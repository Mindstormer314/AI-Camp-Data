package com.thealgorithms.misc;

import java.util.Stack;
import com.thealgorithms.datastructures.lists.SinglyLinkedList;

/**
 * A simple way of knowing if a singly linked list is palindrome is to push all
 * the values into a Stack and then compare the list to popped vales from the
 * Stack.
 *
 * See more:
 * https://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/
 */
public class PalindromeSinglyLinkedList {

    public static void main(String[] args) {
        SinglyLinkedList linkedList = new SinglyLinkedList();

        linkedList.insertHead(3);
        linkedList.insertNth(2, 1);
        linkedList.insertNth(1, 2);
        linkedList.insertNth(2, 3);
        linkedList.insertNth(3, 4);

        if (isPalindrome(linkedList)) {
            System.out.println("It's a palindrome list");
        } else {
            System.out.println("It's NOT a palindrome list");
        }
    }

    public static boolean isPalindrome(SinglyLinkedList linkedList) {
        boolean ret = true;
        Stack<Integer> linkedListValues = new Stack<>();

        for (int i = 0; i < linkedList.size(); i++) {
            linkedListValues.push(linkedList.getNth(i));
        }

        for (int i = 0; i < linkedList.size(); i++) {
            if (linkedList.getNth(i) != linkedListValues.pop()) {
                ret = false;
                break;
            }
        }

        return ret;
    }
}
package com.thealgorithms.misc;

import java.util.*;

/**
 * The array is divided into four sections: a[1..Lo-1] zeroes a[Lo..Mid-1] ones
 * a[Mid..Hi] unknown a[Hi+1..N] twos If array [mid] =0, then swap array [mid]
 * with array [low] and increment both pointers once. If array [mid] = 1, then
 * no swapping is required. Increment mid pointer once. If array [mid] = 2, then
 * we swap array [mid] with array [high] and decrement the high pointer once.
 * For more information on the Dutch national flag algorithm refer
 * https://en.wikipedia.org/wiki/Dutch_national_flag_problem
 */
public class Sort012D {

    public static void main(String args[]) {
        Scanner np = new Scanner(System.in);
        int n = np.nextInt();
        int a[] = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = np.nextInt();
        }
        sort012(a);
    }

    public static void sort012(int[] a) {
        int l = 0;
        int h = a.length - 1;
        int mid = 0;
        int temp;
        while (mid <= h) {
            switch (a[mid]) {
                case 0: {
                    temp = a[l];
                    a[l] = a[mid];
                    a[mid] = temp;
                    l++;
                    mid++;
                    break;
                }
                case 1:
                    mid++;
                    break;
                case 2: {
                    temp = a[mid];
                    a[mid] = a[h];
                    a[h] = temp;
                    h--;
                    break;
                }
            }
        }
        System.out.println("the Sorted array is ");
        for (int i = 0; i < a.length; i++) {
            System.out.print(+a[i] + " ");
        }
    }
}
package com.thealgorithms.misc;

import java.util.Scanner;

public class PalindromePrime {

    public static void main(String[] args) { // Main funtion
        Scanner in = new Scanner(System.in);
        System.out.println("Enter the quantity of First Palindromic Primes you want");
        int n = in.nextInt(); // Input of how many first palindromic prime we want
        functioning(n); // calling function - functioning
        in.close();
    }

    public static boolean prime(int num) { // checking if number is prime or not
        for (int divisor = 3; divisor <= Math.sqrt(num); divisor += 2) {
            if (num % divisor == 0) {
                return false; //  false if not prime
            }
        }
        return true; // True if prime
    }

    public static int reverse(int n) { //  Returns  the reverse of the number
        int reverse = 0;
        while (n != 0) {
            reverse *= 10;
            reverse += n % 10;
            n /= 10;
        }
        return reverse;
    }

    public static void functioning(int y) {
        if (y == 0) {
            return;
        }
        System.out.print(2 + "\n"); // print the first Palindromic Prime
        int count = 1;
        int num = 3;
        while (count < y) {
            if (num == reverse(num) && prime(num)) { // number is prime and it's reverse is same
                count++; // counts check when to terminate while loop
                System.out.print(num + "\n"); // print the Palindromic Prime
            }
            num += 2; // inrease iterator value by two
        }
    }
}
package com.thealgorithms.misc;

import java.util.*;

/*
*A matrix is sparse if many of its coefficients are zero (In general if 2/3rd of matrix elements are 0, it is considered as sparse). 
*The interest in sparsity arises because its exploitation can lead to enormous computational savings and because many large matrix problems that occur in practice are sparse.
*
* @author Ojasva Jain
 */

class Sparcity {

    /*
    * @return Sparcity of matrix
    * 
    * where sparcity = number of zeroes/total elements in matrix
    *
     */
    static double sparcity(double[][] mat) {
        int zero = 0;
        //Traversing the matrix to count number of zeroes 
        for (int i = 0; i < mat.length; i++) {
            for (int j = 0; j < mat[i].length; j++) {
                if (mat[i][j] == 0) {
                    zero++;
                }
            }
        }
        //return sparcity
        return ((double) zero / (mat.length * mat[1].length));
    }

    //Driver method
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("Enter number of rows in matrix: ");
        int n = in.nextInt();
        System.out.println("Enter number of Columns in matrix: ");
        int m = in.nextInt();

        System.out.println("Enter Matrix elements: ");
        double[][] mat = new double[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                mat[i][j] = in.nextDouble();
            }
        }
        System.out.println("Sparcity of matrix is: " + sparcity(mat));
    }
}
package com.thealgorithms.misc;

import java.util.*;

public class RangeInSortedArray {

    public static void main(String[] args) {
        // Testcases
        assert Arrays.equals(sortedRange(new int[]{1, 2, 3, 3, 3, 4, 5}, 3), new int[]{2, 4});
        assert Arrays.equals(sortedRange(new int[]{1, 2, 3, 3, 3, 4, 5}, 4), new int[]{5, 5});
        assert Arrays.equals(sortedRange(new int[]{0, 1, 2}, 3), new int[]{-1, -1});
    }

    // Get the 1st and last occurrence index of a number 'key' in a non-decreasing array 'nums'
    // Gives [-1, -1] in case element doesn't exist in array
    public static int[] sortedRange(int[] nums, int key) {
        int[] range = new int[]{-1, -1};
        alteredBinSearchIter(nums, key, 0, nums.length - 1, range, true);
        alteredBinSearchIter(nums, key, 0, nums.length - 1, range, false);
        return range;
    }

    // Recursive altered binary search which searches for leftmost as well as rightmost occurrence of
    // 'key'
    public static void alteredBinSearch(
            int[] nums, int key, int left, int right, int[] range, boolean goLeft) {
        if (left > right) {
            return;
        }
        int mid = (left + right) / 2;
        if (nums[mid] > key) {
            alteredBinSearch(nums, key, left, mid - 1, range, goLeft);
        } else if (nums[mid] < key) {
            alteredBinSearch(nums, key, mid + 1, right, range, goLeft);
        } else {
            if (goLeft) {
                if (mid == 0 || nums[mid - 1] != key) {
                    range[0] = mid;
                } else {
                    alteredBinSearch(nums, key, left, mid - 1, range, goLeft);
                }
            } else {
                if (mid == nums.length - 1 || nums[mid + 1] != key) {
                    range[1] = mid;
                } else {
                    alteredBinSearch(nums, key, mid + 1, right, range, goLeft);
                }
            }
        }
    }

    // Iterative altered binary search which searches for leftmost as well as rightmost occurrence of
    // 'key'
    public static void alteredBinSearchIter(
            int[] nums, int key, int left, int right, int[] range, boolean goLeft) {
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > key) {
                right = mid - 1;
            } else if (nums[mid] < key) {
                left = mid + 1;
            } else {
                if (goLeft) {
                    if (mid == 0 || nums[mid - 1] != key) {
                        range[0] = mid;
                        return;
                    } else {
                        right = mid - 1;
                    }
                } else {
                    if (mid == nums.length - 1 || nums[mid + 1] != key) {
                        range[1] = mid;
                        return;
                    } else {
                        left = mid + 1;
                    }
                }
            }
        }
    }

    public static int getCountLessThan(int[] nums, int key) {
        return getLessThan(nums, key, 0, nums.length - 1);
    }

    public static int getLessThan(int[] nums, int key, int left, int right) {
        int count = 0;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > key) {
                right = mid - 1;
            } else if (nums[mid] <= key) {
                count = mid + 1; // At least mid+1 elements exist which are <= key
                left = mid + 1;
            }
        }
        return count;
    }
}
package com.thealgorithms.misc;

import java.util.Scanner;

/*
* Wikipedia link : https://en.wikipedia.org/wiki/Invertible_matrix
*
* Here we use gauss elimination method to find the inverse of a given matrix.
* To understand gauss elimination method to find inverse of a matrix: https://www.sangakoo.com/en/unit/inverse-matrix-method-of-gaussian-elimination
*
* We can also find the inverse of a matrix 
 */
public class InverseOfMatrix {

    public static void main(String argv[]) {
        Scanner input = new Scanner(System.in);
        System.out.println("Enter the matrix size (Square matrix only): ");
        int n = input.nextInt();
        double a[][] = new double[n][n];
        System.out.println("Enter the elements of matrix: ");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = input.nextDouble();
            }
        }

        double d[][] = invert(a);
        System.out.println();
        System.out.println("The inverse is: ");
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                System.out.print(d[i][j] + "  ");
            }
            System.out.println();
        }
        input.close();
    }

    public static double[][] invert(double a[][]) {
        int n = a.length;
        double x[][] = new double[n][n];
        double b[][] = new double[n][n];
        int index[] = new int[n];
        for (int i = 0; i < n; ++i) {
            b[i][i] = 1;
        }

        // Transform the matrix into an upper triangle
        gaussian(a, index);

        // Update the matrix b[i][j] with the ratios stored
        for (int i = 0; i < n - 1; ++i) {
            for (int j = i + 1; j < n; ++j) {
                for (int k = 0; k < n; ++k) {
                    b[index[j]][k]
                            -= a[index[j]][i] * b[index[i]][k];
                }
            }
        }

        // Perform backward substitutions
        for (int i = 0; i < n; ++i) {
            x[n - 1][i] = b[index[n - 1]][i] / a[index[n - 1]][n - 1];
            for (int j = n - 2; j >= 0; --j) {
                x[j][i] = b[index[j]][i];
                for (int k = j + 1; k < n; ++k) {
                    x[j][i] -= a[index[j]][k] * x[k][i];
                }
                x[j][i] /= a[index[j]][j];
            }
        }
        return x;
    }

// Method to carry out the partial-pivoting Gaussian
// elimination.  Here index[] stores pivoting order.
    public static void gaussian(double a[][], int index[]) {
        int n = index.length;
        double c[] = new double[n];

        // Initialize the index
        for (int i = 0; i < n; ++i) {
            index[i] = i;
        }

        // Find the rescaling factors, one from each row
        for (int i = 0; i < n; ++i) {
            double c1 = 0;
            for (int j = 0; j < n; ++j) {
                double c0 = Math.abs(a[i][j]);
                if (c0 > c1) {
                    c1 = c0;
                }
            }
            c[i] = c1;
        }

        // Search the pivoting element from each column
        int k = 0;
        for (int j = 0; j < n - 1; ++j) {
            double pi1 = 0;
            for (int i = j; i < n; ++i) {
                double pi0 = Math.abs(a[index[i]][j]);
                pi0 /= c[index[i]];
                if (pi0 > pi1) {
                    pi1 = pi0;
                    k = i;
                }
            }
            // Interchange rows according to the pivoting order
            int itmp = index[j];
            index[j] = index[k];
            index[k] = itmp;
            for (int i = j + 1; i < n; ++i) {
                double pj = a[index[i]][j] / a[index[j]][j];

                // Record pivoting ratios below the diagonal
                a[index[i]][j] = pj;

                // Modify other elements accordingly
                for (int l = j + 1; l < n; ++l) {
                    a[index[i]][l] -= pj * a[index[j]][l];
                }
            }
        }
    }
}
package com.thealgorithms.misc;

import java.util.*;
import java.util.stream.Collectors;

public class TwoSumProblem {

    public static void main(String args[]) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter the target sum ");
        int ts = scan.nextInt();
        System.out.print("Enter the number of elements in the array ");
        int n = scan.nextInt();
        System.out.println("Enter all your array elements:");
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }
        TwoSumProblem t = new TwoSumProblem();
        System.out.println("Brute Force Approach\n" + Arrays.toString(t.BruteForce(arr, ts)) + "\n");
        System.out.println("Two Pointer Approach\n" + Arrays.toString(t.TwoPointer(arr, ts)) + "\n");
        System.out.println("Hashmap Approach\n" + Arrays.toString(t.HashMap(arr, ts)));

    }

    public int[] BruteForce(int[] nums, int target) {
        //Brute Force Approach 
        int ans[] = new int[2];
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    ans[0] = i;
                    ans[1] = j;

                    break;
                }

            }
        }

        return ans;
    }

    public int[] TwoPointer(int[] nums, int target) {
        // HashMap Approach
        int ans[] = new int[2];
        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
            hm.put(i, nums[i]);
        }
        HashMap<Integer, Integer> temp
                = hm.entrySet()
                        .stream()
                        .sorted((i1, i2)
                                -> i1.getValue().compareTo(
                                i2.getValue()))
                        .collect(Collectors.toMap(
                                Map.Entry::getKey,
                                Map.Entry::getValue,
                                (e1, e2) -> e1, LinkedHashMap::new));

        int start = 0;
        int end = nums.length - 1;
        while (start < end) {
            int currSum = (Integer) temp.values().toArray()[start] + (Integer) temp.values().toArray()[end];

            if (currSum == target) {
                ans[0] = (Integer) temp.keySet().toArray()[start];
                ans[1] = (Integer) temp.keySet().toArray()[end];
                break;
            } else if (currSum > target) {
                end -= 1;
            } else if (currSum < target) {
                start += 1;
            }

        }
        return ans;

    }

    public int[] HashMap(int[] nums, int target) {
        //Using Hashmaps
        int ans[] = new int[2];
        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
            hm.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int t = target - nums[i];
            if (hm.containsKey(t) && hm.get(t) != i) {
                ans[0] = i;
                ans[1] = hm.get(t);
                break;
            }
        }

        return ans;
    }

}
package com.thealgorithms.misc;

import java.util.Scanner;

/**
 *
 *
 * <h1>Find the Transpose of Matrix!</h1>
 *
 * Simply take input from the user and print the matrix before the transpose and
 * after the transpose.
 *
 * <p>
 * <b>Note:</b> Giving proper comments in your program makes it more user
 * friendly and it is assumed as a high quality code.
 *
 * @author Rajat-Jain29
 * @version 11.0.9
 * @since 2014-03-31
 */
public class matrixTranspose {

    public static void main(String[] args) {
        /*
     * This is the main method
     *
     * @param args Unused.
     *
     * @return Nothing.
         */
        Scanner sc = new Scanner(System.in);
        int i, j, row, column;
        System.out.println("Enter the number of rows in the 2D matrix:");

        /*
     * Take input from user for how many rows to be print
         */
        row = sc.nextInt();

        System.out.println("Enter the number of columns in the 2D matrix:");

        /*
     * Take input from user for how many coloumn to be print
         */
        column = sc.nextInt();
        int[][] arr = new int[row][column];
        System.out.println("Enter the elements");
        for (i = 0; i < row; i++) {
            for (j = 0; j < column; j++) {
                arr[i][j] = sc.nextInt();
            }
        }

        /*
     * Print matrix before the Transpose in proper way
         */
        System.out.println("The matrix is:");
        for (i = 0; i < row; i++) {
            for (j = 0; j < column; j++) {
                System.out.print(arr[i][j] + "\t");
            }
            System.out.print("\n");
        }

        /*
     * Print matrix after the tranpose in proper way Transpose means Interchanging
     * of rows wth column so we interchange the rows in next loop Thus at last
     * matrix of transpose is obtained through user input...
         */
        System.out.println("The Transpose of the given matrix is:");
        for (i = 0; i < column; i++) {
            for (j = 0; j < row; j++) {
                System.out.print(arr[j][i] + "\t");
            }
            System.out.print("\n");
        }
    }
}
package com.thealgorithms.misc;

import java.awt.Color;

/**
 * @brief A Java implementation of the offcial W3 documented procedure to
 * calculate contrast ratio between colors on the web. This is used to calculate
 * the readability of a foreground color on top of a background color.
 * @since 2020-10-15
 * @see [Color Contrast
 * Ratio](https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-procedure)
 * @author [Seth Falco](https://github.com/SethFalco)
 */
public class ColorContrastRatio {

    /**
     * @brief Calculates the contrast ratio between two given colors.
     * @param a Any color, used to get the red, green, and blue values.
     * @param b Another color, which will be compared against the first color.
     * @return The contrast ratio between the two colors.
     */
    public double getContrastRatio(Color a, Color b) {
        final double aColorLuminance = getRelativeLuminance(a);
        final double bColorLuminance = getRelativeLuminance(b);

        if (aColorLuminance > bColorLuminance) {
            return (aColorLuminance + 0.05) / (bColorLuminance + 0.05);
        }

        return (bColorLuminance + 0.05) / (aColorLuminance + 0.05);
    }

    /**
     * @brief Calculates the relative luminance of a given color.
     * @param color Any color, used to get the red, green, and blue values.
     * @return The relative luminance of the color.
     * @see [More info on relative
     * luminance.](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef)
     */
    public double getRelativeLuminance(Color color) {
        final double red = getColor(color.getRed());
        final double green = getColor(color.getGreen());
        final double blue = getColor(color.getBlue());

        return 0.2126 * red + 0.7152 * green + 0.0722 * blue;
    }

    /**
     * @brief Calculates the final value for a color to be used in the relative
     * luminance formula as described in step 1.
     * @param color8Bit 8-bit representation of a color component value.
     * @return Value for the provided color component to be used in the relative
     * luminance formula.
     */
    public double getColor(int color8Bit) {
        final double sRgb = getColorSRgb(color8Bit);
        return (sRgb <= 0.03928) ? sRgb / 12.92 : Math.pow((sRgb + 0.055) / 1.055, 2.4);
    }

    /**
     * @brief Calculates the Color sRGB value as denoted in step 1 of the
     * procedure document.
     * @param color8Bit 8-bit representation of a color component value.
     * @return A percentile value of the color component.
     */
    private double getColorSRgb(double color8Bit) {
        return color8Bit / 255.0;
    }

    /**
     * You can check this example against another open-source implementation
     * available on GitHub.
     *
     * @see [Online Contrast
     * Ratio](https://contrast-ratio.com/#rgb%28226%2C%20229%2C%20248-on-rgb%2823%2C%20103%2C%20154%29)
     * @see [GitHub Repository for Online Contrast
     * Ratio](https://github.com/LeaVerou/contrast-ratio)
     */
    private static void test() {
        final ColorContrastRatio algImpl = new ColorContrastRatio();

        final Color black = Color.BLACK;
        final double blackLuminance = algImpl.getRelativeLuminance(black);
        assert blackLuminance == 0 : "Test 1 Failed - Incorrect relative luminance.";

        final Color white = Color.WHITE;
        final double whiteLuminance = algImpl.getRelativeLuminance(white);
        assert whiteLuminance == 1 : "Test 2 Failed - Incorrect relative luminance.";

        final double highestColorRatio = algImpl.getContrastRatio(black, white);
        assert highestColorRatio == 21 : "Test 3 Failed - Incorrect contrast ratio.";

        final Color foreground = new Color(23, 103, 154);
        final double foregroundLuminance = algImpl.getRelativeLuminance(foreground);
        assert foregroundLuminance == 0.12215748057375966 : "Test 4 Failed - Incorrect relative luminance.";

        final Color background = new Color(226, 229, 248);
        final double backgroundLuminance = algImpl.getRelativeLuminance(background);
        assert backgroundLuminance == 0.7898468477881603 : "Test 5 Failed - Incorrect relative luminance.";

        final double contrastRatio = algImpl.getContrastRatio(foreground, background);
        assert contrastRatio == 4.878363954846178 : "Test 6 Failed - Incorrect contrast ratio.";
    }

    public static void main(String args[]) {
        test();
    }
}
package com.thealgorithms.misc;

import java.util.Collections;
import java.util.PriorityQueue;

/**
 * @author shrutisheoran
 */
public class MedianOfRunningArray {

    private PriorityQueue<Integer> p1;
    private PriorityQueue<Integer> p2;

    // Constructor
    public MedianOfRunningArray() {
        this.p1 = new PriorityQueue<>(Collections.reverseOrder()); // Max Heap
        this.p2 = new PriorityQueue<>(); // Min Heap
    }

    /*
      Inserting lower half of array to max Heap
      and upper half to min heap
     */
    public void insert(Integer e) {
        p2.add(e);
        if (p2.size() - p1.size() > 1) {
            p1.add(p2.remove());
        }
    }

    /*
      Returns median at any given point
     */
    public Integer median() {
        if (p1.size() == p2.size()) {
            return (p1.peek() + p2.peek()) / 2;
        }
        return p1.size() > p2.size() ? p1.peek() : p2.peek();
    }

    public static void main(String[] args) {
        /*
        Testing the median function
         */

        MedianOfRunningArray p = new MedianOfRunningArray();
        int arr[] = {10, 7, 4, 9, 2, 3, 11, 17, 14};
        for (int i = 0; i < 9; i++) {
            p.insert(arr[i]);
            System.out.print(p.median() + " ");
        }
    }
}
package com.thealgorithms.misc;

import java.util.*;

public class WordBoggle {

    /**
     * O(nm * 8^s + ws) time where n = width of boggle board, m = height of
     * boggle board, s = length of longest word in string array, w = length of
     * string array, 8 is due to 8 explorable neighbours O(nm + ws) space.
     */
    public static List<String> boggleBoard(char[][] board, String[] words) {
        Trie trie = new Trie();
        for (String word : words) {
            trie.add(word);
        }
        Set<String> finalWords = new HashSet<>();
        boolean[][] visited = new boolean[board.length][board.length];
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                explore(i, j, board, trie.root, visited, finalWords);
            }
        }
        return new ArrayList<>(finalWords);
    }

    public static void main(String[] args) {
        // Testcase
        List<String> ans
                = new ArrayList<>(
                        Arrays.asList("a", "boggle", "this", "NOTRE_PEATED", "is", "simple", "board"));
        assert (boggleBoard(
                new char[][]{
                    {'t', 'h', 'i', 's', 'i', 's', 'a'},
                    {'s', 'i', 'm', 'p', 'l', 'e', 'x'},
                    {'b', 'x', 'x', 'x', 'x', 'e', 'b'},
                    {'x', 'o', 'g', 'g', 'l', 'x', 'o'},
                    {'x', 'x', 'x', 'D', 'T', 'r', 'a'},
                    {'R', 'E', 'P', 'E', 'A', 'd', 'x'},
                    {'x', 'x', 'x', 'x', 'x', 'x', 'x'},
                    {'N', 'O', 'T', 'R', 'E', '_', 'P'},
                    {'x', 'x', 'D', 'E', 'T', 'A', 'E'},},
                new String[]{
                    "this",
                    "is",
                    "not",
                    "a",
                    "simple",
                    "test",
                    "boggle",
                    "board",
                    "REPEATED",
                    "NOTRE_PEATED",})
                .equals(ans));
    }

    public static void explore(
            int i,
            int j,
            char[][] board,
            TrieNode trieNode,
            boolean[][] visited,
            Set<String> finalWords) {
        if (visited[i][j]) {
            return;
        }

        char letter = board[i][j];
        if (!trieNode.children.containsKey(letter)) {
            return;
        }
        visited[i][j] = true;
        trieNode = trieNode.children.get(letter);
        if (trieNode.children.containsKey('*')) {
            finalWords.add(trieNode.word);
        }

        List<Integer[]> neighbors = getNeighbors(i, j, board);
        for (Integer[] neighbor : neighbors) {
            explore(neighbor[0], neighbor[1], board, trieNode, visited, finalWords);
        }

        visited[i][j] = false;
    }

    public static List<Integer[]> getNeighbors(int i, int j, char[][] board) {
        List<Integer[]> neighbors = new ArrayList<>();
        if (i > 0 && j > 0) {
            neighbors.add(new Integer[]{i - 1, j - 1});
        }

        if (i > 0 && j < board[0].length - 1) {
            neighbors.add(new Integer[]{i - 1, j + 1});
        }

        if (i < board.length - 1 && j < board[0].length - 1) {
            neighbors.add(new Integer[]{i + 1, j + 1});
        }

        if (i < board.length - 1 && j > 0) {
            neighbors.add(new Integer[]{i + 1, j - 1});
        }

        if (i > 0) {
            neighbors.add(new Integer[]{i - 1, j});
        }

        if (i < board.length - 1) {
            neighbors.add(new Integer[]{i + 1, j});
        }

        if (j > 0) {
            neighbors.add(new Integer[]{i, j - 1});
        }

        if (j < board[0].length - 1) {
            neighbors.add(new Integer[]{i, j + 1});
        }

        return neighbors;
    }
}

// Trie used to optimize string search
class TrieNode {

    Map<Character, TrieNode> children = new HashMap<>();
    String word = "";
}

class Trie {

    TrieNode root;
    char endSymbol;

    public Trie() {
        this.root = new TrieNode();
        this.endSymbol = '*';
    }

    public void add(String str) {
        TrieNode node = this.root;
        for (int i = 0; i < str.length(); i++) {
            char letter = str.charAt(i);
            if (!node.children.containsKey(letter)) {
                TrieNode newNode = new TrieNode();
                node.children.put(letter, newNode);
            }
            node = node.children.get(letter);
        }
        node.children.put(this.endSymbol, null);
        node.word = str;
    }
}
package com.thealgorithms.misc;

import java.util.*;

public class ThreeSumProblem {

    public static void main(String args[]) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter the target sum ");
        int ts = scan.nextInt();
        System.out.print("Enter the number of elements in the array ");
        int n = scan.nextInt();
        System.out.println("Enter all your array elements:");
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }
        ThreeSumProblem th = new ThreeSumProblem();
        System.out.println("Brute Force Approach\n" + (th.BruteForce(arr, ts)) + "\n");
        System.out.println("Two Pointer Approach\n" + (th.TwoPointer(arr, ts)) + "\n");
        System.out.println("Hashmap Approach\n" + (th.Hashmap(arr, ts)));

    }

    public List<List<Integer>> BruteForce(int[] nums, int target) {
        List<List<Integer>> arr = new ArrayList<List<Integer>>();

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                for (int k = j + 1; k < nums.length; k++) {
                    if (nums[i] + nums[j] + nums[k] == target) {
                        List<Integer> temp = new ArrayList<>();
                        temp.add(nums[i]);
                        temp.add(nums[j]);
                        temp.add(nums[k]);
                        Collections.sort(temp);
                        arr.add(temp);
                    }

                }
            }
        }
        arr = new ArrayList<List<Integer>>(new LinkedHashSet<List<Integer>>(arr));
        return arr;
    }

    public List<List<Integer>> TwoPointer(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> arr = new ArrayList<List<Integer>>();
        int start = 0;
        int end = 0;
        int i = 0;
        while (i < nums.length - 1) {
            start = i + 1;
            end = nums.length - 1;
            while (start < end) {
                if (nums[start] + nums[end] + nums[i] == target) {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums[i]);
                    temp.add(nums[start]);
                    temp.add(nums[end]);
                    arr.add(temp);
                    start++;
                    end--;
                } else if (nums[start] + nums[end] + nums[i] < target) {
                    start += 1;
                } else {
                    end -= 1;
                }

            }
            i++;
        }
        Set<List<Integer>> set = new LinkedHashSet<List<Integer>>(arr);
        return new ArrayList<List<Integer>>(set);
    }

    public List<List<Integer>> Hashmap(int[] nums, int target) {
        Arrays.sort(nums);
        Set<List<Integer>> ts = new HashSet();
        HashMap<Integer, Integer> hm = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            hm.put(nums[i], i);
        }

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                int t = target - nums[i] - nums[j];
                if (hm.containsKey(t) && hm.get(t) > j) {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums[i]);
                    temp.add(nums[j]);
                    temp.add(t);
                    ts.add(temp);
                }
            }
        }
        return new ArrayList(ts);
    }

}
package com.thealgorithms.searches;

import java.util.Scanner;

public class LinearSearchThread {
    public static void main(String[] args) {
        int[] list = new int[200];
        for (int j = 0; j < list.length; j++) {
            list[j] = (int) (Math.random() * 100);
        }
        for (int y : list) {
            System.out.print(y + " ");
        }
        System.out.println();
        System.out.print("Enter number to search for: ");
        Scanner in = new Scanner(System.in);
        int x = in.nextInt();
        Searcher t = new Searcher(list, 0, 50, x);
        Searcher t1 = new Searcher(list, 50, 100, x);
        Searcher t2 = new Searcher(list, 100, 150, x);
        Searcher t3 = new Searcher(list, 150, 200, x);
        t.start();
        t1.start();
        t2.start();
        t3.start();
        try {
            t.join();
            t1.join();
            t2.join();
            t3.join();
        } catch (InterruptedException e) {
        }
        boolean found = t.getResult() || t1.getResult() || t2.getResult() || t3.getResult();
        System.out.println("Found = " + found);
    }
}

class Searcher extends Thread {
    private final int[] arr;
    private final int left, right;
    private final int x;
    private boolean found;

    Searcher(int[] arr, int left, int right, int x) {
        this.arr = arr;
        this.left = left;
        this.right = right;
        this.x = x;
    }

    @Override
    public void run() {
        int k = left;
        found = false;
        while (k < right && !found) {
            if (arr[k++] == x) {
                found = true;
            }
        }
    }

    boolean getResult() {
        return found;
    }
}
package com.thealgorithms.searches;

import java.util.*;

public class UnionFind {

    private int[] p;
    private int[] r;

    public UnionFind(int n) {
        p = new int[n];
        r = new int[n];

        for (int i = 0; i < n; i++) {
            p[i] = i;
        }
    }

    public int find(int i) {
        int parent = p[i];

        if (i == parent) {
            return i;
        }

        return p[i] = find(parent);
    }

    public void union(int x, int y) {
        int r0 = find(x);
        int r1 = find(y);

        if (r1 == r0) {
            return;
        }

        if (r[r0] > r[r1]) {
            p[r1] = r0;
        } else if (r[r1] > r[r0]) {
            p[r0] = r1;
        } else {
            p[r1] = r0;
            r[r0]++;
        }
    }

    public int count() {
        List parents = new ArrayList();
        for (int i = 0; i < p.length; i++) {
            if (!parents.contains(find(i))) {
                parents.add(find(i));
            }
        }
        return parents.size();
    }

    public String toString() {
        return "p " + Arrays.toString(p) + " r " + Arrays.toString(r) + "\n";
    }

    // Tests
    public static void main(String[] args) {
        UnionFind uf = new UnionFind(5);
        System.out.println("init /w 5 (should print 'p [0, 1, 2, 3, 4] r [0, 0, 0, 0, 0]'):");
        System.out.println(uf);

        uf.union(1, 2);
        System.out.println("union 1 2 (should print 'p [0, 1, 1, 3, 4] r [0, 1, 0, 0, 0]'):");
        System.out.println(uf);

        uf.union(3, 4);
        System.out.println("union 3 4 (should print 'p [0, 1, 1, 3, 3] r [0, 1, 0, 1, 0]'):");
        System.out.println(uf);

        uf.find(4);
        System.out.println("find 4 (should print 'p [0, 1, 1, 3, 3] r [0, 1, 0, 1, 0]'):");
        System.out.println(uf);

        System.out.println("count (should print '3'):");
        System.out.println(uf.count());
    }
}
package com.thealgorithms.searches;

import java.util.Scanner;

/**
 * Given an integer x, find the square root of x. If x is not a perfect square,
 * then return floor(√x).
 * <p>
 * For example, if x = 5, The answer should be 2 which is the floor value of √5.
 * <p>
 * The approach that will be used for solving the above problem is not going to
 * be a straight forward Math.sqrt(). Instead we will be using Binary Search to
 * find the square root of a number in the most optimised way.
 *
 * @author sahil
 */
public class SquareRootBinarySearch {

    /**
     * This is the driver method.
     *
     * @param args Command line arguments
     */
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a number you want to calculate square root of : ");
        int num = sc.nextInt();
        long ans = squareRoot(num);
        System.out.println("The square root is : " + ans);
    }

    /**
     * This function calculates the floor of square root of a number. We use
     * Binary Search algorithm to calculate the square root in a more optimised
     * way.
     *
     * @param num Number
     * @return answer
     */
    private static long squareRoot(long num) {
        if (num == 0 || num == 1) {
            return num;
        }
        long l = 1;
        long r = num;
        long ans = 0;
        while (l <= r) {
            long mid = l + (r - l) / 2;
            if (mid == num / mid) {
                return mid;
            } else if (mid < num / mid) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Arrays;
import java.util.Random;
import java.util.stream.Stream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;

/**
 * Binary search is one of the most popular algorithms This class represents
 * iterative version {@link BinarySearch} Iterative binary search is likely to
 * have lower constant factors because it doesn't involve the overhead of
 * manipulating the call stack. But in java the recursive version can be
 * optimized by the compiler to this version.
 *
 * <p>
 * Worst-case performance O(log n) Best-case performance O(1) Average
 * performance O(log n) Worst-case space complexity O(1)
 *
 * @author Gabriele La Greca : https://github.com/thegabriele97
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 * @see SearchAlgorithm
 * @see BinarySearch
 */
public final class IterativeBinarySearch implements SearchAlgorithm {

    /**
     * This method implements an iterative version of binary search algorithm
     *
     * @param array a sorted array
     * @param key the key to search in array
     * @return the index of key in the array or -1 if not found
     */
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        int l, r, k, cmp;

        l = 0;
        r = array.length - 1;

        while (l <= r) {
            k = (l + r) >>> 1;
            cmp = key.compareTo(array[k]);

            if (cmp == 0) {
                return k;
            } else if (cmp < 0) {
                r = --k;
            } else {
                l = ++k;
            }
        }

        return -1;
    }

    // Only a main method for test purpose
    public static void main(String[] args) {
        Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        Integer[] integers
                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);

        // the element that should be found
        Integer shouldBeFound = integers[r.nextInt(size - 1)];

        IterativeBinarySearch search = new IterativeBinarySearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                String.format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));
    }
}
package com.thealgorithms.searches;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * @author: caos321
 * @date: 31 October 2021 (Sunday)
 */
public class DepthFirstSearch {

    static class Node {

        private final String name;
        private final List<Node> subNodes;

        public Node(final String name) {
            this.name = name;
            this.subNodes = new ArrayList<>();
        }

        public Node(final String name, final List<Node> subNodes) {
            this.name = name;
            this.subNodes = subNodes;
        }

        public String getName() {
            return name;
        }

        public List<Node> getSubNodes() {
            return subNodes;
        }
    }

    public static Optional<Node> search(final Node node, final String name) {
        if (node.getName().equals(name)) {
            return Optional.of(node);
        }

        return node.getSubNodes()
                .stream()
                .map(value -> search(value, name))
                .flatMap(Optional::stream)
                .findAny();
    }

    public static void assertThat(final Object actual, final Object expected) {
        if (!Objects.equals(actual, expected)) {
            throw new AssertionError(String.format("expected=%s but was actual=%s", expected, actual));
        }
    }

    public static void main(final String[] args) {
        final Node rootNode = new Node("A", List.of(
                new Node("B", List.of(new Node("D"), new Node("F", List.of(
                        new Node("H"), new Node("I")
                )))),
                new Node("C", List.of(new Node("G"))),
                new Node("E")
        ));

        {
            final String expected = "I";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }

        {
            final String expected = "G";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }

        {
            final String expected = "E";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }
    }
}
package com.thealgorithms.searches;

import java.util.Random;
import java.util.stream.Stream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;

/**
 * Linear search is the easiest search algorithm It works with sorted and
 * unsorted arrays (an binary search works only with sorted array) This
 * algorithm just compares all elements of an array to find a value
 *
 * <p>
 * Worst-case performance O(n) Best-case performance O(1) Average performance
 * O(n) Worst-case space complexity
 *
 * @author Varun Upadhyay (https://github.com/varunu28)
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 * @see BinarySearch
 * @see SearchAlgorithm
 */
public class LinearSearch implements SearchAlgorithm {

    /**
     * Generic Linear search method
     *
     * @param array List to be searched
     * @param value Key being searched for
     * @return Location of the key
     */
    @Override
    public <T extends Comparable<T>> int find(T[] array, T value) {
        for (int i = 0; i < array.length; i++) {
            if (array[i].compareTo(value) == 0) {
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        // just generate data
        Random r = new Random();
        int size = 200;
        int maxElement = 100;
        Integer[] integers
                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).toArray(Integer[]::new);

        // the element that should be found
        Integer shouldBeFound = integers[r.nextInt(size - 1)];

        LinearSearch search = new LinearSearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                String.format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;

/**
 * The UpperBound method is used to return an index pointing to the first
 * element in the range [first, last) which has a value greater than val, or the
 * last index if no such element exists i.e. the index of the next smallest
 * number just greater than that number. If there are multiple values that are
 * equal to val it returns the index of the first such value.
 *
 * <p>
 * This is an extension of BinarySearch.
 *
 * <p>
 * Worst-case performance O(log n) Best-case performance O(1) Average
 * performance O(log n) Worst-case space complexity O(1)
 *
 * @author Pratik Padalia (https://github.com/15pratik)
 * @see SearchAlgorithm
 * @see BinarySearch
 */
class UpperBound implements SearchAlgorithm {

    // Driver Program
    public static void main(String[] args) {
        // Just generate data
        Random r = ThreadLocalRandom.current();

        int size = 100;
        int maxElement = 100000;

        Integer[] integers
                = IntStream.generate(() -> r.nextInt(maxElement))
                        .limit(size)
                        .sorted()
                        .boxed()
                        .toArray(Integer[]::new);

        // The element for which the upper bound is to be found
        int val = integers[r.nextInt(size - 1)] + 1;

        UpperBound search = new UpperBound();
        int atIndex = search.find(integers, val);

        System.out.println(
                format(
                        "Val: %d. Upper Bound Found %d at index %d. An array length %d",
                        val, integers[atIndex], atIndex, size));

        boolean toCheck = integers[atIndex] > val || integers[size - 1] < val;
        System.out.println(
                format(
                        "Upper Bound found at an index: %d. Is greater or max element: %b", atIndex, toCheck));
    }

    /**
     * @param array is an array where the UpperBound value is to be found
     * @param key is an element for which the UpperBound is to be found
     * @param <T> is any comparable type
     * @return index of the UpperBound element
     */
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        return search(array, key, 0, array.length - 1);
    }

    /**
     * This method implements the Generic Binary Search
     *
     * @param array The array to make the binary search
     * @param key The number you are looking for
     * @param left The lower bound
     * @param right The upper bound
     * @return the location of the key
     */
    private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) {
        if (right <= left) {
            return left;
        }

        // find median
        int median = (left + right) >>> 1;
        int comp = key.compareTo(array[median]);

        if (comp < 0) {
            // key is smaller, median position can be a possible solution
            return search(array, key, left, median);
        } else {
            // key we are looking is greater, so we must look on the right of median position
            return search(array, key, median + 1, right);
        }
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Arrays;
import java.util.Random;
import java.util.stream.Stream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;

/**
 * A iterative version of a ternary search algorithm This is better way to
 * implement the ternary search, because a recursive version adds some overhead
 * to a stack. But in java the compile can transform the recursive version to
 * iterative implicitly, so there are no much differences between these two
 * algorithms
 *
 * <p>
 * Worst-case performance Θ(log3(N)) Best-case performance O(1) Average
 * performance Θ(log3(N)) Worst-case space complexity O(1)
 *
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 * @see SearchAlgorithm
 * @see TernarySearch
 * @since 2018-04-13
 */
public class IterativeTernarySearch implements SearchAlgorithm {

    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        int left = 0;
        int right = array.length - 1;

        while (right > left) {

            int leftCmp = array[left].compareTo(key);
            int rightCmp = array[right].compareTo(key);
            if (leftCmp == 0) {
                return left;
            }
            if (rightCmp == 0) {
                return right;
            }

            int leftThird = left + (right - left) / 3 + 1;
            int rightThird = right - (right - left) / 3 - 1;

            if (array[leftThird].compareTo(key) <= 0) {
                left = leftThird;
            } else {
                right = rightThird;
            }
        }

        return -1;
    }

    public static void main(String[] args) {
        // just generate data
        Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        Integer[] integers
                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);

        // the element that should be found
        Integer shouldBeFound = integers[r.nextInt(size - 1)];

        IterativeTernarySearch search = new IterativeTernarySearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));
    }
}
package com.thealgorithms.searches;

import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;

import static java.lang.String.format;

class ExponentialSearch implements SearchAlgorithm {

    public static void main(String[] args) {
        Random r = ThreadLocalRandom.current();

        int size = 100;
        int maxElement = 100000;

        Integer[] integers
                = IntStream.generate(() -> r.nextInt(maxElement))
                        .limit(size)
                        .sorted()
                        .boxed()
                        .toArray(Integer[]::new);

        // The element that should be found
        int shouldBeFound = integers[r.nextInt(size - 1)];

        ExponentialSearch search = new ExponentialSearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));

    }

    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        if (array[0] == key) {
            return 0;
        }
        if (array[array.length - 1] == key) {
            return array.length;
        }

        int range = 1;

        while (range < array.length && array[range].compareTo(key) <= -1) {
            range = range * 2;
        }

        return Arrays.binarySearch(array, range / 2, Math.min(range, array.length), key);
    }
}
package com.thealgorithms.searches;

import com.thealgorithms.searches.DepthFirstSearch.Node;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * @author: caos321
 * @date: 31 October 2021 (Sunday)
 */
public class BreadthFirstSearch {

    public static Optional<Node> search(final Node node, final String name) {
        if (node.getName().equals(name)) {
            return Optional.of(node);
        }

        List<Node> queue = new ArrayList<>(node.getSubNodes());

        while (!queue.isEmpty()) {
            final Node current = queue.get(0);

            if (current.getName().equals(name)) {
                return Optional.of(current);
            }

            queue.addAll(current.getSubNodes());

            queue.remove(0);
        }

        return Optional.empty();
    }

    public static void assertThat(final Object actual, final Object expected) {
        if (!Objects.equals(actual, expected)) {
            throw new AssertionError(String.format("expected=%s but was actual=%s", expected, actual));
        }
    }

    public static void main(final String[] args) {
        final Node rootNode = new Node("A", List.of(
                new Node("B", List.of(new Node("D"), new Node("F", List.of(
                        new Node("H"), new Node("I")
                )))),
                new Node("C", List.of(new Node("G"))),
                new Node("E")
        ));

        {
            final String expected = "I";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }

        {
            final String expected = "G";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }

        {
            final String expected = "E";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Arrays;
import java.util.Random;
import java.util.stream.IntStream;

/**
 * Interpolation search algorithm implementation
 *
 * <p>
 * Worst-case performance O(n) Best-case performance O(1) Average performance
 * O(log(log(n))) if the elements are uniformly distributed if not O(n)
 * Worst-case space complexity O(1)
 *
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 */
class InterpolationSearch {

    /**
     * @param array is a sorted array
     * @param key is a value what shoulb be found in the array
     * @return an index if the array contains the key unless -1
     */
    public int find(int array[], int key) {
        // Find indexes of two corners
        int start = 0, end = (array.length - 1);

        // Since array is sorted, an element present
        // in array must be in range defined by corner
        while (start <= end && key >= array[start] && key <= array[end]) {
            // Probing the position with keeping
            // uniform distribution in mind.
            int pos = start + (((end - start) / (array[end] - array[start])) * (key - array[start]));

            // Condition of target found
            if (array[pos] == key) {
                return pos;
            }

            // If key is larger, key is in upper part
            if (array[pos] < key) {
                start = pos + 1;
            } // If key is smaller, x is in lower part
            else {
                end = pos - 1;
            }
        }
        return -1;
    }

    // Driver method
    public static void main(String[] args) {
        Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        int[] integers = IntStream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray();

        // the element that should be found
        Integer shouldBeFound = integers[r.nextInt(size - 1)];

        InterpolationSearch search = new InterpolationSearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                String.format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));
    }
}
package com.thealgorithms.searches;

import java.util.Scanner;

/**
 * Program to perform Saddleback Search Given a sorted 2D array(elements are
 * sorted across every row and column, assuming ascending order) of size n*m we
 * can search a given element in O(n+m)
 *
 * <p>
 * we start from bottom left corner if the current element is greater than the
 * given element then we move up else we move right Sample Input: 5 5
 * ->Dimensions -10 -5 -3 4 9 -6 -2 0 5 10 -4 -1 1 6 12 2 3 7 8 13 100 120 130
 * 140 150 140 ->element to be searched output: 4 3 // first value is row,
 * second one is column
 *
 * @author Nishita Aggarwal
 */
public class SaddlebackSearch {

    /**
     * This method performs Saddleback Search
     *
     * @param arr The **Sorted** array in which we will search the element.
     * @param row the current row.
     * @param col the current column.
     * @param key the element that we want to search for.
     * @return The index(row and column) of the element if found. Else returns
     * -1 -1.
     */
    private static int[] find(int arr[][], int row, int col, int key) {

        // array to store the answer row and column
        int ans[] = {-1, -1};
        if (row < 0 || col >= arr[row].length) {
            return ans;
        }
        if (arr[row][col] == key) {
            ans[0] = row;
            ans[1] = col;
            return ans;
        } // if the current element is greater than the given element then we move up
        else if (arr[row][col] > key) {
            return find(arr, row - 1, col, key);
        }
        // else we move right
        return find(arr, row, col + 1, key);
    }

    /**
     * Main method
     *
     * @param args Command line arguments
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Scanner sc = new Scanner(System.in);
        int arr[][];
        int i, j, rows = sc.nextInt(), col = sc.nextInt();
        arr = new int[rows][col];
        for (i = 0; i < rows; i++) {
            for (j = 0; j < col; j++) {
                arr[i][j] = sc.nextInt();
            }
        }
        int ele = sc.nextInt();
        // we start from bottom left corner
        int ans[] = find(arr, rows - 1, 0, ele);
        System.out.println(ans[0] + " " + ans[1]);
        sc.close();
    }
}
package com.thealgorithms.searches;

class PerfectBinarySearch {

    static int binarySearch(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;

        while (low <= high) {
            int mid = (low + high) / 2;

            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        PerfectBinarySearch BinarySearch = new PerfectBinarySearch();
        int[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        assert BinarySearch.binarySearch(array, -1) == -1;
        assert BinarySearch.binarySearch(array, 11) == -1;
    }
}
package com.thealgorithms.searches;

import java.util.*;

/**
 * An implementation of the Quickselect algorithm as described
 * <a href="https://en.wikipedia.org/wiki/Median_of_medians">here</a>.
 */
public final class QuickSelect {

    /**
     * Selects the {@code n}-th largest element of {@code list}, i.e. the element that would
     * be at index n if the list was sorted.
     * <p>
     * Calling this function might change the order of elements in {@code list}.
     *
     * @param list the list of elements
     * @param n    the index
     * @param <T>  the type of list elements
     * @return the n-th largest element in the list
     * @throws IndexOutOfBoundsException if n is less than 0 or greater or equal to
     *                                   the number of elements in the list
     * @throws IllegalArgumentException  if the list is empty
     * @throws NullPointerException      if {@code list} is null
     */
    public static <T extends Comparable<T>> T select(List<T> list, int n) {
        Objects.requireNonNull(list, "The list of elements must not be null.");

        if (list.size() == 0) {
            String msg = "The list of elements must not be empty.";
            throw new IllegalArgumentException(msg);
        }

        if (n < 0) {
            String msg = "The index must not be negative.";
            throw new IndexOutOfBoundsException(msg);
        }

        if (n >= list.size()) {
            String msg = "The index must be less than the number of elements.";
            throw new IndexOutOfBoundsException(msg);
        }

        int index = selectIndex(list, n);
        return list.get(index);
    }

    private static <T extends Comparable<T>> int selectIndex(List<T> list, int n) {
        return selectIndex(list, 0, list.size() - 1, n);
    }

    private static <T extends Comparable<T>> int selectIndex(
            List<T> list,
            int left,
            int right,
            int n
    ) {
        while (true) {
            if (left == right)
                return left;
            int pivotIndex = pivot(list, left, right);
            pivotIndex = partition(list, left, right, pivotIndex, n);
            if (n == pivotIndex) {
                return n;
            } else if (n < pivotIndex) {
                right = pivotIndex - 1;
            } else {
                left = pivotIndex + 1;
            }
        }
    }

    private static <T extends Comparable<T>> int partition(
            List<T> list,
            int left,
            int right,
            int pivotIndex,
            int n
    ) {
        T pivotValue = list.get(pivotIndex);
        Collections.swap(list, pivotIndex, right);
        int storeIndex = left;

        for (int i = left; i < right; i++) {
            if (list.get(i).compareTo(pivotValue) < 0) {
                Collections.swap(list, storeIndex, i);
                storeIndex++;
            }
        }

        int storeIndexEq = storeIndex;

        for (int i = storeIndex; i < right; i++) {
            if (list.get(i).compareTo(pivotValue) == 0) {
                Collections.swap(list, storeIndexEq, i);
                storeIndexEq++;
            }
        }

        Collections.swap(list, right, storeIndexEq);

        return (n < storeIndex)
                ? storeIndex
                : Math.min(n, storeIndexEq);
    }

    private static <T extends Comparable<T>> int pivot(
            List<T> list,
            int left,
            int right
    ) {
        if (right - left < 5) {
            return partition5(list, left, right);
        }

        for (int i = left; i < right; i += 5) {
            int subRight = i + 4;
            if (subRight > right) {
                subRight = right;
            }
            int median5 = partition5(list, i, subRight);
            int rightIndex = left + (i - left) / 5;
            Collections.swap(list, median5, rightIndex);
        }

        int mid = (right - left) / 10 + left + 1;
        int rightIndex = left + (right - left) / 5;
        return selectIndex(list, left, rightIndex, mid);
    }

    private static <T extends Comparable<T>> int partition5(
            List<T> list,
            int left,
            int right
    ) {
        List<T> ts = list.subList(left, right);
        ts.sort(Comparator.naturalOrder());
        return (left + right) >>> 1;
    }
}
package com.thealgorithms.searches;

import com.thealgorithms.devutils.searches.SearchAlgorithm;

/*
*  Fibonacci Search is a popular algorithm which finds the position of a target value in
*  a sorted array
*
*  The time complexity for this search algorithm is O(log3(n))
*  The space complexity for this search algorithm is O(1)
*  @author Kanakalatha Vemuru (https://github.com/KanakalathaVemuru)
 */
public class FibonacciSearch implements SearchAlgorithm {

    /**
     * @param array is a sorted array where the element has to be searched
     * @param key is an element whose position has to be found
     * @param <T> is any comparable type
     * @return index of the element
     */
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        int fibMinus1 = 1;
        int fibMinus2 = 0;
        int fibNumber = fibMinus1 + fibMinus2;
        int n = array.length;

        while (fibNumber < n) {
            fibMinus2 = fibMinus1;
            fibMinus1 = fibNumber;
            fibNumber = fibMinus2 + fibMinus1;
        }

        int offset = -1;

        while (fibNumber > 1) {
            int i = Math.min(offset + fibMinus2, n - 1);

            if (array[i].compareTo(key) < 0) {
                fibNumber = fibMinus1;
                fibMinus1 = fibMinus2;
                fibMinus2 = fibNumber - fibMinus1;
                offset = i;
            } else if (array[i].compareTo(key) > 0) {
                fibNumber = fibMinus2;
                fibMinus1 = fibMinus1 - fibMinus2;
                fibMinus2 = fibNumber - fibMinus1;
            } else {
                return i;
            }
        }

        if (fibMinus1 == 1 && array[offset + 1] == key) {
            return offset + 1;
        }

        return -1;
    }

    // Driver Program
    public static void main(String[] args) {
        Integer[] integers = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};

        int size = integers.length;
        Integer shouldBeFound = 128;
        FibonacciSearch fsearch = new FibonacciSearch();
        int atIndex = fsearch.find(integers, shouldBeFound);

        System.out.println(
                "Should be found: " + shouldBeFound + ". Found " + integers[atIndex] + " at index " + atIndex + ". An array length " + size);
    }

}
package com.thealgorithms.searches;

import java.util.Collections;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Random;

/**
 * Monte Carlo Tree Search (MCTS) is a heuristic search algorithm used in
 * decition taking problems especially games.
 *
 * See more: https://en.wikipedia.org/wiki/Monte_Carlo_tree_search,
 * https://www.baeldung.com/java-monte-carlo-tree-search
 */
public class MonteCarloTreeSearch {

    public class Node {

        Node parent;
        ArrayList<Node> childNodes;
        boolean isPlayersTurn; // True if it is the player's turn.
        boolean playerWon; // True if the player won; false if the opponent won.
        int score;
        int visitCount;

        public Node() {
        }

        public Node(Node parent, boolean isPlayersTurn) {
            this.parent = parent;
            childNodes = new ArrayList<>();
            this.isPlayersTurn = isPlayersTurn;
            playerWon = false;
            score = 0;
            visitCount = 0;
        }
    }

    static final int WIN_SCORE = 10;
    static final int TIME_LIMIT = 500; // Time the algorithm will be running for (in milliseconds).

    public static void main(String[] args) {
        MonteCarloTreeSearch mcts = new MonteCarloTreeSearch();

        mcts.monteCarloTreeSearch(mcts.new Node(null, true));
    }

    /**
     * Explores a game tree using Monte Carlo Tree Search (MCTS) and returns the
     * most promising node.
     *
     * @param rootNode Root node of the game tree.
     * @return The most promising child of the root node.
     */
    public Node monteCarloTreeSearch(Node rootNode) {
        Node winnerNode;
        double timeLimit;

        // Expand the root node.
        addChildNodes(rootNode, 10);

        timeLimit = System.currentTimeMillis() + TIME_LIMIT;

        // Explore the tree until the time limit is reached.
        while (System.currentTimeMillis() < timeLimit) {
            Node promisingNode;

            // Get a promising node using UCT.
            promisingNode = getPromisingNode(rootNode);

            // Expand the promising node.
            if (promisingNode.childNodes.size() == 0) {
                addChildNodes(promisingNode, 10);
            }

            simulateRandomPlay(promisingNode);
        }

        winnerNode = getWinnerNode(rootNode);
        printScores(rootNode);
        System.out.format("\nThe optimal node is: %02d\n", rootNode.childNodes.indexOf(winnerNode) + 1);

        return winnerNode;
    }

    public void addChildNodes(Node node, int childCount) {
        for (int i = 0; i < childCount; i++) {
            node.childNodes.add(new Node(node, !node.isPlayersTurn));
        }
    }

    /**
     * Uses UCT to find a promising child node to be explored.
     *
     * UCT: Upper Confidence bounds applied to Trees.
     *
     * @param rootNode Root node of the tree.
     * @return The most promising node according to UCT.
     */
    public Node getPromisingNode(Node rootNode) {
        Node promisingNode = rootNode;

        // Iterate until a node that hasn't been expanded is found.
        while (promisingNode.childNodes.size() != 0) {
            double uctIndex = Double.MIN_VALUE;
            int nodeIndex = 0;

            // Iterate through child nodes and pick the most promising one
            // using UCT (Upper Confidence bounds applied to Trees).
            for (int i = 0; i < promisingNode.childNodes.size(); i++) {
                Node childNode = promisingNode.childNodes.get(i);
                double uctTemp;

                // If child node has never been visited
                // it will have the highest uct value.
                if (childNode.visitCount == 0) {
                    nodeIndex = i;
                    break;
                }

                uctTemp = ((double) childNode.score / childNode.visitCount)
                        + 1.41 * Math.sqrt(Math.log(promisingNode.visitCount) / (double) childNode.visitCount);

                if (uctTemp > uctIndex) {
                    uctIndex = uctTemp;
                    nodeIndex = i;
                }
            }

            promisingNode = promisingNode.childNodes.get(nodeIndex);
        }

        return promisingNode;
    }

    /**
     * Simulates a random play from a nodes current state and back propagates
     * the result.
     *
     * @param promisingNode Node that will be simulated.
     */
    public void simulateRandomPlay(Node promisingNode) {
        Random rand = new Random();
        Node tempNode = promisingNode;
        boolean isPlayerWinner;

        // The following line randomly determines whether the simulated play is a win or loss.
        // To use the MCTS algorithm correctly this should be a simulation of the nodes' current
        // state of the game until it finishes (if possible) and use an evaluation function to
        // determine how good or bad the play was.
        // e.g. Play tic tac toe choosing random squares until the game ends. 
        promisingNode.playerWon = (rand.nextInt(6) == 0);

        isPlayerWinner = promisingNode.playerWon;

        // Back propagation of the random play.
        while (tempNode != null) {
            tempNode.visitCount++;

            // Add wining scores to bouth player and opponent depending on the turn.
            if ((tempNode.isPlayersTurn && isPlayerWinner)
                    || (!tempNode.isPlayersTurn && !isPlayerWinner)) {
                tempNode.score += WIN_SCORE;
            }

            tempNode = tempNode.parent;
        }
    }

    public Node getWinnerNode(Node rootNode) {
        return Collections.max(rootNode.childNodes, Comparator.comparing(c -> c.score));
    }

    public void printScores(Node rootNode) {
        System.out.println("N.\tScore\t\tVisits");

        for (int i = 0; i < rootNode.childNodes.size(); i++) {
            System.out.println(String.format("%02d\t%d\t\t%d", i + 1,
                    rootNode.childNodes.get(i).score, rootNode.childNodes.get(i).visitCount));
        }
    }
}
package com.thealgorithms.searches;

import java.util.*;

/*
    Problem Statement: 
    Given an array, find out how many times it has to been rotated 
    from its initial sorted position.
    Input-Output:
    Eg. [11,12,15,18,2,5,6,8]
    It has been rotated: 4 times
    (One rotation means putting the first element to the end)
    Note: The array cannot contain duplicates

    Logic: 
    The position of the minimum element will give the number of times the array has been rotated
    from its initial sorted position.
    Eg. For [2,5,6,8,11,12,15,18], 1 rotation gives [5,6,8,11,12,15,18,2], 2 rotations [6,8,11,12,15,18,2,5] and so on.
    Finding the minimum element will take O(N) time but, we can  use Binary Search to find the mimimum element, we can reduce the complexity to O(log N).
    If we look at the rotated array, to identify the minimum element (say a[i]), we observe that  a[i-1]>a[i]<a[i+1].

    Some other test cases: 
    1. [1,2,3,4] Number of rotations: 0 or 4(Both valid)
    2. [15,17,2,3,5] Number of rotations: 3
 */
class HowManyTimesRotated {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }

        System.out.println("The array has been rotated " + rotated(a) + " times");
        sc.close();

    }

    public static int rotated(int[] a) {
        int low = 0;
        int high = a.length - 1;
        int mid = 0; // low + (high-low)/2 = (low + high)/2

        while (low <= high) {
            mid = low + (high - low) / 2;

            if (a[mid] < a[mid - 1] && a[mid] < a[mid + 1]) {
                break;
            } else if (a[mid] > a[mid - 1] && a[mid] < a[mid + 1]) {
                high = mid + 1;
            } else if (a[mid] > a[mid - 1] && a[mid] > a[mid + 1]) {
                low = mid - 1;
            }
        }

        return mid;
    }
}
package com.thealgorithms.searches;

import com.thealgorithms.devutils.searches.SearchAlgorithm;

public class JumpSearch implements SearchAlgorithm {

    public static void main(String[] args) {
        JumpSearch jumpSearch = new JumpSearch();
        Integer[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        for (int i = 0; i < array.length; i++) {
            assert jumpSearch.find(array, i) == i;
        }
        assert jumpSearch.find(array, -1) == -1;
        assert jumpSearch.find(array, 11) == -1;
    }

    /**
     * Jump Search algorithm implements
     *
     * @param array the array contains elements
     * @param key to be searched
     * @return index of {@code key} if found, otherwise <tt>-1</tt>
     */
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        int length = array.length;
        /* length of array */
        int blockSize = (int) Math.sqrt(length);
        /* block size to be jumped */

        int limit = blockSize;
        while (key.compareTo(array[limit]) > 0 && limit < array.length - 1) {
            limit = Math.min(limit + blockSize, array.length - 1);
        }

        for (int i = limit - blockSize; i <= limit; i++) {
            if (array[i] == key) {
                /* execute linear search */
                return i;
            }
        }
        return -1;
        /* not found */
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;

/**
 * Binary search is one of the most popular algorithms The algorithm finds the
 * position of a target value within a sorted array
 *
 * <p>
 * Worst-case performance O(log n) Best-case performance O(1) Average
 * performance O(log n) Worst-case space complexity O(1)
 *
 * @author Varun Upadhyay (https://github.com/varunu28)
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 * @see SearchAlgorithm
 * @see IterativeBinarySearch
 */
class BinarySearch implements SearchAlgorithm {

    /**
     * @param array is an array where the element should be found
     * @param key is an element which should be found
     * @param <T> is any comparable type
     * @return index of the element
     */
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        return search(array, key, 0, array.length);
    }

    /**
     * This method implements the Generic Binary Search
     *
     * @param array The array to make the binary search
     * @param key The number you are looking for
     * @param left The lower bound
     * @param right The upper bound
     * @return the location of the key
     */
    private <T extends Comparable<T>> int search(T array[], T key, int left, int right) {
        if (right < left) {
            return -1; // this means that the key not found
        }
        // find median
        int median = (left + right) >>> 1;
        int comp = key.compareTo(array[median]);

        if (comp == 0) {
            return median;
        } else if (comp < 0) {
            return search(array, key, left, median - 1);
        } else {
            return search(array, key, median + 1, right);
        }
    }

    // Driver Program
    public static void main(String[] args) {
        // Just generate data
        Random r = ThreadLocalRandom.current();

        int size = 100;
        int maxElement = 100000;

        Integer[] integers
                = IntStream.generate(() -> r.nextInt(maxElement))
                        .limit(size)
                        .sorted()
                        .boxed()
                        .toArray(Integer[]::new);

        // The element that should be found
        int shouldBeFound = integers[r.nextInt(size - 1)];

        BinarySearch search = new BinarySearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;

/**
 * The LowerBound method is used to return an index pointing to the first
 * element in the range [first, last) which has a value not less than val, i.e.
 * the index of the next smallest number just greater than or equal to that
 * number. If there are multiple values that are equal to val it returns the
 * index of the first such value.
 *
 * <p>
 * This is an extension of BinarySearch.
 *
 * <p>
 * Worst-case performance O(log n) Best-case performance O(1) Average
 * performance O(log n) Worst-case space complexity O(1)
 *
 * @author Pratik Padalia (https://github.com/15pratik)
 * @see SearchAlgorithm
 * @see BinarySearch
 */
class LowerBound implements SearchAlgorithm {

    // Driver Program
    public static void main(String[] args) {
        // Just generate data
        Random r = ThreadLocalRandom.current();

        int size = 100;
        int maxElement = 100000;

        Integer[] integers
                = IntStream.generate(() -> r.nextInt(maxElement))
                        .limit(size)
                        .sorted()
                        .boxed()
                        .toArray(Integer[]::new);

        // The element for which the lower bound is to be found
        int val = integers[r.nextInt(size - 1)] + 1;

        LowerBound search = new LowerBound();
        int atIndex = search.find(integers, val);

        System.out.println(
                format(
                        "Val: %d. Lower Bound Found %d at index %d. An array length %d",
                        val, integers[atIndex], atIndex, size));

        boolean toCheck = integers[atIndex] >= val || integers[size - 1] < val;
        System.out.println(
                format(
                        "Lower Bound found at an index: %d. Is greater or max element: %b", atIndex, toCheck));
    }

    /**
     * @param array is an array where the LowerBound value is to be found
     * @param key is an element for which the LowerBound is to be found
     * @param <T> is any comparable type
     * @return index of the LowerBound element
     */
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        return search(array, key, 0, array.length - 1);
    }

    /**
     * This method implements the Generic Binary Search
     *
     * @param array The array to make the binary search
     * @param key The number you are looking for
     * @param left The lower bound
     * @param right The upper bound
     * @return the location of the key
     */
    private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) {
        if (right <= left) {
            return left;
        }

        // find median
        int median = (left + right) >>> 1;
        int comp = key.compareTo(array[median]);

        if (comp == 0) {
            return median;
        } else if (comp < 0) {
            // median position can be a possible solution
            return search(array, key, left, median);
        } else {
            // key we are looking is greater, so we must look on the right of median position
            return search(array, key, median + 1, right);
        }
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Arrays;
import java.util.Random;
import java.util.stream.Stream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;

/**
 * A ternary search algorithm is a technique in computer science for finding the
 * minimum or maximum of a unimodal function The algorithm determines either
 * that the minimum or maximum cannot be in the first third of the domain or
 * that it cannot be in the last third of the domain, then repeats on the
 * remaining third.
 *
 * <p>
 * Worst-case performance Θ(log3(N)) Best-case performance O(1) Average
 * performance Θ(log3(N)) Worst-case space complexity O(1)
 *
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 * @see SearchAlgorithm
 * @see IterativeBinarySearch
 */
public class TernarySearch implements SearchAlgorithm {

    /**
     * @param arr The **Sorted** array in which we will search the element.
     * @param value The value that we want to search for.
     * @return The index of the element if found. Else returns -1.
     */
    @Override
    public <T extends Comparable<T>> int find(T[] arr, T value) {
        return ternarySearch(arr, value, 0, arr.length - 1);
    }

    /**
     * @param arr The **Sorted** array in which we will search the element.
     * @param key The value that we want to search for.
     * @param start The starting index from which we will start Searching.
     * @param end The ending index till which we will Search.
     * @return Returns the index of the Element if found. Else returns -1.
     */
    private <T extends Comparable<T>> int ternarySearch(T[] arr, T key, int start, int end) {
        if (start > end) {
            return -1;
        }
        /* First boundary: add 1/3 of length to start */
        int mid1 = start + (end - start) / 3;
        /* Second boundary: add 2/3 of length to start */
        int mid2 = start + 2 * (end - start) / 3;

        if (key.compareTo(arr[mid1]) == 0) {
            return mid1;
        } else if (key.compareTo(arr[mid2]) == 0) {
            return mid2;
        } /* Search the first (1/3) rd part of the array.*/ else if (key.compareTo(arr[mid1]) < 0) {
            return ternarySearch(arr, key, start, --mid1);
        } /* Search 3rd (1/3)rd part of the array */ else if (key.compareTo(arr[mid2]) > 0) {
            return ternarySearch(arr, key, ++mid2, end);
        } /* Search middle (1/3)rd part of the array */ else {
            return ternarySearch(arr, key, mid1, mid2);
        }
    }

    public static void main(String[] args) {
        // just generate data
        Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        Integer[] integers
                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);

        // the element that should be found
        Integer shouldBeFound = integers[r.nextInt(size - 1)];

        TernarySearch search = new TernarySearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));
    }
}
package com.thealgorithms.matrixexponentiation;

import java.util.Scanner;

/**
 * @author Anirudh Buvanesh (https://github.com/anirudhb11) For more information
 * see https://www.geeksforgeeks.org/matrix-exponentiation/
 *
 */
public class Fibonacci {

    // Exponentiation matrix for Fibonacci sequence
    private static final int[][] fibMatrix = {{1, 1}, {1, 0}};
    private static final int[][] identityMatrix = {{1, 0}, {0, 1}};
    //First 2 fibonacci numbers
    private static final int[][] baseFibNumbers = {{1}, {0}};

    /**
     * Performs multiplication of 2 matrices
     *
     * @param matrix1
     * @param matrix2
     * @return The product of matrix1 and matrix2
     */
    private static int[][] matrixMultiplication(int[][] matrix1, int[][] matrix2) {
        //Check if matrices passed can be multiplied
        int rowsInMatrix1 = matrix1.length;
        int columnsInMatrix1 = matrix1[0].length;

        int rowsInMatrix2 = matrix2.length;
        int columnsInMatrix2 = matrix2[0].length;

        assert columnsInMatrix1 == rowsInMatrix2;
        int[][] product = new int[rowsInMatrix1][columnsInMatrix2];
        for (int rowIndex = 0; rowIndex < rowsInMatrix1; rowIndex++) {
            for (int colIndex = 0; colIndex < columnsInMatrix2; colIndex++) {
                int matrixEntry = 0;
                for (int intermediateIndex = 0; intermediateIndex < columnsInMatrix1; intermediateIndex++) {
                    matrixEntry += matrix1[rowIndex][intermediateIndex] * matrix2[intermediateIndex][colIndex];
                }
                product[rowIndex][colIndex] = matrixEntry;
            }
        }
        return product;
    }

    /**
     * Calculates the fibonacci number using matrix exponentiaition technique
     *
     * @param n The input n for which we have to determine the fibonacci number
     * Outputs the nth * fibonacci number
     * @return a 2 X 1 array as { {F_n+1}, {F_n} }
     */
    public static int[][] fib(int n) {
        if (n == 0) {
            return Fibonacci.identityMatrix;
        } else {
            int[][] cachedResult = fib(n / 2);
            int[][] matrixExpResult = matrixMultiplication(cachedResult, cachedResult);
            if (n % 2 == 0) {
                return matrixExpResult;
            } else {
                return matrixMultiplication(Fibonacci.fibMatrix, matrixExpResult);
            }
        }
    }

    public static void main(String[] args) {
        // Returns [0, 1, 1, 2, 3, 5 ..] for n = [0, 1, 2, 3, 4, 5.. ]
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] result = matrixMultiplication(fib(n), baseFibNumbers);
        System.out.println("Fib(" + n + ") = " + result[1][0]);
        sc.close();
    }
}
package com.thealgorithms.strings;

// Longest Palindromic Substring
import java.util.Scanner;

class LongestPalindromicSubstring {

    public static void main(String[] args) {
        Solution s = new Solution();
        String str = "";
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the string: ");
        str = sc.nextLine();
        System.out.println("Longest substring is : " + s.longestPalindrome(str));
    }
}

class Solution {

    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }
        int n = s.length();
        String maxStr = "";
        for (int i = 0; i < n; ++i) {
            for (int j = i; j < n; ++j) {
                if (isValid(s, i, j) == true) {
                    if (j - i + 1 > maxStr.length()) { // update maxStr
                        maxStr = s.substring(i, j + 1);
                    }
                }
            }
        }
        return maxStr;
    }

    private boolean isValid(String s, int lo, int hi) {
        int n = hi - lo + 1;
        for (int i = 0; i < n / 2; ++i) {
            if (s.charAt(lo + i) != s.charAt(hi - i)) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;

import java.util.HashMap;

/**
 * This class is not thread safe<br>
 * <br>
 * (From wikipedia) In computer science, the Boyer–Moore–Horspool algorithm or
 * Horspool's algorithm is an algorithm for finding substrings in strings. It
 * was published by Nigel Horspool in 1980.
 * <br>
 * <a href=https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm>Wikipedia
 * page</a><br>
 * <br>
 *
 * <p>
 * An explanation:<br>
 *
 * <p>
 * The Horspool algorithm is a simplification of the Boyer-Moore algorithm in
 * that it uses only one of the two heuristic methods for increasing the number
 * of characters shifted when finding a bad match in the text. This method is
 * usually called the "bad symbol" or "bad character" shift. The bad symbol
 * shift method is classified as an input enhancement method in the theory of
 * algorithms. Input enhancement is (from wikipedia) the principle that
 * processing a given input to a problem and altering it in a specific way will
 * increase runtime efficiency or space efficiency, or both. Both algorithms try
 * to match the pattern and text comparing the pattern symbols to the text's
 * from right to left.<br>
 * <br>
 *
 * <p>
 * In the bad symbol shift method, a table is created prior to the search,
 * called the "bad symbol table". The bad symbol table contains the shift values
 * for any symbol in the text and pattern. For these symbols, the value is the
 * length of the pattern, if the symbol is not in the first (length - 1) of the
 * pattern. Else it is the distance from its rightmost occurrence in the pattern
 * to the last symbol of the pattern. In practice, we only calculate the values
 * for the ones that exist in the first (length - 1) of the pattern.<br>
 * <br>
 *
 * <p>
 * For more details on the algorithm and the more advanced Boyer-Moore I
 * recommend checking out the wikipedia page and professor Anany Levitin's book:
 * Introduction To The Design And Analysis Of Algorithms.
 */
public class HorspoolSearch {

    private static HashMap<Character, Integer> shiftValues; // bad symbol table
    private static Integer patternLength;
    private static int comparisons = 0; // total comparisons in the current/last search

    /**
     * Case sensitive version version of the algorithm
     *
     * @param pattern the pattern to be searched for (needle)
     * @param text the text being searched in (haystack)
     * @return -1 if not found or first index of the pattern in the text
     */
    public static int findFirst(String pattern, String text) {
        return firstOccurrence(pattern, text, true);
    }

    /**
     * Case insensitive version version of the algorithm
     *
     * @param pattern the pattern to be searched for (needle)
     * @param text the text being searched in (haystack)
     * @return -1 if not found or first index of the pattern in the text
     */
    public static int findFirstInsensitive(String pattern, String text) {
        return firstOccurrence(pattern, text, false);
    }

    /**
     * Utility method that returns comparisons made by last run (mainly for
     * tests)
     *
     * @return number of character comparisons of the last search
     */
    public static Integer getLastComparisons() {
        return HorspoolSearch.comparisons;
    }

    /**
     * Fairly standard implementation of the Horspool algorithm. Only the index
     * of the last character of the pattern on the text is saved and shifted by
     * the appropriate amount when a mismatch is found. The algorithm stops at
     * the first match or when the entire text has been exhausted.
     *
     * @param pattern String to be matched in the text
     * @param text text String
     * @return index of first occurrence of the pattern in the text
     */
    private static int firstOccurrence(String pattern, String text, boolean caseSensitive) {
        shiftValues = calcShiftValues(pattern); // build the bad symbol table
        comparisons = 0; // reset comparisons

        int textIndex
                = pattern.length() - 1; // align pattern with text start and get index of the last character

        // while pattern is not out of text bounds
        while (textIndex < text.length()) {

            // try to match pattern with current part of the text starting from last character
            int i = pattern.length() - 1;
            while (i >= 0) {
                comparisons++;
                char patternChar = pattern.charAt(i);
                char textChar = text.charAt((textIndex + i) - (pattern.length() - 1));
                if (!charEquals(patternChar, textChar, caseSensitive)) { // bad character, shift pattern
                    textIndex += getShiftValue(text.charAt(textIndex));
                    break;
                }
                i--;
            }

            // check for full match
            if (i == -1) {
                return textIndex - pattern.length() + 1;
            }
        }

        // text exhausted, return failure
        return -1;
    }

    /**
     * Compares the argument characters
     *
     * @param c1 first character
     * @param c2 second character
     * @param caseSensitive boolean determining case sensitivity of comparison
     * @return truth value of the equality comparison
     */
    private static boolean charEquals(char c1, char c2, boolean caseSensitive) {
        if (caseSensitive) {
            return c1 == c2;
        }
        return Character.toLowerCase(c1) == Character.toLowerCase(c2);
    }

    /**
     * Builds the bad symbol table required to run the algorithm. The method
     * starts from the second to last character of the pattern and moves to the
     * left. When it meets a new character, it is by definition its rightmost
     * occurrence and therefore puts the distance from the current index to the
     * index of the last character into the table. If the character is already
     * in the table, then it is not a rightmost occurrence, so it continues.
     *
     * @param pattern basis for the bad symbol table
     * @return the bad symbol table
     */
    private static HashMap<Character, Integer> calcShiftValues(String pattern) {
        patternLength = pattern.length();
        HashMap<Character, Integer> table = new HashMap<>();

        for (int i = pattern.length() - 2;
                i >= 0;
                i--) { // length - 2 is the index of the second to last character
            char c = pattern.charAt(i);
            int finalI = i;
            table.computeIfAbsent(c, k -> pattern.length() - 1 - finalI);
        }

        return table;
    }

    /**
     * Helper function that uses the bad symbol shift table to return the
     * appropriate shift value for a given character
     *
     * @param c character
     * @return shift value that corresponds to the character argument
     */
    private static Integer getShiftValue(char c) {
        if (shiftValues.get(c) != null) {
            return shiftValues.get(c);
        } else {
            return patternLength;
        }
    }
}
package com.thealgorithms.strings;

/*
Backtracking algorithm used in the program:-

>>Fix a character in the first position and swap the rest of the character with the first character.
  Like in ABC, in the first iteration three strings are formed: ABC, BAC, and CBA by swapping A with
  A, B and C respectively.
>>Repeat step 1 for the rest of the characters like fixing second character B and so on.
>>Now swap again to go back to the previous position. E.g., from ABC, we formed ABC by fixing B again,
  and we backtrack to the previous position and swap B with C. So, now we got ABC and ACB.
>>Repeat these steps for BAC and CBA, to get all the permutations.
 */
public class PermuteString {

    //Function for swapping the characters at position I with character at position j    
    public static String swapString(String a, int i, int j) {
        char[] b = a.toCharArray();
        char ch;
        ch = b[i];
        b[i] = b[j];
        b[j] = ch;
        return String.valueOf(b);
    }

    public static void main(String[] args) {
        String str = "ABC";
        int len = str.length();
        System.out.println("All the permutations of the string are: ");
        generatePermutation(str, 0, len);
    }

    //Function for generating different permutations of the string    
    public static void generatePermutation(String str, int start, int end) {
        //Prints the permutations    
        if (start == end - 1) {
            System.out.println(str);
        } else {
            for (int i = start; i < end; i++) {
                //Swapping the string by fixing a character    
                str = swapString(str, start, i);
                //Recursively calling function generatePermutation() for rest of the characters     
                generatePermutation(str, start + 1, end);
                //Backtracking and swapping the characters again.    
                str = swapString(str, start, i);
            }
        }
    }
}
package com.thealgorithms.strings;

public class CharactersSame {

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        assert isAllCharactersSame("");
        assert !isAllCharactersSame("aab");
        assert isAllCharactersSame("aaa");
        assert isAllCharactersSame("11111");
    }

    /**
     * check if all the characters of a string are same
     *
     * @param s the string to check
     * @return {@code true} if all characters of a string are same, otherwise
     * {@code false}
     */
    public static boolean isAllCharactersSame(String s) {
        for (int i = 1, length = s.length(); i < length; ++i) {
            if (s.charAt(i) != s.charAt(0)) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * Vowel Count is a system whereby character strings are placed in order based
 * on the position of the characters in the conventional ordering of an
 * alphabet. Wikipedia: https://en.wikipedia.org/wiki/Alphabetical_order
 */
public class CheckVowels {
    private static final Set<Character> VOWELS = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));

    /**
     * Check if a string is has vowels or not
     *
     * @param input a string
     * @return {@code true} if given string has vowels, otherwise {@code false}
     */
    public static boolean hasVowels(String input) {
        return countVowels(input) > 0;
    }

    /**
     * count the number of vowels
     *
     * @param input a string prints the count of vowels
     */
    public static int countVowels(String input) {
        if (input == null) {
            return 0;
        }
        int cnt = 0;
        for (char c : input.toLowerCase().toCharArray()) {
            if (VOWELS.contains(c)) {
                ++cnt;
            }
        }
        return cnt;
    }
}
package com.thealgorithms.strings;

import java.util.Arrays;
import java.util.HashMap;


/**
 * An anagram is a word or phrase formed by rearranging the letters of a different word or phrase,
 * typically using all the original letters exactly once.[1]
 * For example, the word anagram itself can be rearranged into nag a ram,
 * also the word binary into brainy and the word adobe into abode.
 * Reference from https://en.wikipedia.org/wiki/Anagram
 */
public class Anagrams {
    // 4 approaches are provided for anagram checking. approach 2 and approach 3 are similar but differ in running time.
    public static void main(String[] args) {
        String first = "deal";
        String second = "lead";
        // All the below methods takes input but doesn't return any output to the main method.
        Anagrams nm = new Anagrams();
        System.out.println(nm.approach2(first, second));  /* To activate methods for different approaches*/
        System.out.println(nm.approach1(first, second));  /* To activate methods for different approaches*/
        System.out.println(nm.approach3(first, second));  /* To activate methods for different approaches*/
        System.out.println(nm.approach4(first, second));  /* To activate methods for different approaches*/

        /**
         * OUTPUT :
         * first string ="deal" second string ="lead"
         * Output: Anagram
         * Input and output is constant for all four approaches
         * 1st approach Time Complexity : O(n logn)
         * Auxiliary Space Complexity : O(1)
         * 2nd approach Time Complexity : O(n)
         * Auxiliary Space Complexity : O(1)
         * 3rd approach Time Complexity : O(n)
         * Auxiliary Space Complexity : O(1)
         * 4th approach Time Complexity : O(n)
         * Auxiliary Space Complexity : O(n)
         */
    }

    boolean approach1(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        } else {
            char c[] = s.toCharArray();
            char d[] = t.toCharArray();
            Arrays.sort(c);
            Arrays.sort(d);    /* In this approach the strings are stored in the character arrays and both the arrays are sorted. After that both the arrays are compared for checking anangram */
            if (Arrays.equals(c, d)) {
                return true;
            } else {
                return false;
            }
        }
    }

    boolean approach2(String a, String b) {
        if (a.length() != b.length()) {
            return false;
        } else {
            int m[] = new int[26];
            int n[] = new int[26];
            for (char c : a.toCharArray()) {
                m[c - 'a']++;
            }
            // In this approach the frequency of both the strings are stored and after that the frequencies are iterated from 0 to 26(from 'a' to 'z' ). If the frequencies match then anagram message is displayed in the form of boolean format
            // Running time and space complexity of this algo is less as compared to others
            for (char c : b.toCharArray()) {
                n[c - 'a']++;
            }
            for (int i = 0; i < 26; i++) {
                if (m[i] != n[i]) {
                    return false;
                }
            }
            return true;
        }
    }

    boolean approach3(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        // this is similar to approach number 2 but here the string is not converted to character array
        else {
            int a[] = new int[26];
            int b[] = new int[26];
            int k = s.length();
            for (int i = 0; i < k; i++) {
                a[s.charAt(i) - 'a']++;
                b[t.charAt(i) - 'a']++;
            }
            for (int i = 0; i < 26; i++) {
                if (a[i] != b[i])
                    return false;
            }
            return true;
        }
    }

    boolean approach4(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        // This approach is done using hashmap where frequencies are stored and checked iteratively and if all the frequencies of first string match with the second string then anagram message is displayed in boolean format
        else {
            HashMap<Character, Integer> nm = new HashMap<>();
            HashMap<Character, Integer> kk = new HashMap<>();
            for (char c : s.toCharArray()) {
                nm.put(c, nm.getOrDefault(c, 0) + 1);
            }
            for (char c : t.toCharArray()) {

                kk.put(c, kk.getOrDefault(c, 0) + 1);
            }
            // It checks for equal frequencies
            for (char c : nm.keySet()) {
                if (!nm.get(c).equals(kk.get(c))) {
                    return false;
                }
            }
            return true;
        }
    }
}
package com.thealgorithms.strings;

import java.util.HashMap;
import java.util.Map;

/**
 * Two strings are anagrams if they are made of the same letters arranged
 * differently (ignoring the case).
 */
public class CheckAnagrams {

    public static void main(String[] args) {
        assert isAnagrams("Silent", "Listen");
        assert isAnagrams("This is a string", "Is this a string");
        assert !isAnagrams("There", "Their");
    }

    /**
     * Check if two strings are anagrams or not
     *
     * @param s1 the first string
     * @param s2 the second string
     * @return {@code true} if two string are anagrams, otherwise {@code false}
     */
    public static boolean isAnagrams(String s1, String s2) {
        int l1 = s1.length();
        int l2 = s2.length();
        s1 = s1.toLowerCase();
        s2 = s2.toLowerCase();
        Map<Character, Integer> charAppearances = new HashMap<>();

        for (int i = 0; i < l1; i++) {
            char c = s1.charAt(i);
            int numOfAppearances = charAppearances.getOrDefault(c, 0);
            charAppearances.put(c, numOfAppearances + 1);
        }

        for (int i = 0; i < l2; i++) {
            char c = s2.charAt(i);
            if (!charAppearances.containsKey(c)) {
                return false;
            }
            charAppearances.put(c, charAppearances.get(c) - 1);
        }

        for (int cnt : charAppearances.values()) {
            if (cnt != 0) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;

public class Lower {

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        String[] strings = {"ABC", "ABC123", "abcABC", "abc123ABC"};
        for (String s : strings) {
            assert toLowerCase(s).equals(s.toLowerCase());
        }
    }

    /**
     * Converts all of the characters in this {@code String} to lower case
     *
     * @param s the string to convert
     * @return the {@code String}, converted to lowercase.
     */
    public static String toLowerCase(String s) {
        char[] values = s.toCharArray();
        for (int i = 0; i < values.length; ++i) {
            if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {
                values[i] = Character.toLowerCase(values[i]);
            }
        }
        return new String(values);
    }
}
package com.thealgorithms.strings;

/**
 * Alphabetical order is a system whereby character strings are placed in order
 * based on the position of the characters in the conventional ordering of an
 * alphabet. Wikipedia: https://en.wikipedia.org/wiki/Alphabetical_order
 */
class Alphabetical {

    public static void main(String[] args) {
        assert !isAlphabetical("123abc");
        assert isAlphabetical("aBC");
        assert isAlphabetical("abc");
        assert !isAlphabetical("xyzabc");
        assert isAlphabetical("abcxyz");
    }

    /**
     * Check if a string is alphabetical order or not
     *
     * @param s a string
     * @return {@code true} if given string is alphabetical order, otherwise
     * {@code false}
     */
    public static boolean isAlphabetical(String s) {
        s = s.toLowerCase();
        for (int i = 0; i < s.length() - 1; ++i) {
            if (!Character.isLetter(s.charAt(i)) || !(s.charAt(i) <= s.charAt(i + 1))) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;

import java.util.List;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.HashSet;

/*
    **Problem Statement:**
    A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:

    Every adjacent pair of words differs by a single letter.
    Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
    sk == endWord
    Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.

    **Example 1:**
    Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
    Output: 5 
    Explanation: One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> cog", which is 5 words long.

    **Example 2:**
    Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
    Output: 0
    Explanation: The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.

    **Constraints:**
    1 <= beginWord.length <= 10
    endWord.length == beginWord.length
    1 <= wordList.length <= 5000
    wordList[i].length == beginWord.length
    beginWord, endWord, and wordList[i] consist of lowercase English letters.
    beginWord != endWord
    All the words in wordList are unique.
 */
class WordLadder {

    /**
     * Driver Code
     */
    public static void main(String[] args) {

        String beginWord = "hit";
        String endWord = "cog";
        String words[] = {"hot", "dot", "dog", "lot", "log", "cog"};
        List<String> wordList = Arrays.asList(words);

        System.out.println("Ladder Length: " + ladderLength(beginWord, endWord, wordList));
    }

    /**
     * This function finds the ladderLength
     *
     * @param beginWord: Starting word of the ladder
     * @param endWord: Ending word of the ladder
     * @param wordList: This list contains the words which needs to be included
     * in ladder.
     * @return ladderLength: This function will return the ladderLength(level)
     * if the endword is there. Otherwise, will return the length as 0.
     */
    public static int ladderLength(String beginWord, String endWord, List<String> wordList) {
        HashSet<String> set = new HashSet();
        for (String word : wordList) {
            set.add(word);
        }

        if (!set.contains(endWord)) {
            return 0;
        }

        Queue<String> queue = new LinkedList();
        queue.offer(beginWord);
        int level = 1;

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                String curr = queue.poll();
                char[] words_chars = curr.toCharArray();
                for (int j = 0; j < words_chars.length; j++) {
                    char original_chars = words_chars[j];
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (words_chars[j] == c) {
                            continue;
                        }
                        words_chars[j] = c;
                        String new_word = String.valueOf(words_chars);
                        if (new_word.equals(endWord)) {
                            return level + 1;
                        }
                        if (set.contains(new_word)) {
                            set.remove(new_word);
                            queue.offer(new_word);
                        }
                    }
                    words_chars[j] = original_chars;
                }
            }
            level++;
        }
        return 0;
    }
}
package com.thealgorithms.strings;

/**
 * Reverse String using different version
 */
public class ReverseString {

    public static void main(String[] args) {
        assert reverse("abc123").equals("321cba");
        assert reverse2("abc123").equals("321cba");
    }

    /**
     * easiest way to reverses the string str and returns it
     *
     * @param str string to be reversed
     * @return reversed string
     */
    public static String reverse(String str) {
        return new StringBuilder(str).reverse().toString();
    }

    /**
     * second way to reverses the string str and returns it
     *
     * @param str string to be reversed
     * @return reversed string
     */
    public static String reverse2(String str) {

        if (str == null || str.isEmpty()) {
            return str;
        }

        char[] value = str.toCharArray();
        for (int i = 0, j = str.length() - 1; i < j; i++, j--) {
            char temp = value[i];
            value[i] = value[j];
            value[j] = temp;
        }
        return new String(value);
    }
}
package com.thealgorithms.strings;

/**
 * Given a string, moving several characters in front of the string to the end
 * of the string. For example, move the two characters'a' and 'b' in front of
 * the string "abcdef" to the end of the string, so that the original string
 * becomes the string "cdefab"
 */
public class Rotation {

    public static void main(String[] args) {
        assert rotation("abcdef", 2).equals("cdefab");

        char[] values = "abcdef".toCharArray();
        rotation(values, 2);
        assert new String(values).equals("cdefab");
    }

    /**
     * Move {@code n} characters in front of given string to the end of string
     * time complexity: O(n) space complexity: O(n)
     *
     * @param s given string
     * @param n the total characters to be moved
     * @return string after rotation
     */
    public static String rotation(String s, int n) {
        return s.substring(n) + s.substring(0, n);
    }

    /**
     * Move {@code n} characters in front of given character array to the end of
     * array time complexity: O(n) space complexity: O(1)
     *
     * @param values given character array
     * @param n the total characters to be moved
     */
    public static void rotation(char[] values, int n) {
        reverse(values, 0, n - 1);
        reverse(values, n, values.length - 1);
        reverse(values, 0, values.length - 1);
    }

    /**
     * Reverse character array
     *
     * @param values character array
     * @param from begin index of given array
     * @param to end index of given array
     */
    public static void reverse(char[] values, int from, int to) {
        while (from < to) {
            char temp = values[from];
            values[from] = values[to];
            values[to] = temp;
            from++;
            to--;
        }
    }
}
package com.thealgorithms.strings;

public class Upper {

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        String[] strings = {"ABC", "ABC123", "abcABC", "abc123ABC"};
        for (String s : strings) {
            assert toUpperCase(s).equals(s.toUpperCase());
        }
    }

    /**
     * Converts all of the characters in this {@code String} to upper case
     *
     * @param s the string to convert
     * @return the {@code String}, converted to uppercase.
     */
    public static String toUpperCase(String s) {
        if (s == null || "".equals(s)) {
            return s;
        }
        char[] values = s.toCharArray();
        for (int i = 0; i < values.length; ++i) {
            if (Character.isLetter(values[i]) && Character.isLowerCase(values[i])) {
                values[i] = Character.toUpperCase(values[i]);
            }
        }
        return new String(values);
    }
}
package com.thealgorithms.strings ;
import java.util.HashMap ;
class longestNonRepeativeSubstring {

    public static int lengthOfLongestSubstring(String s) {
    
        int max = 0 , start = 0 , i = 0 ;
        HashMap< Character , Integer > map = new HashMap<>() ;
    
        while ( i < s.length() ) {

            char temp = s.charAt( i ) ;

            // adding key to map if not present
            if ( ! map.containsKey( temp ) )
                map.put( temp , 0 ) ;

            // checking if the first value is the dublicate value
            else if ( s.charAt( start ) == temp )
                start++ ;

            // checking if the previous value is dublicate value
            else if ( s.charAt( i - 1 )  == temp ) {
                if ( max < map.size() ) max = map.size() ;
                map = new HashMap<>() ;
                start = i ;
                i-- ;
            }

            // last possible place where dublicate value can be is between start and i
            else {
                if ( max < map.size() ) max = map.size() ;
                while ( s.charAt( start ) != temp ) {
                    map.remove( s.charAt( start ) ) ;
                    start++ ;
                }
                start++ ;
            }

            i++ ;

        }
        if ( max < map.size() ) max = map.size() ;
        return max ;
    }

}
package com.thealgorithms.strings;

/**
 * Wikipedia: https://en.wikipedia.org/wiki/Pangram
 */
public class Pangram {

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        assert isPangram("The quick brown fox jumps over the lazy dog");
        assert !isPangram("The quick brown fox jumps over the azy dog");
        /* not exists l character */
    }

    /**
     * Check if a string is a pangram string or not
     *
     * @param s string to check
     * @return {@code true} if given string is pangram, otherwise {@code false}
     */
    public static boolean isPangram(String s) {
        boolean[] marked = new boolean[26];
        /* by default all letters don't exists */
        char[] values = s.toCharArray();
        for (char value : values) {
            if (Character.isLetter(value)) {
                int index = Character.isUpperCase(value) ? value - 'A' : value - 'a';
                marked[index] = true;
                /* mark current character exists */
            }
        }

        for (boolean b : marked) {
            if (!b) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;

/**
 * Wikipedia: https://en.wikipedia.org/wiki/Palindrome
 */
class Palindrome {

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        String[] palindromes = {null, "", "aba", "123321"};
        for (String s : palindromes) {
            assert isPalindrome(s) && isPalindromeRecursion(s) && isPalindrome1(s);
        }

        String[] notPalindromes = {"abb", "abc", "abc123"};
        for (String s : notPalindromes) {
            assert !isPalindrome(s) && !isPalindromeRecursion(s) && !isPalindrome1(s);
        }
    }

    /**
     * Check if a string is palindrome string or not
     *
     * @param s a string to check
     * @return {@code true} if given string is palindrome, otherwise
     * {@code false}
     */
    public static boolean isPalindrome(String s) {
        return (s == null || s.length() <= 1) || s.equals(new StringBuilder(s).reverse().toString());
    }

    /**
     * Check if a string is palindrome string or not using recursion
     *
     * @param s a string to check
     * @return {@code true} if given string is palindrome, otherwise
     * {@code false}
     */
    public static boolean isPalindromeRecursion(String s) {
        if (s == null || s.length() <= 1) {
            return true;
        }

        if (s.charAt(0) != s.charAt(s.length() - 1)) {
            return false;
        }

        return isPalindrome(s.substring(1, s.length() - 1));
    }

    /**
     * Check if a string is palindrome string or not another way
     *
     * @param s a string to check
     * @return {@code true} if given string is palindrome, otherwise
     * {@code false}
     */
    public static boolean isPalindrome1(String s) {
        if (s == null || s.length() <= 1) {
            return true;
        }
        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;

import java.util.*;

public class List_all_Possible_Words_From_Phone_Digits {

    static Character[][] numberToCharMap;

    private static List<String> printWords(int[] numbers,
            int len,
            int numIndex,
            String s) {
        if (len == numIndex) {
            return new ArrayList<>(Collections.singleton(s));
        }

        List<String> stringList = new ArrayList<>();

        for (int i = 0;
                i < numberToCharMap[numbers[numIndex]].length; i++) {
            String sCopy
                    = String.copyValueOf(s.toCharArray());
            sCopy = sCopy.concat(
                    numberToCharMap[numbers[numIndex]][i].toString());
            stringList.addAll(printWords(numbers, len,
                    numIndex + 1,
                    sCopy));
        }
        return stringList;
    }

    private static void printWords(int[] numbers) {
        generateNumberToCharMap();
        List<String> stringList
                = printWords(numbers, numbers.length, 0, "");
        stringList.stream().forEach(System.out::println);
    }

    private static void generateNumberToCharMap() {
        numberToCharMap = new Character[10][5];
        numberToCharMap[0] = new Character[]{'\0'};
        numberToCharMap[1] = new Character[]{'\0'};
        numberToCharMap[2] = new Character[]{'a', 'b', 'c'};
        numberToCharMap[3] = new Character[]{'d', 'e', 'f'};
        numberToCharMap[4] = new Character[]{'g', 'h', 'i'};
        numberToCharMap[5] = new Character[]{'j', 'k', 'l'};
        numberToCharMap[6] = new Character[]{'m', 'n', 'o'};
        numberToCharMap[7] = new Character[]{'p', 'q', 'r', 's'};
        numberToCharMap[8] = new Character[]{'t', 'u', 'v'};
        numberToCharMap[9] = new Character[]{'w', 'x', 'y', 'z'};
    }

// Driver code 
    public static void main(String[] args) {
        int number[] = {2, 3, 4};
        printWords(number);
    }
}
package com.thealgorithms.conversions;

/**
 * @author Varun Upadhyay (https://github.com/varunu28)
 */
// Driver program
public class AnyBaseToDecimal {

    public static void main(String[] args) {
        assert convertToDecimal("1010", 2) == Integer.valueOf("1010", 2);
        assert convertToDecimal("777", 8) == Integer.valueOf("777", 8);
        assert convertToDecimal("999", 10) == Integer.valueOf("999", 10);
        assert convertToDecimal("ABCDEF", 16) == Integer.valueOf("ABCDEF", 16);
        assert convertToDecimal("XYZ", 36) == Integer.valueOf("XYZ", 36);
    }

    /**
     * Convert any radix to decimal number
     *
     * @param s the string to be convert
     * @param radix the radix
     * @return decimal of bits
     * @throws NumberFormatException if {@code bits} or {@code radix} is invalid
     */
    public static int convertToDecimal(String s, int radix) {
        int num = 0;
        int pow = 1;

        for (int i = s.length() - 1; i >= 0; i--) {
            int digit = valOfChar(s.charAt(i));
            if (digit >= radix) {
                throw new NumberFormatException("For input string " + s);
            }
            num += valOfChar(s.charAt(i)) * pow;
            pow *= radix;
        }
        return num;
    }

    /**
     * Convert character to integer
     *
     * @param c the character
     * @return represented digit of given character
     * @throws NumberFormatException if {@code ch} is not UpperCase or Digit
     * character.
     */
    public static int valOfChar(char c) {
        if (!(Character.isUpperCase(c) || Character.isDigit(c))) {
            throw new NumberFormatException("invalid character :" + c);
        }
        return Character.isDigit(c) ? c - '0' : c - 'A' + 10;
    }
}
package com.thealgorithms.conversions;

/**
 * Converting Integers into Roman Numerals
 *
 * <p>
 * ('I', 1); ('IV',4); ('V', 5); ('IX',9); ('X', 10); ('XL',40); ('L', 50);
 * ('XC',90); ('C', 100); ('D', 500); ('M', 1000);
 */
public class IntegerToRoman {

    private static int[] allArabianRomanNumbers
            = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    private static String[] allRomanNumbers
            = new String[]{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

    // Value must be > 0
    public static String integerToRoman(int num) {
        if (num <= 0) {
            return "";
        }

        StringBuilder builder = new StringBuilder();

        for (int a = 0; a < allArabianRomanNumbers.length; a++) {
            int times = num / allArabianRomanNumbers[a];
            for (int b = 0; b < times; b++) {
                builder.append(allRomanNumbers[a]);
            }

            num -= times * allArabianRomanNumbers[a];
        }

        return builder.toString();
    }

    public static void main(String[] args) {
        System.out.println(IntegerToRoman.integerToRoman(2131));
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;

/**
 * Converts any Binary number to an Octal Number
 *
 * @author Zachary Jones
 */
public class BinaryToOctal {

    /**
     * Main method
     *
     * @param args Command line arguments
     */
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Input the binary number: ");
        int b = sc.nextInt();
        System.out.println("Octal equivalent: " + convertBinaryToOctal(b));
        sc.close();
    }

    /**
     * This method converts a binary number to an octal number.
     *
     * @param binary The binary number
     * @return The octal number
     */
    public static String convertBinaryToOctal(int binary) {
        String octal = "";
        int currBit = 0, j = 1;
        while (binary != 0) {
            int code3 = 0;
            for (int i = 0; i < 3; i++) {
                currBit = binary % 10;
                binary = binary / 10;
                code3 += currBit * j;
                j *= 2;
            }
            octal = code3 + octal;
            j = 1;
        }
        return octal;
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;

/**
 * This class converts a Binary number to a Decimal number
 */
class BinaryToDecimal {

    /**
     * Main Method
     *
     * @param args Command line arguments
     */
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int binNum, binCopy, d, s = 0, power = 0;
        System.out.print("Binary number: ");
        binNum = sc.nextInt();
        binCopy = binNum;
        while (binCopy != 0) {
            d = binCopy % 10;
            s += d * (int) Math.pow(2, power++);
            binCopy /= 10;
        }
        System.out.println("Decimal equivalent:" + s);
        sc.close();
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;
// given a source number , source base, destination base, this code can give you the destination
// number.
// sn ,sb,db ---> ()dn  .   this is what we have to do    .

public class AnytoAny {

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int sn = scn.nextInt();
        int sb = scn.nextInt();
        int db = scn.nextInt();
        int m = 1, dec = 0, dn = 0;
        while (sn != 0) {
            dec = dec + (sn % 10) * m;
            m *= sb;
            sn /= 10;
        }
        m = 1;
        while (dec != 0) {
            dn = dn + (dec % db) * m;
            m *= 10;
            dec /= db;
        }
        System.out.println(dn);
        scn.close();
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;

/**
 * This class converts Decimal numbers to Octal Numbers
 */
public class DecimalToOctal {

    /**
     * Main Method
     *
     * @param args Command line Arguments
     */

    // enter in a decimal value to get Octal output
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n, k, d, s = 0, c = 0;
        System.out.print("Decimal number: ");
        n = sc.nextInt();
        k = n;
        while (k != 0) {
            d = k % 8;
            s += d * (int) Math.pow(10, c++);
            k /= 8;
        }

        System.out.println("Octal equivalent:" + s);
        sc.close();
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;

/**
 * Converts any Octal Number to a Decimal Number
 *
 * @author Zachary Jones
 */
public class OctalToDecimal {

    /**
     * Main method
     *
     * @param args Command line arguments
     */
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Octal Input: ");
        String inputOctal = sc.nextLine();
        int result = convertOctalToDecimal(inputOctal);
        if (result != -1) {
            System.out.println("Result convertOctalToDecimal : " + result);
        }
        sc.close();
    }

    /**
     * This method converts an octal number to a decimal number.
     *
     * @param inputOctal The octal number
     * @return The decimal number
     */
    public static int convertOctalToDecimal(String inputOctal) {

        try {
            // Actual conversion of Octal to Decimal:
            Integer outputDecimal = Integer.parseInt(inputOctal, 8);
            return outputDecimal;
        } catch (NumberFormatException ne) {
            // Printing a warning message if the input is not a valid octal
            // number:
            System.out.println("Invalid Input, Expecting octal number 0-7");
            return -1;
        }
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;

/**
 * Converts any Hexadecimal Number to Octal
 *
 * @author Tanmay Joshi
 */
public class HexToOct {

    /**
     * This method converts a Hexadecimal number to a decimal number
     *
     * @param s The Hexadecimal Number
     * @return The Decimal number
     */
    public static int hex2decimal(String s) {
        String str = "0123456789ABCDEF";
        s = s.toUpperCase();
        int val = 0;
        for (int i = 0; i < s.length(); i++) {
            char a = s.charAt(i);
            int n = str.indexOf(a);
            val = 16 * val + n;
        }
        return val;
    }

    /**
     * This method converts a Decimal number to a octal number
     *
     * @param q The Decimal Number
     * @return The Octal number
     */
    public static int decimal2octal(int q) {
        int now;
        int i = 1;
        int octnum = 0;
        while (q > 0) {
            now = q % 8;
            octnum = (now * (int) (Math.pow(10, i))) + octnum;
            q /= 8;
            i++;
        }
        octnum /= 10;
        return octnum;
    }

    /**
     * Main method that gets the hex input from user and converts it into octal.
     *
     * @param args arguments
     */
    public static void main(String args[]) {
        String hexadecnum;
        int decnum, octalnum;
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter Hexadecimal Number : ");
        hexadecnum = scan.nextLine();

        // first convert hexadecimal to decimal
        decnum
                = hex2decimal(
                        hexadecnum); // Pass the string to the hex2decimal function and get the decimal form in
        // variable decnum

        // convert decimal to octal
        octalnum = decimal2octal(decnum);
        System.out.println("Number in octal: " + octalnum);
        scan.close();
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;

/**
 * This class converts a Decimal number to a Binary number
 */
class DecimalToBinary {

    /**
     * Main Method
     *
     * @param args Command Line Arguments
     */
    public static void main(String args[]) {
        conventionalConversion();
        bitwiseConversion();
    }

    /**
     * This method converts a decimal number to a binary number using a
     * conventional algorithm.
     */
    public static void conventionalConversion() {
        int n, b = 0, c = 0, d;
        Scanner input = new Scanner(System.in);
        System.out.printf("Conventional conversion.%n Enter the decimal number: ");
        n = input.nextInt();
        while (n != 0) {
            d = n % 2;
            b = b + d * (int) Math.pow(10, c++);
            n /= 2;
        } // converting decimal to binary
        System.out.println("\tBinary number: " + b);
        input.close();
    }

    /**
     * This method converts a decimal number to a binary number using a bitwise
     * algorithm
     */
    public static void bitwiseConversion() {
        int n, b = 0, c = 0, d;
        Scanner input = new Scanner(System.in);
        System.out.printf("Bitwise conversion.%n Enter the decimal number: ");
        n = input.nextInt();
        while (n != 0) {
            d = (n & 1);
            b += d * (int) Math.pow(10, c++);
            n >>= 1;
        }
        System.out.println("\tBinary number: " + b);
        input.close();
    }
}
package com.thealgorithms.conversions;

import java.util.Arrays;
import java.util.HashSet;
import java.util.InputMismatchException;
import java.util.Scanner;

/**
 * Class for converting from "any" base to "any" other base, when "any" means
 * from 2-36. Works by going from base 1 to decimal to base 2. Includes
 * auxiliary method for determining whether a number is valid for a given base.
 *
 * @author Michael Rolland
 * @version 2017.10.10
 */
public class AnyBaseToAnyBase {

    /**
     * Smallest and largest base you want to accept as valid input
     */
    static final int MINIMUM_BASE = 2;

    static final int MAXIMUM_BASE = 36;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String n;
        int b1, b2;
        while (true) {
            try {
                System.out.print("Enter number: ");
                n = in.next();
                System.out.print(
                        "Enter beginning base (between " + MINIMUM_BASE + " and " + MAXIMUM_BASE + "): ");
                b1 = in.nextInt();
                if (b1 > MAXIMUM_BASE || b1 < MINIMUM_BASE) {
                    System.out.println("Invalid base!");
                    continue;
                }
                if (!validForBase(n, b1)) {
                    System.out.println("The number is invalid for this base!");
                    continue;
                }
                System.out.print(
                        "Enter end base (between " + MINIMUM_BASE + " and " + MAXIMUM_BASE + "): ");
                b2 = in.nextInt();
                if (b2 > MAXIMUM_BASE || b2 < MINIMUM_BASE) {
                    System.out.println("Invalid base!");
                    continue;
                }
                break;
            } catch (InputMismatchException e) {
                System.out.println("Invalid input.");
                in.next();
            }
        }
        System.out.println(base2base(n, b1, b2));
        in.close();
    }

    /**
     * Checks if a number (as a String) is valid for a given base.
     */
    public static boolean validForBase(String n, int base) {
        char[] validDigits = {
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
            'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
        };
        // digitsForBase contains all the valid digits for the base given
        char[] digitsForBase = Arrays.copyOfRange(validDigits, 0, base);

        // Convert character array into set for convenience of contains() method
        HashSet<Character> digitsList = new HashSet<>();
        for (int i = 0; i < digitsForBase.length; i++) {
            digitsList.add(digitsForBase[i]);
        }

        // Check that every digit in n is within the list of valid digits for that base.
        for (char c : n.toCharArray()) {
            if (!digitsList.contains(c)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Method to convert any integer from base b1 to base b2. Works by
     * converting from b1 to decimal, then decimal to b2.
     *
     * @param n The integer to be converted.
     * @param b1 Beginning base.
     * @param b2 End base.
     * @return n in base b2.
     */
    public static String base2base(String n, int b1, int b2) {
        // Declare variables: decimal value of n,
        // character of base b1, character of base b2,
        // and the string that will be returned.
        int decimalValue = 0, charB2;
        char charB1;
        String output = "";
        // Go through every character of n
        for (int i = 0; i < n.length(); i++) {
            // store the character in charB1
            charB1 = n.charAt(i);
            // if it is a non-number, convert it to a decimal value >9 and store it in charB2
            if (charB1 >= 'A' && charB1 <= 'Z') {
                charB2 = 10 + (charB1 - 'A');
            } // Else, store the integer value in charB2
            else {
                charB2 = charB1 - '0';
            }
            // Convert the digit to decimal and add it to the
            // decimalValue of n
            decimalValue = decimalValue * b1 + charB2;
        }

        // Converting the decimal value to base b2:
        // A number is converted from decimal to another base
        // by continuously dividing by the base and recording
        // the remainder until the quotient is zero. The number in the
        // new base is the remainders, with the last remainder
        // being the left-most digit.
        if (0 == decimalValue) {
            return "0";
        }
        // While the quotient is NOT zero:
        while (decimalValue != 0) {
            // If the remainder is a digit < 10, simply add it to
            // the left side of the new number.
            if (decimalValue % b2 < 10) {
                output = Integer.toString(decimalValue % b2) + output;
            } // If the remainder is >= 10, add a character with the
            // corresponding value to the new number. (A = 10, B = 11, C = 12, ...)
            else {
                output = (char) ((decimalValue % b2) + 55) + output;
            }
            // Divide by the new base again
            decimalValue /= b2;
        }
        return output;
    }
}
package com.thealgorithms.conversions;

// Hex [0-9],[A-F] -> Binary [0,1]
public class HexaDecimalToBinary {

    private final int LONG_BITS = 8;

    public void convert(String numHex) {
        // String a HexaDecimal:
        int conHex = Integer.parseInt(numHex, 16);
        // Hex a Binary:
        String binary = Integer.toBinaryString(conHex);
        // Output:
        System.out.println(numHex + " = " + completeDigits(binary));
    }

    public String completeDigits(String binNum) {
        for (int i = binNum.length(); i < LONG_BITS; i++) {
            binNum = "0" + binNum;
        }
        return binNum;
    }

    public static void main(String[] args) {

        // Testing Numbers:
        String[] hexNums = {"1", "A1", "ef", "BA", "AA", "BB", "19", "01", "02", "03", "04"};
        HexaDecimalToBinary objConvert = new HexaDecimalToBinary();

        for (String num : hexNums) {
            objConvert.convert(num);
        }
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;

/**
 * Converts turkish character to latin character
 *
 * @author Özgün Gökşenli
 */
public class TurkishToLatinConversion {

    /**
     * Main method
     *
     * @param args Command line arguments
     */
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Input the string: ");
        String b = sc.next();
        System.out.println("Converted: " + convertTurkishToLatin(b));
        sc.close();
    }

    /**
     * This method converts a turkish character to latin character.
     *
     * @param param String paramter
     * @return String
     */
    public static String convertTurkishToLatin(String param) {
        char[] turkishChars
                = new char[]{0x131, 0x130, 0xFC, 0xDC, 0xF6, 0xD6, 0x15F, 0x15E, 0xE7, 0xC7, 0x11F, 0x11E};
        char[] latinChars = new char[]{'i', 'I', 'u', 'U', 'o', 'O', 's', 'S', 'c', 'C', 'g', 'G'};
        for (int i = 0; i < turkishChars.length; i++) {
            param
                    = param.replaceAll(
                            new String(new char[]{turkishChars[i]}), new String(new char[]{latinChars[i]}));
        }
        return param;
    }
}
package com.thealgorithms.conversions;

import java.util.Arrays;

/**
 * The RGB color model is an additive color model in which red, green, and blue
 * light are added together in various ways to reproduce a broad array of
 * colors. The name of the model comes from the initials of the three additive
 * primary colors, red, green, and blue. Meanwhile, the HSV representation
 * models how colors appear under light. In it, colors are represented using
 * three components: hue, saturation and (brightness-)value. This class provides
 * methods for converting colors from one representation to the other.
 * (description adapted from https://en.wikipedia.org/wiki/RGB_color_model and
 * https://en.wikipedia.org/wiki/HSL_and_HSV).
 */
public class RgbHsvConversion {

    public static void main(String[] args) {
        // Expected RGB-values taken from https://www.rapidtables.com/convert/color/hsv-to-rgb.html

        // Test hsvToRgb-method
        assert Arrays.equals(hsvToRgb(0, 0, 0), new int[]{0, 0, 0});
        assert Arrays.equals(hsvToRgb(0, 0, 1), new int[]{255, 255, 255});
        assert Arrays.equals(hsvToRgb(0, 1, 1), new int[]{255, 0, 0});
        assert Arrays.equals(hsvToRgb(60, 1, 1), new int[]{255, 255, 0});
        assert Arrays.equals(hsvToRgb(120, 1, 1), new int[]{0, 255, 0});
        assert Arrays.equals(hsvToRgb(240, 1, 1), new int[]{0, 0, 255});
        assert Arrays.equals(hsvToRgb(300, 1, 1), new int[]{255, 0, 255});
        assert Arrays.equals(hsvToRgb(180, 0.5, 0.5), new int[]{64, 128, 128});
        assert Arrays.equals(hsvToRgb(234, 0.14, 0.88), new int[]{193, 196, 224});
        assert Arrays.equals(hsvToRgb(330, 0.75, 0.5), new int[]{128, 32, 80});

        // Test rgbToHsv-method
        // approximate-assertions needed because of small deviations due to converting between
        // int-values and double-values.
        assert approximatelyEqualHsv(rgbToHsv(0, 0, 0), new double[]{0, 0, 0});
        assert approximatelyEqualHsv(rgbToHsv(255, 255, 255), new double[]{0, 0, 1});
        assert approximatelyEqualHsv(rgbToHsv(255, 0, 0), new double[]{0, 1, 1});
        assert approximatelyEqualHsv(rgbToHsv(255, 255, 0), new double[]{60, 1, 1});
        assert approximatelyEqualHsv(rgbToHsv(0, 255, 0), new double[]{120, 1, 1});
        assert approximatelyEqualHsv(rgbToHsv(0, 0, 255), new double[]{240, 1, 1});
        assert approximatelyEqualHsv(rgbToHsv(255, 0, 255), new double[]{300, 1, 1});
        assert approximatelyEqualHsv(rgbToHsv(64, 128, 128), new double[]{180, 0.5, 0.5});
        assert approximatelyEqualHsv(rgbToHsv(193, 196, 224), new double[]{234, 0.14, 0.88});
        assert approximatelyEqualHsv(rgbToHsv(128, 32, 80), new double[]{330, 0.75, 0.5});
    }

    /**
     * Conversion from the HSV-representation to the RGB-representation.
     *
     * @param hue Hue of the color.
     * @param saturation Saturation of the color.
     * @param value Brightness-value of the color.
     * @return The tuple of RGB-components.
     */
    public static int[] hsvToRgb(double hue, double saturation, double value) {
        if (hue < 0 || hue > 360) {
            throw new IllegalArgumentException("hue should be between 0 and 360");
        }

        if (saturation < 0 || saturation > 1) {
            throw new IllegalArgumentException("saturation should be between 0 and 1");
        }

        if (value < 0 || value > 1) {
            throw new IllegalArgumentException("value should be between 0 and 1");
        }

        double chroma = value * saturation;
        double hueSection = hue / 60;
        double secondLargestComponent = chroma * (1 - Math.abs(hueSection % 2 - 1));
        double matchValue = value - chroma;

        return getRgbBySection(hueSection, chroma, matchValue, secondLargestComponent);
    }

    /**
     * Conversion from the RGB-representation to the HSV-representation.
     *
     * @param red Red-component of the color.
     * @param green Green-component of the color.
     * @param blue Blue-component of the color.
     * @return The tuple of HSV-components.
     */
    public static double[] rgbToHsv(int red, int green, int blue) {
        if (red < 0 || red > 255) {
            throw new IllegalArgumentException("red should be between 0 and 255");
        }

        if (green < 0 || green > 255) {
            throw new IllegalArgumentException("green should be between 0 and 255");
        }

        if (blue < 0 || blue > 255) {
            throw new IllegalArgumentException("blue should be between 0 and 255");
        }

        double dRed = (double) red / 255;
        double dGreen = (double) green / 255;
        double dBlue = (double) blue / 255;
        double value = Math.max(Math.max(dRed, dGreen), dBlue);
        double chroma = value - Math.min(Math.min(dRed, dGreen), dBlue);
        double saturation = value == 0 ? 0 : chroma / value;
        double hue;

        if (chroma == 0) {
            hue = 0;
        } else if (value == dRed) {
            hue = 60 * (0 + (dGreen - dBlue) / chroma);
        } else if (value == dGreen) {
            hue = 60 * (2 + (dBlue - dRed) / chroma);
        } else {
            hue = 60 * (4 + (dRed - dGreen) / chroma);
        }

        hue = (hue + 360) % 360;

        return new double[]{hue, saturation, value};
    }

    private static boolean approximatelyEqualHsv(double[] hsv1, double[] hsv2) {
        boolean bHue = Math.abs(hsv1[0] - hsv2[0]) < 0.2;
        boolean bSaturation = Math.abs(hsv1[1] - hsv2[1]) < 0.002;
        boolean bValue = Math.abs(hsv1[2] - hsv2[2]) < 0.002;

        return bHue && bSaturation && bValue;
    }

    private static int[] getRgbBySection(
            double hueSection, double chroma, double matchValue, double secondLargestComponent) {
        int red;
        int green;
        int blue;

        if (hueSection >= 0 && hueSection <= 1) {
            red = convertToInt(chroma + matchValue);
            green = convertToInt(secondLargestComponent + matchValue);
            blue = convertToInt(matchValue);
        } else if (hueSection > 1 && hueSection <= 2) {
            red = convertToInt(secondLargestComponent + matchValue);
            green = convertToInt(chroma + matchValue);
            blue = convertToInt(matchValue);
        } else if (hueSection > 2 && hueSection <= 3) {
            red = convertToInt(matchValue);
            green = convertToInt(chroma + matchValue);
            blue = convertToInt(secondLargestComponent + matchValue);
        } else if (hueSection > 3 && hueSection <= 4) {
            red = convertToInt(matchValue);
            green = convertToInt(secondLargestComponent + matchValue);
            blue = convertToInt(chroma + matchValue);
        } else if (hueSection > 4 && hueSection <= 5) {
            red = convertToInt(secondLargestComponent + matchValue);
            green = convertToInt(matchValue);
            blue = convertToInt(chroma + matchValue);
        } else {
            red = convertToInt(chroma + matchValue);
            green = convertToInt(matchValue);
            blue = convertToInt(secondLargestComponent + matchValue);
        }

        return new int[]{red, green, blue};
    }

    private static int convertToInt(double input) {
        return (int) Math.round(255 * input);
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;

/**
 * Converts any Octal Number to HexaDecimal
 *
 * @author Tanmay Joshi
 */
public class OctalToHexadecimal {

    /**
     * This method converts a Octal number to a decimal number
     *
     * @param s The Octal Number
     * @return The Decimal number
     */
    public static int octToDec(String s) {
        int i = 0;
        for (int j = 0; j < s.length(); j++) {
            char num = s.charAt(j);
            num -= '0';
            i *= 8;
            i += num;
        }
        return i;
    }

    /**
     * This method converts a Decimal number to a Hexadecimal number
     *
     * @param d The Decimal Number
     * @return The Hexadecimal number
     */
    public static String decimalToHex(int d) {
        String digits = "0123456789ABCDEF";
        if (d <= 0) {
            return "0";
        }
        String hex = "";
        while (d > 0) {
            int digit = d % 16;
            hex = digits.charAt(digit) + hex;
            d = d / 16;
        }
        return hex;
    }

    public static void main(String args[]) {

        Scanner input = new Scanner(System.in);
        System.out.print("Enter the Octal number: ");
        // Take octal number as input from user in a string
        String oct = input.next();

        // Pass the octal number to function and get converted decimal form
        int decimal = octToDec(oct);

        // Pass the decimal number to function and get converted Hex form of the number
        String hex = decimalToHex(decimal);
        System.out.println("The Hexadecimal equivalant is: " + hex);
        input.close();
    }
}
package com.thealgorithms.conversions;

import java.util.*;

public class RomanToInteger {

    private static Map<Character, Integer> map
            = new HashMap<Character, Integer>() {
        /**
         *          */
        private static final long serialVersionUID = 87605733047260530L;

        {
            put('I', 1);
            put('V', 5);
            put('X', 10);
            put('L', 50);
            put('C', 100);
            put('D', 500);
            put('M', 1000);
        }
    };
    // Roman Number = Roman Numerals

    /**
     * This function convert Roman number into Integer
     *
     * @param A Roman number string
     * @return integer
     */
    public static int romanToInt(String A) {

        A = A.toUpperCase();
        char prev = ' ';

        int sum = 0;

        int newPrev = 0;
        for (int i = A.length() - 1; i >= 0; i--) {
            char c = A.charAt(i);

            if (prev != ' ') {
                // checking current Number greater then previous or not
                newPrev = map.get(prev) > newPrev ? map.get(prev) : newPrev;
            }

            int currentNum = map.get(c);

            // if current number greater then prev max previous then add
            if (currentNum >= newPrev) {
                sum += currentNum;
            } else {
                // subtract upcoming number until upcoming number not greater then prev max
                sum -= currentNum;
            }

            prev = c;
        }

        return sum;
    }

    public static void main(String[] args) {
        int sum = romanToInt("MDCCCIV");
        System.out.println(sum);
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;

public class HexaDecimalToDecimal {

    // convert hexadecimal to decimal
    public static int getHexaToDec(String hex) {
        String digits = "0123456789ABCDEF";
        hex = hex.toUpperCase();
        int val = 0;
        for (int i = 0; i < hex.length(); i++) {
            int d = digits.indexOf(hex.charAt(i));
            val = 16 * val + d;
        }
        return val;
    }

    // Main method gets the hexadecimal input from user and converts it into Decimal output.
    public static void main(String args[]) {
        String hexa_Input;
        int dec_output;
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter Hexadecimal Number : ");
        hexa_Input = scan.nextLine();

        // convert hexadecimal to decimal
        dec_output = getHexaToDec(hexa_Input);
        /*
    Pass the string to the getHexaToDec function
    and it returns the decimal form in the variable dec_output.
         */
        System.out.println("Number in Decimal: " + dec_output);
        scan.close();
    }
}
package com.thealgorithms.conversions;

// hex = [0 - 9] -> [A - F]
class DecimalToHexaDecimal {

    private static final int sizeOfIntInHalfBytes = 8;
    private static final int numberOfBitsInAHalfByte = 4;
    private static final int halfByte = 0x0F;
    private static final char[] hexDigits = {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
    };

    // Returns the hex value of the dec entered in the parameter.
    public static String decToHex(int dec) {
        StringBuilder hexBuilder = new StringBuilder(sizeOfIntInHalfBytes);
        hexBuilder.setLength(sizeOfIntInHalfBytes);
        for (int i = sizeOfIntInHalfBytes - 1; i >= 0; --i) {
            int j = dec & halfByte;
            hexBuilder.setCharAt(i, hexDigits[j]);
            dec >>= numberOfBitsInAHalfByte;
        }
        return hexBuilder.toString().toLowerCase();
    }

    // Test above function.
    public static void main(String[] args) {
        System.out.println("Test...");
        int dec = 305445566;
        String libraryDecToHex = Integer.toHexString(dec);
        String decToHex = decToHex(dec);
        System.out.println("Result from the library : " + libraryDecToHex);
        System.out.println("Result decToHex method : " + decToHex);
    }
}
package com.thealgorithms.conversions;

import java.util.*;

/**
 * Converts any Binary Number to a Hexadecimal Number
 *
 * @author Nishita Aggarwal
 */
public class BinaryToHexadecimal {

    /**
     * This method converts a binary number to a hexadecimal number.
     *
     * @param binary The binary number
     * @return The hexadecimal number
     */
    static String binToHex(int binary) {
        // hm to store hexadecimal codes for binary numbers within the range: 0000 to 1111 i.e. for
        // decimal numbers 0 to 15
        HashMap<Integer, String> hm = new HashMap<>();
        // String to store hexadecimal code
        String hex = "";
        int i;
        for (i = 0; i < 10; i++) {
            hm.put(i, String.valueOf(i));
        }
        for (i = 10; i < 16; i++) {
            hm.put(i, String.valueOf((char) ('A' + i - 10)));
        }
        int currbit;
        while (binary != 0) {
            int code4 = 0; // to store decimal equivalent of number formed by 4 decimal digits
            for (i = 0; i < 4; i++) {
                currbit = binary % 10;
                binary = binary / 10;
                code4 += currbit * Math.pow(2, i);
            }
            hex = hm.get(code4) + hex;
        }
        return hex;
    }

    /**
     * Main method
     *
     * @param args Command line arguments
     */
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter binary number:");
        int binary = sc.nextInt();
        String hex = binToHex(binary);
        System.out.println("Hexadecimal Code:" + hex);
        sc.close();
    }
}
package com.thealgorithms.conversions;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

/**
 * @author Varun Upadhyay (https://github.com/varunu28)
 */
// Driver Program
public class DecimalToAnyBase {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter the decimal input below: ");
        int decInput = Integer.parseInt(br.readLine());
        System.out.println();

        System.out.println("Enter the base below: ");
        int base = Integer.parseInt(br.readLine());
        System.out.println();

        System.out.println("Decimal Input" + " is: " + decInput);
        System.out.println(
                "Value of " + decInput + " in base " + base + " is: " + convertToAnyBase(decInput, base));

        br.close();
    }

    /**
     * This method produces a String value of any given input decimal in any
     * base
     *
     * @param inp Decimal of which we need the value in base in String format
     * @return string format of the converted value in the given base
     */
    public static String convertToAnyBase(int inp, int base) {
        ArrayList<Character> charArr = new ArrayList<>();

        while (inp > 0) {
            charArr.add(reVal(inp % base));
            inp /= base;
        }

        StringBuilder str = new StringBuilder(charArr.size());

        for (Character ch : charArr) {
            str.append(ch);
        }

        return str.reverse().toString();
    }

    /**
     * This method produces character value of the input integer and returns it
     *
     * @param num integer of which we need the character value of
     * @return character value of input integer
     */
    public static char reVal(int num) {
        if (num >= 0 && num <= 9) {
            return (char) (num + '0');
        } else {
            return (char) (num - 10 + 'A');
        }
    }
}
package com.thealgorithms.backtracking;

import java.util.*;

/**
 * Finds all permutations of given array
 * @author Alan Piao (https://github.com/cpiao3)
 */
public class Combination {
    private static int length;
    /**
     * Find all combinations of given array using backtracking
     * @param arr the array.
     * @param n length of combination
     * @param <T> the type of elements in the array.
     * @return a list of all combinations of length n. If n == 0, return null.
     */
    public static <T> List<TreeSet<T>> combination(T[] arr, int n) {
        if (n == 0) {
            return null;
        }
        length = n;
        T[] array = arr.clone();
        Arrays.sort(array);
        List<TreeSet<T>> result = new LinkedList<>();
        backtracking(array, 0, new TreeSet<T>(), result);
        return result;
    }
    /**
     * Backtrack all possible combinations of a given array
     * @param arr the array.
     * @param index the starting index.
     * @param currSet set that tracks current combination
     * @param result the list contains all combination.
     * @param <T> the type of elements in the array.
     */
    private static <T> void backtracking(T[] arr, int index, TreeSet<T> currSet, List<TreeSet<T>> result) {
        if (index + length - currSet.size() > arr.length) return;
        if (length - 1 == currSet.size()) {
            for (int i = index; i < arr.length; i++) {
                currSet.add(arr[i]);
                result.add((TreeSet<T>) currSet.clone());
                currSet.remove(arr[i]);
            }
        }
        for (int i = index; i < arr.length; i++) {
            currSet.add(arr[i]);
            backtracking(arr, i + 1, currSet, result);
            currSet.remove(arr[i]);
        }
    }
}
package com.thealgorithms.backtracking;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

/**
 * Finds all permutations of given array
 * @author Alan Piao (https://github.com/cpiao3)
 */
public class Permutation {
    /**
     * Find all permutations of given array using backtracking
     * @param arr the array.
     * @param <T> the type of elements in the array.
     * @return a list of all permutations.
     */
    public static <T> List<T[]> permutation(T[] arr) {
        T[] array = arr.clone();
        List<T[]> result = new LinkedList<>();
        backtracking(array, 0, result);
        return result;
    }
    /**
     * Backtrack all possible orders of a given array
     * @param arr the array.
     * @param index the starting index.
     * @param result the list contains all permutations.
     * @param <T> the type of elements in the array.
     */
    private static <T> void backtracking(T[] arr, int index, List<T[]> result) {
        if (index == arr.length) {
            result.add(arr.clone());
        }
        for (int i = index; i < arr.length; i++) {
            swap(index, i, arr);
            backtracking(arr, index + 1, result);
            swap(index, i, arr);
        }
    }
    /**
     * Swap two element for a given array
     * @param a first index
     * @param b second index
     * @param arr the array.
     * @param <T> the type of elements in the array.
     */
    private static <T> void swap(int a, int b, T[] arr) {
        T temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
package com.thealgorithms.backtracking;

import java.util.Scanner;

/*
 * Problem Statement :
 * Find the number of ways that a given integer, N , can be expressed as the sum of the Xth powers of unique, natural numbers.
 * For example, if N=100 and X=3, we have to find all combinations of unique cubes adding up to 100. The only solution is 1^3+2^3+3^3+4^3.
 * Therefore output will be 1.
 */
public class PowerSum {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the number and the power");
        int N = sc.nextInt();
        int X = sc.nextInt();
        PowerSum ps = new PowerSum();
        int count = ps.powSum(N, X);
        //printing the answer.
        System.out.println("Number of combinations of different natural number's raised to " + X + " having sum " + N + " are : ");
        System.out.println(count);
        sc.close();
    }
    private int count = 0, sum = 0;

    public int powSum(int N, int X) {
        Sum(N, X, 1);
        return count;
    }

    //here i is the natural number which will be raised by X and added in sum.
    public void Sum(int N, int X, int i) {
        //if sum is equal to N that is one of our answer and count is increased.
        if (sum == N) {
            count++;
            return;
        } //we will be adding next natural number raised to X only if on adding it in sum the result is less than N.
        else if (sum + power(i, X) <= N) {
            sum += power(i, X);
            Sum(N, X, i + 1);
            //backtracking and removing the number added last since no possible combination is there with it.
            sum -= power(i, X);
        }
        if (power(i, X) < N) {
            //calling the sum function with next natural number after backtracking if when it is raised to X is still less than X.
            Sum(N, X, i + 1);
        }
    }

    //creating a separate power function so that it can be used again and again when required. 
    private int power(int a, int b) {
        return (int) Math.pow(a, b);
    }
}
package com.thealgorithms.backtracking;

import java.util.ArrayList;
import java.util.List;

/**
 * Problem statement: Given a N x N chess board. Return all arrangements in
 * which N queens can be placed on the board such no two queens attack each
 * other. Ex. N = 6 Solution= There are 4 possible ways Arrangement: 1 ".Q....",
 * "...Q..", ".....Q", "Q.....", "..Q...", "....Q."
 * <p>
 * Arrangement: 2 "..Q...", ".....Q", ".Q....", "....Q.", "Q.....", "...Q.."
 * <p>
 * Arrangement: 3 "...Q..", "Q.....", "....Q.", ".Q....", ".....Q", "..Q..."
 * <p>
 * Arrangement: 4 "....Q.", "..Q...", "Q.....", ".....Q", "...Q..", ".Q...."
 *
 * Solution: Brute Force approach:
 *
 * Generate all possible arrangement to place N queens on N*N board. Check each
 * board if queens are placed safely. If it is safe, include arrangement in
 * solution set. Otherwise ignore it
 *
 * Optimized solution: This can be solved using backtracking in below steps
 *
 * Start with first column and place queen on first row Try placing queen in a
 * row on second column If placing second queen in second column attacks any of
 * the previous queens, change the row in second column otherwise move to next
 * column and try to place next queen In case if there is no rows where a queen
 * can be placed such that it doesn't attack previous queens, then go back to
 * previous column and change row of previous queen. Keep doing this until last
 * queen is not placed safely. If there is no such way then return an empty list
 * as solution
 */
public class NQueens {

    public static void main(String[] args) {
        placeQueens(1);
        placeQueens(2);
        placeQueens(3);
        placeQueens(4);
        placeQueens(5);
        placeQueens(6);
    }

    public static void placeQueens(final int queens) {
        List<List<String>> arrangements = new ArrayList<List<String>>();
        getSolution(queens, arrangements, new int[queens], 0);
        if (arrangements.isEmpty()) {
            System.out.println("There is no way to place " + queens + " queens on board of size " + queens + "x" + queens);
        } else {
            System.out.println("Arrangement for placing " + queens + " queens");
        }
        arrangements.forEach(arrangement -> {
            arrangement.forEach(row -> System.out.println(row));
            System.out.println();
        });
    }

    /**
     * This is backtracking function which tries to place queen recursively
     *
     * @param boardSize: size of chess board
     * @param solutions: this holds all possible arrangements
     * @param columns: columns[i] = rowId where queen is placed in ith column.
     * @param columnIndex: This is the column in which queen is being placed
     */
    private static void getSolution(int boardSize, List<List<String>> solutions, int[] columns, int columnIndex) {
        if (columnIndex == boardSize) {
            // this means that all queens have been placed
            List<String> sol = new ArrayList<String>();
            for (int i = 0; i < boardSize; i++) {
                StringBuilder sb = new StringBuilder();
                for (int j = 0; j < boardSize; j++) {
                    sb.append(j == columns[i] ? "Q" : ".");
                }
                sol.add(sb.toString());
            }
            solutions.add(sol);
            return;
        }

        // This loop tries to place queen in a row one by one
        for (int rowIndex = 0; rowIndex < boardSize; rowIndex++) {
            columns[columnIndex] = rowIndex;
            if (isPlacedCorrectly(columns, rowIndex, columnIndex)) {
                // If queen is placed successfully at rowIndex in column=columnIndex then try placing queen in next column
                getSolution(boardSize, solutions, columns, columnIndex + 1);
            }
        }
    }

    /**
     * This function checks if queen can be placed at row = rowIndex in column =
     * columnIndex safely
     *
     * @param columns: columns[i] = rowId where queen is placed in ith column.
     * @param rowIndex: row in which queen has to be placed
     * @param columnIndex: column in which queen is being placed
     * @return true: if queen can be placed safely false: otherwise
     */
    private static boolean isPlacedCorrectly(int[] columns, int rowIndex, int columnIndex) {
        for (int i = 0; i < columnIndex; i++) {
            int diff = Math.abs(columns[i] - rowIndex);
            if (diff == 0 || columnIndex - i == diff) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.backtracking;

/**
 * Java program for Flood fill algorithm.
 * @author Akshay Dubey (https://github.com/itsAkshayDubey)
 */
public class FloodFill {

    /**
     * Get the color at the given co-odrinates of a 2D image
     *
     * @param image The image to be filled
     * @param x The x co-ordinate of which color is to be obtained
     * @param y The y co-ordinate of which color is to be obtained
     */
	
	public static int getPixel(int[][] image, int x, int y) {
	
		return image[x][y];
	
	}
	
    /**
     * Put the color at the given co-odrinates of a 2D image
     *
     * @param image The image to be filed
     * @param x The x co-ordinate at which color is to be filled
     * @param y The y co-ordinate at which color is to be filled
     */
	public static void putPixel(int[][] image, int x, int y, int newColor) {
		
		image[x][y] = newColor;
	
	}
	
	
    /**
     * Fill the 2D image with new color
     *
     * @param image The image to be filed
     * @param x The x co-ordinate at which color is to be filled
     * @param y The y co-ordinate at which color is to be filled
     * @param newColor The new color which to be filled in the image
     * @param oldColor The old color which is to be replaced in the image
     * @return
     */
	public static void floodFill(int[][] image, int x, int y, int newColor, int oldColor) {

		if(x < 0 || x >= image.length) return;
		if(y < 0 || y >= image[x].length) return;
		if(getPixel(image, x, y) != oldColor) return;

		putPixel(image, x, y, newColor);

		/* Recursively check for horizontally & vertically adjacent coordinates */
		floodFill(image, x + 1, y, newColor, oldColor);
		floodFill(image, x - 1, y, newColor, oldColor);
		floodFill(image, x, y + 1, newColor, oldColor);
		floodFill(image, x, y - 1, newColor, oldColor);

		/* Recursively check for diagonally adjacent coordinates  */
		floodFill(image, x + 1, y - 1, newColor, oldColor);
		floodFill(image, x - 1, y + 1, newColor, oldColor);
		floodFill(image, x + 1, y + 1, newColor, oldColor);
		floodFill(image, x - 1, y - 1, newColor, oldColor);

	}

}package com.thealgorithms.backtracking;

import java.util.*;

/*
    * Problem Statement: -
    
    Given a N*N board with the Knight placed on the first block of an empty board. Moving according to the rules of
    chess knight must visit each square exactly once. Print the order of each cell in which they are visited.

    Example: -

    Input : N = 8

    Output:
        0  59  38  33  30  17   8  63
        37  34  31  60   9  62  29  16
        58   1  36  39  32  27  18   7
        35  48  41  26  61  10  15  28
        42  57   2  49  40  23   6  19
        47  50  45  54  25  20  11  14
        56  43  52   3  22  13  24   5
        51  46  55  44  53   4  21  12

 */
public class KnightsTour {

    private final static int base = 12;
    private final static int[][] moves = {{1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}}; // Possible moves by knight on chess
    private static int[][] grid;    // chess grid
    private static int total;   // total squares in chess

    public static void main(String[] args) {
        grid = new int[base][base];
        total = (base - 4) * (base - 4);

        for (int r = 0; r < base; r++) {
            for (int c = 0; c < base; c++) {
                if (r < 2 || r > base - 3 || c < 2 || c > base - 3) {
                    grid[r][c] = -1;
                }
            }
        }

        int row = 2 + (int) (Math.random() * (base - 4));
        int col = 2 + (int) (Math.random() * (base - 4));

        grid[row][col] = 1;

        if (solve(row, col, 2)) {
            printResult();
        } else {
            System.out.println("no result");
        }

    }

    // Return True when solvable
    private static boolean solve(int row, int column, int count) {
        if (count > total) {
            return true;
        }

        List<int[]> neighbor = neighbors(row, column);

        if (neighbor.isEmpty() && count != total) {
            return false;
        }

        Collections.sort(neighbor, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return a[2] - b[2];
            }
        });

        for (int[] nb : neighbor) {
            row = nb[0];
            column = nb[1];
            grid[row][column] = count;
            if (!orphanDetected(count, row, column) && solve(row, column, count + 1)) {
                return true;
            }
            grid[row][column] = 0;
        }

        return false;
    }

    // Returns List of neighbours
    private static List<int[]> neighbors(int row, int column) {
        List<int[]> neighbour = new ArrayList<>();

        for (int[] m : moves) {
            int x = m[0];
            int y = m[1];
            if (grid[row + y][column + x] == 0) {
                int num = countNeighbors(row + y, column + x);
                neighbour.add(new int[]{row + y, column + x, num});
            }
        }
        return neighbour;
    }

    // Returns the total count of neighbors
    private static int countNeighbors(int row, int column) {
        int num = 0;
        for (int[] m : moves) {
            if (grid[row + m[1]][column + m[0]] == 0) {
                num++;
            }
        }
        return num;
    }

    // Returns true if it is orphan
    private static boolean orphanDetected(int count, int row, int column) {
        if (count < total - 1) {
            List<int[]> neighbor = neighbors(row, column);
            for (int[] nb : neighbor) {
                if (countNeighbors(nb[0], nb[1]) == 0) {
                    return true;
                }
            }
        }
        return false;
    }

    // Prints the result grid
    private static void printResult() {
        for (int[] row : grid) {
            for (int i : row) {
                if (i == -1) {
                    continue;
                }
                System.out.printf("%2d ", i);
            }
            System.out.println();
        }
    }
}
package com.thealgorithms.others;

/**
 * Guass Legendre Algorithm ref
 * https://en.wikipedia.org/wiki/Gauss–Legendre_algorithm
 *
 * @author AKS1996
 */
public class GuassLegendre {

    public static void main(String[] args) {
        for (int i = 1; i <= 3; ++i) {
            System.out.println(pi(i));
        }
    }

    static double pi(int l) {
        /*
     * l: No of loops to run
         */

        double a = 1, b = Math.pow(2, -0.5), t = 0.25, p = 1;
        for (int i = 0; i < l; ++i) {
            double temp[] = update(a, b, t, p);
            a = temp[0];
            b = temp[1];
            t = temp[2];
            p = temp[3];
        }

        return Math.pow(a + b, 2) / (4 * t);
    }

    static double[] update(double a, double b, double t, double p) {
        double values[] = new double[4];
        values[0] = (a + b) / 2;
        values[1] = Math.sqrt(a * b);
        values[2] = t - p * Math.pow(a - values[0], 2);
        values[3] = 2 * p;

        return values;
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

public class RootPrecision {

    public static void main(String[] args) {
        // take input
        Scanner scn = new Scanner(System.in);

        // N is the input number
        int N = scn.nextInt();

        // P is precision value for eg - P is 3 in 2.564 and 5 in 3.80870.
        int P = scn.nextInt();
        System.out.println(squareRoot(N, P));

        scn.close();
    }

    public static double squareRoot(int N, int P) {
        // rv means return value
        double rv;

        double root = Math.pow(N, 0.5);

        // calculate precision to power of 10 and then multiply it with root value.
        int precision = (int) Math.pow(10, P);
        root = root * precision;
        /*typecast it into integer then divide by precision and again typecast into double
    so as to have decimal points upto P precision */

        rv = (int) root;
        return rv / precision;
    }
}
package com.thealgorithms.others;

/*
 * A left rotation operation on an array
 * shifts each of the array's elements
 * given integer n unit to the left.
 * 
 * @author sangin-lee 
 */

public class ArrayLeftRotation {

	/*
	 * Returns the result of left rotation of given array arr and integer n
	 * 
	 * @param arr : int[] given array
	 * 
	 * @param n : int given integer
	 * 
	 * @return : int[] result of left rotation
	 */
	public static int[] rotateLeft(int[] arr, int n) {
		int size = arr.length;
		int[] dst = new int[size];
		n = n % size;
		for(int i = 0; i < size; i++) {
			dst[i] = arr[n];
			n = (n + 1) % size;
		}
		return dst;
	}

}
package com.thealgorithms.others;

import java.util.*;

public class StackPostfixNotation {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String post = scanner.nextLine(); // Takes input with spaces in between eg. "1 21 +"
        System.out.println(postfixEvaluate(post));
        scanner.close();
    }

    // Evaluates the given postfix expression string and returns the result.
    public static int postfixEvaluate(String exp) {
        Stack<Integer> s = new Stack<Integer>();
        Scanner tokens = new Scanner(exp);

        while (tokens.hasNext()) {
            if (tokens.hasNextInt()) {
                s.push(tokens.nextInt()); // If int then push to stack
            } else { // else pop top two values and perform the operation
                int num2 = s.pop();
                int num1 = s.pop();
                String op = tokens.next();

                if (op.equals("+")) {
                    s.push(num1 + num2);
                } else if (op.equals("-")) {
                    s.push(num1 - num2);
                } else if (op.equals("*")) {
                    s.push(num1 * num2);
                } else {
                    s.push(num1 / num2);
                }

                //  "+", "-", "*", "/"
            }
        }
        tokens.close();
        return s.pop();
    }
}
package com.thealgorithms.others;

import java.util.Random;
import java.util.Scanner;

/**
 * For detailed info and implementation see: <a
 * href="http://devmag.org.za/2009/04/25/perlin-noise/">Perlin-Noise</a>
 */
public class PerlinNoise {

    /**
     * @param width width of noise array
     * @param height height of noise array
     * @param octaveCount numbers of layers used for blending noise
     * @param persistence value of impact each layer get while blending
     * @param seed used for randomizer
     * @return float array containing calculated "Perlin-Noise" values
     */
    static float[][] generatePerlinNoise(
            int width, int height, int octaveCount, float persistence, long seed) {
        final float[][] base = new float[width][height];
        final float[][] perlinNoise = new float[width][height];
        final float[][][] noiseLayers = new float[octaveCount][][];

        Random random = new Random(seed);
        // fill base array with random values as base for noise
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                base[x][y] = random.nextFloat();
            }
        }

        // calculate octaves with different roughness
        for (int octave = 0; octave < octaveCount; octave++) {
            noiseLayers[octave] = generatePerlinNoiseLayer(base, width, height, octave);
        }

        float amplitude = 1f;
        float totalAmplitude = 0f;

        // calculate perlin noise by blending each layer together with specific persistence
        for (int octave = octaveCount - 1; octave >= 0; octave--) {
            amplitude *= persistence;
            totalAmplitude += amplitude;

            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                    // adding each value of the noise layer to the noise
                    // by increasing amplitude the rougher noises will have more impact
                    perlinNoise[x][y] += noiseLayers[octave][x][y] * amplitude;
                }
            }
        }

        // normalize values so that they stay between 0..1
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                perlinNoise[x][y] /= totalAmplitude;
            }
        }

        return perlinNoise;
    }

    /**
     * @param base base random float array
     * @param width width of noise array
     * @param height height of noise array
     * @param octave current layer
     * @return float array containing calculated "Perlin-Noise-Layer" values
     */
    static float[][] generatePerlinNoiseLayer(float[][] base, int width, int height, int octave) {
        float[][] perlinNoiseLayer = new float[width][height];

        // calculate period (wavelength) for different shapes
        int period = 1 << octave; // 2^k
        float frequency = 1f / period; // 1/2^k

        for (int x = 0; x < width; x++) {
            // calculates the horizontal sampling indices
            int x0 = (x / period) * period;
            int x1 = (x0 + period) % width;
            float horizintalBlend = (x - x0) * frequency;

            for (int y = 0; y < height; y++) {
                // calculates the vertical sampling indices
                int y0 = (y / period) * period;
                int y1 = (y0 + period) % height;
                float verticalBlend = (y - y0) * frequency;

                // blend top corners
                float top = interpolate(base[x0][y0], base[x1][y0], horizintalBlend);

                // blend bottom corners
                float bottom = interpolate(base[x0][y1], base[x1][y1], horizintalBlend);

                // blend top and bottom interpolation to get the final blend value for this cell
                perlinNoiseLayer[x][y] = interpolate(top, bottom, verticalBlend);
            }
        }

        return perlinNoiseLayer;
    }

    /**
     * @param a value of point a
     * @param b value of point b
     * @param alpha determine which value has more impact (closer to 0 -> a,
     * closer to 1 -> b)
     * @return interpolated value
     */
    static float interpolate(float a, float b, float alpha) {
        return a * (1 - alpha) + alpha * b;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        final int width;
        final int height;
        final int octaveCount;
        final float persistence;
        final long seed;
        final String charset;
        final float[][] perlinNoise;

        System.out.println("Width (int): ");
        width = in.nextInt();

        System.out.println("Height (int): ");
        height = in.nextInt();

        System.out.println("Octave count (int): ");
        octaveCount = in.nextInt();

        System.out.println("Persistence (float): ");
        persistence = in.nextFloat();

        System.out.println("Seed (long): ");
        seed = in.nextLong();

        System.out.println("Charset (String): ");
        charset = in.next();

        perlinNoise = generatePerlinNoise(width, height, octaveCount, persistence, seed);
        final char[] chars = charset.toCharArray();
        final int length = chars.length;
        final float step = 1f / length;
        // output based on charset
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                float value = step;
                float noiseValue = perlinNoise[x][y];

                for (char c : chars) {
                    if (noiseValue <= value) {
                        System.out.print(c);
                        break;
                    }

                    value += step;
                }
            }

            System.out.println();
        }
        in.close();
    }
}
package com.thealgorithms.others;

import java.util.Arrays;
import java.util.Scanner;

/**
 * To find triplet equals to given sum in complexity O(n*log(n))
 *
 * <p>
 * Array must be sorted
 *
 * @author Ujjawal Joshi
 * @date 2020.05.18
 * <p>
 * Test Cases: Input: 6 //Length of array 12 3 4 1 6 9 target=24 Output:3 9 12
 * Explanation: There is a triplet (12, 3 and 9) present in the array whose sum
 * is 24.
 */
class ThreeSum {

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // Length of an array

        int a[] = new int[n];

        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        System.out.println("Target");
        int n_find = sc.nextInt();

        Arrays.sort(a); // Sort the array if array is not sorted

        for (int i = 0; i < n; i++) {

            int l = i + 1, r = n - 1;

            while (l < r) {
                if (a[i] + a[l] + a[r] == n_find) {
                    System.out.println(a[i] + " " + a[l] + " " + a[r]);
                    break;
                } // if you want all the triplets write l++;r--; insted of break;
                else if (a[i] + a[l] + a[r] < n_find) {
                    l++;
                } else {
                    r--;
                }
            }
        }

        sc.close();
    }
}
package com.thealgorithms.others;

import java.util.Stack;

/**
 * This implements Queue using two Stacks.
 *
 * <p>
 * Big O Runtime: insert(): O(1) remove(): O(1) amortized isEmpty(): O(1)
 *
 * <p>
 * A queue data structure functions the same as a real world queue. The elements
 * that are added first are the first to be removed. New elements are added to
 * the back/rear of the queue.
 *
 * @author sahilb2 (https://www.github.com/sahilb2)
 */
class QueueWithStack {

    // Stack to keep track of elements inserted into the queue
    private Stack<Object> inStack;
    // Stack to keep track of elements to be removed next in queue
    private Stack<Object> outStack;

    /**
     * Constructor
     */
    public QueueWithStack() {
        this.inStack = new Stack<>();
        this.outStack = new Stack<>();
    }

    /**
     * Inserts an element at the rear of the queue
     *
     * @param x element to be added
     */
    public void insert(Object x) {
        // Insert element into inStack
        this.inStack.push(x);
    }

    /**
     * Remove an element from the front of the queue
     *
     * @return the new front of the queue
     */
    public Object remove() {
        if (this.outStack.isEmpty()) {
            // Move all elements from inStack to outStack (preserving the order)
            while (!this.inStack.isEmpty()) {
                this.outStack.push(this.inStack.pop());
            }
        }
        return this.outStack.pop();
    }

    /**
     * Peek at the element from the front of the queue
     *
     * @return the front element of the queue
     */
    public Object peekFront() {
        if (this.outStack.isEmpty()) {
            // Move all elements from inStack to outStack (preserving the order)
            while (!this.inStack.isEmpty()) {
                this.outStack.push(this.inStack.pop());
            }
        }
        return this.outStack.peek();
    }

    /**
     * Peek at the element from the back of the queue
     *
     * @return the back element of the queue
     */
    public Object peekBack() {
        return this.inStack.peek();
    }

    /**
     * Returns true if the queue is empty
     *
     * @return true if the queue is empty
     */
    public boolean isEmpty() {
        return (this.inStack.isEmpty() && this.outStack.isEmpty());
    }

    /**
     * Returns true if the inStack is empty.
     *
     * @return true if the inStack is empty.
     */
    public boolean isInStackEmpty() {
        return (inStack.size() == 0);
    }

    /**
     * Returns true if the outStack is empty.
     *
     * @return true if the outStack is empty.
     */
    public boolean isOutStackEmpty() {
        return (outStack.size() == 0);
    }
}

/**
 * This class is the example for the Queue class
 *
 * @author sahilb2 (https://www.github.com/sahilb2)
 */
public class QueueUsingTwoStacks {

    /**
     * Main method
     *
     * @param args Command line arguments
     */
    public static void main(String args[]) {
        QueueWithStack myQueue = new QueueWithStack();
        myQueue.insert(1);
        System.out.println(myQueue.peekBack()); // Will print 1
        // instack: [(top) 1]
        // outStack: []
        myQueue.insert(2);
        System.out.println(myQueue.peekBack()); // Will print 2
        // instack: [(top) 2, 1]
        // outStack: []
        myQueue.insert(3);
        System.out.println(myQueue.peekBack()); // Will print 3
        // instack: [(top) 3, 2, 1]
        // outStack: []
        myQueue.insert(4);
        System.out.println(myQueue.peekBack()); // Will print 4
        // instack: [(top) 4, 3, 2, 1]
        // outStack: []

        System.out.println(myQueue.isEmpty()); // Will print false

        System.out.println(myQueue.remove()); // Will print 1
        System.out.println((myQueue.isInStackEmpty()) ? "null" : myQueue.peekBack()); // Will print NULL
        // instack: []
        // outStack: [(top) 2, 3, 4]

        myQueue.insert(5);
        System.out.println(myQueue.peekFront()); // Will print 2
        // instack: [(top) 5]
        // outStack: [(top) 2, 3, 4]

        myQueue.remove();
        System.out.println(myQueue.peekFront()); // Will print 3
        // instack: [(top) 5]
        // outStack: [(top) 3, 4]
        myQueue.remove();
        System.out.println(myQueue.peekFront()); // Will print 4
        // instack: [(top) 5]
        // outStack: [(top) 4]
        myQueue.remove();
        // instack: [(top) 5]
        // outStack: []
        System.out.println(myQueue.peekFront()); // Will print 5
        // instack: []
        // outStack: [(top) 5]
        myQueue.remove();
        // instack: []
        // outStack: []

        System.out.println(myQueue.isEmpty()); // Will print true
    }
}
package com.thealgorithms.others;

/**
 *
 *
 * <h2>Shortest job first.</h2>
 *
 * <p>
 * Shortest job first (SJF) or shortest job next, is a scheduling policy that
 * selects the waiting process with the smallest execution time to execute next
 * Shortest Job first has the advantage of having minimum average waiting time
 * among all scheduling algorithms. It is a Greedy Algorithm. It may cause
 * starvation if shorter processes keep coming. This problem has been solved
 * using the concept of aging.
 *
 * @author shivg7706
 * @since 2018/10/27
 */
import java.util.*;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Scanner;

class Process {

    public int pid;
    public int arrivalTime;
    public int burstTime;
    public int priority;
    public int turnAroundTime;
    public int waitTime;
    public int remainingTime;
}

class Schedule {

    private int noOfProcess;
    private int timer = 0;
    private ArrayList<Process> processes;
    private ArrayList<Process> remainingProcess;
    private ArrayList<Integer> gantChart;
    private float burstAll;
    private Map<Integer, ArrayList<Process>> arrivals;

    Schedule() {
        Scanner in = new Scanner(System.in);

        processes = new ArrayList<Process>();
        remainingProcess = new ArrayList<Process>();

        gantChart = new ArrayList<>();
        arrivals = new HashMap<>();

        System.out.print("Enter the no. of processes: ");
        noOfProcess = in.nextInt();
        System.out.println("Enter the arrival, burst and priority of processes");
        for (int i = 0; i < noOfProcess; i++) {
            Process p = new Process();
            p.pid = i;
            p.arrivalTime = in.nextInt();
            p.burstTime = in.nextInt();
            p.priority = in.nextInt();
            p.turnAroundTime = 0;
            p.waitTime = 0;
            p.remainingTime = p.burstTime;

            if (arrivals.get(p.arrivalTime) == null) {
                arrivals.put(p.arrivalTime, new ArrayList<Process>());
            }
            arrivals.get(p.arrivalTime).add(p);
            processes.add(p);
            burstAll += p.burstTime;
        }
        in.close();
    }

    void startScheduling() {

        processes.sort(
                new Comparator<Process>() {
            @Override
            public int compare(Process a, Process b) {
                return a.arrivalTime - b.arrivalTime;
            }
        });

        while (!(arrivals.size() == 0 && remainingProcess.size() == 0)) {
            removeFinishedProcess();
            if (arrivals.get(timer) != null) {
                remainingProcess.addAll(arrivals.get(timer));
                arrivals.remove(timer);
            }

            remainingProcess.sort(
                    new Comparator<Process>() {
                private int alpha = 6;
                private int beta = 1;

                @Override
                public int compare(Process a, Process b) {
                    int aRem = a.remainingTime;
                    int bRem = b.remainingTime;
                    int aprior = a.priority;
                    int bprior = b.priority;
                    return (alpha * aRem + beta * aprior) - (alpha * bRem + beta * bprior);
                }
            });

            int k = timeElapsed(timer);
            ageing(k);
            timer++;
        }

        System.out.println("Total time required: " + (timer - 1));
    }

    void removeFinishedProcess() {
        ArrayList<Integer> completed = new ArrayList<Integer>();
        for (int i = 0; i < remainingProcess.size(); i++) {
            if (remainingProcess.get(i).remainingTime == 0) {
                completed.add(i);
            }
        }

        for (int i = 0; i < completed.size(); i++) {
            int pid = remainingProcess.get(completed.get(i)).pid;
            processes.get(pid).waitTime = remainingProcess.get(completed.get(i)).waitTime;
            remainingProcess.remove(remainingProcess.get(completed.get(i)));
        }
    }

    public int timeElapsed(int i) {
        if (!remainingProcess.isEmpty()) {
            gantChart.add(i, remainingProcess.get(0).pid);
            remainingProcess.get(0).remainingTime--;
            return 1;
        }
        return 0;
    }

    public void ageing(int k) {
        for (int i = k; i < remainingProcess.size(); i++) {
            remainingProcess.get(i).waitTime++;
            if (remainingProcess.get(i).waitTime % 7 == 0) {
                remainingProcess.get(i).priority--;
            }
        }
    }

    public void solve() {
        System.out.println("Gant chart ");
        for (int i = 0; i < gantChart.size(); i++) {
            System.out.print(gantChart.get(i) + " ");
        }
        System.out.println();

        float waitTimeTot = 0;
        float tatTime = 0;

        for (int i = 0; i < noOfProcess; i++) {
            processes.get(i).turnAroundTime = processes.get(i).waitTime + processes.get(i).burstTime;

            waitTimeTot += processes.get(i).waitTime;
            tatTime += processes.get(i).turnAroundTime;

            System.out.println(
                    "Process no.: "
                    + i
                    + " Wait time: "
                    + processes.get(i).waitTime
                    + " Turn Around Time: "
                    + processes.get(i).turnAroundTime);
        }

        System.out.println("Average Waiting Time: " + waitTimeTot / noOfProcess);
        System.out.println("Average TAT Time: " + tatTime / noOfProcess);
        System.out.println("Throughput: " + (float) noOfProcess / (timer - 1));
    }
}

public class SJF {

    public static void main(String[] args) {
        Schedule s = new Schedule();
        s.startScheduling();
        s.solve();
    }
}
package com.thealgorithms.others;

/**
 * You can read more about Euler's totient function
 *
 * <p>
 * See https://en.wikipedia.org/wiki/Euler%27s_totient_function
 */
public class EulersFunction {
    // This method returns us number of x that (x < n) and gcd(x, n) == 1 in O(sqrt(n)) time
    // complexity;

    public static int getEuler(int n) {
        int result = n;
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) {
                while (n % i == 0) {
                    n /= i;
                }
                result -= result / i;
            }
        }
        if (n > 1) {
            result -= result / n;
        }
        return result;
    }

    public static void main(String[] args) {
        for (int i = 1; i < 100; i++) {
            System.out.println(getEuler(i));
        }
    }
}
package com.thealgorithms.others;

// Java Program to implement Auto-Complete 
// Feature using Trie
class Trieac {

    // Alphabet size (# of symbols) 
    public static final int ALPHABET_SIZE = 26;

    // Trie node 
    static class TrieNode {

        TrieNode children[] = new TrieNode[ALPHABET_SIZE];

        // isWordEnd is true if the node represents 
        // end of a word 
        boolean isWordEnd;
    };

    // Returns new trie node (initialized to NULLs) 
    static TrieNode getNode() {
        TrieNode pNode = new TrieNode();
        pNode.isWordEnd = false;

        for (int i = 0; i < ALPHABET_SIZE; i++) {
            pNode.children[i] = null;
        }

        return pNode;
    }

    // If not present, inserts key into trie. If the 
    // key is prefix of trie node, just marks leaf node 
    static void insert(TrieNode root, final String key) {
        TrieNode pCrawl = root;

        for (int level = 0; level < key.length(); level++) {
            int index = (key.charAt(level) - 'a');
            if (pCrawl.children[index] == null) {
                pCrawl.children[index] = getNode();
            }
            pCrawl = pCrawl.children[index];
        }

        // mark last node as leaf 
        pCrawl.isWordEnd = true;
    }

    // Returns true if key presents in trie, else false 
    boolean search(TrieNode root, final String key) {
        int length = key.length();
        TrieNode pCrawl = root;

        for (int level = 0; level < length; level++) {
            int index = (key.charAt(level) - 'a');

            if (pCrawl.children[index] == null) {
                pCrawl = pCrawl.children[index];
            }
        }

        return (pCrawl != null && pCrawl.isWordEnd);
    }

    // Returns 0 if current node has a child 
    // If all children are NULL, return 1. 
    static boolean isLastNode(TrieNode root) {
        for (int i = 0; i < ALPHABET_SIZE; i++) {
            if (root.children[i] != null) {
                return false;
            }
        }
        return true;
    }

    // Recursive function to print auto-suggestions 
    // for given node. 
    static void suggestionsRec(TrieNode root, String currPrefix) {
        // found a string in Trie with the given prefix 
        if (root.isWordEnd) {
            System.out.println(currPrefix);
        }

        // All children struct node pointers are NULL 
        if (isLastNode(root)) {
            return;
        }

        for (int i = 0; i < ALPHABET_SIZE; i++) {
            if (root.children[i] != null) {
                // append current character to currPrefix string 
                currPrefix += (char) (97 + i);

                // recur over the rest 
                suggestionsRec(root.children[i], currPrefix);
            }
        }
    }

    // Fucntion  to print suggestions for
    // given query prefix.
    static int printAutoSuggestions(TrieNode root,
            final String query) {
        TrieNode pCrawl = root;

        // Check if prefix is present and find the 
        // the node (of last level) with last character 
        // of given string. 
        int level;
        int n = query.length();

        for (level = 0; level < n; level++) {
            int index = (query.charAt(level) - 'a');

            // no string in the Trie has this prefix 
            if (pCrawl.children[index] == null) {
                return 0;
            }

            pCrawl = pCrawl.children[index];
        }

        // If prefix is present as a word. 
        boolean isWord = (pCrawl.isWordEnd == true);

        // If prefix is last node of tree (has no 
        // children) 
        boolean isLast = isLastNode(pCrawl);

        // If prefix is present as a word, but 
        // there is no subtree below the last 
        // matching node. 
        if (isWord && isLast) {
            System.out.println(query);
            return -1;
        }

        // If there are nodes below the last 
        // matching character. 
        if (!isLast) {
            String prefix = query;
            suggestionsRec(pCrawl, prefix);
            return 1;
        }

        return 0;
    }

    // Driver code
    public static void main(String[] args) {
        TrieNode root = getNode();
        insert(root, "hello");
        insert(root, "dog");
        insert(root, "hell");
        insert(root, "cat");
        insert(root, "a");
        insert(root, "hel");
        insert(root, "help");
        insert(root, "helps");
        insert(root, "helping");
        int comp = printAutoSuggestions(root, "hel");

        if (comp == -1) {
            System.out.println("No other strings found "
                    + "with this prefix\n");
        } else if (comp == 0) {
            System.out.println("No string found with"
                    + " this prefix\n");
        }
    }
}
package com.thealgorithms.others;

/**
 * @author Prateek Kumar Oraon (https://github.com/prateekKrOraon)
 */
import java.util.Scanner;

// An implementation of Rabin-Karp string matching algorithm
// Program will simply end if there is no match
public class RabinKarp {

    public static Scanner scanner = null;
    public static final int d = 256;

    public static void main(String[] args) {

        scanner = new Scanner(System.in);
        System.out.println("Enter String");
        String text = scanner.nextLine();
        System.out.println("Enter pattern");
        String pattern = scanner.nextLine();

        int q = 101;
        searchPat(text, pattern, q);
    }

    private static void searchPat(String text, String pattern, int q) {

        int m = pattern.length();
        int n = text.length();
        int t = 0;
        int p = 0;
        int h = 1;
        int j = 0;
        int i = 0;

        h = (int) Math.pow(d, m - 1) % q;

        for (i = 0; i < m; i++) {
            // hash value is calculated for each character and then added with the hash value of the next
            // character for pattern
            // as well as the text for length equal to the length of pattern
            p = (d * p + pattern.charAt(i)) % q;
            t = (d * t + text.charAt(i)) % q;
        }

        for (i = 0; i <= n - m; i++) {

            // if the calculated hash value of the pattern and text matches then
            // all the characters of the pattern is matched with the text of length equal to length of the
            // pattern
            // if all matches then pattern exist in string
            // if not then the hash value of the first character of the text is subtracted and hash value
            // of the next character after the end
            // of the evaluated characters is added
            if (p == t) {

                // if hash value matches then the individual characters are matched
                for (j = 0; j < m; j++) {

                    // if not matched then break out of the loop
                    if (text.charAt(i + j) != pattern.charAt(j)) {
                        break;
                    }
                }

                // if all characters are matched then pattern exist in the string
                if (j == m) {
                    System.out.println("Pattern found at index " + i);
                }
            }

            // if i<n-m then hash value of the first character of the text is subtracted and hash value of
            // the next character after the end
            // of the evaluated characters is added to get the hash value of the next window of characters
            // in the text
            if (i < n - m) {
                t = (d * (t - text.charAt(i) * h) + text.charAt(i + m)) % q;

                // if hash value becomes less than zero than q is added to make it positive
                if (t < 0) {
                    t = (t + q);
                }
            }
        }
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

/**
 * @author Nishita Aggarwal
 * <p>
 * Brian Kernighan’s Algorithm
 * <p>
 * algorithm to count the number of set bits in a given number
 * <p>
 * Subtraction of 1 from a number toggles all the bits (from right to left) till
 * the rightmost set bit(including the rightmost set bit). So if we subtract a
 * number by 1 and do bitwise & with itself i.e. (n & (n-1)), we unset the
 * rightmost set bit.
 * <p>
 * If we do n & (n-1) in a loop and count the no of times loop executes we get
 * the set bit count.
 * <p>
 * <p>
 * Time Complexity: O(logn)
 */
public class BrianKernighanAlgorithm {

    /**
     * @param num: number in which we count the set bits
     * @return int: Number of set bits
     */
    static int countSetBits(int num) {
        int cnt = 0;
        while (num != 0) {
            num = num & (num - 1);
            cnt++;
        }
        return cnt;
    }

    /**
     * @param args : command line arguments
     */
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        int setBitCount = countSetBits(num);
        System.out.println(setBitCount);
        sc.close();
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

class Krishnamurthy {

    static int fact(int n) {
        int i, p = 1;
        for (i = n; i >= 1; i--) {
            p = p * i;
        }
        return p;
    }

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int a, b, s = 0;
        System.out.print("Enter the number : ");
        a = sc.nextInt();
        int n = a;
        while (a > 0) {
            b = a % 10;
            s = s + fact(b);
            a = a / 10;
        }
        if (s == n) {
            System.out.print(n + " is a krishnamurthy number");
        } else {
            System.out.print(n + " is not a krishnamurthy number");
        }
        sc.close();
    }
}
package com.thealgorithms.others;

/**
 * This file contains an implementation of BANKER'S ALGORITM Wikipedia:
 * https://en.wikipedia.org/wiki/Banker%27s_algorithm
 *
 * The algorithm for finding out whether or not a system is in a safe state can
 * be described as follows: 1. Let Work and Finish be vectors of length ‘m’ and
 * ‘n’ respectively. Initialize: Work= Available Finish [i]=false; for
 * i=1,2,……,n 2. Find an i such that both a) Finish [i]=false b) Need_i<=work
 *
 * if no such i exists goto step (4) 3. Work=Work + Allocation_i Finish[i]= true
 * goto step(2) 4. If Finish[i]=true for all i, then the system is in safe
 * state.
 *
 * Time Complexity: O(n*n*m) Space Complexity: O(n*m) where n = number of
 * processes and m = number of resources.
 *
 * @author AMRITESH ANAND (https://github.com/amritesh19)
 */
import java.util.Scanner;

public class BankersAlgorithm {

    /**
     * This method finds the need of each process
     */
    static void calculateNeed(int needArray[][], int maxArray[][], int allocationArray[][], int totalProcess, int totalResources) {
        for (int i = 0; i < totalProcess; i++) {
            for (int j = 0; j < totalResources; j++) {
                needArray[i][j] = maxArray[i][j] - allocationArray[i][j];
            }
        }
    }

    /**
     * This method find the system is in safe state or not
     *
     * @param processes[] int array of processes (0...n-1), size = n
     * @param availableArray[] int array of number of instances of each
     * resource, size = m
     * @param maxArray[][] int matrix(2-D array) of maximum demand of each
     * process in a system, size = n*m
     * @param allocationArray[][] int matrix(2-D array) of the number of
     * resources of each type currently allocated to each process, size = n*m
     * @param totalProcess number of total processes, n
     * @param totalResources number of total resources, m
     *
     * @return boolean if the system is in safe state or not
     */
    static boolean checkSafeSystem(int processes[], int availableArray[], int maxArray[][], int allocationArray[][], int totalProcess, int totalResources) {
        int[][] needArray = new int[totalProcess][totalResources];

        calculateNeed(needArray, maxArray, allocationArray, totalProcess, totalResources);

        boolean[] finishProcesses = new boolean[totalProcess];

        int[] safeSequenceArray = new int[totalProcess];

        int[] workArray = new int[totalResources];

        for (int i = 0; i < totalResources; i++) {
            workArray[i] = availableArray[i];
        }

        int count = 0;

        // While all processes are not finished or system is not in safe state.
        while (count < totalProcess) {
            boolean foundSafeSystem = false;
            for (int m = 0; m < totalProcess; m++) {
                if (finishProcesses[m] == false) {
                    int j;

                    for (j = 0; j < totalResources; j++) {
                        if (needArray[m][j] > workArray[j]) {
                            break;
                        }
                    }

                    if (j == totalResources) {
                        for (int k = 0; k < totalResources; k++) {
                            workArray[k] += allocationArray[m][k];
                        }

                        safeSequenceArray[count++] = m;

                        finishProcesses[m] = true;

                        foundSafeSystem = true;
                    }
                }
            }

            // If we could not find a next process in safe sequence.
            if (foundSafeSystem == false) {
                System.out.print("The system is not in the safe state because lack of resources");
                return false;
            }
        }

        System.out.print("The system is in safe sequence and the sequence is as follows: ");
        for (int i = 0; i < totalProcess; i++) {
            System.out.print("P" + safeSequenceArray[i] + " ");
        }

        return true;
    }

    /**
     * This is main method of Banker's Algorithm
     */
    public static void main(String[] args) {
        int numberOfProcesses, numberOfResources;

        Scanner sc = new Scanner(System.in);

        System.out.println("Enter total number of processes");
        numberOfProcesses = sc.nextInt();

        System.out.println("Enter total number of resources");
        numberOfResources = sc.nextInt();

        int processes[] = new int[numberOfProcesses];
        for (int i = 0; i < numberOfProcesses; i++) {
            processes[i] = i;
        }

        System.out.println("--Enter the availability of--");

        int availableArray[] = new int[numberOfResources];
        for (int i = 0; i < numberOfResources; i++) {
            System.out.println("resource " + i + ": ");
            availableArray[i] = sc.nextInt();
        }

        System.out.println("--Enter the maximum matrix--");

        int maxArray[][] = new int[numberOfProcesses][numberOfResources];
        for (int i = 0; i < numberOfProcesses; i++) {
            System.out.println("For process " + i + ": ");
            for (int j = 0; j < numberOfResources; j++) {
                System.out.println("Enter the maximum instances of resource " + j);
                maxArray[i][j] = sc.nextInt();
            }
        }

        System.out.println("--Enter the allocation matrix--");

        int allocationArray[][] = new int[numberOfProcesses][numberOfResources];
        for (int i = 0; i < numberOfProcesses; i++) {
            System.out.println("For process " + i + ": ");
            for (int j = 0; j < numberOfResources; j++) {
                System.out.println("Allocated instances of resource " + j);
                allocationArray[i][j] = sc.nextInt();
            }
        }

        checkSafeSystem(processes, availableArray, maxArray, allocationArray, numberOfProcesses, numberOfResources);

        sc.close();
    }
}

/*
    Example: 
    n = 5
    m = 3

    Process     Allocation      Max       Available
                0   1   2    0   1   2    0   1   2

        0       0   1   0    7   5   3    3   3   2
        1       2   0   0    3   2   2 
        2       3   0   2    9   0   2
        3       2   1   1    2   2   2
        4       0   0   2    4   3   3

    Result: The system is in safe sequence and the sequence is as follows: P1, P3, P4, P0, P2 
 */
package com.thealgorithms.others;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Scanner;

public class SkylineProblem {

    Building[] building;
    int count;

    public void run() {
        Scanner sc = new Scanner(System.in);

        int num = sc.nextInt();
        this.building = new Building[num];

        for (int i = 0; i < num; i++) {
            String input = sc.next();
            String[] data = input.split(",");
            this.add(Integer.parseInt(data[0]), Integer.parseInt(data[1]), Integer.parseInt(data[2]));
        }
        this.print(this.findSkyline(0, num - 1));

        sc.close();
    }

    public void add(int left, int height, int right) {
        building[count++] = new Building(left, height, right);
    }

    public void print(ArrayList<Skyline> skyline) {
        Iterator<Skyline> it = skyline.iterator();

        while (it.hasNext()) {
            Skyline temp = it.next();
            System.out.print(temp.coordinates + "," + temp.height);
            if (it.hasNext()) {
                System.out.print(",");
            }
        }
    }

    public ArrayList<Skyline> findSkyline(int start, int end) {
        if (start == end) {
            ArrayList<Skyline> list = new ArrayList<>();
            list.add(new Skyline(building[start].left, building[start].height));
            list.add(new Skyline(building[end].right, 0));

            return list;
        }

        int mid = (start + end) / 2;

        ArrayList<Skyline> sky1 = this.findSkyline(start, mid);
        ArrayList<Skyline> sky2 = this.findSkyline(mid + 1, end);

        return this.mergeSkyline(sky1, sky2);
    }

    public ArrayList<Skyline> mergeSkyline(ArrayList<Skyline> sky1, ArrayList<Skyline> sky2) {
        int currentH1 = 0, currentH2 = 0;
        ArrayList<Skyline> skyline = new ArrayList<>();
        int maxH = 0;

        while (!sky1.isEmpty() && !sky2.isEmpty()) {
            if (sky1.get(0).coordinates < sky2.get(0).coordinates) {
                int currentX = sky1.get(0).coordinates;
                currentH1 = sky1.get(0).height;

                if (currentH1 < currentH2) {
                    sky1.remove(0);
                    if (maxH != currentH2) {
                        skyline.add(new Skyline(currentX, currentH2));
                    }
                } else {
                    maxH = currentH1;
                    sky1.remove(0);
                    skyline.add(new Skyline(currentX, currentH1));
                }
            } else {
                int currentX = sky2.get(0).coordinates;
                currentH2 = sky2.get(0).height;

                if (currentH2 < currentH1) {
                    sky2.remove(0);
                    if (maxH != currentH1) {
                        skyline.add(new Skyline(currentX, currentH1));
                    }
                } else {
                    maxH = currentH2;
                    sky2.remove(0);
                    skyline.add(new Skyline(currentX, currentH2));
                }
            }
        }

        while (!sky1.isEmpty()) {
            skyline.add(sky1.get(0));
            sky1.remove(0);
        }

        while (!sky2.isEmpty()) {
            skyline.add(sky2.get(0));
            sky2.remove(0);
        }

        return skyline;
    }

    public class Skyline {

        public int coordinates;
        public int height;

        public Skyline(int coordinates, int height) {
            this.coordinates = coordinates;
            this.height = height;
        }
    }

    public class Building {

        public int left;
        public int height;
        public int right;

        public Building(int left, int height, int right) {
            this.left = left;
            this.height = height;
            this.right = right;
        }
    }

    public static void main(String[] args) {
        SkylineProblem skylineProblem = new SkylineProblem();
        skylineProblem.run();
    }
}
package com.thealgorithms.others;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

/**
 * Creates a random password from ASCII letters Given password length bounds
 *
 * @author AKS1996
 * @date 2017.10.25
 */
class PasswordGen {

    public static void main(String args[]) {
        String password = generatePassword(8, 16);
        System.out.print("Password: " + password);
    }

    static String generatePassword(int min_length, int max_length) {
        Random random = new Random();

        String upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        String lower = "abcdefghijklmnopqrstuvwxyz";
        String numbers = "0123456789";
        String specialChars = "!@#$%^&*(){}?";

        String allChars = upper + lower + numbers + specialChars;

        List<Character> letters = new ArrayList<Character>();
        for (char c : allChars.toCharArray()) {
            letters.add(c);
        }

        // Inbuilt method to randomly shuffle a elements of a list
        Collections.shuffle(letters);
        StringBuilder password = new StringBuilder();

        // Note that size of the password is also random
        for (int i = random.nextInt(max_length - min_length) + min_length; i > 0; --i) {
            password.append(letters.get(random.nextInt(letters.size())));
        }

        return password.toString();
    }
}
package com.thealgorithms.others;

import java.util.Objects;

/**
 * Damm algorithm is a check digit algorithm that detects all single-digit
 * errors and all adjacent transposition errors. It was presented by H. Michael
 * Damm in 2004. Essential part of the algorithm is a quasigroup of order 10
 * (i.e. having a 10 × 10 Latin square as the body of its operation table) with
 * the special feature of being weakly totally anti-symmetric. Damm revealed
 * several methods to create totally anti-symmetric quasigroups of order 10 and
 * gave some examples in his doctoral dissertation.
 *
 * @see <a href="https://en.wikipedia.org/wiki/Damm_algorithm">Wiki. Damm
 * algorithm</a>
 */
public class Damm {

    /**
     * Weakly totally anti-symmetric quasigroup of order 10. This table is not
     * the only possible realisation of weak totally anti-symmetric quasigroup
     * but the most common one (taken from Damm doctoral dissertation). All
     * zeros lay on the diagonal because it simplifies the check digit
     * calculation.
     */
    private static final byte[][] DAMM_TABLE = {
        {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},
        {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},
        {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},
        {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},
        {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},
        {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},
        {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},
        {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},
        {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},
        {2, 5, 8, 1, 4, 3, 6, 7, 9, 0}
    };

    /**
     * Check input digits by Damm algorithm.
     *
     * @param digits input to check
     * @return true if check was successful, false otherwise
     * @throws IllegalArgumentException if input parameter contains not only
     * digits
     * @throws NullPointerException if input is null
     */
    public static boolean dammCheck(String digits) {
        checkInput(digits);
        int[] numbers = toIntArray(digits);

        int checksum = 0;
        for (int number : numbers) {
            checksum = DAMM_TABLE[checksum][number];
        }

        return checksum == 0;
    }

    /**
     * Calculate check digit for initial digits and add it tho the last
     * position.
     *
     * @param initialDigits initial value
     * @return digits with the checksum in the last position
     * @throws IllegalArgumentException if input parameter contains not only
     * digits
     * @throws NullPointerException if input is null
     */
    public static String addDammChecksum(String initialDigits) {
        checkInput(initialDigits);
        int[] numbers = toIntArray(initialDigits);

        int checksum = 0;
        for (int number : numbers) {
            checksum = DAMM_TABLE[checksum][number];
        }

        return initialDigits + checksum;
    }

    public static void main(String[] args) {
        System.out.println("Damm algorithm usage examples:");
        var validInput = "5724";
        var invalidInput = "5824";
        checkAndPrint(validInput);
        checkAndPrint(invalidInput);

        System.out.println("\nCheck digit generation example:");
        var input = "572";
        generateAndPrint(input);
    }

    private static void checkAndPrint(String input) {
        String validationResult = Damm.dammCheck(input)
                ? "valid"
                : "not valid";
        System.out.println("Input '" + input + "' is " + validationResult);
    }

    private static void generateAndPrint(String input) {
        String result = addDammChecksum(input);
        System.out.println("Generate and add checksum to initial value '" + input + "'. Result: '" + result + "'");
    }

    private static void checkInput(String input) {
        Objects.requireNonNull(input);
        if (!input.matches("\\d+")) {
            throw new IllegalArgumentException("Input '" + input + "' contains not only digits");
        }
    }

    private static int[] toIntArray(String string) {
        return string.chars()
                .map(i -> Character.digit(i, 10))
                .toArray();
    }
}
package com.thealgorithms.others;

import java.util.*;

class PageRank {

    public static void main(String args[]) {
        int nodes, i, j;
        Scanner in = new Scanner(System.in);
        System.out.print("Enter the Number of WebPages: ");
        nodes = in.nextInt();
        PageRank p = new PageRank();
        System.out.println("Enter the Adjacency Matrix with 1->PATH & 0->NO PATH Between two WebPages: ");
        for (i = 1; i <= nodes; i++) {
            for (j = 1; j <= nodes; j++) {
                p.path[i][j] = in.nextInt();
                if (j == i) {
                    p.path[i][j] = 0;
                }
            }
        }
        p.calc(nodes);
    }

    public int path[][] = new int[10][10];
    public double pagerank[] = new double[10];

    public void calc(double totalNodes) {

        double InitialPageRank;
        double OutgoingLinks = 0;
        double DampingFactor = 0.85;
        double TempPageRank[] = new double[10];
        int ExternalNodeNumber;
        int InternalNodeNumber;
        int k = 1; // For Traversing
        int ITERATION_STEP = 1;
        InitialPageRank = 1 / totalNodes;
        System.out.printf(
                " Total Number of Nodes :" + totalNodes + "\t Initial PageRank  of All Nodes :" + InitialPageRank + "\n");

        // 0th ITERATION _ OR _ INITIALIZATION PHASE //
        for (k = 1; k <= totalNodes; k++) {
            this.pagerank[k] = InitialPageRank;
        }
        System.out.printf("\n Initial PageRank Values , 0th Step \n");

        for (k = 1; k <= totalNodes; k++) {
            System.out.printf(" Page Rank of " + k + " is :\t" + this.pagerank[k] + "\n");
        }

        while (ITERATION_STEP <= 2) // Iterations
        {
            // Store the PageRank for All Nodes in Temporary Array
            for (k = 1; k <= totalNodes; k++) {
                TempPageRank[k] = this.pagerank[k];
                this.pagerank[k] = 0;
            }

            for (InternalNodeNumber = 1; InternalNodeNumber <= totalNodes; InternalNodeNumber++) {
                for (ExternalNodeNumber = 1; ExternalNodeNumber <= totalNodes; ExternalNodeNumber++) {
                    if (this.path[ExternalNodeNumber][InternalNodeNumber] == 1) {
                        k = 1;
                        OutgoingLinks = 0; // Count the Number of Outgoing Links for each ExternalNodeNumber
                        while (k <= totalNodes) {
                            if (this.path[ExternalNodeNumber][k] == 1) {
                                OutgoingLinks = OutgoingLinks + 1; // Counter for Outgoing Links
                            }
                            k = k + 1;
                        }
                        // Calculate PageRank
                        this.pagerank[InternalNodeNumber] += TempPageRank[ExternalNodeNumber] * (1 / OutgoingLinks);
                    }
                }
                System.out.printf("\n After " + ITERATION_STEP + "th Step \n");

                for (k = 1; k <= totalNodes; k++) {
                    System.out.printf(" Page Rank of " + k + " is :\t" + this.pagerank[k] + "\n");
                }

                ITERATION_STEP = ITERATION_STEP + 1;
            }

            // Add the Damping Factor to PageRank
            for (k = 1; k <= totalNodes; k++) {
                this.pagerank[k] = (1 - DampingFactor) + DampingFactor * this.pagerank[k];
            }

            // Display PageRank
            System.out.printf("\n Final Page Rank : \n");
            for (k = 1; k <= totalNodes; k++) {
                System.out.printf(" Page Rank of " + k + " is :\t" + this.pagerank[k] + "\n");
            }

        }
    }
}
package com.thealgorithms.others;

import java.util.Objects;

/**
 * The Verhoeff algorithm is a checksum formula for error detection developed by
 * the Dutch mathematician Jacobus Verhoeff and was first published in 1969. It
 * was the first decimal check digit algorithm which detects all single-digit
 * errors, and all transposition errors involving two adjacent digits.
 *
 * <p>
 * The strengths of the algorithm are that it detects all transliteration and
 * transposition errors, and additionally most twin, twin jump, jump
 * transposition and phonetic errors. The main weakness of the Verhoeff
 * algorithm is its complexity. The calculations required cannot easily be
 * expressed as a formula. For easy calculation three tables are required:</p>
 * <ol>
 * <li>multiplication table</li>
 * <li>inverse table</li>
 * <li>permutation table</li>
 * </ol>
 *
 * @see <a href="https://en.wikipedia.org/wiki/Verhoeff_algorithm">Wiki.
 * Verhoeff algorithm</a>
 */
public class Verhoeff {

    /**
     * Table {@code d}. Based on multiplication in the dihedral group D5 and is
     * simply the Cayley table of the group. Note that this group is not
     * commutative, that is, for some values of {@code j} and {@code k},
     * {@code d(j,k) ≠ d(k, j)}.
     *
     * @see <a href="https://en.wikipedia.org/wiki/Dihedral_group">Wiki.
     * Dihedral group</a>
     */
    private static final byte[][] MULTIPLICATION_TABLE = {
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
        {1, 2, 3, 4, 0, 6, 7, 8, 9, 5},
        {2, 3, 4, 0, 1, 7, 8, 9, 5, 6},
        {3, 4, 0, 1, 2, 8, 9, 5, 6, 7},
        {4, 0, 1, 2, 3, 9, 5, 6, 7, 8},
        {5, 9, 8, 7, 6, 0, 4, 3, 2, 1},
        {6, 5, 9, 8, 7, 1, 0, 4, 3, 2},
        {7, 6, 5, 9, 8, 2, 1, 0, 4, 3},
        {8, 7, 6, 5, 9, 3, 2, 1, 0, 4},
        {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
    };

    /**
     * The inverse table {@code inv}. Represents the multiplicative inverse of a
     * digit, that is, the value that satisfies {@code d(j, inv(j)) = 0}.
     */
    private static final byte[] MULTIPLICATIVE_INVERSE = {0, 4, 3, 2, 1, 5, 6, 7, 8, 9};

    /**
     * The permutation table {@code p}. Applies a permutation to each digit
     * based on its position in the number. This is actually a single
     * permutation {@code (1 5 8 9 4 2 7 0)(3 6)} applied iteratively; i.e.
     * {@code p(i+j,n) = p(i, p(j,n))}.
     */
    private static final byte[][] PERMUTATION_TABLE = {
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
        {1, 5, 7, 6, 2, 8, 3, 0, 9, 4},
        {5, 8, 0, 3, 7, 9, 6, 1, 4, 2},
        {8, 9, 1, 6, 0, 4, 3, 5, 2, 7},
        {9, 4, 5, 3, 1, 2, 6, 8, 7, 0},
        {4, 2, 8, 6, 5, 7, 3, 9, 0, 1},
        {2, 7, 9, 3, 8, 0, 6, 4, 1, 5},
        {7, 0, 4, 6, 9, 1, 3, 2, 5, 8}
    };

    /**
     * Check input digits by Verhoeff algorithm.
     *
     * @param digits input to check
     * @return true if check was successful, false otherwise
     * @throws IllegalArgumentException if input parameter contains not only
     * digits
     * @throws NullPointerException if input is null
     */
    public static boolean verhoeffCheck(String digits) {
        checkInput(digits);
        int[] numbers = toIntArray(digits);

        // The Verhoeff algorithm
        int checksum = 0;
        for (int i = 0; i < numbers.length; i++) {
            int index = numbers.length - i - 1;
            byte b = PERMUTATION_TABLE[i % 8][numbers[index]];
            checksum = MULTIPLICATION_TABLE[checksum][b];
        }

        return checksum == 0;
    }

    /**
     * Calculate check digit for initial digits and add it tho the last
     * position.
     *
     * @param initialDigits initial value
     * @return digits with the checksum in the last position
     * @throws IllegalArgumentException if input parameter contains not only
     * digits
     * @throws NullPointerException if input is null
     */
    public static String addVerhoeffChecksum(String initialDigits) {
        checkInput(initialDigits);

        // Add zero to end of input value
        var modifiedDigits = initialDigits + "0";

        int[] numbers = toIntArray(modifiedDigits);

        int checksum = 0;
        for (int i = 0; i < numbers.length; i++) {
            int index = numbers.length - i - 1;
            byte b = PERMUTATION_TABLE[i % 8][numbers[index]];
            checksum = MULTIPLICATION_TABLE[checksum][b];
        }
        checksum = MULTIPLICATIVE_INVERSE[checksum];

        return initialDigits + checksum;
    }

    public static void main(String[] args) {
        System.out.println("Verhoeff algorithm usage examples:");
        var validInput = "2363";
        var invalidInput = "2364";
        checkAndPrint(validInput);
        checkAndPrint(invalidInput);

        System.out.println("\nCheck digit generation example:");
        var input = "236";
        generateAndPrint(input);
    }

    private static void checkAndPrint(String input) {
        String validationResult = Verhoeff.verhoeffCheck(input)
                ? "valid"
                : "not valid";
        System.out.println("Input '" + input + "' is " + validationResult);
    }

    private static void generateAndPrint(String input) {
        String result = addVerhoeffChecksum(input);
        System.out.println("Generate and add checksum to initial value '" + input + "'. Result: '" + result + "'");
    }

    private static void checkInput(String input) {
        Objects.requireNonNull(input);
        if (!input.matches("\\d+")) {
            throw new IllegalArgumentException("Input '" + input + "' contains not only digits");
        }
    }

    private static int[] toIntArray(String string) {
        return string.chars()
                .map(i -> Character.digit(i, 10))
                .toArray();
    }
}
package com.thealgorithms.others;

import java.util.Arrays;

/**
 * The two pointer technique is a useful tool to utilize when searching for
 * pairs in a sorted array.
 *
 * <p>
 * link: https://www.geeksforgeeks.org/two-pointers-technique/
 */
class TwoPointers {

    public static void main(String[] args) {
        int[] arr = {10, 20, 35, 50, 75, 80};
        int key = 70;
        assert isPairedSum(arr, key);
        /* 20 + 60 == 70 */

        arr = new int[]{1, 2, 3, 4, 5, 6, 7};
        key = 13;
        assert isPairedSum(arr, key);
        /* 6 + 7 == 13 */

        key = 14;
        assert !isPairedSum(arr, key);
    }

    /**
     * Given a sorted array arr (sorted in ascending order). Find if there
     * exists any pair of elements such that their sum is equal to key.
     *
     * @param arr the array contains elements
     * @param key the number to search
     * @return {@code true} if there exists a pair of elements, {@code false}
     * otherwise.
     */
    private static boolean isPairedSum(int[] arr, int key) {
        /* array sorting is necessary for this algorithm to function correctly */
        Arrays.sort(arr);
        int i = 0;
        /* index of first element */
        int j = arr.length - 1;
        /* index of last element */

        while (i < j) {
            if (arr[i] + arr[j] == key) {
                return true;
            } else if (arr[i] + arr[j] < key) {
                i++;
            } else {
                j--;
            }
        }
        return false;
    }
}
package com.thealgorithms.others;

class Sudoku {

    public static boolean isSafe(int[][] board,
            int row, int col,
            int num) {
        // Row has the unique (row-clash)
        for (int d = 0; d < board.length; d++) {

            // Check if the number we are trying to
            // place is already present in
            // that row, return false;
            if (board[row][d] == num) {
                return false;
            }
        }

        // Column has the unique numbers (column-clash)
        for (int r = 0; r < board.length; r++) {

            // Check if the number
            // we are trying to
            // place is already present in
            // that column, return false;
            if (board[r][col] == num) {
                return false;
            }
        }

        // Corresponding square has
        // unique number (box-clash)
        int sqrt = (int) Math.sqrt(board.length);
        int boxRowStart = row - row % sqrt;
        int boxColStart = col - col % sqrt;

        for (int r = boxRowStart;
                r < boxRowStart + sqrt; r++) {
            for (int d = boxColStart;
                    d < boxColStart + sqrt; d++) {
                if (board[r][d] == num) {
                    return false;
                }
            }
        }

        // if there is no clash, it's safe
        return true;
    }

    public static boolean solveSudoku(
            int[][] board, int n) {
        int row = -1;
        int col = -1;
        boolean isEmpty = true;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 0) {
                    row = i;
                    col = j;

                    // We still have some remaining
                    // missing values in Sudoku
                    isEmpty = false;
                    break;
                }
            }
            if (!isEmpty) {
                break;
            }
        }

        // No empty space left
        if (isEmpty) {
            return true;
        }

        // Else for each-row backtrack
        for (int num = 1; num <= n; num++) {
            if (isSafe(board, row, col, num)) {
                board[row][col] = num;
                if (solveSudoku(board, n)) {
                    // print(board, n);
                    return true;
                } else {
                    // replace it
                    board[row][col] = 0;
                }
            }
        }
        return false;
    }

    public static void print(
            int[][] board, int N) {

        // We got the answer, just print it
        for (int r = 0; r < N; r++) {
            for (int d = 0; d < N; d++) {
                System.out.print(board[r][d]);
                System.out.print(" ");
            }
            System.out.print("\n");

            if ((r + 1) % (int) Math.sqrt(N) == 0) {
                System.out.print("");
            }
        }
    }

    // Driver Code
    public static void main(String args[]) {

        int[][] board = new int[][]{
            {3, 0, 6, 5, 0, 8, 4, 0, 0},
            {5, 2, 0, 0, 0, 0, 0, 0, 0},
            {0, 8, 7, 0, 0, 0, 0, 3, 1},
            {0, 0, 3, 0, 1, 0, 0, 8, 0},
            {9, 0, 0, 8, 6, 3, 0, 0, 5},
            {0, 5, 0, 0, 9, 0, 6, 0, 0},
            {1, 3, 0, 0, 0, 0, 2, 5, 0},
            {0, 0, 0, 0, 0, 0, 0, 7, 4},
            {0, 0, 5, 2, 0, 6, 3, 0, 0}
        };
        int N = board.length;

        if (solveSudoku(board, N)) {
            // print solution
            print(board, N);
        } else {
            System.out.println("No solution");
        }
    }
}
package com.thealgorithms.others;

import java.io.BufferedReader;
import java.io.InputStreamReader;

/**
 * @author Varun Upadhyay (https://github.com/varunu28)
 */
public class RemoveDuplicateFromString {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String inpStr = br.readLine();

        System.out.println("Actual string is: " + inpStr);
        System.out.println("String after removing duplicates: " + removeDuplicate(inpStr));

        br.close();
    }

    /**
     * This method produces a string after removing all the duplicate characters
     * from input string and returns it Example: Input String - "aabbbccccddddd"
     * Output String - "abcd"
     *
     * @param s String from which duplicate characters have to be removed
     * @return string with only unique characters
     */
    public static String removeDuplicate(String s) {
        if (s == null || s.isEmpty()) {
            return s;
        }

        StringBuilder sb = new StringBuilder();
        int n = s.length();

        for (int i = 0; i < n; i++) {
            if (sb.toString().indexOf(s.charAt(i)) == -1) {
                sb.append(String.valueOf(s.charAt(i)));
            }
        }

        return sb.toString();
    }
}
package com.thealgorithms.others;

import java.util.Arrays;
import java.util.Random;

/**
 * MiniMax is an algorithm used int artificial intelligence and game theory for
 * minimizing the possible loss for the worst case scenario.
 *
 * See more (https://en.wikipedia.org/wiki/Minimax,
 * https://www.geeksforgeeks.org/minimax-algorithm-in-game-theory-set-1-introduction/).
 *
 * @author aitofi (https://github.com/aitorfi)
 */
public class MiniMaxAlgorithm {

    /**
     * Game tree represented as an int array containing scores. Each array
     * element is a leaf node.
     */
    private int[] scores;
    private int height;

    /**
     * Initializes the scores with 8 random leaf nodes
     */
    public MiniMaxAlgorithm() {
        scores = getRandomScores(3, 99);
        height = log2(scores.length);
    }

    public static void main(String[] args) {
        MiniMaxAlgorithm miniMaxAlgorith = new MiniMaxAlgorithm();
        boolean isMaximizer = true; // Specifies the player that goes first.
        boolean verbose = true; // True to show each players choices.
        int bestScore;

        bestScore = miniMaxAlgorith.miniMax(0, isMaximizer, 0, verbose);

        if (verbose) {
            System.out.println();
        }

        System.out.println(Arrays.toString(miniMaxAlgorith.getScores()));
        System.out.println(
                "The best score for " + (isMaximizer ? "Maximizer" : "Minimizer") + " is " + String.valueOf(bestScore));
    }

    /**
     * Returns the optimal score assuming that both players play their best.
     *
     * @param depth Indicates how deep we are into the game tree.
     * @param isMaximizer True if it is maximizers turn; otherwise false.
     * @param index Index of the leaf node that is being evaluated.
     * @param verbose True to show each players choices.
     * @return The optimal score for the player that made the first move.
     */
    public int miniMax(int depth, boolean isMaximizer, int index, boolean verbose) {
        int bestScore, score1, score2;

        if (depth == height) { // Leaf node reached.
            return scores[index];
        }

        score1 = miniMax(depth + 1, !isMaximizer, index * 2, verbose);
        score2 = miniMax(depth + 1, !isMaximizer, (index * 2) + 1, verbose);

        if (isMaximizer) {
            // Maximizer player wants to get the maximum possible score.
            bestScore = Math.max(score1, score2);
        } else {
            // Minimizer player wants to get the minimum possible score.
            bestScore = Math.min(score1, score2);
        }

        // Leaf nodes can be sequentially inspected by
        // recurssively multiplying (0 * 2) and ((0 * 2) + 1):
        // (0 x 2) = 0; ((0 x 2) + 1) = 1
        // (1 x 2) = 2; ((1 x 2) + 1) = 3
        // (2 x 2) = 4; ((2 x 2) + 1) = 5 ...
        if (verbose) {
            System.out.println(String.format("From %02d and %02d, %s chooses %02d", score1, score2,
                    (isMaximizer ? "Maximizer" : "Minimizer"), bestScore));
        }

        return bestScore;
    }

    /**
     * Returns an array of random numbers which lenght is a power of 2.
     *
     * @param size The power of 2 that will determine the lenght of the array.
     * @param maxScore The maximum possible score.
     * @return An array of random numbers.
     */
    public static int[] getRandomScores(int size, int maxScore) {
        int[] randomScores = new int[(int) Math.pow(2, size)];
        Random rand = new Random();

        for (int i = 0; i < randomScores.length; i++) {
            randomScores[i] = rand.nextInt(maxScore) + 1;
        }

        return randomScores;
    }

    // A utility function to find Log n in base 2
    private int log2(int n) {
        return (n == 1) ? 0 : log2(n / 2) + 1;
    }

    public void setScores(int[] scores) {
        if (scores.length % 1 == 0) {
            this.scores = scores;
            height = log2(this.scores.length);
        } else {
            System.out.println("The number of scores must be a power of 2.");
        }
    }

    public int[] getScores() {
        return scores;
    }

    public int getHeight() {
        return height;
    }
}
package com.thealgorithms.others;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;

/**
 * The Koch snowflake is a fractal curve and one of the earliest fractals to
 * have been described. The Koch snowflake can be built up iteratively, in a
 * sequence of stages. The first stage is an equilateral triangle, and each
 * successive stage is formed by adding outward bends to each side of the
 * previous stage, making smaller equilateral triangles. This can be achieved
 * through the following steps for each line: 1. divide the line segment into
 * three segments of equal length. 2. draw an equilateral triangle that has the
 * middle segment from step 1 as its base and points outward. 3. remove the line
 * segment that is the base of the triangle from step 2. (description adapted
 * from https://en.wikipedia.org/wiki/Koch_snowflake ) (for a more detailed
 * explanation and an implementation in the Processing language, see
 * https://natureofcode.com/book/chapter-8-fractals/
 * #84-the-koch-curve-and-the-arraylist-technique ).
 */
public class KochSnowflake {

    public static void main(String[] args) {
        // Test Iterate-method
        ArrayList<Vector2> vectors = new ArrayList<Vector2>();
        vectors.add(new Vector2(0, 0));
        vectors.add(new Vector2(1, 0));
        ArrayList<Vector2> result = Iterate(vectors, 1);

        assert result.get(0).x == 0;
        assert result.get(0).y == 0;

        assert result.get(1).x == 1. / 3;
        assert result.get(1).y == 0;

        assert result.get(2).x == 1. / 2;
        assert result.get(2).y == Math.sin(Math.PI / 3) / 3;

        assert result.get(3).x == 2. / 3;
        assert result.get(3).y == 0;

        assert result.get(4).x == 1;
        assert result.get(4).y == 0;

        // Test GetKochSnowflake-method
        int imageWidth = 600;
        double offsetX = imageWidth / 10.;
        double offsetY = imageWidth / 3.7;
        BufferedImage image = GetKochSnowflake(imageWidth, 5);

        // The background should be white
        assert image.getRGB(0, 0) == new Color(255, 255, 255).getRGB();

        // The snowflake is drawn in black and this is the position of the first vector
        assert image.getRGB((int) offsetX, (int) offsetY) == new Color(0, 0, 0).getRGB();

        // Save image
        try {
            ImageIO.write(image, "png", new File("KochSnowflake.png"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Go through the number of iterations determined by the argument "steps".
     * Be careful with high values (above 5) since the time to calculate
     * increases exponentially.
     *
     * @param initialVectors The vectors composing the shape to which the
     * algorithm is applied.
     * @param steps The number of iterations.
     * @return The transformed vectors after the iteration-steps.
     */
    public static ArrayList<Vector2> Iterate(ArrayList<Vector2> initialVectors, int steps) {
        ArrayList<Vector2> vectors = initialVectors;
        for (int i = 0; i < steps; i++) {
            vectors = IterationStep(vectors);
        }

        return vectors;
    }

    /**
     * Method to render the Koch snowflake to a image.
     *
     * @param imageWidth The width of the rendered image.
     * @param steps The number of iterations.
     * @return The image of the rendered Koch snowflake.
     */
    public static BufferedImage GetKochSnowflake(int imageWidth, int steps) {
        if (imageWidth <= 0) {
            throw new IllegalArgumentException("imageWidth should be greater than zero");
        }

        double offsetX = imageWidth / 10.;
        double offsetY = imageWidth / 3.7;
        Vector2 vector1 = new Vector2(offsetX, offsetY);
        Vector2 vector2
                = new Vector2(imageWidth / 2, Math.sin(Math.PI / 3) * imageWidth * 0.8 + offsetY);
        Vector2 vector3 = new Vector2(imageWidth - offsetX, offsetY);
        ArrayList<Vector2> initialVectors = new ArrayList<Vector2>();
        initialVectors.add(vector1);
        initialVectors.add(vector2);
        initialVectors.add(vector3);
        initialVectors.add(vector1);
        ArrayList<Vector2> vectors = Iterate(initialVectors, steps);
        return GetImage(vectors, imageWidth, imageWidth);
    }

    /**
     * Loops through each pair of adjacent vectors. Each line between two
     * adjacent vectors is divided into 4 segments by adding 3 additional
     * vectors in-between the original two vectors. The vector in the middle is
     * constructed through a 60 degree rotation so it is bent outwards.
     *
     * @param vectors The vectors composing the shape to which the algorithm is
     * applied.
     * @return The transformed vectors after the iteration-step.
     */
    private static ArrayList<Vector2> IterationStep(ArrayList<Vector2> vectors) {
        ArrayList<Vector2> newVectors = new ArrayList<Vector2>();
        for (int i = 0; i < vectors.size() - 1; i++) {
            Vector2 startVector = vectors.get(i);
            Vector2 endVector = vectors.get(i + 1);
            newVectors.add(startVector);
            Vector2 differenceVector = endVector.subtract(startVector).multiply(1. / 3);
            newVectors.add(startVector.add(differenceVector));
            newVectors.add(startVector.add(differenceVector).add(differenceVector.rotate(60)));
            newVectors.add(startVector.add(differenceVector.multiply(2)));
        }

        newVectors.add(vectors.get(vectors.size() - 1));
        return newVectors;
    }

    /**
     * Utility-method to render the Koch snowflake to an image.
     *
     * @param vectors The vectors defining the edges to be rendered.
     * @param imageWidth The width of the rendered image.
     * @param imageHeight The height of the rendered image.
     * @return The image of the rendered edges.
     */
    private static BufferedImage GetImage(
            ArrayList<Vector2> vectors, int imageWidth, int imageHeight) {
        BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = image.createGraphics();

        // Set the background white
        g2d.setBackground(Color.WHITE);
        g2d.fillRect(0, 0, imageWidth, imageHeight);

        // Draw the edges
        g2d.setColor(Color.BLACK);
        BasicStroke bs = new BasicStroke(1);
        g2d.setStroke(bs);
        for (int i = 0; i < vectors.size() - 1; i++) {
            int x1 = (int) vectors.get(i).x;
            int y1 = (int) vectors.get(i).y;
            int x2 = (int) vectors.get(i + 1).x;
            int y2 = (int) vectors.get(i + 1).y;

            g2d.drawLine(x1, y1, x2, y2);
        }

        return image;
    }

    /**
     * Inner class to handle the vector calculations.
     */
    private static class Vector2 {

        double x, y;

        public Vector2(double x, double y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public String toString() {
            return String.format("[%f, %f]", this.x, this.y);
        }

        /**
         * Vector addition
         *
         * @param vector The vector to be added.
         * @return The sum-vector.
         */
        public Vector2 add(Vector2 vector) {
            double x = this.x + vector.x;
            double y = this.y + vector.y;
            return new Vector2(x, y);
        }

        /**
         * Vector subtraction
         *
         * @param vector The vector to be subtracted.
         * @return The difference-vector.
         */
        public Vector2 subtract(Vector2 vector) {
            double x = this.x - vector.x;
            double y = this.y - vector.y;
            return new Vector2(x, y);
        }

        /**
         * Vector scalar multiplication
         *
         * @param scalar The factor by which to multiply the vector.
         * @return The scaled vector.
         */
        public Vector2 multiply(double scalar) {
            double x = this.x * scalar;
            double y = this.y * scalar;
            return new Vector2(x, y);
        }

        /**
         * Vector rotation (see https://en.wikipedia.org/wiki/Rotation_matrix)
         *
         * @param angleInDegrees The angle by which to rotate the vector.
         * @return The rotated vector.
         */
        public Vector2 rotate(double angleInDegrees) {
            double radians = angleInDegrees * Math.PI / 180;
            double ca = Math.cos(radians);
            double sa = Math.sin(radians);
            double x = ca * this.x - sa * this.y;
            double y = sa * this.x + ca * this.y;
            return new Vector2(x, y);
        }
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

/**
 * You enter a string into this program, and it will return how many words were
 * in that particular string
 *
 * @author Marcus
 */
public class CountWords {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println("Enter your text: ");
        String str = input.nextLine();

        System.out.println("Your text has " + wordCount(str) + " word(s)");
        System.out.println("Your text has " + secondaryWordCount(str) + " word(s)");
        input.close();
    }

    private static int wordCount(String s) {
        if (s == null || s.isEmpty()) {
            return 0;
        }
        return s.trim().split("[\\s]+").length;
    }

    /**
     * counts the number of words in a sentence but ignores all potential
     * non-alphanumeric characters that do not represent a word. runs in O(n)
     * where n is the length of s
     *
     * @param s String: sentence with word(s)
     * @return int: number of words
     */
    private static int secondaryWordCount(String s) {
        if (s == null || s.isEmpty()) {
            return 0;
        }
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (Character.isLetter(c) || Character.isDigit(c)) {
                sb.append(c);
            }
        }
        s = sb.toString();
        return s.trim().split("[\\s]+").length;
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

class FloydTriangle {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the number of rows which you want in your Floyd Triangle: ");
        int r = sc.nextInt(), n = 0;
        sc.close();
        for (int i = 0; i < r; i++) {
            for (int j = 0; j <= i; j++) {
                System.out.print(++n + " ");
            }
            System.out.println();
        }
    }
}
package com.thealgorithms.others;

import java.util.Arrays;

/**
 * Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers
 * up to any given limit. It does so by iteratively marking as composite (i.e.,
 * not prime) the multiples of each prime, starting with the first prime number,
 * 2. The multiples of a given prime are generated as a sequence of numbers
 * starting from that prime, with constant difference between them that is equal
 * to that prime. This is the sieve's key distinction from using trial division
 * to sequentially test each candidate number for divisibility by each prime.
 * Once all the multiples of each discovered prime have been marked as
 * composites, the remaining unmarked numbers are primes.
 * <p>
 * Poetry about Sieve of Eratosthenes:
 * <p>
 * <i>Sift the Two's and Sift the Three's:</i></p>
 * <p>
 * <i>The Sieve of Eratosthenes.</i></p>
 * <p>
 * <i>When the multiples sublime,</i></p>
 * <p>
 * <i>The numbers that remain are Prime.</i></p>
 *
 * @see <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Wiki</a>
 */
public class SieveOfEratosthenes {

    /**
     * @param n The number till which we have to check for prime Prints all the
     * prime numbers till n. Should be more than 1.
     * @return array of all prime numbers between 0 to n
     */
    public static int[] findPrimesTill(int n) {
        // Create array where index is number and value is flag - is that number a prime or not.
        // size of array is n + 1 cause in Java array indexes starts with 0
        Type[] numbers = new Type[n + 1];

        // Start with assumption that all numbers except 0 and 1 are primes.
        Arrays.fill(numbers, Type.PRIME);
        numbers[0] = numbers[1] = Type.NOT_PRIME;

        double cap = Math.sqrt(n);
        // Main algorithm: mark all numbers which are multiples of some other values as not prime
        for (int i = 2; i <= cap; i++) {
            if (numbers[i] == Type.PRIME) {
                for (int j = 2; i * j <= n; j++) {
                    numbers[i * j] = Type.NOT_PRIME;
                }
            }
        }

        //Write all primes to result array
        int primesCount = (int) Arrays.stream(numbers)
                .filter(element -> element == Type.PRIME)
                .count();
        int[] primes = new int[primesCount];

        int primeIndex = 0;
        for (int i = 0; i < n + 1; i++) {
            if (numbers[i] == Type.PRIME) {
                primes[primeIndex++] = i;
            }
        }

        return primes;
    }

    private enum Type {
        PRIME, NOT_PRIME
    }

    public static void main(String[] args) {
        int n = 100;
        System.out.println("Searching for all primes from zero to " + n);
        int[] primes = findPrimesTill(n);
        System.out.println("Found: " + Arrays.toString(primes));
    }
}
package com.thealgorithms.others;

/**
 * *
 * A pseudorandom number generator.
 *
 * @author Tobias Carryer
 * @date October 10, 2017
 */
public class LinearCongruentialGenerator {

    private double a, c, m, previousValue;

    /**
     * *
     * These parameters are saved and used when nextNumber() is called. The
     * current timestamp in milliseconds is used as the seed.
     *
     * @param multiplier
     * @param increment
     * @param modulo The maximum number that can be generated (exclusive). A
     * common value is 2^32.
     */
    public LinearCongruentialGenerator(double multiplier, double increment, double modulo) {
        this(System.currentTimeMillis(), multiplier, increment, modulo);
    }

    /**
     * *
     * These parameters are saved and used when nextNumber() is called.
     *
     * @param seed
     * @param multiplier
     * @param increment
     * @param modulo The maximum number that can be generated (exclusive). A
     * common value is 2^32.
     */
    public LinearCongruentialGenerator(
            double seed, double multiplier, double increment, double modulo) {
        this.previousValue = seed;
        this.a = multiplier;
        this.c = increment;
        this.m = modulo;
    }

    /**
     * The smallest number that can be generated is zero. The largest number
     * that can be generated is modulo-1. modulo is set in the constructor.
     *
     * @return a pseudorandom number.
     */
    public double nextNumber() {
        previousValue = (a * previousValue + c) % m;
        return previousValue;
    }

    public static void main(String[] args) {
        // Show the LCG in action.
        // Decisive proof that the LCG works could be made by adding each number
        // generated to a Set while checking for duplicates.
        LinearCongruentialGenerator lcg
                = new LinearCongruentialGenerator(1664525, 1013904223, Math.pow(2.0, 32.0));
        for (int i = 0; i < 512; i++) {
            System.out.println(lcg.nextNumber());
        }
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

/**
 * Fibonacci sequence, and characterized by the fact that every number after the
 * first two is the sum of the two preceding ones.
 *
 * <p>
 * Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21,...
 *
 * <p>
 * Source for the explanation: https://en.wikipedia.org/wiki/Fibonacci_number
 *
 * Problem Statement: print all Fibonacci numbers that are smaller than your
 * given input N
 */
public class FibbonaciSeries {

    public static void main(String[] args) {
        // Get input from the user
        Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int first = 0, second = 1;
        scan.close();
        while (first <= n) {
            // print first fibo 0 then add second fibo into it while updating second as well
            System.out.println(first);
            int next = first + second;
            first = second;
            second = next;
        }
    }
}
package com.thealgorithms.others;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class HappyNumbersSeq {
    private static final Set<Integer> CYCLE_NUMS = new HashSet<>(Arrays.asList(4, 16, 20, 37, 58, 145));

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("Enter number: ");
        int n = in.nextInt();
        while (n != 1 && !isSad(n)) {
            System.out.print(n + " ");
            n = sumSquares(n);
        }
        String res = n == 1 ? "1 Happy number" : "Sad number";
        System.out.println(res);
    }

    private static int sumSquares(int n) {
        int s = 0;
        for (; n > 0; n /= 10) {
            int r = n % 10;
            s += r * r;
        }
        return s;
    }

    private static boolean isSad(int n) {
        return CYCLE_NUMS.contains(n);
    }
}
package com.thealgorithms.others;

import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.Comparator;

// node class is the basic structure 
// of each node present in the Huffman - tree. 
class HuffmanNode {

    int data;
    char c;

    HuffmanNode left;
    HuffmanNode right;
}

// comparator class helps to compare the node 
// on the basis of one of its attribute. 
// Here we will be compared 
// on the basis of data values of the nodes. 
class MyComparator implements Comparator<HuffmanNode> {

    public int compare(HuffmanNode x, HuffmanNode y) {

        return x.data - y.data;
    }
}

public class Huffman {

    // recursive function to print the 
    // huffman-code through the tree traversal. 
    // Here s is the huffman - code generated. 
    public static void printCode(HuffmanNode root, String s) {

        // base case; if the left and right are null 
        // then its a leaf node and we print 
        // the code s generated by traversing the tree. 
        if (root.left
                == null
                && root.right
                == null
                && Character.isLetter(root.c)) {

            // c is the character in the node 
            System.out.println(root.c + ":" + s);

            return;
        }

        // if we go to left then add "0" to the code. 
        // if we go to the right add"1" to the code. 
        // recursive calls for left and 
        // right sub-tree of the generated tree. 
        printCode(root.left, s + "0");
        printCode(root.right, s + "1");
    }

    // main function 
    public static void main(String[] args) {

        Scanner s = new Scanner(System.in);

        // number of characters. 
        int n = 6;
        char[] charArray = {'a', 'b', 'c', 'd', 'e', 'f'};
        int[] charfreq = {5, 9, 12, 13, 16, 45};

        // creating a priority queue q. 
        // makes a min-priority queue(min-heap). 
        PriorityQueue<HuffmanNode> q
                = new PriorityQueue<HuffmanNode>(n, new MyComparator());

        for (int i = 0; i < n; i++) {

            // creating a Huffman node object 
            // and add it to the priority queue. 
            HuffmanNode hn = new HuffmanNode();

            hn.c = charArray[i];
            hn.data = charfreq[i];

            hn.left = null;
            hn.right = null;

            // add functions adds 
            // the huffman node to the queue. 
            q.add(hn);
        }

        // create a root node 
        HuffmanNode root = null;

        // Here we will extract the two minimum value 
        // from the heap each time until 
        // its size reduces to 1, extract until 
        // all the nodes are extracted. 
        while (q.size() > 1) {

            // first min extract. 
            HuffmanNode x = q.peek();
            q.poll();

            // second min extarct. 
            HuffmanNode y = q.peek();
            q.poll();

            // new node f which is equal 
            HuffmanNode f = new HuffmanNode();

            // to the sum of the frequency of the two nodes 
            // assigning values to the f node. 
            f.data = x.data + y.data;
            f.c = '-';

            // first extracted node as left child. 
            f.left = x;

            // second extracted node as the right child. 
            f.right = y;

            // marking the f node as the root node. 
            root = f;

            // add this node to the priority-queue. 
            q.add(f);
        }

        // print the codes by traversing the tree 
        printCode(root, "");
    }
}
package com.thealgorithms.others;

/**
 * @author Prateek Kumar Oraon (https://github.com/prateekKrOraon)
 */
import java.util.Scanner;

// An implementaion of string matching using finite automata
public class StringMatchFiniteAutomata {

    public static final int CHARS = 256;
    public static int[][] FA;
    public static Scanner scanner = null;

    public static void main(String[] args) {

        scanner = new Scanner(System.in);
        System.out.println("Enter String");
        String text = scanner.nextLine();
        System.out.println("Enter pattern");
        String pat = scanner.nextLine();

        searchPat(text, pat);

        scanner.close();
    }

    public static void searchPat(String text, String pat) {

        int m = pat.length();
        int n = text.length();

        FA = new int[m + 1][CHARS];

        computeFA(pat, m, FA);

        int state = 0;
        for (int i = 0; i < n; i++) {
            state = FA[state][text.charAt(i)];

            if (state == m) {
                System.out.println("Pattern found at index " + (i - m + 1));
            }
        }
    }

    // Computes finite automata for the partern
    public static void computeFA(String pat, int m, int[][] FA) {

        for (int state = 0; state <= m; ++state) {
            for (int x = 0; x < CHARS; ++x) {
                FA[state][x] = getNextState(pat, m, state, x);
            }
        }
    }

    public static int getNextState(String pat, int m, int state, int x) {

        // if current state is less than length of pattern
        // and input character of pattern matches the character in the alphabet
        // then automata goes to next state
        if (state < m && x == pat.charAt(state)) {
            return state + 1;
        }

        for (int ns = state; ns > 0; ns--) {

            if (pat.charAt(ns - 1) == x) {

                for (int i = 0; i < ns - 1; i++) {

                    if (pat.charAt(i) != pat.charAt(state - ns + i + 1)) {
                        break;
                    }

                    if (i == ns - 1) {
                        return ns;
                    }
                }
            }
        }

        return 0;
    }
}
package com.thealgorithms.others;

/**
 * Implementation of Knuth–Morris–Pratt algorithm Usage: see the main function
 * for an example
 */
public class KMP {
    // a working example

    public static void main(String[] args) {
        final String haystack = "AAAAABAAABA"; // This is the full string
        final String needle = "AAAA"; // This is the substring that we want to find
        KMPmatcher(haystack, needle);
    }

    // find the starting index in string haystack[] that matches the search word P[]
    public static void KMPmatcher(final String haystack, final String needle) {
        final int m = haystack.length();
        final int n = needle.length();
        final int[] pi = computePrefixFunction(needle);
        int q = 0;
        for (int i = 0; i < m; i++) {
            while (q > 0 && haystack.charAt(i) != needle.charAt(q)) {
                q = pi[q - 1];
            }

            if (haystack.charAt(i) == needle.charAt(q)) {
                q++;
            }

            if (q == n) {
                System.out.println("Pattern starts: " + (i + 1 - n));
                q = pi[q - 1];
            }
        }
    }

    // return the prefix function
    private static int[] computePrefixFunction(final String P) {
        final int n = P.length();
        final int[] pi = new int[n];
        pi[0] = 0;
        int q = 0;
        for (int i = 1; i < n; i++) {
            while (q > 0 && P.charAt(q) != P.charAt(i)) {
                q = pi[q - 1];
            }

            if (P.charAt(q) == P.charAt(i)) {
                q++;
            }

            pi[i] = q;
        }
        return pi;
    }
}
package com.thealgorithms.others;

import java.io.*;
import java.util.*;

/* display the most frequent K words in the file and the times it appear
in the file – shown in order (ignore case and periods) */
public class TopKWords {

    static class CountWords {

        private String fileName;

        public CountWords(String fileName) {
            this.fileName = fileName;
        }

        public Map<String, Integer> getDictionary() {
            Map<String, Integer> dictionary = new HashMap<>();
            FileInputStream fis = null;

            try {

                fis = new FileInputStream(fileName); // open the file
                int in = 0;
                String s = ""; // init a empty word
                in = fis.read(); // read one character

                while (-1 != in) {
                    if (Character.isLetter((char) in)) {
                        s += (char) in; // if get a letter, append to s
                    } else {
                        // this branch means an entire word has just been read
                        if (s.length() > 0) {
                            // see whether word exists or not
                            if (dictionary.containsKey(s)) {
                                // if exist, count++
                                dictionary.put(s, dictionary.get(s) + 1);
                            } else {
                                // if not exist, initiate count of this word with 1
                                dictionary.put(s, 1);
                            }
                        }
                        s = ""; // reInit a empty word
                    }
                    in = fis.read();
                }
                return dictionary;
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    // you always have to close the I/O streams
                    if (fis != null) {
                        fis.close();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return null;
        }
    }

    public static void main(String[] args) {
        // you can replace the filePath with yours
        CountWords cw = new CountWords("/Users/lisanaaa/Desktop/words.txt");
        Map<String, Integer> dictionary
                = cw.getDictionary(); // get the words dictionary: {word: frequency}

        // we change the map to list for convenient sort
        List<Map.Entry<String, Integer>> list = new ArrayList<>(dictionary.entrySet());

        // sort by lambda valueComparator
        list.sort(Comparator.comparing(m -> m.getValue()));

        Scanner input = new Scanner(System.in);
        int k = input.nextInt();
        while (k > list.size()) {
            System.out.println("Retype a number, your number is too large");
            input = new Scanner(System.in);
            k = input.nextInt();
        }
        for (int i = 0; i < k; i++) {
            System.out.println(list.get(list.size() - i - 1));
        }
        input.close();
    }
}
package com.thealgorithms.others;

import java.util.Arrays;
import java.util.Objects;

/**
 * The Luhn algorithm or Luhn formula, also known as the "modulus 10" or "mod
 * 10" algorithm, named after its creator, IBM scientist Hans Peter Luhn, is a
 * simple checksum formula used to validate a variety of identification numbers.
 *
 * <p>
 * The algorithm is in the public domain and is in wide use today. It is
 * specified in ISO/IEC 7812-1. It is not intended to be a cryptographically
 * secure hash function; it was designed to protect against accidental errors,
 * not malicious attacks. Most credit cards and many government identification
 * numbers use the algorithm as a simple method of distinguishing valid numbers
 * from mistyped or otherwise incorrect numbers.</p>
 *
 * <p>
 * The Luhn algorithm will detect any single-digit error, as well as almost all
 * transpositions of adjacent digits. It will not, however, detect transposition
 * of the two-digit sequence 09 to 90 (or vice versa). It will detect most of
 * the possible twin errors (it will not detect 22 ↔ 55, 33 ↔ 66 or 44 ↔
 * 77).</p>
 *
 * <p>
 * The check digit is computed as follows:</p>
 * <ol>
 * <li>Take the original number and starting from the rightmost digit moving
 * left, double the value of every second digit (including the rightmost
 * digit).</li>
 * <li>Replace the resulting value at each position with the sum of the digits
 * of this position's value or just subtract 9 from all numbers more or equal
 * then 10.</li>
 * <li>Sum up the resulting values from all positions (s).</li>
 * <li>The calculated check digit is equal to {@code 10 - s % 10}.</li>
 * </ol>
 *
 * @see <a href="https://en.wikipedia.org/wiki/Luhn_algorithm">Wiki</a>
 */
public class Luhn {

    /**
     * Check input digits array by Luhn algorithm. Initial array doesn't change
     * while processing.
     *
     * @param digits array of digits from 0 to 9
     * @return true if check was successful, false otherwise
     */
    public static boolean luhnCheck(int[] digits) {
        int[] numbers = Arrays.copyOf(digits, digits.length);
        int sum = 0;

        for (int i = numbers.length - 1; i >= 0; i--) {
            if (i % 2 == 0) {
                int temp = numbers[i] * 2;
                if (temp > 9) {
                    temp = temp - 9;
                }
                numbers[i] = temp;
            }
            sum += numbers[i];
        }

        return sum % 10 == 0;
    }

    public static void main(String[] args) {
        System.out.println("Luhn algorithm usage examples:");
        int[] validInput = {4, 5, 6, 1, 2, 6, 1, 2, 1, 2, 3, 4, 5, 4, 6, 7};
        int[] invalidInput = {4, 5, 6, 1, 2, 6, 1, 2, 1, 2, 3, 4, 5, 4, 6, 4}; //typo in last symbol
        checkAndPrint(validInput);
        checkAndPrint(invalidInput);

        System.out.println("\nBusiness examples:");
        String validCardNumber = "5265 9251 6151 1412";
        String invalidCardNumber = "4929 3231 3088 1896";
        String illegalCardNumber = "4F15 BC06 3A88 76D5";
        businessExample(validCardNumber);
        businessExample(invalidCardNumber);
        businessExample(illegalCardNumber);
    }

    private static void checkAndPrint(int[] input) {
        String validationResult = Luhn.luhnCheck(input)
                ? "valid"
                : "not valid";
        System.out.println("Input " + Arrays.toString(input) + " is " + validationResult);
    }


    /*
        ========================
         Business usage example
        ========================
     */
    /**
     * Object representation of credit card.
     */
    private record CreditCard(int[] digits) {

        private static final int DIGITS_COUNT = 16;

        /**
         * @param cardNumber string representation of credit card number - 16
         * digits. Can have spaces for digits separation
         * @return credit card object
         * @throws IllegalArgumentException if input string is not 16 digits or
         * if Luhn check was failed
         */
        public static CreditCard fromString(String cardNumber) {
            Objects.requireNonNull(cardNumber);
            String trimmedCardNumber = cardNumber.replaceAll(" ", "");
            if (trimmedCardNumber.length() != DIGITS_COUNT || !trimmedCardNumber.matches("\\d+")) {
                throw new IllegalArgumentException("{" + cardNumber + "} - is not a card number");
            }

            int[] cardNumbers = toIntArray(trimmedCardNumber);
            boolean isValid = luhnCheck(cardNumbers);
            if (!isValid) {
                throw new IllegalArgumentException("Credit card number {" + cardNumber + "} - have a typo");
            }

            return new CreditCard(cardNumbers);
        }

        /**
         * @return string representation separated by space every 4 digits.
         * Example: "5265 9251 6151 1412"
         */
        public String number() {
            StringBuilder result = new StringBuilder();
            for (int i = 0; i < DIGITS_COUNT; i++) {
                if (i % 4 == 0 && i != 0) {
                    result.append(" ");
                }
                result.append(digits[i]);
            }
            return result.toString();
        }

        @Override
        public String toString() {
            return String.format("%s {%s}", CreditCard.class.getSimpleName(), number());
        }

        private static int[] toIntArray(String string) {
            return string.chars()
                    .map(i -> Character.digit(i, 10))
                    .toArray();
        }
    }

    private static void businessExample(String cardNumber) {
        try {
            System.out.println("Trying to create CreditCard object from valid card number: " + cardNumber);
            CreditCard creditCard = CreditCard.fromString(cardNumber);
            System.out.println("And business object is successfully created: " + creditCard + "\n");
        } catch (IllegalArgumentException e) {
            System.out.println("And fail with exception message: " + e.getMessage() + "\n");
        }
    }
}
package com.thealgorithms.others;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import javax.imageio.ImageIO;

/**
 * The Mandelbrot set is the set of complex numbers "c" for which the series
 * "z_(n+1) = z_n * z_n + c" does not diverge, i.e. remains bounded. Thus, a
 * complex number "c" is a member of the Mandelbrot set if, when starting with
 * "z_0 = 0" and applying the iteration repeatedly, the absolute value of "z_n"
 * remains bounded for all "n > 0". Complex numbers can be written as "a + b*i":
 * "a" is the real component, usually drawn on the x-axis, and "b*i" is the
 * imaginary component, usually drawn on the y-axis. Most visualizations of the
 * Mandelbrot set use a color-coding to indicate after how many steps in the
 * series the numbers outside the set cross the divergence threshold. Images of
 * the Mandelbrot set exhibit an elaborate and infinitely complicated boundary
 * that reveals progressively ever-finer recursive detail at increasing
 * magnifications, making the boundary of the Mandelbrot set a fractal curve.
 * (description adapted from https://en.wikipedia.org/wiki/Mandelbrot_set ) (see
 * also https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set
 * )
 */
public class Mandelbrot {

    public static void main(String[] args) {
        // Test black and white
        BufferedImage blackAndWhiteImage = getImage(800, 600, -0.6, 0, 3.2, 50, false);

        // Pixel outside the Mandelbrot set should be white.
        assert blackAndWhiteImage.getRGB(0, 0) == new Color(255, 255, 255).getRGB();

        // Pixel inside the Mandelbrot set should be black.
        assert blackAndWhiteImage.getRGB(400, 300) == new Color(0, 0, 0).getRGB();

        // Test color-coding
        BufferedImage coloredImage = getImage(800, 600, -0.6, 0, 3.2, 50, true);

        // Pixel distant to the Mandelbrot set should be red.
        assert coloredImage.getRGB(0, 0) == new Color(255, 0, 0).getRGB();

        // Pixel inside the Mandelbrot set should be black.
        assert coloredImage.getRGB(400, 300) == new Color(0, 0, 0).getRGB();

        // Save image
        try {
            ImageIO.write(coloredImage, "png", new File("Mandelbrot.png"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Method to generate the image of the Mandelbrot set. Two types of
     * coordinates are used: image-coordinates that refer to the pixels and
     * figure-coordinates that refer to the complex numbers inside and outside
     * the Mandelbrot set. The figure-coordinates in the arguments of this
     * method determine which section of the Mandelbrot set is viewed. The main
     * area of the Mandelbrot set is roughly between "-1.5 < x < 0.5" and "-1 <
     * y < 1" in the figure-coordinates.
     *
     * @param imageWidth The width of the rendered image.
     * @param imageHeight The height of the rendered image.
     * @param figureCenterX The x-coordinate of the center of the figure.
     * @param figureCenterY The y-coordinate of the center of the figure.
     * @param figureWidth The width of the figure.
     * @param maxStep Maximum number of steps to check for divergent behavior.
     * @param useDistanceColorCoding Render in color or black and white.
     * @return The image of the rendered Mandelbrot set.
     */
    public static BufferedImage getImage(
            int imageWidth,
            int imageHeight,
            double figureCenterX,
            double figureCenterY,
            double figureWidth,
            int maxStep,
            boolean useDistanceColorCoding) {
        if (imageWidth <= 0) {
            throw new IllegalArgumentException("imageWidth should be greater than zero");
        }

        if (imageHeight <= 0) {
            throw new IllegalArgumentException("imageHeight should be greater than zero");
        }

        if (maxStep <= 0) {
            throw new IllegalArgumentException("maxStep should be greater than zero");
        }

        BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB);
        double figureHeight = figureWidth / imageWidth * imageHeight;

        // loop through the image-coordinates
        for (int imageX = 0; imageX < imageWidth; imageX++) {
            for (int imageY = 0; imageY < imageHeight; imageY++) {
                // determine the figure-coordinates based on the image-coordinates
                double figureX = figureCenterX + ((double) imageX / imageWidth - 0.5) * figureWidth;
                double figureY = figureCenterY + ((double) imageY / imageHeight - 0.5) * figureHeight;

                double distance = getDistance(figureX, figureY, maxStep);

                // color the corresponding pixel based on the selected coloring-function
                image.setRGB(
                        imageX,
                        imageY,
                        useDistanceColorCoding
                                ? colorCodedColorMap(distance).getRGB()
                                : blackAndWhiteColorMap(distance).getRGB());
            }
        }

        return image;
    }

    /**
     * Black and white color-coding that ignores the relative distance. The
     * Mandelbrot set is black, everything else is white.
     *
     * @param distance Distance until divergence threshold
     * @return The color corresponding to the distance.
     */
    private static Color blackAndWhiteColorMap(double distance) {
        return distance >= 1 ? new Color(0, 0, 0) : new Color(255, 255, 255);
    }

    /**
     * Color-coding taking the relative distance into account. The Mandelbrot
     * set is black.
     *
     * @param distance Distance until divergence threshold.
     * @return The color corresponding to the distance.
     */
    private static Color colorCodedColorMap(double distance) {
        if (distance >= 1) {
            return new Color(0, 0, 0);
        } else {
            // simplified transformation of HSV to RGB
            // distance determines hue
            double hue = 360 * distance;
            double saturation = 1;
            double val = 255;
            int hi = (int) (Math.floor(hue / 60)) % 6;
            double f = hue / 60 - Math.floor(hue / 60);

            int v = (int) val;
            int p = 0;
            int q = (int) (val * (1 - f * saturation));
            int t = (int) (val * (1 - (1 - f) * saturation));

            switch (hi) {
                case 0:
                    return new Color(v, t, p);
                case 1:
                    return new Color(q, v, p);
                case 2:
                    return new Color(p, v, t);
                case 3:
                    return new Color(p, q, v);
                case 4:
                    return new Color(t, p, v);
                default:
                    return new Color(v, p, q);
            }
        }
    }

    /**
     * Return the relative distance (ratio of steps taken to maxStep) after
     * which the complex number constituted by this x-y-pair diverges. Members
     * of the Mandelbrot set do not diverge so their distance is 1.
     *
     * @param figureX The x-coordinate within the figure.
     * @param figureX The y-coordinate within the figure.
     * @param maxStep Maximum number of steps to check for divergent behavior.
     * @return The relative distance as the ratio of steps taken to maxStep.
     */
    private static double getDistance(double figureX, double figureY, int maxStep) {
        double a = figureX;
        double b = figureY;
        int currentStep = 0;
        for (int step = 0; step < maxStep; step++) {
            currentStep = step;
            double aNew = a * a - b * b + figureX;
            b = 2 * a * b + figureY;
            a = aNew;

            // divergence happens for all complex number with an absolute value
            // greater than 4 (= divergence threshold)
            if (a * a + b * b > 4) {
                break;
            }
        }
        return (double) currentStep / (maxStep - 1);
    }
}
package com.thealgorithms.others;

/**
 * Dijkstra's algorithm,is a graph search algorithm that solves the
 * single-source shortest path problem for a graph with nonnegative edge path
 * costs, producing a shortest path tree.
 *
 * <p>
 * NOTE: The inputs to Dijkstra's algorithm are a directed and weighted graph
 * consisting of 2 or more nodes, generally represented by an adjacency matrix
 * or list, and a start node.
 *
 * <p>
 * Original source of code:
 * https://rosettacode.org/wiki/Dijkstra%27s_algorithm#Java Also most of the
 * comments are from RosettaCode.
 */
import java.util.*;

public class Dijkstra {

    private static final Graph.Edge[] GRAPH = {
        // Distance from node "a" to node "b" is 7.
        // In the current Graph there is no way to move the other way (e,g, from "b" to "a"),
        // a new edge would be needed for that
        new Graph.Edge("a", "b", 7),
        new Graph.Edge("a", "c", 9),
        new Graph.Edge("a", "f", 14),
        new Graph.Edge("b", "c", 10),
        new Graph.Edge("b", "d", 15),
        new Graph.Edge("c", "d", 11),
        new Graph.Edge("c", "f", 2),
        new Graph.Edge("d", "e", 6),
        new Graph.Edge("e", "f", 9),};
    private static final String START = "a";
    private static final String END = "e";

    /**
     * main function Will run the code with "GRAPH" that was defined above.
     */
    public static void main(String[] args) {
        Graph g = new Graph(GRAPH);
        g.dijkstra(START);
        g.printPath(END);
        // g.printAllPaths();
    }
}

class Graph {
    // mapping of vertex names to Vertex objects, built from a set of Edges

    private final Map<String, Vertex> graph;

    /**
     * One edge of the graph (only used by Graph constructor)
     */
    public static class Edge {

        public final String v1, v2;
        public final int dist;

        public Edge(String v1, String v2, int dist) {
            this.v1 = v1;
            this.v2 = v2;
            this.dist = dist;
        }
    }

    /**
     * One vertex of the graph, complete with mappings to neighbouring vertices
     */
    public static class Vertex implements Comparable<Vertex> {

        public final String name;
        // MAX_VALUE assumed to be infinity
        public int dist = Integer.MAX_VALUE;
        public Vertex previous = null;
        public final Map<Vertex, Integer> neighbours = new HashMap<>();

        public Vertex(String name) {
            this.name = name;
        }

        private void printPath() {
            if (this == this.previous) {
                System.out.printf("%s", this.name);
            } else if (this.previous == null) {
                System.out.printf("%s(unreached)", this.name);
            } else {
                this.previous.printPath();
                System.out.printf(" -> %s(%d)", this.name, this.dist);
            }
        }

        public int compareTo(Vertex other) {
            if (dist == other.dist) {
                return name.compareTo(other.name);
            }

            return Integer.compare(dist, other.dist);
        }

        @Override
        public boolean equals(Object object) {
            if (this == object) {
                return true;
            }
            if (object == null || getClass() != object.getClass()) {
                return false;
            }
            if (!super.equals(object)) {
                return false;
            }

            Vertex vertex = (Vertex) object;

            if (dist != vertex.dist) {
                return false;
            }
            if (name != null ? !name.equals(vertex.name) : vertex.name != null) {
                return false;
            }
            if (previous != null ? !previous.equals(vertex.previous) : vertex.previous != null) {
                return false;
            }
            if (neighbours != null ? !neighbours.equals(vertex.neighbours) : vertex.neighbours != null) {
                return false;
            }

            return true;
        }

        @Override
        public int hashCode() {
            int result = super.hashCode();
            result = 31 * result + (name != null ? name.hashCode() : 0);
            result = 31 * result + dist;
            result = 31 * result + (previous != null ? previous.hashCode() : 0);
            result = 31 * result + (neighbours != null ? neighbours.hashCode() : 0);
            return result;
        }

        @Override
        public String toString() {
            return "(" + name + ", " + dist + ")";
        }
    }

    /**
     * Builds a graph from a set of edges
     */
    public Graph(Edge[] edges) {
        graph = new HashMap<>(edges.length);

        // one pass to find all vertices
        for (Edge e : edges) {
            if (!graph.containsKey(e.v1)) {
                graph.put(e.v1, new Vertex(e.v1));
            }
            if (!graph.containsKey(e.v2)) {
                graph.put(e.v2, new Vertex(e.v2));
            }
        }

        // another pass to set neighbouring vertices
        for (Edge e : edges) {
            graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);
            // graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected
            // graph
        }
    }

    /**
     * Runs dijkstra using a specified source vertex
     */
    public void dijkstra(String startName) {
        if (!graph.containsKey(startName)) {
            System.err.printf("Graph doesn't contain start vertex \"%s\"%n", startName);
            return;
        }
        final Vertex source = graph.get(startName);
        NavigableSet<Vertex> q = new TreeSet<>();

        // set-up vertices
        for (Vertex v : graph.values()) {
            v.previous = v == source ? source : null;
            v.dist = v == source ? 0 : Integer.MAX_VALUE;
            q.add(v);
        }

        dijkstra(q);
    }

    /**
     * Implementation of dijkstra's algorithm using a binary heap.
     */
    private void dijkstra(final NavigableSet<Vertex> q) {
        Vertex u, v;
        while (!q.isEmpty()) {
            // vertex with shortest distance (first iteration will return source)
            u = q.pollFirst();
            if (u.dist == Integer.MAX_VALUE) {
                break; // we can ignore u (and any other remaining vertices) since they are unreachable
            }
            // look at distances to each neighbour
            for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {
                v = a.getKey(); // the neighbour in this iteration

                final int alternateDist = u.dist + a.getValue();
                if (alternateDist < v.dist) { // shorter path to neighbour found
                    q.remove(v);
                    v.dist = alternateDist;
                    v.previous = u;
                    q.add(v);
                }
            }
        }
    }

    /**
     * Prints a path from the source to the specified vertex
     */
    public void printPath(String endName) {
        if (!graph.containsKey(endName)) {
            System.err.printf("Graph doesn't contain end vertex \"%s\"%n", endName);
            return;
        }

        graph.get(endName).printPath();
        System.out.println();
    }

    /**
     * Prints the path from the source to every vertex (output order is not
     * guaranteed)
     */
    public void printAllPaths() {
        for (Vertex v : graph.values()) {
            v.printPath();
            System.out.println();
        }
    }
}
package com.thealgorithms.others;

import java.util.*;

public class InsertDeleteInArray {

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in); // Input statement
        System.out.println("Enter the size of the array");
        int size = s.nextInt();
        int a[] = new int[size];
        int i;

        // To enter the initial elements
        for (i = 0; i < size; i++) {
            System.out.println("Enter the element");
            a[i] = s.nextInt();
        }

        // To insert a new element(we are creating a new array)
        System.out.println("Enter the index at which the element should be inserted");
        int insert_pos = s.nextInt();
        System.out.println("Enter the element to be inserted");
        int ins = s.nextInt();
        int size2 = size + 1;
        int b[] = new int[size2];
        for (i = 0; i < size2; i++) {
            if (i <= insert_pos) {
                b[i] = a[i];
            } else {
                b[i] = a[i - 1];
            }
        }
        b[insert_pos] = ins;
        for (i = 0; i < size2; i++) {
            System.out.println(b[i]);
        }

        // To delete an element given the index
        System.out.println("Enter the index at which element is to be deleted");
        int del_pos = s.nextInt();
        for (i = del_pos; i < size2 - 1; i++) {
            b[i] = b[i + 1];
        }
        for (i = 0; i < size2 - 1; i++) {
            System.out.println(b[i]);
        }
        s.close();
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

class TowerOfHanoi {

    public static void shift(int n, String startPole, String intermediatePole, String endPole) {
        // if n becomes zero the program returns thus ending the loop.
        if (n != 0) {
            // Shift function is called in recursion for swapping the n-1 disc from the startPole to the
            // intermediatePole
            shift(n - 1, startPole, endPole, intermediatePole);
            System.out.format("Move %d from %s to %s\n", n, startPole, endPole); // Result Printing
            // Shift function is called in recursion for swapping the n-1 disc from the intermediatePole
            // to the endPole
            shift(n - 1, intermediatePole, startPole, endPole);
        }
    }

    public static void main(String[] args) {
        System.out.print("Enter number of discs on Pole 1: ");
        Scanner scanner = new Scanner(System.in);
        int numberOfDiscs = scanner.nextInt(); // input of number of discs on pole 1
        shift(numberOfDiscs, "Pole1", "Pole2", "Pole3"); // Shift function called
        scanner.close();
    }
}
package com.thealgorithms.others;

import java.util.ArrayList;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

/**
 * @author dimgrichr
 */
public class CRCAlgorithm {

    private int correctMess;

    private int wrongMess;

    private int wrongMessCaught;

    private int wrongMessNotCaught;

    private int messSize;

    private double ber;

    private boolean messageChanged;

    private ArrayList<Integer> message;

    private ArrayList<Integer> dividedMessage;

    private ArrayList<Integer> p;

    private Random randomGenerator;

    /**
     * The algorithm's main constructor. The most significant variables, used in
     * the algorithm, are set in their initial values.
     *
     * @param str The binary number P, in a string form, which is used by the
     * CRC algorithm
     * @param size The size of every transmitted message
     * @param ber The Bit Error Rate
     */
    public CRCAlgorithm(String str, int size, double ber) {
        messageChanged = false;
        message = new ArrayList<>();
        messSize = size;
        dividedMessage = new ArrayList<>();
        p = new ArrayList<>();
        for (int i = 0; i < str.length(); i++) {
            p.add(Character.getNumericValue(str.charAt(i)));
        }
        randomGenerator = new Random();
        correctMess = 0;
        wrongMess = 0;
        wrongMessCaught = 0;
        wrongMessNotCaught = 0;
        this.ber = ber;
    }

    /**
     * Returns the counter wrongMess
     *
     * @return wrongMess, the number of Wrong Messages
     */
    public int getWrongMess() {
        return wrongMess;
    }

    /**
     * Returns the counter wrongMessCaught
     *
     * @return wrongMessCaught, the number of wrong messages, which are caught
     * by the CRC algoriithm
     */
    public int getWrongMessCaught() {
        return wrongMessCaught;
    }

    /**
     * Returns the counter wrongMessNotCaught
     *
     * @return wrongMessNotCaught, the number of wrong messages, which are not
     * caught by the CRC algorithm
     */
    public int getWrongMessNotCaught() {
        return wrongMessNotCaught;
    }

    /**
     * Returns the counter correctMess
     *
     * @return correctMess, the number of the Correct Messages
     */
    public int getCorrectMess() {
        return correctMess;
    }

    /**
     * Resets some of the object's values, used on the main function, so that it
     * can be re-used, in order not to waste too much memory and time, by
     * creating new objects.
     */
    public void refactor() {
        messageChanged = false;
        message = new ArrayList<>();
        dividedMessage = new ArrayList<>();
    }

    /**
     * Random messages, consisted of 0's and 1's, are generated, so that they
     * can later be transmitted
     */
    public void generateRandomMess() {
        for (int i = 0; i < messSize; i++) {
            int x = ThreadLocalRandom.current().nextInt(0, 2);
            message.add(x);
        }
    }

    /**
     * The most significant part of the CRC algorithm. The message is divided by
     * P, so the dividedMessage ArrayList<Integer> is created. If check == true,
     * the dividedMessaage is examined, in order to see if it contains any 1's.
     * If it does, the message is considered to be wrong by the receiver,so the
     * variable wrongMessCaught changes. If it does not, it is accepted, so one
     * of the variables correctMess, wrongMessNotCaught, changes. If check ==
     * false, the diviided Message is added at the end of the ArrayList<integer>
     * message.
     *
     * @param check the variable used to determine, if the message is going to
     * be checked from the receiver if true, it is checked otherwise, it is not
     */
    public void divideMessageWithP(boolean check) {
        ArrayList<Integer> x = new ArrayList<>();
        ArrayList<Integer> k = (ArrayList<Integer>) message.clone();
        if (!check) {
            for (int i = 0; i < p.size() - 1; i++) {
                k.add(0);
            }
        }
        while (!k.isEmpty()) {
            while (x.size() < p.size() && !k.isEmpty()) {
                x.add(k.get(0));
                k.remove(0);
            }
            if (x.size() == p.size()) {
                for (int i = 0; i < p.size(); i++) {
                    if (x.get(i) == p.get(i)) {
                        x.set(i, 0);
                    } else {
                        x.set(i, 1);
                    }
                }
                for (int i = 0; i < x.size() && x.get(i) != 1; i++) {
                    x.remove(0);
                }
            }
        }
        dividedMessage = (ArrayList<Integer>) x.clone();
        if (!check) {
            for (int z : dividedMessage) {
                message.add(z);
            }
        } else {
            if (dividedMessage.contains(1) && messageChanged) {
                wrongMessCaught++;
            } else if (!dividedMessage.contains(1) && messageChanged) {
                wrongMessNotCaught++;
            } else if (!messageChanged) {
                correctMess++;
            }
        }
    }

    /**
     * Once the message is transmitted, some of it's elements, is possible to
     * change from 1 to 0, or from 0 to 1, because of the Bit Error Rate (ber).
     * For every element of the message, a random double number is created. If
     * that number is smaller than ber, then the spesific element changes. On
     * the other hand, if it's bigger than ber, it does not. Based on these
     * changes. the boolean variable messageChanged, gets the value: true, or
     * false.
     */
    public void changeMess() {
        for (int y : message) {
            double x = randomGenerator.nextDouble();
            while (x < 0.0000 || x > 1.00000) {
                x = randomGenerator.nextDouble();
            }
            if (x < ber) {
                messageChanged = true;
                if (y == 1) {
                    message.set(message.indexOf(y), 0);
                } else {
                    message.set(message.indexOf(y), 1);
                }
            }
        }
        if (messageChanged) {
            wrongMess++;
        }
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

public class CountChar {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("Enter your text: ");
        String str = input.nextLine();
        input.close();
        System.out.println("There are " + CountCharacters(str) + " characters.");
    }

    /**
     * Count non space character in string
     *
     * @param str String to count the characters
     * @return number of character in the specified string
     */
    private static int CountCharacters(String str) {
        return str.replaceAll("\\s", "").length();
    }
}
package com.thealgorithms.others;
/**
 * @author Alexandros Lemonaris
 */

import java.util.ArrayList;

public abstract class MemoryManagementAlgorithms {

    /**
     * Method to allocate memory to blocks according to CPU algorithms.
     * Use of inheritance to avoid repeated code.
     * Abstract method since it is implemented different for each algorithm.
     * It should return an ArrayList of Integers, where the index is the process
     * ID (zero-indexed) and the value is the block number (also zero-indexed).
     * @param sizeOfBlocks an int array that contains the sizes of the memory
     * blocks available.
     * @param sizeOfProcesses: an int array that contains the sizes of the
     * processes we need memory blocks for.
     * @return the ArrayList filled with Integers repressenting the memory
     * allocation that took place.
     */
    public abstract ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses);

}
/**
 * @author Dekas Dimitrios
 */
class BestFitCPU extends MemoryManagementAlgorithms {

    private static final int NO_ALLOCATION
            = -255; // if a process has been allocated in position -255,
    // it means that it has not been actually allocated.

    /**
     * Method to find the maximum valued element of an array filled with
     * positive integers.
     *
     * @param array: an array filled with positive integers.
     * @return the maximum valued element of the array.
     */
    private static int findMaxElement(int[] array) {
        int max = -1;
        for (int value : array) {
            if (value > max) {
                max = value;
            }
        }
        return max;
    }

    /**
     * Method to find the index of the memory block that is going to fit the
     * given process based on the best fit algorithm.
     *
     * @param blocks: the array with the available memory blocks.
     * @param process: the size of the process.
     * @return the index of the block that fits, or -255 if no such block
     * exists.
     */
    private static int findBestFit(int[] blockSizes, int processSize) {
        // Initialize minDiff with an unreachable value by a difference between a blockSize and the
        // processSize.
        int minDiff = findMaxElement(blockSizes);
        int index
                = NO_ALLOCATION; // If there is no block that can fit the process, return NO_ALLOCATION as the
        // result.
        for (int i = 0;
             i < blockSizes.length;
             i++) { // Find the most fitting memory block for the given process.
            if (blockSizes[i] - processSize < minDiff && blockSizes[i] - processSize >= 0) {
                minDiff = blockSizes[i] - processSize;
                index = i;
            }
        }
        return index;
    }

    /**
     * Method to allocate memory to blocks according to the best fit algorithm.
     * It should return an ArrayList of Integers, where the index is the process
     * ID (zero-indexed) and the value is the block number (also zero-indexed).
     *
     * @param sizeOfBlocks: an int array that contains the sizes of the memory
     * blocks available.
     * @param sizeOfProcesses: an int array that contains the sizes of the
     * processes we need memory blocks for.
     * @return the ArrayList filled with Integers repressenting the memory
     * allocation that took place.
     */
    public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) {
        // The array list responsible for saving the memory allocations done by the best-fit algorithm
        ArrayList<Integer> memAlloc = new ArrayList<>();
        // Do this for every process
        for (int processSize : sizeOfProcesses) {
            int chosenBlockIdx
                    = findBestFit(
                    sizeOfBlocks, processSize); // Find the index of the memory block going to be used
            memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list
            if (chosenBlockIdx
                    != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,
                sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size
            }
        }
        return memAlloc;
    }

}

/**
 * @author Dekas Dimitrios
 */
class WorstFitCPU extends MemoryManagementAlgorithms {

    private static final int NO_ALLOCATION
            = -255; // if a process has been allocated in position -255,
    // it means that it has not been actually allocated.

    /**
     * Method to find the index of the memory block that is going to fit the
     * given process based on the worst fit algorithm.
     *
     * @param blocks: the array with the available memory blocks.
     * @param process: the size of the process.
     * @return the index of the block that fits, or -255 if no such block
     * exists.
     */
    private static int findWorstFit(int[] blockSizes, int processSize) {
        int max = -1;
        int index = -1;
        for (int i = 0;
             i < blockSizes.length;
             i++) { // Find the index of the biggest memory block available.
            if (blockSizes[i] > max) {
                max = blockSizes[i];
                index = i;
            }
        }
        // If the biggest memory block cannot fit the process, return -255 as the result
        if (processSize > blockSizes[index]) {
            return NO_ALLOCATION;
        }
        return index;
    }

    /**
     * Method to allocate memory to blocks according to the worst fit algorithm.
     * It should return an ArrayList of Integers, where the index is the process
     * ID (zero-indexed) and the value is the block number (also zero-indexed).
     *
     * @param sizeOfBlocks: an int array that contains the sizes of the memory
     * blocks available.
     * @param sizeOfProcesses: an int array that contains the sizes of the
     * processes we need memory blocks for.
     * @return the ArrayList filled with Integers repressenting the memory
     * allocation that took place.
     */
    public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) {
        // The array list responsible for saving the memory allocations done by the worst-fit algorithm
        ArrayList<Integer> memAlloc = new ArrayList<>();
        // Do this for every process
        for (int processSize : sizeOfProcesses) {
            int chosenBlockIdx
                    = findWorstFit(
                    sizeOfBlocks, processSize); // Find the index of the memory block going to be used
            memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list
            if (chosenBlockIdx
                    != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,
                sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size
            }
        }
        return memAlloc;
    }

}

/**
 * @author Dekas Dimitrios
 */
class FirstFitCPU extends MemoryManagementAlgorithms {

    private static final int NO_ALLOCATION
            = -255; // if a process has been allocated in position -255,
    // it means that it has not been actually allocated.

    /**
     * Method to find the index of the memory block that is going to fit the
     * given process based on the first fit algorithm.
     *
     * @param blocks: the array with the available memory blocks.
     * @param process: the size of the process.
     * @return the index of the block that fits, or -255 if no such block
     * exists.
     */
    private static int findFirstFit(int[] blockSizes, int processSize) {
        for (int i = 0; i < blockSizes.length; i++) {
            if (blockSizes[i] >= processSize) {
                return i;
            }
        }
        // If there is not a block that can fit the process, return -255 as the result
        return NO_ALLOCATION;
    }

    /**
     * Method to allocate memory to blocks according to the first fit algorithm.
     * It should return an ArrayList of Integers, where the index is the process
     * ID (zero-indexed) and the value is the block number (also zero-indexed).
     *
     * @param sizeOfBlocks: an int array that contains the sizes of the memory
     * blocks available.
     * @param sizeOfProcesses: an int array that contains the sizes of the
     * processes we need memory blocks for.
     * @return the ArrayList filled with Integers repressenting the memory
     * allocation that took place.
     */
    public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) {
        // The array list responsible for saving the memory allocations done by the first-fit algorithm
        ArrayList<Integer> memAlloc = new ArrayList<>();
        // Do this for every process
        for (int processSize : sizeOfProcesses) {
            int chosenBlockIdx
                    = findFirstFit(
                    sizeOfBlocks, processSize); // Find the index of the memory block going to be used
            memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list
            if (chosenBlockIdx
                    != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,
                sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size
            }
        }
        return memAlloc;
    }

}

/**
 * @author Alexandros Lemonaris
 */
class NextFit extends MemoryManagementAlgorithms {

    private static final int NO_ALLOCATION
            = -255; // if a process has been allocated in position -255,
    // it means that it has not been actually allocated.
    private int counter = 0; // variable that keeps the position of the last registration into the memory
    /**
     * Method to find the index of the memory block that is going to fit the
     * given process based on the next fit algorithm. In the case of next fit,
     * if the search is interrupted in between, the new search is carried out from the last location.
     *
     * @param blocks: the array with the available memory blocks.
     * @param process: the size of the process.
     * @return the index of the block that fits, or -255 if no such block
     * exists.
     */
    private int findNextFit(int[] blockSizes, int processSize) {

        for (int i = 0; i < blockSizes.length; i++) {
            if (counter + i >= blockSizes.length){
                counter = -i; // starts from the start of the array
            }
            if (blockSizes[i + counter] >= processSize) {
                counter += i;
                return counter;
            }
        }
        // If there is not a block that can fit the process, return -255 as the result
        counter += blockSizes.length; // counter keeps its last value
        return NO_ALLOCATION;
    }

    /**
     * Method to allocate memory to blocks according to the first fit algorithm.
     * It should return an ArrayList of Integers, where the index is the process
     * ID (zero-indexed) and the value is the block number (also zero-indexed).
     *
     * @param sizeOfBlocks: an int array that contains the sizes of the memory
     * blocks available.
     * @param sizeOfProcesses: an int array that contains the sizes of the
     * processes we need memory blocks for.
     * @return the ArrayList filled with Integers repressenting the memory
     * allocation that took place.
     */
    public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) {
        // The array list responsible for saving the memory allocations done by the first-fit algorithm
        ArrayList<Integer> memAlloc = new ArrayList<>();
        // Do this for every process
        for (int processSize : sizeOfProcesses) {
            int chosenBlockIdx
                    = findNextFit(
                    sizeOfBlocks, processSize); // Find the index of the memory block going to be used
            memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list
            if (chosenBlockIdx
                    != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,
                sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size
            }
        }
        return memAlloc;
    }

}

package com.thealgorithms.others;

/* Program to reverse a Stack using Recursion*/
import java.util.Stack;

public class ReverseStackUsingRecursion {

    // Stack
    private static Stack<Integer> stack = new Stack<>();

    // Main function
    public static void main(String[] args) {
        // To Create a Dummy Stack containing integers from 0-9
        for (int i = 0; i < 10; i++) {
            stack.push(i);
        }
        System.out.println("STACK");

        // To print that dummy Stack
        for (int k = 9; k >= 0; k--) {
            System.out.println(k);
        }

        // Reverse Function called
        reverseUsingRecursion(stack);

        System.out.println("REVERSED STACK : ");
        // To print reversed  stack
        while (!stack.isEmpty()) {
            System.out.println(stack.pop());
        }
    }

    // Function Used to reverse Stack Using Recursion
    private static void reverseUsingRecursion(Stack<Integer> stack) {
        if (stack.isEmpty()) // If stack is empty then return
        {
            return;
        }
        /* All items are stored in call stack until we reach the end*/

        int temptop = stack.peek();
        stack.pop();
        reverseUsingRecursion(stack); // Recursion call
        insertAtEnd(temptop); // Insert items held in call stack one by one into stack
    }

    // Function used to insert element at the end of stack
    private static void insertAtEnd(int temptop) {
        if (stack.isEmpty()) {
            stack.push(temptop); // If stack is empty push the element
        } else {
            int temp = stack.peek();
            /* All the items are stored in call stack until we reach end*/
            stack.pop();

            insertAtEnd(temptop); // Recursive call

            stack.push(temp);
        }
    }
}
package com.thealgorithms.others;

import java.util.BitSet;

/**
 * Generates a crc32 checksum for a given string or byte array
 */
public class CRC32 {

    public static void main(String[] args) {
        System.out.println(Integer.toHexString(crc32("Hello World")));
    }

    public static int crc32(String str) {
        return crc32(str.getBytes());
    }

    public static int crc32(byte[] data) {
        BitSet bitSet = BitSet.valueOf(data);
        int crc32 = 0xFFFFFFFF; // initial value
        for (int i = 0; i < data.length * 8; i++) {
            if (((crc32 >>> 31) & 1) != (bitSet.get(i) ? 1 : 0)) {
                crc32 = (crc32 << 1) ^ 0x04C11DB7; // xor with polynomial
            } else {
                crc32 = (crc32 << 1);
            }
        }
        crc32 = Integer.reverse(crc32); // result reflect
        return crc32 ^ 0xFFFFFFFF; // final xor value
    }
}
package com.thealgorithms.others;

/**
 * Given a matrix of size n x n We have to rotate this matrix by 90 Degree Here
 * is the algorithm for this problem .
 */
import java.util.*;

class Rotate_by_90_degree {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();

        while (t-- > 0) {
            int n = sc.nextInt();
            int[][] arr = new int[n][n];

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    arr[i][j] = sc.nextInt();
                }
            }

            Rotate g = new Rotate();
            g.rotate(arr);
            printMatrix(arr);
        }
        sc.close();
    }

    static void printMatrix(int arr[][]) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println("");
        }
    }
}

/**
 * Class containing the algo to roate matrix by 90 degree
 */
class Rotate {

    static void rotate(int a[][]) {
        int n = a.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i > j) {
                    int temp = a[i][j];
                    a[i][j] = a[j][i];
                    a[j][i] = temp;
                }
            }
        }
        int i = 0, k = n - 1;
        while (i < k) {
            for (int j = 0; j < n; j++) {
                int temp = a[i][j];
                a[i][j] = a[k][j];
                a[k][j] = temp;
            }

            i++;
            k--;
        }
    }
}
package com.thealgorithms.others;

import java.util.InputMismatchException;
import java.util.Scanner;

/**
 * Class for finding the lowest base in which a given integer is a palindrome.
 * Includes auxiliary methods for converting between bases and reversing
 * strings.
 *
 * <p>
 * NOTE: There is potential for error, see note at line 63.
 *
 * @author RollandMichael
 * @version 2017.09.28
 */
public class LowestBasePalindrome {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = 0;
        while (true) {
            try {
                System.out.print("Enter number: ");
                n = in.nextInt();
                break;
            } catch (InputMismatchException e) {
                System.out.println("Invalid input!");
                in.next();
            }
        }
        System.out.println(n + " is a palindrome in base " + lowestBasePalindrome(n));
        System.out.println(base2base(Integer.toString(n), 10, lowestBasePalindrome(n)));
        in.close();
    }

    /**
     * Given a number in base 10, returns the lowest base in which the number is
     * represented by a palindrome (read the same left-to-right and
     * right-to-left).
     *
     * @param num A number in base 10.
     * @return The lowest base in which num is a palindrome.
     */
    public static int lowestBasePalindrome(int num) {
        int base, num2 = num;
        int digit;
        char digitC;
        boolean foundBase = false;
        String newNum = "";
        String digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        while (!foundBase) {
            // Try from bases 2 to num-1
            for (base = 2; base < num2; base++) {
                newNum = "";
                while (num > 0) {
                    // Obtain the first digit of n in the current base,
                    // which is equivalent to the integer remainder of (n/base).
                    // The next digit is obtained by dividing n by the base and
                    // continuing the process of getting the remainder. This is done
                    // until n is <=0 and the number in the new base is obtained.
                    digit = (num % base);
                    num /= base;
                    // If the digit isn't in the set of [0-9][A-Z] (beyond base 36), its character
                    // form is just its value in ASCII.

                    // NOTE: This may cause problems, as the capital letters are ASCII values
                    // 65-90. It may cause false positives when one digit is, for instance 10 and assigned
                    // 'A' from the character array and the other is 65 and also assigned 'A'.
                    // Regardless, the character is added to the representation of n
                    // in the current base.
                    if (digit >= digits.length()) {
                        digitC = (char) (digit);
                        newNum += digitC;
                        continue;
                    }
                    newNum += digits.charAt(digit);
                }
                // Num is assigned back its original value for the next iteration.
                num = num2;
                // Auxiliary method reverses the number.
                String reverse = reverse(newNum);
                // If the number is read the same as its reverse, then it is a palindrome.
                // The current base is returned.
                if (reverse.equals(newNum)) {
                    foundBase = true;
                    return base;
                }
            }
        }
        // If all else fails, n is always a palindrome in base n-1. ("11")
        return num - 1;
    }

    private static String reverse(String str) {
        String reverse = "";
        for (int i = str.length() - 1; i >= 0; i--) {
            reverse += str.charAt(i);
        }
        return reverse;
    }

    private static String base2base(String n, int b1, int b2) {
        // Declare variables: decimal value of n,
        // character of base b1, character of base b2,
        // and the string that will be returned.
        int decimalValue = 0, charB2;
        char charB1;
        String output = "";
        // Go through every character of n
        for (int i = 0; i < n.length(); i++) {
            // store the character in charB1
            charB1 = n.charAt(i);
            // if it is a non-number, convert it to a decimal value >9 and store it in charB2
            if (charB1 >= 'A' && charB1 <= 'Z') {
                charB2 = 10 + (charB1 - 'A');
            } // Else, store the integer value in charB2
            else {
                charB2 = charB1 - '0';
            }
            // Convert the digit to decimal and add it to the
            // decimalValue of n
            decimalValue = decimalValue * b1 + charB2;
        }

        // Converting the decimal value to base b2:
        // A number is converted from decimal to another base
        // by continuously dividing by the base and recording
        // the remainder until the quotient is zero. The number in the
        // new base is the remainders, with the last remainder
        // being the left-most digit.
        // While the quotient is NOT zero:
        while (decimalValue != 0) {
            // If the remainder is a digit < 10, simply add it to
            // the left side of the new number.
            if (decimalValue % b2 < 10) {
                output = Integer.toString(decimalValue % b2) + output;
            } // If the remainder is >= 10, add a character with the
            // corresponding value to the new number. (A = 10, B = 11, C = 12, ...)
            else {
                output = (char) ((decimalValue % b2) + 55) + output;
            }
            // Divide by the new base again
            decimalValue /= b2;
        }
        return output;
    }
}
package com.thealgorithms.others;

import java.util.Arrays;

/**
 * BFPRT algorithm.
 */
public class BFPRT {

    public static int[] getMinKNumsByBFPRT(int[] arr, int k) {
        if (k < 1 || k > arr.length) {
            return null;
        }
        int minKth = getMinKthByBFPRT(arr, k);
        int[] res = new int[k];
        int index = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < minKth) {
                res[index++] = arr[i];
            }
        }
        for (; index != res.length; index++) {
            res[index] = minKth;
        }
        return res;
    }

    public static int getMinKthByBFPRT(int[] arr, int k) {
        int[] copyArr = copyArray(arr);
        return bfprt(copyArr, 0, copyArr.length - 1, k - 1);
    }

    public static int[] copyArray(int[] arr) {
        int[] copyArr = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            copyArr[i] = arr[i];
        }
        return copyArr;
    }

    public static int bfprt(int[] arr, int begin, int end, int i) {
        if (begin == end) {
            return arr[begin];
        }
        int pivot = medianOfMedians(arr, begin, end);
        int[] pivotRange = partition(arr, begin, end, pivot);
        if (i >= pivotRange[0] && i <= pivotRange[1]) {
            return arr[i];
        } else if (i < pivotRange[0]) {
            return bfprt(arr, begin, pivotRange[0] - 1, i);
        } else {
            return bfprt(arr, pivotRange[1] + 1, end, i);
        }
    }

    /**
     * wikipedia: https://en.wikipedia.org/wiki/Median_of_medians .
     *
     * @param arr an array.
     * @param begin begin num.
     * @param end end num.
     * @return median of medians.
     */
    public static int medianOfMedians(int[] arr, int begin, int end) {
        int num = end - begin + 1;
        int offset = num % 5 == 0 ? 0 : 1;
        int[] mArr = new int[num / 5 + offset];
        for (int i = 0; i < mArr.length; i++) {
            mArr[i] = getMedian(arr, begin + i * 5, Math.min(end, begin + i * 5 + 4));
        }
        return bfprt(mArr, 0, mArr.length - 1, mArr.length / 2);
    }

    public static void swap(int[] arr, int i, int j) {
        int swap = arr[i];
        arr[i] = arr[j];
        arr[j] = swap;
    }

    public static int[] partition(int[] arr, int begin, int end, int num) {
        int small = begin - 1;
        int cur = begin;
        int big = end + 1;
        while (cur != big) {
            if (arr[cur] < num) {
                swap(arr, ++small, cur++);
            } else if (arr[cur] > num) {
                swap(arr, --big, cur);
            } else {
                cur++;
            }
        }
        int[] pivotRange = new int[2];
        pivotRange[0] = small + 1;
        pivotRange[1] = big - 1;
        return pivotRange;
    }

    public static int getMedian(int[] arr, int begin, int end) {
        insertionSort(arr, begin, end);
        int sum = begin + end;
        int mid = sum / 2 + (sum % 2);
        return arr[mid];
    }

    public static void insertionSort(int[] arr, int begin, int end) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = begin + 1; i != end + 1; i++) {
            for (int j = i; j != begin; j--) {
                if (arr[j - 1] > arr[j]) {
                    swap(arr, j - 1, j);
                } else {
                    break;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {11, 9, 1, 3, 9, 2, 2, 5, 6, 5, 3, 5, 9, 7, 2, 5, 5, 1, 9};
        int[] minK = getMinKNumsByBFPRT(arr, 5);
        System.out.println(Arrays.toString(minK));
    }
}
/* this Code is the illustration of Boyer moore's voting algorithm to
find the majority element is an array that appears more than n/2 times in an array
where "n" is the length of the array.
For more information on the algorithm refer https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm
 */
package com.thealgorithms.others;

import java.util.*;

public class BoyerMoore {

    public static int findmajor(int[] a) {
        int count = 0;
        int cand = -1;
        for (int i = 0; i < a.length; i++) {
            if (count == 0) {
                cand = a[i];
                count = 1;
            } else {
                if (a[i] == cand) {
                    count++;
                } else {
                    count--;
                }
            }
        }
        for (int i = 0; i < a.length; i++) {
            if (a[i] == cand) {
                count++;
            }
        }
        if (count > (a.length / 2)) {
            return cand;
        }
        return -1;
    }

    public static void main(String args[]) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        int a[] = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = input.nextInt();
        }
        System.out.println("the majority element is " + findmajor(a));

    }
}
package com.thealgorithms.others;

import java.util.Scanner;

public class ReturnSubsequence {

    public static void main(String[] args) {
        System.out.println("Enter String: ");
        Scanner s = new Scanner(System.in);
        String givenString = s.next(); // given string
        String[] subsequence = returnSubsequence(givenString); // calling returnSubsequence() function
        System.out.println("Subsequences : ");
        // print the given array of subsequences
        for (int i = 0; i < subsequence.length; i++) {
            System.out.println(subsequence[i]);
        }
        s.close();
    }

    /**
     * @param givenString
     * @return subsequence
     */
    private static String[] returnSubsequence(String givenString) {
        if (givenString.length()
                == 0) // If string is empty we will create an array of size=1 and insert "" (Empty string)
        // in it
        {
            String[] ans = new String[1];
            ans[0] = "";
            return ans;
        }
        String[] SmallAns
                = returnSubsequence(
                        givenString.substring(
                                1)); // recursive call to get subsequences of substring starting from index
        // position=1

        String[] ans
                = new String[2 * SmallAns.length]; // Our answer will be an array off string of size=2*SmallAns
        int i = 0;
        for (; i < SmallAns.length; i++) {
            ans[i] = SmallAns[i]; // Copying all the strings present in SmallAns to ans string array
        }
        for (int k = 0; k < SmallAns.length; k++) {
            ans[k + SmallAns.length]
                    = givenString.charAt(0)
                    + SmallAns[k]; // Insert character at index=0 of the given substring in front of every string
            // in SmallAns
        }
        return ans;
    }
}
package com.thealgorithms.minimizinglateness;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.StringTokenizer;

public class MinimizingLateness {

    private static class Schedule { // Schedule class

        int t = 0; // Time required for the operation to be performed
        int d = 0; // Time the job should be completed
        int s = 0; // Start time of the task
        int f = 0; // End time of the operation

        public Schedule(int t, int d) {
            this.t = t;
            this.d = d;
        }
    }

    public static void main(String[] args) throws IOException {
        StringTokenizer token;

        BufferedReader in = new BufferedReader(new FileReader("MinimizingLateness/lateness_data.txt"));
        String ch = in.readLine();
        if (ch == null || ch.isEmpty()) {
            in.close();
            return;
        }
        int indexCount = Integer.parseInt(ch);
        System.out.println("Input Data : ");
        System.out.println(indexCount); // number of operations
        Schedule[] array = new Schedule[indexCount]; // Create an array to hold the operation
        int i = 0;
        while ((ch = in.readLine()) != null) {
            token = new StringTokenizer(ch, " ");
            // Include the time required for the operation to be performed in the array and the time it
            // should be completed.
            array[i]
                    = new Schedule(Integer.parseInt(token.nextToken()), Integer.parseInt(token.nextToken()));
            i++;
            System.out.println(array[i - 1].t + " " + array[i - 1].d);
        }

        int tryTime = 0; // Total time worked
        int lateness = 0; // Lateness
        for (int j = 0; j < indexCount - 1; j++) {
            array[j].s = tryTime; // Start time of the task
            array[j].f = tryTime + array[j].t; // Time finished
            tryTime = tryTime + array[j].t; // Add total work time
            // Lateness
            lateness = lateness + Math.max(0, tryTime - array[j].d);
        }
        System.out.println();
        System.out.println("Output Data : ");
        System.out.println(lateness);
        in.close();
    }
}
package com.thealgorithms.ciphers;

import java.util.HashMap;
import java.util.Map;

/**
 * The simple substitution cipher is a cipher that has been in use for many
 * hundreds of years (an excellent history is given in Simon Singhs 'the Code
 * Book'). It basically consists of substituting every plaintext character for a
 * different ciphertext character. It differs from the Caesar cipher in that the
 * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.
 *
 * @author Hassan Elseoudy
 */
public class SimpleSubstitutionCipher {

    /**
     * Encrypt text by replacing each element with its opposite character.
     *
     * @return Encrypted message
     */
    public static String encode(String message, String cipherSmall) {
        StringBuilder encoded = new StringBuilder();

        // This map is used to encode
        Map<Character, Character> cipherMap = new HashMap<>();

        char beginSmallLetter = 'a';
        char beginCapitalLetter = 'A';

        cipherSmall = cipherSmall.toLowerCase();
        String cipherCapital = cipherSmall.toUpperCase();

        // To handle Small and Capital letters
        for (int i = 0; i < cipherSmall.length(); i++) {
            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));
            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));
        }

        for (int i = 0; i < message.length(); i++) {
            if (Character.isAlphabetic(message.charAt(i))) {
                encoded.append(cipherMap.get(message.charAt(i)));
            } else {
                encoded.append(message.charAt(i));
            }
        }

        return encoded.toString();
    }

    /**
     * Decrypt message by replacing each element with its opposite character in
     * cipher.
     *
     * @return message
     */
    public static String decode(String encryptedMessage, String cipherSmall) {
        StringBuilder decoded = new StringBuilder();

        Map<Character, Character> cipherMap = new HashMap<>();

        char beginSmallLetter = 'a';
        char beginCapitalLetter = 'A';

        cipherSmall = cipherSmall.toLowerCase();
        String cipherCapital = cipherSmall.toUpperCase();

        for (int i = 0; i < cipherSmall.length(); i++) {
            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);
            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);
        }

        for (int i = 0; i < encryptedMessage.length(); i++) {
            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {
                decoded.append(cipherMap.get(encryptedMessage.charAt(i)));
            } else {
                decoded.append(encryptedMessage.charAt(i));
            }
        }

        return decoded.toString();
    }

    /**
     * TODO remove main and make JUnit Testing
     */
    public static void main(String[] args) {
        String a = encode("defend the east wall of the castle", "phqgiumeaylnofdxjkrcvstzwb");
        String b = decode(a, "phqgiumeaylnofdxjkrcvstzwb");
        System.out.println(b);
    }
}
package com.thealgorithms.ciphers;

import java.util.Objects;

/**
 * Columnar Transposition Cipher Encryption and Decryption.
 *
 * @author <a href="https://github.com/freitzzz">freitzzz</a>
 */
public class ColumnarTranspositionCipher {

    private static String keyword;
    private static Object[][] table;
    private static String abecedarium;
    public static final String ABECEDARIUM
            = "abcdefghijklmnopqrstuvwxyzABCDEFG" + "HIJKLMNOPQRSTUVWXYZ0123456789,.;:-@";
    private static final String ENCRYPTION_FIELD = "≈";
    private static final char ENCRYPTION_FIELD_CHAR = '≈';

    /**
     * Encrypts a certain String with the Columnar Transposition Cipher Rule
     *
     * @param word Word being encrypted
     * @param keyword String with keyword being used
     * @return a String with the word encrypted by the Columnar Transposition
     * Cipher Rule
     */
    public static String encrpyter(String word, String keyword) {
        ColumnarTranspositionCipher.keyword = keyword;
        abecedariumBuilder(500);
        table = tableBuilder(word);
        Object[][] sortedTable = sortTable(table);
        StringBuilder wordEncrypted = new StringBuilder();
        for (int i = 0; i < sortedTable[i].length; i++) {
            for (int j = 1; j < sortedTable.length; j++) {
                wordEncrypted.append(sortedTable[j][i]);
            }
        }
        return wordEncrypted.toString();
    }

    /**
     * Encrypts a certain String with the Columnar Transposition Cipher Rule
     *
     * @param word Word being encrypted
     * @param keyword String with keyword being used
     * @param abecedarium String with the abecedarium being used. null for
     * default one
     * @return a String with the word encrypted by the Columnar Transposition
     * Cipher Rule
     */
    public static String encrpyter(String word, String keyword, String abecedarium) {
        ColumnarTranspositionCipher.keyword = keyword;
        ColumnarTranspositionCipher.abecedarium = Objects.requireNonNullElse(abecedarium, ABECEDARIUM);
        table = tableBuilder(word);
        Object[][] sortedTable = sortTable(table);
        StringBuilder wordEncrypted = new StringBuilder();
        for (int i = 0; i < sortedTable[0].length; i++) {
            for (int j = 1; j < sortedTable.length; j++) {
                wordEncrypted.append(sortedTable[j][i]);
            }
        }
        return wordEncrypted.toString();
    }

    /**
     * Decrypts a certain encrypted String with the Columnar Transposition
     * Cipher Rule
     *
     * @return a String decrypted with the word encrypted by the Columnar
     * Transposition Cipher Rule
     */
    public static String decrypter() {
        StringBuilder wordDecrypted = new StringBuilder();
        for (int i = 1; i < table.length; i++) {
            for (Object item : table[i]) {
                wordDecrypted.append(item);
            }
        }
        return wordDecrypted.toString().replaceAll(ENCRYPTION_FIELD, "");
    }

    /**
     * Builds a table with the word to be encrypted in rows by the Columnar
     * Transposition Cipher Rule
     *
     * @return An Object[][] with the word to be encrypted filled in rows and
     * columns
     */
    private static Object[][] tableBuilder(String word) {
        Object[][] table = new Object[numberOfRows(word) + 1][keyword.length()];
        char[] wordInChards = word.toCharArray();
        // Fils in the respective numbers
        table[0] = findElements();
        int charElement = 0;
        for (int i = 1; i < table.length; i++) {
            for (int j = 0; j < table[i].length; j++) {
                if (charElement < wordInChards.length) {
                    table[i][j] = wordInChards[charElement];
                    charElement++;
                } else {
                    table[i][j] = ENCRYPTION_FIELD_CHAR;
                }
            }
        }
        return table;
    }

    /**
     * Determines the number of rows the table should have regarding the
     * Columnar Transposition Cipher Rule
     *
     * @return an int with the number of rows that the table should have in
     * order to respect the Columnar Transposition Cipher Rule.
     */
    private static int numberOfRows(String word) {
        if (word.length() / keyword.length() > word.length() / keyword.length()) {
            return (word.length() / keyword.length()) + 1;
        } else {
            return word.length() / keyword.length();
        }
    }

    /**
     * @return charValues
     */
    private static Object[] findElements() {
        Object[] charValues = new Object[keyword.length()];
        for (int i = 0; i < charValues.length; i++) {
            int charValueIndex = abecedarium.indexOf(keyword.charAt(i));
            charValues[i] = charValueIndex > -1 ? charValueIndex : null;
        }
        return charValues;
    }

    /**
     * @return tableSorted
     */
    private static Object[][] sortTable(Object[][] table) {
        Object[][] tableSorted = new Object[table.length][table[0].length];
        for (int i = 0; i < tableSorted.length; i++) {
            System.arraycopy(table[i], 0, tableSorted[i], 0, tableSorted[i].length);
        }
        for (int i = 0; i < tableSorted[0].length; i++) {
            for (int j = i + 1; j < tableSorted[0].length; j++) {
                if ((int) tableSorted[0][i] > (int) table[0][j]) {
                    Object[] column = getColumn(tableSorted, tableSorted.length, i);
                    switchColumns(tableSorted, j, i, column);
                }
            }
        }
        return tableSorted;
    }

    /**
     * @return columnArray
     */
    private static Object[] getColumn(Object[][] table, int rows, int column) {
        Object[] columnArray = new Object[rows];
        for (int i = 0; i < rows; i++) {
            columnArray[i] = table[i][column];
        }
        return columnArray;
    }

    private static void switchColumns(
            Object[][] table, int firstColumnIndex, int secondColumnIndex, Object[] columnToSwitch) {
        for (int i = 0; i < table.length; i++) {
            table[i][secondColumnIndex] = table[i][firstColumnIndex];
            table[i][firstColumnIndex] = columnToSwitch[i];
        }
    }

    /**
     * Creates an abecedarium with a specified ascii inded
     *
     * @param value Number of characters being used based on the ASCII Table
     */
    private static void abecedariumBuilder(int value) {
        StringBuilder t = new StringBuilder();
        for (int i = 0; i < value; i++) {
            t.append((char) i);
        }
        abecedarium = t.toString();
    }

    private static void showTable() {
        for (Object[] table1 : table) {
            for (Object item : table1) {
                System.out.print(item + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        String keywordForExample = "asd215";
        String wordBeingEncrypted = "This is a test of the Columnar Transposition Cipher";
        System.out.println("### Example of Columnar Transposition Cipher ###\n");
        System.out.println("Word being encryped ->>> " + wordBeingEncrypted);
        System.out.println(
                "Word encrypted ->>> "
                + ColumnarTranspositionCipher.encrpyter(wordBeingEncrypted, keywordForExample));
        System.out.println("Word decryped ->>> " + ColumnarTranspositionCipher.decrypter());
        System.out.println("\n### Encrypted Table ###");
        showTable();
    }
}
package com.thealgorithms.ciphers;

import java.util.HashMap;
import java.util.Map;

/**
 * The simple substitution cipher is a cipher that has been in use for many
 * hundreds of years (an excellent history is given in Simon Singhs 'the Code
 * Book'). It basically consists of substituting every plaintext character for a
 * different ciphertext character. It differs from the Caesar cipher in that the
 * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.
 */
public class SimpleSubCipher {

    /**
     * Encrypt text by replacing each element with its opposite character.
     *
     * @param message
     * @param cipherSmall
     * @return Encrypted message
     */
    public static String encode(String message, String cipherSmall) {
        String encoded = "";

        // This map is used to encode
        Map<Character, Character> cipherMap = new HashMap<>();

        char beginSmallLetter = 'a';
        char beginCapitalLetter = 'A';

        cipherSmall = cipherSmall.toLowerCase();
        String cipherCapital = cipherSmall.toUpperCase();

        // To handle Small and Capital letters
        for (int i = 0; i < cipherSmall.length(); i++) {
            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));
            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));
        }

        for (int i = 0; i < message.length(); i++) {
            if (Character.isAlphabetic(message.charAt(i))) {
                encoded += cipherMap.get(message.charAt(i));
            } else {
                encoded += message.charAt(i);
            }
        }

        return encoded;
    }

    /**
     * Decrypt message by replacing each element with its opposite character in
     * cipher.
     *
     * @param encryptedMessage
     * @param cipherSmall
     * @return message
     */
    public static String decode(String encryptedMessage, String cipherSmall) {
        String decoded = "";

        Map<Character, Character> cipherMap = new HashMap<Character, Character>();

        char beginSmallLetter = 'a';
        char beginCapitalLetter = 'A';

        cipherSmall = cipherSmall.toLowerCase();
        String cipherCapital = cipherSmall.toUpperCase();

        for (int i = 0; i < cipherSmall.length(); i++) {
            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);
            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);
        }

        for (int i = 0; i < encryptedMessage.length(); i++) {
            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {
                decoded += cipherMap.get(encryptedMessage.charAt(i));
            } else {
                decoded += encryptedMessage.charAt(i);
            }
        }

        return decoded;
    }

    public static void main(String[] args) {
        String a = encode("defend the east wall of the castle", "phqgiumeaylnofdxjkrcvstzwb");
        String b = decode(a, "phqgiumeaylnofdxjkrcvstzwb");
        System.out.println(b);
    }

}
package com.thealgorithms.ciphers;

import java.util.Scanner;

/**
 * A Java implementation of Caesar Cipher. /It is a type of substitution cipher
 * in which each letter in the plaintext is replaced by a letter some fixed
 * number of positions down the alphabet. /
 *
 * @author FAHRI YARDIMCI
 * @author khalil2535
 */
public class Caesar {

    /**
     * Encrypt text by shifting every Latin char by add number shift for ASCII
     * Example : A + 1 -> B
     *
     * @return Encrypted message
     */
    public static String encode(String message, int shift) {
        StringBuilder encoded = new StringBuilder();

        shift %= 26;

        final int length = message.length();
        for (int i = 0; i < length; i++) {

            //            int current = message.charAt(i); //using char to shift characters because ascii
            // is in-order latin alphabet
            char current = message.charAt(i); // Java law : char + int = char

            if (IsCapitalLatinLetter(current)) {

                current += shift;
                encoded.append((char) (current > 'Z' ? current - 26 : current)); // 26 = number of latin letters

            } else if (IsSmallLatinLetter(current)) {

                current += shift;
                encoded.append((char) (current > 'z' ? current - 26 : current)); // 26 = number of latin letters

            } else {
                encoded.append(current);
            }
        }
        return encoded.toString();
    }

    /**
     * Decrypt message by shifting back every Latin char to previous the ASCII
     * Example : B - 1 -> A
     *
     * @return message
     */
    public static String decode(String encryptedMessage, int shift) {
        StringBuilder decoded = new StringBuilder();

        shift %= 26;

        final int length = encryptedMessage.length();
        for (int i = 0; i < length; i++) {
            char current = encryptedMessage.charAt(i);
            if (IsCapitalLatinLetter(current)) {

                current -= shift;
                decoded.append((char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters

            } else if (IsSmallLatinLetter(current)) {

                current -= shift;
                decoded.append((char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters

            } else {
                decoded.append(current);
            }
        }
        return decoded.toString();
    }

    /**
     * @return true if character is capital Latin letter or false for others
     */
    private static boolean IsCapitalLatinLetter(char c) {
        return c >= 'A' && c <= 'Z';
    }

    /**
     * @return true if character is small Latin letter or false for others
     */
    private static boolean IsSmallLatinLetter(char c) {
        return c >= 'a' && c <= 'z';
    }
    /**
     *  @return string array which contains all the possible decoded combination.
     */
    public static String[] bruteforce(String encryptedMessage) {
        String[] listOfAllTheAnswers = new String[27];
        for (int i=0; i<=26; i++) {
            listOfAllTheAnswers[i] = decode(encryptedMessage, i);
        }

        return listOfAllTheAnswers;
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int shift = 0;
        System.out.println("Please enter the message (Latin Alphabet)");
        String message = input.nextLine();
        System.out.println(message);
        System.out.println("(E)ncode or (D)ecode or (B)ruteforce?");
        char choice = input.next().charAt(0);
        switch (choice) {
            case 'E':
            case 'e':
                System.out.println("Please enter the shift number");
                shift = input.nextInt() % 26;
                System.out.println(
                        "ENCODED MESSAGE IS \n" + encode(message, shift)); // send our function to handle
                break;
            case 'D':
            case 'd':
                System.out.println("Please enter the shift number");
                shift = input.nextInt() % 26;
                System.out.println("DECODED MESSAGE IS \n" + decode(message, shift));
                break;
            case 'B':
            case 'b':
                String[] listOfAllTheAnswers = bruteforce(message);
                for (int i =0; i<=26; i++) {
                    System.out.println("FOR SHIFT " + String.valueOf(i) + " decoded message is " + listOfAllTheAnswers[i]);
                }
            default:
                System.out.println("default case");
        }
        
        input.close();
    }
}
package com.thealgorithms.ciphers;

import java.util.Scanner;

/*
 * Java Implementation of Hill Cipher
 * Hill cipher is a polyalphabetic substitution cipher. Each letter is represented by a number belonging to the set Z26 where A=0 , B=1, ..... Z=25.
 * To encrypt a message, each block of n letters (since matrix size is n x n) is multiplied by an invertible n × n matrix, against modulus 26.
 * To decrypt the message, each block is multiplied by the inverse of the matrix used for encryption.
 * The cipher key and plaintext/ciphertext are user inputs.
 * @author Ojasva Jain
 */
public class HillCipher {

    static Scanner userInput = new Scanner(System.in);

    /* Following function encrypts the message
     */
    static void encrypt(String message) {
        message = message.toUpperCase();
        // Get key matrix
        System.out.println("Enter key matrix size");
        int matrixSize = userInput.nextInt();
        System.out.println("Enter Key/encryptionKey matrix ");
        int keyMatrix[][] = new int[matrixSize][matrixSize];
        for (int i = 0; i < matrixSize; i++) {
            for (int j = 0; j < matrixSize; j++) {
                keyMatrix[i][j] = userInput.nextInt();
            }
        }
        //check if det = 0
        validateDeterminant(keyMatrix,matrixSize);

        int[][] messageVector = new int[matrixSize][1];
        String CipherText = "";
        int cipherMatrix[][] = new int[matrixSize][1];
        int j = 0;
        while (j < message.length()) {
            for (int i = 0; i < matrixSize; i++) {
                if (j >= message.length()) {
                    messageVector[i][0] = 23;
                } else {
                    messageVector[i][0] = (message.charAt(j)) % 65;
                }
                System.out.println(messageVector[i][0]);
                j++;
            }
            int x, i;
            for (i = 0; i < matrixSize; i++) {
                cipherMatrix[i][0] = 0;

                for (x = 0; x < matrixSize; x++) {
                    cipherMatrix[i][0] += keyMatrix[i][x] * messageVector[x][0];
                }
                System.out.println(cipherMatrix[i][0]);
                cipherMatrix[i][0] = cipherMatrix[i][0] % 26;
            }
            for (i = 0; i < matrixSize; i++) {
                CipherText += (char) (cipherMatrix[i][0] + 65);
            }
        }
        System.out.println("Ciphertext: " + CipherText);
    }

    //Following function decrypts a message
    static void decrypt(String message) {
        message = message.toUpperCase();
        // Get key matrix
        System.out.println("Enter key matrix size");
        int n = userInput.nextInt();
        System.out.println("Enter inverseKey/decryptionKey matrix ");
        int keyMatrix[][] = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                keyMatrix[i][j] = userInput.nextInt();
            }
        }
        //check if det = 0
        validateDeterminant(keyMatrix,n);

        //solving for the required plaintext message
        int[][] messageVector = new int[n][1];
        String PlainText = "";
        int plainMatrix[][] = new int[n][1];
        int j = 0;
        while (j < message.length()) {
            for (int i = 0; i < n; i++) {
                if (j >= message.length()) {
                    messageVector[i][0] = 23;
                } else {
                    messageVector[i][0] = (message.charAt(j)) % 65;
                }
                System.out.println(messageVector[i][0]);
                j++;
            }
            int x, i;
            for (i = 0; i < n; i++) {
                plainMatrix[i][0] = 0;

                for (x = 0; x < n; x++) {
                    plainMatrix[i][0] += keyMatrix[i][x] * messageVector[x][0];
                }

                plainMatrix[i][0] = plainMatrix[i][0] % 26;
            }
            for (i = 0; i < n; i++) {
                PlainText += (char) (plainMatrix[i][0] + 65);
            }
        }
        System.out.println("Plaintext: " + PlainText);
    }

    // Determinant calculator
    public static int determinant(int a[][], int n) {
        int det = 0, sign = 1, p = 0, q = 0;

        if (n == 1) {
            det = a[0][0];
        } else {
            int b[][] = new int[n - 1][n - 1];
            for (int x = 0; x < n; x++) {
                p = 0;
                q = 0;
                for (int i = 1; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        if (j != x) {
                            b[p][q++] = a[i][j];
                            if (q % (n - 1) == 0) {
                                p++;
                                q = 0;
                            }
                        }
                    }
                }
                det = det + a[0][x] * determinant(b, n - 1) * sign;
                sign = -sign;
            }
        }
        return det;
    }

    // Function to implement Hill Cipher
    static void hillCipher(String message) {
        message.toUpperCase();
        System.out.println("What do you want to process from the message?");
        System.out.println("Press 1: To Encrypt");
        System.out.println("Press 2: To Decrypt");
        short sc = userInput.nextShort();
        if (sc == 1) {
            encrypt(message);
        } else if (sc == 2) {
            decrypt(message);
        } else {
            System.out.println("Invalid input, program terminated.");
        }
    }

    static void validateDeterminant(int[][] keyMatrix, int n){
        if (determinant(keyMatrix, n) % 26 == 0) {
            System.out.println("Invalid key, as determinant = 0. Program Terminated");
            return;
        }
    }

    // Driver code
    public static void main(String[] args) {
        // Get the message to be encrypted
        System.out.println("Enter message");
        String message = userInput.nextLine();
        hillCipher(message);
    }
}package com.thealgorithms.ciphers;

import java.util.Scanner;

class ProductCipher {

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the input to be encrypted: ");
        String substitutionInput = sc.nextLine();
        System.out.println(" ");
        System.out.println("Enter a number: ");
        int n = sc.nextInt();

        // Substitution encryption
        StringBuffer substitutionOutput = new StringBuffer();
        for (int i = 0; i < substitutionInput.length(); i++) {
            char c = substitutionInput.charAt(i);
            substitutionOutput.append((char) (c + 5));
        }
        System.out.println(" ");
        System.out.println("Substituted text: ");
        System.out.println(substitutionOutput);

        // Transposition encryption
        String transpositionInput = substitutionOutput.toString();
        int modulus;
        if ((modulus = transpositionInput.length() % n) != 0) {
            modulus = n - modulus;

            for (; modulus != 0; modulus--) {
                transpositionInput += "/";
            }
        }
        StringBuffer transpositionOutput = new StringBuffer();
        System.out.println(" ");
        System.out.println("Transposition Matrix: ");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < transpositionInput.length() / n; j++) {
                char c = transpositionInput.charAt(i + (j * n));
                System.out.print(c);
                transpositionOutput.append(c);
            }
            System.out.println();
        }
        System.out.println(" ");
        System.out.println("Final encrypted text: ");
        System.out.println(transpositionOutput);

        // Transposition decryption
        n = transpositionOutput.length() / n;
        StringBuffer transpositionPlaintext = new StringBuffer();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < transpositionOutput.length() / n; j++) {
                char c = transpositionOutput.charAt(i + (j * n));
                transpositionPlaintext.append(c);
            }
        }

        // Substitution decryption
        StringBuffer plaintext = new StringBuffer();
        for (int i = 0; i < transpositionPlaintext.length(); i++) {
            char c = transpositionPlaintext.charAt(i);
            plaintext.append((char) (c - 5));
        }

        System.out.println("Plaintext: ");
        System.out.println(plaintext);
        sc.close();
    }

}
package com.thealgorithms.ciphers;

/*
 * Java program for Blowfish Algorithm 
 * Wikipedia: https://en.wikipedia.org/wiki/Blowfish_(cipher)
 * 
 * Author: Akshay Dubey (https://github.com/itsAkshayDubey)
 * 
 * */

public class Blowfish {
	
	//Initializing substitution boxes
	String S[][]
			= { { "d1310ba6", "98dfb5ac", "2ffd72db", "d01adfb7", "b8e1afed",
				"6a267e96", "ba7c9045", "f12c7f99", "24a19947", "b3916cf7",
				"0801f2e2", "858efc16", "636920d8", "71574e69", "a458fea3",
				"f4933d7e", "0d95748f", "728eb658", "718bcd58", "82154aee",
				"7b54a41d", "c25a59b5", "9c30d539", "2af26013", "c5d1b023",
				"286085f0", "ca417918", "b8db38ef", "8e79dcb0", "603a180e",
				"6c9e0e8b", "b01e8a3e", "d71577c1", "bd314b27", "78af2fda",
				"55605c60", "e65525f3", "aa55ab94", "57489862", "63e81440",
				"55ca396a", "2aab10b6", "b4cc5c34", "1141e8ce", "a15486af",
				"7c72e993", "b3ee1411", "636fbc2a", "2ba9c55d", "741831f6",
				"ce5c3e16", "9b87931e", "afd6ba33", "6c24cf5c", "7a325381",
				"28958677", "3b8f4898", "6b4bb9af", "c4bfe81b", "66282193",
				"61d809cc", "fb21a991", "487cac60", "5dec8032", "ef845d5d",
				"e98575b1", "dc262302", "eb651b88", "23893e81", "d396acc5",
				"0f6d6ff3", "83f44239", "2e0b4482", "a4842004", "69c8f04a",
				"9e1f9b5e", "21c66842", "f6e96c9a", "670c9c61", "abd388f0",
				"6a51a0d2", "d8542f68", "960fa728", "ab5133a3", "6eef0b6c",
				"137a3be4", "ba3bf050", "7efb2a98", "a1f1651d", "39af0176",
				"66ca593e", "82430e88", "8cee8619", "456f9fb4", "7d84a5c3",
				"3b8b5ebe", "e06f75d8", "85c12073", "401a449f", "56c16aa6",
				"4ed3aa62", "363f7706", "1bfedf72", "429b023d", "37d0d724",
				"d00a1248", "db0fead3", "49f1c09b", "075372c9", "80991b7b",
				"25d479d8", "f6e8def7", "e3fe501a", "b6794c3b", "976ce0bd",
				"04c006ba", "c1a94fb6", "409f60c4", "5e5c9ec2", "196a2463",
				"68fb6faf", "3e6c53b5", "1339b2eb", "3b52ec6f", "6dfc511f",
				"9b30952c", "cc814544", "af5ebd09", "bee3d004", "de334afd",
				"660f2807", "192e4bb3", "c0cba857", "45c8740f", "d20b5f39",
				"b9d3fbdb", "5579c0bd", "1a60320a", "d6a100c6", "402c7279",
				"679f25fe", "fb1fa3cc", "8ea5e9f8", "db3222f8", "3c7516df",
				"fd616b15", "2f501ec8", "ad0552ab", "323db5fa", "fd238760",
				"53317b48", "3e00df82", "9e5c57bb", "ca6f8ca0", "1a87562e",
				"df1769db", "d542a8f6", "287effc3", "ac6732c6", "8c4f5573",
				"695b27b0", "bbca58c8", "e1ffa35d", "b8f011a0", "10fa3d98",
				"fd2183b8", "4afcb56c", "2dd1d35b", "9a53e479", "b6f84565",
				"d28e49bc", "4bfb9790", "e1ddf2da", "a4cb7e33", "62fb1341",
				"cee4c6e8", "ef20cada", "36774c01", "d07e9efe", "2bf11fb4",
				"95dbda4d", "ae909198", "eaad8e71", "6b93d5a0", "d08ed1d0",
				"afc725e0", "8e3c5b2f", "8e7594b7", "8ff6e2fb", "f2122b64",
				"8888b812", "900df01c", "4fad5ea0", "688fc31c", "d1cff191",
				"b3a8c1ad", "2f2f2218", "be0e1777", "ea752dfe", "8b021fa1",
				"e5a0cc0f", "b56f74e8", "18acf3d6", "ce89e299", "b4a84fe0",
				"fd13e0b7", "7cc43b81", "d2ada8d9", "165fa266", "80957705",
				"93cc7314", "211a1477", "e6ad2065", "77b5fa86", "c75442f5",
				"fb9d35cf", "ebcdaf0c", "7b3e89a0", "d6411bd3", "ae1e7e49",
				"00250e2d", "2071b35e", "226800bb", "57b8e0af", "2464369b",
				"f009b91e", "5563911d", "59dfa6aa", "78c14389", "d95a537f",
				"207d5ba2", "02e5b9c5", "83260376", "6295cfa9", "11c81968",
				"4e734a41", "b3472dca", "7b14a94a", "1b510052", "9a532915",
				"d60f573f", "bc9bc6e4", "2b60a476", "81e67400", "08ba6fb5",
				"571be91f", "f296ec6b", "2a0dd915", "b6636521", "e7b9f9b6",
				"ff34052e", "c5855664", "53b02d5d", "a99f8fa1", "08ba4799",
			"6e85076a" },
					{ "4b7a70e9", "b5b32944", "db75092e", "c4192623", "ad6ea6b0",
				"49a7df7d", "9cee60b8", "8fedb266", "ecaa8c71", "699a17ff",
				"5664526c", "c2b19ee1", "193602a5", "75094c29", "a0591340",
				"e4183a3e", "3f54989a", "5b429d65", "6b8fe4d6", "99f73fd6",
				"a1d29c07", "efe830f5", "4d2d38e6", "f0255dc1", "4cdd2086",
				"8470eb26", "6382e9c6", "021ecc5e", "09686b3f", "3ebaefc9",
				"3c971814", "6b6a70a1", "687f3584", "52a0e286", "b79c5305",
				"aa500737", "3e07841c", "7fdeae5c", "8e7d44ec", "5716f2b8",
				"b03ada37", "f0500c0d", "f01c1f04", "0200b3ff", "ae0cf51a",
				"3cb574b2", "25837a58", "dc0921bd", "d19113f9", "7ca92ff6",
				"94324773", "22f54701", "3ae5e581", "37c2dadc", "c8b57634",
				"9af3dda7", "a9446146", "0fd0030e", "ecc8c73e", "a4751e41",
				"e238cd99", "3bea0e2f", "3280bba1", "183eb331", "4e548b38",
				"4f6db908", "6f420d03", "f60a04bf", "2cb81290", "24977c79",
				"5679b072", "bcaf89af", "de9a771f", "d9930810", "b38bae12",
				"dccf3f2e", "5512721f", "2e6b7124", "501adde6", "9f84cd87",
				"7a584718", "7408da17", "bc9f9abc", "e94b7d8c", "ec7aec3a",
				"db851dfa", "63094366", "c464c3d2", "ef1c1847", "3215d908",
				"dd433b37", "24c2ba16", "12a14d43", "2a65c451", "50940002",
				"133ae4dd", "71dff89e", "10314e55", "81ac77d6", "5f11199b",
				"043556f1", "d7a3c76b", "3c11183b", "5924a509", "f28fe6ed",
				"97f1fbfa", "9ebabf2c", "1e153c6e", "86e34570", "eae96fb1",
				"860e5e0a", "5a3e2ab3", "771fe71c", "4e3d06fa", "2965dcb9",
				"99e71d0f", "803e89d6", "5266c825", "2e4cc978", "9c10b36a",
				"c6150eba", "94e2ea78", "a5fc3c53", "1e0a2df4", "f2f74ea7",
				"361d2b3d", "1939260f", "19c27960", "5223a708", "f71312b6",
				"ebadfe6e", "eac31f66", "e3bc4595", "a67bc883", "b17f37d1",
				"018cff28", "c332ddef", "be6c5aa5", "65582185", "68ab9802",
				"eecea50f", "db2f953b", "2aef7dad", "5b6e2f84", "1521b628",
				"29076170", "ecdd4775", "619f1510", "13cca830", "eb61bd96",
				"0334fe1e", "aa0363cf", "b5735c90", "4c70a239", "d59e9e0b",
				"cbaade14", "eecc86bc", "60622ca7", "9cab5cab", "b2f3846e",
				"648b1eaf", "19bdf0ca", "a02369b9", "655abb50", "40685a32",
				"3c2ab4b3", "319ee9d5", "c021b8f7", "9b540b19", "875fa099",
				"95f7997e", "623d7da8", "f837889a", "97e32d77", "11ed935f",
				"16681281", "0e358829", "c7e61fd6", "96dedfa1", "7858ba99",
				"57f584a5", "1b227263", "9b83c3ff", "1ac24696", "cdb30aeb",
				"532e3054", "8fd948e4", "6dbc3128", "58ebf2ef", "34c6ffea",
				"fe28ed61", "ee7c3c73", "5d4a14d9", "e864b7e3", "42105d14",
				"203e13e0", "45eee2b6", "a3aaabea", "db6c4f15", "facb4fd0",
				"c742f442", "ef6abbb5", "654f3b1d", "41cd2105", "d81e799e",
				"86854dc7", "e44b476a", "3d816250", "cf62a1f2", "5b8d2646",
				"fc8883a0", "c1c7b6a3", "7f1524c3", "69cb7492", "47848a0b",
				"5692b285", "095bbf00", "ad19489d", "1462b174", "23820e00",
				"58428d2a", "0c55f5ea", "1dadf43e", "233f7061", "3372f092",
				"8d937e41", "d65fecf1", "6c223bdb", "7cde3759", "cbee7460",
				"4085f2a7", "ce77326e", "a6078084", "19f8509e", "e8efd855",
				"61d99735", "a969a7aa", "c50c06c2", "5a04abfc", "800bcadc",
				"9e447a2e", "c3453484", "fdd56705", "0e1e9ec9", "db73dbd3",
				"105588cd", "675fda79", "e3674340", "c5c43465", "713e38d8",
				"3d28f89e", "f16dff20", "153e21e7", "8fb03d4a", "e6e39f2b",
					"db83adf7" },
					{ "e93d5a68", "948140f7", "f64c261c", "94692934", "411520f7",
						"7602d4f7", "bcf46b2e", "d4a20068", "d4082471", "3320f46a",
						"43b7d4b7", "500061af", "1e39f62e", "97244546", "14214f74",
						"bf8b8840", "4d95fc1d", "96b591af", "70f4ddd3", "66a02f45",
						"bfbc09ec", "03bd9785", "7fac6dd0", "31cb8504", "96eb27b3",
						"55fd3941", "da2547e6", "abca0a9a", "28507825", "530429f4",
						"0a2c86da", "e9b66dfb", "68dc1462", "d7486900", "680ec0a4",
						"27a18dee", "4f3ffea2", "e887ad8c", "b58ce006", "7af4d6b6",
						"aace1e7c", "d3375fec", "ce78a399", "406b2a42", "20fe9e35",
						"d9f385b9", "ee39d7ab", "3b124e8b", "1dc9faf7", "4b6d1856",
						"26a36631", "eae397b2", "3a6efa74", "dd5b4332", "6841e7f7",
						"ca7820fb", "fb0af54e", "d8feb397", "454056ac", "ba489527",
						"55533a3a", "20838d87", "fe6ba9b7", "d096954b", "55a867bc",
						"a1159a58", "cca92963", "99e1db33", "a62a4a56", "3f3125f9",
						"5ef47e1c", "9029317c", "fdf8e802", "04272f70", "80bb155c",
						"05282ce3", "95c11548", "e4c66d22", "48c1133f", "c70f86dc",
						"07f9c9ee", "41041f0f", "404779a4", "5d886e17", "325f51eb",
						"d59bc0d1", "f2bcc18f", "41113564", "257b7834", "602a9c60",
						"dff8e8a3", "1f636c1b", "0e12b4c2", "02e1329e", "af664fd1",
						"cad18115", "6b2395e0", "333e92e1", "3b240b62", "eebeb922",
						"85b2a20e", "e6ba0d99", "de720c8c", "2da2f728", "d0127845",
						"95b794fd", "647d0862", "e7ccf5f0", "5449a36f", "877d48fa",
						"c39dfd27", "f33e8d1e", "0a476341", "992eff74", "3a6f6eab",
						"f4f8fd37", "a812dc60", "a1ebddf8", "991be14c", "db6e6b0d",
						"c67b5510", "6d672c37", "2765d43b", "dcd0e804", "f1290dc7",
						"cc00ffa3", "b5390f92", "690fed0b", "667b9ffb", "cedb7d9c",
						"a091cf0b", "d9155ea3", "bb132f88", "515bad24", "7b9479bf",
						"763bd6eb", "37392eb3", "cc115979", "8026e297", "f42e312d",
						"6842ada7", "c66a2b3b", "12754ccc", "782ef11c", "6a124237",
						"b79251e7", "06a1bbe6", "4bfb6350", "1a6b1018", "11caedfa",
						"3d25bdd8", "e2e1c3c9", "44421659", "0a121386", "d90cec6e",
						"d5abea2a", "64af674e", "da86a85f", "bebfe988", "64e4c3fe",
						"9dbc8057", "f0f7c086", "60787bf8", "6003604d", "d1fd8346",
						"f6381fb0", "7745ae04", "d736fccc", "83426b33", "f01eab71",
						"b0804187", "3c005e5f", "77a057be", "bde8ae24", "55464299",
						"bf582e61", "4e58f48f", "f2ddfda2", "f474ef38", "8789bdc2",
						"5366f9c3", "c8b38e74", "b475f255", "46fcd9b9", "7aeb2661",
						"8b1ddf84", "846a0e79", "915f95e2", "466e598e", "20b45770",
						"8cd55591", "c902de4c", "b90bace1", "bb8205d0", "11a86248",
						"7574a99e", "b77f19b6", "e0a9dc09", "662d09a1", "c4324633",
						"e85a1f02", "09f0be8c", "4a99a025", "1d6efe10", "1ab93d1d",
						"0ba5a4df", "a186f20f", "2868f169", "dcb7da83", "573906fe",
						"a1e2ce9b", "4fcd7f52", "50115e01", "a70683fa", "a002b5c4",
						"0de6d027", "9af88c27", "773f8641", "c3604c06", "61a806b5",
						"f0177a28", "c0f586e0", "006058aa", "30dc7d62", "11e69ed7",
						"2338ea63", "53c2dd94", "c2c21634", "bbcbee56", "90bcb6de",
						"ebfc7da1", "ce591d76", "6f05e409", "4b7c0188", "39720a3d",
						"7c927c24", "86e3725f", "724d9db9", "1ac15bb4", "d39eb8fc",
						"ed545578", "08fca5b5", "d83d7cd3", "4dad0fc4", "1e50ef5e",
						"b161e6f8", "a28514d9", "6c51133c", "6fd5c7e7", "56e14ec4",
						"362abfce", "ddc6c837", "d79a3234", "92638212", "670efa8e",
					"406000e0" },
					{ "3a39ce37", "d3faf5cf", "abc27737", "5ac52d1b", "5cb0679e",
						"4fa33742", "d3822740", "99bc9bbe", "d5118e9d", "bf0f7315",
						"d62d1c7e", "c700c47b", "b78c1b6b", "21a19045", "b26eb1be",
						"6a366eb4", "5748ab2f", "bc946e79", "c6a376d2", "6549c2c8",
						"530ff8ee", "468dde7d", "d5730a1d", "4cd04dc6", "2939bbdb",
						"a9ba4650", "ac9526e8", "be5ee304", "a1fad5f0", "6a2d519a",
						"63ef8ce2", "9a86ee22", "c089c2b8", "43242ef6", "a51e03aa",
						"9cf2d0a4", "83c061ba", "9be96a4d", "8fe51550", "ba645bd6",
						"2826a2f9", "a73a3ae1", "4ba99586", "ef5562e9", "c72fefd3",
						"f752f7da", "3f046f69", "77fa0a59", "80e4a915", "87b08601",
						"9b09e6ad", "3b3ee593", "e990fd5a", "9e34d797", "2cf0b7d9",
						"022b8b51", "96d5ac3a", "017da67d", "d1cf3ed6", "7c7d2d28",
						"1f9f25cf", "adf2b89b", "5ad6b472", "5a88f54c", "e029ac71",
						"e019a5e6", "47b0acfd", "ed93fa9b", "e8d3c48d", "283b57cc",
						"f8d56629", "79132e28", "785f0191", "ed756055", "f7960e44",
						"e3d35e8c", "15056dd4", "88f46dba", "03a16125", "0564f0bd",
						"c3eb9e15", "3c9057a2", "97271aec", "a93a072a", "1b3f6d9b",
						"1e6321f5", "f59c66fb", "26dcf319", "7533d928", "b155fdf5",
						"03563482", "8aba3cbb", "28517711", "c20ad9f8", "abcc5167",
						"ccad925f", "4de81751", "3830dc8e", "379d5862", "9320f991",
						"ea7a90c2", "fb3e7bce", "5121ce64", "774fbe32", "a8b6e37e",
						"c3293d46", "48de5369", "6413e680", "a2ae0810", "dd6db224",
						"69852dfd", "09072166", "b39a460a", "6445c0dd", "586cdecf",
						"1c20c8ae", "5bbef7dd", "1b588d40", "ccd2017f", "6bb4e3bb",
						"dda26a7e", "3a59ff45", "3e350a44", "bcb4cdd5", "72eacea8",
						"fa6484bb", "8d6612ae", "bf3c6f47", "d29be463", "542f5d9e",
						"aec2771b", "f64e6370", "740e0d8d", "e75b1357", "f8721671",
						"af537d5d", "4040cb08", "4eb4e2cc", "34d2466a", "0115af84",
						"e1b00428", "95983a1d", "06b89fb4", "ce6ea048", "6f3f3b82",
						"3520ab82", "011a1d4b", "277227f8", "611560b1", "e7933fdc",
						"bb3a792b", "344525bd", "a08839e1", "51ce794b", "2f32c9b7",
						"a01fbac9", "e01cc87e", "bcc7d1f6", "cf0111c3", "a1e8aac7",
						"1a908749", "d44fbd9a", "d0dadecb", "d50ada38", "0339c32a",
						"c6913667", "8df9317c", "e0b12b4f", "f79e59b7", "43f5bb3a",
						"f2d519ff", "27d9459c", "bf97222c", "15e6fc2a", "0f91fc71",
						"9b941525", "fae59361", "ceb69ceb", "c2a86459", "12baa8d1",
						"b6c1075e", "e3056a0c", "10d25065", "cb03a442", "e0ec6e0e",
						"1698db3b", "4c98a0be", "3278e964", "9f1f9532", "e0d392df",
						"d3a0342b", "8971f21e", "1b0a7441", "4ba3348c", "c5be7120",
						"c37632d8", "df359f8d", "9b992f2e", "e60b6f47", "0fe3f11d",
						"e54cda54", "1edad891", "ce6279cf", "cd3e7e6f", "1618b166",
						"fd2c1d05", "848fd2c5", "f6fb2299", "f523f357", "a6327623",
						"93a83531", "56cccd02", "acf08162", "5a75ebb5", "6e163697",
						"88d273cc", "de966292", "81b949d0", "4c50901b", "71c65614",
						"e6c6c7bd", "327a140a", "45e1d006", "c3f27b9a", "c9aa53fd",
						"62a80f00", "bb25bfe2", "35bdd2f6", "71126905", "b2040222",
						"b6cbcf7c", "cd769c2b", "53113ec0", "1640e3d3", "38abbd60",
						"2547adf0", "ba38209c", "f746ce76", "77afa1c5", "20756060",
						"85cbfe4e", "8ae88dd8", "7aaaf9b0", "4cf9aa7e", "1948c25c",
						"02fb8a8c", "01c36ae4", "d6ebe1f9", "90d4f869", "a65cdea0",
						"3f09252d", "c208e69f", "b74e6132", "ce77e25b", "578fdfe3",
					"3ac372e6" } };

	//Initializing subkeys with digits of pi
	String P[] = { "243f6a88", "85a308d3", "13198a2e", "03707344", "a4093822",
			"299f31d0", "082efa98", "ec4e6c89", "452821e6", "38d01377",
			"be5466cf", "34e90c6c", "c0ac29b7", "c97c50dd", "3f84d5b5",
			"b5470917", "9216d5d9", "8979fb1b" };

	//Initializing modVal to 2^32
	long modVal = 4294967296L;
	

    /**
     * This method returns binary representation of the hexadecimal number passed as parameter
     *
     * @param hex Number for which binary representation is required
     * @return String object which is a binary representation of the hex number passed as parameter
     */
	private String hexToBin(String hex)
	{
		String binary = "";
		Long num;
		String binary4B;
		int n = hex.length();
		for (int i = 0; i < n; i++) {

			num = Long.parseUnsignedLong(
					hex.charAt(i) + "", 16);
			binary4B = Long.toBinaryString(num);

			binary4B = "0000" + binary4B;

			binary4B = binary4B.substring(binary4B.length() - 4);
			binary += binary4B;
		}
		return binary;
	}

    /**
     * This method returns hexadecimal representation of the binary number passed as parameter
     *
     * @param binary Number for which hexadecimal representation is required
     * @return String object which is a hexadecimal representation of the binary number passed as parameter
     */
	private String binToHex(String binary)
	{

		long num = Long.parseUnsignedLong(binary, 2);
		String hex = Long.toHexString(num);
		while (hex.length() < (binary.length() / 4))
			hex = "0" + hex;

		return hex;
	}

    /**
     * This method returns a string obtained by XOR-ing two strings of same length passed a method parameters
     *      
     * @param String a and b are string objects which will be XORed and are to be of same length
     * @return String object obtained by XOR operation on String a and String b
     * */
	private String xor(String a, String b)
	{
		a = hexToBin(a);
		b = hexToBin(b);
		String ans = "";
		for (int i = 0; i < a.length(); i++)
			ans += (char)(((a.charAt(i) - '0')
					^ (b.charAt(i) - '0'))
					+ '0');
		ans = binToHex(ans);
		return ans;
	}

    /**
     * This method returns addition of two hexadecimal numbers passed as parameters and moded with 2^32 
     *
     * @param String a and b are hexadecimal numbers
     * @return String object which is a is addition that is then moded with 2^32 of hex numbers passed as parameters
     */
	private String addBin(String a, String b)
	{
		String ans = "";
		long n1 = Long.parseUnsignedLong(a, 16);
		long n2 = Long.parseUnsignedLong(b, 16);
		n1 = (n1 + n2) % modVal;
		ans = Long.toHexString(n1);
		ans = "00000000" + ans;
		return ans.substring(ans.length() - 8);
	}

	/*F-function splits the 32-bit input into four 8-bit quarters 
	 and uses the quarters as input to the S-boxes. 
	 The S-boxes accept 8-bit input and produce 32-bit output. 
	 The outputs are added modulo 232 and XORed to produce the final 32-bit output 
	*/
	private String f(String plainText)
	{
		String a[] = new String[4];
		String ans = "";
		for (int i = 0; i < 8; i += 2) {
			//column number for S-box is a 8-bit value
			long col
			= Long.parseUnsignedLong(
					hexToBin(
							plainText
							.substring(i, i + 2)),
					2);
			a[i / 2] = S[i / 2][(int)col];
		}
		ans = addBin(a[0], a[1]);
		ans = xor(ans, a[2]);
		ans = addBin(ans, a[3]);
		return ans;
	}

	//generate subkeys
	private void keyGenerate(String key)
	{
		int j = 0;
		for (int i = 0; i < P.length; i++) {

			//XOR-ing 32-bit parts of the key with initial subkeys
			P[i] = xor(P[i], key.substring(j, j + 8));

			j = (j + 8) % key.length();
		}
	}

	//round function
	private String round(int time, String plainText)
	{
		String left, right;
		left = plainText.substring(0, 8);
		right = plainText.substring(8, 16);
		left = xor(left, P[time]);

		//output from F function
		String fOut = f(left);

		right = xor(fOut, right);

		//swap left and right
		return right + left;
	}

    /**
     * This method returns cipher text for the plaintext passed as the first parameter generated
     * using the key passed as the second parameter
     *
     * @param String plainText is the text which is to be encrypted
     * @param String key is the key which is to be used for generating cipher text
     * @return String cipherText is the encrypted value
     */
	String encrypt(String plainText, String key)
	{
		//generating key
		keyGenerate(key);
		
		for (int i = 0; i < 16; i++)
			plainText = round(i, plainText);

		//postprocessing
		String right = plainText.substring(0, 8);
		String left = plainText.substring(8, 16);
		right = xor(right, P[16]);
		left = xor(left, P[17]);
		return left + right;
	}
	
    /**
     * This method returns plaintext for the ciphertext passed as the first parameter decoded
     * using the key passed as the second parameter
     *
     * @param String ciphertext is the text which is to be decrypted
     * @param String key is the key which is to be used for generating cipher text
     * @return String plainText is the decrypted text
     */
    String decrypt(String cipherText,String key)
    {
    	//generating key
    	keyGenerate(key);
    	
        for (int i = 17; i > 1; i--)
            cipherText = round(i, cipherText);
 
        //postprocessing
        String right = cipherText.substring(0, 8);
        String left = cipherText.substring(8, 16);
        right = xor(right, P[1]);
        left = xor(left, P[0]);
        return left + right;
    }

}
package com.thealgorithms.ciphers;

class AffineCipher {

    // Key values of a and b
    static int a = 17;
    static int b = 20;

    static String encryptMessage(char[] msg) {
        /// Cipher Text initially empty
        String cipher = "";
        for (int i = 0; i < msg.length; i++) {
            // Avoid space to be encrypted
            /* applying encryption formula ( a x + b ) mod m
            {here x is msg[i] and m is 26} and added 'A' to
            bring it in range of ascii alphabet[ 65-90 | A-Z ] */
            if (msg[i] != ' ') {
                cipher = cipher
                        + (char) ((((a * (msg[i] - 'A')) + b) % 26) + 'A');
            } else // else simply append space character
            {
                cipher += msg[i];
            }
        }
        return cipher;
    }

    static String decryptCipher(String cipher) {
        String msg = "";
        int a_inv = 0;
        int flag = 0;

        //Find a^-1 (the multiplicative inverse of a
        //in the group of integers modulo m.)
        for (int i = 0; i < 26; i++) {
            flag = (a * i) % 26;

            // Check if (a*i)%26 == 1,
            // then i will be the multiplicative inverse of a
            if (flag == 1) {
                a_inv = i;
            }
        }
        for (int i = 0; i < cipher.length(); i++) {
            /*Applying decryption formula a^-1 ( x - b ) mod m
            {here x is cipher[i] and m is 26} and added 'A'
            to bring it in range of ASCII alphabet[ 65-90 | A-Z ] */
            if (cipher.charAt(i) != ' ') {
                msg = msg + (char) (((a_inv
                        * ((cipher.charAt(i) + 'A' - b)) % 26)) + 'A');
            } else //else simply append space character
            {
                msg += cipher.charAt(i);
            }
        }

        return msg;
    }

    // Driver code
    public static void main(String[] args) {
        String msg = "AFFINE CIPHER";

        // Calling encryption function
        String cipherText = encryptMessage(msg.toCharArray());
        System.out.println("Encrypted Message is : " + cipherText);

        // Calling Decryption function
        System.out.println("Decrypted Message is: " + decryptCipher(cipherText));

    }
}
package com.thealgorithms.ciphers;

/**
 * A Java implementation of Vigenere Cipher.
 *
 * @author straiffix
 * @author beingmartinbmc
 */
public class Vigenere {

    public static String encrypt(final String message, final String key) {

        StringBuilder result = new StringBuilder();

        for (int i = 0, j = 0; i < message.length(); i++) {
            char c = message.charAt(i);
            if (Character.isLetter(c)) {
                if (Character.isUpperCase(c)) {
                    result.append((char) ((c + key.toUpperCase().charAt(j) - 2 * 'A') % 26 + 'A'));

                } else {
                    result.append((char) ((c + key.toLowerCase().charAt(j) - 2 * 'a') % 26 + 'a'));
                }
            } else {
                result.append(c);
            }
            j = ++j % key.length();
        }
        return result.toString();
    }

    public static String decrypt(final String message, final String key) {
        StringBuilder result = new StringBuilder();

        for (int i = 0, j = 0; i < message.length(); i++) {

            char c = message.charAt(i);
            if (Character.isLetter(c)) {
                if (Character.isUpperCase(c)) {
                    result.append((char) ('Z' - (25 - (c - key.toUpperCase().charAt(j))) % 26));

                } else {
                    result.append((char) ('z' - (25 - (c - key.toLowerCase().charAt(j))) % 26));
                }
            } else {
                result.append(c);
            }

            j = ++j % key.length();
        }
        return result.toString();
    }

    public static void main(String[] args) {
        String text = "Hello World!";
        String key = "itsakey";
        System.out.println(text);
        String ciphertext = encrypt(text, key);
        System.out.println(ciphertext);
        System.out.println(decrypt(ciphertext, key));
    }
}
package com.thealgorithms.ciphers;

import java.math.BigInteger;
import java.util.Scanner;

/**
 * This class is build to demonstrate the application of the AES-algorithm on a
 * single 128-Bit block of data.
 */
public class AES {

    /**
     * Precalculated values for x to the power of 2 in Rijndaels galois field.
     * Used as 'RCON' during the key expansion.
     */
    private static final int[] RCON = {
        0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
        0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
        0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
        0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
        0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
        0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
        0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
        0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
        0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
        0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
        0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
        0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
        0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
        0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
        0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
        0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
    };

    /**
     * Rijndael S-box Substitution table used for encryption in the subBytes
     * step, as well as the key expansion.
     */
    private static final int[] SBOX = {
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
    };

    /**
     * Inverse Rijndael S-box Substitution table used for decryption in the
     * subBytesDec step.
     */
    private static final int[] INVERSE_SBOX = {
        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
    };

    /**
     * Precalculated lookup table for galois field multiplication by 2 used in
     * the MixColums step during encryption.
     */
    private static final int[] MULT2 = {
        0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
        0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
        0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
        0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
        0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
        0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
        0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
        0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
        0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
        0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
        0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
        0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
        0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
        0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
        0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
        0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5
    };

    /**
     * Precalculated lookup table for galois field multiplication by 3 used in
     * the MixColums step during encryption.
     */
    private static final int[] MULT3 = {
        0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
        0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
        0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
        0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
        0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
        0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
        0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
        0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
        0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
        0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
        0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
        0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
        0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
        0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
        0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
        0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a
    };

    /**
     * Precalculated lookup table for galois field multiplication by 9 used in
     * the MixColums step during decryption.
     */
    private static final int[] MULT9 = {
        0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
        0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
        0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
        0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
        0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
        0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
        0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
        0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
        0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
        0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
        0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
        0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
        0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
        0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
        0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
        0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46
    };

    /**
     * Precalculated lookup table for galois field multiplication by 11 used in
     * the MixColums step during decryption.
     */
    private static final int[] MULT11 = {
        0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
        0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
        0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
        0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
        0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
        0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
        0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
        0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
        0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
        0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
        0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
        0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
        0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
        0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
        0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
        0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3
    };

    /**
     * Precalculated lookup table for galois field multiplication by 13 used in
     * the MixColums step during decryption.
     */
    private static final int[] MULT13 = {
        0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
        0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
        0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
        0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
        0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
        0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
        0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
        0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
        0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
        0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
        0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
        0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
        0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
        0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
        0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
        0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97
    };

    /**
     * Precalculated lookup table for galois field multiplication by 14 used in
     * the MixColums step during decryption.
     */
    private static final int[] MULT14 = {
        0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
        0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
        0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
        0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
        0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
        0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
        0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
        0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
        0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
        0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
        0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
        0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
        0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
        0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
        0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
        0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d
    };

    /**
     * Subroutine of the Rijndael key expansion.
     */
    public static BigInteger scheduleCore(BigInteger t, int rconCounter) {
        StringBuilder rBytes = new StringBuilder(t.toString(16));

        // Add zero padding
        while (rBytes.length() < 8) {
            rBytes.insert(0, "0");
        }

        // rotate the first 16 bits to the back
        String rotatingBytes = rBytes.substring(0, 2);
        String fixedBytes = rBytes.substring(2);

        rBytes = new StringBuilder(fixedBytes + rotatingBytes);

        // apply S-Box to all 8-Bit Substrings
        for (int i = 0; i < 4; i++) {
            StringBuilder currentByteBits = new StringBuilder(rBytes.substring(i * 2, (i + 1) * 2));

            int currentByte = Integer.parseInt(currentByteBits.toString(), 16);
            currentByte = SBOX[currentByte];

            // add the current RCON value to the first byte
            if (i == 0) {
                currentByte = currentByte ^ RCON[rconCounter];
            }

            currentByteBits = new StringBuilder(Integer.toHexString(currentByte));

            // Add zero padding
            while (currentByteBits.length() < 2) {
                currentByteBits.insert(0, '0');
            }

            // replace bytes in original string
            rBytes = new StringBuilder(rBytes.substring(0, i * 2) + currentByteBits + rBytes.substring((i + 1) * 2));
        }

        // t = new BigInteger(rBytes, 16);
        // return t;
        return new BigInteger(rBytes.toString(), 16);
    }

    /**
     * Returns an array of 10 + 1 round keys that are calculated by using
     * Rijndael key schedule
     *
     * @return array of 10 + 1 round keys
     */
    public static BigInteger[] keyExpansion(BigInteger initialKey) {
        BigInteger[] roundKeys = {
            initialKey,
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),};

        // initialize rcon iteration
        int rconCounter = 1;

        for (int i = 1; i < 11; i++) {

            // get the previous 32 bits the key
            BigInteger t = roundKeys[i - 1].remainder(new BigInteger("100000000", 16));

            // split previous key into 8-bit segments
            BigInteger[] prevKey = {
                roundKeys[i - 1].remainder(new BigInteger("100000000", 16)),
                roundKeys[i - 1]
                .remainder(new BigInteger("10000000000000000", 16))
                .divide(new BigInteger("100000000", 16)),
                roundKeys[i - 1]
                .remainder(new BigInteger("1000000000000000000000000", 16))
                .divide(new BigInteger("10000000000000000", 16)),
                roundKeys[i - 1].divide(new BigInteger("1000000000000000000000000", 16)),};

            // run schedule core
            t = scheduleCore(t, rconCounter);
            rconCounter += 1;

            // Calculate partial round key
            BigInteger t0 = t.xor(prevKey[3]);
            BigInteger t1 = t0.xor(prevKey[2]);
            BigInteger t2 = t1.xor(prevKey[1]);
            BigInteger t3 = t2.xor(prevKey[0]);

            // Join round key segments
            t2 = t2.multiply(new BigInteger("100000000", 16));
            t1 = t1.multiply(new BigInteger("10000000000000000", 16));
            t0 = t0.multiply(new BigInteger("1000000000000000000000000", 16));
            roundKeys[i] = t0.add(t1).add(t2).add(t3);
        }
        return roundKeys;
    }

    /**
     * representation of the input 128-bit block as an array of 8-bit integers.
     *
     * @param block of 128-bit integers
     * @return array of 8-bit integers
     */
    public static int[] splitBlockIntoCells(BigInteger block) {

        int[] cells = new int[16];
        StringBuilder blockBits = new StringBuilder(block.toString(2));

        // Append leading 0 for full "128-bit" string
        while (blockBits.length() < 128) {
            blockBits.insert(0, '0');
        }

        // split 128 to 8 bit cells
        for (int i = 0; i < cells.length; i++) {
            String cellBits = blockBits.substring(8 * i, 8 * (i + 1));
            cells[i] = Integer.parseInt(cellBits, 2);
        }

        return cells;
    }

    /**
     * Returns the 128-bit BigInteger representation of the input of an array of
     * 8-bit integers.
     *
     * @param cells that we need to merge
     * @return block of merged cells
     */
    public static BigInteger mergeCellsIntoBlock(int[] cells) {

        StringBuilder blockBits = new StringBuilder();
        for (int i = 0; i < 16; i++) {
            StringBuilder cellBits = new StringBuilder(Integer.toBinaryString(cells[i]));

            // Append leading 0 for full "8-bit" strings
            while (cellBits.length() < 8) {
                cellBits.insert(0, '0');
            }

            blockBits.append(cellBits);
        }

        return new BigInteger(blockBits.toString(), 2);
    }

    /**
     * @return ciphertext XOR key
     */
    public static BigInteger addRoundKey(BigInteger ciphertext, BigInteger key) {
        return ciphertext.xor(key);
    }

    /**
     * substitutes 8-Bit long substrings of the input using the S-Box and
     * returns the result.
     *
     * @return subtraction Output
     */
    public static BigInteger subBytes(BigInteger ciphertext) {

        int[] cells = splitBlockIntoCells(ciphertext);

        for (int i = 0; i < 16; i++) {
            cells[i] = SBOX[cells[i]];
        }

        return mergeCellsIntoBlock(cells);
    }

    /**
     * substitutes 8-Bit long substrings of the input using the inverse S-Box
     * for decryption and returns the result.
     *
     * @return subtraction Output
     */
    public static BigInteger subBytesDec(BigInteger ciphertext) {

        int[] cells = splitBlockIntoCells(ciphertext);

        for (int i = 0; i < 16; i++) {
            cells[i] = INVERSE_SBOX[cells[i]];
        }

        return mergeCellsIntoBlock(cells);
    }

    /**
     * Cell permutation step. Shifts cells within the rows of the input and
     * returns the result.
     */
    public static BigInteger shiftRows(BigInteger ciphertext) {
        int[] cells = splitBlockIntoCells(ciphertext);
        int[] output = new int[16];

        // do nothing in the first row
        output[0] = cells[0];
        output[4] = cells[4];
        output[8] = cells[8];
        output[12] = cells[12];

        // shift the second row backwards by one cell
        output[1] = cells[5];
        output[5] = cells[9];
        output[9] = cells[13];
        output[13] = cells[1];

        // shift the third row backwards by two cell
        output[2] = cells[10];
        output[6] = cells[14];
        output[10] = cells[2];
        output[14] = cells[6];

        // shift the forth row backwards by tree cell
        output[3] = cells[15];
        output[7] = cells[3];
        output[11] = cells[7];
        output[15] = cells[11];

        return mergeCellsIntoBlock(output);
    }

    /**
     * Cell permutation step for decryption . Shifts cells within the rows of
     * the input and returns the result.
     */
    public static BigInteger shiftRowsDec(BigInteger ciphertext) {
        int[] cells = splitBlockIntoCells(ciphertext);
        int[] output = new int[16];

        // do nothing in the first row
        output[0] = cells[0];
        output[4] = cells[4];
        output[8] = cells[8];
        output[12] = cells[12];

        // shift the second row forwards by one cell
        output[1] = cells[13];
        output[5] = cells[1];
        output[9] = cells[5];
        output[13] = cells[9];

        // shift the third row forwards by two cell
        output[2] = cells[10];
        output[6] = cells[14];
        output[10] = cells[2];
        output[14] = cells[6];

        // shift the forth row forwards by tree cell
        output[3] = cells[7];
        output[7] = cells[11];
        output[11] = cells[15];
        output[15] = cells[3];

        return mergeCellsIntoBlock(output);
    }

    /**
     * Applies the Rijndael MixColumns to the input and returns the result.
     */
    public static BigInteger mixColumns(BigInteger ciphertext) {

        int[] cells = splitBlockIntoCells(ciphertext);
        int[] outputCells = new int[16];

        for (int i = 0; i < 4; i++) {
            int[] row = {cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3]};

            outputCells[i * 4] = MULT2[row[0]] ^ MULT3[row[1]] ^ row[2] ^ row[3];
            outputCells[i * 4 + 1] = row[0] ^ MULT2[row[1]] ^ MULT3[row[2]] ^ row[3];
            outputCells[i * 4 + 2] = row[0] ^ row[1] ^ MULT2[row[2]] ^ MULT3[row[3]];
            outputCells[i * 4 + 3] = MULT3[row[0]] ^ row[1] ^ row[2] ^ MULT2[row[3]];
        }
        return mergeCellsIntoBlock(outputCells);
    }

    /**
     * Applies the inverse Rijndael MixColumns for decryption to the input and
     * returns the result.
     */
    public static BigInteger mixColumnsDec(BigInteger ciphertext) {

        int[] cells = splitBlockIntoCells(ciphertext);
        int[] outputCells = new int[16];

        for (int i = 0; i < 4; i++) {
            int[] row = {cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3]};

            outputCells[i * 4] = MULT14[row[0]] ^ MULT11[row[1]] ^ MULT13[row[2]] ^ MULT9[row[3]];
            outputCells[i * 4 + 1] = MULT9[row[0]] ^ MULT14[row[1]] ^ MULT11[row[2]] ^ MULT13[row[3]];
            outputCells[i * 4 + 2] = MULT13[row[0]] ^ MULT9[row[1]] ^ MULT14[row[2]] ^ MULT11[row[3]];
            outputCells[i * 4 + 3] = MULT11[row[0]] ^ MULT13[row[1]] ^ MULT9[row[2]] ^ MULT14[row[3]];
        }
        return mergeCellsIntoBlock(outputCells);
    }

    /**
     * Encrypts the plaintext with the key and returns the result
     *
     * @param plainText which we want to encrypt
     * @param key the key for encrypt
     * @return EncryptedText
     */
    public static BigInteger encrypt(BigInteger plainText, BigInteger key) {
        BigInteger[] roundKeys = keyExpansion(key);

        // Initial round
        plainText = addRoundKey(plainText, roundKeys[0]);

        // Main rounds
        for (int i = 1; i < 10; i++) {
            plainText = subBytes(plainText);
            plainText = shiftRows(plainText);
            plainText = mixColumns(plainText);
            plainText = addRoundKey(plainText, roundKeys[i]);
        }

        // Final round
        plainText = subBytes(plainText);
        plainText = shiftRows(plainText);
        plainText = addRoundKey(plainText, roundKeys[10]);

        return plainText;
    }

    /**
     * Decrypts the ciphertext with the key and returns the result
     *
     * @param cipherText The Encrypted text which we want to decrypt
     * @return decryptedText
     */
    public static BigInteger decrypt(BigInteger cipherText, BigInteger key) {

        BigInteger[] roundKeys = keyExpansion(key);

        // Invert final round
        cipherText = addRoundKey(cipherText, roundKeys[10]);
        cipherText = shiftRowsDec(cipherText);
        cipherText = subBytesDec(cipherText);

        // Invert main rounds
        for (int i = 9; i > 0; i--) {
            cipherText = addRoundKey(cipherText, roundKeys[i]);
            cipherText = mixColumnsDec(cipherText);
            cipherText = shiftRowsDec(cipherText);
            cipherText = subBytesDec(cipherText);
        }

        // Invert initial round
        cipherText = addRoundKey(cipherText, roundKeys[0]);

        return cipherText;
    }

    public static void main(String[] args) {

        try (Scanner input = new Scanner(System.in)) {
            System.out.println("Enter (e) letter for encrpyt or (d) letter for decrypt :");
            char choice = input.nextLine().charAt(0);
            String in;
            switch (choice) {
                case 'E', 'e' -> {
                    System.out.println("Choose a plaintext block (128-Bit Integer in base 16):");
                    in = input.nextLine();
                    BigInteger plaintext = new BigInteger(in, 16);
                    System.out.println("Choose a Key (128-Bit Integer in base 16):");
                    in = input.nextLine();
                    BigInteger encryptionKey = new BigInteger(in, 16);
                    System.out.println(
                            "The encrypted message is: \n" + encrypt(plaintext, encryptionKey).toString(16));
                }
                case 'D', 'd' -> {
                    System.out.println("Enter your ciphertext block (128-Bit Integer in base 16):");
                    in = input.nextLine();
                    BigInteger ciphertext = new BigInteger(in, 16);
                    System.out.println("Choose a Key (128-Bit Integer in base 16):");
                    in = input.nextLine();
                    BigInteger decryptionKey = new BigInteger(in, 16);
                    System.out.println(
                            "The deciphered message is:\n" + decrypt(ciphertext, decryptionKey).toString(16));
                }
                default ->
                    System.out.println("** End **");
            }
        }
    }
}
package com.thealgorithms.ciphers;

import javax.swing.*;
import java.math.BigInteger;
import java.security.SecureRandom;

/**
 * @author Nguyen Duy Tiep on 23-Oct-17.
 */
public final class RSA {

    public static void main(String[] args) {

        RSA rsa = new RSA(1024);
        String text1 = JOptionPane.showInputDialog("Enter a message to encrypt :");

        String ciphertext = rsa.encrypt(text1);
        JOptionPane.showMessageDialog(null, "Your encrypted message : " + ciphertext);

        JOptionPane.showMessageDialog(null, "Your message after decrypt : " + rsa.decrypt(ciphertext));
    }

    private BigInteger modulus, privateKey, publicKey;

    public RSA(int bits) {
        generateKeys(bits);
    }

    /**
     * @return encrypted message
     */
    public synchronized String encrypt(String message) {
        return (new BigInteger(message.getBytes())).modPow(publicKey, modulus).toString();
    }

    /**
     * @return encrypted message as big integer
     */
    public synchronized BigInteger encrypt(BigInteger message) {
        return message.modPow(publicKey, modulus);
    }

    /**
     * @return plain message
     */
    public synchronized String decrypt(String encryptedMessage) {
        return new String((new BigInteger(encryptedMessage)).modPow(privateKey, modulus).toByteArray());
    }

    /**
     * @return plain message as big integer
     */
    public synchronized BigInteger decrypt(BigInteger encryptedMessage) {
        return encryptedMessage.modPow(privateKey, modulus);
    }

    /**
     * Generate a new public and private key set.
     */
    public synchronized void generateKeys(int bits) {
        SecureRandom r = new SecureRandom();
        BigInteger p = new BigInteger(bits / 2, 100, r);
        BigInteger q = new BigInteger(bits / 2, 100, r);
        modulus = p.multiply(q);

        BigInteger m = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));

        publicKey = new BigInteger("3");

        while (m.gcd(publicKey).intValue() > 1) {
            publicKey = publicKey.add(new BigInteger("2"));
        }

        privateKey = publicKey.modInverse(m);
    }
}
package com.thealgorithms.ciphers;

import javax.crypto.*;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

/**
 * This example program shows how AES encryption and decryption can be done in
 * Java. Please note that secret key and encrypted text is unreadable binary and
 * hence in the following program we display it in hexadecimal format of the
 * underlying bytes.
 */
public class AESEncryption {

    private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();

    /**
     * 1. Generate a plain text for encryption 2. Get a secret key (printed in
     * hexadecimal form). In actual use this must by encrypted and kept safe.
     * The same key is required for decryption.
     */
    public static void main(String[] args) throws Exception {
        String plainText = "Hello World";
        SecretKey secKey = getSecretEncryptionKey();
        byte[] cipherText = encryptText(plainText, secKey);
        String decryptedText = decryptText(cipherText, secKey);

        System.out.println("Original Text:" + plainText);
        System.out.println("AES Key (Hex Form):" + bytesToHex(secKey.getEncoded()));
        System.out.println("Encrypted Text (Hex Form):" + bytesToHex(cipherText));
        System.out.println("Descrypted Text:" + decryptedText);
    }

    /**
     * gets the AES encryption key. In your actual programs, this should be
     * safely stored.
     *
     * @return secKey (Secret key that we encrypt using it)
     * @throws NoSuchAlgorithmException (from KeyGenrator)
     */
    public static SecretKey getSecretEncryptionKey() throws NoSuchAlgorithmException {
        KeyGenerator aesKeyGenerator = KeyGenerator.getInstance("AES");
        aesKeyGenerator.init(128); // The AES key size in number of bits
        return aesKeyGenerator.generateKey();
    }

    /**
     * Encrypts plainText in AES using the secret key
     *
     * @return byteCipherText (The encrypted text)
     * @throws NoSuchPaddingException (from Cipher)
     * @throws NoSuchAlgorithmException (from Cipher)
     * @throws InvalidKeyException (from Cipher)
     * @throws BadPaddingException (from Cipher)
     * @throws IllegalBlockSizeException (from Cipher)
     */
    public static byte[] encryptText(String plainText, SecretKey secKey)
            throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
            IllegalBlockSizeException, BadPaddingException {
        // AES defaults to AES/ECB/PKCS5Padding in Java 7
        Cipher aesCipher = Cipher.getInstance("AES");
        aesCipher.init(Cipher.ENCRYPT_MODE, secKey);
        return aesCipher.doFinal(plainText.getBytes());
    }

    /**
     * Decrypts encrypted byte array using the key used for encryption.
     *
     * @return plainText
     */
    public static String decryptText(byte[] byteCipherText, SecretKey secKey)
            throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
            IllegalBlockSizeException, BadPaddingException {
        // AES defaults to AES/ECB/PKCS5Padding in Java 7
        Cipher aesCipher = Cipher.getInstance("AES");
        aesCipher.init(Cipher.DECRYPT_MODE, secKey);
        byte[] bytePlainText = aesCipher.doFinal(byteCipherText);
        return new String(bytePlainText);
    }

    /**
     * Convert a binary byte array into readable hex form Old library is
     * deprecated on OpenJdk 11 and this is faster regarding other solution is
     * using StringBuilder
     *
     * @return hexHash
     */
    public static String bytesToHex(byte[] bytes) {
        char[] hexChars = new char[bytes.length * 2];
        for (int j = 0; j < bytes.length; j++) {
            int v = bytes[j] & 0xFF;
            hexChars[j * 2] = HEX_ARRAY[v >>> 4];
            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
        }
        return new String(hexChars);
    }
}
package com.thealgorithms.divideandconquer;

public class BinaryExponentiation {

    public static void main(String args[]) {
        System.out.println(calculatePower(2, 30));
    }

    // Function to calculate x^y
    // Time Complexity: O(logn)
    public static long calculatePower(long x, long y) {
        if (y == 0) {
            return 1;
        }
        long val = calculatePower(x, y / 2);
        val *= val;
        if (y % 2 == 1) {
            val *= x;
        }
        return val;
    }
}
package com.thealgorithms.divideandconquer;

/**
 * For a set of points in a coordinates system (10000 maximum), ClosestPair
 * class calculates the two closest points.
 */
public final class ClosestPair {

    /**
     * Number of points
     */
    int numberPoints;
    /**
     * Input data, maximum 10000.
     */
    private Location[] array;
    /**
     * Minimum point coordinate.
     */
    Location point1 = null;
    /**
     * Minimum point coordinate.
     */
    Location point2 = null;
    /**
     * Minimum point length.
     */
    private static double minNum = Double.MAX_VALUE;

    public static void setMinNum(double minNum) {
        ClosestPair.minNum = minNum;
    }

    public static void setSecondCount(int secondCount) {
        ClosestPair.secondCount = secondCount;
    }

    /**
     * secondCount
     */
    private static int secondCount = 0;

    /**
     * Constructor.
     */
    ClosestPair(int points) {
        numberPoints = points;
        array = new Location[numberPoints];
    }

    /**
     * Location class is an auxiliary type to keep points coordinates.
     */
    public static class Location {

        double x;
        double y;

        /**
         * @param xpar (IN Parameter) x coordinate <br>
         * @param ypar (IN Parameter) y coordinate <br>
         */
        Location(final double xpar, final double ypar) { // Save x, y coordinates
            this.x = xpar;
            this.y = ypar;
        }
    }

    public Location[] createLocation(int numberValues) {
        return new Location[numberValues];
    }

    public Location buildLocation(double x, double y) {
        return new Location(x, y);
    }

    /**
     * xPartition function: arrange x-axis.
     *
     * @param a (IN Parameter) array of points <br>
     * @param first (IN Parameter) first point <br>
     * @param last (IN Parameter) last point <br>
     * @return pivot index
     */
    public int xPartition(final Location[] a, final int first, final int last) {

        Location pivot = a[last]; // pivot
        int i = first - 1;
        Location temp; // Temporarily store value for position transformation
        for (int j = first; j <= last - 1; j++) {
            if (a[j].x <= pivot.x) { // Less than or less than pivot
                i++;
                temp = a[i]; // array[i] <-> array[j]
                a[i] = a[j];
                a[j] = temp;
            }
        }
        i++;
        temp = a[i]; // array[pivot] <-> array[i]
        a[i] = a[last];
        a[last] = temp;
        return i; // pivot index
    }

    /**
     * yPartition function: arrange y-axis.
     *
     * @param a (IN Parameter) array of points <br>
     * @param first (IN Parameter) first point <br>
     * @param last (IN Parameter) last point <br>
     * @return pivot index
     */
    public int yPartition(final Location[] a, final int first, final int last) {

        Location pivot = a[last]; // pivot
        int i = first - 1;
        Location temp; // Temporarily store value for position transformation
        for (int j = first; j <= last - 1; j++) {
            if (a[j].y <= pivot.y) { // Less than or less than pivot
                i++;
                temp = a[i]; // array[i] <-> array[j]
                a[i] = a[j];
                a[j] = temp;
            }
        }
        i++;
        temp = a[i]; // array[pivot] <-> array[i]
        a[i] = a[last];
        a[last] = temp;
        return i; // pivot index
    }

    /**
     * xQuickSort function: //x-axis Quick Sorting.
     *
     * @param a (IN Parameter) array of points <br>
     * @param first (IN Parameter) first point <br>
     * @param last (IN Parameter) last point <br>
     */
    public void xQuickSort(final Location[] a, final int first, final int last) {

        if (first < last) {
            int q = xPartition(a, first, last); // pivot
            xQuickSort(a, first, q - 1); // Left
            xQuickSort(a, q + 1, last); // Right
        }
    }

    /**
     * yQuickSort function: //y-axis Quick Sorting.
     *
     * @param a (IN Parameter) array of points <br>
     * @param first (IN Parameter) first point <br>
     * @param last (IN Parameter) last point <br>
     */
    public void yQuickSort(final Location[] a, final int first, final int last) {

        if (first < last) {
            int q = yPartition(a, first, last); // pivot
            yQuickSort(a, first, q - 1); // Left
            yQuickSort(a, q + 1, last); // Right
        }
    }

    /**
     * closestPair function: find closest pair.
     *
     * @param a (IN Parameter) array stored before divide <br>
     * @param indexNum (IN Parameter) number coordinates divideArray <br>
     * @return minimum distance <br>
     */
    public double closestPair(final Location[] a, final int indexNum) {

        Location[] divideArray = new Location[indexNum];
        System.arraycopy(a, 0, divideArray, 0, indexNum); // Copy previous array
        int divideX = indexNum / 2; // Intermediate value for divide
        Location[] leftArray = new Location[divideX]; // divide - left array
        // divide-right array
        Location[] rightArray = new Location[indexNum - divideX];
        if (indexNum <= 3) { // If the number of coordinates is 3 or less
            return bruteForce(divideArray);
        }
        // divide-left array
        System.arraycopy(divideArray, 0, leftArray, 0, divideX);
        // divide-right array
        System.arraycopy(divideArray, divideX, rightArray, 0, indexNum - divideX);

        double minLeftArea; // Minimum length of left array
        double minRightArea; // Minimum length of right array
        double minValue; // Minimum lengt

        minLeftArea = closestPair(leftArray, divideX); // recursive closestPair
        minRightArea = closestPair(rightArray, indexNum - divideX);
        // window size (= minimum length)
        minValue = Math.min(minLeftArea, minRightArea);

        // Create window.  Set the size for creating a window
        // and creating a new array for the coordinates in the window
        for (int i = 0; i < indexNum; i++) {
            double xGap = Math.abs(divideArray[divideX].x - divideArray[i].x);
            if (xGap < minValue) {
                ClosestPair.setSecondCount(secondCount + 1); // size of the array
            } else {
                if (divideArray[i].x > divideArray[divideX].x) {
                    break;
                }
            }
        }
        // new array for coordinates in window
        Location[] firstWindow = new Location[secondCount];
        int k = 0;
        for (int i = 0; i < indexNum; i++) {
            double xGap = Math.abs(divideArray[divideX].x - divideArray[i].x);
            if (xGap < minValue) { // if it's inside a window
                firstWindow[k] = divideArray[i]; // put in an array
                k++;
            } else {
                if (divideArray[i].x > divideArray[divideX].x) {
                    break;
                }
            }
        }
        yQuickSort(firstWindow, 0, secondCount - 1); // Sort by y coordinates
        /* Coordinates in Window */
        double length;
        // size comparison within window
        for (int i = 0; i < secondCount - 1; i++) {
            for (int j = (i + 1); j < secondCount; j++) {
                double xGap = Math.abs(firstWindow[i].x - firstWindow[j].x);
                double yGap = Math.abs(firstWindow[i].y - firstWindow[j].y);
                if (yGap < minValue) {
                    length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));
                    // If measured distance is less than current min distance
                    if (length < minValue) {
                        // Change minimum distance to current distance
                        minValue = length;
                        // Conditional for registering final coordinate
                        if (length < minNum) {
                            ClosestPair.setMinNum(length);
                            point1 = firstWindow[i];
                            point2 = firstWindow[j];
                        }
                    }
                } else {
                    break;
                }
            }
        }
        ClosestPair.setSecondCount(0);
        return minValue;
    }

    /**
     * bruteForce function: When the number of coordinates is less than 3.
     *
     * @param arrayParam (IN Parameter) array stored before divide <br>
     * @return <br>
     */
    public double bruteForce(final Location[] arrayParam) {

        double minValue = Double.MAX_VALUE; // minimum distance
        double length;
        double xGap; // Difference between x coordinates
        double yGap; // Difference between y coordinates
        double result = 0;

        if (arrayParam.length == 2) {
            // Difference between x coordinates
            xGap = (arrayParam[0].x - arrayParam[1].x);
            // Difference between y coordinates
            yGap = (arrayParam[0].y - arrayParam[1].y);
            // distance between coordinates
            length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));
            // Conditional statement for registering final coordinate
            if (length < minNum) {
                ClosestPair.setMinNum(length);
            }
            point1 = arrayParam[0];
            point2 = arrayParam[1];
            result = length;
        }
        if (arrayParam.length == 3) {
            for (int i = 0; i < arrayParam.length - 1; i++) {
                for (int j = (i + 1); j < arrayParam.length; j++) {
                    // Difference between x coordinates
                    xGap = (arrayParam[i].x - arrayParam[j].x);
                    // Difference between y coordinates
                    yGap = (arrayParam[i].y - arrayParam[j].y);
                    // distance between coordinates
                    length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));
                    // If measured distance is less than current min distance
                    if (length < minValue) {
                        // Change minimum distance to current distance
                        minValue = length;
                        if (length < minNum) {
                            // Registering final coordinate
                            ClosestPair.setMinNum(length);
                            point1 = arrayParam[i];
                            point2 = arrayParam[j];
                        }
                    }
                }
            }
            result = minValue;
        }
        return result; // If only one point returns 0.
    }

    /**
     * main function: execute class.
     *
     * @param args (IN Parameter) <br>
     */
    public static void main(final String[] args) {

        // Input data consists of one x-coordinate and one y-coordinate
        ClosestPair cp = new ClosestPair(12);
        cp.array[0] = cp.buildLocation(2, 3);
        cp.array[1] = cp.buildLocation(2, 16);
        cp.array[2] = cp.buildLocation(3, 9);
        cp.array[3] = cp.buildLocation(6, 3);
        cp.array[4] = cp.buildLocation(7, 7);
        cp.array[5] = cp.buildLocation(19, 4);
        cp.array[6] = cp.buildLocation(10, 11);
        cp.array[7] = cp.buildLocation(15, 2);
        cp.array[8] = cp.buildLocation(15, 19);
        cp.array[9] = cp.buildLocation(16, 11);
        cp.array[10] = cp.buildLocation(17, 13);
        cp.array[11] = cp.buildLocation(9, 12);

        System.out.println("Input data");
        System.out.println("Number of points: " + cp.array.length);
        for (int i = 0; i < cp.array.length; i++) {
            System.out.println("x: " + cp.array[i].x + ", y: " + cp.array[i].y);
        }

        cp.xQuickSort(cp.array, 0, cp.array.length - 1); // Sorting by x value

        double result; // minimum distance

        result = cp.closestPair(cp.array, cp.array.length);
        // ClosestPair start
        // minimum distance coordinates and distance output
        System.out.println("Output Data");
        System.out.println("(" + cp.point1.x + ", " + cp.point1.y + ")");
        System.out.println("(" + cp.point2.x + ", " + cp.point2.y + ")");
        System.out.println("Minimum Distance : " + result);
    }
}
package com.thealgorithms.divideandconquer;

import java.util.ArrayList;
import java.util.Comparator;

/**
 * @author dimgrichr
 * <p>
 * Space complexity: O(n) Time complexity: O(nlogn), because it is a divide and
 * conquer algorithm
 */
public class SkylineAlgorithm {

    private ArrayList<Point> points;

    /**
     * Main constructor of the application. ArrayList points gets created, which
     * represents the sum of all edges.
     */
    public SkylineAlgorithm() {
        points = new ArrayList<>();
    }

    /**
     * @return points, the ArrayList that includes all points.
     */
    public ArrayList<Point> getPoints() {
        return points;
    }

    /**
     * The main divide and conquer, and also recursive algorithm. It gets an
     * ArrayList full of points as an argument. If the size of that ArrayList is
     * 1 or 2, the ArrayList is returned as it is, or with one less point (if
     * the initial size is 2 and one of it's points, is dominated by the other
     * one). On the other hand, if the ArrayList's size is bigger than 2, the
     * function is called again, twice, with arguments the corresponding half of
     * the initial ArrayList each time. Once the flashback has ended, the
     * function produceFinalSkyLine gets called, in order to produce the final
     * skyline, and return it.
     *
     * @param list, the initial list of points
     * @return leftSkyLine, the combination of first half's and second half's
     * skyline
     * @see Point
     */
    public ArrayList<Point> produceSubSkyLines(ArrayList<Point> list) {

        // part where function exits flashback
        int size = list.size();
        if (size == 1) {
            return list;
        } else if (size == 2) {
            if (list.get(0).dominates(list.get(1))) {
                list.remove(1);
            } else {
                if (list.get(1).dominates(list.get(0))) {
                    list.remove(0);
                }
            }
            return list;
        }

        // recursive part of the function
        ArrayList<Point> leftHalf = new ArrayList<>();
        ArrayList<Point> rightHalf = new ArrayList<>();
        for (int i = 0; i < list.size(); i++) {
            if (i < list.size() / 2) {
                leftHalf.add(list.get(i));
            } else {
                rightHalf.add(list.get(i));
            }
        }
        ArrayList<Point> leftSubSkyLine = produceSubSkyLines(leftHalf);
        ArrayList<Point> rightSubSkyLine = produceSubSkyLines(rightHalf);

        // skyline is produced
        return produceFinalSkyLine(leftSubSkyLine, rightSubSkyLine);
    }

    /**
     * The first half's skyline gets cleared from some points that are not part
     * of the final skyline (Points with same x-value and different y=values.
     * The point with the smallest y-value is kept). Then, the minimum y-value
     * of the points of first half's skyline is found. That helps us to clear
     * the second half's skyline, because, the points of second half's skyline
     * that have greater y-value of the minimum y-value that we found before,
     * are dominated, so they are not part of the final skyline. Finally, the
     * "cleaned" first half's and second half's skylines, are combined,
     * producing the final skyline, which is returned.
     *
     * @param left the skyline of the left part of points
     * @param right the skyline of the right part of points
     * @return left the final skyline
     */
    public ArrayList<Point> produceFinalSkyLine(ArrayList<Point> left, ArrayList<Point> right) {

        // dominated points of ArrayList left are removed
        for (int i = 0; i < left.size() - 1; i++) {
            if (left.get(i).x == left.get(i + 1).x && left.get(i).y > left.get(i + 1).y) {
                left.remove(i);
                i--;
            }
        }

        // minimum y-value is found
        int min = left.get(0).y;
        for (int i = 1; i < left.size(); i++) {
            if (min > left.get(i).y) {
                min = left.get(i).y;
                if (min == 1) {
                    i = left.size();
                }
            }
        }

        // dominated points of ArrayList right are removed
        for (int i = 0; i < right.size(); i++) {
            if (right.get(i).y >= min) {
                right.remove(i);
                i--;
            }
        }

        // final skyline found and returned
        left.addAll(right);
        return left;
    }

    public static class Point {

        private int x;
        private int y;

        /**
         * The main constructor of Point Class, used to represent the 2
         * Dimension points.
         *
         * @param x the point's x-value.
         * @param y the point's y-value.
         */
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        /**
         * @return x, the x-value
         */
        public int getX() {
            return x;
        }

        /**
         * @return y, the y-value
         */
        public int getY() {
            return y;
        }

        /**
         * Based on the skyline theory, it checks if the point that calls the
         * function dominates the argument point.
         *
         * @param p1 the point that is compared
         * @return true if the point wich calls the function dominates p1 false
         * otherwise.
         */
        public boolean dominates(Point p1) {
            // checks if p1 is dominated
            return (this.x < p1.x && this.y <= p1.y) || (this.x <= p1.x && this.y < p1.y);
        }
    }

    /**
     * It is used to compare the 2 Dimension points, based on their x-values, in
     * order get sorted later.
     */
    class XComparator implements Comparator<Point> {

        @Override
        public int compare(Point a, Point b) {
            return Integer.compare(a.x, b.x);
        }
    }
}
package com.thealgorithms.divideandconquer;

// Java Program to Implement Strassen Algorithm
// Class Strassen matrix multiplication
public class StrassenMatrixMultiplication {

    // Method 1
    // Function to multiply matrices
    public int[][] multiply(int[][] A, int[][] B) {
        int n = A.length;

        int[][] R = new int[n][n];

        if (n == 1) {
            R[0][0] = A[0][0] * B[0][0];
        } else {
            // Dividing Matrix into parts
            // by storing sub-parts to variables
            int[][] A11 = new int[n / 2][n / 2];
            int[][] A12 = new int[n / 2][n / 2];
            int[][] A21 = new int[n / 2][n / 2];
            int[][] A22 = new int[n / 2][n / 2];
            int[][] B11 = new int[n / 2][n / 2];
            int[][] B12 = new int[n / 2][n / 2];
            int[][] B21 = new int[n / 2][n / 2];
            int[][] B22 = new int[n / 2][n / 2];

            // Dividing matrix A into 4 parts
            split(A, A11, 0, 0);
            split(A, A12, 0, n / 2);
            split(A, A21, n / 2, 0);
            split(A, A22, n / 2, n / 2);

            // Dividing matrix B into 4 parts
            split(B, B11, 0, 0);
            split(B, B12, 0, n / 2);
            split(B, B21, n / 2, 0);
            split(B, B22, n / 2, n / 2);

            // Using Formulas as described in algorithm
            // M1:=(A1+A3)×(B1+B2)
            int[][] M1
                    = multiply(add(A11, A22), add(B11, B22));

            // M2:=(A2+A4)×(B3+B4)
            int[][] M2 = multiply(add(A21, A22), B11);

            // M3:=(A1−A4)×(B1+A4)
            int[][] M3 = multiply(A11, sub(B12, B22));

            // M4:=A1×(B2−B4)
            int[][] M4 = multiply(A22, sub(B21, B11));

            // M5:=(A3+A4)×(B1)
            int[][] M5 = multiply(add(A11, A12), B22);

            // M6:=(A1+A2)×(B4)
            int[][] M6
                    = multiply(sub(A21, A11), add(B11, B12));

            // M7:=A4×(B3−B1)
            int[][] M7
                    = multiply(sub(A12, A22), add(B21, B22));

            // P:=M2+M3−M6−M7
            int[][] C11 = add(sub(add(M1, M4), M5), M7);

            // Q:=M4+M6
            int[][] C12 = add(M3, M5);

            // R:=M5+M7
            int[][] C21 = add(M2, M4);

            // S:=M1−M3−M4−M5
            int[][] C22 = add(sub(add(M1, M3), M2), M6);

            join(C11, R, 0, 0);
            join(C12, R, 0, n / 2);
            join(C21, R, n / 2, 0);
            join(C22, R, n / 2, n / 2);
        }

        return R;
    }

    // Method 2
    // Function to subtract two matrices
    public int[][] sub(int[][] A, int[][] B) {
        int n = A.length;

        int[][] C = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                C[i][j] = A[i][j] - B[i][j];
            }
        }

        return C;
    }

    // Method 3
    // Function to add two matrices
    public int[][] add(int[][] A, int[][] B) {

        int n = A.length;

        int[][] C = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                C[i][j] = A[i][j] + B[i][j];
            }
        }

        return C;
    }

    // Method 4
    // Function to split parent matrix
    // into child matrices
    public void split(int[][] P, int[][] C, int iB, int jB) {
        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {
            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {
                C[i1][j1] = P[i2][j2];
            }
        }
    }

    // Method 5
    // Function to join child matrices
    // into (to) parent matrix
    public void join(int[][] C, int[][] P, int iB, int jB) {
        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {
            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {
                P[i2][j2] = C[i1][j1];
            }
        }
    }

    // Method 5
    // Main driver method
    public static void main(String[] args) {
        System.out.println("Strassen Multiplication Algorithm Implementation For Matrix Multiplication :\n");

        StrassenMatrixMultiplication s = new StrassenMatrixMultiplication();

        // Size of matrix
        // Considering size as 4 in order to illustrate
        int N = 4;

        // Matrix A
        // Custom input to matrix
        int[][] A = {{1, 2, 5, 4},
        {9, 3, 0, 6},
        {4, 6, 3, 1},
        {0, 2, 0, 6}};

        // Matrix B
        // Custom input to matrix
        int[][] B = {{1, 0, 4, 1},
        {1, 2, 0, 2},
        {0, 3, 1, 3},
        {1, 8, 1, 2}};

        // Matrix C computations
        // Matrix C calling method to get Result
        int[][] C = s.multiply(A, B);

        System.out.println("\nProduct of matrices A and  B : ");

        // Print the output
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.print(C[i][j] + " ");
            }
            System.out.println();
        }
    }
}
package com.thealgorithms.maths;

/**
 * In number theory, a perfect number is a positive integer that is equal to the
 * sum of its positive divisors, excluding the number itself. For instance, 6
 * has divisors 1, 2 and 3 (excluding itself), and 1 + 2 + 3 = 6, so 6 is a
 * perfect number.
 *
 * <p>
 * link:https://en.wikipedia.org/wiki/Perfect_number
 */
public class PerfectNumber {

    public static void main(String[] args) {
        assert isPerfectNumber(6);
        /* 1 + 2 + 3 == 6 */
        assert !isPerfectNumber(8);
        /* 1 + 2 + 4 != 8 */
        assert isPerfectNumber(28);
        /* 1 + 2 + 4 + 7 + 14 == 28 */
    }

    /**
     * Check if {@code number} is perfect number or not
     *
     * @param number the number
     * @return {@code true} if {@code number} is perfect number, otherwise false
     */
    public static boolean isPerfectNumber(int number) {
        int sum = 0;
        /* sum of its positive divisors */
        for (int i = 1; i < number; ++i) {
            if (number % i == 0) {
                sum += i;
            }
        }
        return sum == number;
    }
}
package com.thealgorithms.maths;

public class PiNilakantha {

    // Calculates Pi using Nilakantha's infinite series
    // Method 2 in the following link explains the algorithm
    // https://en.scratch-wiki.info/wiki/Calculating_Pi
    public static void main(String[] args) {
        assert calculatePi(0) == 3.0;
        assert calculatePi(10) > 3.0;
        assert calculatePi(100) < 4.0;

        System.out.println(calculatePi(500));
    }

    /**
     * @param iterations number of times the infinite series gets repeated Pi
     * get more accurate the higher the value of iterations is Values from 0 up
     * to 500 are allowed since double precision is not sufficient for more than
     * about 500 repetitions of this algorithm
     * @return the pi value of the calculation with a precision of x iteration
     */
    public static double calculatePi(int iterations) {
        if (iterations < 0 || iterations > 500) {
            throw new IllegalArgumentException("Please input Integer Number between 0 and 500");
        }

        double pi = 3;
        int divCounter = 2;

        for (int i = 0; i < iterations; i++) {

            if (i % 2 == 0) {
                pi = pi + 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2));
            } else {
                pi = pi - 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2));
            }

            divCounter += 2;
        }
        return pi;
    }
}
package com.thealgorithms.maths;

public class LeonardoNumber {

    public static int leonardoNumber(int n) {
        if (n < 0) {
            return 0;
        }
        if (n == 0 || n == 1) {
            return 1;
        }
        return (leonardoNumber(n - 1) + leonardoNumber(n - 2) + 1);
    }

    public static void main(String args[]) {
        for (int i = 0; i < 20; i++) {
            System.out.print(leonardoNumber(i) + " ");
        }

    }
}
package com.thealgorithms.maths;

public class StandardScore {
	public static double zScore(double num, double mean, double stdDev)
	{
		double z = (num - mean)/stdDev;
		return z;
	}
}
package com.thealgorithms.maths;

/* This is a program to check if a number is a Krishnamurthy number or not.
A number is a Krishnamurthy number if the sum of the factorials of the digits of the number is equal to the number itself.
For example, 1, 2 and 145 are Krishnamurthy numbers.
Krishnamurthy number is also referred to as a Strong number.
 */
import java.io.*;

public class KrishnamurthyNumber {
    //returns True if the number is a Krishnamurthy number and False if it is not.

    public static boolean isKMurthy(int n) {
        //initialising the variable s that will store the sum of the factorials of the digits to 0
        int s = 0;
        //storing the number n in a temporary variable tmp
        int tmp = n;

        //Krishnamurthy numbers are positive
        if (n <= 0) {
            return false;
        } //checking if the number is a Krishnamurthy number
        else {
            while (n != 0) {
                //initialising the variable fact that will store the factorials of the digits
                int fact = 1;
                //computing factorial of each digit
                for (int i = 1; i <= n % 10; i++) {
                    fact = fact * i;
                }
                //computing the sum of the factorials
                s = s + fact;
                //discarding the digit for which factorial has been calculated
                n = n / 10;
            }

            //evaluating if sum of the factorials of the digits equals the number itself
            if (tmp == s) {
                return true;
            } else {
                return false;
            }
        }
    }

    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter a number to check if it is a Krishnamurthy number: ");
        int n = Integer.parseInt(br.readLine());
        if (isKMurthy(n)) {
            System.out.println(n + " is a Krishnamurthy number.");
        } else {
            System.out.println(n + " is NOT a Krishnamurthy number.");
        }
    }
}
package com.thealgorithms.maths;

public class ParseInteger {

    public static void main(String[] args) {
        assert parseInt("123") == Integer.parseInt("123");
        assert parseInt("-123") == Integer.parseInt("-123");
        assert parseInt("0123") == Integer.parseInt("0123");
        assert parseInt("+123") == Integer.parseInt("+123");
    }

    /**
     * Parse a string to integer
     *
     * @param s the string
     * @return the integer value represented by the argument in decimal.
     * @throws NumberFormatException if the {@code string} does not contain a
     * parsable integer.
     */
    public static int parseInt(String s) {
        if (s == null || s.length() == 0) {
            throw new NumberFormatException("null");
        }
        boolean isNegative = s.charAt(0) == '-';
        boolean isPositive = s.charAt(0) == '+';
        int number = 0;
        for (int i = isNegative ? 1 : isPositive ? 1 : 0, length = s.length(); i < length; ++i) {
            if (!Character.isDigit(s.charAt(i))) {
                throw new NumberFormatException("s=" + s);
            }
            number = number * 10 + s.charAt(i) - '0';
        }
        return isNegative ? -number : number;
    }
}
package com.thealgorithms.maths;

/**
 * A utility to check if a given number is power of two or not. For example 8,16
 * etc.
 */
public class PowerOfTwoOrNot {

    public static void main(String[] args) {
        assert !checkIfPowerOfTwoOrNot(0);
        assert checkIfPowerOfTwoOrNot(1);
        assert checkIfPowerOfTwoOrNot(8);
        assert checkIfPowerOfTwoOrNot(16);
        assert checkIfPowerOfTwoOrNot(1024);
    }

    /**
     * Checks whether given number is power of two or not.
     *
     * @param number the number to check
     * @return {@code true} if given number is power of two, otherwise
     * {@code false}
     */
    public static boolean checkIfPowerOfTwoOrNot(int number) {
        return number != 0 && ((number & (number - 1)) == 0);
    }
}
package com.thealgorithms.maths;

/*
 * Java program for Pronic Number
 * Pronic Number: A number n is a pronic number if
 * it is equal to product of two consecutive numbers m and m+1.
 * Wikipedia: https://en.wikipedia.org/wiki/Pronic_number
 * 
 * Author: Akshay Dubey (https://github.com/itsAkshayDubey)
 * 
 * */

public class PronicNumber {

	/**
     * This method checks if the given number is pronic number or non-pronic number
     *
     * @param input_number Integer value which is to be checked if is a pronic number or not 
     * @return true if input number is a pronic number, false otherwise
     */
	static boolean isPronic(int input_number) {
		
		//Iterating from 0 to input_number
		for(int i = 0; i <= input_number; i++) {
			
			//Checking if product of i and (i+1) is equals input_number
			if(i * (i+1) == input_number && i != input_number) {
				
				//return true if product of i and (i+1) is equals input_number
				return true;
			}
			
		}
		
		//return false if product of i and (i+1) for all values from 0 to input_number is not equals input_number
		return false;
	}
}
package com.thealgorithms.maths;

/**
 * Find the number of digits in a number.
 */
public class NumberOfDigits {

    public static void main(String[] args) {
        int[] numbers = {0, 12, 123, 1234, -12345, 123456, 1234567, 12345678, 123456789};
        for (int i = 0; i < numbers.length; ++i) {
            assert numberOfDigits(numbers[i]) == i + 1;
            assert numberOfDigitsFast(numbers[i]) == i + 1;
            assert numberOfDigitsFaster(numbers[i]) == i + 1;
            assert numberOfDigitsRecursion(numbers[i]) == i + 1;
        }
    }

    /**
     * Find the number of digits in a number.
     *
     * @param number number to find
     * @return number of digits of given number
     */
    private static int numberOfDigits(int number) {
        int digits = 0;
        do {
            digits++;
            number /= 10;
        } while (number != 0);
        return digits;
    }

    /**
     * Find the number of digits in a number fast version.
     *
     * @param number number to find
     * @return number of digits of given number
     */
    private static int numberOfDigitsFast(int number) {
        return number == 0 ? 1 : (int) Math.floor(Math.log10(Math.abs(number)) + 1);
    }

    /**
     * Find the number of digits in a number faster version.
     *
     * @param number number to find
     * @return number of digits of given number
     */
    private static int numberOfDigitsFaster(int number) {
        return number < 0 ? (-number + "").length() : (number + "").length();
    }

    /**
     * Find the number of digits in a number using recursion.
     *
     * @param number number to find
     * @return number of digits of given number
     */
    private static int numberOfDigitsRecursion(int number) {
        return number / 10 == 0 ? 1 : 1 + numberOfDigitsRecursion(number / 10);
    }
}
package com.thealgorithms.maths;

public class PowRecursion {

    public static void main(String[] args) {
        assert Double.compare(pow(2, 0), Math.pow(2, 0)) == 0;
        assert Double.compare(pow(0, 2), Math.pow(0, 2)) == 0;
        assert Double.compare(pow(2, 10), Math.pow(2, 10)) == 0;
        assert Double.compare(pow(10, 2), Math.pow(10, 2)) == 0;
    }

    /**
     * Returns the value of the first argument raised to the power of the second
     * argument
     *
     * @param a the base.
     * @param b the exponent.
     * @return the value {@code a}<sup>{@code b}</sup>.
     */
    public static long pow(int a, int b) {
        return b == 0 ? 1 : a * pow(a, b - 1);
    }
}
package com.thealgorithms.maths;

public class SumOfDigits {

    public static void main(String[] args) {
        assert sumOfDigits(-123) == 6 && sumOfDigitsRecursion(-123) == 6 && sumOfDigitsFast(-123) == 6;

        assert sumOfDigits(0) == 0 && sumOfDigitsRecursion(0) == 0 && sumOfDigitsFast(0) == 0;

        assert sumOfDigits(12345) == 15
                && sumOfDigitsRecursion(12345) == 15
                && sumOfDigitsFast(12345) == 15;
    }

    /**
     * Calculate the sum of digits of a number
     *
     * @param number the number contains digits
     * @return sum of digits of given {@code number}
     */
    public static int sumOfDigits(int number) {
        number = number < 0 ? -number : number;
        /* calculate abs value */
        int sum = 0;
        while (number != 0) {
            sum += number % 10;
            number /= 10;
        }
        return sum;
    }

    /**
     * Calculate the sum of digits of a number using recursion
     *
     * @param number the number contains digits
     * @return sum of digits of given {@code number}
     */
    public static int sumOfDigitsRecursion(int number) {
        number = number < 0 ? -number : number;
        /* calculate abs value */
        return number < 10 ? number : number % 10 + sumOfDigitsRecursion(number / 10);
    }

    /**
     * Calculate the sum of digits of a number using char array
     *
     * @param number the number contains digits
     * @return sum of digits of given {@code number}
     */
    public static int sumOfDigitsFast(int number) {
        number = number < 0 ? -number : number;
        /* calculate abs value */
        char[] digits = (number + "").toCharArray();
        int sum = 0;
        for (int i = 0; i < digits.length; ++i) {
            sum += digits[i] - '0';
        }
        return sum;
    }
}
package com.thealgorithms.maths;

/**
 * https://en.wikipedia.org/wiki/Lucas_number
 */
public class LucasSeries {

    public static void main(String[] args) {
        assert lucasSeries(1) == 2 && lucasSeriesIteration(1) == 2;
        assert lucasSeries(2) == 1 && lucasSeriesIteration(2) == 1;
        assert lucasSeries(3) == 3 && lucasSeriesIteration(3) == 3;
        assert lucasSeries(4) == 4 && lucasSeriesIteration(4) == 4;
        assert lucasSeries(5) == 7 && lucasSeriesIteration(5) == 7;
        assert lucasSeries(6) == 11 && lucasSeriesIteration(6) == 11;
        assert lucasSeries(11) == 123 && lucasSeriesIteration(11) == 123;
    }

    /**
     * Calculate nth number of lucas series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,
     * 123, ....) using recursion
     *
     * @param n nth
     * @return nth number of lucas series
     */
    public static int lucasSeries(int n) {
        return n == 1 ? 2 : n == 2 ? 1 : lucasSeries(n - 1) + lucasSeries(n - 2);
    }

    /**
     * Calculate nth number of lucas series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76,
     * 123, ....) using iteration
     *
     * @param n nth
     * @return nth number of lucas series
     */
    public static int lucasSeriesIteration(int n) {
        int previous = 2;
        int current = 1;
        for (int i = 1; i < n; i++) {
            int next = previous + current;
            previous = current;
            current = next;
        }
        return previous;
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;

/**
 * Class for linear convolution of two discrete signals using the convolution
 * theorem.
 *
 * @author Ioannis Karavitsis
 * @version 1.0
 */
public class ConvolutionFFT {

    /**
     * This method pads the signal with zeros until it reaches the new size.
     *
     * @param x The signal to be padded.
     * @param newSize The new size of the signal.
     */
    private static void padding(ArrayList<FFT.Complex> x, int newSize) {
        if (x.size() < newSize) {
            int diff = newSize - x.size();
            for (int i = 0; i < diff; i++) {
                x.add(new FFT.Complex());
            }
        }
    }

    /**
     * Discrete linear convolution function. It uses the convolution theorem for
     * discrete signals convolved: = IDFT(DFT(a)*DFT(b)). This is true for
     * circular convolution. In order to get the linear convolution of the two
     * signals we first pad the two signals to have the same size equal to the
     * convolved signal (a.size() + b.size() - 1). Then we use the FFT algorithm
     * for faster calculations of the two DFTs and the final IDFT.
     *
     * <p>
     * More info: https://en.wikipedia.org/wiki/Convolution_theorem
     * https://ccrma.stanford.edu/~jos/ReviewFourier/FFT_Convolution.html
     *
     * @param a The first signal.
     * @param b The other signal.
     * @return The convolved signal.
     */
    public static ArrayList<FFT.Complex> convolutionFFT(
            ArrayList<FFT.Complex> a, ArrayList<FFT.Complex> b) {
        int convolvedSize = a.size() + b.size() - 1; // The size of the convolved signal
        padding(a, convolvedSize); // Zero padding both signals
        padding(b, convolvedSize);

        /* Find the FFTs of both signals (Note that the size of the FFTs will be bigger than the convolvedSize because of the extra zero padding in FFT algorithm) */
        FFT.fft(a, false);
        FFT.fft(b, false);
        ArrayList<FFT.Complex> convolved = new ArrayList<>();

        for (int i = 0; i < a.size(); i++) {
            convolved.add(a.get(i).multiply(b.get(i))); // FFT(a)*FFT(b)
        }
        FFT.fft(convolved, true); // IFFT
        convolved
                .subList(convolvedSize, convolved.size())
                .clear(); // Remove the remaining zeros after the convolvedSize. These extra zeros came from
        // paddingPowerOfTwo() method inside the fft() method.

        return convolved;
    }
}
package com.thealgorithms.maths;

/**
 * Calculate average of a list of numbers
 */
public class Average {

    private static final double SMALL_VALUE = 0.00001f;

    public static void main(String[] args) {
        assert Math.abs(average(new double[]{3, 6, 9, 12, 15, 18, 21}) - 12) < SMALL_VALUE;
        assert Math.abs(average(new double[]{5, 10, 15, 20, 25, 30, 35}) - 20) < SMALL_VALUE;
        assert Math.abs(average(new double[]{1, 2, 3, 4, 5, 6, 7, 8}) - 4.5) < SMALL_VALUE;
        int[] array = {2, 4, 10};
        assert average(array) == 5;
    }

    /**
     * Calculate average of a list of numbers
     *
     * @param numbers array to store numbers
     * @return mean of given numbers
     */
    public static double average(double[] numbers) {
        double sum = 0;
        for (double number : numbers) {
            sum += number;
        }
        return sum / numbers.length;
    }

    /**
     * find average value of int array
     *
     * @param array the array contains element and the sum does not excess long
     * value limit
     * @return average value
     */
    public static int average(int[] array) {
        long sum = 0;
        for (int i = 0; i < array.length; ++i) {
            sum += array[i];
        }
        return (int) (sum / array.length);
    }
}
// Wikipedia for Harshad Number : https://en.wikipedia.org/wiki/Harshad_number
package com.thealgorithms.maths;

import java.util.Scanner;

public class HarshadNumber {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a number : ");
        long a = sc.nextLong();

        checkHarshadNumber(a);
    }

    /**
     * A function to check if a number is Harshad number or not
     *
     * @param a The number which should be checked
     */
    public static void checkHarshadNumber(long a) {

        long b = a;
        int sum = 0;

        // this is just for showing the explanation else it's of no use you can ommit it
        int[] each = new int[Long.toString(a).length()];

        int c = 0;

        while (b > 0) {
            sum += b % 10;
            each[c] = (int) (b % 10);
            b /= 10;
            c++;
        }

        if (a % sum == 0) {
            System.out.println(a + " is a Harshad Number");

            // For you better explanation how is that a Harshad Number
            System.out.println("\nExplaination :");

            for (int i = each.length - 1; i >= 0; i--) {
                System.out.print(each[i] + " ");
                if (i != 0) {
                    System.out.print("+ ");
                }
            }

            System.out.println("= " + sum);
            System.out.println(sum + " × " + (a / sum) + " = " + a);
        } else {
            System.out.println(a + " is not a Harshad Number");
        }
    }
}
package com.thealgorithms.maths;

public class PalindromeNumber {

    public static void main(String[] args) {

        assert isPalindrome(12321);
        assert !isPalindrome(1234);
        assert isPalindrome(1);
    }

    /**
     * Check if {@code n} is palindrome number or not
     *
     * @param number the number
     * @return {@code true} if {@code n} is palindrome number, otherwise
     * {@code false}
     */
    public static boolean isPalindrome(int number) {
        if (number < 0) {
            throw new IllegalArgumentException(number + "");
        }
        int numberCopy = number;
        int reverseNumber = 0;
        while (numberCopy != 0) {
            int remainder = numberCopy % 10;
            reverseNumber = reverseNumber * 10 + remainder;
            numberCopy /= 10;
        }
        return number == reverseNumber;
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;
import java.util.Collections;

/**
 * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal
 * using the Cooley-Tukey algorithm.
 *
 * @author Ioannis Karavitsis
 * @version 1.0
 */
public class FFT {

    /**
     * This class represents a complex number and has methods for basic
     * operations.
     *
     * <p>
     * More info:
     * https://introcs.cs.princeton.edu/java/32class/Complex.java.html
     */
    static class Complex {

        private double real, img;

        /**
         * Default Constructor. Creates the complex number 0.
         */
        public Complex() {
            real = 0;
            img = 0;
        }

        /**
         * Constructor. Creates a complex number.
         *
         * @param r The real part of the number.
         * @param i The imaginary part of the number.
         */
        public Complex(double r, double i) {
            real = r;
            img = i;
        }

        /**
         * Returns the real part of the complex number.
         *
         * @return The real part of the complex number.
         */
        public double getReal() {
            return real;
        }

        /**
         * Returns the imaginary part of the complex number.
         *
         * @return The imaginary part of the complex number.
         */
        public double getImaginary() {
            return img;
        }

        /**
         * Adds this complex number to another.
         *
         * @param z The number to be added.
         * @return The sum.
         */
        public Complex add(Complex z) {
            Complex temp = new Complex();
            temp.real = this.real + z.real;
            temp.img = this.img + z.img;
            return temp;
        }

        /**
         * Subtracts a number from this complex number.
         *
         * @param z The number to be subtracted.
         * @return The difference.
         */
        public Complex subtract(Complex z) {
            Complex temp = new Complex();
            temp.real = this.real - z.real;
            temp.img = this.img - z.img;
            return temp;
        }

        /**
         * Multiplies this complex number by another.
         *
         * @param z The number to be multiplied.
         * @return The product.
         */
        public Complex multiply(Complex z) {
            Complex temp = new Complex();
            temp.real = this.real * z.real - this.img * z.img;
            temp.img = this.real * z.img + this.img * z.real;
            return temp;
        }

        /**
         * Multiplies this complex number by a scalar.
         *
         * @param n The real number to be multiplied.
         * @return The product.
         */
        public Complex multiply(double n) {
            Complex temp = new Complex();
            temp.real = this.real * n;
            temp.img = this.img * n;
            return temp;
        }

        /**
         * Finds the conjugate of this complex number.
         *
         * @return The conjugate.
         */
        public Complex conjugate() {
            Complex temp = new Complex();
            temp.real = this.real;
            temp.img = -this.img;
            return temp;
        }

        /**
         * Finds the magnitude of the complex number.
         *
         * @return The magnitude.
         */
        public double abs() {
            return Math.hypot(this.real, this.img);
        }

        /**
         * Divides this complex number by another.
         *
         * @param z The divisor.
         * @return The quotient.
         */
        public Complex divide(Complex z) {
            Complex temp = new Complex();
            double d = z.abs() * z.abs();
            d = (double)Math.round(d * 1000000000d) / 1000000000d;
            temp.real = (this.real * z.real + this.img * z.img) / (d);
            temp.img = (this.img * z.real - this.real * z.img) / (d);
            return temp;
        }

        /**
         * Divides this complex number by a scalar.
         *
         * @param n The divisor which is a real number.
         * @return The quotient.
         */
        public Complex divide(double n) {
            Complex temp = new Complex();
            temp.real = this.real / n;
            temp.img = this.img / n;
            return temp;
        }
    }

    /**
     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm
     * with Bit-Reversal. The size of the input signal must be a power of 2. If
     * it isn't then it is padded with zeros and the output FFT will be bigger
     * than the input signal.
     *
     * <p>
     * More info:
     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html
     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/
     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm
     * https://cp-algorithms.com/algebra/fft.html
     *  @param x The discrete signal which is then converted to the FFT or the
     * IFFT of signal x.
     * @param inverse True if you want to find the inverse FFT.
     * @return
     */
    public static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {
        /* Pad the signal with zeros if necessary */
        paddingPowerOfTwo(x);
        int N = x.size();
        int log2N = findLog2(N);
        x = fftBitReversal(N,log2N,x);
        int direction = inverse ? -1 : 1;

        /* Main loop of the algorithm */
        for (int len = 2; len <= N; len *= 2) {
            double angle = -2 * Math.PI / len * direction;
            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));
            for (int i = 0; i < N; i += len) {
                Complex w = new Complex(1, 0);
                for (int j = 0; j < len / 2; j++) {
                    Complex u = x.get(i + j);
                    Complex v = w.multiply(x.get(i + j + len / 2));
                    x.set(i + j, u.add(v));
                    x.set(i + j + len / 2, u.subtract(v));
                    w = w.multiply(wlen);
                }
            }
        }
        x = inverseFFT(N,inverse,x);
        return x;
    }

    /* Find the log2(N) */
    public static int findLog2(int N){
        int log2N = 0;
        while ((1 << log2N) < N) {
            log2N++;
        }
        return log2N;
    }

    /* Swap the values of the signal with bit-reversal method */
    public static ArrayList<Complex> fftBitReversal(int N, int log2N, ArrayList<Complex> x){
        int reverse;
        for (int i = 0; i < N; i++) {
            reverse = reverseBits(i, log2N);
            if (i < reverse) {
                Collections.swap(x, i, reverse);
            }
        }
        return x;
    }

    /* Divide by N if we want the inverse FFT */
    public static ArrayList<Complex> inverseFFT(int N, boolean inverse, ArrayList<Complex> x ){
        if (inverse) {
            for (int i = 0; i < x.size(); i++) {
                Complex z = x.get(i);
                x.set(i, z.divide(N));
            }
        }
        return x;
    }

    /**
     * This function reverses the bits of a number. It is used in Cooley-Tukey
     * FFT algorithm.
     *
     * <p>
     * E.g. num = 13 = 00001101 in binary log2N = 8 Then reversed = 176 =
     * 10110000 in binary
     *
     * <p>
     * More info: https://cp-algorithms.com/algebra/fft.html
     * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/
     *
     * @param num The integer you want to reverse its bits.
     * @param log2N The number of bits you want to reverse.
     * @return The reversed number
     */
    private static int reverseBits(int num, int log2N) {
        int reversed = 0;
        for (int i = 0; i < log2N; i++) {
            if ((num & (1 << i)) != 0) {
                reversed |= 1 << (log2N - 1 - i);
            }
        }
        return reversed;
    }

    /**
     * This method pads an ArrayList with zeros in order to have a size equal to
     * the next power of two of the previous size.
     *
     * @param x The ArrayList to be padded.
     */
    private static void paddingPowerOfTwo(ArrayList<Complex> x) {
        int n = 1;
        int oldSize = x.size();
        while (n < oldSize) {
            n *= 2;
        }
        for (int i = 0; i < n - oldSize; i++) {
            x.add(new Complex());
        }
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;
import java.util.Collections;

/**
 * n number theory, a vampire number (or true vampire number) is a composite
 * natural number with an even number of digits, that can be factored into two
 * natural numbers each with half as many digits as the original number and not
 * both with trailing zeroes, where the two factors contain precisely all the
 * digits of the original number, in any order, counting multiplicity. The first
 * vampire number is 1260 = 21 × 60. *
 *
 * <p>
 * link: https://en.wikipedia.org/wiki/Vampire_number *
 *
 * <p>
 */
public class VampireNumber {

    public static void main(String[] args) {

        test(10, 1000);
    }

    static void test(int startValue, int stopValue) {
        int countofRes = 1;
        StringBuilder res = new StringBuilder();

        for (int i = startValue; i <= stopValue; i++) {
            for (int j = i; j <= stopValue; j++) {
                // System.out.println(i+ " "+ j);
                if (isVampireNumber(i, j, true)) {
                    countofRes++;
                    res.append("" + countofRes + ": = ( " + i + "," + j + " = " + i * j + ")" + "\n");
                }
            }
        }
        System.out.println(res);
    }

    static boolean isVampireNumber(int a, int b, boolean noPseudoVamireNumbers) {

        // this is for pseudoVampireNumbers  pseudovampire number need not be of length n/2 digits for
        // example
        // 126 = 6 x 21
        if (noPseudoVamireNumbers) {
            if (a * 10 <= b || b * 10 <= a) {
                return false;
            }
        }

        String mulDigits = splitIntoDigits(a * b, 0);
        String faktorDigits = splitIntoDigits(a, b);

        return mulDigits.equals(faktorDigits);
    }

    // methode to Split the numbers to Digits
    static String splitIntoDigits(int num, int num2) {

        StringBuilder res = new StringBuilder();

        ArrayList<Integer> digits = new ArrayList<>();
        while (num > 0) {
            digits.add(num % 10);
            num /= 10;
        }
        while (num2 > 0) {
            digits.add(num2 % 10);
            num2 /= 10;
        }
        Collections.sort(digits);
        for (int i : digits) {
            res.append(i);
        }

        return res.toString();
    }
}
/**
 * A number is said to be Dudeney if the sum of the digits, is the cube root of the entered number.
 * Example- Let the number be 512, its sum of digits is 5+1+2=8. The cube root of 512 is also 8.
 *          Since, the sum of the digits is equal to the cube root of the entered number;
 *          it is a Dudeney Number.
 */
package com.thealgorithms.maths;

import java.io.*;

public class DudeneyNumber {

    //returns True if the number is a Dudeney number and False if it is not a Dudeney number.
    public static boolean isDudeney(int n) {
        // Calculating Cube Root
        int cube_root = (int) (Math.round((Math.pow(n, 1.0 / 3.0))));
        // If the number is not a perfect cube the method returns false.
        if (cube_root * cube_root * cube_root != n) {
            return false;
        }
        int sum_of_digits = 0;// Stores the sums of the digit of the entered number
        int temp = n;//A temporary variable to store the entered number
        // Loop to calculate sum of the digits.
        while (temp > 0) {

            // Extracting Last digit of the number
            int rem = temp % 10;

            // Calculating sum of digits.
            sum_of_digits += rem;

            // Removing the last digit
            temp /= 10;
        }

        //If the cube root of the number is not equal to the sum of its digits we return false.  
        if (cube_root != sum_of_digits) {
            return false;
        }

        return true;
    }

    /**
     * Method to check if number is Dudeney Number or Not 1) Input - Enter a
     * Number: 512 Output - It is a Dudeney Number. 2) Input - Enter a Number:
     * 125 Output - It is not a Dudeney Number.
     */
    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter a Number: ");
        int n = Integer.parseInt(br.readLine());
        if (isDudeney(n)) {
            System.out.println("It is a Dudeney Number.");
        } else {
            System.out.println("It is not a Dudeney Number.");
        }
    }
}
/** Author : Suraj Kumar Modi
 * https://github.com/skmodi649
 */
/** You are given a number n. You need to find the digital root of n.
 * DigitalRoot of a number is the recursive sum of its digits until we get a single digit number.
 *
 * Test Case 1:
 * Input:
 * n = 1
 * Output:  1
 * Explanation: Digital root of 1 is 1
 *
 * Test Case 2:
 * Input:
 * n = 99999
 * Output: 9
 * Explanation: Sum of digits of 99999 is 45
 * which is not a single digit number, hence
 * sum of digit of 45 is 9 which is a single
 * digit number.
 */
/** Algorithm :
 * Step 1 : Define a method digitalRoot(int n)
 * Step 2 : Define another method single(int n)
 * Step 3 : digitalRoot(int n) method takes output of single(int n) as input
 * if(single(int n) <= 9)
 * return single(n)
 * else
 * return digitalRoot(single(n))
 * Step 4 : single(int n) calculates the sum of digits of number n recursively
 * if(n<=9)
 * return n;
 * else
 * return (n%10) + (n/10)
 * Step 5 : In main method simply take n as input and then call digitalRoot(int n) function and print the result
 */
package com.thealgorithms.maths;

import java.util.*;

class DigitalRoot {

    public static int digitalRoot(int n) {
        if (single(n) <= 9) // If n is already single digit than simply call single method and return the value
        {
            return single(n);
        } else {
            return digitalRoot(single(n));
        }
    }

    // This function is used for finding the sum of digits of number
    public static int single(int n) {
        if (n <= 9) // if n becomes less than 10 than return n
        {
            return n;
        } else {
            return (n % 10) + single(n / 10);                     // n % 10 for extracting digits one by one
        }
    }                                                             // n / 10 is the number obtainded after removing the digit one by one  
    // Sum of digits is stored in the Stack memory and then finally returned

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the number : ");
        int n = sc.nextInt();                                     // Taking a number as input from the user
        System.out.println("Digital Root : " + digitalRoot(n));     // Printing the value returned by digitalRoot() method
    }
}

/**
 * Time Complexity : O((Number of Digits)^2) Auxiliary Space Complexity :
 * O(Number of Digits) Constraints : 1 <= n <= 10^7
 */
package com.thealgorithms.maths;

/**
 * Find the area of a triangle using only side lengths
 */

public class HeronsFormula {
	
	public static double Herons(int s1, int s2, int s3)
	{
		double a = s1;
		double b = s2;
		double c = s3;
		double s = (a + b + c)/2.0;
		double area = 0;
		area = Math.sqrt((s)*(s-a)*(s-b)*(s-c));
		return area;
	}
}
package com.thealgorithms.maths;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;

/*
 * Find the mode of an array of numbers
 *
 * The mode of an array of numbers is the most frequently occurring number in the array,
 * or the most frequently occurring numbers if there are multiple numbers with the same frequency
 */
public class Mode {

    public static void main(String[] args) {

        /* Test array of integers */
        assert (mode(new int[]{})) == null;
        assert Arrays.equals(mode(new int[]{5}), new int[]{5});
        assert Arrays.equals(mode(new int[]{1, 2, 3, 4, 5}), new int[]{1, 2, 3, 4, 5});
        assert Arrays.equals(mode(new int[]{7, 9, 9, 4, 5, 6, 7, 7, 8}), new int[]{7});
        assert Arrays.equals(mode(new int[]{7, 9, 9, 4, 5, 6, 7, 7, 9}), new int[]{7, 9});
    }

    /*
   * Find the mode of an array of integers
   *
   * @param numbers array of integers
   * @return mode of the array
     */
    public static int[] mode(int[] numbers) {

        if (numbers.length == 0) {
            return null;
        }

        HashMap<Integer, Integer> count = new HashMap<>();

        for (int num : numbers) {
            if (count.containsKey(num)) {

                count.put(num, count.get(num) + 1);

            } else {

                count.put(num, 1);
            }
        }

        int max = Collections.max(count.values());
        ArrayList<Integer> modes = new ArrayList<>();

        for (int num : count.keySet()) {
            if (count.get(num) == max) {
                modes.add(num);
            }
        }
        return modes.stream().mapToInt(n -> n).toArray();
    }
}
package com.thealgorithms.maths;

/*
 * Java program for Binomial Cofficients
 * Binomial Cofficients: A binomial cofficient C(n,k) gives number ways
 * in which k objects can be chosen from n objects.
 * Wikipedia: https://en.wikipedia.org/wiki/Binomial_coefficient
 * 
 * Author: Akshay Dubey (https://github.com/itsAkshayDubey)
 * 
 * */

public class BinomialCoefficient {
	
	/**
     * This method returns the number of ways in which k objects can be chosen from n objects
     *
     * @param total_objects Total number of objects
     * @param no_of_objects Number of objects to be chosen from total_objects
     * @return number of ways in which no_of_objects objects can be chosen from total_objects objects
     */
	
	static int binomialCoefficient(int total_objects, int no_of_objects) {
		
		//Base Case
		if(no_of_objects > total_objects) {
			return 0;
		}
		
		//Base Case
		if(no_of_objects == 0 || no_of_objects == total_objects) {
			return 1;
		}
		
		//Recursive Call
		return binomialCoefficient(total_objects - 1, no_of_objects - 1)
				+ binomialCoefficient(total_objects - 1, no_of_objects);
	}
	
	public static void main(String[] args) {
		System.out.println(binomialCoefficient(20,2));
		
		//Output: 190
	}

}
package com.thealgorithms.maths;

/**
 * Class for linear convolution of two discrete signals
 *
 * @author Ioannis Karavitsis
 * @version 1.0
 */
public class Convolution {

    /**
     * Discrete linear convolution function. Both input signals and the output
     * signal must start from 0. If you have a signal that has values before 0
     * then shift it to start from 0.
     *
     * @param A The first discrete signal
     * @param B The second discrete signal
     * @return The convolved signal
     */
    public static double[] convolution(double[] A, double[] B) {
        double[] convolved = new double[A.length + B.length - 1];

        /*
    The discrete convolution of two signals A and B is defined as:

          A.length
    C[i] = Σ (A[k]*B[i-k])
          k=0

    It's obvious that:  0 <= k <= A.length , 0 <= i <= A.length + B.length - 2  and  0 <= i-k <= B.length - 1
    From the last inequality we get that:  i - B.length + 1 <= k <= i and thus we get the conditions below.
         */
        for (int i = 0; i < convolved.length; i++) {
            convolved[i] = 0;
            int k = Math.max(i - B.length + 1, 0);

            while (k < i + 1 && k < A.length) {
                convolved[i] += A[k] * B[i - k];
                k++;
            }
        }

        return convolved;
    }
}
package com.thealgorithms.maths;

public class StandardDeviation {
	
  public static double stdDev(double[] data)
	{
		double var = 0;
		double avg = 0;
		for (int i = 0; i < data.length; i++)
		{
			avg += data[i];
		}
		avg /= data.length;
		for (int j = 0; j < data.length; j++)
		{
			var += Math.pow((data[j] - avg), 2);
		}
		var /= data.length;
		return Math.sqrt(var);
	}
  
}
package com.thealgorithms.maths;

/**
 * @see <a href="https://en.wikipedia.org/wiki/Combination">Combination</a>
 */
public class Combinations {

    public static void main(String[] args) {
        assert combinations(1, 1) == 1;
        assert combinations(10, 5) == 252;
        assert combinations(6, 3) == 20;
        assert combinations(20, 5) == 15504;

        // Since, 200 is a big number its factorial will go beyond limits of long even when 200C5 can be saved in a long
        // variable. So below will fail
        // assert combinations(200, 5) == 2535650040l;
        assert combinationsOptimized(100, 0) == 1;
        assert combinationsOptimized(1, 1) == 1;
        assert combinationsOptimized(10, 5) == 252;
        assert combinationsOptimized(6, 3) == 20;
        assert combinationsOptimized(20, 5) == 15504;
        assert combinationsOptimized(200, 5) == 2535650040l;
    }

    /**
     * Calculate of factorial
     *
     * @param n the number
     * @return factorial of given number
     */
    public static long factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("number is negative");
        }
        return n == 0 || n == 1 ? 1 : n * factorial(n - 1);
    }

    /**
     * Calculate combinations
     *
     * @param n first number
     * @param k second number
     * @return combinations of given {@code n} and {@code k}
     */
    public static long combinations(int n, int k) {
        return factorial(n) / (factorial(k) * factorial(n - k));
    }

    /**
     * The above method can exceed limit of long (overflow) when factorial(n) is
     * larger than limits of long variable. Thus even if nCk is within range of
     * long variable above reason can lead to incorrect result. This is an
     * optimized version of computing combinations. Observations: nC(k + 1) = (n
     * - k) * nCk / (k + 1) We know the value of nCk when k = 1 which is nCk = n
     * Using this base value and above formula we can compute the next term
     * nC(k+1)
     *
     * @param n
     * @param k
     * @return nCk
     */
    public static long combinationsOptimized(int n, int k) {
        if (n < 0 || k < 0) {
            throw new IllegalArgumentException("n or k can't be negative");
        }
        if (n < k) {
            throw new IllegalArgumentException("n can't be smaller than k");
        }
        // nC0 is always 1
        long solution = 1;
        for (int i = 0; i < k; i++) {
            long next = (n - i) * solution / (i + 1);
            solution = next;
        }
        return solution;
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;
import java.util.Random;

/**
 * use quick sort algorithm to get kth largest or kth smallest element in given array
 */
public class FindKthNumber {
    private static final Random random = new Random();

    public static void main(String[] args) {
        /* generate array with random size and random elements */
        int[] nums = generateArray(100);

        /* get 3th largest element */
        int kth = 3;
        int kthMaxIndex = nums.length - kth;
        int targetMax = findKthMax(nums, kthMaxIndex);

        /* get 3th smallest element */
        int kthMinIndex = kth - 1;
        int targetMin = findKthMax(nums, kthMinIndex);

        Arrays.sort(nums);
        assert nums[kthMaxIndex] == targetMax;
        assert nums[kthMinIndex] == targetMin;
    }

    private static int[] generateArray(int capacity) {
        int size = random.nextInt(capacity) + 1;
        int[] array = new int[size];

        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt() % 100;
        }
        return array;
    }

    private static int findKthMax(int[] nums, int k) {
        int start = 0, end = nums.length;
        while (start < end) {
            int pivot = partition(nums, start, end);
            if (k == pivot) {
                return nums[pivot];
            } else if (k > pivot) {
                start = pivot + 1;
            } else {
                end = pivot;
            }
        }
        return -1;
    }

    private static int partition(int[] nums, int start, int end) {
        int pivot = nums[start];
        int j = start;
        for (int i = start + 1; i < end; i++) {
            if (nums[i] < pivot) {
                j++;
                swap(nums, i, j);
            }
        }
        swap(nums, start, j);
        return j;
    }

    private static void swap(int[] nums, int a, int b) {
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}
package com.thealgorithms.maths;

import java.util.*;

class KeithNumber {

    //user-defined function that checks if the given number is Keith or not  
    static boolean isKeith(int x) {
        //List stores all the digits of the X  
        ArrayList<Integer> terms = new ArrayList<Integer>();
        //n denotes the number of digits   
        int temp = x, n = 0;
        //executes until the condition becomes false  
        while (temp > 0) {
            //determines the last digit of the number and add it to the List      
            terms.add(temp % 10);
            //removes the last digit  
            temp = temp / 10;
            //increments the number of digits (n) by 1  
            n++;
        }
        //reverse the List  
        Collections.reverse(terms);
        int next_term = 0, i = n;
        //finds next term for the series  
        //loop executes until the condition returns true  
        while (next_term < x) {
            next_term = 0;
            //next term is the sum of previous n terms (it depends on number of digits the number has)  
            for (int j = 1; j <= n; j++) {
                next_term = next_term + terms.get(i - j);
            }
            terms.add(next_term);
            i++;
        }
        //when the control comes out of the while loop, there will be two conditions:  
        //either next_term will be equal to x or greater than x  
        //if equal, the given number is Keith, else not  
        return (next_term == x);
    }

    //driver code  
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        if (isKeith(n)) {
            System.out.println("Yes, the given number is a Keith number.");
        } else {
            System.out.println("No, the given number is not a Keith number.");
        }
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;

public class Gaussian {

    public static ArrayList<Double> gaussian(int mat_size, ArrayList<Double> matrix) {
        ArrayList<Double> answerArray = new ArrayList<Double>();
        int i, j = 0;

        double[][] mat = new double[mat_size + 1][mat_size + 1];
        double[][] x = new double[mat_size][mat_size + 1];

        // Values from arraylist to matrix
        for (i = 0; i < mat_size; i++) {
            for (j = 0; j <= mat_size; j++) {
                mat[i][j] = matrix.get(i);
            }
        }

        mat = gaussianElimination(mat_size, i, mat);
        answerArray = valueOfGaussian(mat_size, x, mat);
        return answerArray;
    }

    // Perform Gaussian elimination
    public static double[][] gaussianElimination(int mat_size, int i, double[][] mat) {
        int step = 0;
        for (step = 0; step < mat_size - 1; step++) {
            for (i = step; i < mat_size - 1; i++) {
                double a = (mat[i + 1][step] / mat[step][step]);

                for (int j = step; j <= mat_size; j++) {
                    mat[i + 1][j] = mat[i + 1][j] - (a * mat[step][j]);
                }
            }
        }
        return mat;
    }

    // calculate the x_1, x_2,... values of the gaussian and save it in an arraylist.
    public static ArrayList<Double> valueOfGaussian(int mat_size, double[][] x, double[][] mat) {
        ArrayList<Double> answerArray = new ArrayList<Double>();
        int i, j;

        for (i = 0; i < mat_size; i++) {
            for (j = 0; j <= mat_size; j++) {
                x[i][j] = mat[i][j];
            }
        }

        for (i = mat_size - 1; i >= 0; i--) {
            double sum = 0;
            for (j = mat_size - 1; j > i; j--) {
                x[i][j] = x[j][j] * x[i][j];
                sum = x[i][j] + sum;
            }
            if (x[i][i] == 0) {
                x[i][i] = 0;
            } else {
                x[i][i] = (x[i][mat_size] - sum) / (x[i][i]);
            }
            answerArray.add(x[i][j]);
        }
        return answerArray;
    }
}package com.thealgorithms.maths;

// POWER (exponentials) Examples (a^b)
public class Pow {

    public static void main(String[] args) {
        assert pow(2, 0) == Math.pow(2, 0); // == 1
        assert pow(0, 2) == Math.pow(0, 2); // == 0
        assert pow(2, 10) == Math.pow(2, 10); // == 1024
        assert pow(10, 2) == Math.pow(10, 2); // == 100
    }

    /**
     * Returns the value of the first argument raised to the power of the second
     * argument
     *
     * @param a the base.
     * @param b the exponent.
     * @return the value {@code a}<sup>{@code b}</sup>.
     */
    public static long pow(int a, int b) {
        long result = 1;
        for (int i = 1; i <= b; i++) {
            result *= a;
        }
        return result;
    }
}
package com.thealgorithms.maths;

/**
 * https://en.wikipedia.org/wiki/Perfect_square
 */
public class PerfectSquare {

    public static void main(String[] args) {
        assert !isPerfectSquare(-1);
        assert !isPerfectSquare(3);
        assert !isPerfectSquare(5);
        assert isPerfectSquare(9);
        assert isPerfectSquare(100);
    }

    /**
     * Check if a number is perfect square number
     *
     * @param number the number to be checked
     * @return <tt>true</tt> if {@code number} is perfect square, otherwise
     * <tt>false</tt>
     */
    public static boolean isPerfectSquare(int number) {
        int sqrt = (int) Math.sqrt(number);
        return sqrt * sqrt == number;
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;

/**
 * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal
 * using the Bluestein's algorithm.
 *
 * @author Ioannis Karavitsis
 * @version 1.0
 */
public class FFTBluestein {

    /**
     * Bluestein's FFT Algorithm.
     *
     * <p>
     * More info:
     * https://en.wikipedia.org/wiki/Chirp_Z-transform#Bluestein.27s_algorithm
     * http://tka4.org/materials/lib/Articles-Books/Numerical%20Algorithms/Hartley_Trasform/Bluestein%27s%20FFT%20algorithm%20-%20Wikipedia,%20the%20free%20encyclopedia.htm
     *
     * @param x The discrete signal which is then converted to the FFT or the
     * IFFT of signal x.
     * @param inverse True if you want to find the inverse FFT.
     */
    public static void fftBluestein(ArrayList<FFT.Complex> x, boolean inverse) {
        int N = x.size();
        int bnSize = 2 * N - 1;
        int direction = inverse ? -1 : 1;
        ArrayList<FFT.Complex> an = new ArrayList<>();
        ArrayList<FFT.Complex> bn = new ArrayList<>();

        /* Initialization of the b(n) sequence (see Wikipedia's article above for the symbols used)*/
        for (int i = 0; i < bnSize; i++) {
            bn.add(new FFT.Complex());
        }

        for (int i = 0; i < N; i++) {
            double angle = (i - N + 1) * (i - N + 1) * Math.PI / N * direction;
            bn.set(i, new FFT.Complex(Math.cos(angle), Math.sin(angle)));
            bn.set(bnSize - i - 1, new FFT.Complex(Math.cos(angle), Math.sin(angle)));
        }

        /* Initialization of the a(n) sequence */
        for (int i = 0; i < N; i++) {
            double angle = -i * i * Math.PI / N * direction;
            an.add(x.get(i).multiply(new FFT.Complex(Math.cos(angle), Math.sin(angle))));
        }

        ArrayList<FFT.Complex> convolution = ConvolutionFFT.convolutionFFT(an, bn);

        /* The final multiplication of the convolution with the b*(k) factor  */
        for (int i = 0; i < N; i++) {
            double angle = -1 * i * i * Math.PI / N * direction;
            FFT.Complex bk = new FFT.Complex(Math.cos(angle), Math.sin(angle));
            x.set(i, bk.multiply(convolution.get(i + N - 1)));
        }

        /* Divide by N if we want the inverse FFT */
        if (inverse) {
            for (int i = 0; i < N; i++) {
                FFT.Complex z = x.get(i);
                x.set(i, z.divide(N));
            }
        }
    }
}
package com.thealgorithms.maths;

/**
 * This is Euclid's algorithm which is used to find the greatest common
 * denominator Overide function name gcd
 *
 * @author Oskar Enmalm 3/10/17
 */
public class GCD {

    /**
     * get greatest common divisor
     *
     * @param num1 the first number
     * @param num2 the second number
     * @return gcd
     */
    public static int gcd(int num1, int num2) {
        if (num1 < 0 || num2 < 0) {
            throw new ArithmeticException();
        }

        if (num1 == 0 || num2 == 0) {
            return Math.abs(num1 - num2);
        }

        while (num1 % num2 != 0) {
            int remainder = num1 % num2;
            num1 = num2;
            num2 = remainder;
        }
        return num2;
    }

    /**
     * get greatest common divisor in array
     *
     * @param number contains number
     * @return gcd
     */
    public static int gcd(int[] number) {
        int result = number[0];
        for (int i = 1; i < number.length; i++) // call gcd function (input two value)
        {
            result = gcd(result, number[i]);
        }

        return result;
    }

    public static void main(String[] args) {
        int[] myIntArray = {4, 16, 32};

        // call gcd function (input array)
        System.out.println(gcd(myIntArray)); // => 4
        System.out.printf("gcd(40,24)=%d gcd(24,40)=%d%n", gcd(40, 24), gcd(24, 40)); // => 8
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;
public class PascalTriangle {
    /**
     *In mathematics, Pascal's triangle is a triangular array of the binomial coefficients that arises
     * in probability theory, combinatorics, and algebra. In much of the Western world, it is named after
     * the French mathematician Blaise Pascal, although other mathematicians studied it centuries before
     * him in India, Persia, China, Germany, and Italy.
     *
     * The rows of Pascal's triangle are conventionally enumerated starting with row n=0 at the top (the 0th row).
     * The entries in each row are numbered from the left beginning with k=0 and are usually staggered relative
     * to the numbers in the adjacent rows. The triangle may be constructed in the following manner:
     * In row 0 (the topmost row), there is a unique nonzero entry 1. Each entry of each subsequent row is
     * constructed by adding the number above and to the left with the number above and to the right, treating
     * blank entries as 0. For example, the initial number in the first (or any other) row is 1 (the sum of 0 and 1),
     * whereas the numbers 1 and 3 in the third row are added to produce the number 4 in the fourth row. *
     *
     *<p>
     *     link:-https://en.wikipedia.org/wiki/Pascal%27s_triangle
     *
     * <p>
     *     Example:-
     *                  1
     *                1   1
     *              1   2   1
     *            1   3   3   1
     *          1   4   6   4   1
     *        1   5  10   10  5   1
     *      1   6  15  20   15  6   1
     *    1   7  21  35   35  21  7   1
     *  1   8  28  56  70   56   28  8   1
     *
     */

        public static int[][] pascal(int n)
    {
        /**
         * @param arr  An auxiliary array to store generated pascal triangle values
         * @return
         */
        int[][] arr = new int[n][n];
        /**
         * @param line Iterate through every line and print integer(s) in it
         * @param i Represents the column number of the element we are currently on
         */
        for (int line = 0; line < n; line++)
        {
            /**
             *  @Every line has number of integers equal to line number
             */
            for (int i = 0; i <= line; i++)
            {
                // First and last values in every row are 1
                if (line == i || i == 0)
                    arr[line][i] = 1;
                    // The rest elements are sum of values just above and left of above
                else
                    arr[line][i] = arr[line-1][i-1] + arr[line-1][i];
            }
        }
        
        return arr;
    }
}
package com.thealgorithms.maths;

/**
 * https://en.wikipedia.org/wiki/Cube_(algebra)
 */
public class PerfectCube {

    public static void main(String[] args) {
        assert !isPerfectCube(-1);
        assert isPerfectCube(0);
        assert isPerfectCube(1);
        assert !isPerfectCube(4);
        assert isPerfectCube(8);
        assert isPerfectCube(27);
    }

    /**
     * Check if a number is perfect cube or not
     *
     * @param number number to check
     * @return {@code true} if {@code number} is perfect cube, otherwise
     * {@code false}
     */
    public static boolean isPerfectCube(int number) {
        int a = (int) Math.pow(number, 1.0 / 3);
        return a * a * a == number;
    }
}
package com.thealgorithms.maths;

import java.util.Random;

public class MaxValue {

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        Random rand = new Random();

        /* test 100 times using rand numbers */
        for (int i = 1; i <= 100; ++i) {
            /* generate number from -50 to 49 */
            int a = rand.nextInt(100) - 50;
            int b = rand.nextInt(100) - 50;
            assert max(a, b) == Math.max(a, b);
        }
    }

    /**
     * Returns the greater of two {@code int} values. That is, the result is the
     * argument closer to the value of {@link Integer#MAX_VALUE}. If the
     * arguments have the same value, the result is that same value.
     *
     * @param a an argument.
     * @param b another argument.
     * @return the larger of {@code a} and {@code b}.
     */
    public static int max(int a, int b) {
        return a >= b ? a : b;
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;

public class PrimeFactorization {

    public static void main(String[] args) {
        System.out.println("## all prime factors ##");
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = scanner.nextInt();
        System.out.print(("printing factors of " + n + " : "));
        pfactors(n);
        scanner.close();
    }

    public static void pfactors(int n) {

        while (n % 2 == 0) {
            System.out.print(2 + " ");
            n /= 2;
        }

        for (int i = 3; i <= Math.sqrt(n); i += 2) {
            while (n % i == 0) {
                System.out.print(i + " ");
                n /= i;
            }
        }

        if (n > 2) {
            System.out.print(n);
        }
    }
}
package com.thealgorithms.maths;

/**
 * An Armstrong number is equal to the sum of the cubes of its digits. For
 * example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370. An
 * Armstrong number is often called Narcissistic number.
 *
 * @author Vivek
 */
public class Armstrong {

    /**
     * Checks whether a given number is an armstrong number or not.
     *
     * @param number number to check
     * @return {@code true} if given number is armstrong number, {@code false}
     * otherwise
     */
    public boolean isArmstrong(int number) {
        long sum = 0;
        long number2 = number;
        while (number2 > 0) {
            long mod = number2 % 10;
            sum += Math.pow(mod, 3);
            number2 /= 10;
        }
        return sum == number;
    }
}package com.thealgorithms.maths;

/**
 * The trinomial triangle is a variation of Pascal’s triangle. The difference
 * between the two is that an entry in the trinomial triangle is the sum of the
 * three (rather than the two in Pasacal’s triangle) entries above it
 *
 * Example Input: n = 4 Output 1 1 1 1 1 2 3 2 1 1 3 6 7 6 3 1
 */
public class TrinomialTriangle {

    public static int TrinomialValue(int n, int k) {
        if (n == 0 && k == 0) {
            return 1;
        }

        if (k < -n || k > n) {
            return 0;
        }

        return TrinomialValue(n - 1, k - 1) + TrinomialValue(n - 1, k) + TrinomialValue(n - 1, k + 1);
    }

    public static void printTrinomial(int n) {
        for (int i = 0; i < n; i++) {
            for (int j = -i; j <= 0; j++) {
                System.out.print(TrinomialValue(i, j) + " ");
            }

            for (int j = 1; j <= i; j++) {
                System.out.print(TrinomialValue(i, j) + " ");
            }

            System.out.println();
        }
    }

    public static void main(String argc[]) {
        int n = 6;
        printTrinomial(n);
    }
}
package com.thealgorithms.maths;

/**
 * Amicable numbers are two different numbers so related that the sum of the
 * proper divisors of each is equal to the other number. (A proper divisor of a
 * number is a positive factor of that number other than the number itself. For
 * example, the proper divisors of 6 are 1, 2, and 3.) A pair of amicable
 * numbers constitutes an aliquot sequence of period 2. It is unknown if there
 * are infinitely many pairs of amicable numbers. *
 *
 * <p>
 * link: https://en.wikipedia.org/wiki/Amicable_numbers *
 *
 * <p>
 * Simple Example : (220,284) 220 is divisible by {1,2,4,5,10,11,20,22,44,55,110
 * } <- Sum = 284
 * 284 is divisible by -> 1,2,4,71,142 and the Sum of that is. Yes right you
 * probably expected it 220
 */
public class AmicableNumber {

    public static void main(String[] args) {

        AmicableNumber.findAllInRange(1, 3000);
        /* Res -> Int Range of 1 till 3000there are 3Amicable_numbers These are  1: = ( 220,284)	2: = ( 1184,1210)
    3: = ( 2620,2924) So it worked	*/

    }

    /**
     * @param startValue
     * @param stopValue
     * @return
     */
    static void findAllInRange(int startValue, int stopValue) {

        /* the 2 for loops are to avoid to double check tuple. For example (200,100) and (100,200) is the same calculation
     * also to avoid is to check the number with it self. a number with itself is always a AmicableNumber
     * */
        StringBuilder res = new StringBuilder();
        int countofRes = 0;

        for (int i = startValue; i < stopValue; i++) {
            for (int j = i + 1; j <= stopValue; j++) {
                if (isAmicableNumber(i, j)) {
                    countofRes++;
                    res.append("" + countofRes + ": = ( " + i + "," + j + ")" + "\t");
                }
            }
        }
        res.insert(
                0,
                "Int Range of "
                + startValue
                + " till "
                + stopValue
                + " there are "
                + countofRes
                + " Amicable_numbers.These are \n ");
        System.out.println(res.toString());
    }

    /**
     * Check if {@code numberOne and numberTwo } are AmicableNumbers or not
     *
     * @param numberOne numberTwo
     * @return {@code true} if {@code numberOne numberTwo} isAmicableNumbers
     * otherwise false
     */
    static boolean isAmicableNumber(int numberOne, int numberTwo) {

        return ((recursiveCalcOfDividerSum(numberOne, numberOne) == numberTwo
                && numberOne == recursiveCalcOfDividerSum(numberTwo, numberTwo)));
    }

    /**
     * calculated in recursive calls the Sum of all the Dividers beside it self
     *
     * @param number div = the next to test dividely by using the modulo
     * operator
     * @return sum of all the dividers
     */
    static int recursiveCalcOfDividerSum(int number, int div) {

        if (div == 1) {
            return 0;
        } else if (number % --div == 0) {
            return recursiveCalcOfDividerSum(number, div) + div;
        } else {
            return recursiveCalcOfDividerSum(number, div);
        }
    }
}
package com.thealgorithms.maths;

import java.math.BigDecimal;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;

/**
 * @author: caos321
 * @date: 14 October 2021 (Thursday)
 */
public class FibonacciJavaStreams {

    public static Optional<BigDecimal> calculate(final BigDecimal index) {
        if (index == null || index.compareTo(BigDecimal.ZERO) < 0) {
            return Optional.empty();
        }

        if (index.compareTo(BigDecimal.ONE) < 0) {
            return Optional.of(BigDecimal.ZERO);
        }

        if (index.compareTo(new BigDecimal(2)) < 0) {
            return Optional.of(BigDecimal.ONE);
        }

        final List<BigDecimal> results = Stream.iterate(
                index,
                x -> x.compareTo(BigDecimal.ZERO) > 0,
                x -> x.subtract(BigDecimal.ONE)
        )
                .reduce(
                        List.of(),
                        (list, current)
                        -> list.isEmpty() || list.size() < 2
                        ? List.of(BigDecimal.ZERO, BigDecimal.ONE)
                        : List.of(list.get(1), list.get(0).add(list.get(1))),
                        (list1, list2) -> list1
                );

        return results.isEmpty()
                ? Optional.empty()
                : Optional.of(results.get(results.size() - 1));
    }

    public static void assertThat(final Object actual, final Object expected) {
        if (!Objects.equals(actual, expected)) {
            throw new AssertionError(String.format("expected=%s but was actual=%s", expected, actual));
        }
    }

    public static void main(final String[] args) {
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(-1));
            assertThat(result.isEmpty(), true);
        }
        {
            final Optional<BigDecimal> result = calculate(BigDecimal.ZERO);
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, BigDecimal.ZERO));
        }
        {
            final Optional<BigDecimal> result = calculate(BigDecimal.ONE);
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, BigDecimal.ONE));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(2));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, BigDecimal.ONE));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(3));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(2)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(10));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(55)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(20));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(6765)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(30));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(832040)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(40));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(102334155)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(50));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(12586269025L)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(100));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal("354224848179261915075")));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(200));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal("280571172992510140037611932413038677189525")));
        }
    }
}
// Ugly numbers are numbers whose only prime factors are 2, 3 or 5. The sequence 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, … shows the first 11 ugly numbers.
// By convention, 1 is included.
// A program to find the nth Ugly number
// Algorithm :
// Initialize three-pointers two, three, and five pointing to zero.
// Take 3 variables nm2, nm3, and nm5 to keep track of next multiple of 2,3 and 5.
// Make an array of size n to store the ugly numbers with 1 at 0th index.
// Initialize a variable next which stores the value of the last element in the array.
// Run a loop n-1 times and perform steps 6,7 and 8.
// Update the values of nm2, nm3, nm5 as ugly[two]*2, ugly[three]*3, ugly[5]*5 respectively.
// Select the minimum value from nm2, nm3, and nm5 and increment the pointer related to it.
// Store the minimum value in variable next and array.
// Return next.
package com.thealgorithms.maths;

import java.util.*;

class NthUglyNumber {

    /* Function to get the nth ugly number*/
    public long getNthUglyNo(int n) {
        long[] ugly = new long[n];
        int two = 0, three = 0, five = 0;
        long nm2 = 2, nm3 = 3, nm5 = 5;
        long next = 1;

        ugly[0] = 1;

        for (int i = 1; i < n; i++) {
            next = Math.min(nm2, Math.min(nm3, nm5));

            ugly[i] = next;
            if (next == nm2) {
                two = two + 1;
                nm2 = ugly[two] * 2;
            }
            if (next == nm3) {
                three = three + 1;
                nm3 = ugly[three] * 3;
            }
            if (next == nm5) {
                five = five + 1;
                nm5 = ugly[five] * 5;
            }
        }
        return next;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the value of n : ");
        int n = sc.nextInt();
        NthUglyNumber ob = new NthUglyNumber();
        long ugly = ob.getNthUglyNo(n);
        System.out.println("nth Ugly number is : " + ugly);
    }
}
package com.thealgorithms.maths;

/**
 * @author https://github.com/shellhub/
 */
public class GCDRecursion {

    public static void main(String[] args) {
        System.out.println(gcd(20, 15));
        /* output: 5 */
        System.out.println(gcd(10, 8));
        /* output: 2 */
        System.out.println(gcd(gcd(10, 5), gcd(5, 10)));
        /* output: 5 */
    }

    /**
     * get greatest common divisor
     *
     * @param a the first number
     * @param b the second number
     * @return gcd
     */
    public static int gcd(int a, int b) {

        if (a < 0 || b < 0) {
            throw new ArithmeticException();
        }

        if (a == 0 || b == 0) {
            return Math.abs(a - b);
        }

        if (a % b == 0) {
            return b;
        } else {
            return gcd(b, a % b);
        }
    }
}
package com.thealgorithms.maths;

public record ADTFraction(int numerator, int denominator) {

    /**
     * Initializes a newly created {@code ADTFraction} object so that it represents
     * a fraction with the {@code numerator} and {@code denominator} provided as arguments.
     *
     * @param numerator   The fraction numerator
     * @param denominator The fraction denominator
     */
    public ADTFraction {
        if (denominator == 0) {
            throw new IllegalArgumentException("Denominator cannot be 0");
        }
    }

    /**
     * Add two fractions.
     *
     * @param fraction the {@code ADTFraction} to add
     * @return A new {@code ADTFraction} containing the result of the operation
     */
    public ADTFraction plus(ADTFraction fraction) {
        var numerator = this.denominator * fraction.numerator + this.numerator * fraction.denominator;
        var denominator = this.denominator * fraction.denominator;
        return new ADTFraction(numerator, denominator);

    }

    /**
     * Multiply fraction by a number.
     *
     * @param number the number to multiply
     * @return A new {@code ADTFraction} containing the result of the operation
     */
    public ADTFraction times(int number) {
        return times(new ADTFraction(number, 1));
    }

    /**
     * Multiply two fractions.
     *
     * @param fraction the {@code ADTFraction} to multiply
     * @return A new {@code ADTFraction} containing the result of the operation
     */
    public ADTFraction times(ADTFraction fraction) {
        var numerator = this.numerator * fraction.numerator;
        var denominator = this.denominator * fraction.denominator;
        return new ADTFraction(numerator, denominator);
    }

    /**
     * Generates the reciprocal of the fraction.
     *
     * @return A new {@code ADTFraction} with the {@code numerator} and {@code denominator} switched
     */
    public ADTFraction reciprocal() {
        return new ADTFraction(this.denominator, this.numerator);
    }

    /**
     * Calculates the result of the fraction.
     *
     * @return The numerical result of the division between {@code numerator} and {@code denominator}
     */
    public float value() {
        return (float) this.numerator / this.denominator;
    }

    /**
     * Returns a string representation of this {@code ADTFraction} in the format
     * {@code numerator}/{@code denominator}.
     *
     * @return A string representation of this {@code ADTFraction}
     */
    @Override
    public String toString() {
        return String.format("%d/%d", this.numerator, this.denominator);
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;

/**
 * Class for circular convolution of two discrete signals using the convolution
 * theorem.
 *
 * @author Ioannis Karavitsis
 * @version 1.0
 */
public class CircularConvolutionFFT {

    /**
     * This method pads the signal with zeros until it reaches the new size.
     *
     * @param x The signal to be padded.
     * @param newSize The new size of the signal.
     */
    private static void padding(ArrayList<FFT.Complex> x, int newSize) {
        if (x.size() < newSize) {
            int diff = newSize - x.size();
            for (int i = 0; i < diff; i++) {
                x.add(new FFT.Complex());
            }
        }
    }

    /**
     * Discrete circular convolution function. It uses the convolution theorem
     * for discrete signals: convolved = IDFT(DFT(a)*DFT(b)). Then we use the
     * FFT algorithm for faster calculations of the two DFTs and the final IDFT.
     *
     * <p>
     * More info: https://en.wikipedia.org/wiki/Convolution_theorem
     *
     * @param a The first signal.
     * @param b The other signal.
     * @return The convolved signal.
     */
    public static ArrayList<FFT.Complex> fftCircularConvolution(
            ArrayList<FFT.Complex> a, ArrayList<FFT.Complex> b) {
        int convolvedSize
                = Math.max(
                        a.size(), b.size()); // The two signals must have the same size equal to the bigger one
        padding(a, convolvedSize); // Zero padding the smaller signal
        padding(b, convolvedSize);

        /* Find the FFTs of both signal. Here we use the Bluestein algorithm because we want the FFT to have the same length with the signal and not bigger */
        FFTBluestein.fftBluestein(a, false);
        FFTBluestein.fftBluestein(b, false);
        ArrayList<FFT.Complex> convolved = new ArrayList<>();

        for (int i = 0; i < a.size(); i++) {
            convolved.add(a.get(i).multiply(b.get(i))); // FFT(a)*FFT(b)
        }
        FFTBluestein.fftBluestein(convolved, true); // IFFT

        return convolved;
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;
import java.util.NoSuchElementException;
import java.lang.IllegalStateException;

public class ReverseNumber {

    public static void main(String[] args) {
        int number;
        int reverse = 0;

        try (Scanner sc = new Scanner(System.in)) {
            System.out.println("Enter a number:");
            number = sc.nextInt();
        } catch (NoSuchElementException | IllegalStateException e) {
            System.out.println("ERROR: Invalid input");
            return;
        }

        while (number != 0) {
            int remainder = number % 10;

            reverse = reverse * 10 + remainder;
            number = number / 10;
        }

        System.out.println("The reverse of the given number is: " + reverse);
    }
}
package com.thealgorithms.maths;

public class DistanceFormula {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		double dX = Math.pow(x2-x1, 2);
		double dY = Math.pow(y2-x1, 2);
		double d = Math.sqrt(dX+dY);
		return d;
	}
}
package com.thealgorithms.maths;

import java.util.Random;

public class Ceil {

    public static void main(String[] args) {
        Random random = new Random();
        for (int i = 1; i <= 1000; ++i) {
            double randomNumber = random.nextDouble();
            assert ceil(randomNumber) == Math.ceil(randomNumber);
        }
    }

    /**
     * Returns the smallest (closest to negative infinity)
     *
     * @param number the number
     * @return the smallest (closest to negative infinity) of given
     * {@code number}
     */
    public static double ceil(double number) {
        if (number - (int) number == 0) {
            return number;
        } else if (number - (int) number > 0) {
            return (int) (number + 1);
        } else {
            return (int) number;
        }
    }
}
package com.thealgorithms.maths;

public class BinaryPow {

    /**
     * Calculate a^p using binary exponentiation
     * [Binary-Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html)
     *
     * @param a the base for exponentiation
     * @param p the exponent - must be greater than 0
     * @return a^p
     */
    public static int binPow(int a, int p) {
        int res = 1;
        while (p > 0) {
            if ((p & 1) == 1) {
                res = res * a;
            }
            a = a * a;
            p >>>= 1;
        }
        return res;
    }

    /**
     * Function for testing binary exponentiation
     *
     * @param a the base
     * @param p the exponent
     */
    public static void test(int a, int p) {
        int res = binPow(a, p);
        assert res == (int) Math.pow(a, p) : "Incorrect Implementation";
        System.out.println(a + "^" + p + ": " + res);
    }

    /**
     * Main Function to call tests
     *
     * @param args System Line Arguments
     */
    public static void main(String[] args) {
        // prints 2^15: 32768
        test(2, 15);

        // prints 3^9: 19683
        test(3, 9);
    }
}
package com.thealgorithms.maths;

/**
 * Fibonacci: 0 1 1 2 3 5 8 13 21 ...
 */
public class FibonacciNumber {

    public static void main(String[] args) {
        assert isFibonacciNumber(1);
        assert isFibonacciNumber(2);
        assert isFibonacciNumber(21);
        assert !isFibonacciNumber(9);
        assert !isFibonacciNumber(10);
    }

    /**
     * Check if a number is perfect square number
     *
     * @param number the number to be checked
     * @return <tt>true</tt> if {@code number} is perfect square, otherwise
     * <tt>false</tt>
     */
    public static boolean isPerfectSquare(int number) {
        int sqrt = (int) Math.sqrt(number);
        return sqrt * sqrt == number;
    }

    /**
     * Check if a number is fibonacci number This is true if and only if at
     * least one of 5x^2+4 or 5x^2-4 is a perfect square
     *
     * @param number the number
     * @return <tt>true</tt> if {@code number} is fibonacci number, otherwise
     * <tt>false</tt>
     * @link https://en.wikipedia.org/wiki/Fibonacci_number#Identification
     */
    public static boolean isFibonacciNumber(int number) {
        return isPerfectSquare(5 * number * number + 4) || isPerfectSquare(5 * number * number - 4);
    }
}
package com.thealgorithms.maths;

import java.util.Random;

public class MinValue {

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        Random rand = new Random();

        /* test 100 times using rand numbers */
        for (int i = 1; i <= 100; ++i) {
            /* generate number from -50 to 49 */
            int a = rand.nextInt(100) - 50;
            int b = rand.nextInt(100) - 50;
            assert min(a, b) == Math.min(a, b);
        }
    }

    /**
     * Returns the smaller of two {@code int} values. That is, the result the
     * argument closer to the value of {@link Integer#MIN_VALUE}. If the
     * arguments have the same value, the result is that same value.
     *
     * @param a an argument.
     * @param b another argument.
     * @return the smaller of {@code a} and {@code b}.
     */
    public static int min(int a, int b) {
        return a <= b ? a : b;
    }
}
package com.thealgorithms.maths;

public class AbsoluteValue {

    /**
     * Returns the absolute value of a number.
     *
     * @param number The number to be transformed
     * @return The absolute value of the {@code number}
     */
    public static int getAbsValue(int number) {
        return number < 0 ? -number : number;
    }
}
package com.thealgorithms.maths;

import java.math.BigDecimal;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.stream.IntStream;

/**
 * @author: caos321
 * @date: 31 October 2021 (Sunday)
 */
public class MatrixUtil {

    public static boolean isValid(final BigDecimal[][] matrix) {
        return matrix != null && matrix.length > 0 && matrix[0].length > 0;
    }

    public static boolean hasEqualSizes(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {
        return isValid(matrix1) && isValid(matrix2)
                && matrix1.length == matrix2.length
                && matrix1[0].length == matrix2[0].length;
    }

    public static boolean canMultiply(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {
        return isValid(matrix1) && isValid(matrix2)
                && matrix1[0].length == matrix2.length;
    }

    public static Optional<BigDecimal[][]> operate(final BigDecimal[][] matrix1,
            final BigDecimal[][] matrix2,
            final BiFunction<BigDecimal, BigDecimal, BigDecimal> operation) {
        if (!hasEqualSizes(matrix1, matrix2)) {
            return Optional.empty();
        }

        final int rowSize = matrix1.length;
        final int columnSize = matrix1[0].length;

        final BigDecimal[][] result = new BigDecimal[rowSize][columnSize];

        IntStream.range(0, rowSize).forEach(rowIndex
                -> IntStream.range(0, columnSize).forEach(columnIndex -> {
                    final BigDecimal value1 = matrix1[rowIndex][columnIndex];
                    final BigDecimal value2 = matrix2[rowIndex][columnIndex];

                    result[rowIndex][columnIndex] = operation.apply(value1, value2);
                }));

        return Optional.of(result);
    }

    public static Optional<BigDecimal[][]> add(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {
        return operate(matrix1, matrix2, BigDecimal::add);
    }

    public static Optional<BigDecimal[][]> subtract(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {
        return operate(matrix1, matrix2, BigDecimal::subtract);
    }

    public static Optional<BigDecimal[][]> multiply(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {
        if (!canMultiply(matrix1, matrix2)) {
            return Optional.empty();
        }

        final int size = matrix1[0].length;

        final int matrix1RowSize = matrix1.length;
        final int matrix2ColumnSize = matrix2[0].length;

        final BigDecimal[][] result = new BigDecimal[matrix1RowSize][matrix2ColumnSize];

        IntStream.range(0, matrix1RowSize).forEach(rowIndex
                -> IntStream.range(0, matrix2ColumnSize).forEach(columnIndex
                        -> result[rowIndex][columnIndex] = IntStream.range(0, size).mapToObj(index -> {
                    final BigDecimal value1 = matrix1[rowIndex][index];
                    final BigDecimal value2 = matrix2[index][columnIndex];

                    return value1.multiply(value2);
                })
                        .reduce(BigDecimal.ZERO, BigDecimal::add)
                )
        );

        return Optional.of(result);
    }

    public static void assertThat(final BigDecimal[][] actual, final BigDecimal[][] expected) {
        if (!Objects.deepEquals(actual, expected)) {
            throw new AssertionError(String.format(
                    "expected=%s but was actual=%s",
                    Arrays.deepToString(expected),
                    Arrays.deepToString(actual)
            ));
        }
    }

    public static void main(final String[] args) {
        {
            final BigDecimal[][] matrix1 = {
                {new BigDecimal(3), new BigDecimal(2)},
                {new BigDecimal(0), new BigDecimal(1)},};

            final BigDecimal[][] matrix2 = {
                {new BigDecimal(1), new BigDecimal(3)},
                {new BigDecimal(2), new BigDecimal(0)},};

            final BigDecimal[][] actual = add(matrix1, matrix2)
                    .orElseThrow(() -> new AssertionError("Could not compute matrix!"));

            final BigDecimal[][] expected = {
                {new BigDecimal(4), new BigDecimal(5)},
                {new BigDecimal(2), new BigDecimal(1)}
            };

            assertThat(actual, expected);
        }

        {
            final BigDecimal[][] matrix1 = {
                {new BigDecimal(1), new BigDecimal(4)},
                {new BigDecimal(5), new BigDecimal(6)},};

            final BigDecimal[][] matrix2 = {
                {new BigDecimal(2), new BigDecimal(0)},
                {new BigDecimal(-2), new BigDecimal(-3)},};

            final BigDecimal[][] actual = subtract(matrix1, matrix2)
                    .orElseThrow(() -> new AssertionError("Could not compute matrix!"));

            final BigDecimal[][] expected = {
                {new BigDecimal(-1), new BigDecimal(4)},
                {new BigDecimal(7), new BigDecimal(9)}
            };

            assertThat(actual, expected);
        }

        {
            final BigDecimal[][] matrix1 = {
                {new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)},
                {new BigDecimal(4), new BigDecimal(5), new BigDecimal(6)},
                {new BigDecimal(7), new BigDecimal(8), new BigDecimal(9)}
            };

            final BigDecimal[][] matrix2 = {
                {new BigDecimal(1), new BigDecimal(2)},
                {new BigDecimal(3), new BigDecimal(4)},
                {new BigDecimal(5), new BigDecimal(6)}
            };

            final BigDecimal[][] actual = multiply(matrix1, matrix2)
                    .orElseThrow(() -> new AssertionError("Could not compute matrix!"));

            final BigDecimal[][] expected = {
                {new BigDecimal(22), new BigDecimal(28)},
                {new BigDecimal(49), new BigDecimal(64)},
                {new BigDecimal(76), new BigDecimal(100)}
            };

            assertThat(actual, expected);
        }
    }
}
package com.thealgorithms.maths;

/**
 * Find the area of various geometric shapes
 */
public class Area {

    public static void main(String[] args) {

        /* test cube */
        assert Double.compare(surfaceAreaCube(1), 6.0) == 0;

        /* test sphere */
        assert Double.compare(surfaceAreaSphere(5), 314.1592653589793) == 0;
        assert Double.compare(surfaceAreaSphere(1), 12.566370614359172) == 0;

        /* test rectangle */
        assert Double.compare(surfaceAreaRectangle(10, 20), 200.0) == 0;

        /* test square */
        assert Double.compare(surfaceAreaSquare(10), 100.0) == 0;

        /* test triangle */
        assert Double.compare(surfaceAreaTriangle(10, 10), 50.0) == 0;

        /* test parallelogram */
        assert Double.compare(surfaceAreaParallelogram(10, 20), 200.0) == 0;

        /* test trapezium */
        assert Double.compare(surfaceAreaTrapezium(10, 20, 30), 450.0) == 0;

        /* test circle */
        assert Double.compare(surfaceAreaCircle(20), 1256.6370614359173) == 0;

        /* test cylinder */
        assert Double.compare(surfaceAreaCylinder(1, 2), 18.84955592153876) == 0;

        /* test hemisphere */
        assert Double.compare(surfaceAreaHemisphere(5), 235.61944901923448) == 0;
        assert Double.compare(surfaceAreaHemisphere(1), 9.42477796076938) == 0;

        /* test cone */
        assert Double.compare(surfaceAreaCone(6, 8), 301.59289474462014) == 0;
        assert Double.compare(surfaceAreaCone(10, 24), 1130.9733552923256) == 0;

    }

    /**
     * Calculate the surface area of a cube.
     *
     * @param sideLength side length of cube
     * @return surface area of given cube
     */
    private static double surfaceAreaCube(double sideLength) {
        return 6 * sideLength * sideLength;
    }

    /**
     * Calculate the surface area of a sphere.
     *
     * @param radius radius of sphere
     * @return surface area of given sphere
     */
    private static double surfaceAreaSphere(double radius) {
        return 4 * Math.PI * radius * radius;
    }

    /**
     * Calculate the area of a rectangle
     *
     * @param length length of rectangle
     * @param width width of rectangle
     * @return area of given rectangle
     */
    private static double surfaceAreaRectangle(double length, double width) {
        return length * width;
    }

    /**
     * Calculate surface area of a cylinder
     *
     * @param radius radius of the floor
     * @param height height of the cylinder.
     * @return volume of given cylinder
     */
    private static double surfaceAreaCylinder(double radius, double height) {
        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);
    }

    /**
     * Calculate the area of a square
     *
     * @param sideLength side length of square
     * @return area of given square
     */
    private static double surfaceAreaSquare(double sideLength) {
        return sideLength * sideLength;
    }

    /**
     * Calculate the area of a triangle
     *
     * @param base base of triangle
     * @param height height of triangle
     * @return area of given triangle
     */
    private static double surfaceAreaTriangle(double base, double height) {
        return base * height / 2;
    }

    /**
     * Calculate the area of a parallelogram
     *
     * @param base base of parallelogram
     * @param height height of parallelogram
     * @return area of given parallelogram
     */
    private static double surfaceAreaParallelogram(double base, double height) {
        return base * height;
    }

    /**
     * Calculate the area of a trapezium
     *
     * @param base1 upper base of trapezium
     * @param base2 bottom base of trapezium
     * @param height height of trapezium
     * @return area of given trapezium
     */
    private static double surfaceAreaTrapezium(double base1, double base2, double height) {
        return (base1 + base2) * height / 2;
    }

    /**
     * Calculate the area of a circle
     *
     * @param radius radius of circle
     * @return area of given circle
     */
    private static double surfaceAreaCircle(double radius) {
        return Math.PI * radius * radius;
    }

    /**
     * Calculate the surface area of a hemisphere.
     *
     * @param radius radius of hemisphere
     * @return surface area of given hemisphere
     */
    private static double surfaceAreaHemisphere(double radius) {
        return 3 * Math.PI * radius * radius;
    }

    /**
     * Calculate the surface area of a cone.
     *
     * @param radius radius of cone.
     * @param height of cone.
     * @return surface area of given cone.
     */
    private static double surfaceAreaCone(double radius, double height) {
        return Math.PI * radius * (radius + Math.pow((height * height + radius * radius), 0.5));
    }
}
package com.thealgorithms.maths;

import java.util.TreeMap;

public class SimpsonIntegration {

    /*
     * Calculate definite integrals by using Composite Simpson's rule.
     * Wiki: https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson's_rule
     * Given f a function and an even number N of intervals that divide the integration interval e.g. [a, b],
     * we calculate the step h = (b-a)/N and create a table that contains all the x points of
     * the real axis xi = x0 + i*h and the value f(xi) that corresponds to these xi.
     *
     * To evaluate the integral i use the formula below:
     * I = h/3 * {f(x0) + 4*f(x1) + 2*f(x2) + 4*f(x3) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)}
     *
     */
    public static void main(String[] args) {
        SimpsonIntegration integration = new SimpsonIntegration();

        // Give random data for the example purposes
        int N = 16;
        double a = 1;
        double b = 3;

        // Check so that N is even
        if (N % 2 != 0) {
            System.out.println("N must be even number for Simpsons method. Aborted");
            System.exit(1);
        }

        // Calculate step h and evaluate the integral
        double h = (b - a) / (double) N;
        double integralEvaluation = integration.simpsonsMethod(N, h, a);
        System.out.println("The integral is equal to: " + integralEvaluation);
    }

    /*
     * @param N: Number of intervals (must be even number N=2*k)
     * @param h: Step h = (b-a)/N
     * @param a: Starting point of the interval
     * @param b: Ending point of the interval
     *
     * The interpolation points xi = x0 + i*h are stored the treeMap data
     *
     * @return result of the integral evaluation
     */
    public double simpsonsMethod(int N, double h, double a) {
        TreeMap<Integer, Double> data = new TreeMap<>(); // Key: i, Value: f(xi)
        double temp;
        double xi = a; // Initialize the variable xi = x0 + 0*h

        // Create the table of xi and yi points
        for (int i = 0; i <= N; i++) {
            temp = f(xi); // Get the value of the function at that point
            data.put(i, temp);
            xi += h; // Increase the xi to the next point
        }

        // Apply the formula
        double integralEvaluation = 0;
        for (int i = 0; i < data.size(); i++) {
            if (i == 0 || i == data.size() - 1) {
                integralEvaluation += data.get(i);
                System.out.println("Multiply f(x" + i + ") by 1");
            } else if (i % 2 == 1) {
                integralEvaluation += (double) 4 * data.get(i);
                System.out.println("Multiply f(x" + i + ") by 4");
            } else {
                integralEvaluation += (double) 2 * data.get(i);
                System.out.println("Multiply f(x" + i + ") by 2");
            }
        }

        // Multiply by h/3
        integralEvaluation = h / 3 * integralEvaluation;

        // Return the result
        return integralEvaluation;
    }

    // Sample function f
    // Function f(x) = e^(-x) * (4 - x^2)
    public double f(double x) {
        return Math.exp(-x) * (4 - Math.pow(x, 2));
//        return Math.sqrt(x);
    }

}
package com.thealgorithms.maths;

public class FactorialRecursion {

    /* Driver Code */
    public static void main(String[] args) {
        assert factorial(0) == 1;
        assert factorial(1) == 1;
        assert factorial(2) == 2;
        assert factorial(3) == 6;
        assert factorial(5) == 120;
    }

    /**
     * Recursive FactorialRecursion Method
     *
     * @param n The number to factorial
     * @return The factorial of the number
     */
    public static long factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("number is negative");
        }
        return n == 0 || n == 1 ? 1 : n * factorial(n - 1);
    }
}
package com.thealgorithms.maths;
import java.math.BigInteger;
import java.util.*;

public class KaprekarNumbers {

	/* This program demonstrates if a given number is Kaprekar Number or not.
	Kaprekar Number: A Kaprekar number is an n-digit number which its square can be split into two parts where the right part has n
	digits and sum of these parts is equal to the original number. */

	// Provides a list of kaprekarNumber in a range
	public static ArrayList<Long> kaprekarNumberInRange(long start, long end) throws Exception {
		long n = end-start;
		if (n <0) throw new Exception("Invalid range");
		ArrayList<Long> list = new ArrayList<>();

		for (long i = start; i <= end; i++) {
			if (isKaprekarNumber(i)) list.add(i);
		}

		return list;
	}

	// Checks whether a given number is Kaprekar Number or not
	public static boolean isKaprekarNumber(long num) {
		String number = Long.toString(num);
		BigInteger originalNumber = new BigInteger(number);
		BigInteger numberSquared = originalNumber.multiply(originalNumber);
		if(number.length() == numberSquared.toString().length()){
			return number.equals(numberSquared.toString());
		}
		else{
			BigInteger leftDigits1 = new BigInteger("0");
			BigInteger leftDigits2;
			if(numberSquared.toString().contains("0")){
				leftDigits1 = new BigInteger(
						numberSquared.toString().
								substring(0, numberSquared.toString().indexOf("0")
								)
				);
			}
			leftDigits2 = new BigInteger(
					numberSquared.toString()
							.substring(0, (numberSquared.toString().length() - number.length()))
			);
			BigInteger rightDigits = new BigInteger(numberSquared.toString().substring(numberSquared.toString().length() - number.length()));
			String x = leftDigits1.add(rightDigits).toString();
			String y = leftDigits2.add(rightDigits).toString();
			return (number.equals(x)) || (number.equals(y));
		}		
	}

}
package com.thealgorithms.maths;

/**
 * In mathematics, an arithmetic progression (AP) or arithmetic sequence is a
 * sequence of numbers such that the difference between the consecutive terms is
 * constant. Difference here means the second minus the first. For instance, the
 * sequence 5, 7, 9, 11, 13, 15, . . . is an arithmetic progression with common
 * difference of 2.
 *
 * <p>
 * Wikipedia: https://en.wikipedia.org/wiki/Arithmetic_progression
 */
public class SumOfArithmeticSeries {

    public static void main(String[] args) {

        /* 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 */
        assert Double.compare(55.0, sumOfSeries(1, 1, 10)) == 0;

        /* 1 + 3 + 5 + 7 + 9 + 11 + 13 + 15 + 17 + 19 */
        assert Double.compare(100.0, sumOfSeries(1, 2, 10)) == 0;

        /* 1 + 11 + 21 + 31 + 41 + 51 + 61 + 71 + 81 + 91 */
        assert Double.compare(460.0, sumOfSeries(1, 10, 10)) == 0;

        /* 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 0.6 + 0.7 + 0.8 + 0.9 + 1.0 */
        assert Double.compare(5.5, sumOfSeries(0.1, 0.1, 10)) == 0;

        assert Double.compare(49600.0, sumOfSeries(1, 10, 100)) == 0;
    }

    /**
     * Calculate sum of arithmetic series
     *
     * @param firstTerm the initial term of an arithmetic series
     * @param commonDiff the common difference of an arithmetic series
     * @param numOfTerms the total terms of an arithmetic series
     * @return sum of given arithmetic series
     */
    private static double sumOfSeries(double firstTerm, double commonDiff, int numOfTerms) {
        return numOfTerms / 2.0 * (2 * firstTerm + (numOfTerms - 1) * commonDiff);
    }
}
package com.thealgorithms.maths;

import java.util.*;

/*A magic square of order n is an arrangement of distinct n^2 integers,in a square, such that the n numbers in all
rows, all columns, and both diagonals sum to the same constant. A magic square contains the integers from 1 to n^2.*/
public class MagicSquare {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        System.out.print("Input a number: ");
        int num = sc.nextInt();
        if ((num % 2 == 0) || (num <= 0)) {
            System.out.print("Input number must be odd and >0");
            System.exit(0);
        }

        int[][] magic_square = new int[num][num];

        int row_num = num / 2;
        int col_num = num - 1;
        magic_square[row_num][col_num] = 1;

        for (int i = 2; i <= num * num; i++) {
            if (magic_square[(row_num - 1 + num) % num][(col_num + 1) % num] == 0) {
                row_num = (row_num - 1 + num) % num;
                col_num = (col_num + 1) % num;
            } else {
                col_num = (col_num - 1 + num) % num;
            }
            magic_square[row_num][col_num] = i;
        }

        // print the square
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                if (magic_square[i][j] < 10) {
                    System.out.print(" ");
                }
                if (magic_square[i][j] < 100) {
                    System.out.print(" ");
                }
                System.out.print(magic_square[i][j] + " ");
            }
            System.out.println();
        }

    }
}
package com.thealgorithms.maths;

public class Factorial {

    /* Driver Code */
    public static void main(String[] args) {
        assert factorial(0) == 1;
        assert factorial(1) == 1;
        assert factorial(5) == 120;
        assert factorial(10) == 3628800;
    }

    /**
     * Calculate factorial N using iteration
     *
     * @param n the number
     * @return the factorial of {@code n}
     */
    public static long factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("number is negative");
        }
        long factorial = 1;
        for (int i = 1; i <= n; factorial *= i, ++i)
      ;
        return factorial;
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;


public class SquareRootWithBabylonianMethod {
    /**
     * get the value, return the square root
     *
     * @param num contains elements
     * @return the square root of num
     */
    public static float square_Root(float num)
    {
        float a = num;
        float b = 1;
        double e = 0.000001;
        while (a - b > e) {
            a = (a + b) / 2;
            b = num / a;
        }
        return a;
    }

}
package com.thealgorithms.maths;

import java.util.ArrayList;
import java.util.function.BiFunction;

/**
 * In mathematics and computational science, the Euler method (also called
 * forward Euler method) is a first-order numerical procedure for solving
 * ordinary differential equations (ODEs) with a given initial value. It is the
 * most basic explicit method for numerical integration of ordinary differential
 * equations. The method proceeds in a series of steps. At each step the y-value
 * is calculated by evaluating the differential equation at the previous step,
 * multiplying the result with the step-size and adding it to the last y-value:
 * y_n+1 = y_n + stepSize * f(x_n, y_n). (description adapted from
 * https://en.wikipedia.org/wiki/Euler_method ) (see also:
 * https://www.geeksforgeeks.org/euler-method-solving-differential-equation/ )
 */
public class EulerMethod {

    /**
     * Illustrates how the algorithm is used in 3 examples and prints the
     * results to the console.
     */
    public static void main(String[] args) {
        System.out.println("example 1:");
        BiFunction<Double, Double, Double> exampleEquation1 = (x, y) -> x;
        ArrayList<double[]> points1 = eulerFull(0, 4, 0.1, 0, exampleEquation1);
        assert points1.get(points1.size() - 1)[1] == 7.800000000000003;
        points1.forEach(
                point -> System.out.println(String.format("x: %1$f; y: %2$f", point[0], point[1])));

        // example from https://en.wikipedia.org/wiki/Euler_method
        System.out.println("\n\nexample 2:");
        BiFunction<Double, Double, Double> exampleEquation2 = (x, y) -> y;
        ArrayList<double[]> points2 = eulerFull(0, 4, 0.1, 1, exampleEquation2);
        assert points2.get(points2.size() - 1)[1] == 45.25925556817596;
        points2.forEach(
                point -> System.out.println(String.format("x: %1$f; y: %2$f", point[0], point[1])));

        // example from https://www.geeksforgeeks.org/euler-method-solving-differential-equation/
        System.out.println("\n\nexample 3:");
        BiFunction<Double, Double, Double> exampleEquation3 = (x, y) -> x + y + x * y;
        ArrayList<double[]> points3 = eulerFull(0, 0.1, 0.025, 1, exampleEquation3);
        assert points3.get(points3.size() - 1)[1] == 1.1116729841674804;
        points3.forEach(
                point -> System.out.println(String.format("x: %1$f; y: %2$f", point[0], point[1])));
    }

    /**
     * calculates the next y-value based on the current value of x, y and the
     * stepSize the console.
     *
     * @param xCurrent Current x-value.
     * @param stepSize Step-size on the x-axis.
     * @param yCurrent Current y-value.
     * @param differentialEquation The differential equation to be solved.
     * @return The next y-value.
     */
    public static double eulerStep(
            double xCurrent,
            double stepSize,
            double yCurrent,
            BiFunction<Double, Double, Double> differentialEquation) {
        if (stepSize <= 0) {
            throw new IllegalArgumentException("stepSize should be greater than zero");
        }
        double yNext = yCurrent + stepSize * differentialEquation.apply(xCurrent, yCurrent);
        return yNext;
    }

    /**
     * Loops through all the steps until xEnd is reached, adds a point for each
     * step and then returns all the points
     *
     * @param xStart First x-value.
     * @param xEnd Last x-value.
     * @param stepSize Step-size on the x-axis.
     * @param yStart First y-value.
     * @param differentialEquation The differential equation to be solved.
     * @return The points constituting the solution of the differential
     * equation.
     */
    public static ArrayList<double[]> eulerFull(
            double xStart,
            double xEnd,
            double stepSize,
            double yStart,
            BiFunction<Double, Double, Double> differentialEquation) {
        if (xStart >= xEnd) {
            throw new IllegalArgumentException("xEnd should be greater than xStart");
        }
        if (stepSize <= 0) {
            throw new IllegalArgumentException("stepSize should be greater than zero");
        }

        ArrayList<double[]> points = new ArrayList<double[]>();
        double[] firstPoint = {xStart, yStart};
        points.add(firstPoint);
        double yCurrent = yStart;
        double xCurrent = xStart;

        while (xCurrent < xEnd) {
            // Euler method for next step
            yCurrent = eulerStep(xCurrent, stepSize, yCurrent, differentialEquation);
            xCurrent += stepSize;
            double[] point = {xCurrent, yCurrent};
            points.add(point);
        }

        return points;
    }
}
package com.thealgorithms.maths;

/**
 * @file
 *
 * @brief Calculates the [Cross
 * Product](https://en.wikipedia.org/wiki/Cross_product) and the magnitude of
 * two mathematical 3D vectors.
 *
 *
 * @details Cross Product of two vectors gives a vector. Direction Ratios of a
 * vector are the numeric parts of the given vector. They are the tree parts of
 * the vector which determine the magnitude (value) of the vector. The method of
 * finding a cross product is the same as finding the determinant of an order 3
 * matrix consisting of the first row with unit vectors of magnitude 1, the
 * second row with the direction ratios of the first vector and the third row
 * with the direction ratios of the second vector. The magnitude of a vector is
 * it's value expressed as a number. Let the direction ratios of the first
 * vector, P be: a, b, c Let the direction ratios of the second vector, Q be: x,
 * y, z Therefore the calculation for the cross product can be arranged as:
 *
 * ``` P x Q: 1	1	1 a	b	c x	y	z ```
 *
 * The direction ratios (DR) are calculated as follows: 1st DR, J: (b * z) - (c
 * * y) 2nd DR, A: -((a * z) - (c * x)) 3rd DR, N: (a * y) - (b * x)
 *
 * Therefore, the direction ratios of the cross product are: J, A, N The
 * following Java Program calculates the direction ratios of the cross products
 * of two vector. The program uses a function, cross() for doing so. The
 * direction ratios for the first and the second vector has to be passed one by
 * one separated by a space character.
 *
 * Magnitude of a vector is the square root of the sum of the squares of the
 * direction ratios.
 *
 *
 * For maintaining filename consistency, Vector class has been termed as
 * VectorCrossProduct
 *
 * @author [Syed](https://github.com/roeticvampire)
 */
public class VectorCrossProduct {

    int x;
    int y;
    int z;

    //Default constructor, initialises all three Direction Ratios to 0
    VectorCrossProduct() {
        x = 0;
        y = 0;
        z = 0;
    }

    /**
     * constructor, initialises Vector with given Direction Ratios
     *
     * @param _x set to x
     * @param _y set to y
     * @param _z set to z
     */
    VectorCrossProduct(int _x, int _y, int _z) {
        x = _x;
        y = _y;
        z = _z;
    }

    /**
     * Returns the magnitude of the vector
     *
     * @return double
     */
    double magnitude() {
        return Math.sqrt(x * x + y * y + z * z);
    }

    /**
     * Returns the dot product of the current vector with a given vector
     *
     * @param b: the second vector
     * @return int: the dot product
     */
    int dotProduct(VectorCrossProduct b) {
        return x * b.x + y * b.y + z * b.z;
    }

    /**
     * Returns the cross product of the current vector with a given vector
     *
     * @param b: the second vector
     * @return vectorCrossProduct: the cross product
     */
    VectorCrossProduct crossProduct(VectorCrossProduct b) {
        VectorCrossProduct product = new VectorCrossProduct();
        product.x = (y * b.z) - (z * b.y);
        product.y = -((x * b.z) - (z * b.x));
        product.z = (x * b.y) - (y * b.x);
        return product;
    }

    /**
     * Display the Vector
     */
    void displayVector() {
        System.out.println("x : " + x + "\ty : " + y + "\tz : " + z);
    }

    public static void main(String[] args) {
        test();
    }

    static void test() {
        //Create two vectors
        VectorCrossProduct A = new VectorCrossProduct(1, -2, 3);
        VectorCrossProduct B = new VectorCrossProduct(2, 0, 3);

        //Determine cross product
        VectorCrossProduct crossProd = A.crossProduct(B);
        crossProd.displayVector();

        //Determine dot product
        int dotProd = A.dotProduct(B);
        System.out.println("Dot Product of A and B: " + dotProd);

    }

}
package com.thealgorithms.maths;

import java.util.Arrays;
import java.util.Random;

public class FindMinRecursion {

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        Random rand = new Random();

        /* rand size */
        int size = rand.nextInt(100) + 1;
        int[] array = new int[size];

        /* init array with rand numbers */
        for (int i = 0; i < size; i++) {
            array[i] = rand.nextInt() % 100;
        }

        assert min(array, 0, array.length - 1) == Arrays.stream(array).min().getAsInt();
        assert min(array, array.length) == Arrays.stream(array).min().getAsInt();
    }

    /**
     * Get min of array using divide and conquer algorithm
     *
     * @param array contains elements
     * @param low the index of the first element
     * @param high the index of the last element
     * @return min of {@code array}
     */
    public static int min(int[] array, int low, int high) {
        if (low == high) {
            return array[low]; // or array[high]
        }

        int mid = (low + high) >>> 1;

        int leftMin = min(array, low, mid); // get min in [low, mid]
        int rightMin = min(array, mid + 1, high); // get min in [mid+1, high]

        return Math.min(leftMin, rightMin);
    }

    /**
     * Get min of array using recursion algorithm
     *
     * @param array contains elements
     * @param len length of given array
     * @return min value of {@code array}
     */
    public static int min(int[] array, int len) {
        return len == 1 ? array[0] : Math.min(min(array, len - 1), array[len - 1]);
    }
}
package com.thealgorithms.maths;

/**
 * A number is said to be an Automorphic, if it is present in the last digit(s)
 * of its square. Example- Let the number be 25, its square is 625. Since,
 * 25(The input number) is present in the last two digits of its square(625), it
 * is an Automorphic Number.
 */
import java.io.*;

public class AutomorphicNumber {

    //returns True if the number is a Automorphic number and False if it is not an Automorphic number
    public static boolean isAutomorphic(int n) {
        int m, c, r, p, k;
        c = 0;
        /**
         * m = Temporary variable to store a copy of the number entered by the
         * user. n = The number entered by the user c = Count the digits of the
         * number entered by user. p = To calculate the square of the number. k
         * = Support variable to count the digits of the number
         */
        double s;
        m = n;
        p = m * m; //Calculating square of the number
        do {
            k = n / 10;
            c = c + 1; //Counting the digits of the number entered by user.
            n = k;
        } while (n != 0);
        s = Math.pow(10, c);
        r = p % (int) s;
        if (m == r) //Checking if the original number entered is present at the end of the square
        {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Method to check if number is Automorphic Number or Not 1) Input - Enter a
     * Number: 25 Output - It is an Automorphic Number. 2) Input - Enter a
     * Number: 7 Output - It is not an Automorphic Number.
     */
    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter a Number: ");
        int n = Integer.parseInt(br.readLine());
        if (isAutomorphic(n)) {
            System.out.println("It is an Automorphic Number.");
        } else {
            System.out.println("It is not an Automorphic Number.");
        }
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;
import java.util.Random;

public class FindMax {

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        Random random = new Random();

        /* random size */
        int size = random.nextInt(100) + 1;
        int[] array = new int[size];

        /* init array with random numbers */
        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt() % 100;
        }

        assert Arrays.stream(array).max().getAsInt() == findMax(array);
    }

    /**
     * find max of array
     *
     * @param array the array contains element
     * @return max value of given array
     */
    public static int findMax(int[] array) {
        int max = array[0];
        for (int i = 1; i < array.length; ++i) {
            if (array[i] > max) {
                max = array[i];
            }
        }
        return max;
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;

public class AbsoluteMax {

    /**
     * Compares the numbers given as arguments to get the absolute max value.
     *
     * @param numbers The numbers to compare
     * @return The absolute max value
     */
    public static int getMaxValue(int... numbers) {
        if (numbers.length == 0) {
            throw new IllegalArgumentException("Numbers array cannot be empty");
        }

        var absMaxWrapper = new Object() {
            int value = numbers[0];
        };

        Arrays.stream(numbers)
                .skip(1)
                .filter(number -> Math.abs(number) > Math.abs(absMaxWrapper.value))
                .forEach(number -> absMaxWrapper.value = number);

        return absMaxWrapper.value;
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;

public class PrimeCheck {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter a number: ");
        int n = scanner.nextInt();
        if (isPrime(n)) {
            System.out.println("algo1 verify that " + n + " is a prime number");
        } else {
            System.out.println("algo1 verify that " + n + " is not a prime number");
        }

        if (fermatPrimeChecking(n, 20)) {
            System.out.println("algo2 verify that " + n + " is a prime number");
        } else {
            System.out.println("algo2 verify that " + n + " is not a prime number");
        }
        scanner.close();
    }

    /**
     * *
     * Checks if a number is prime or not
     *
     * @param n the number
     * @return {@code true} if {@code n} is prime
     */
    public static boolean isPrime(int n) {
        if (n == 2) {
            return true;
        }
        if (n < 2 || n % 2 == 0) {
            return false;
        }
        for (int i = 3, limit = (int) Math.sqrt(n); i <= limit; i += 2) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }

    /**
     * *
     * Checks if a number is prime or not
     *
     * @param n the number
     * @return {@code true} if {@code n} is prime
     */
    public static boolean fermatPrimeChecking(int n, int iteration){
      long a;
      int up = n - 2, down = 2;
      for(int i=0;i<iteration;i++){
        a = (long)Math.floor(Math.random()*(up - down + 1) + down);
        if(modPow(a,n-1,n) != 1){
          return false;
        }
      }
      return true;
    }


    /**
     * *
     * @param a basis
     * @param b exponent
     * @param c modulo
     * @return (a^b) mod c
     */
    private static long modPow(long a, long b, long c){
        long res = 1;
        for (int i = 0; i < b; i++)
        {
            res *= a;
            res %= c;
        }
        return res % c;
    }
}
package com.thealgorithms.maths;

/**
 * Translates numbers into the Roman Numeral System.
 *
 * @see <a href="https://en.wikipedia.org/wiki/Roman_numerals">Roman
 * numerals</a>
 * @author Sokratis Fotkatzikis
 * @version 1.0
 */
public class RomanNumeralUtil {

    private static final int MIN_VALUE = 1;
    private static final int MAX_VALUE = 5999;
    //1000-5999
    private static final String[] RN_M = {"", "M", "MM", "MMM", "MMMM", "MMMMM"};
    //100-900
    private static final String[] RN_C = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
    //10-90
    private static final String[] RN_X = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
    //1-9
    private static final String[] RN_I = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};

    public static String generate(int number) {
        if (number < MIN_VALUE || number > MAX_VALUE) {
            throw new IllegalArgumentException(
                    String.format(
                            "The number must be in the range [%d, %d]",
                            MIN_VALUE,
                            MAX_VALUE
                    )
            );
        }

        return RN_M[number / 1000]
                + RN_C[number % 1000 / 100]
                + RN_X[number % 100 / 10]
                + RN_I[number % 10];
    }
}
package com.thealgorithms.maths;

/*
 * Algorithm explanation: https://technotip.com/6774/c-program-to-find-generic-root-of-a-number/#:~:text=Generic%20Root%3A%20of%20a%20number,get%20a%20single%2Ddigit%20output.&text=For%20Example%3A%20If%20user%20input,%2B%204%20%2B%205%20%3D%2015.
 */
public class GenericRoot {

    public static void main(String[] args) {
        int number1 = 1234;
        int number2 = 12345;
        int result1 = genericRoot(number1);
        int result2 = genericRoot(number2);
        System.out.println("Generic root of " + number1 + " is: " + result1);
        System.out.println("Generic root of " + number2 + " is: " + result2);
    }

    private static int genericRoot(int n) {
        int root = 0;
        while (n > 0 || root > 9) {
            if (n == 0) {
                n = root;
                root = 0;
            }
            root += n % 10;
            n /= 10;
        }
        return root;
    }
}
package com.thealgorithms.maths;

import java.util.Random;

public class Floor {

    public static void main(String[] args) {
        Random random = new Random();
        for (int i = 1; i <= 1000; ++i) {
            double randomNumber = random.nextDouble();
            assert floor(randomNumber) == Math.floor(randomNumber);
        }
    }

    /**
     * Returns the largest (closest to positive infinity)
     *
     * @param number the number
     * @return the largest (closest to positive infinity) of given
     * {@code number}
     */
    public static double floor(double number) {
        if (number - (int) number == 0) {
            return number;
        } else if (number - (int) number > 0) {
            return (int) number;
        } else {
            return (int) number - 1;
        }
    }
}
package com.thealgorithms.maths;

import java.util.Objects;

public final class LinearDiophantineEquationsSolver {

    public static void main(String[] args) {
        // 3x + 4y = 7
        final var toSolve = new Equation(3, 4, 7);
        System.out.println(findAnySolution(toSolve));
    }

    public static Solution findAnySolution(final Equation equation) {
        if (equation.a() == 0 && equation.b() == 0 && equation.c() == 0) {
            return Solution.INFINITE_SOLUTIONS;
        }
        final var stub = new GcdSolutionWrapper(0, new Solution(0, 0));
        final var gcdSolution = gcd(equation.a(), equation.b(), stub);
        if (equation.c() % gcdSolution.getGcd() != 0) {
            return Solution.NO_SOLUTION;
        }
        final var toReturn = new Solution(0, 0);
        var xToSet = stub.getSolution().getX() * (equation.c() / stub.getGcd());
        var yToSet = stub.getSolution().getY() * (equation.c() / stub.getGcd());
        toReturn.setX(xToSet);
        toReturn.setY(yToSet);
        return toReturn;
    }

    private static GcdSolutionWrapper gcd(final int a, final int b, final GcdSolutionWrapper previous) {
        if (b == 0) {
            return new GcdSolutionWrapper(a, new Solution(1, 0));
        }
        // stub wrapper becomes the `previous` of the next recursive call
        final var stubWrapper = new GcdSolutionWrapper(0, new Solution(0, 0));
        final var next = /* recursive call */ gcd(b, a % b, stubWrapper);
        previous.getSolution().setX(next.getSolution().getY());
        previous.getSolution().setY(next.getSolution().getX() - (a / b) * (next.getSolution().getY()));
        previous.setGcd(next.getGcd());
        return new GcdSolutionWrapper(next.getGcd(), previous.getSolution());
    }

    public static final class Solution {

        public static final Solution NO_SOLUTION = new Solution(Integer.MAX_VALUE, Integer.MAX_VALUE);
        public static final Solution INFINITE_SOLUTIONS = new Solution(Integer.MIN_VALUE, Integer.MIN_VALUE);
        private int x;
        private int y;

        public Solution(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public int getX() {
            return x;
        }

        public int getY() {
            return y;
        }

        public void setX(int x) {
            this.x = x;
        }

        public void setY(int y) {
            this.y = y;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (obj == null || obj.getClass() != this.getClass()) {
                return false;
            }
            var that = (Solution) obj;
            return this.x == that.x
                    && this.y == that.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }

        @Override
        public String toString() {
            return "Solution["
                    + "x=" + x + ", "
                    + "y=" + y + ']';
        }

    }

    public record Equation(int a, int b, int c) {

    }

    public static final class GcdSolutionWrapper {

        private int gcd;
        private Solution solution;

        public GcdSolutionWrapper(int gcd, Solution solution) {
            this.gcd = gcd;
            this.solution = solution;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (obj == null || obj.getClass() != this.getClass()) {
                return false;
            }
            var that = (GcdSolutionWrapper) obj;
            return this.gcd == that.gcd
                    && Objects.equals(this.solution, that.solution);
        }

        public int getGcd() {
            return gcd;
        }

        public void setGcd(int gcd) {
            this.gcd = gcd;
        }

        public Solution getSolution() {
            return solution;
        }

        public void setSolution(Solution solution) {
            this.solution = solution;
        }

        @Override
        public int hashCode() {
            return Objects.hash(gcd, solution);
        }

        @Override
        public String toString() {
            return "GcdSolutionWrapper["
                    + "gcd=" + gcd + ", "
                    + "solution=" + solution + ']';
        }

    }
}
package com.thealgorithms.maths;

import java.util.Arrays;

public class AbsoluteMin {

    /**
     * Compares the numbers given as arguments to get the absolute min value.
     *
     * @param numbers The numbers to compare
     * @return The absolute min value
     */
    public static int getMinValue(int... numbers) {
        if (numbers.length == 0) {
            throw new IllegalArgumentException("Numbers array cannot be empty");
        }

        var absMinWrapper = new Object() {
            int value = numbers[0];
        };

        Arrays.stream(numbers)
                .skip(1)
                .filter(number -> Math.abs(number) < Math.abs(absMinWrapper.value))
                .forEach(number -> absMinWrapper.value = number);

        return absMinWrapper.value;
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;

/**
 * Wikipedia: https://en.wikipedia.org/wiki/Median
 */
public class Median {

    public static void main(String[] args) {
        assert median(new int[]{0}) == 0;
        assert median(new int[]{1, 2}) == 1.5;
        assert median(new int[]{4, 1, 3, 2}) == 2.5;
        assert median(new int[]{1, 3, 3, 6, 7, 8, 9}) == 6;
        assert median(new int[]{1, 2, 3, 4, 5, 6, 8, 9}) == 4.5;
    }

    /**
     * Calculate average median
     *
     * @param values number series
     * @return median of given {@code values}
     */
    public static double median(int[] values) {
        Arrays.sort(values);
        int length = values.length;
        return length % 2 == 0
                ? (values[length / 2] + values[length / 2 - 1]) / 2.0
                : values[length / 2];
    }
}
package com.thealgorithms.maths;


/* Find volume of various shapes.*/
public class Volume {

    public static void main(String[] args) {

        /* test cube */
        assert Double.compare(volumeCube(7), 343.0) == 0;

        /* test cuboid */
        assert Double.compare(volumeCuboid(2, 5, 7), 70.0) == 0;

        /* test sphere */
        assert Double.compare(volumeSphere(5), 523.5987755982989) == 0;

        /* test cylinder */
        assert Double.compare(volumeCylinder(1, 2), 12.566370614359172) == 0;

        /* test hemisphere */
        assert Double.compare(volumeHemisphere(5), 261.79938779914943) == 0;

        /* test cone */
        assert Double.compare(volumeCone(5, 7), 916.297857297023) == 0;
        
        /*test prism*/
        assert Double.compare(volumePrism(10, 2), 20.0) == 0;
        
        /*test pyramid*/
        assert Double.compare(volumePyramid(10, 3), 10.0) == 0;

    }

    /**
     * Calculate the volume of a cube.
     *
     * @param sideLength side length of cube
     * @return volume of given cube
     */
    private static double volumeCube(double sidelength) {
        return sidelength * sidelength * sidelength;
    }

    /**
     * Calculate the volume of a cuboid.
     *
     * @param width of cuboid
     * @param height of cuboid
     * @param length of cuboid
     * @return volume of given cuboid
     */
    private static double volumeCuboid(double width, double height, double length) {
        return width * height * length;
    }

    /**
     * Calculate the volume of a sphere.
     *
     * @param radius radius of sphere
     * @return volume of given sphere
     */
    private static double volumeSphere(double radius) {
        return 4 / 3 * Math.PI * radius * radius * radius;
    }

    /**
     * Calculate volume of a cylinder
     *
     * @param radius radius of the floor
     * @param height height of the cylinder.
     * @return volume of given cylinder
     */
    private static double volumeCylinder(double radius, double height) {
        return Math.PI * radius * radius * height;
    }

    /**
     * Calculate the volume of a hemisphere.
     *
     * @param radius radius of hemisphere
     * @return volume of given hemisphere
     */
    private static double volumeHemisphere(double radius) {
        return 2 / 3 * Math.PI * radius * radius * radius;
    }

    /**
     * Calculate the volume of a cone.
     *
     * @param radius radius of cone.
     * @param height of cone.
     * @return volume of given cone.
     */
    private static double volumeCone(double radius, double height) {
        return Math.PI * radius * radius * height / 3;
    }
    
    /**
     * Calculate the volume of a prism.
     *
     * @param area of the base.
     * @param height of prism.
     * @return volume of given prism.
     */
    private static double volumePrism(double basearea, double height) {
        return basearea * height;
    }
    
    /**
     * Calculate the volume of a pyramid.
     *
     * @param area of the base.
     * @param height of pyramid.
     * @return volume of given pyramid.
     */
    private static double volumePyramid(double basearea, double height) {
        return basearea * height / 3;
    }
}
package com.thealgorithms.maths;

import java.util.*;

/* 
* @author Ojasva Jain
* Determinant of Matrix Wikipedia link : https://en.wikipedia.org/wiki/Determinant
 */
public class DeterminantOfMatrix {

    // Determinant calculator
    //@return determinant of the input matrix
    static int determinant(int a[][], int n) {
        int det = 0, sign = 1, p = 0, q = 0;
        if (n == 1) {
            det = a[0][0];
        } else {
            int b[][] = new int[n - 1][n - 1];
            for (int x = 0; x < n; x++) {
                p = 0;
                q = 0;
                for (int i = 1; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        if (j != x) {
                            b[p][q++] = a[i][j];
                            if (q % (n - 1) == 0) {
                                p++;
                                q = 0;
                            }
                        }
                    }
                }
                det = det + a[0][x] * determinant(b, n - 1) * sign;
                sign = -sign;
            }
        }
        return det;
    }

    //Driver Method
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        //Input Matrix
        System.out.println("Enter matrix size (Square matrix only)");
        int n = in.nextInt();
        System.out.println("Enter matrix");
        int a[][] = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = in.nextInt();
            }
        }
        System.out.println(determinant(a, n));
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;
import java.util.Random;

public class FindMin {

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        Random random = new Random();

        /* random size */
        int size = random.nextInt(100) + 1;
        int[] array = new int[size];

        /* init array with random numbers */
        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt() % 100;
        }

        assert Arrays.stream(array).min().getAsInt() == findMin(array);
    }

    /**
     * Find the minimum number of an array of numbers.
     *
     * @param array the array contains element
     * @return min value
     */
    public static int findMin(int[] array) {
        int min = array[0];
        for (int i = 1; i < array.length; ++i) {
            if (array[i] < min) {
                min = array[i];
            }
        }
        return min;
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;
import java.util.Random;

public class FindMaxRecursion {

    public static void main(String[] args) {
        Random rand = new Random();

        /* rand size */
        int size = rand.nextInt(100) + 1;
        int[] array = new int[size];

        /* init array with rand numbers */
        for (int i = 0; i < size; i++) {
            array[i] = rand.nextInt() % 100;
        }

        assert max(array, array.length) == Arrays.stream(array).max().getAsInt();
        assert max(array, 0, array.length - 1) == Arrays.stream(array).max().getAsInt();
    }

    /**
     * Get max of array using divide and conquer algorithm
     *
     * @param array contains elements
     * @param low the index of the first element
     * @param high the index of the last element
     * @return max of {@code array}
     */
    public static int max(int[] array, int low, int high) {
        if (low == high) {
            return array[low]; // or array[high]
        }

        int mid = (low + high) >>> 1;

        int leftMax = max(array, low, mid); // get max in [low, mid]
        int rightMax = max(array, mid + 1, high); // get max in [mid+1, high]

        return Math.max(leftMax, rightMax);
    }

    /**
     * Get max of array using recursion algorithm
     *
     * @param array contains elements
     * @param len length of given array
     * @return max value of {@code array}
     */
    public static int max(int[] array, int len) {
        return len == 1 ? array[0] : Math.max(max(array, len - 1), array[len - 1]);
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;
import java.util.List;

/*
 * Java program for printing juggler sequence 
 * Wikipedia: https://en.wikipedia.org/wiki/Juggler_sequence
 * 
 * Author: Akshay Dubey (https://github.com/itsAkshayDubey)
 * 
 * */

public class JugglerSequence {
    /**
     * This method prints juggler sequence starting with the number in the parameter
     *
     * @param inputNumber Number from which juggler sequence is to be started
     */
    public static void jugglerSequence(int inputNumber) {
        // Copy method argument to a local variable
        int n = inputNumber;
        List<String> seq = new ArrayList<>();
        seq.add(n + "");
        // Looping till n reaches 1
        while (n != 1) {
            int temp;
            // if previous term is even then
            // next term in the sequence is square root of previous term
            // if previous term is odd then
            // next term is floor value of 3 time the square root of previous term

            // Check if previous term is even or odd
            if (n % 2 == 0) {
                temp = (int) Math.floor(Math.sqrt(n));
            } else {
                temp = (int) Math.floor(Math.sqrt(n) * Math.sqrt(n) * Math.sqrt(n));
            }
            n = temp;
            seq.add(n + "");
        }
        String res = String.join(",", seq);
        System.out.println(res);
    }

    // Driver code
    public static void main(String[] args) {
        jugglerSequence(3);
        // Output: 3,5,11,36,6,2,1
    }
}
package com.thealgorithms.maths;

/**
 * https://en.wikipedia.org/wiki/Pythagorean_triple
 */
public class PythagoreanTriple {

    public static void main(String[] args) {
        assert isPythagTriple(3, 4, 5);
        assert isPythagTriple(5, 12, 13);
        assert isPythagTriple(6, 8, 10);
        assert !isPythagTriple(10, 20, 30);
        assert !isPythagTriple(6, 8, 100);
        assert !isPythagTriple(-1, -1, 1);
    }

    /**
     * Check if a,b,c are a Pythagorean Triple
     *
     * @param a x/y component length of a right triangle
     * @param b y/x component length of a right triangle
     * @param c hypotenuse length of a right triangle
     * @return boolean <tt>true</tt> if a, b, c satisfy the Pythagorean theorem,
     * otherwise
     * <tt>false</tt>
     */
    public static boolean isPythagTriple(int a, int b, int c) {
        if (a <= 0 || b <= 0 || c <= 0) {
            return false;
        } else {
            return (a * a) + (b * b) == (c * c);
        }
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;

/*
 * Find the 2 elements which are non repeating in an array
 * Reason to use bitwise operator: It makes our program faster as we are operating on bits and not on
 * actual numbers.  
 */
public class NonRepeatingElement {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int i, res = 0;
        System.out.println("Enter the number of elements in the array");
        int n = sc.nextInt();
        if ((n & 1) == 1) {
            //Not allowing odd number of elements as we are expecting 2 non repeating numbers
            System.out.println("Array should contain even number of elements");
            return;
        }
        int arr[] = new int[n];

        System.out.println("Enter " + n + " elements in the array. NOTE: Only 2 elements should not repeat");
        for (i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        try {
            sc.close();
        } catch (Exception e) {
            System.out.println("Unable to close scanner" + e);
        }

        //Find XOR of the 2 non repeating elements
        for (i = 0; i < n; i++) {
            res ^= arr[i];
        }

        //Finding the rightmost set bit
        res = res & (-res);
        int num1 = 0, num2 = 0;

        for (i = 0; i < n; i++) {
            if ((res & arr[i]) > 0)//Case 1 explained below
            {
                num1 ^= arr[i];
            } else {
                num2 ^= arr[i];//Case 2 explained below
            }
        }

        System.out.println("The two non repeating elements are " + num1 + " and " + num2);

    }

    /* 
  Explanation of the code:
  let us assume we have an array [1,2,1,2,3,4]
  Property of XOR: num ^ num = 0. 
  If we XOR all the elemnets of the array we will be left with 3 ^ 4 as 1 ^ 1 and 2 ^ 2 would give 0.
  Our task is to find num1 and num2 from the result of 3 ^ 4 = 7.
  We need to find two's complement of 7 and find the rightmost set bit. i.e. (num & (-num))
  Two's complement of 7 is 001 and hence res = 1.
  There can be 2 options when we Bitise AND this res with all the elements in our array
  1. Result will come non zero number
  2. Result will be 0.
  In the first case we will XOR our element with the first number (which is initially 0)
  In the second case we will XOR our element with the second number(which is initially 0)
  This is how we will get non repeating elements with the help of bitwise operators. 
     */
}
package com.thealgorithms.maths;

import java.util.stream.IntStream;

/**
 * In number theory, the aliquot sum s(n) of a positive integer n is the sum of
 * all proper divisors of n, that is, all divisors of n other than n itself. For
 * example, the proper divisors of 15 (that is, the positive divisors of 15 that
 * are not equal to 15) are 1, 3 and 5, so the aliquot sum of 15 is 9 i.e. (1 +
 * 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum
 */
public class AliquotSum {

    /**
     * Finds the aliquot sum of an integer number.
     *
     * @param number a positive integer
     * @return aliquot sum of given {@code number}
     */
    public static int getAliquotValue(int number) {
        var sumWrapper = new Object() {
            int value = 0;
        };

        IntStream.iterate(1, i -> ++i)
                .limit(number / 2)
                .filter(i -> number % i == 0)
                .forEach(i -> sumWrapper.value += i);

        return sumWrapper.value;
    }
}
package com.thealgorithms.audiofilters;

/**
 * N-Order IIR Filter Assumes inputs are normalized to [-1, 1]
 *
 * Based on the difference equation from
 * https://en.wikipedia.org/wiki/Infinite_impulse_response
 */
public class IIRFilter {

    private final int order;
    private final double[] coeffsA;
    private final double[] coeffsB;
    private final double[] historyX;
    private final double[] historyY;

    /**
     * Construct an IIR Filter
     *
     * @param order the filter's order
     * @throws IllegalArgumentException if order is zero or less
     */
    public IIRFilter(int order) throws IllegalArgumentException {
        if (order < 1) {
            throw new IllegalArgumentException("order must be greater than zero");
        }

        this.order = order;
        coeffsA = new double[order + 1];
        coeffsB = new double[order + 1];

        // Sane defaults
        coeffsA[0] = 1.0;
        coeffsB[0] = 1.0;

        historyX = new double[order];
        historyY = new double[order];
    }

    /**
     * Set coefficients
     *
     * @param aCoeffs Denominator coefficients
     * @param bCoeffs Numerator coefficients
     * @throws IllegalArgumentException if {@code aCoeffs} or {@code bCoeffs} is
     * not of size {@code order}, or if {@code aCoeffs[0]} is 0.0
     */
    public void setCoeffs(double[] aCoeffs, double[] bCoeffs) throws IllegalArgumentException {
        if (aCoeffs.length != order) {
            throw new IllegalArgumentException("aCoeffs must be of size " + order + ", got " + aCoeffs.length);
        }

        if (aCoeffs[0] == 0.0) {
            throw new IllegalArgumentException("aCoeffs.get(0) must not be zero");
        }

        if (bCoeffs.length != order) {
            throw new IllegalArgumentException("bCoeffs must be of size " + order + ", got " + bCoeffs.length);
        }

        for (int i = 0; i <= order; i++) {
            coeffsA[i] = aCoeffs[i];
            coeffsB[i] = bCoeffs[i];
        }
    }

    /**
     * Process a single sample
     *
     * @param sample the sample to process
     * @return the processed sample
     */
    public double process(double sample) {
        double result = 0.0;

        // Process
        for (int i = 1; i <= order; i++) {
            result += (coeffsB[i] * historyX[i - 1] - coeffsA[i] * historyY[i - 1]);
        }
        result = (result + coeffsB[0] * sample) / coeffsA[0];

        // Feedback
        for (int i = order - 1; i > 0; i--) {
            historyX[i] = historyX[i - 1];
            historyY[i] = historyY[i - 1];
        }

        historyX[0] = sample;
        historyY[0] = result;

        return result;
    }
}
package com.thealgorithms.dynamicprogramming;

/**
 * @author Varun Upadhyay (https://github.com/varunu28)
 */
public class CoinChange {

    // Driver Program
    public static void main(String[] args) {

        int amount = 12;
        int[] coins = {2, 4, 5};

        System.out.println(
                "Number of combinations of getting change for " + amount + " is: " + change(coins, amount));
        System.out.println(
                "Minimum number of coins required for amount :"
                + amount
                + " is: "
                + minimumCoins(coins, amount));
    }

    /**
     * This method finds the number of combinations of getting change for a
     * given amount and change coins
     *
     * @param coins The list of coins
     * @param amount The amount for which we need to find the change Finds the
     * number of combinations of change
     */
    public static int change(int[] coins, int amount) {

        int[] combinations = new int[amount + 1];
        combinations[0] = 1;

        for (int coin : coins) {
            for (int i = coin; i < amount + 1; i++) {
                combinations[i] += combinations[i - coin];
            }
            // Uncomment the below line to see the state of combinations for each coin
            // printAmount(combinations);
        }

        return combinations[amount];
    }

    /**
     * This method finds the minimum number of coins needed for a given amount.
     *
     * @param coins The list of coins
     * @param amount The amount for which we need to find the minimum number of
     * coins. Finds the minimum number of coins that make a given value.
     */
    public static int minimumCoins(int[] coins, int amount) {
        // minimumCoins[i] will store the minimum coins needed for amount i
        int[] minimumCoins = new int[amount + 1];

        minimumCoins[0] = 0;

        for (int i = 1; i <= amount; i++) {
            minimumCoins[i] = Integer.MAX_VALUE;
        }
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (coin <= i) {
                    int sub_res = minimumCoins[i - coin];
                    if (sub_res != Integer.MAX_VALUE && sub_res + 1 < minimumCoins[i]) {
                        minimumCoins[i] = sub_res + 1;
                    }
                }
            }
        }
        // Uncomment the below line to see the state of combinations for each coin
        // printAmount(minimumCoins);
        return minimumCoins[amount];
    }

    // A basic print method which prints all the contents of the array
    public static void printAmount(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
package com.thealgorithms.dynamicprogramming;

/**
 * Given a text and wildcard pattern implement a wildcard pattern matching
 * algorithm that finds if wildcard is matched with text. The matching should
 * cover the entire text ?-> matches single characters *-> match the sequence of
 * characters
 *
 */
/**
 * For calculation of Time and Space Complexity. Let N be length of src and M be
 * length of pat
 *
 */
public class RegexMatching {

    // Method 1: Using Recursion
    // Time Complexity=0(2^(N+M)) Space Complexity=Recursion Extra Space
    static boolean regexRecursion(String src, String pat) {
        if (src.length() == 0 && pat.length() == 0) {
            return true;
        }
        if (src.length() != 0 && pat.length() == 0) {
            return false;
        }
        if (src.length() == 0 && pat.length() != 0) {
            for (int i = 0; i < pat.length(); i++) {
                if (pat.charAt(i) != '*') {
                    return false;
                }
            }
            return true;
        }
        char chs = src.charAt(0);
        char chp = pat.charAt(0);

        String ros = src.substring(1);
        String rop = pat.substring(1);

        boolean ans;
        if (chs == chp || chp == '?') {
            ans = regexRecursion(ros, rop);
        } else if (chp == '*') {
            boolean blank = regexRecursion(src, rop);
            boolean multiple = regexRecursion(ros, pat);
            ans = blank || multiple;
        } else {
            ans = false;
        }
        return ans;
    }

    // Method 2: Using Recursion and breaking string using virtual index
    // Time Complexity=0(2^(N+M)) Space Complexity=Recursion Extra Space
    static boolean regexRecursion(String src, String pat, int svidx, int pvidx) {
        if (src.length() == svidx && pat.length() == pvidx) {
            return true;
        }
        if (src.length() != svidx && pat.length() == pvidx) {
            return false;
        }
        if (src.length() == svidx && pat.length() != pvidx) {
            for (int i = pvidx; i < pat.length(); i++) {
                if (pat.charAt(i) != '*') {
                    return false;
                }
            }
            return true;
        }
        char chs = src.charAt(svidx);
        char chp = pat.charAt(pvidx);

        boolean ans;
        if (chs == chp || chp == '?') {
            ans = regexRecursion(src, pat, svidx + 1, pvidx + 1);
        } else if (chp == '*') {
            boolean blank = regexRecursion(src, pat, svidx, pvidx + 1);
            boolean multiple = regexRecursion(src, pat, svidx + 1, pvidx);
            ans = blank || multiple;
        } else {
            ans = false;
        }
        return ans;
    }

    // Method 3: Top-Down DP(Memoization)
    // Time Complexity=0(N*M) Space Complexity=0(N*M)+Recursion Extra Space
    static boolean regexRecursion(String src, String pat, int svidx, int pvidx, int[][] strg) {
        if (src.length() == svidx && pat.length() == pvidx) {
            return true;
        }
        if (src.length() != svidx && pat.length() == pvidx) {
            return false;
        }
        if (src.length() == svidx && pat.length() != pvidx) {
            for (int i = pvidx; i < pat.length(); i++) {
                if (pat.charAt(i) != '*') {
                    return false;
                }
            }
            return true;
        }
        if (strg[svidx][pvidx] != 0) {
            return strg[svidx][pvidx] == 1 ? false : true;
        }
        char chs = src.charAt(svidx);
        char chp = pat.charAt(pvidx);

        boolean ans;
        if (chs == chp || chp == '?') {
            ans = regexRecursion(src, pat, svidx + 1, pvidx + 1, strg);
        } else if (chp == '*') {
            boolean blank = regexRecursion(src, pat, svidx, pvidx + 1, strg);
            boolean multiple = regexRecursion(src, pat, svidx + 1, pvidx, strg);
            ans = blank || multiple;
        } else {
            ans = false;
        }
        strg[svidx][pvidx] = ans == false ? 1 : 2;
        return ans;
    }

    // Method 4: Bottom-Up DP(Tabulation)
    // Time Complexity=0(N*M) Space Complexity=0(N*M)
    static boolean regexBU(String src, String pat) {

        boolean strg[][] = new boolean[src.length() + 1][pat.length() + 1];
        strg[src.length()][pat.length()] = true;
        for (int row = src.length(); row >= 0; row--) {
            for (int col = pat.length() - 1; col >= 0; col--) {
                if (row == src.length()) {
                    if (pat.charAt(col) == '*') {
                        strg[row][col] = strg[row][col + 1];
                    } else {
                        strg[row][col] = false;
                    }
                } else {
                    char chs = src.charAt(row);
                    char chp = pat.charAt(col);

                    boolean ans;
                    if (chs == chp || chp == '?') {
                        ans = strg[row + 1][col + 1];
                    } else if (chp == '*') {
                        boolean blank = strg[row][col + 1];
                        boolean multiple = strg[row + 1][col];
                        ans = blank || multiple;
                    } else {
                        ans = false;
                    }
                    strg[row][col] = ans;
                }
            }
        }
        return strg[0][0];
    }

    public static void main(String[] args) {

        String src = "aa";
        String pat = "*";
        System.out.println("Method 1: " + regexRecursion(src, pat));
        System.out.println("Method 2: " + regexRecursion(src, pat, 0, 0));
        System.out.println("Method 3: " + regexRecursion(src, pat, 0, 0, new int[src.length()][pat.length()]));
        System.out.println("Method 4: " + regexBU(src, pat));

    }

}
// Memoization vs Tabulation : https://www.geeksforgeeks.org/tabulation-vs-memoization/
// Question Link : https://practice.geeksforgeeks.org/problems/wildcard-pattern-matching/1
package com.thealgorithms.dynamicprogramming;

/*
 * Algorithm explanation https://leetcode.com/problems/longest-palindromic-substring/
 */
public class LongestPalindromicSubstring {

    public static void main(String[] args) {
        String a = "babad";
        String b = "cbbd";

        String aLPS = LPS(a);
        String bLPS = LPS(b);

        System.out.println(a + " => " + aLPS);
        System.out.println(b + " => " + bLPS);
    }

    private static String LPS(String input) {
        if (input == null || input.length() == 0) {
            return input;
        }
        boolean arr[][] = new boolean[input.length()][input.length()];
        int start = 0, end = 0;
        for (int g = 0; g < input.length(); g++) {
            for (int i = 0, j = g; j < input.length(); i++, j++) {

                if (g == 0) {
                    arr[i][j] = true;
                } else if (g == 1) {
                    if (input.charAt(i) == input.charAt(j)) {
                        arr[i][j] = true;
                    } else {
                        arr[i][j] = false;
                    }
                } else {

                    if (input.charAt(i) == input.charAt(j) && arr[i + 1][j - 1]) {
                        arr[i][j] = true;
                    } else {
                        arr[i][j] = false;
                    }
                }

                if (arr[i][j]) {
                    start = i;
                    end = j;
                }
            }
        }
        return input.substring(start, end + 1);
    }

}
package com.thealgorithms.dynamicprogramming;

/**
 * @author Kshitij VERMA (github.com/kv19971) LEVENSHTEIN DISTANCE dyamic
 * programming implementation to show the difference between two strings
 * (https://en.wikipedia.org/wiki/Levenshtein_distance)
 */
public class LevenshteinDistance {

    private static int minimum(int a, int b, int c) {
        if (a < b && a < c) {
            return a;
        } else if (b < a && b < c) {
            return b;
        } else {
            return c;
        }
    }

    private static int calculate_distance(String a, String b) {
        int len_a = a.length() + 1;
        int len_b = b.length() + 1;
        int[][] distance_mat = new int[len_a][len_b];
        for (int i = 0; i < len_a; i++) {
            distance_mat[i][0] = i;
        }
        for (int j = 0; j < len_b; j++) {
            distance_mat[0][j] = j;
        }
        for (int i = 0; i < len_a; i++) {
            for (int j = 0; j < len_b; j++) {
                int cost;
                if (a.charAt(i) == b.charAt(j)) {
                    cost = 0;
                } else {
                    cost = 1;
                }
                distance_mat[i][j]
                        = minimum(distance_mat[i - 1][j], distance_mat[i - 1][j - 1], distance_mat[i][j - 1])
                        + cost;
            }
        }
        return distance_mat[len_a - 1][len_b - 1];
    }

    public static void main(String[] args) {
        String a = ""; // enter your string here
        String b = ""; // enter your string here

        System.out.print("Levenshtein distance between " + a + " and " + b + " is: ");
        System.out.println(calculate_distance(a, b));
    }
}
package com.thealgorithms.dynamicprogramming;

/**
 * Java program for Boundary fill algorithm.
 * @author Akshay Dubey (https://github.com/itsAkshayDubey)
 */
public class BoundaryFill {
	
    /**
     * Get the color at the given co-odrinates of a 2D image
     *
     * @param image The image to be filled
     * @param x_co_ordinate The x co-ordinate of which color is to be obtained
     * @param y_co_ordinate The y co-ordinate of which color is to be obtained
     */
	public static int getPixel(int[][] image, int x_co_ordinate, int y_co_ordinate) {
	
		return image[x_co_ordinate][y_co_ordinate];
	
	}
	
    /**
     * Put the color at the given co-odrinates of a 2D image
     *
     * @param image The image to be filed
     * @param x_co_ordinate The x co-ordinate at which color is to be filled
     * @param y_co_ordinate The y co-ordinate at which color is to be filled
     */
	public static void putPixel(int[][] image, int x_co_ordinate, int y_co_ordinate, int new_color) {
		
		image[x_co_ordinate][y_co_ordinate] = new_color;
	
	}
	
    /**
     * Fill the 2D image with new color
     *
     * @param image The image to be filed
     * @param x_co_ordinate The x co-ordinate at which color is to be filled
     * @param y_co_ordinate The y co-ordinate at which color is to be filled
     * @param new_color The new color which to be filled in the image
     * @param boundary_color The old color which is to be replaced in the image
     */
	public static void boundaryFill(int[][] image, int x_co_ordinate, int y_co_ordinate, int new_color, int boundary_color) {
		if(x_co_ordinate >= 0 && y_co_ordinate >= 0 && getPixel(image, x_co_ordinate, y_co_ordinate) != new_color && getPixel(image, x_co_ordinate, y_co_ordinate) != boundary_color) {
			
			putPixel(image, x_co_ordinate, y_co_ordinate, new_color);
			boundaryFill(image, x_co_ordinate + 1, y_co_ordinate, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate - 1, y_co_ordinate, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate, y_co_ordinate + 1, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate, y_co_ordinate - 1, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate + 1, y_co_ordinate - 1, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate - 1, y_co_ordinate + 1, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate + 1, y_co_ordinate + 1, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate - 1, y_co_ordinate - 1, new_color, boundary_color);
			
			
		}
		
	}
	
    /**
     * This method will print the 2D image matrix
     *
     * @param image The image to be printed on the console
     */
	public static void printImageArray(int[][] image) {
		
		for(int i=0 ; i<image.length ; i++) {
			for(int j=0 ; j<image[0].length ; j++) {
				
				System.out.print(image[i][j]+"  ");
			}
			
			System.out.println();
		}
		
	}
	
	// Driver Program
	public static void main(String[] args) {
		
		//Input 2D image matrix
		int[][] image = {
				{0,0,0,0,0,0,0},
				{0,3,3,3,3,0,0},
				{0,3,0,0,3,0,0},
				{0,3,0,0,3,3,3},
				{0,3,3,3,0,0,3},
				{0,0,0,3,0,0,3},
				{0,0,0,3,3,3,3}
		};
		
		
		boundaryFill(image,2,2,5,3);
		
		/* Output ==>
		 * 0  0  0  0  0  0  0  
		   0  3  3  3  3  0  0  
		   0  3  5  5  3  0  0  
           0  3  5  5  3  3  3  
           0  3  3  3  5  5  3  
           0  0  0  3  5  5  3  
           0  0  0  3  3  3  3
		 * */
		
		//print 2D image matrix
		printImageArray(image);
	}

}package com.thealgorithms.dynamicprogramming;

// A Dynamic Programming based solution
// for 0-1 Knapsack problem
public class DyanamicProgrammingKnapsack {

    static int max(int a, int b) {
        return (a > b) ? a : b;
    }

    // Returns the maximum value that can
    // be put in a knapsack of capacity W
    static int knapSack(int W, int wt[], int val[], int n) {
        int i, w;
        int K[][] = new int[n + 1][W + 1];

        // Build table K[][] in bottom up manner
        for (i = 0; i <= n; i++) {
            for (w = 0; w <= W; w++) {
                if (i == 0 || w == 0) {
                    K[i][w] = 0;
                } else if (wt[i - 1] <= w) {
                    K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]);
                } else {
                    K[i][w] = K[i - 1][w];
                }
            }
        }

        return K[n][W];
    }

    // Driver code
    public static void main(String args[]) {
        int val[] = new int[]{60, 100, 120};
        int wt[] = new int[]{10, 20, 30};
        int W = 50;
        int n = val.length;
        System.out.println(knapSack(W, wt, val, n));
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class MatrixChainMultiplication {

    private static Scanner scan = new Scanner(System.in);
    private static ArrayList<Matrix> mArray = new ArrayList<>();
    private static int size;
    private static int[][] m;
    private static int[][] s;
    private static int[] p;

    public static void main(String[] args) {
        int count = 1;
        while (true) {
            String[] mSize = input("input size of matrix A(" + count + ") ( ex. 10 20 ) : ");
            int col = Integer.parseInt(mSize[0]);
            if (col == 0) {
                break;
            }
            int row = Integer.parseInt(mSize[1]);

            Matrix matrix = new Matrix(count, col, row);
            mArray.add(matrix);
            count++;
        }
        for (Matrix m : mArray) {
            System.out.format("A(%d)  =  %2d  x  %2d%n", m.count(), m.col(), m.row());
        }

        size = mArray.size();
        m = new int[size + 1][size + 1];
        s = new int[size + 1][size + 1];
        p = new int[size + 1];

        for (int i = 0; i < size + 1; i++) {
            Arrays.fill(m[i], -1);
            Arrays.fill(s[i], -1);
        }

        for (int i = 0; i < p.length; i++) {
            p[i] = i == 0 ? mArray.get(i).col() : mArray.get(i - 1).row();
        }

        matrixChainOrder();
        for (int i = 0; i < size; i++) {
            System.out.print("-------");
        }
        System.out.println();
        printArray(m);
        for (int i = 0; i < size; i++) {
            System.out.print("-------");
        }
        System.out.println();
        printArray(s);
        for (int i = 0; i < size; i++) {
            System.out.print("-------");
        }
        System.out.println();

        System.out.println("Optimal solution : " + m[1][size]);
        System.out.print("Optimal parens : ");
        printOptimalParens(1, size);
    }

    private static void printOptimalParens(int i, int j) {
        if (i == j) {
            System.out.print("A" + i);
        } else {
            System.out.print("(");
            printOptimalParens(i, s[i][j]);
            printOptimalParens(s[i][j] + 1, j);
            System.out.print(")");
        }
    }

    private static void printArray(int[][] array) {
        for (int i = 1; i < size + 1; i++) {
            for (int j = 1; j < size + 1; j++) {
                System.out.print(String.format("%7d", array[i][j]));
            }
            System.out.println();
        }
    }

    private static void matrixChainOrder() {
        for (int i = 1; i < size + 1; i++) {
            m[i][i] = 0;
        }

        for (int l = 2; l < size + 1; l++) {
            for (int i = 1; i < size - l + 2; i++) {
                int j = i + l - 1;
                m[i][j] = Integer.MAX_VALUE;

                for (int k = i; k < j; k++) {
                    int q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
                    if (q < m[i][j]) {
                        m[i][j] = q;
                        s[i][j] = k;
                    }
                }
            }
        }
    }

    private static String[] input(String string) {
        System.out.print(string);
        return (scan.nextLine().split(" "));
    }
}

class Matrix {

    private int count;
    private int col;
    private int row;

    Matrix(int count, int col, int row) {
        this.count = count;
        this.col = col;
        this.row = row;
    }

    int count() {
        return count;
    }

    int col() {
        return col;
    }

    int row() {
        return row;
    }
}
package com.thealgorithms.dynamicprogramming;

/**
 * DynamicProgramming solution for the Egg Dropping Puzzle
 */
public class EggDropping {

    // min trials with n eggs and m floors
    private static int minTrials(int n, int m) {

        int[][] eggFloor = new int[n + 1][m + 1];
        int result, x;

        for (int i = 1; i <= n; i++) {
            eggFloor[i][0] = 0; // Zero trial for zero floor.
            eggFloor[i][1] = 1; // One trial for one floor
        }

        // j trials for only 1 egg
        for (int j = 1; j <= m; j++) {
            eggFloor[1][j] = j;
        }

        // Using bottom-up approach in DP
        for (int i = 2; i <= n; i++) {
            for (int j = 2; j <= m; j++) {
                eggFloor[i][j] = Integer.MAX_VALUE;
                for (x = 1; x <= j; x++) {
                    result = 1 + Math.max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);

                    // choose min of all values for particular x
                    if (result < eggFloor[i][j]) {
                        eggFloor[i][j] = result;
                    }
                }
            }
        }

        return eggFloor[n][m];
    }

    public static void main(String args[]) {
        int n = 2, m = 4;
        // result outputs min no. of trials in worst case for n eggs and m floors
        int result = minTrials(n, m);
        System.out.println(result);
    }
}
package com.thealgorithms.dynamicprogramming;

/**
 * A DynamicProgramming based solution for 0-1 Knapsack problem
 */
public class Knapsack {

    private static int knapSack(int W, int wt[], int val[], int n) throws IllegalArgumentException {
        if (wt == null || val == null) {
            throw new IllegalArgumentException();
        }
        int i, w;
        int rv[][] = new int[n + 1][W + 1]; // rv means return value

        // Build table rv[][] in bottom up manner
        for (i = 0; i <= n; i++) {
            for (w = 0; w <= W; w++) {
                if (i == 0 || w == 0) {
                    rv[i][w] = 0;
                } else if (wt[i - 1] <= w) {
                    rv[i][w] = Math.max(val[i - 1] + rv[i - 1][w - wt[i - 1]], rv[i - 1][w]);
                } else {
                    rv[i][w] = rv[i - 1][w];
                }
            }
        }

        return rv[n][W];
    }

    // Driver program to test above function
    public static void main(String args[]) {
        int val[] = new int[]{50, 100, 130};
        int wt[] = new int[]{10, 20, 40};
        int W = 50;
        System.out.println(knapSack(W, wt, val, val.length));
    }
}
/** Author : Siddhant Swarup Mallick
 * Github : https://github.com/siddhant2002
 */


/**
 * A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
 * The robot can only move either down or right at any point in time.
 * The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
 * How many possible unique paths are there?
 */

/** Program description - To find the number of unique paths possible */

package com.thealgorithms.dynamicprogramming;

import java.util.*;

public class UniquePaths {
    public static boolean uniquePaths(int m , int n , int ans) {
        int []dp = new int[n];
        Arrays.fill(dp,1);
        for (int i=1; i<m; i++)
        {
            for (int j=1; j<n; j++)
            {
                dp[j] += dp[j-1];

            }
        }
        return dp[n-1]==ans;
        // return true if predicted answer matches with expected answer
    }
    // The above method runs in O(n) time
    public static boolean uniquePaths2(int m , int n , int ans) {
        int dp[][] = new int[m][n];
        for (int i=0; i<m; i++)
        {
            dp[i][0] = 1;
        }
        for (int j=0; j<n; j++)
        {
            dp[0][j] = 1;
        }
        for (int i=1; i<m; i++)
        {
            for (int j=1; j<n; j++)
            {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1]==ans;
        // return true if predicted answer matches with expected answer
    }
    // The above mthod takes O(m*n) time
}
/**
     * OUTPUT :
     * Input - m = 3, n = 7
     * Output: it returns either true if expected answer matches with the predicted answer else it returns false
     * 1st approach Time Complexity : O(n)
     * Auxiliary Space Complexity : O(n)
     * Input - m = 3, n = 7
     * Output: it returns either true if expected answer matches with the predicted answer else it returns false
     * 2nd approach Time Complexity : O(m*n)
     * Auxiliary Space Complexity : O(m*n)
     */
package com.thealgorithms.dynamicprogramming;

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

/**
 * @author Varun Upadhyay (https://github.com/varunu28)
 */
public class Fibonacci {

    private static Map<Integer, Integer> map = new HashMap<>();

    public static void main(String[] args) {

        // Methods all returning [0, 1, 1, 2, 3, 5, ...] for n = [0, 1, 2, 3, 4, 5, ...]
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        System.out.println(fibMemo(n));
        System.out.println(fibBotUp(n));
        System.out.println(fibOptimized(n));
        sc.close();
    }

    /**
     * This method finds the nth fibonacci number using memoization technique
     *
     * @param n The input n for which we have to determine the fibonacci number
     * Outputs the nth fibonacci number
     */
    public static int fibMemo(int n) {
        if (map.containsKey(n)) {
            return map.get(n);
        }

        int f;

        if (n <= 1) {
            f = n;
        } else {
            f = fibMemo(n - 1) + fibMemo(n - 2);
            map.put(n, f);
        }
        return f;
    }

    /**
     * This method finds the nth fibonacci number using bottom up
     *
     * @param n The input n for which we have to determine the fibonacci number
     * Outputs the nth fibonacci number
     */
    public static int fibBotUp(int n) {

        Map<Integer, Integer> fib = new HashMap<>();

        for (int i = 0; i <= n; i++) {
            int f;
            if (i <= 1) {
                f = i;
            } else {
                f = fib.get(i - 1) + fib.get(i - 2);
            }
            fib.put(i, f);
        }

        return fib.get(n);
    }

    /**
     * This method finds the nth fibonacci number using bottom up
     *
     * @param n The input n for which we have to determine the fibonacci number
     * Outputs the nth fibonacci number
     * <p>
     * This is optimized version of Fibonacci Program. Without using Hashmap and
     * recursion. It saves both memory and time. Space Complexity will be O(1)
     * Time Complexity will be O(n)
     * <p>
     * Whereas , the above functions will take O(n) Space.
     * @author Shoaib Rayeen (https://github.com/shoaibrayeen)
     */
    public static int fibOptimized(int n) {
        if (n == 0) {
            return 0;
        }
        int prev = 0, res = 1, next;
        for (int i = 2; i <= n; i++) {
            next = prev + res;
            prev = res;
            res = next;
        }
        return res;
    }
}
/** Author : Siddhant Swarup Mallick
 * Github : https://github.com/siddhant2002
 */
/**
 * In mathematics, the Golomb sequence is a non-decreasing integer sequence where n-th term is equal to number of times n appears in the sequence.
 */

/**
 * Wikipedia Link - https://en.wikipedia.org/wiki/Golomb_sequence
 */

/** Program description - To find the Golomb sequence upto n */

package com.thealgorithms.dynamicprogramming;

public class CountFriendsPairing {
    public static boolean countFriendsPairing(int n, int a[]) {
        int dp[] = new int[n + 1];
        // array of n+1 size is created
        dp[0] = 1;
        // since 1st index position value is fixed so it's marked as 1
        for (int i = 1; i < n; i++) {
            dp[i] = 1 + dp[i - dp[dp[i - 1]]];
            // formula for ith golomb sequence is dp(i) = 1 + dp(i – dp(dp(i - 1)))
        }
        for (int i = 1; i < n; i++) {
            if (a[i - 1] != dp[i]) {
                return false;
                // checks whether the calculated answer matches with the expected answer
            }
        }
        return true;
        // returns true if calculated answer matches with the expected answer
    }
}
package com.thealgorithms.dynamicprogramming;

/**
 * A DynamicProgramming solution for Rod cutting problem Returns the best
 * obtainable price for a rod of length n and price[] as prices of different
 * pieces
 */
public class RodCutting {

    private static int cutRod(int[] price, int n) {
        int val[] = new int[n + 1];
        val[0] = 0;

        for (int i = 1; i <= n; i++) {
            int max_val = Integer.MIN_VALUE;
            for (int j = 0; j < i; j++) {
                max_val = Math.max(max_val, price[j] + val[i - j - 1]);
            }

            val[i] = max_val;
        }

        return val[n];
    }

    // main function to test
    public static void main(String args[]) {
        int[] arr = new int[]{2, 5, 13, 19, 20};
        int result = cutRod(arr, arr.length);
        System.out.println("Maximum Obtainable Value is " + result);
    }
}
package com.thealgorithms.dynamicprogramming;

/**
 * Algorithm explanation
 * https://www.educative.io/edpresso/longest-palindromic-subsequence-algorithm
 */
public class LongestPalindromicSubsequence {

    public static void main(String[] args) {
        String a = "BBABCBCAB";
        String b = "BABCBAB";

        String aLPS = LPS(a);
        String bLPS = LPS(b);

        System.out.println(a + " => " + aLPS);
        System.out.println(b + " => " + bLPS);
    }

    public static String LPS(String original) throws IllegalArgumentException {
        StringBuilder reverse = new StringBuilder(original);
        reverse = reverse.reverse();
        return recursiveLPS(original, reverse.toString());
    }

    private static String recursiveLPS(String original, String reverse) {
        String bestResult = "";

        // no more chars, then return empty
        if (original.length() == 0 || reverse.length() == 0) {
            bestResult = "";
        } else {

            // if the last chars match, then remove it from both strings and recur
            if (original.charAt(original.length() - 1) == reverse.charAt(reverse.length() - 1)) {
                String bestSubResult
                        = recursiveLPS(
                                original.substring(0, original.length() - 1),
                                reverse.substring(0, reverse.length() - 1));

                bestResult = reverse.charAt(reverse.length() - 1) + bestSubResult;
            } else {
                // otherwise (1) ignore the last character of reverse, and recur on original and updated
                // reverse again
                // (2) ignore the last character of original and recur on the updated original and reverse
                // again
                // then select the best result from these two subproblems.

                String bestSubResult1 = recursiveLPS(original, reverse.substring(0, reverse.length() - 1));
                String bestSubResult2 = recursiveLPS(original.substring(0, original.length() - 1), reverse);
                if (bestSubResult1.length() > bestSubResult2.length()) {
                    bestResult = bestSubResult1;
                } else {
                    bestResult = bestSubResult2;
                }
            }
        }

        return bestResult;
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Vector;

public class FordFulkerson {

    static final int INF = 987654321;
    // edges
    static int V;
    static int[][] capacity, flow;

    public static void main(String[] args) {
        System.out.println("V : 6");
        V = 6;
        capacity = new int[V][V];

        capacity[0][1] = 12;
        capacity[0][3] = 13;
        capacity[1][2] = 10;
        capacity[2][3] = 13;
        capacity[2][4] = 3;
        capacity[2][5] = 15;
        capacity[3][2] = 7;
        capacity[3][4] = 15;
        capacity[4][5] = 17;

        System.out.println("Max capacity in networkFlow : " + networkFlow(0, 5));
    }

    private static int networkFlow(int source, int sink) {
        flow = new int[V][V];
        int totalFlow = 0;
        while (true) {
            Vector<Integer> parent = new Vector<>(V);
            for (int i = 0; i < V; i++) {
                parent.add(-1);
            }
            Queue<Integer> q = new LinkedList<>();
            parent.set(source, source);
            q.add(source);
            while (!q.isEmpty() && parent.get(sink) == -1) {
                int here = q.peek();
                q.poll();
                for (int there = 0; there < V; ++there) {
                    if (capacity[here][there] - flow[here][there] > 0 && parent.get(there) == -1) {
                        q.add(there);
                        parent.set(there, here);
                    }
                }
            }
            if (parent.get(sink) == -1) {
                break;
            }

            int amount = INF;
            String printer = "path : ";
            StringBuilder sb = new StringBuilder();
            for (int p = sink; p != source; p = parent.get(p)) {
                amount = Math.min(capacity[parent.get(p)][p] - flow[parent.get(p)][p], amount);
                sb.append(p + "-");
            }
            sb.append(source);
            for (int p = sink; p != source; p = parent.get(p)) {
                flow[parent.get(p)][p] += amount;
                flow[p][parent.get(p)] -= amount;
            }
            totalFlow += amount;
            printer += sb.reverse() + " / max flow : " + totalFlow;
            System.out.println(printer);
        }

        return totalFlow;
    }
}
package com.thealgorithms.dynamicprogramming;
// Here is the top-down approach of
// dynamic programming

public class MemoizationTechniqueKnapsack {

    // A utility function that returns
    // maximum of two integers
    static int max(int a, int b) {
        return (a > b) ? a : b;
    }

    // Returns the value of maximum profit
    static int knapSackRec(int W, int wt[], int val[], int n, int[][] dp) {

        // Base condition
        if (n == 0 || W == 0) {
            return 0;
        }

        if (dp[n][W] != -1) {
            return dp[n][W];
        }

        if (wt[n - 1] > W) // Store the value of function call
        // stack in table before return
        {
            return dp[n][W] = knapSackRec(W, wt, val, n - 1, dp);
        } else // Return value of table after storing
        {
            return dp[n][W]
                    = max(
                            (val[n - 1] + knapSackRec(W - wt[n - 1], wt, val, n - 1, dp)),
                            knapSackRec(W, wt, val, n - 1, dp));
        }
    }

    static int knapSack(int W, int wt[], int val[], int N) {

        // Declare the table dynamically
        int dp[][] = new int[N + 1][W + 1];

        // Loop to initially filled the
        // table with -1
        for (int i = 0; i < N + 1; i++) {
            for (int j = 0; j < W + 1; j++) {
                dp[i][j] = -1;
            }
        }

        return knapSackRec(W, wt, val, N, dp);
    }

    // Driver Code
    public static void main(String[] args) {
        int val[] = {60, 100, 120};
        int wt[] = {10, 20, 30};

        int W = 50;
        int N = val.length;

        System.out.println(knapSack(W, wt, val, N));
    }
}
package com.thealgorithms.dynamicprogramming;

/* A Naive recursive implementation
of 0-1 Knapsack problem */
public class BruteForceKnapsack {

    // A utility function that returns
    // maximum of two integers
    static int max(int a, int b) {
        return (a > b) ? a : b;
    }

    // Returns the maximum value that
    // can be put in a knapsack of
    // capacity W
    static int knapSack(int W, int wt[], int val[], int n) {
        // Base Case
        if (n == 0 || W == 0) {
            return 0;
        }

        // If weight of the nth item is
        // more than Knapsack capacity W,
        // then this item cannot be included
        // in the optimal solution
        if (wt[n - 1] > W) {
            return knapSack(W, wt, val, n - 1);
        } // Return the maximum of two cases:
        // (1) nth item included
        // (2) not included
        else {
            return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1), knapSack(W, wt, val, n - 1));
        }
    }

    // Driver code
    public static void main(String args[]) {
        int val[] = new int[]{60, 100, 120};
        int wt[] = new int[]{10, 20, 30};
        int W = 50;
        int n = val.length;
        System.out.println(knapSack(W, wt, val, n));
    }
}
package com.thealgorithms.dynamicprogramming;

/**
 * This file contains an implementation of finding the nth CATALAN NUMBER using
 * dynamic programming Wikipedia: https://en.wikipedia.org/wiki/Catalan_number
 *
 * Time Complexity: O(n^2) Space Complexity: O(n)
 *
 * @author AMRITESH ANAND (https://github.com/amritesh19)
 */
import java.util.Scanner;

public class CatalanNumber {

    /**
     * This method finds the nth Catalan number
     *
     * @param n input n which determines the nth Catalan number n should be less
     * than equal to 50 as 50th Catalan number is 6,533,841,209,031,609,592 for
     * n > 50, BigInteger class should be used instead long
     *
     * @return catalanArray[n] the nth Catalan number
     */
    static long findNthCatalan(int n) {

        // Array to store the results of subproblems i.e Catalan numbers from [1...n-1]
        long catalanArray[] = new long[n + 1];

        // Initialising C₀ = 1 and C₁ = 1 
        catalanArray[0] = 1;
        catalanArray[1] = 1;

        /**
         * The Catalan numbers satisfy the recurrence relation C₀=1 and Cn = Σ
         * (Ci * Cn-1-i), i = 0 to n-1 , n > 0
         */
        for (int i = 2; i <= n; i++) {
            catalanArray[i] = 0;
            for (int j = 0; j < i; j++) {
                catalanArray[i] += catalanArray[j] * catalanArray[i - j - 1];
            }
        }

        return catalanArray[n];
    }

    // Main method
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.println("Enter the number n to find nth Catalan number (n <= 50)");
        int n = sc.nextInt();
        System.out.println(n + "th Catalan number is " + findNthCatalan(n));

        sc.close();
    }
}
package com.thealgorithms.dynamicprogramming;

/*
* this is an important Algo in which
* we have starting and ending of board and we have to reach
* we have to count no. of ways
* that help to reach end point i.e number by rolling dice
* which have 1 to 6 digits

Test Case:
here target is 10

int n=10;
		startAlgo();
		System.out.println(bpR(0,n));
		System.out.println(endAlgo()+"ms");
		int[] strg=new int [n+1];
		startAlgo();
		System.out.println(bpRS(0,n,strg));
		System.out.println(endAlgo()+"ms");
		startAlgo();
		System.out.println(bpIS(0,n,strg));
		System.out.println(endAlgo()+"ms");



 */
public class BoardPath {

    public static long startTime;
    public static long endTime;

    public static void startAlgo() {
        startTime = System.currentTimeMillis();
    }

    public static long endAlgo() {
        endTime = System.currentTimeMillis();
        return endTime - startTime;
    }

    public static int bpR(int start, int end) {
        if (start == end) {
            return 1;
        } else if (start > end) {
            return 0;
        }
        int count = 0;
        for (int dice = 1; dice <= 6; dice++) {
            count += bpR(start + dice, end);
        }
        return count;
    }

    public static int bpRS(int curr, int end, int strg[]) {
        if (curr == end) {
            return 1;
        } else if (curr > end) {
            return 0;
        }
        if (strg[curr] != 0) {
            return strg[curr];
        }
        int count = 0;
        for (int dice = 1; dice <= 6; dice++) {
            count += bpRS(curr + dice, end, strg);
        }
        strg[curr] = count;
        return count;
    }

    public static int bpIS(int curr, int end, int[] strg) {
        strg[end] = 1;
        for (int i = end - 1; i >= 0; i--) {
            int count = 0;
            for (int dice = 1; dice <= 6 && dice + i < strg.length; dice++) {
                count += strg[i + dice];
            }
            strg[i] = count;
        }
        return strg[0];
    }
}
package com.thealgorithms.dynamicprogramming;

/**
 * A DynamicProgramming based solution for Edit Distance problem In Java
 * Description of Edit Distance with an Example:
 *
 * <p>
 * Edit distance is a way of quantifying how dissimilar two strings (e.g.,
 * words) are to one another, by counting the minimum number of operations
 * required to transform one string into the other. The distance operations are
 * the removal, insertion, or substitution of a character in the string.
 *
 * <p>
 *
 * <p>
 * The Distance between "kitten" and "sitting" is 3. A minimal edit script that
 * transforms the former into the latter is:
 *
 * <p>
 * kitten → sitten (substitution of "s" for "k") sitten → sittin (substitution
 * of "i" for "e") sittin → sitting (insertion of "g" at the end).
 *
 * @author SUBHAM SANGHAI
 */
import java.util.Scanner;

public class EditDistance {

    public static int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        // len1+1, len2+1, because finally return dp[len1][len2]
        int[][] dp = new int[len1 + 1][len2 + 1];
        /* If second string is empty, the only option is to
    insert all characters of first string into second*/
        for (int i = 0; i <= len1; i++) {
            dp[i][0] = i;
        }
        /* If first string is empty, the only option is to
    insert all characters of second string into first*/
        for (int j = 0; j <= len2; j++) {
            dp[0][j] = j;
        }
        // iterate though, and check last char
        for (int i = 0; i < len1; i++) {
            char c1 = word1.charAt(i);
            for (int j = 0; j < len2; j++) {
                char c2 = word2.charAt(j);
                // if last two chars equal
                if (c1 == c2) {
                    // update dp value for +1 length
                    dp[i + 1][j + 1] = dp[i][j];
                } else {
                    /* if two characters are different ,
          then take the minimum of the various operations(i.e insertion,removal,substitution)*/
                    int replace = dp[i][j] + 1;
                    int insert = dp[i][j + 1] + 1;
                    int delete = dp[i + 1][j] + 1;

                    int min = replace > insert ? insert : replace;
                    min = delete > min ? min : delete;
                    dp[i + 1][j + 1] = min;
                }
            }
        }
        /* return the final answer , after traversing through both the strings*/
        return dp[len1][len2];
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        String s1, s2;
        System.out.println("Enter the First String");
        s1 = input.nextLine();
        System.out.println("Enter the Second String");
        s2 = input.nextLine();
        // ans stores the final Edit Distance between the two strings
        int ans = minDistance(s1, s2);
        System.out.println(
                "The minimum Edit Distance between \"" + s1 + "\" and \"" + s2 + "\" is " + ans);
        input.close();
    }

    // edit distance problem
    public static int editDistance(String s1, String s2) {
        int[][] storage = new int[s1.length() + 1][s2.length() + 1];
        return editDistance(s1, s2, storage);

    }

    public static int editDistance(String s1, String s2, int[][] storage) {
        int m = s1.length();
        int n = s2.length();
        if (storage[m][n] > 0) {
            return storage[m][n];

        }
        if (m == 0) {
            storage[m][n] = n;
            return storage[m][n];

        }
        if (n == 0) {
            storage[m][n] = m;
            return storage[m][n];

        }
        if (s1.charAt(0) == s2.charAt(0)) {
            storage[m][n] = editDistance(s1.substring(1), s2.substring(1), storage);
            return storage[m][n];

        } else {
            int op1 = editDistance(s1, s2.substring(1), storage);
            int op2 = editDistance(s1.substring(1), s2, storage);
            int op3 = editDistance(s1.substring(1), s2.substring(1), storage);
            storage[m][n] = 1 + Math.min(op1, Math.min(op2, op3));
            return storage[m][n];
        }
    }
}
package com.thealgorithms.dynamicprogramming;

// Given N dice each with M faces, numbered from 1 to M, find the number of ways to get sum X.
// X is the summation of values on each face when all the dice are thrown.

/* The Naive approach is to find all the possible combinations of values from n dice and
keep on counting the results that sum to X. This can be done using recursion. */
// The above recursion solution exhibits overlapping subproblems.

/* Hence, storing the results of the solved sub-problems saves time.
And it can be done using Dynamic Programming(DP).
Following is implementation of Dynamic Programming approach. */
// Code ---->
// Java program to find number of ways to get sum 'x' with 'n' 
// dice where every dice has 'm' faces 
class DP {

    /* The main function that returns the number of ways to get sum 'x' with 'n' dice and 'm' with m faces. */
    public static long findWays(int m, int n, int x) {

        /* Create a table to store the results of subproblems. 
    One extra row and column are used for simplicity 
    (Number of dice is directly used as row index and sum is directly used as column index). 
    The entries in 0th row and 0th column are never used. */
        long[][] table = new long[n + 1][x + 1];

        /* Table entries for only one dice */
        for (int j = 1; j <= m && j <= x; j++) {
            table[1][j] = 1;
        }

        /* Fill rest of the entries in table using recursive relation 
    i: number of dice, j: sum */
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                for (int k = 1; k < j && k <= m; k++) {
                    table[i][j] += table[i - 1][j - k];
                }
            }
        }

        return table[n][x];
    }

    public static void main(String[] args) {
        System.out.println(findWays(4, 2, 1));
        System.out.println(findWays(2, 2, 3));
        System.out.println(findWays(6, 3, 8));
        System.out.println(findWays(4, 2, 5));
        System.out.println(findWays(4, 3, 5));
    }
}

/*
OUTPUT:
0
2
21
4
6
 */
// Time Complexity: O(m * n * x) where m is number of faces, n is number of dice and x is given sum.

package com.thealgorithms.dynamicprogramming;

// Matrix-chain Multiplication
// Problem Statement
// we have given a chain A1,A2,...,Ani of n matrices, where for i = 1,2,...,n, 
// matrix Ai has dimension pi−1 ×pi
// , fully parenthesize the product A1A2 ···An in a way that
// minimizes the number of scalar multiplications.
public class MatrixChainRecursiveTopDownMemoisation {

    static int Memoized_Matrix_Chain(int p[]) {
        int n = p.length;
        int m[][] = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                m[i][j] = Integer.MAX_VALUE;
            }
        }
        return Lookup_Chain(m, p, 1, n - 1);
    }

    static int Lookup_Chain(int m[][], int p[], int i, int j) {
        if (i == j) {
            m[i][j] = 0;
            return m[i][j];
        }
        if (m[i][j] < Integer.MAX_VALUE) {
            return m[i][j];
        } else {
            for (int k = i; k < j; k++) {
                int q = Lookup_Chain(m, p, i, k) + Lookup_Chain(m, p, k + 1, j) + (p[i - 1] * p[k] * p[j]);
                if (q < m[i][j]) {
                    m[i][j] = q;
                }
            }
        }
        return m[i][j];
    }

    // in this code we are taking the example of 4 matrixes whose orders are 1x2,2x3,3x4,4x5 respectively
    // output should be  Minimum number of multiplications is 38
    public static void main(String[] args) {

        int arr[] = {1, 2, 3, 4, 5};
        System.out.println("Minimum number of multiplications is " + Memoized_Matrix_Chain(arr));
    }
}
/** Author : Siddhant Swarup Mallick
 * Github : https://github.com/siddhant2002
 */


/** Program description - To find the New Man Shanks Prime. */
/** Wikipedia Link - https://en.wikipedia.org/wiki/Newman%E2%80%93Shanks%E2%80%93Williams_prime */

package com.thealgorithms.dynamicprogramming;

public class NewManShanksPrime {
    public static boolean nthManShanksPrime(int n , int expected_answer)
    {
        int a[] = new int[n+1];
        // array of n+1 size is initialized
        a[0] = a[1] = 1;
        // The 0th and 1st index position values are fixed. They are initialized as 1
        for(int i=2;i<=n;i++)
        {
            a[i]=2*a[i-1]+a[i-2];
        }
        // The loop is continued till n
        return a[n]==expected_answer;
        // returns true if calculated answer matches with expected answer
    }
}package com.thealgorithms.dynamicprogramming;

// Java program to find length of the shortest supersequence
class ShortestSuperSequence {

    // Function to find length of the
    // shortest supersequence of X and Y.
    static int shortestSuperSequence(String X, String Y) {
        int m = X.length();
        int n = Y.length();

        // find lcs
        int l = lcs(X, Y, m, n);

        // Result is sum of input string
        // lengths - length of lcs
        return (m + n - l);
    }

    // Returns length of LCS
    // for X[0..m - 1], Y[0..n - 1]
    static int lcs(String X, String Y, int m, int n) {
        int[][] L = new int[m + 1][n + 1];
        int i, j;

        // Following steps build L[m + 1][n + 1]
        // in bottom up fashion. Note that
        // L[i][j] contains length of LCS
        // of X[0..i - 1]and Y[0..j - 1]
        for (i = 0; i <= m; i++) {
            for (j = 0; j <= n; j++) {
                if (i == 0 || j == 0) {
                    L[i][j] = 0;
                } else if (X.charAt(i - 1) == Y.charAt(j - 1)) {
                    L[i][j] = L[i - 1][j - 1] + 1;
                } else {
                    L[i][j] = Math.max(L[i - 1][j],
                            L[i][j - 1]);
                }
            }
        }

        // L[m][n] contains length of LCS
        // for X[0..n - 1] and Y[0..m - 1]
        return L[m][n];
    }

    // Driver code
    public static void main(String args[]) {
        String X = "AGGTAB";
        String Y = "GXTXAYB";

        System.out.println("Length of the shortest "
                + "supersequence is "
                + shortestSuperSequence(X, Y));
    }
}
package com.thealgorithms.dynamicprogramming;

/**
 * Imagine you have a collection of N wines placed next to each other on the
 * shelf. The price of ith wine is pi(Prices of different wines are different).
 * Because wine gets better every year supposing today is year 1, on year y the
 * price would be y*pi i.e y times the value of the initial year. You want to
 * sell all wines but you have to sell one wine per year. One more constraint on
 * each year you are allowed to sell either leftmost or rightmost wine on the
 * shelf. You are not allowed to reorder. You have to find the maximum profit
 *
 */
public class WineProblem {

    // Method 1: Using Recursion
    // Time Complexity=0(2^N) Space Complexity=Recursion extra space
    public static int WPRecursion(int[] arr, int si, int ei) {
        int n = arr.length;
        int year = (n - (ei - si + 1)) + 1;
        if (si == ei) {
            return arr[si] * year;
        }

        int start = WPRecursion(arr, si + 1, ei) + arr[si] * year;
        int end = WPRecursion(arr, si, ei - 1) + arr[ei] * year;

        int ans = Math.max(start, end);

        return ans;
    }

    // Method 2: Top-Down DP(Memoization)
    // Time Complexity=0(N*N) Space Complexity=0(N*N)+Recursion extra space
    public static int WPTD(int[] arr, int si, int ei, int[][] strg) {
        int n = arr.length;
        int year = (n - (ei - si + 1)) + 1;
        if (si == ei) {
            return arr[si] * year;
        }

        if (strg[si][ei] != 0) {
            return strg[si][ei];
        }
        int start = WPTD(arr, si + 1, ei, strg) + arr[si] * year;
        int end = WPTD(arr, si, ei - 1, strg) + arr[ei] * year;

        int ans = Math.max(start, end);

        strg[si][ei] = ans;

        return ans;
    }

    // Method 3: Bottom-Up DP(Tabulation)
    // Time Complexity=0(N*N/2)->0(N*N) Space Complexity=0(N*N)
    public static int WPBU(int[] arr) {
        int n = arr.length;
        int[][] strg = new int[n][n];

        for (int slide = 0; slide <= n - 1; slide++) {
            for (int si = 0; si <= n - slide - 1; si++) {
                int ei = si + slide;
                int year = (n - (ei - si + 1)) + 1;
                if (si == ei) {
                    strg[si][ei] = arr[si] * year;
                } else {
                    int start = strg[si + 1][ei] + arr[si] * year;
                    int end = strg[si][ei - 1] + arr[ei] * year;

                    strg[si][ei] = Math.max(start, end);

                }
            }
        }
        return strg[0][n - 1];
    }

    public static void main(String[] args) {
        int[] arr = {2, 3, 5, 1, 4};
        System.out.println("Method 1: " + WPRecursion(arr, 0, arr.length - 1));
        System.out.println("Method 2: " + WPTD(arr, 0, arr.length - 1, new int[arr.length][arr.length]));
        System.out.println("Method 3: " + WPBU(arr));

    }

}
// Memoization vs Tabulation : https://www.geeksforgeeks.org/tabulation-vs-memoization/
// Question Link : https://www.geeksforgeeks.org/maximum-profit-sale-wines/
package com.thealgorithms.dynamicprogramming;

/*

 * Problem Statement: - 
 * Find Longest Alternating Subsequence

 * A sequence {x1, x2, .. xn} is alternating sequence if its elements satisfy one of the following relations : 

   x1 < x2 > x3 < x4 > x5 < …. xn or 
   x1 > x2 < x3 > x4 < x5 > …. xn
 */
public class LongestAlternatingSubsequence {

    /* Function to return longest alternating subsequence length*/
    static int AlternatingLength(int arr[], int n) {
        /*

		las[i][0] = Length of the longest
			alternating subsequence ending at
			index i and last element is
			greater than its previous element

		las[i][1] = Length of the longest
			alternating subsequence ending at
			index i and last element is
			smaller than its previous
			element 

         */
        int las[][] = new int[n][2]; // las = LongestAlternatingSubsequence

        for (int i = 0; i < n; i++) {
            las[i][0] = las[i][1] = 1;
        }

        int result = 1; // Initialize result

        /* Compute values in bottom up manner */
        for (int i = 1; i < n; i++) {

            /* Consider all elements as previous of arr[i]*/
            for (int j = 0; j < i; j++) {

                /* If arr[i] is greater, then check with las[j][1] */
                if (arr[j] < arr[i] && las[i][0] < las[j][1] + 1) {
                    las[i][0] = las[j][1] + 1;
                }

                /* If arr[i] is smaller, then check with las[j][0]*/
                if (arr[j] > arr[i] && las[i][1] < las[j][0] + 1) {
                    las[i][1] = las[j][0] + 1;
                }
            }

            /* Pick maximum of both values at index i */
            if (result < Math.max(las[i][0], las[i][1])) {
                result = Math.max(las[i][0], las[i][1]);
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int arr[] = {10, 22, 9, 33, 49, 50, 31, 60};
        int n = arr.length;
        System.out.println("Length of Longest " + "alternating subsequence is " + AlternatingLength(arr, n));
    }
}
package com.thealgorithms.dynamicprogramming;
// Partition a set into two subsets such that the difference of subset sums is minimum

/*
Input:  arr[] = {1, 6, 11, 5}
Output: 1
Explanation:
Subset1 = {1, 5, 6}, sum of Subset1 = 12
Subset2 = {11}, sum of Subset2 = 11

Input:  arr[] = {36, 7, 46, 40}
Output: 23
Explanation:
Subset1 = {7, 46} ;  sum of Subset1 = 53
Subset2 = {36, 40} ; sum of Subset2  = 76
 */
public class MinimumSumPartition {

    public static int subSet(int[] arr) {
        int n = arr.length;
        int sum = getSum(arr);
        boolean[][] dp = new boolean[n + 1][sum + 1];
        for (int i = 0; i <= n; i++) {
            dp[i][0] = true;
        }
        for (int j = 0; j <= sum; j++) {
            dp[0][j] = false;
        }

        // fill dp array
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= sum; j++) {
                if (arr[i - 1] < j) {
                    dp[i][j] = dp[i - 1][j - arr[i - 1]] || dp[i - 1][j];
                } else if (arr[i - 1] == j) {
                    dp[i][j] = true;
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        // fill the index array
        int[] index = new int[sum];
        int p = 0;
        for (int i = 0; i <= sum / 2; i++) {
            if (dp[n][i]) {
                index[p++] = i;
            }
        }

        return getMin(index, sum);
    }

    /**
     * Calculate sum of array elements
     *
     * @param arr the array
     * @return sum of given array
     */
    public static int getSum(int[] arr) {
        int sum = 0;
        for (int temp : arr) {
            sum += temp;
        }
        return sum;
    }

    public static int getMin(int[] arr, int sum) {
        if (arr.length == 0) {
            return 0;
        }
        int min = Integer.MAX_VALUE;
        for (int temp : arr) {
            min = Math.min(min, sum - 2 * temp);
        }
        return min;
    }

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        assert subSet(new int[]{1, 6, 11, 5}) == 1;
        assert subSet(new int[]{36, 7, 46, 40}) == 23;
        assert subSet(new int[]{1, 2, 3, 9}) == 3;
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.Scanner;

/**
 * @file @brief Implements [Palindrome
 * Partitioning](https://leetcode.com/problems/palindrome-partitioning-ii/)
 * algorithm, giving you the minimum number of partitions you need to make
 *
 * @details palindrome partitioning uses dynamic programming and goes to all the
 * possible partitions to find the minimum you are given a string and you need
 * to give minimum number of partitions needed to divide it into a number of
 * palindromes [Palindrome Partitioning]
 * (https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/) overall time
 * complexity O(n^2) For example: example 1:- String : "nitik" Output : 2 => "n
 * | iti | k" For example: example 2:- String : "ababbbabbababa" Output : 3 =>
 * "aba | b | bbabb | ababa"
 * @author [Syed] (https://github.com/roeticvampire)
 */
public class PalindromicPartitioning {

    public static int minimalpartitions(String word) {
        int len = word.length();
        /* We Make two arrays to create a bottom-up solution.
           minCuts[i] = Minimum number of cuts needed for palindrome partitioning of substring word[0..i]
           isPalindrome[i][j] = true if substring str[i..j] is palindrome
           Base Condition: C[i] is 0 if P[0][i]= true
         */
        int[] minCuts = new int[len];
        boolean[][] isPalindrome = new boolean[len][len];

        int i, j, L; // different looping variables

        // Every substring of length 1 is a palindrome
        for (i = 0; i < len; i++) {
            isPalindrome[i][i] = true;
        }

        /* L is substring length. Build the solution in bottom up manner by considering all substrings of length starting from 2 to n. */
        for (L = 2; L <= len; L++) {
            // For substring of length L, set different possible starting indexes
            for (i = 0; i < len - L + 1; i++) {
                j = i + L - 1; // Ending index
                // If L is 2, then we just need to
                // compare two characters. Else need to
                // check two corner characters and value
                // of P[i+1][j-1]
                if (L == 2) {
                    isPalindrome[i][j] = (word.charAt(i) == word.charAt(j));
                } else {
                    if ((word.charAt(i) == word.charAt(j)) && isPalindrome[i + 1][j - 1]) {
                        isPalindrome[i][j] = true;
                    } else {
                        isPalindrome[i][j] = false;
                    }

                }
            }
        }

        //We find the minimum for each index
        for (i = 0; i < len; i++) {
            if (isPalindrome[0][i] == true) {
                minCuts[i] = 0;
            } else {
                minCuts[i] = Integer.MAX_VALUE;
                for (j = 0; j < i; j++) {
                    if (isPalindrome[j + 1][i] == true && 1 + minCuts[j] < minCuts[i]) {
                        minCuts[i] = 1 + minCuts[j];
                    }
                }
            }
        }

        // Return the min cut value for complete
        // string. i.e., str[0..n-1]
        return minCuts[len - 1];
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        String word;
        System.out.println("Enter the First String");
        word = input.nextLine();
        // ans stores the final minimal cut count needed for partitioning
        int ans = minimalpartitions(word);
        System.out.println(
                "The minimum cuts needed to partition \"" + word + "\" into palindromes is " + ans);
        input.close();
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.Arrays;

/**
 * Recursive Solution for 0-1 knapsack with memoization
 */
public class KnapsackMemoization {

    private static int[][] t;

    // Returns the maximum value that can
    // be put in a knapsack of capacity W
    public static int knapsack(int[] wt, int[] value, int W, int n) {
        if (t[n][W] != -1) {
            return t[n][W];
        }
        if (n == 0 || W == 0) {
            return 0;
        }
        if (wt[n - 1] <= W) {
            t[n - 1][W - wt[n - 1]] = knapsack(wt, value, W - wt[n - 1], n - 1);
            // Include item in the bag. In that case add the value of the item and call for the remaining items
            int tmp1 = value[n - 1] + t[n - 1][W - wt[n - 1]];
            // Don't include the nth item in the bag anl call for remaining item without reducing the weight
            int tmp2 = knapsack(wt, value, W, n - 1);
            t[n - 1][W] = tmp2;
            // include the larger one
            int tmp = tmp1 > tmp2 ? tmp1 : tmp2;
            t[n][W] = tmp;
            return tmp;
            // If Weight for the item is more than the desired weight then don't include it
            // Call for rest of the n-1 items
        } else if (wt[n - 1] > W) {
            t[n][W] = knapsack(wt, value, W, n - 1);
            return t[n][W];
        }
        return -1;
    }

    // Driver code
    public static void main(String args[]) {
        int[] wt = {1, 3, 4, 5};
        int[] value = {1, 4, 5, 7};
        int W = 10;
        t = new int[wt.length + 1][W + 1];
        Arrays.stream(t).forEach(a -> Arrays.fill(a, -1));
        int res = knapsack(wt, value, W, wt.length);
        System.out.println("Maximum knapsack value " + res);
    }
}
package com.thealgorithms.dynamicprogramming;

class LongestCommonSubsequence {

    public static String getLCS(String str1, String str2) {

        // At least one string is null
        if (str1 == null || str2 == null) {
            return null;
        }

        // At least one string is empty
        if (str1.length() == 0 || str2.length() == 0) {
            return "";
        }

        String[] arr1 = str1.split("");
        String[] arr2 = str2.split("");

        // lcsMatrix[i][j]  = LCS of first i elements of arr1 and first j characters of arr2
        int[][] lcsMatrix = new int[arr1.length + 1][arr2.length + 1];

        for (int i = 0; i < arr1.length + 1; i++) {
            lcsMatrix[i][0] = 0;
        }
        for (int j = 1; j < arr2.length + 1; j++) {
            lcsMatrix[0][j] = 0;
        }
        for (int i = 1; i < arr1.length + 1; i++) {
            for (int j = 1; j < arr2.length + 1; j++) {
                if (arr1[i - 1].equals(arr2[j - 1])) {
                    lcsMatrix[i][j] = lcsMatrix[i - 1][j - 1] + 1;
                } else {
                    lcsMatrix[i][j]
                            = lcsMatrix[i - 1][j] > lcsMatrix[i][j - 1] ? lcsMatrix[i - 1][j] : lcsMatrix[i][j - 1];
                }
            }
        }
        return lcsString(str1, str2, lcsMatrix);
    }

    public static String lcsString(String str1, String str2, int[][] lcsMatrix) {
        StringBuilder lcs = new StringBuilder();
        int i = str1.length(), j = str2.length();
        while (i > 0 && j > 0) {
            if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                lcs.append(str1.charAt(i - 1));
                i--;
                j--;
            } else if (lcsMatrix[i - 1][j] > lcsMatrix[i][j - 1]) {
                i--;
            } else {
                j--;
            }
        }
        return lcs.reverse().toString();
    }

    public static void main(String[] args) {
        String str1 = "DSGSHSRGSRHTRD";
        String str2 = "DATRGAGTSHS";
        String lcs = getLCS(str1, str2);

        // Print LCS
        if (lcs != null) {
            System.out.println("String 1: " + str1);
            System.out.println("String 2: " + str2);
            System.out.println("LCS: " + lcs);
            System.out.println("LCS length: " + lcs.length());
        }
    }
}
package com.thealgorithms.dynamicprogramming;

public class SubsetSum {

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        int[] arr = new int[]{50, 4, 10, 15, 34};
        assert subsetSum(arr, 64);
        /* 4 + 10 + 15 + 34 = 64 */
        assert subsetSum(arr, 99);
        /* 50 + 15 + 34 = 99 */
        assert !subsetSum(arr, 5);
        assert !subsetSum(arr, 66);
    }

    /**
     * Test if a set of integers contains a subset that sum to a given integer.
     *
     * @param arr the array contains integers.
     * @param sum target sum of subset.
     * @return {@code true} if subset exists, otherwise {@code false}.
     */
    private static boolean subsetSum(int[] arr, int sum) {
        int n = arr.length;
        boolean[][] isSum = new boolean[n + 2][sum + 1];

        isSum[n + 1][0] = true;
        for (int i = 1; i <= sum; i++) {
            isSum[n + 1][i] = false;
        }

        for (int i = n; i > 0; i--) {
            isSum[i][0] = true;
            for (int j = 1; j <= arr[i - 1] - 1; j++) {
                if (j <= sum) {
                    isSum[i][j] = isSum[i + 1][j];
                }
            }
            for (int j = arr[i - 1]; j <= sum; j++) {
                isSum[i][j] = (isSum[i + 1][j] || isSum[i + 1][j - arr[i - 1]]);
            }
        }

        return isSum[1][sum];
    }
}
package com.thealgorithms.dynamicprogramming;

public class Sum_Of_Subset {

    public static void main(String[] args) {

        int[] arr = {7, 3, 2, 5, 8};
        int Key = 14;

        if (subsetSum(arr, arr.length - 1, Key)) {
            System.out.print("Yes, that sum exists");
        } else {
            System.out.print("Nope, that number does not exist");
        }
    }

    public static boolean subsetSum(int[] arr, int num, int Key) {
        if (Key == 0) {
            return true;
        }
        if (num < 0 || Key < 0) {
            return false;
        }

        boolean include = subsetSum(arr, num - 1, Key - arr[num]);
        boolean exclude = subsetSum(arr, num - 1, Key);

        return include || exclude;
    }
}
package com.thealgorithms.dynamicprogramming;

/*
Given the following grid with length m and width n:
\---\---\---\ (n)
\ 1 \ 3 \ 1 \
\---\---\---\
\ 1 \ 5 \ 1 \
\---\---\---\
\ 4 \ 2 \ 1 \
\---\---\---\
(m)
Find the path where its sum is the smallest.

All numbers given are positive.
The Time Complexity of your algorithm should be smaller than or equal to O(mn).
The Space Complexity of your algorithm should be smaller than or equal to O(mn).
You can only move from the top left corner to the down right corner.
You can only move one step down or right.

EXAMPLE:
INPUT: grid = [[1,3,1],[1,5,1],[4,2,1]]
OUTPUT: 7
EXPLANATIONS: 1 + 3 + 1 + 1 + 1 = 7

For more information see https://www.geeksforgeeks.org/maximum-path-sum-matrix/
 */
public class MinimumPathSum {

    public void testRegular() {
        int[][] grid = {
            {1, 3, 1},
            {1, 5, 1},
            {4, 2, 1}
        };
        System.out.println(minimumPathSum(grid));
    }

    public void testLessColumns() {
        int[][] grid = {
            {1, 2},
            {5, 6},
            {1, 1}
        };
        System.out.println(minimumPathSum(grid));
    }

    public void testLessRows() {
        int[][] grid = {
            {2, 3, 3},
            {7, 2, 1}
        };
        System.out.println(minimumPathSum(grid));
    }

    public void testOneRowOneColumn() {
        int[][] grid = {{2}};
        System.out.println(minimumPathSum(grid));
    }

    public static int minimumPathSum(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        if (n == 0) {
            return 0;
        }
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        for (int i = 0; i < n - 1; i++) {
            dp[0][i + 1] = dp[0][i] + grid[0][i + 1];
        }
        for (int i = 0; i < m - 1; i++) {
            dp[i + 1][0] = dp[i][0] + grid[i + 1][0];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[m - 1][n - 1];
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.Scanner;

/**
 * @author Afrizal Fikri (https://github.com/icalF)
 */
public class LongestIncreasingSubsequence {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        System.out.println(LIS(arr));
        System.out.println(findLISLen(arr));
        sc.close();
    }

    private static int upperBound(int[] ar, int l, int r, int key) {
        while (l < r - 1) {
            int m = (l + r) >>> 1;
            if (ar[m] >= key) {
                r = m;
            } else {
                l = m;
            }
        }

        return r;
    }

    private static int LIS(int[] array) {
        int N = array.length;
        if (N == 0) {
            return 0;
        }

        int[] tail = new int[N];

        // always points empty slot in tail
        int length = 1;

        tail[0] = array[0];
        for (int i = 1; i < N; i++) {

            // new smallest value
            if (array[i] < tail[0]) {
                tail[0] = array[i];
            } // array[i] extends largest subsequence
            else if (array[i] > tail[length - 1]) {
                tail[length++] = array[i];
            } // array[i] will become end candidate of an existing subsequence or
            // Throw away larger elements in all LIS, to make room for upcoming grater elements than
            // array[i]
            // (and also, array[i] would have already appeared in one of LIS, identify the location and
            // replace it)
            else {
                tail[upperBound(tail, -1, length - 1, array[i])] = array[i];
            }
        }

        return length;
    }

    /**
     * @author Alon Firestein (https://github.com/alonfirestein)
     */
    // A function for finding the length of the LIS algorithm in O(nlogn) complexity.
    public static int findLISLen(int a[]) {
        int size = a.length;
        int arr[] = new int[size];
        arr[0] = a[0];
        int lis = 1;
        for (int i = 1; i < size; i++) {
            int index = binarySearchBetween(arr, lis, a[i]);
            arr[index] = a[i];
            if (index > lis) {
                lis++;
            }
        }
        return lis;
    }
    // O(logn)

    private static int binarySearchBetween(int[] t, int end, int key) {
        int left = 0;
        int right = end;
        if (key < t[0]) {
            return 0;
        }
        if (key > t[end]) {
            return end + 1;
        }
        while (left < right - 1) {
            int middle = (left + right) / 2;
            if (t[middle] < key) {
                left = middle;
            } else {
                right = middle;
            }
        }
        return right;
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.Scanner;

/**
 * Given a string containing just the characters '(' and ')', find the length of
 * the longest valid (well-formed) parentheses substring.
 *
 * @author Libin Yang (https://github.com/yanglbme)
 * @since 2018/10/5
 */
public class LongestValidParentheses {

    public static int getLongestValidParentheses(String s) {
        if (s == null || s.length() < 2) {
            return 0;
        }
        char[] chars = s.toCharArray();
        int n = chars.length;
        int[] res = new int[n];
        res[0] = 0;
        res[1] = chars[1] == ')' && chars[0] == '(' ? 2 : 0;

        int max = res[1];

        for (int i = 2; i < n; ++i) {
            if (chars[i] == ')') {
                if (chars[i - 1] == '(') {
                    res[i] = res[i - 2] + 2;
                } else {
                    int index = i - res[i - 1] - 1;
                    if (index >= 0 && chars[index] == '(') {
                        // ()(())
                        res[i] = res[i - 1] + 2 + (index - 1 >= 0 ? res[index - 1] : 0);
                    }
                }
            }
            max = Math.max(max, res[i]);
        }

        return max;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        while (true) {
            String str = sc.nextLine();
            if ("quit".equals(str)) {
                break;
            }

            System.out.println("Len is: " + getLongestValidParentheses(str));
        }

        sc.close();
    }
}
/** Author : Siddhant Swarup Mallick
 * Github : https://github.com/siddhant2002
 */

/** Program description - To find the maximum subarray sum */
 package com.thealgorithms.dynamicprogramming;

public class KadaneAlgorithm {
    public static boolean max_Sum(int a[] , int predicted_answer)
    {
        int sum=a[0],running_sum=0;
        for(int k:a)
        {
            running_sum=running_sum+k;
            // running sum of all the indexs are stored
            sum=Math.max(sum,running_sum);
            // the max is stored inorder to the get the maximum sum
            if(running_sum<0)
            running_sum=0;
            // if running sum is negative then it is initialized to zero
        }
        // for-each loop is used to iterate over the array and find the maximum subarray sum
        return sum==predicted_answer;
        // It returns true if sum and predicted answer matches
        // The predicted answer is the answer itself. So it always return true
    }
    /**
     * OUTPUT :
     * Input - {89,56,98,123,26,75,12,40,39,68,91}
     * Output: it returns either true or false
     * 1st approach Time Complexity : O(n)
     * Auxiliary Space Complexity : O(1)
     */
}package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.less;
import static com.thealgorithms.sorts.SortUtils.print;

class InsertionSort implements SortAlgorithm {

    /**
     * Generic insertion sort algorithm in increasing order.
     *
     * @param array the array to be sorted.
     * @param <T> the class of array.
     * @return sorted array.
     */
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        for (int i = 1; i < array.length; i++) {
            T insertValue = array[i];
            int j;
            for (j = i - 1; j >= 0 && less(insertValue, array[j]); j--) {
                array[j + 1] = array[j];
            }
            if (j != i - 1) {
                array[j + 1] = insertValue;
            }
        }
        return array;
    }

    /**
     * Driver Code
     */
    public static void main(String[] args) {
        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        InsertionSort sort = new InsertionSort();
        sort.sort(integers);
        print(integers);
        /* [1, 4, 6, 9, 12, 23, 54, 78, 231] */

        String[] strings = {"c", "a", "e", "b", "d"};
        sort.sort(strings);
        print(strings);
        /* [a, b, c, d, e] */
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

/**
 * The idea of Swap-Sort is to count the number m of smaller values (that are in
 * A) from each element of an array A(1...n) and then swap the element with the
 * element in A(m+1). This ensures that the exchanged element is already in the
 * correct, i.e. final, position. The disadvantage of this algorithm is that
 * each element may only occur once, otherwise there is no termination.
 */
public class SwapSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        int LENGTH = array.length;
        int index = 0;

        while (index < LENGTH - 1) {
            int amountSmallerElements = this.getSmallerElementCount(array, index);

            if (amountSmallerElements > 0 && index != amountSmallerElements) {
                T element = array[index];
                array[index] = array[amountSmallerElements];
                array[amountSmallerElements] = element;
            } else {
                index++;
            }
        }

        return array;
    }

    private <T extends Comparable<T>> int getSmallerElementCount(T[] array, int index) {
        int counter = 0;
        for (int i = 0; i < array.length; i++) {
            if (less(array[i], array[index])) {
                counter++;
            }
        }

        return counter;
    }

    public static void main(String[] args) {
        // ==== Int =======
        Integer[] a = {3, 7, 45, 1, 33, 5, 2, 9};
        System.out.print("unsorted: ");
        print(a);
        System.out.println();

        new SwapSort().sort(a);
        System.out.print("sorted: ");
        print(a);
        System.out.println();

        // ==== String =======
        String[] b = {"banana", "berry", "orange", "grape", "peach", "cherry", "apple", "pineapple"};
        System.out.print("unsorted: ");
        print(b);
        System.out.println();

        new SwapSort().sort(b);
        System.out.print("sorted: ");
        print(b);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

public class CircleSort implements SortAlgorithm {

    /* This method implements the circle sort
    * @param array The array to be sorted 
     */
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        int n = array.length;
        while (doSort(array, 0, n - 1));
        return array;
    }

    /* This method implements the cyclic sort recursive version
    * @param array The array to be sorted
    * @param the left boundary of the part currently being sorted
    * @param the right boundary of the part currently being sorted
     */
    private <T extends Comparable<T>> Boolean doSort(T[] array, int left, int right) {
        Boolean swapped = false;

        if (left == right) {
            return false;
        }

        int low = left;
        int high = right;

        while (low < high) {
            if (array[low].compareTo(array[high]) > 0) {
                swap(array, low, high);
                swapped = true;
            }
            low++;
            high--;
        }

        if (low == high && array[low].compareTo(array[high + 1]) > 0) {
            swap(array, low, high + 1);
            swapped = true;
        }

        int mid = left + (right - left) / 2;
        Boolean leftHalf = doSort(array, left, mid);
        Boolean rightHalf = doSort(array, mid + 1, right);

        return swapped || leftHalf || rightHalf;
    }

    /* Driver code*/
    public static void main(String[] args) {
        CircleSort CSort = new CircleSort();

        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        CSort.sort(arr);
        for (int i = 0; i < arr.length - 1; ++i) {
            assert arr[i] <= arr[i + 1];
        }

        String[] stringArray = {"c", "a", "e", "b", "d"};
        CSort.sort(stringArray);
        for (int i = 0; i < stringArray.length - 1; ++i) {
            assert arr[i].compareTo(arr[i + 1]) <= 0;
        }
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;

import static com.thealgorithms.maths.Ceil.ceil;
import static com.thealgorithms.maths.Floor.floor;
import static com.thealgorithms.searches.QuickSelect.select;

/**
 * A wiggle sort implementation based on John L.s' answer in
 * https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity
 * Also have a look at: https://cs.stackexchange.com/questions/125372/how-to-wiggle-sort-an-array-in-linear-time-complexity?noredirect=1&lq=1
 * Not all arrays are wiggle-sortable. This algorithm will find some obviously not wiggle-sortable arrays and throw an error,
 * but there are some exceptions that won't be caught, for example [1, 2, 2].
 */
public class WiggleSort implements SortAlgorithm {
    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        return wiggleSort(unsorted);
    }

    private int mapIndex(int index, int n) {
        return ((2 * index + 1) % (n | 1));
    }

    /**
     * Modified Dutch National Flag Sort. See also: sorts/DutchNationalFlagSort
     *
     * @param sortThis array to sort into group "greater", "equal" and "smaller" than median
     * @param median   defines the groups
     * @param <T>      extends interface Comparable
     */
    private <T extends Comparable<T>> void triColorSort(T[] sortThis, T median) {
        int n = sortThis.length;
        int i = 0;
        int j = 0;
        int k = n - 1;
        while (j <= k) {
            if (0 < sortThis[mapIndex(j, n)].compareTo(median)) {
                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(i, n));
                i++;
                j++;
            } else if (0 > sortThis[mapIndex(j, n)].compareTo(median)) {
                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(k, n));
                k--;
            } else {
                j++;
            }
        }
    }

    private <T extends Comparable<T>> T[] wiggleSort(T[] sortThis) {
        // find the median using quickSelect (if the result isn't in the array, use the next greater value)
        T median;

        median = select(Arrays.<T>asList(sortThis), (int) floor(sortThis.length / 2.0));

        int numMedians = 0;

        for (T sortThi : sortThis) {
            if (0 == sortThi.compareTo(median)) {
                numMedians++;
            }
        }
        // added condition preventing off-by-one errors for odd arrays.
        // https://cs.stackexchange.com/questions/150886/how-to-find-wiggle-sortable-arrays-did-i-misunderstand-john-l-s-answer?noredirect=1&lq=1
        if (sortThis.length % 2 == 1 && numMedians == ceil(sortThis.length / 2.0)) {
            T smallestValue = select(Arrays.asList(sortThis), 0);
            if (!(0 == smallestValue.compareTo(median))) {
                throw new IllegalArgumentException("For odd Arrays if the median appears ceil(n/2) times, " +
                        "the median has to be the smallest values in the array.");
            }
        }
        if (numMedians > ceil(sortThis.length / 2.0)) {
            throw new IllegalArgumentException("No more than half the number of values may be the same.");

        }

        triColorSort(sortThis, median);
        return sortThis;
    }
}package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Heap Sort Algorithm Implements MinHeap
 *
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 */
public class HeapSort implements SortAlgorithm {

    private static class Heap<T extends Comparable<T>> {

        /**
         * Array to store heap
         */
        private T[] heap;

        /**
         * Constructor
         *
         * @param heap array of unordered integers
         */
        public Heap(T[] heap) {
            this.heap = heap;
        }

        /**
         * Heapifies subtree from top as root to last as last child
         *
         * @param rootIndex index of root
         * @param lastChild index of last child
         */
        private void heapSubtree(int rootIndex, int lastChild) {
            int leftIndex = rootIndex * 2 + 1;
            int rightIndex = rootIndex * 2 + 2;
            T root = heap[rootIndex];
            if (rightIndex <= lastChild) { // if has right and left children
                T left = heap[leftIndex];
                T right = heap[rightIndex];
                if (less(left, right) && less(left, root)) {
                    swap(heap, leftIndex, rootIndex);
                    heapSubtree(leftIndex, lastChild);
                } else if (less(right, root)) {
                    swap(heap, rightIndex, rootIndex);
                    heapSubtree(rightIndex, lastChild);
                }
            } else if (leftIndex <= lastChild) { // if no right child, but has left child
                T left = heap[leftIndex];
                if (less(left, root)) {
                    swap(heap, leftIndex, rootIndex);
                    heapSubtree(leftIndex, lastChild);
                }
            }
        }

        /**
         * Makes heap with root as root
         *
         * @param root index of root of heap
         */
        private void makeMinHeap(int root) {
            int leftIndex = root * 2 + 1;
            int rightIndex = root * 2 + 2;
            boolean hasLeftChild = leftIndex < heap.length;
            boolean hasRightChild = rightIndex < heap.length;
            if (hasRightChild) { // if has left and right
                makeMinHeap(leftIndex);
                makeMinHeap(rightIndex);
                heapSubtree(root, heap.length - 1);
            } else if (hasLeftChild) {
                heapSubtree(root, heap.length - 1);
            }
        }

        /**
         * Gets the root of heap
         *
         * @return root of heap
         */
        private T getRoot(int size) {
            swap(heap, 0, size);
            heapSubtree(0, size - 1);
            return heap[size]; // return old root
        }
    }

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        return sort(Arrays.asList(unsorted)).toArray(unsorted);
    }

    @Override
    public <T extends Comparable<T>> List<T> sort(List<T> unsorted) {
        int size = unsorted.size();

        @SuppressWarnings("unchecked")
        Heap<T> heap = new Heap<>(unsorted.toArray((T[]) new Comparable[unsorted.size()]));

        heap.makeMinHeap(0); // make min heap using index 0 as root.
        List<T> sorted = new ArrayList<>(size);
        while (size > 0) {
            T min = heap.getRoot(--size);
            sorted.add(min);
        }

        return sorted;
    }

    /**
     * Main method
     *
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        Integer[] heap = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        HeapSort heapSort = new HeapSort();
        print(heapSort.sort(heap));
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

public class ShellSort implements SortAlgorithm {

    /**
     * Implements generic shell sort.
     *
     * @param array the array to be sorted.
     * @param <T> the type of elements in the array.
     * @return the sorted array.
     */
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        int length = array.length;
        int gap = 1;

        /* Calculate gap for optimization purpose */
        while (gap < length / 3) {
            gap = 3 * gap + 1;
        }

        for (; gap > 0; gap /= 3) {
            for (int i = gap; i < length; i++) {
                int j;
                T temp = array[i];
                for (j = i; j >= gap && less(temp, array[j - gap]); j -= gap) {
                    array[j] = array[j - gap];
                }
                array[j] = temp;
            }
        }
        return array;
    }

    /* Driver Code */
    public static void main(String[] args) {
        Integer[] toSort = {4, 23, 6, 78, 1, 54, 231, 9, 12};

        ShellSort sort = new ShellSort();
        sort.sort(toSort);
        for (int i = 0; i < toSort.length - 1; ++i) {
            assert toSort[i] <= toSort[i + 1];
        }
        print(toSort);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.less;
import static com.thealgorithms.sorts.SortUtils.print;

/**
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 */
class CycleSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] arr) {
        int n = arr.length;

        // traverse array elements
        for (int j = 0; j <= n - 2; j++) {
            // initialize item as starting point
            T item = arr[j];

            // Find position where we put the item.
            int pos = j;
            for (int i = j + 1; i < n; i++) {
                if (less(arr[i], item)) {
                    pos++;
                }
            }

            // If item is already in correct position
            if (pos == j) {
                continue;
            }

            // ignore all duplicate elements
            while (item.compareTo(arr[pos]) == 0) {
                pos += 1;
            }

            // put the item to it's right position
            if (pos != j) {
                item = replace(arr, pos, item);
            }

            // Rotate rest of the cycle
            while (pos != j) {
                pos = j;

                // Find position where we put the element
                for (int i = j + 1; i < n; i++) {
                    if (less(arr[i], item)) {
                        pos += 1;
                    }
                }

                // ignore all duplicate elements
                while (item.compareTo(arr[pos]) == 0) {
                    pos += 1;
                }

                // put the item to it's right position
                if (item != arr[pos]) {
                    item = replace(arr, pos, item);
                }
            }
        }

        return arr;
    }

    private <T extends Comparable<T>> T replace(T[] arr, int pos, T item) {
        T temp = item;
        item = arr[pos];
        arr[pos] = temp;
        return item;
    }

    public static void main(String[] args) {
        Integer arr[] = {4, 23, 6, 78, 1, 26, 11, 23, 0, -6, 3, 54, 231, 9, 12};
        CycleSort cycleSort = new CycleSort();
        cycleSort.sort(arr);

        System.out.println("After sort : ");
        print(arr);
    }
}
package com.thealgorithms.sorts;

import java.util.Random;

/**
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 * @see SortAlgorithm
 */
public class BogoSort implements SortAlgorithm {

    private static final Random random = new Random();

    private static <T extends Comparable<T>> boolean isSorted(T[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            if (SortUtils.less(array[i + 1], array[i])) {
                return false;
            }
        }
        return true;
    }

    // Randomly shuffles the array
    private static <T> void nextPermutation(T[] array) {
        int length = array.length;

        for (int i = 0; i < array.length; i++) {
            int randomIndex = i + random.nextInt(length - i);
            SortUtils.swap(array, randomIndex, i);
        }
    }

    public <T extends Comparable<T>> T[] sort(T[] array) {
        while (!isSorted(array)) {
            nextPermutation(array);
        }
        return array;
    }

    // Driver Program
    public static void main(String[] args) {
        // Integer Input
        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};

        BogoSort bogoSort = new BogoSort();

        // print a sorted array
        SortUtils.print(bogoSort.sort(integers));

        // String Input
        String[] strings = {"c", "a", "e", "b", "d"};

        SortUtils.print(bogoSort.sort(strings));
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

/**
 * @author Varun Upadhyay (https://github.com/varunu28)
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 * @see SortAlgorithm
 */
class QuickSort implements SortAlgorithm {

    /**
     * This method implements the Generic Quick Sort
     *
     * @param array The array to be sorted Sorts the array in increasing order
     */
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        doSort(array, 0, array.length - 1);
        return array;
    }

    /**
     * The sorting process
     *
     * @param left The first index of an array
     * @param right The last index of an array
     * @param array The array to be sorted
     */
    private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {
        if (left < right) {
            int pivot = randomPartition(array, left, right);
            doSort(array, left, pivot - 1);
            doSort(array, pivot, right);
        }
    }

    /**
     * Ramdomize the array to avoid the basically ordered sequences
     *
     * @param array The array to be sorted
     * @param left The first index of an array
     * @param right The last index of an array
     * @return the partition index of the array
     */
    private static <T extends Comparable<T>> int randomPartition(T[] array, int left, int right) {
        int randomIndex = left + (int) (Math.random() * (right - left + 1));
        swap(array, randomIndex, right);
        return partition(array, left, right);
    }

    /**
     * This method finds the partition index for an array
     *
     * @param array The array to be sorted
     * @param left The first index of an array
     * @param right The last index of an array Finds the partition index of an
     * array
     */
    private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {
        int mid = (left + right) >>> 1;
        T pivot = array[mid];

        while (left <= right) {
            while (less(array[left], pivot)) {
                ++left;
            }
            while (less(pivot, array[right])) {
                --right;
            }
            if (left <= right) {
                swap(array, left, right);
                ++left;
                --right;
            }
        }
        return left;
    }

    // Driver Program
    public static void main(String[] args) {

        // For integer input
        Integer[] array = {3, 4, 1, 32, 0, 1, 5, 12, 2, 5, 7, 8, 9, 2, 44, 111, 5};

        QuickSort quickSort = new QuickSort();
        quickSort.sort(array);

        // Output => 0 1 1 2 2 3 4 5 5 5 7 8 9 12 32 44 111
        print(array);

        String[] stringArray = {"c", "a", "e", "b", "d"};
        quickSort.sort(stringArray);

        // Output => a	b	c	d	e
        print(stringArray);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.print;
import com.thealgorithms.datastructures.trees.BSTRecursiveGeneric;

import java.util.List;

/**
 * <h1> Implementation of the Tree Sort algorithm</h1>
 *
 * <p>
 * Tree Sort: A sorting algorithm which constructs a Binary Search Tree using
 * the unsorted data and then outputs the data by inorder traversal of the tree.
 *
 * Reference: https://en.wikipedia.org/wiki/Tree_sort
 * </p>
 *
 * @author Madhur Panwar (https://github.com/mdrpanwar)
 */
public class TreeSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {
        return doTreeSortArray(unsortedArray);
    }

    @Override
    public <T extends Comparable<T>> List<T> sort(List<T> unsortedList) {
        return doTreeSortList(unsortedList);
    }

    private <T extends Comparable<T>> T[] doTreeSortArray(T[] unsortedArray) {
        // create a generic BST tree
        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();

        // add all elements to the tree
        for (T element : unsortedArray) {
            tree.add(element);
        }

        // get the sorted list by inorder traversal of the tree
        List<T> sortedList = tree.inorderSort();

        // add the elements back to the initial array
        int i = 0;
        for (T element : sortedList) {
            unsortedArray[i++] = element;
        }

        // return the array
        return unsortedArray;
    }

    private <T extends Comparable<T>> List<T> doTreeSortList(List<T> unsortedList) {
        // create a generic BST tree
        BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();

        // add all elements to the tree
        for (T element : unsortedList) {
            tree.add(element);
        }

        // get the sorted list by inorder traversal of the tree and return it
        return tree.inorderSort();
    }

    public static void main(String[] args) {
        TreeSort treeSort = new TreeSort();

        // ==== Integer Array =======
        System.out.println("Testing for Integer Array....");
        Integer[] a = {3, -7, 45, 1, 343, -5, 2, 9};
        System.out.print(String.format("%-10s", "unsorted: "));
        print(a);
        a = treeSort.sort(a);
        System.out.print(String.format("%-10s", "sorted: "));
        print(a);
        System.out.println();

        // ==== Integer List =======
        System.out.println("Testing for Integer List....");
        List<Integer> intList = List.of(3, -7, 45, 1, 343, -5, 2, 9);
        System.out.print(String.format("%-10s", "unsorted: "));
        print(intList);
        intList = treeSort.sort(intList);
        System.out.print(String.format("%-10s", "sorted: "));
        print(intList);
        System.out.println();

        // ==== String Array =======
        System.out.println("Testing for String Array....");
        String[] b = {"banana", "berry", "orange", "grape", "peach", "cherry", "apple", "pineapple"};
        System.out.print(String.format("%-10s", "unsorted: "));
        print(b);
        b = treeSort.sort(b);
        System.out.print(String.format("%-10s", "sorted: "));
        print(b);
        System.out.println();

        // ==== String List =======
        System.out.println("Testing for String List....");
        List<String> stringList = List.of("banana", "berry", "orange", "grape", "peach", "cherry", "apple", "pineapple");
        System.out.print(String.format("%-10s", "unsorted: "));
        print(stringList);
        stringList = treeSort.sort(stringList);
        System.out.print(String.format("%-10s", "sorted: "));
        print(stringList);

    }

}
package com.thealgorithms.sorts;

import java.util.Random;

/**
 * @author [Hemanth Kotagiri](https://github.com/hemanth-kotagiri)
 * @see [Tim Sort](https://en.wikipedia.org/wiki/Tim_sort)
 */
class TimSort {

    int array[];
    int array_length;
    int RUN = 32;

    /**
     * @brief A constructor which takes in the array specified by the user.
     * @param array : Array given by the user.
     */
    public TimSort(int[] array) {
        this.array = array;
        this.array_length = array.length;
    }

    /**
     * @brief A constructor which takes in an array length and randomly
     * initializes an array.
     * @param array_length length given by the user.
     */
    public TimSort(int array_length) {
        Random rand = new Random();

        this.array_length = array_length;
        this.array = new int[this.array_length];

        for (int i = 0; i < this.array_length; i++) {
            int random_number = rand.nextInt(1000);
            this.array[i] = random_number;
        }
    }

    /**
     * @brief A method to change the size of the run.
     * @param run : Value specified by the user to change the run.
     */
    public void change_run(int run) {
        this.RUN = run;
    }

    /**
     * @brief A default constructor when no parameters are given. Initializes
     * the array length to be 100. Generates a random number array of size 100.
     */
    public TimSort() {
        this.array_length = 100;
        this.array = new int[this.array_length];

        Random rand = new Random();
        for (int i = 0; i < this.array_length; i++) {
            int random_number = rand.nextInt(1000);
            this.array[i] = random_number;
        }
    }

    /**
     * @brief Performs Insertion Sort Algorithm on given array with bounded
     * indices.
     * @param array: The array on which the algorithm is to be performed.
     * @param start_idx: The starting index from which the algorithm is to be
     * performed.
     * @param end_idx: The ending index at which the algorithm needs to stop
     * sorting.
     */
    public void insertion_sort(int[] array, int start_idx, int end_idx) {
        for (int i = start_idx; i <= end_idx; i++) {
            int current_element = array[i];
            int j = i - 1;
            while (j >= start_idx && array[j] > current_element) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = current_element;
        }
    }

    /**
     * @brief A method to merge two runs(chunks of array).
     * @param array: The origin array which is to be sorted.
     * @param start: Starting index of the first run(chunk).
     * @param mid: The ending index of the first run(chunk).
     * @param end: Ending index of the second run(chunk).
     */
    public void merge_runs(int array[], int start, int mid, int end) {

        int first_array_size = mid - start + 1, second_array_size = end - mid;
        int array1[] = new int[first_array_size], array2[] = new int[second_array_size];
        int i = 0, j = 0, k = 0;

        // Building the two sub arrays from the array to merge later
        for (i = 0; i < first_array_size; i++) {
            array1[i] = array[start + i];
        }
        for (i = 0; i < second_array_size; i++) {
            array2[i] = array[mid + 1 + i];
        }

        i = 0;
        j = 0;
        k = start;

        while (i < first_array_size && j < second_array_size) {
            if (array1[i] <= array2[j]) {
                array[k] = array1[i];
                i++;
            } else {
                array[k] = array2[j];
                j++;
            }
            k++;
        }

        while (i < first_array_size) {
            array[k] = array1[i];
            k++;
            i++;
        }

        while (j < second_array_size) {
            array[k] = array2[j];
            k++;
            j++;
        }
    }

    /**
     * @brief Tim Sort Algorithm method.
     */
    public void algorithm() {
        // Before Sorting
        System.out.println("Before sorting the array: ");
        this.showArrayElements();
        System.out.println();

        // Applying insertion sort on RUNS.
        for (int i = 0; i < this.array_length; i += this.RUN) {
            this.insertion_sort(this.array, i, Math.min(i + this.RUN, (this.array_length - 1)));
        }

        for (int split = this.RUN; split < this.array_length; split = 2 * split) {
            for (int start_idx = 0; start_idx < this.array_length; start_idx += 2 * split) {
                int mid = start_idx + split - 1;
                int end_idx = Math.min((start_idx + 2 * split - 1), (this.array_length - 1));

                this.merge_runs(this.array, start_idx, mid, end_idx);
            }
        }
        // After sorting
        System.out.println("After sorting the array: ");
        this.showArrayElements();
        System.out.println();
    }

    /**
     * @brief A method to show the elements inside the array.
     */
    public void showArrayElements() {
        for (int i = 0; i < this.array.length; i++) {
            System.out.print(this.array[i] + " ");
        }
        System.out.println();
    }

    /**
     * @brief A method to test the sorting algorithm
     */
    static void test() {
        int[] array = {4, 1, 3, 17, 12, 11, 8};
        TimSort sorterObj1 = new TimSort();
        TimSort sorterObj2 = new TimSort(50);
        TimSort sorterObj3 = new TimSort(array);

        sorterObj1.algorithm();
        sorterObj2.algorithm();
        sorterObj3.algorithm();

        // Testing the first array
        for (int i = 0; i < sorterObj1.array_length - 1; i++) {
            assert ((sorterObj1.array[i] <= sorterObj1.array[i + 1])) : "Array is not sorted";
        }

        // Testing the second array.
        for (int i = 0; i < sorterObj2.array_length - 1; i++) {
            assert ((sorterObj2.array[i] <= sorterObj2.array[i + 1])) : "Array is not sorted";
        }

        // Testing the third array.
        for (int i = 0; i < sorterObj3.array_length - 1; i++) {
            assert ((sorterObj3.array[i] <= sorterObj3.array[i + 1])) : "Array is not sorted";
        }
    }

    public static void main(String[] args) {
        test();
    }
}
package com.thealgorithms.sorts;

import java.util.*;
import static com.thealgorithms.sorts.SortUtils.*;

public class PigeonholeSort {
    /*
        This code implements the pigeonhole sort algorithm for the integer array,
        but we can also implement this for string arrays too.
        See https://www.geeksforgeeks.org/pigeonhole-sort/
    */
    void sort(Integer[] array){
        int maxElement = array[0];
        for (int element: array) {
            if (element > maxElement) maxElement = element;
        }

        int numOfPigeonholes = 1 + maxElement;
        ArrayList<Integer>[] pigeonHole =  new ArrayList[numOfPigeonholes];

        for (int k=0; k<numOfPigeonholes; k++) {
            pigeonHole[k] = new ArrayList<>();
        }

        for (int t: array) {
            pigeonHole[t].add(t);
        }

        int k=0;
        for (ArrayList<Integer> ph: pigeonHole) {
            for (int elements: ph) {
                array[k]=elements;
                k=k+1;
            }
        }
    }

    public static void main(String[] args)
    {
        PigeonholeSort pigeonholeSort = new PigeonholeSort();
        Integer[] arr = { 8, 3, 2, 7, 4, 6, 8 };

        System.out.print("Unsorted order is : ");
        print(arr);

        pigeonholeSort.sort(arr);
        
        System.out.print("Sorted order is : ");
        for (int i = 0; i < arr.length; i++) {
            assert (arr[i]) <= (arr[i+1]);
        }
        print(arr);
    }
}
package com.thealgorithms.sorts;

/**
 * @author Amir Hassan (https://github.com/ahsNT)
 * @see SortAlgorithm
 */
public class StoogeSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {
        sort(unsortedArray, 0, unsortedArray.length);
        return unsortedArray;
    }

    public <T extends Comparable<T>> T[] sort(T[] unsortedArray, int start, int end) {
        if (SortUtils.less(unsortedArray[end - 1], unsortedArray[start])) {
            T temp = unsortedArray[start];
            unsortedArray[start] = unsortedArray[end - 1];
            unsortedArray[end - 1] = temp;
        }

        int len = end - start;
        if (len > 2) {
            int third = len / 3;
            sort(unsortedArray, start, end - third);
            sort(unsortedArray, start + third, end);
            sort(unsortedArray, start, end - third);
        }
        return unsortedArray;
    }

    public static void main(String[] args) {
        StoogeSort stoogeSort = new StoogeSort();

        Integer[] integerArray = {8, 84, 53, 953, 64, 2, 202};
        // Print integerArray unsorted
        SortUtils.print(integerArray);

        stoogeSort.sort(integerArray);
        // Print integerArray sorted
        SortUtils.print(integerArray);

        String[] stringArray = {"g", "d", "a", "b", "f", "c", "e"};
        // Print stringArray unsorted
        SortUtils.print(stringArray);

        stoogeSort.sort(stringArray);
        // Print stringArray sorted
        SortUtils.print(stringArray);
    }
}
package com.thealgorithms.sorts;

import java.util.Random;

/**
 * BubbleSort algorithm implements using recursion
 */
public class BubbleSortRecursion implements SortAlgorithm {

    public static void main(String[] args) {
        Integer[] array = new Integer[10];

        Random random = new Random();
        /* generate 10 random numbers from -50 to 49 */
        for (int i = 0; i < array.length; ++i) {
            array[i] = random.nextInt(100) - 50;
        }

        BubbleSortRecursion bubbleSortRecursion = new BubbleSortRecursion();
        bubbleSortRecursion.sort(array);

        /* check array is sorted or not */
        for (int i = 0; i < array.length - 1; ++i) {
            assert (array[i].compareTo(array[i + 1]) <= 0);
        }
    }

    /**
     * @param unsorted - an array should be sorted
     * @return sorted array
     */
    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        bubbleSort(unsorted, unsorted.length);
        return unsorted;
    }

    /**
     * BubbleSort algorithm implements using recursion
     *
     * @param unsorted array contains elements
     * @param len length of given array
     */
    private static <T extends Comparable<T>> void bubbleSort(T[] unsorted, int len) {
        boolean swapped = false;
        /* flag to check if array is sorted or not */
        for (int i = 0; i < len - 1; ++i) {
            if (SortUtils.greater(unsorted[i], unsorted[i + 1])) {
                SortUtils.swap(unsorted, i, i + 1);
                swapped = true;
            }
        }
        if (swapped) {
            bubbleSort(unsorted, len - 1);
        }
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;

class RadixSort {

    private static int getMax(int[] arr, int n) {
        int mx = arr[0];
        for (int i = 1; i < n; i++) {
            if (arr[i] > mx) {
                mx = arr[i];
            }
        }
        return mx;
    }

    private static void countSort(int[] arr, int n, int exp) {
        int[] output = new int[n];
        int i;
        int[] count = new int[10];
        Arrays.fill(count, 0);

        for (i = 0; i < n; i++) {
            count[(arr[i] / exp) % 10]++;
        }

        for (i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }

        for (i = n - 1; i >= 0; i--) {
            output[count[(arr[i] / exp) % 10] - 1] = arr[i];
            count[(arr[i] / exp) % 10]--;
        }

        for (i = 0; i < n; i++) {
            arr[i] = output[i];
        }
    }

    private static void radixsort(int[] arr, int n) {

        int m = getMax(arr, n);

        for (int exp = 1; m / exp > 0; exp *= 10) {
            countSort(arr, n, exp);
        }
    }

    static void print(int[] arr, int n) {
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }
    }

    public static void main(String[] args) {
        int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};
        int n = arr.length;
        radixsort(arr, n);
        print(arr, n);
    }
}
// Written by James Mc Dermott(theycallmemac)
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

/**
 * Comb Sort algorithm implementation
 *
 * <p>
 * Best-case performance O(n * log(n)) Worst-case performance O(n ^ 2)
 * Worst-case space complexity O(1)
 *
 * <p>
 * Comb sort improves on bubble sort.
 *
 * @author Sandeep Roy (https://github.com/sandeeproy99)
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 * @see BubbleSort
 * @see SortAlgorithm
 */
class CombSort implements SortAlgorithm {

    // To find gap between elements
    private int nextGap(int gap) {
        // Shrink gap by Shrink factor
        gap = (gap * 10) / 13;
        return (gap < 1) ? 1 : gap;
    }

    /**
     * Function to sort arr[] using Comb
     *
     * @param arr - an array should be sorted
     * @return sorted array
     */
    @Override
    public <T extends Comparable<T>> T[] sort(T[] arr) {
        int size = arr.length;

        // initialize gap
        int gap = size;

        // Initialize swapped as true to make sure that loop runs
        boolean swapped = true;

        // Keep running while gap is more than 1 and last iteration caused a swap
        while (gap != 1 || swapped) {
            // Find next gap
            gap = nextGap(gap);

            // Initialize swapped as false so that we can check if swap happened or not
            swapped = false;

            // Compare all elements with current gap
            for (int i = 0; i < size - gap; i++) {
                if (less(arr[i + gap], arr[i])) {
                    // Swap arr[i] and arr[i+gap]
                    swapped = swap(arr, i, i + gap);
                }
            }
        }
        return arr;
    }

    // Driver method
    public static void main(String[] args) {
        CombSort ob = new CombSort();
        Integer[] arr = {8, 4, 1, 56, 3, -44, -1, 0, 36, 34, 8, 12, -66, -78, 23, -6, 28, 0};
        ob.sort(arr);

        System.out.println("sorted array");
        print(arr);
    }
}
package com.thealgorithms.sorts;

/**
 * @author Mateus Bizzo (https://github.com/MattBizzo)
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 */
class CocktailShakerSort implements SortAlgorithm {

    /**
     * This method implements the Generic Cocktail Shaker Sort
     *
     * @param array The array to be sorted Sorts the array in increasing order
     */
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {

        int length = array.length;
        int left = 0;
        int right = length - 1;
        int swappedLeft, swappedRight;
        while (left < right) {
            // front
            swappedRight = 0;
            for (int i = left; i < right; i++) {
                if (SortUtils.less(array[i + 1], array[i])) {
                    SortUtils.swap(array, i, i + 1);
                    swappedRight = i;
                }
            }
            // back
            right = swappedRight;
            swappedLeft = length - 1;
            for (int j = right; j > left; j--) {
                if (SortUtils.less(array[j], array[j - 1])) {
                    SortUtils.swap(array, j - 1, j);
                    swappedLeft = j;
                }
            }
            left = swappedLeft;
        }
        return array;
    }

    // Driver Program
    public static void main(String[] args) {
        // Integer Input
        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        CocktailShakerSort shakerSort = new CocktailShakerSort();

        // Output => 1 4 6 9 12 23 54 78 231
        SortUtils.print(shakerSort.sort(integers));

        // String Input
        String[] strings = {"c", "a", "e", "b", "d"};
        SortUtils.print(shakerSort.sort(strings));
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;
import java.util.*;

/*This code implements the mergeSort algorithm without extra space
For understanding about mergesort visit :https://www.geeksforgeeks.org/merge-sort/
 */
public class MergeSortNoExtraSpace {

    public static void call_merge_sort(int a[], int n) {
        int maxele = Arrays.stream(a).max().getAsInt() + 1;
        merge_sort(a, 0, n - 1, maxele);
    }

    public static void merge_sort(int a[], int start, int end, int maxele) { //this function divides the array into 2 halves

        if (start < end) {
            int mid = (start + end) / 2;
            merge_sort(a, start, mid, maxele);
            merge_sort(a, mid + 1, end, maxele);
            implement_merge_sort(a, start, mid, end, maxele);

        }
    }

    public static void implement_merge_sort(int a[], int start, int mid, int end, int maxele) {  //implementation of mergesort
        int i = start;
        int j = mid + 1;
        int k = start;
        while (i <= mid && j <= end) {
            if (a[i] % maxele <= a[j] % maxele) {
                a[k] = a[k] + (a[i]
                        % maxele) * maxele;
                k++;
                i++;
            } else {
                a[k] = a[k] + (a[j]
                        % maxele) * maxele;
                k++;
                j++;
            }
        }
        while (i <= mid) {
            a[k] = a[k] + (a[i]
                    % maxele) * maxele;
            k++;
            i++;
        }
        while (j <= end) {
            a[k] = a[k] + (a[j]
                    % maxele) * maxele;
            k++;
            j++;
        }
        for (i = start; i <= end; i++) {
            a[i] = a[i] / maxele;
        }

    }

    public static void main(String args[]) {
        Scanner inp = new Scanner(System.in);
        System.out.println("Enter array size");
        int n = inp.nextInt();
        int a[] = new int[n];
        System.out.println("Enter array elements");
        for (int i = 0; i < n; i++) {
            a[i] = inp.nextInt();
        }
        call_merge_sort(a, n);
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
    }
}
package com.thealgorithms.sorts;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

/**
 * Wikipedia: https://en.wikipedia.org/wiki/Bucket_sort
 */
public class BucketSort {

    public static void main(String[] args) {
        int[] arr = new int[10];

        /* generate 10 random numbers from -50 to 49 */
        Random random = new Random();
        for (int i = 0; i < arr.length; ++i) {
            arr[i] = random.nextInt(100) - 50;
        }

        bucketSort(arr);

        /* check array is sorted or not */
        for (int i = 0, limit = arr.length - 1; i < limit; ++i) {
            assert arr[i] <= arr[i + 1];
        }
    }

    /**
     * BucketSort algorithms implements
     *
     * @param arr the array contains elements
     */
    private static void bucketSort(int[] arr) {
        /* get max value of arr */
        int max = max(arr);

        /* get min value of arr */
        int min = min(arr);

        /* number of buckets */
        int numberOfBuckets = max - min + 1;

        List<List<Integer>> buckets = new ArrayList<>(numberOfBuckets);

        /* init buckets */
        for (int i = 0; i < numberOfBuckets; ++i) {
            buckets.add(new ArrayList<>());
        }

        /* store elements to buckets */
        for (int value : arr) {
            int hash = hash(value, min, numberOfBuckets);
            buckets.get(hash).add(value);
        }

        /* sort individual bucket */
        for (List<Integer> bucket : buckets) {
            Collections.sort(bucket);
        }

        /* concatenate buckets to origin array */
        int index = 0;
        for (List<Integer> bucket : buckets) {
            for (int value : bucket) {
                arr[index++] = value;
            }
        }
    }

    /**
     * Get index of bucket which of our elements gets placed into it.
     *
     * @param elem the element of array to be sorted
     * @param min min value of array
     * @param numberOfBucket the number of bucket
     * @return index of bucket
     */
    private static int hash(int elem, int min, int numberOfBucket) {
        return (elem - min) / numberOfBucket;
    }

    /**
     * Calculate max value of array
     *
     * @param arr the array contains elements
     * @return max value of given array
     */
    public static int max(int[] arr) {
        int max = arr[0];
        for (int value : arr) {
            if (value > max) {
                max = value;
            }
        }
        return max;
    }

    /**
     * Calculate min value of array
     *
     * @param arr the array contains elements
     * @return min value of given array
     */
    public static int min(int[] arr) {
        int min = arr[0];
        for (int value : arr) {
            if (value < min) {
                min = value;
            }
        }
        return min;
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

public class MergeSortRecursive {

    List<Integer> arr;

    public MergeSortRecursive(List<Integer> arr) {
        this.arr = arr;
    }

    public void mergeSort() {
        List<Integer> arrSorted = merge(arr);
        System.out.println(arrSorted);
    }

    private static List<Integer> merge(List<Integer> arr) {

        // base condition
        if (arr.size() <= 1) {
            return arr;
        }

        int arrLength = arr.size();
        int half = arrLength / 2;
        List<Integer> arrA = arr.subList(0, half);
        List<Integer> arrB = arr.subList(half, arr.size());

        // recursion
        arrA = merge(arrA);
        arrB = merge(arrB);

        return sort(arrA, arrB);
    }

    private static List<Integer> sort(List<Integer> unsortedA, List<Integer> unsortedB) {
        if (unsortedA.size() <= 0 && unsortedB.size() <= 0) {
            return new ArrayList<>();
        }
        if (unsortedA.size() <= 0) {
            return unsortedB;
        }
        if (unsortedB.size() <= 0) {
            return unsortedA;
        }
        if (unsortedA.get(0) <= unsortedB.get(0)) {
            List<Integer> newAl = new ArrayList<Integer>() {
                {
                    add(unsortedA.get(0));
                }
            };
            newAl.addAll(sort(unsortedA.subList(1, unsortedA.size()), unsortedB));
            return newAl;
        } else {
            List<Integer> newAl = new ArrayList<Integer>() {
                {
                    add(unsortedB.get(0));
                }
            };
            newAl.addAll(sort(unsortedA, unsortedB.subList(1, unsortedB.size())));
            return newAl;
        }
    }

}

class App {

    public static void main(String[] args) {
        MergeSortRecursive sort = new MergeSortRecursive(new ArrayList<>(Arrays.asList(4, 3, 1, 8, 5, 10, 0, 1, 4, 11, 8, 9)));
        sort.mergeSort();
    }
}
package com.thealgorithms.sorts;

/**
 * @author Amir Hassan (https://github.com/ahsNT)
 * @see SortAlgorithm
 */
public class SlowSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {
        sort(unsortedArray, 0, unsortedArray.length - 1);
        return unsortedArray;
    }

    private <T extends Comparable<T>> void sort(T[] array, int i, int j) {
        if (SortUtils.greaterOrEqual(i, j)) {
            return;
        }
        int m = (i + j) / 2;
        sort(array, i, m);
        sort(array, m + 1, j);
        if (SortUtils.less(array[j], array[m])) {
            T temp = array[j];
            array[j] = array[m];
            array[m] = temp;
        }
        sort(array, i, j - 1);
    }

    public static void main(String[] args) {
        SlowSort slowSort = new SlowSort();

        Integer[] integerArray = {8, 84, 53, 953, 64, 2, 202, 98};
        // Print integerArray unsorted
        SortUtils.print(integerArray);

        slowSort.sort(integerArray);
        // Print integerArray sorted
        SortUtils.print(integerArray);

        String[] stringArray = {"g", "d", "a", "b", "f", "c", "e"};
        // Print stringArray unsorted
        SortUtils.print(stringArray);

        slowSort.sort(stringArray);
        // Print stringArray sorted
        SortUtils.print(stringArray);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.print;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

import java.util.*;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * @author Youssef Ali (https://github.com/youssefAli11997)
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 */
class CountingSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        return sort(Arrays.asList(unsorted)).toArray(unsorted);
    }

    /**
     * This method implements the Generic Counting Sort
     *
     * @param list The list to be sorted
     * <p>
     * Sorts the list in increasing order The method uses list elements as keys
     * in the frequency map
     */
    @Override
    public <T extends Comparable<T>> List<T> sort(List<T> list) {

        Map<T, Integer> frequency = new TreeMap<>();
        // The final output array
        List<T> sortedArray = new ArrayList<>(list.size());

        // Counting the frequency of @param array elements
        list.forEach(v -> frequency.put(v, frequency.getOrDefault(v, 0) + 1));

        // Filling the sortedArray
        for (Map.Entry<T, Integer> element : frequency.entrySet()) {
            for (int j = 0; j < element.getValue(); j++) {
                sortedArray.add(element.getKey());
            }
        }

        return sortedArray;
    }

    /**
     * Stream Counting Sort The same as method {@link CountingSort#sort(List)} }
     * but this method uses stream API
     *
     * @param list The list to be sorted
     */
    private static <T extends Comparable<T>> List<T> streamSort(List<T> list) {
        return list.stream()
                .collect(toMap(k -> k, v -> 1, (v1, v2) -> v1 + v2, TreeMap::new))
                .entrySet()
                .stream()
                .flatMap(entry -> IntStream.rangeClosed(1, entry.getValue()).mapToObj(t -> entry.getKey()))
                .collect(toList());
    }

    // Driver Program
    public static void main(String[] args) {
        // Integer Input
        List<Integer> unsortedInts
                = Stream.of(4, 23, 6, 78, 1, 54, 23, 1, 9, 231, 9, 12).collect(toList());
        CountingSort countingSort = new CountingSort();

        System.out.println("Before Sorting:");
        print(unsortedInts);

        // Output => 1 1 4 6 9 9 12 23 23 54 78 231
        System.out.println("After Sorting:");
        print(countingSort.sort(unsortedInts));
        System.out.println("After Sorting By Streams:");
        print(streamSort(unsortedInts));

        System.out.println("\n------------------------------\n");

        // String Input
        List<String> unsortedStrings
                = Stream.of("c", "a", "e", "b", "d", "a", "f", "g", "c").collect(toList());

        System.out.println("Before Sorting:");
        print(unsortedStrings);

        // Output => a a b c c d e f g
        System.out.println("After Sorting:");
        print(countingSort.sort(unsortedStrings));

        System.out.println("After Sorting By Streams:");
        print(streamSort(unsortedStrings));
    }
}
package com.thealgorithms.sorts;

/**
 * Generic merge sort algorithm.
 *
 * @see SortAlgorithm
 */
class MergeSort implements SortAlgorithm {

    /**
     * Generic merge sort algorithm implements.
     *
     * @param unsorted the array which should be sorted.
     * @param <T> Comparable class.
     * @return sorted array.
     */
    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        doSort(unsorted, 0, unsorted.length - 1);
        return unsorted;
    }

    /**
     * @param arr the array to be sorted.
     * @param left the first index of the array.
     * @param right the last index of the array.
     */
    private static <T extends Comparable<T>> void doSort(T[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) >>> 1;
            doSort(arr, left, mid);
            doSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    /**
     * Merges two parts of an array.
     *
     * @param arr the array to be merged.
     * @param left the first index of the array.
     * @param mid the middle index of the array.
     * @param right the last index of the array merges two parts of an array in
     * increasing order.
     */
    private static <T extends Comparable<T>> void merge(T[] arr, int left, int mid, int right) {
        int length = right - left + 1;
        @SuppressWarnings("unchecked")
        T[] temp = (T[]) new Comparable[length];
        int i = left;
        int j = mid + 1;
        int k = 0;

        while (i <= mid && j <= right) {
            if (arr[i].compareTo(arr[j]) <= 0) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }

        while (i <= mid) {
            temp[k++] = arr[i++];
        }

        while (j <= right) {
            temp[k++] = arr[j++];
        }

        System.arraycopy(temp, 0, arr, left, length);
    }

    /**
     * Driver code
     */
    public static void main(String[] args) {
        MergeSort mergeSort = new MergeSort();

        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        mergeSort.sort(arr);
        for (int i = 0; i < arr.length - 1; ++i) {
            assert arr[i] <= arr[i + 1];
        }

        String[] stringArray = {"c", "a", "e", "b", "d"};
        mergeSort.sort(stringArray);
        for (int i = 0; i < stringArray.length - 1; ++i) {
            assert arr[i].compareTo(arr[i + 1]) <= 0;
        }
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;
import java.util.List;

/**
 * The common interface of most sorting algorithms
 *
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 */
public interface SortAlgorithm {

    /**
     * Main method arrays sorting algorithms
     *
     * @param unsorted - an array should be sorted
     * @return a sorted array
     */
    <T extends Comparable<T>> T[] sort(T[] unsorted);

    /**
     * Auxiliary method for algorithms what wanted to work with lists from JCF
     *
     * @param unsorted - a list should be sorted
     * @return a sorted list
     */
    @SuppressWarnings("unchecked")
    default <T extends Comparable<T>> List<T> sort(List<T> unsorted) {
        return Arrays.asList(sort(unsorted.toArray((T[]) new Comparable[unsorted.size()])));
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

/**
 * Implementation of gnome sort
 *
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 * @since 2018-04-10
 */
public class GnomeSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] arr) {
        int i = 1;
        int j = 2;
        while (i < arr.length) {
            if (less(arr[i - 1], arr[i])) {
                i = j++;
            } else {
                swap(arr, i - 1, i);
                if (--i == 0) {
                    i = j++;
                }
            }
        }

        return null;
    }

    public static void main(String[] args) {
        Integer[] integers = {4, 23, 6, 78, 1, 26, 11, 23, 0, -6, 3, 54, 231, 9, 12};
        String[] strings = {"c", "a", "e", "b", "d", "dd", "da", "zz", "AA", "aa", "aB", "Hb", "Z"};
        GnomeSort gnomeSort = new GnomeSort();

        gnomeSort.sort(integers);
        gnomeSort.sort(strings);

        System.out.println("After sort : ");
        print(integers);
        print(strings);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

/**
 * Implementation of pancake sort
 *
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 * @since 2018-04-10
 */
public class PancakeSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        int size = array.length;

        for (int i = 0; i < size; i++) {
            T max = array[0];
            int index = 0;
            for (int j = 0; j < size - i; j++) {
                if (less(max, array[j])) {
                    max = array[j];
                    index = j;
                }
            }
            flip(array, index, array.length - 1 - i);
        }
        return array;
    }

    public static void main(String[] args) {

        Integer[] arr = {
            10, 9, 8, 7, 6, 15, 14, 7, 4, 3, 8, 6, 3, 1, 2, -2, -5, -8, -3, -1, 13, 12, 11, 5, 4, 3, 2, 1
        };
        PancakeSort pancakeSort = new PancakeSort();
        System.out.println("After sorting:");
        pancakeSort.sort(arr);
        print(arr);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

public class SimpleSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        final int LENGTH = array.length;

        for (int i = 0; i < LENGTH; i++) {
            for (int j = i + 1; j < LENGTH; j++) {
                if (less(array[j], array[i])) {
                    T element = array[j];
                    array[j] = array[i];
                    array[i] = element;
                }
            }
        }

        return array;
    }

    public static void main(String[] args) {
        // ==== Int =======
        Integer[] a = {3, 7, 45, 1, 33, 5, 2, 9};
        System.out.print("unsorted: ");
        print(a);
        System.out.println();

        new SimpleSort().sort(a);
        System.out.print("sorted: ");
        print(a);
        System.out.println();

        // ==== String =======
        String[] b = {"banana", "berry", "orange", "grape", "peach", "cherry", "apple", "pineapple"};
        System.out.print("unsorted: ");
        print(b);
        System.out.println();

        new SimpleSort().sort(b);
        System.out.print("sorted: ");
        print(b);
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;
import java.util.List;

/**
 * The class contains util methods
 *
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 */
final class SortUtils {

    /**
     * Helper method for swapping places in array
     *
     * @param array The array which elements we want to swap
     * @param idx index of the first element
     * @param idy index of the second element
     */
    static <T> boolean swap(T[] array, int idx, int idy) {
        T swap = array[idx];
        array[idx] = array[idy];
        array[idy] = swap;
        return true;
    }

    /**
     * This method checks if first element is less than the other element
     *
     * @param v first element
     * @param w second element
     * @return true if the first element is less than the second element
     */
    static <T extends Comparable<T>> boolean less(T v, T w) {
        return v.compareTo(w) < 0;
    }

    /**
     * This method checks if first element is greater than the other element
     *
     * @param v first element
     * @param w second element
     * @return true if the first element is greater than the second element
     */
    static <T extends Comparable<T>> boolean greater(T v, T w) {
        return v.compareTo(w) > 0;
    }

    /**
     * This method checks if first element is greater than or equal the other
     * element
     *
     * @param v first element
     * @param w second element
     * @return true if the first element is greater than or equal the second
     * element
     */
    static <T extends Comparable<T>> boolean greaterOrEqual(T v, T w) {
        return v.compareTo(w) >= 0;
    }

    /**
     * Prints a list
     *
     * @param toPrint - a list which should be printed
     */
    static void print(List<?> toPrint) {
        toPrint.stream().map(Object::toString).map(str -> str + " ").forEach(System.out::print);

        System.out.println();
    }

    /**
     * Prints an array
     *
     * @param toPrint - an array which should be printed
     */
    static void print(Object[] toPrint) {
        System.out.println(Arrays.toString(toPrint));
    }

    /**
     * Swaps all position from {
     *
     * @param left} to @{
     * @param right} for {
     * @param array}
     *
     * @param array is an array
     * @param left is a left flip border of the array
     * @param right is a right flip border of the array
     */
    static <T extends Comparable<T>> void flip(T[] array, int left, int right) {
        while (left <= right) {
            swap(array, left++, right--);
        }
    }
}
package com.thealgorithms.sorts;

public class DNFSort {

    // Sort the input array, the array is assumed to
    // have values in {0, 1, 2}
    static void sort012(int a[], int arr_size) {
        int low = 0;
        int high = arr_size - 1;
        int mid = 0, temp = 0;
        while (mid <= high) {
            switch (a[mid]) {
                case 0: {
                    temp = a[low];
                    a[low] = a[mid];
                    a[mid] = temp;
                    low++;
                    mid++;
                    break;
                }
                case 1:
                    mid++;
                    break;
                case 2: {
                    temp = a[mid];
                    a[mid] = a[high];
                    a[high] = temp;
                    high--;
                    break;
                }
            }
        }
    }

    /* Utility function to print array arr[] */
    static void printArray(int arr[], int arr_size) {
        for (int i = 0; i < arr_size; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println("");
    }

    /*Driver function to check for above functions*/
    public static void main(String[] args) {
        int arr[] = {0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1};
        int arr_size = arr.length;
        sort012(arr, arr_size);
        System.out.println("Array after seggregation ");
        printArray(arr, arr_size);
    }
}
package com.thealgorithms.sorts;

/* Java program for Bitonic Sort. Note that this program
works only when size of input is a power of 2. */
public class BitonicSort {

    /* The parameter dir indicates the sorting direction,
  ASCENDING or DESCENDING; if (a[i] > a[j]) agrees
  with the direction, then a[i] and a[j] are
  interchanged. */
    void compAndSwap(int a[], int i, int j, int dir) {
        if ((a[i] > a[j] && dir == 1) || (a[i] < a[j] && dir == 0)) {
            // Swapping elements
            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
    }

    /* It recursively sorts a bitonic sequence in ascending
  order, if dir = 1, and in descending order otherwise
  (means dir=0). The sequence to be sorted starts at
  index position low, the parameter cnt is the number
  of elements to be sorted.*/
    void bitonicMerge(int a[], int low, int cnt, int dir) {
        if (cnt > 1) {
            int k = cnt / 2;
            for (int i = low; i < low + k; i++) {
                compAndSwap(a, i, i + k, dir);
            }
            bitonicMerge(a, low, k, dir);
            bitonicMerge(a, low + k, k, dir);
        }
    }

    /* This funcion first produces a bitonic sequence by
  recursively sorting its two halves in opposite sorting
  orders, and then calls bitonicMerge to make them in
  the same order */
    void bitonicSort(int a[], int low, int cnt, int dir) {
        if (cnt > 1) {
            int k = cnt / 2;

            // sort in ascending order since dir here is 1
            bitonicSort(a, low, k, 1);

            // sort in descending order since dir here is 0
            bitonicSort(a, low + k, k, 0);

            // Will merge whole sequence in ascending order
            // since dir=1.
            bitonicMerge(a, low, cnt, dir);
        }
    }

    /*Caller of bitonicSort for sorting the entire array
  of length N in ASCENDING order */
    void sort(int a[], int N, int up) {
        bitonicSort(a, 0, N, up);
    }

    /* A utility function to print array of size n */
    static void printArray(int arr[]) {
        int n = arr.length;
        for (int i = 0; i < n; ++i) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String args[]) {
        int a[] = {3, 7, 4, 8, 6, 2, 1, 5};
        int up = 1;
        BitonicSort ob = new BitonicSort();
        ob.sort(a, a.length, up);
        System.out.println("\nSorted array");
        printArray(a);
    }
}
/** Author : Siddhant Swarup Mallick
 * Github : https://github.com/siddhant2002
 */

/** Program description - To sort the LinkList as per sorting technique */

package com.thealgorithms.sorts;
import java.util.*;
public class LinkList_Sort {
    public static boolean isSorted(int p[] , int option) {
        try (Scanner sc = new Scanner(System.in)) {
        }
        int a[] = p;
        // Array is taken as input from test class
        int b[] = p;
        // array similar to a
        int ch = option;
        // Choice is choosed as any number from 1 to 3 (So the linked list will be sorted by Merge sort technique/Insertion sort technique/Heap sort technique)
        switch (ch) {
            case 1:
                Task nm = new Task();
                Node start = null, prev = null, fresh, ptr;
                for (int i = 0; i < a.length; i++) {
                    // New nodes are created and values are added
                    fresh = new Node(); // Node class is called
                    fresh.val = a[i]; // Node val is stored
                    if (start == null)
                        start = fresh;
                    else
                        prev.next = fresh;
                    prev = fresh;
                }
                start = nm.sort_by_mergesort(start);
                // method is being called
                int i=0;
                for (ptr = start;ptr != null; ptr = ptr.next) {
                    a[i++]=ptr.val;
                    // storing the sorted values in the array
                }
                Arrays.sort(b);
                // array b is sorted and it will return true when checked with sorted list
                LinkList_Sort uu=new LinkList_Sort();
                if(uu.compare(a,b))
                {
                    return true;
                }
                else
                {
                    return false;
                }
                // The given array and the expected array is checked if both are same then true is displayed else false is displayed
            case 2:
                Node start1 = null, prev1 = null, fresh1, ptr1;
                for (int i1 = 0; i1 < a.length; i1++) {
                    // New nodes are created and values are added
                    fresh1 = new Node(); // New node is created
                    fresh1.val = a[i1]; // Value is stored in the value part of the node
                    if (start1 == null)
                        start1 = fresh1;
                    else
                        prev1.next = fresh1;
                    prev1 = fresh1;
                }
                Task1 kk = new Task1();
                start1 = kk.sort_by_insertionsort(start1);
                // method is being called
                int i1=0;
                for (ptr1 = start1; ptr1 != null; ptr1 = ptr1.next) {
                    a[i1++]=ptr1.val;
                    // storing the sorted values in the array
                }
                LinkList_Sort uu1=new LinkList_Sort();
                // array b is not sorted and it will return false when checked with sorted list
                if(uu1.compare(a,b))
                {
                    return true;
                }
                else
                {
                    return false;
                }
                // The given array and the expected array is checked if both are same then true is displayed else false is displayed
            case 3:
                Task2 mm = new Task2();
                Node start2 = null, prev2 = null, fresh2, ptr2;
                for (int i2 = 0; i2 < a.length; i2++) {
                    // New nodes are created and values are added
                    fresh2 = new Node(); // Node class is created
                    fresh2.val = a[i2]; // Value is stored in the value part of the Node
                    if (start2 == null)
                        start2 = fresh2;
                    else
                        prev2.next = fresh2;
                    prev2 = fresh2;
                }
                start2 = mm.sort_by_heapsort(start2);
                // method is being called
                int i3=0;
                for (ptr2 = start2; ptr2 != null; ptr2 = ptr2.next) {
                    a[i3++]=ptr2.val;
                    // storing the sorted values in the array
                }
                Arrays.sort(b);
                // array b is sorted and it will return true when checked with sorted list
                LinkList_Sort uu2=new LinkList_Sort();
                if(uu2.compare(a,b))
                {
                    return true;
                }
                else
                {
                    return false;
                }
                // The given array and the expected array is checked if both are same then true is displayed else false is displayed
            default:
                // default is used incase user puts a unauthorized value
                System.out.println("Wrong choice");
        }
        // Switch case is used to call the classes as per the user requirement
        return false;
    }
    boolean compare(int a[] , int b[])
    {
        for(int i=0;i<a.length;i++)
        {
            if(a[i]!=b[i])
            return false;
        }
        return true;
        // Both the arrays are checked for equalness. If both are equal then true is returned else false is returned
    }
    /**
     * OUTPUT :
     * Input - {89,56,98,123,26,75,12,40,39,68,91} is same for all the 3 classes
     * Output: [12 26 39 40 56 68 75 89 91 98 123] is same for all the 3 classes
     * 1st approach Time Complexity : O(n logn)
     * Auxiliary Space Complexity : O(n)
     * 2nd approach Time Complexity : O(n^2)
     * Auxiliary Space Complexity : O(n)
     * 3rd approach Time Complexity : O(n logn)
     * Auxiliary Space Complexity : O(n)
     */
}

class Node {
    int val;
    Node next;
    // Node class for creation of linklist nodes
}

class Task {
    static int a[];

    public Node sort_by_mergesort(Node head) {
        if (head == null || head.next == null)
            return head;
        int c = count(head);
        a = new int[c];
        // Array of size c is created
        int i = 0;
        for (Node ptr = head; ptr != null; ptr = ptr.next) {
            a[i++] = ptr.val;
        }
        // values are stored in the array
        i = 0;
        task(a, 0, c - 1);
        // task method will be executed
        for (Node ptr = head; ptr != null; ptr = ptr.next) {
            ptr.val = a[i++];
            // Value is stored in the linklist after being sorted
        }
        return head;
    }

    int count(Node head) {
        int c = 0;
        Node ptr;
        for (ptr = head; ptr != null; ptr = ptr.next) {
            c++;
        }
        return c;
        // This Method is used to count number of elements/nodes present in the linklist
        // It will return a integer type value denoting the number of nodes present
    }

    void task(int n[], int i, int j) {
        if (i < j) {
            int m = (i + j) / 2;
            task(n, i, m);
            task(n, m + 1, j);
            task1(n, i, m, j);
            // Array is halved and sent for sorting
        }
    }

    void task1(int n[], int s, int m, int e) {
        int i = s, k = 0, j = m + 1;
        int b[] = new int[e - s + 1];
        while (i <= m && j <= e) {
            if (n[j] >= n[i])
                b[k++] = n[i++];
            else
                b[k++] = n[j++];
        }
        // Smallest number is stored after checking from both the arrays
        while (i <= m) {
            b[k++] = n[i++];
        }
        while (j <= e) {
            b[k++] = n[j++];
        }
        for (int p = s; p <= e; p++) {
            a[p] = b[p - s];
        }
    }
    // The method task and task1 is used to sort the linklist using merge sort
}
class Task1 {
    public Node sort_by_insertionsort(Node head) {
        if (head == null || head.next == null)
            return head;
        int c = count(head);
        int a[] = new int[c];
        // Array of size c is created
        a[0] = head.val;
        int i;
        Node ptr;
        for (ptr = head.next, i = 1; ptr != null; ptr = ptr.next, i++) {
            int j = i - 1;
            while (j >= 0 && a[j] > ptr.val) {
                // values are stored in the array
                a[j + 1] = a[j];
                j--;
            }
            a[j + 1] = ptr.val;
        }
        i = 0;
        for (ptr = head; ptr != null; ptr = ptr.next) {
            ptr.val = a[i++];
            // Value is stored in the linklist after being sorted
        }
        return head;
    }

    static int count(Node head) {
        Node ptr;
        int c = 0;
        for (ptr = head; ptr != null; ptr = ptr.next) {
            c++;
        }
        return c;
        // This Method is used to count number of elements/nodes present in the linklist
        // It will return a integer type value denoting the number of nodes present
    }
    // The method task and task1 is used to sort the linklist using insertion sort
}

class Task2 {
    static int a[];

    public Node sort_by_heapsort(Node head) {
        if (head == null || head.next == null)
            return head;
        int c = count(head);
        a = new int[c];
        // Array of size c is created
        int i = 0;
        for (Node ptr = head; ptr != null; ptr = ptr.next) {
            a[i++] = ptr.val;
            // values are stored in the array
        }
        i = 0;
        task(a);
        for (Node ptr = head; ptr != null; ptr = ptr.next) {
            ptr.val = a[i++];
            // Value is stored in the linklist after being sorted
        }
        return head;
    }

    int count(Node head) {
        int c = 0;
        Node ptr;
        for (ptr = head; ptr != null; ptr = ptr.next) {
            c++;
        }
        return c;
        // This Method is used to count number of elements/nodes present in the linklist
        // It will return a integer type value denoting the number of nodes present
    }

    void task(int n[]) {
        int k = n.length;
        for (int i = k / 2 - 1; i >= 0; i--) {
            task1(n, k, i);
        }
        for (int i = k - 1; i > 0; i--) {
            int d = n[0];
            n[0] = n[i];
            n[i] = d;
            task1(n, i, 0);
            // recursive calling of task1 method
        }
    }

    void task1(int n[], int k, int i) {
        int p = i;
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        if (l < k && n[l] > n[p])
            p = l;
        if (r < k && n[r] > n[p])
            p = r;
        if (p != i) {
            int d = n[p];
            n[p] = n[i];
            n[i] = d;
            task1(n, k, p);
        }
    }
    // The method task and task1 is used to sort the linklist using heap sort
}package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

/**
 * @author Varun Upadhyay (https://github.com/varunu28)
 * @author Podshivalov Nikita (https://github.com/nikitap492)
 * @see SortAlgorithm
 */
class BubbleSort implements SortAlgorithm {

    /**
     * Implements generic bubble sort algorithm.
     *
     * @param array the array to be sorted.
     * @param <T> the type of elements in the array.
     * @return the sorted array.
     */
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        for (int i = 1, size = array.length; i < size; ++i) {
            boolean swapped = false;
            for (int j = 0; j < size - i; ++j) {
                if (greater(array[j], array[j + 1])) {
                    swap(array, j, j + 1);
                    swapped = true;
                }
            }
            if (!swapped) {
                break;
            }
        }
        return array;
    }

    /**
     * Driver Code
     */
    public static void main(String[] args) {

        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        BubbleSort bubbleSort = new BubbleSort();
        bubbleSort.sort(integers);

        for (int i = 0; i < integers.length - 1; ++i) {
            assert integers[i] <= integers[i + 1];
        }
        print(integers);
        /* output: [1, 4, 6, 9, 12, 23, 54, 78, 231] */

        String[] strings = {"c", "a", "e", "b", "d"};
        bubbleSort.sort(strings);
        for (int i = 0; i < strings.length - 1; i++) {
            assert strings[i].compareTo(strings[i + 1]) <= 0;
        }
        print(bubbleSort.sort(strings));
        /* output: [a, b, c, d, e] */
    }
}
package com.thealgorithms.sorts;

import java.util.Random;

// https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort
public class OddEvenSort {

    public static void main(String[] args) {
        int[] arr = new int[100];

        Random random = new Random();

        // Print out unsorted elements
        for (int i = 0; i < arr.length; ++i) {
            arr[i] = random.nextInt(100) - 50;
            System.out.println(arr[i]);
        }
        System.out.println("--------------");

        oddEvenSort(arr);

        //Print Sorted elements
        for (int i = 0; i < arr.length - 1; ++i) {
            System.out.println(arr[i]);
            assert arr[i] <= arr[i + 1];
        }
    }

    /**
     * Odd Even Sort algorithms implements
     *
     * @param arr the array contains elements
     */
    public static void oddEvenSort(int[] arr) {
        boolean sorted = false;
        while (!sorted) {
            sorted = true;

            for (int i = 1; i < arr.length - 1; i += 2) {
                if (arr[i] > arr[i + 1]) {
                    swap(arr, i, i + 1);
                    sorted = false;
                }
            }

            for (int i = 0; i < arr.length - 1; i += 2) {
                if (arr[i] > arr[i + 1]) {
                    swap(arr, i, i + 1);
                    sorted = false;
                }
            }
        }
    }

    /**
     * Helper function to swap two array values.
     *
     * @param arr the array contains elements
     * @param i the first index to be swapped
     * @param j the second index to be swapped
     */
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
package com.thealgorithms.sorts;

public class SelectionSort implements SortAlgorithm {

    /**
     * Generic selection sort algorithm in increasing order.
     *
     * @param arr the array to be sorted.
     * @param <T> the class of array.
     * @return sorted array.
     */
    @Override
    public <T extends Comparable<T>> T[] sort(T[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[minIndex].compareTo(arr[j]) > 0) {
                    minIndex = j;
                }
            }
            if (minIndex != i) {
                T temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
        return arr;
    }

    /**
     * Driver Code
     */
    public static void main(String[] args) {

        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        SelectionSort selectionSort = new SelectionSort();
        Integer[] sorted = selectionSort.sort(arr);
        for (int i = 0; i < sorted.length - 1; ++i) {
            assert sorted[i] <= sorted[i + 1];
        }

        String[] strings = {"c", "a", "e", "b", "d"};
        String[] sortedStrings = selectionSort.sort(strings);
        for (int i = 0; i < sortedStrings.length - 1; ++i) {
            assert strings[i].compareTo(strings[i + 1]) <= 0;
        }
    }
}
package com.thealgorithms.sorts;

/**
 * The Dutch National Flag Sort sorts a sequence of values into three permutations which are defined by a value given
 * as the indented middle.
 * First permutation: values less than middle.
 * Second permutation: values equal middle.
 * Third permutation: values greater than middle.
 * If no indented middle is given, this implementation will use a value from the given Array.
 * This value is the one positioned in the arrays' middle if the arrays' length is odd.
 * If the arrays' length is even, the value left to the middle will be used.
 * More information and Pseudocode: https://en.wikipedia.org/wiki/Dutch_national_flag_problem
 */
public class DutchNationalFlagSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        return dutch_national_flag_sort(unsorted, unsorted[(int) Math.ceil((unsorted.length)/2.0) -1]);
    }

    public <T extends Comparable<T>> T[] sort(T[] unsorted, T intendedMiddle) {
        return dutch_national_flag_sort(unsorted, intendedMiddle);
    }

    private <T extends Comparable<T>> T[] dutch_national_flag_sort(T[] arr, T intendedMiddle){
        int i = 0;
        int j = 0;
        int k = arr.length - 1;

        while( j <= k){
            if ( 0 > arr[j].compareTo(intendedMiddle)){
                SortUtils.swap(arr, i, j);
                j++;
                i++;
            } else if (0 < arr[j].compareTo(intendedMiddle)){
                SortUtils.swap(arr, j, k);
                k--;
            } else {
                j++;
            }
        }
       return arr;
    }
}
