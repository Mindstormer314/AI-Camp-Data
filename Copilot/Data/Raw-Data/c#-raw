namespace DataStructures.SegmentTrees
{
    /// <summary>
    ///     This is an extension of a segment tree, which allows the update of a single element.
    /// </summary>
    public class SegmentTreeUpdate : SegmentTree
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="SegmentTreeUpdate" /> class.
        ///     Runtime complexity: O(n) where n equals the array-length.
        /// </summary>
        /// <param name="arr">Array on which the queries should be made.</param>
        public SegmentTreeUpdate(int[] arr)
            : base(arr)
        {
        }

        /// <summary>
        ///     Updates a single element of the input array.
        ///     Changes the leaf first and updates its parents afterwards.
        ///     Runtime complexity: O(logN) where N equals the initial array-length.
        /// </summary>
        /// <param name="node">Index of the node that should be updated.</param>
        /// <param name="value">New Value of the element.</param>
        public void Update(int node, int value)
        {
            Tree[node + Tree.Length / 2] = value;
            Propagate(Parent(node + Tree.Length / 2));
        }

        /// <summary>
        ///     Recalculates the value of node by its children.
        ///     Calls its parent to do the same.
        /// </summary>
        /// <param name="node">Index of current node.</param>
        private void Propagate(int node)
        {
            if (node == 0)
            {
                // passed root
                return;
            }

            Tree[node] = Tree[Left(node)] + Tree[Right(node)];
            Propagate(Parent(node));
        }
    }
}
using System;

namespace DataStructures.SegmentTrees
{
    /// <summary>
    ///     Goal:   Data structure with which you can quickly perform queries on an array (i.e. sum of subarray)
    ///     and at the same time efficiently update an entry
    ///     or apply a distributive operation to a subarray.
    ///     Idea:   Preprocessing special queries
    ///     Hint:   The query operation HAS to be associative (in this example addition).
    /// </summary>
    public class SegmentTree
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="SegmentTree" /> class.
        ///     Runtime complexity: O(n) where n equals the array-length.
        /// </summary>
        /// <param name="arr">Array on which the queries should be made.</param>
        public SegmentTree(int[] arr)
        {
            // Calculates next power of two
            var pow = (int)Math.Pow(2, Math.Ceiling(Math.Log(arr.Length, 2)));
            Tree = new int[2 * pow];

            // Transfers the input array into the last half of the segment tree array
            Array.Copy(arr, 0, Tree, pow, arr.Length);

            // Calculates the first half
            for (var i = pow - 1; i > 0; --i)
            {
                Tree[i] = Tree[Left(i)] + Tree[Right(i)];
            }
        }

        /// <summary>Gets the segment tree array.</summary>
        public int[] Tree { get; }

        /// <summary>
        ///     Starts a query.
        ///     Runtime complexity: O(logN) where n equals the array-length.
        /// </summary>
        /// <param name="l">Left border of the query.</param>
        /// <param name="r">Right border of the query.</param>
        /// <returns>Sum of the subarray between <c>l</c> and <c>r</c> (including <c>l</c> and <c>r</c>).</returns>
        // Editing of query start at node with 1.
        // Node with index 1 includes the whole input subarray.
        public int Query(int l, int r) =>
            Query(++l, ++r, 1, Tree.Length / 2, 1);

        /// <summary>
        ///     Calculates the right child of a node.
        /// </summary>
        /// <param name="node">Current node.</param>
        /// <returns>Index of the right child.</returns>
        protected int Right(int node) => 2 * node + 1;

        /// <summary>
        ///     Calculates the left child of a node.
        /// </summary>
        /// <param name="node">Current node.</param>
        /// <returns>Index of the left child.</returns>
        protected int Left(int node) => 2 * node;

        /// <summary>
        ///     Calculates the parent of a node.
        /// </summary>
        /// <param name="node">Current node.</param>
        /// <returns>Index of the parent node.</returns>
        protected int Parent(int node) => node / 2;

        /// <summary>
        ///     Edits a query.
        /// </summary>
        /// <param name="l">Left border of the query.</param>
        /// <param name="r">Right border of the query.</param>
        /// <param name="a">Left end of the subarray enclosed by <c>i</c>.</param>
        /// <param name="b">Right end of the subarray enclosed by <c>i</c>.</param>
        /// <param name="i">Current node.</param>
        /// <returns>Sum of a subarray between <c>l</c> and <c>r</c> (including <c>l</c> and <c>r</c>).</returns>
        protected virtual int Query(int l, int r, int a, int b, int i)
        {
            // If a and b are in the (by l and r) specified subarray
            if (l <= a && b <= r)
            {
                return Tree[i];
            }

            // If a or b are out of the by l and r specified subarray
            if (r < a || b < l)
            {
                // Returns the neutral value of the operation
                // (in this case 0, because x + 0 = x)
                return 0;
            }

            // Calculates index m of the node that cuts the current subarray in half
            var m = (a + b) / 2;

            // Start query of new two subarrays a:m and m+1:b
            // The right and left child cover this intervals
            return Query(l, r, a, m, Left(i)) + Query(l, r, m + 1, b, Right(i));
        }
    }
}
using System;

namespace DataStructures.SegmentTrees
{
    /// <summary>
    ///     This is an extension of a segment tree, which allows applying distributive operations to a subarray
    ///     (in this case multiplication).
    /// </summary>
    public class SegmentTreeApply : SegmentTree
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="SegmentTreeApply" /> class.
        ///     Runtime complexity: O(n) where n equals the array-length.
        /// </summary>
        /// <param name="arr">Array on which the operations should be made.</param>
        public SegmentTreeApply(int[] arr)
            : base(arr)
        {
            // Initilizes and fills "operand" array with neutral element (in this case 1, because value * 1 = value)
            Operand = new int[Tree.Length];
            Array.Fill(Operand, 1);
        }

        /// <summary>
        ///     Gets an array that stores for each node an operand,
        ///     which must be applied to all direct and indirect child nodes of this node
        ///     (but not to the node itself).
        /// </summary>
        public int[] Operand { get; }

        /// <summary>
        ///     Applies a distributive operation to a subarray defined by <c>l</c> and <c>r</c>
        ///     (in this case multiplication by <c>value</c>).
        ///     Runtime complexity: O(logN) where N equals the initial array-length.
        /// </summary>
        /// <param name="l">Left border of the subarray.</param>
        /// <param name="r">Right border of the subarray.</param>
        /// <param name="value">Value with which each element of the interval is calculated.</param>
        public void Apply(int l, int r, int value)
        {
            // The Application start at node with 1
            // Node with index 1 includes the whole input subarray
            Apply(++l, ++r, value, 1, Tree.Length / 2, 1);
        }

        /// <summary>
        ///     Edits a query.
        /// </summary>
        /// <param name="l">Left border of the query.</param>
        /// <param name="r">Right border of the query.</param>
        /// <param name="a">Left end of the subarray enclosed by <c>i</c>.</param>
        /// <param name="b">Right end of the subarray enclosed by <c>i</c>.</param>
        /// <param name="i">Current node.</param>
        /// <returns>Sum of a subarray between <c>l</c> and <c>r</c> (including <c>l</c> and <c>r</c>).</returns>
        protected override int Query(int l, int r, int a, int b, int i)
        {
            if (l <= a && b <= r)
            {
                return Tree[i];
            }

            if (r < a || b < l)
            {
                return 0;
            }

            var m = (a + b) / 2;

            // Application of the saved operand to the direct and indrect child nodes
            return Operand[i] * (Query(l, r, a, m, Left(i)) + Query(l, r, m + 1, b, Right(i)));
        }

        /// <summary>
        ///     Applies the operation.
        /// </summary>
        /// <param name="l">Left border of the Application.</param>
        /// <param name="r">Right border of the Application.</param>
        /// <param name="value">Multiplier by which the subarray is to be multiplied.</param>
        /// <param name="a">Left end of the subarray enclosed by <c>i</c>.</param>
        /// <param name="b">Right end of the subarray enclosed by <c>i</c>.</param>
        /// <param name="i">Current node.</param>
        private void Apply(int l, int r, int value, int a, int b, int i)
        {
            // If a and b are in the (by l and r) specified subarray
            if (l <= a && b <= r)
            {
                // Applies the operation to the current node and saves it for the direct and indirect child nodes
                Operand[i] = value * Operand[i];
                Tree[i] = value * Tree[i];
                return;
            }

            // If a or b are out of the by l and r specified subarray stop application at this node
            if (r < a || b < l)
            {
                return;
            }

            // Calculates index m of the node that cuts the current subarray in half
            var m = (a + b) / 2;

            // Applies the operation to both halfes
            Apply(l, r, value, a, m, Left(i));
            Apply(l, r, value, m + 1, b, Right(i));

            // Recalculates the value of this node by its (possibly new) children.
            Tree[i] = Operand[i] * (Tree[Left(i)] + Tree[Right(i)]);
        }
    }
}
using System.Collections;
using System.Collections.Generic;

namespace DataStructures
{
    /// <summary>
    ///     Implementation of SortedList using binary search.
    /// </summary>
    /// <typeparam name="T">Generic Type.</typeparam>
    public class SortedList<T> : IEnumerable<T>
    {
        private readonly IComparer<T> comparer;
        private readonly List<T> memory;

        /// <summary>
        ///     Initializes a new instance of the <see cref="SortedList{T}" /> class. Uses a Comparer.Default for type T.
        /// </summary>
        public SortedList()
            : this(Comparer<T>.Default)
        {
        }

        /// <summary>
        ///     Gets the number of elements containing in <see cref="SortedList{T}" />.
        /// </summary>
        public int Count => memory.Count;

        /// <summary>
        ///     Initializes a new instance of the <see cref="SortedList{T}" /> class.
        /// </summary>
        /// <param name="comparer">Comparer user for binary search.</param>
        public SortedList(IComparer<T> comparer)
        {
            memory = new List<T>();
            this.comparer = comparer;
        }

        /// <summary>
        ///     Adds new item to <see cref="SortedList{T}" /> instance, maintaining the order.
        /// </summary>
        /// <param name="item">An element to insert.</param>
        public void Add(T item)
        {
            var index = IndexFor(item, out _);
            memory.Insert(index, item);
        }

        /// <summary>
        ///     Gets an element of <see cref="SortedList{T}" /> at specified index.
        /// </summary>
        /// <param name="i">Index.</param>
        public T this[int i] => memory[i];

        /// <summary>
        /// Removes all elements from <see cref="SortedList{T}" />.
        /// </summary>
        public void Clear()
            => memory.Clear();

        /// <summary>
        /// Indicates whether a <see cref="SortedList{T}" /> contains a certain element.
        /// </summary>
        /// <param name="item">An element to search.</param>
        /// <returns>true - <see cref="SortedList{T}" /> contains an element, otherwise - false.</returns>
        public bool Contains(T item)
        {
            _ = IndexFor(item, out var found);
            return found;
        }

        /// <summary>
        /// Removes a certain element from <see cref="SortedList{T}" />.
        /// </summary>
        /// <param name="item">An element to remove.</param>
        /// <returns>true - element is found and removed, otherwise false.</returns>
        public bool TryRemove(T item)
        {
            var index = IndexFor(item, out var found);

            if (found)
            {
                memory.RemoveAt(index);
            }

            return found;
        }

        /// <summary>
        /// Returns an enumerator that iterates through the <see cref="SortedList{T}" />.
        /// </summary>
        /// <returns>A Enumerator for the <see cref="SortedList{T}" />.</returns>
        public IEnumerator<T> GetEnumerator()
            => memory.GetEnumerator();

        /// <inheritdoc cref="IEnumerable.GetEnumerator"/>
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        /// <summary>
        /// Binary search algorithm for finding element index in <see cref="SortedList{T}" />.
        /// </summary>
        /// <param name="item">Element.</param>
        /// <param name="found">Indicates whether the equal value was found in <see cref="SortedList{T}" />.</param>
        /// <returns>Index for the Element.</returns>
        private int IndexFor(T item, out bool found)
        {
            var left = 0;
            var right = memory.Count;

            while (right - left > 0)
            {
                var mid = (left + right) / 2;

                switch (comparer.Compare(item, memory[mid]))
                {
                    case > 0:
                        left = mid + 1;
                        break;
                    case < 0:
                        right = mid;
                        break;
                    default:
                        found = true;
                        return mid;
                }
            }

            found = false;
            return left;
        }
    }
}
namespace DataStructures.DisjointSet
{
    /// <summary>
    /// node class to be used by disjoint set to represent nodes in Disjoint Set forest.
    /// </summary>
    /// <typeparam name="T">generic type for data to be stored.</typeparam>
    public class Node<T>
    {
        public int Rank { get; set; }

        public Node<T> Parent { get; set; }

        public T Data { get; set; }

        public Node(T data)
        {
            Data = data;
            Parent = this;
        }
    }
}
using System.Collections;

namespace DataStructures.DisjointSet
{
    /// <summary>
    /// Implementation of Disjoint Set with Union By Rank and Path Compression heuristics.
    /// </summary>
    /// <typeparam name="T"> generic type for implementation.</typeparam>
    public class DisjointSet<T>
    {
        /// <summary>
        /// make a new set and return its representative.
        /// </summary>
        /// <param name="x">element to add in to the DS.</param>
        /// <returns>representative of x.</returns>
        public Node<T> MakeSet(T x) => new(x);

        /// <summary>
        /// find the representative of a certain node.
        /// </summary>
        /// <param name="node">node to find representative.</param>
        /// <returns>representative of x.</returns>
        public Node<T> FindSet(Node<T> node)
        {
            if (node != node.Parent)
            {
                node.Parent = FindSet(node.Parent);
            }

            return node.Parent;
        }

        /// <summary>
        /// merge two sets.
        /// </summary>
        /// <param name="x">first set member.</param>
        /// <param name="y">second set member.</param>
        public void UnionSet(Node<T> x, Node<T> y)
        {
            Node<T> nx = FindSet(x);
            Node<T> ny = FindSet(y);
            if (nx == ny)
            {
                return;
            }

            if (nx.Rank > ny.Rank)
            {
                ny.Parent = nx;
            }
            else if (ny.Rank > nx.Rank)
            {
                nx.Parent = ny;
            }
            else
            {
                nx.Parent = ny;
                ny.Rank++;
            }
        }
    }
}
namespace DataStructures.RedBlackTree
{
    /// <summary>
    ///     Enum to represent node colors.
    /// </summary>
    public enum NodeColor : byte
    {
        /// <summary>
        ///     Represents red node
        /// </summary>
        Red,

        /// <summary>
        ///     Represents black node
        /// </summary>
        Black,
    }

    /// <summary>
    ///     Generic class to represent nodes in an <see cref="RedBlackTree{TKey}"/> instance.
    /// </summary>
    /// <typeparam name="TKey">The type of key for the node.</typeparam>
    public class RedBlackTreeNode<TKey>
    {
        /// <summary>
        ///     Gets or sets key value of node.
        /// </summary>
        public TKey Key { get; set; }

        /// <summary>
        ///     Gets or sets the color of the node.
        /// </summary>
        public NodeColor Color { get; set; }

        /// <summary>
        ///     Gets or sets the parent of the node.
        /// </summary>
        public RedBlackTreeNode<TKey>? Parent { get; set; }

        /// <summary>
        ///     Gets or sets left child of the node.
        /// </summary>
        public RedBlackTreeNode<TKey>? Left { get; set; }

        /// <summary>
        ///     Gets or sets the right child of the node.
        /// </summary>
        public RedBlackTreeNode<TKey>? Right { get; set; }

        /// <summary>
        ///  Initializes a new instance of the <see cref="RedBlackTreeNode{TKey}"/> class.
        /// </summary>
        /// <param name="key">Key value for node.</param>
        /// <param name="parent">Parent of node.</param>
        public RedBlackTreeNode(TKey key, RedBlackTreeNode<TKey>? parent)
        {
            Key = key;
            Parent = parent;
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.RedBlackTree
{
    /// <summary>
    ///     A self-balancing bindary tree.
    /// </summary>
    /// <remarks>
    ///     A red-black tree is a self-balancing binary search tree (BST) that
    ///     stores a color with each node. A node's color can either be red or
    ///     black. Several properties are maintained to ensure the tree remains
    ///     balanced.
    ///     <list type="number">
    ///         <item>
    ///             <term>A red node does not have a red child.</term>
    ///         </item>
    ///         <item>
    ///             <term>All null nodes are considered black.</term>
    ///         </item>
    ///         <item>
    ///             <term>
    ///                 Every path from a node to its descendant leaf nodes
    ///             has the same number of black nodes.
    ///             </term>
    ///         </item>
    ///         <item>
    ///             <term>(Optional) The root is always black.</term>
    ///         </item>
    ///     </list>
    ///     Red-black trees are generally slightly more unbalanced than an
    ///     AVL tree, but insertion and deletion is generally faster.
    ///     See https://en.wikipedia.org/wiki/Red%E2%80%93black_tree for more information.
    /// </remarks>
    /// <typeparam name="TKey">Type of key for the tree.</typeparam>
    public class RedBlackTree<TKey>
    {
        /// <summary>
        ///     Gets the number of nodes in the tree.
        /// </summary>
        public int Count { get; private set; }

        /// <summary>
        ///     Comparer to use when comparing key values.
        /// </summary>
        private readonly Comparer<TKey> comparer;

        /// <summary>
        ///     Reference to the root node.
        /// </summary>
        private RedBlackTreeNode<TKey>? root;

        /// <summary>
        ///     Initializes a new instance of the <see cref="RedBlackTree{TKey}"/> class.
        /// </summary>
        public RedBlackTree()
        {
            comparer = Comparer<TKey>.Default;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="RedBlackTree{TKey}"/> class
        ///     using the specified comparer.
        /// </summary>
        /// <param name="customComparer">Comparer to use when comparing keys.</param>
        public RedBlackTree(Comparer<TKey> customComparer)
        {
            comparer = customComparer;
        }

        /// <summary>
        ///     Add a single node to the tree.
        /// </summary>
        /// <param name="key">Key value to add.</param>
        public void Add(TKey key)
        {
            if (root is null)
            {
                // Case 3
                // New node is root
                root = new RedBlackTreeNode<TKey>(key, null)
                {
                    Color = NodeColor.Black,
                };
                Count++;
                return;
            }

            // Regular binary tree insertion
            var node = Add(root, key);

            // Get which side child was added to
            var childDir = comparer.Compare(node.Key, node.Parent!.Key);

            // Set node to be new node's parent for easier handling
            node = node.Parent;

            // Return tree to valid state
            int addCase;
            do
            {
                addCase = GetAddCase(node);

                switch(addCase)
                {
                    case 1:
                        break;
                    case 2:
                        var oldParent = node.Parent;
                        node = AddCase2(node);

                        if (node is not null)
                        {
                            childDir = comparer.Compare(oldParent!.Key, oldParent.Parent!.Key);
                        }

                        break;
                    case 4:
                        node.Color = NodeColor.Black;
                        break;
                    case 56:
                        AddCase56(node, comparer.Compare(node.Key, node.Parent!.Key), childDir);
                        break;
                    default:
                        throw new InvalidOperationException("It should not be possible to get here!");
                }
            }
            while (addCase == 2 && node is not null);

            Count++;
        }

        /// <summary>
        ///     Add multiple nodes to the tree.
        /// </summary>
        /// <param name="keys">Key values to add.</param>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys)
            {
                Add(key);
            }
        }

        /// <summary>
        ///     Remove a node from the tree.
        /// </summary>
        /// <param name="key">Key value to remove.</param>
        public void Remove(TKey key)
        {
            // Search for node
            var node = Remove(root, key);

            // Simple cases
            node = RemoveSimpleCases(node);

            // Exit if deleted node was not non-root black leaf
            if (node is null)
            {
                return;
            }

            // Delete node
            DeleteLeaf(node.Parent!, comparer.Compare(node.Key, node.Parent!.Key));

            // Recolor tree
            do
            {
                node = RemoveRecolor(node);
            }
            while (node is not null && node.Parent is not null);    // Case 2: Reached root

            Count--;
        }

        /// <summary>
        ///     Check if given node is in the tree.
        /// </summary>
        /// <param name="key">Key value to search for.</param>
        /// <returns>Whether or not the node is in the tree.</returns>
        public bool Contains(TKey key)
        {
            var node = root;
            while (node is not null)
            {
                var compareResult = comparer.Compare(key, node.Key);
                if (compareResult < 0)
                {
                    node = node.Left;
                }
                else if (compareResult > 0)
                {
                    node = node.Right;
                }
                else
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        ///     Get the minimum value in the tree.
        /// </summary>
        /// <returns>Minimum value in tree.</returns>
        public TKey GetMin()
        {
            if (root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMin(root).Key;
        }

        /// <summary>
        ///     Get the maximum value in the tree.
        /// </summary>
        /// <returns>Maximum value in tree.</returns>
        public TKey GetMax()
        {
            if (root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMax(root).Key;
        }

        /// <summary>
        ///     Get keys in order from smallest to largest as defined by the comparer.
        /// </summary>
        /// <returns>Keys in tree in order from smallest to largest.</returns>
        public IEnumerable<TKey> GetKeysInOrder()
        {
            var result = new List<TKey>();
            InOrderWalk(root);
            return result;

            void InOrderWalk(RedBlackTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                InOrderWalk(node.Left);
                result.Add(node.Key);
                InOrderWalk(node.Right);
            }
        }

        /// <summary>
        ///     Get keys in the pre-order order.
        /// </summary>
        /// <returns>Keys in pre-order order.</returns>
        public IEnumerable<TKey> GetKeysPreOrder()
        {
            var result = new List<TKey>();
            PreOrderWalk(root);
            return result;

            void PreOrderWalk(RedBlackTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                result.Add(node.Key);
                PreOrderWalk(node.Left);
                PreOrderWalk(node.Right);
            }
        }

        /// <summary>
        ///     Get keys in the post-order order.
        /// </summary>
        /// <returns>Keys in the post-order order.</returns>
        public IEnumerable<TKey> GetKeysPostOrder()
        {
            var result = new List<TKey>();
            PostOrderWalk(root);
            return result;

            void PostOrderWalk(RedBlackTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                PostOrderWalk(node.Left);
                PostOrderWalk(node.Right);
                result.Add(node.Key);
            }
        }

        /// <summary>
        ///     Perform binary tree insertion.
        /// </summary>
        /// <param name="node">Root of subtree to search from.</param>
        /// <param name="key">Key value to insert.</param>
        /// <returns>Node that was added.</returns>
        private RedBlackTreeNode<TKey> Add(RedBlackTreeNode<TKey> node, TKey key)
        {
            int compareResult;
            RedBlackTreeNode<TKey> newNode;
            while (true)
            {
                compareResult = comparer.Compare(key, node!.Key);
                if (compareResult < 0)
                {
                    if (node.Left is null)
                    {
                        newNode = new RedBlackTreeNode<TKey>(key, node);
                        node.Left = newNode;
                        break;
                    }
                    else
                    {
                        node = node.Left;
                    }
                }
                else if (compareResult > 0)
                {
                    if (node.Right is null)
                    {
                        newNode = new RedBlackTreeNode<TKey>(key, node);
                        node.Right = newNode;
                        break;
                    }
                    else
                    {
                        node = node.Right;
                    }
                }
                else
                {
                    throw new ArgumentException($"Key \"{key}\" already exists in tree!");
                }
            }

            return newNode;
        }

        /// <summary>
        ///     Perform case 2 of insertion by pushing blackness down from parent.
        /// </summary>
        /// <param name="node">Parent of inserted node.</param>
        /// <returns>Grandparent of inserted node.</returns>
        private RedBlackTreeNode<TKey>? AddCase2(RedBlackTreeNode<TKey> node)
        {
            var grandparent = node.Parent;
            var parentDir = comparer.Compare(node.Key, node.Parent!.Key);
            var uncle = parentDir < 0 ? grandparent!.Right : grandparent!.Left;

            node.Color = NodeColor.Black;
            uncle!.Color = NodeColor.Black;
            grandparent.Color = NodeColor.Red;

            // Keep root black
            if (node.Parent.Parent is null)
            {
                node.Parent.Color = NodeColor.Black;
            }

            // Set current node as parent to move up tree
            return node.Parent.Parent;
        }

        /// <summary>
        ///     Perform rotations needed for cases 5 and 6 of insertion.
        /// </summary>
        /// <param name="node">Parent of node just inserted.</param>
        /// <param name="parentDir">The side node is on of its parent.</param>
        /// <param name="childDir">The side the child node is on.</param>
        private void AddCase56(RedBlackTreeNode<TKey> node, int parentDir, int childDir)
        {
            if (parentDir < 0)
            {
                // Case 5
                if (childDir > 0)
                {
                    node = RotateLeft(node);
                }

                // Case 6
                node = RotateRight(node.Parent!);
                node.Color = NodeColor.Black;
                node.Right!.Color = NodeColor.Red;
            }
            else
            {
                // Case 5
                if (childDir < 0)
                {
                    node = RotateRight(node);
                }

                // Case 6
                node = RotateLeft(node.Parent!);
                node.Color = NodeColor.Black;
                node.Left!.Color = NodeColor.Red;
            }
        }

        /// <summary>
        ///     Determine which add case applies to inserted node.
        /// </summary>
        /// <param name="node">Parent of inserted node.</param>
        /// <returns>Case number needed to get tree in valid state. Cases 5 and 6 are represented by 56.</returns>
        private int GetAddCase(RedBlackTreeNode<TKey> node)
        {
            if (node.Color == NodeColor.Black)
            {
                return 1;
            }
            else if (node.Parent is null)
            {
                return 4;
            }
            else
            {
                // Remaining insert cases need uncle
                var grandparent = node.Parent;
                var parentDir = comparer.Compare(node.Key, node.Parent.Key);
                var uncle = parentDir < 0 ? grandparent.Right : grandparent.Left;

                // Case 5 & 6
                if (uncle is null || uncle.Color == NodeColor.Black)
                {
                    return 56;
                }

                return 2;
            }
        }

        /// <summary>
        ///     Search for the node to be deleted.
        /// </summary>
        /// <param name="node">Node to start search from.</param>
        /// <param name="key">Key to search for.</param>
        /// <returns>Node to be deleted.</returns>
        private RedBlackTreeNode<TKey> Remove(RedBlackTreeNode<TKey>? node, TKey key)
        {
            if (node is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }
            else if (!Contains(key))
            {
                throw new KeyNotFoundException($"Key {key} is not in the tree!");
            }
            else
            {
                // Find node
                int dir;
                while (true)
                {
                    dir = comparer.Compare(key, node!.Key);
                    if (dir < 0)
                    {
                        node = node.Left;
                    }
                    else if (dir > 0)
                    {
                        node = node.Right;
                    }
                    else
                    {
                        break;
                    }
                }

                return node;
            }
        }

        /// <summary>
        ///     Get the tree back into a valid state after removing non-root black leaf.
        /// </summary>
        /// <param name="node">Non-root black leaf being removed.</param>
        private RedBlackTreeNode<TKey>? RemoveRecolor(RedBlackTreeNode<TKey> node)
        {
            var removeCase = GetRemoveCase(node);

            var dir = comparer.Compare(node.Key, node.Parent!.Key);

            // Determine current node's sibling and nephews
            var sibling = dir < 0 ? node.Parent.Right : node.Parent.Left;
            var closeNewphew = dir < 0 ? sibling!.Left : sibling!.Right;
            var distantNephew = dir < 0 ? sibling!.Right : sibling!.Left;

            switch (removeCase)
            {
                case 1:
                    sibling.Color = NodeColor.Red;
                    return node.Parent;
                case 3:
                    RemoveCase3(node, closeNewphew, dir);
                    break;
                case 4:
                    RemoveCase4(sibling);
                    break;
                case 5:
                    RemoveCase5(node, sibling, dir);
                    break;
                case 6:
                    RemoveCase6(node, distantNephew!, dir);
                    break;
                default:
                    throw new InvalidOperationException("It should not be possible to get here!");
            }

            return null;
        }

        /// <summary>
        ///     Simple removal cases where black height doesn't change.
        /// </summary>
        /// <param name="node">Node to remove.</param>
        /// <returns>Non-root black leaf node or null. Null indicates that removal was performed.</returns>
        private RedBlackTreeNode<TKey>? RemoveSimpleCases(RedBlackTreeNode<TKey> node)
        {
            // Node to delete is root and has no children
            if (node.Parent is null && node.Left is null && node.Right is null)
            {
                root = null;
                Count--;
                return null;
            }

            // Node has two children. Swap pointers
            if (node.Left is not null && node.Right is not null)
            {
                var successor = GetMin(node.Right);
                node.Key = successor.Key;
                node = successor;
            }

            // At this point node should have at most one child
            if (node.Color == NodeColor.Red)
            {
                // Node is red so it must have no children since it doesn't have two children
                DeleteLeaf(node.Parent!, comparer.Compare(node.Key, node.Parent!.Key));

                Count--;
                return null;
            }
            else
            {
                // Node is black and may or may not be node
                return RemoveBlackNode(node);
            }
        }

        /// <summary>
        ///     Node to delete is black. If it is a leaf then we need to recolor, otherwise remove it.
        /// </summary>
        /// <param name="node">Black node to examine.</param>
        /// <returns>Node to start recoloring from. Null if deletion occurred.</returns>
        private RedBlackTreeNode<TKey>? RemoveBlackNode(RedBlackTreeNode<TKey> node)
        {
            // Node is black and has at most one child. If it has a child it must be red.
            var child = node.Left ?? node.Right;

            // Continue to recoloring if node is leaf
            if (child is null)
            {
                return node;
            }

            // Recolor child
            child.Color = NodeColor.Black;
            child.Parent = node.Parent;

            var childDir = node.Parent is null ? 0 : comparer.Compare(node.Key, node.Parent.Key);

            // Replace node with child
            Transplant(node.Parent, child, childDir);

            Count--;
            return null;
        }

        /// <summary>
        ///     Perform case 3 of removal.
        /// </summary>
        /// <param name="node">Node that was removed.</param>
        /// <param name="closeNephew">Close nephew of removed node.</param>
        /// <param name="childDir">Side of parent the removed node was.</param>
        private void RemoveCase3(RedBlackTreeNode<TKey> node, RedBlackTreeNode<TKey>? closeNephew, int childDir)
        {
            // Rotate and recolor
            var sibling = childDir < 0 ? RotateLeft(node.Parent!) : RotateRight(node.Parent!);
            sibling.Color = NodeColor.Black;
            if (childDir < 0)
            {
                sibling.Left!.Color = NodeColor.Red;
            }
            else
            {
                sibling.Right!.Color = NodeColor.Red;
            }

            // Get new distant newphew
            sibling = closeNephew!;
            var distantNephew = childDir < 0 ? sibling.Right : sibling.Left;

            // Parent is red, sibling is black
            if (distantNephew is not null && distantNephew.Color == NodeColor.Red)
            {
                RemoveCase6(node, distantNephew, childDir);
                return;
            }

            // Get new close nephew
            closeNephew = childDir < 0 ? sibling!.Left : sibling!.Right;

            // Sibling is black, distant nephew is black
            if (closeNephew is not null && closeNephew.Color == NodeColor.Red)
            {
                RemoveCase5(node, sibling!, childDir);
                return;
            }

            // Final recoloring
            RemoveCase4(sibling!);
        }

        /// <summary>
        ///     Perform case 4 of removal.
        /// </summary>
        /// <param name="sibling">Sibling of removed node.</param>
        private void RemoveCase4(RedBlackTreeNode<TKey> sibling)
        {
            sibling.Color = NodeColor.Red;
            sibling.Parent!.Color = NodeColor.Black;
        }

        /// <summary>
        ///     Perform case 5 of removal.
        /// </summary>
        /// <param name="node">Node that was removed.</param>
        /// <param name="sibling">Sibling of removed node.</param>
        /// <param name="childDir">Side of parent removed node was on.</param>
        private void RemoveCase5(RedBlackTreeNode<TKey> node, RedBlackTreeNode<TKey> sibling, int childDir)
        {
            sibling = childDir < 0 ? RotateRight(sibling) : RotateLeft(sibling);
            var distantNephew = childDir < 0 ? sibling.Right! : sibling.Left!;

            sibling.Color = NodeColor.Black;
            distantNephew.Color = NodeColor.Red;

            RemoveCase6(node, distantNephew, childDir);
        }

        /// <summary>
        ///     Perform case 6 of removal.
        /// </summary>
        /// <param name="node">Node that was removed.</param>
        /// <param name="distantNephew">Distant nephew of removed node.</param>
        /// <param name="childDir">Side of parent removed node was on.</param>
        private void RemoveCase6(RedBlackTreeNode<TKey> node, RedBlackTreeNode<TKey> distantNephew, int childDir)
        {
            var oldParent = node.Parent!;
            node = childDir < 0 ? RotateLeft(oldParent) : RotateRight(oldParent);
            node.Color = oldParent.Color;
            oldParent.Color = NodeColor.Black;
            distantNephew.Color = NodeColor.Black;
        }

        /// <summary>
        ///     Determine which removal case is required.
        /// </summary>
        /// <param name="node">Node being removed.</param>
        /// <returns>Which removal case should be performed.</returns>
        private int GetRemoveCase(RedBlackTreeNode<TKey> node)
        {
            var dir = comparer.Compare(node.Key, node.Parent!.Key);

            // Determine current node's sibling and nephews
            var sibling = dir < 0 ? node.Parent.Right : node.Parent.Left;
            var closeNewphew = dir < 0 ? sibling!.Left : sibling!.Right;
            var distantNephew = dir < 0 ? sibling!.Right : sibling!.Left;

            if (sibling.Color == NodeColor.Red)
            {
                return 3;
            }
            else if (distantNephew is not null && distantNephew.Color == NodeColor.Red)
            {
                return 6;
            }
            else if (closeNewphew is not null && closeNewphew.Color == NodeColor.Red)
            {
                return 5;
            }
            else if (node.Parent.Color == NodeColor.Red)
            {
                return 4;
            }
            else
            {
                return 1;
            }
        }

        /// <summary>
        ///     Set child of node or delete leaf.
        /// </summary>
        /// <param name="node">Node to set child of. Set to null for root.</param>
        /// <param name="child">Node to set as child.</param>
        /// <param name="dir">Which side of node to place child.</param>
        private void Transplant(RedBlackTreeNode<TKey>? node, RedBlackTreeNode<TKey>? child, int dir)
        {
            if (node is null)
            {
                root = child;
            }
            else if (child is null)
            {
                DeleteLeaf(node, dir);
            }
            else if (dir < 0)
            {
                node.Left = child;
            }
            else
            {
                node.Right = child;
            }
        }

        /// <summary>
        ///     Delete leaf node.
        /// </summary>
        /// <param name="node">Parent of leaf node to delete.</param>
        /// <param name="dir">Side of parent leaf is on.</param>
        private void DeleteLeaf(RedBlackTreeNode<TKey> node, int dir)
        {
            if (dir < 0)
            {
                node.Left = null;
            }
            else
            {
                node.Right = null;
            }
        }

        /// <summary>
        ///     Perform a left (counter-clockwise) rotation.
        /// </summary>
        /// <param name="node">Node to rotate about.</param>
        /// <returns>New node with rotation applied.</returns>
        private RedBlackTreeNode<TKey> RotateLeft(RedBlackTreeNode<TKey> node)
        {
            var temp1 = node;
            var temp2 = node!.Right!.Left;

            node = node.Right;
            node.Parent = temp1.Parent;
            if (node.Parent is not null)
            {
                var nodeDir = comparer.Compare(node.Key, node.Parent.Key);
                if (nodeDir < 0)
                {
                    node.Parent.Left = node;
                }
                else
                {
                    node.Parent.Right = node;
                }
            }

            node.Left = temp1;
            node.Left.Parent = node;

            node.Left.Right = temp2;
            if (temp2 is not null)
            {
                node.Left.Right!.Parent = temp1;
            }

            if (node.Parent is null)
            {
                root = node;
            }

            return node;
        }

        /// <summary>
        ///     Perform a right (clockwise) rotation.
        /// </summary>
        /// <param name="node">Node to rotate about.</param>
        /// <returns>New node with rotation applied.</returns>
        private RedBlackTreeNode<TKey> RotateRight(RedBlackTreeNode<TKey> node)
        {
            var temp1 = node;
            var temp2 = node!.Left!.Right;

            node = node.Left;
            node.Parent = temp1.Parent;
            if (node.Parent is not null)
            {
                var nodeDir = comparer.Compare(node.Key, node.Parent.Key);
                if (nodeDir < 0)
                {
                    node.Parent.Left = node;
                }
                else
                {
                    node.Parent.Right = node;
                }
            }

            node.Right = temp1;
            node.Right.Parent = node;

            node.Right.Left = temp2;
            if (temp2 is not null)
            {
                node.Right.Left!.Parent = temp1;
            }

            if (node.Parent is null)
            {
                root = node;
            }

            return node;
        }

        /// <summary>
        ///     Helper function to get node instance with minimum key value
        ///     in the specified subtree.
        /// </summary>
        /// <param name="node">Node specifying root of subtree.</param>
        /// <returns>Minimum value in node's subtree.</returns>
        private RedBlackTreeNode<TKey> GetMin(RedBlackTreeNode<TKey> node)
        {
            while (node.Left is not null)
            {
                node = node.Left;
            }

            return node;
        }

        /// <summary>
        ///     Helper function to get node instance with maximum key value
        ///     in the specified subtree.
        /// </summary>
        /// <param name="node">Node specifyng root of subtree.</param>
        /// <returns>Maximum value in node's subtree.</returns>
        private RedBlackTreeNode<TKey> GetMax(RedBlackTreeNode<TKey> node)
        {
            while (node.Right is not null)
            {
                node = node.Right;
            }

            return node;
        }
    }
}
using System;
using System.Collections.Generic;
using Utilities.Exceptions;

namespace DataStructures.LinkedList.DoublyLinkedList
{
    /// <summary>
    ///     Similar to a Singly Linked List but each node contains a refenrence to the previous node in the list.
    ///     <see cref="System.Collections.Generic.LinkedList{T}" /> is a doubly linked list.
    ///     Compared to singly linked lists it can be traversed forwards and backwards.
    ///     Adding a node to a doubly linked list is simpler because ever node contains a reference to the previous node.
    /// </summary>
    /// <typeparam name="T">Generic type.</typeparam>
    public class DoublyLinkedList<T>
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="DoublyLinkedList{T}" /> class.
        /// </summary>
        /// <param name="data"> Data of the original head of the list.</param>
        public DoublyLinkedList(T data)
        {
            Head = new DoublyLinkedListNode<T>(data);
            Tail = Head;
            Count = 1;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="DoublyLinkedList{T}" /> class from an enumerable.
        /// </summary>
        /// <param name="data"> Enumerable of data to be stored in the list.</param>
        public DoublyLinkedList(IEnumerable<T> data)
        {
            foreach (var d in data)
            {
                Add(d);
            }
        }

        /// <summary>
        ///     Gets the amount of nodes in the list.
        /// </summary>
        public int Count { get; private set; }

        /// <summary>
        ///     Gets or sets the first node of the list.
        /// </summary>
        private DoublyLinkedListNode<T>? Head { get; set; }

        /// <summary>
        ///     Gets or sets the last node of the list.
        /// </summary>
        private DoublyLinkedListNode<T>? Tail { get; set; }

        /// <summary>
        ///     Replaces the Head of the list with the new value.
        /// </summary>
        /// <param name="data"> Value for the new Head of the list.</param>
        /// <returns>The new Head node.</returns>
        public DoublyLinkedListNode<T> AddHead(T data)
        {
            var node = new DoublyLinkedListNode<T>(data);

            if (Head is null)
            {
                Head = node;
                Tail = node;
                Count = 1;
                return node;
            }

            Head.Previous = node;
            node.Next = Head;
            Head = node;
            Count++;
            return node;
        }

        /// <summary>
        ///     Adds a new value at the end of the list.
        /// </summary>
        /// <param name="data"> New value to be added to the list.</param>
        /// <returns>The new node created based on the new value.</returns>
        public DoublyLinkedListNode<T> Add(T data)
        {
            if (Head is null)
            {
                return AddHead(data);
            }

            var node = new DoublyLinkedListNode<T>(data);
            Tail!.Next = node;
            node.Previous = Tail;
            Tail = node;
            Count++;
            return node;
        }

        /// <summary>
        ///     Adds a new value after an existing node.
        /// </summary>
        /// <param name="data"> New value to be added to the list.</param>
        /// <param name="existingNode"> An existing node in the list.</param>
        /// <returns>The new node created based on the new value.</returns>
        public DoublyLinkedListNode<T> AddAfter(T data, DoublyLinkedListNode<T> existingNode)
        {
            if (existingNode == Tail)
            {
                return Add(data);
            }

            var node = new DoublyLinkedListNode<T>(data);
            node.Next = existingNode.Next;
            node.Previous = existingNode;
            existingNode.Next = node;

            if (existingNode.Next is not null)
            {
                existingNode.Next.Previous = node;
            }

            Count++;
            return node;
        }

        /// <summary>
        ///     Gets an enumerable based on the data in the list.
        /// </summary>
        /// <returns>The data in the list in an IEnumerable. It can used to create a list or an array with LINQ.</returns>
        public IEnumerable<T> GetData()
        {
            var current = Head;
            while (current is not null)
            {
                yield return current.Data;
                current = current.Next;
            }
        }

        /// <summary>
        ///     Gets an enumerable based on the data in the list reversed.
        /// </summary>
        /// <returns>The data in the list in an IEnumerable. It can used to create a list or an array with LINQ.</returns>
        public IEnumerable<T> GetDataReversed()
        {
            var current = Tail;
            while (current is not null)
            {
                yield return current.Data;
                current = current.Previous;
            }
        }

        /// <summary>
        ///     Reverses the list. Because of how doubly linked list are structured this is not a complex action.
        /// </summary>
        public void Reverse()
        {
            var current = Head;
            DoublyLinkedListNode<T>? temp = null;

            while (current is not null)
            {
                temp = current.Previous;
                current.Previous = current.Next;
                current.Next = temp;
                current = current.Previous;
            }

            Tail = Head;

            // temp can be null on empty list
            if (temp is not null)
            {
                Head = temp.Previous;
            }
        }

        /// <summary>
        ///     Looks for a node in the list that contains the value of the parameter.
        /// </summary>
        /// <param name="data"> Value to be looked for in a node.</param>
        /// <returns>The node in the list the has the paramater as a value or null if not found.</returns>
        public DoublyLinkedListNode<T> Find(T data)
        {
            var current = Head;
            while (current is not null)
            {
                if (current.Data is null && data is null || current.Data is not null && current.Data.Equals(data))
                {
                    return current;
                }

                current = current.Next;
            }

            throw new ItemNotFoundException();
        }

        /// <summary>
        ///     Looks for a node in the list that contains the value of the parameter.
        /// </summary>
        /// <param name="position"> Position in the list.</param>
        /// <returns>The node in the list the has the paramater as a value or null if not found.</returns>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when position is negative or out range of the list.</exception>
        public DoublyLinkedListNode<T> GetAt(int position)
        {
            if (position < 0 || position >= Count)
            {
                throw new ArgumentOutOfRangeException($"Max count is {Count}");
            }

            var current = Head;
            for (var i = 0; i < position; i++)
            {
                current = current!.Next;
            }

            return current ?? throw new ArgumentOutOfRangeException($"{nameof(position)} must be an index in the list");
        }

        /// <summary>
        ///     Removes the Head and replaces it with the second node in the list.
        /// </summary>
        public void RemoveHead()
        {
            if (Head is null)
            {
                throw new InvalidOperationException();
            }

            Head = Head.Next;
            if (Head is null)
            {
                Tail = null;
                Count = 0;
                return;
            }

            Head.Previous = null;
            Count--;
        }

        /// <summary>
        ///     Removes the last node in the list.
        /// </summary>
        public void Remove()
        {
            if (Tail is null)
            {
                throw new InvalidOperationException("Cannot prune empty list");
            }

            Tail = Tail.Previous;
            if (Tail is null)
            {
                Head = null;
                Count = 0;
                return;
            }

            Tail.Next = null;
            Count--;
        }

        /// <summary>
        ///     Removes specific node.
        /// </summary>
        /// <param name="node"> Node to be removed.</param>
        public void RemoveNode(DoublyLinkedListNode<T> node)
        {
            if (node == Head)
            {
                RemoveHead();
                return;
            }

            if (node == Tail)
            {
                Remove();
                return;
            }

            if (node.Previous is null || node.Next is null)
            {
                throw new ArgumentException(
                    $"{nameof(node)} cannot have Previous or Next null if it's an internal node");
            }

            node.Previous.Next = node.Next;
            node.Next.Previous = node.Previous;
            Count--;
        }

        /// <summary>
        ///     Removes a node that contains the data from the parameter.
        /// </summary>
        /// <param name="data"> Data to be removed form the list.</param>
        public void Remove(T data)
        {
            var node = Find(data);
            RemoveNode(node);
        }

        /// <summary>
        ///     Looks for the index of the node with the parameter as data.
        /// </summary>
        /// <param name="data"> Data to look for.</param>
        /// <returns>Returns the index of the node if it is found or -1 if the node is not found.</returns>
        public int IndexOf(T data)
        {
            var current = Head;
            var index = 0;
            while (current is not null)
            {
                if (current.Data is null && data is null || current.Data is not null && current.Data.Equals(data))
                {
                    return index;
                }

                index++;
                current = current.Next;
            }

            return -1;
        }

        /// <summary>
        ///     List contains a node that has the parameter as data.
        /// </summary>
        /// <param name="data"> Node to be removed.</param>
        /// <returns>True if the node is found. False if it isn't.</returns>
        public bool Contains(T data) => IndexOf(data) != -1;
    }
}
namespace DataStructures.LinkedList.DoublyLinkedList
{
    /// <summary>
    ///     Generic node class for Doubly Linked List.
    /// </summary>
    /// <typeparam name="T">Generic type.</typeparam>
    public class DoublyLinkedListNode<T>
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="DoublyLinkedListNode{T}" /> class.
        /// </summary>
        /// <param name="data">Data to be stored in this node.</param>
        public DoublyLinkedListNode(T data) => Data = data;

        /// <summary>
        ///     Gets the data stored on this node.
        /// </summary>
        public T Data { get; }

        /// <summary>
        ///     Gets or sets the reference to the next node in the Doubly Linked List.
        /// </summary>
        public DoublyLinkedListNode<T>? Next { get; set; }

        /// <summary>
        ///     Gets or sets the reference to the previous node in the Doubly Linked List.
        /// </summary>
        public DoublyLinkedListNode<T>? Previous { get; set; }
    }
}
namespace DataStructures.LinkedList.SinglyLinkedList
{
    public class SinglyLinkedListNode<T>
    {
        public SinglyLinkedListNode(T data)
        {
            Data = data;
            Next = null;
        }

        public T Data { get; }

        public SinglyLinkedListNode<T>? Next { get; set; }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.LinkedList.SinglyLinkedList
{
    public class SinglyLinkedList<T>
    {
        // points to the start of the list
        private SinglyLinkedListNode<T>? Head { get; set; }

        /// <summary>
        ///     Adds new node to the start of the list,
        ///     time complexity: O(1),
        ///     space complexity: O(1).
        /// </summary>
        /// <param name="data">Contents of newly added node.</param>
        /// <returns>Added list node.</returns>
        public SinglyLinkedListNode<T> AddFirst(T data)
        {
            var newListElement = new SinglyLinkedListNode<T>(data)
            {
                Next = Head,
            };

            Head = newListElement;
            return newListElement;
        }

        /// <summary>
        ///     Adds new node to the end of the list,
        ///     time complexity: O(n),
        ///     space complexity: O(1),
        ///     where n - number of nodes in the list.
        /// </summary>
        /// <param name="data">Contents of newly added node.</param>
        /// <returns>Added list node.</returns>
        public SinglyLinkedListNode<T> AddLast(T data)
        {
            var newListElement = new SinglyLinkedListNode<T>(data);

            // if head is null, the added element is the first, hence it is the head
            if (Head is null)
            {
                Head = newListElement;
                return newListElement;
            }

            // temp ListElement to avoid overwriting the original
            var tempElement = Head;

            // iterates through all elements
            while (tempElement.Next is not null)
            {
                tempElement = tempElement.Next;
            }

            // adds the new element to the last one
            tempElement.Next = newListElement;
            return newListElement;
        }

        /// <summary>
        ///     Returns element at index <paramref name="index" /> in the list.
        /// </summary>
        /// <param name="index">Index of an element to be returned.</param>
        /// <returns>Element at index <paramref name="index" />.</returns>
        public T GetElementByIndex(int index)
        {
            if (index < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(index));
            }

            var tempElement = Head;

            for (var i = 0; tempElement is not null && i < index; i++)
            {
                tempElement = tempElement.Next;
            }

            if (tempElement is null)
            {
                throw new ArgumentOutOfRangeException(nameof(index));
            }

            return tempElement.Data;
        }

        public int Length()
        {
            // checks if there is a head
            if (Head is null)
            {
                return 0;
            }

            var tempElement = Head;
            var length = 1;

            while (tempElement.Next is not null)
            {
                tempElement = tempElement.Next;
                length++;
            }

            return length;
        }

        public IEnumerable<T> GetListData()
        {
            // temp ListElement to avoid overwriting the original
            var tempElement = Head;

            // all elements where a next attribute exists
            while (tempElement is not null)
            {
                yield return tempElement.Data;
                tempElement = tempElement.Next;
            }
        }

        public bool DeleteElement(T element)
        {
            var currentElement = Head;
            SinglyLinkedListNode<T>? previousElement = null;

            // iterates through all elements
            while (currentElement is not null)
            {
                // checks if the element, which should get deleted is in this list element
                if (currentElement.Data is null && element is null ||
                    currentElement.Data is not null && currentElement.Data.Equals(element))
                {
                    // if element is head just take the next one as head
                    if (currentElement.Equals(Head))
                    {
                        Head = Head.Next;
                        return true;
                    }

                    // else take the prev one and overwrite the next with the one behind the deleted
                    if (previousElement is not null)
                    {
                        previousElement.Next = currentElement.Next;
                        return true;
                    }
                }

                // iterating
                previousElement = currentElement;
                currentElement = currentElement.Next;
            }

            return false;
        }
    }
}
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;

namespace DataStructures.Probabilistic
{
    public class BloomFilter<T> where T : notnull
    {
        private const uint FnvPrime = 16777619;
        private const uint FnvOffsetBasis = 2166136261;
        private readonly byte[] filter;
        private readonly int numHashes;
        private readonly int sizeBits;

        /// <summary>
        /// Initializes a new instance of the <see cref="BloomFilter{T}"/> class. This constructor will create a Bloom Filter
        /// of an optimal size with the optimal number of hashes to minimize the error rate.
        /// </summary>
        /// <param name="expectedNumElements">Expected number of unique elements that could be added to the filter.</param>
        public BloomFilter(int expectedNumElements)
        {
            numHashes = (int)Math.Ceiling(.693 * 8 * expectedNumElements / expectedNumElements); // compute optimal number of hashes
            filter = new byte[expectedNumElements]; // set up filter with 8 times as many bits as elements
            sizeBits = expectedNumElements * 8; // number of bit slots in the filter
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BloomFilter{T}"/> class.
        /// This constructor let's you decide how large you want the filter to be as well as allowing you to specify
        /// how many hashes it will use. Only use if you don't care to optimize false positivity.
        /// </summary>
        /// <param name="sizeBits">size in bits you want the filter to be.</param>
        /// <param name="numHashes">number of hash functions to be used.</param>
        public BloomFilter(int sizeBits, int numHashes)
        {
            filter = new byte[sizeBits / 8 + 1];
            this.numHashes = numHashes;
            this.sizeBits = sizeBits;
        }

        /// <summary>
        /// Inserts an item into the bloom filter.
        /// </summary>
        /// <param name="item">The item being inserted into the Bloom Filter.</param>
        public void Insert(T item)
        {
            foreach (var slot in GetSlots(item))
            {
                filter[slot / 8] |= (byte)(1 << (slot % 8)); // set the filter at the decided slot to 1.
            }
        }

        /// <summary>
        /// Searches the Bloom Filter to determine if the item exists in the Bloom Filter.
        /// </summary>
        /// <param name="item">The item being searched for in the Bloom Filter.</param>
        /// <returns>true if the item has been added to the Bloom Filter, false otherwise.</returns>
        public bool Search(T item)
        {
            foreach (var slot in GetSlots(item))
            {
                var @byte = filter[slot / 8]; // Extract the byte in the filter.
                var mask = 1 << (slot % 8); // Build the mask for the slot number.
                if ((@byte & mask) != mask)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Yields the appropriate slots for the given item.
        /// </summary>
        /// <param name="item">The item to determine the slots for.</param>
        /// <returns>The slots of the filter to flip or check.</returns>
        private IEnumerable<int> GetSlots(T item)
        {
            var hash = item.GetHashCode();
            for (var i = 0; i < numHashes; i++)
            {
                yield return Math.Abs((i + 1) * hash) % sizeBits;
            }
        }
    }
}
using System;

namespace DataStructures.Probabilistic
{
    public class CountMinSketch<T> where T : notnull
    {
        private readonly int[][] sketch;
        private readonly int numHashes;

        /// <summary>
        /// Initializes a new instance of the <see cref="CountMinSketch{T}"/> class based off dimensions
        /// passed by the user.
        /// </summary>
        /// <param name="width">The width of the sketch.</param>
        /// <param name="numHashes">The number of hashes to use in the sketch.</param>
        public CountMinSketch(int width, int numHashes)
        {
            sketch = new int[numHashes][];
            for (var i = 0; i < numHashes; i++)
            {
                sketch[i] = new int[width];
            }

            this.numHashes = numHashes;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CountMinSketch{T}"/> class based off the optimizing error rate
        /// and error probability formula width = e/errorRate numHashes = ln(1.0/errorProp).
        /// </summary>
        /// <param name="errorRate">The amount of acceptable over counting for the sketch.</param>
        /// <param name="errorProb">The probability that an item will be over counted.</param>
        public CountMinSketch(double errorRate, double errorProb)
        {
            var width = (int)Math.Ceiling(Math.E / errorRate);
            numHashes = (int)Math.Ceiling(Math.Log(1.0 / errorProb));
            sketch = new int[numHashes][];
            for (var i = 0; i < numHashes; i++)
            {
                sketch[i] = new int[width];
            }
        }

        /// <summary>
        /// Inserts the provided item into the sketch.
        /// </summary>
        /// <param name="item">Item to insert.</param>
        public void Insert(T item)
        {
            var initialHash = item.GetHashCode();
            for (int i = 0; i < numHashes; i++)
            {
                var slot = GetSlot(i, initialHash);
                sketch[i][slot]++;
            }
        }

        /// <summary>
        /// Queries the count of the given item that have been inserted into the sketch.
        /// </summary>
        /// <param name="item">item to insert into the sketch.</param>
        /// <returns>the number of times the provided item has been inserted into the sketch.</returns>
        public int Query(T item)
        {
            var initialHash = item.GetHashCode();
            var min = int.MaxValue;
            for (int i = 0; i < numHashes; i++)
            {
                var slot = GetSlot(i, initialHash);
                min = Math.Min(sketch[i][slot], min);
            }

            return min;
        }

        private int GetSlot(int i, int initialHash) => Math.Abs((i + 1) * initialHash) % sketch[0].Length;
    }
}
using System;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Probabilistic
{
    public class HyperLogLog<T> where T : notnull
    {
        private const int P = 16;
        private const double Alpha = .673;
        private readonly int[] registers;
        private readonly HashSet<int> setRegisters;

        /// <summary>
        /// Initializes a new instance of the <see cref="HyperLogLog{T}"/> class.
        /// </summary>
        public HyperLogLog()
        {
            var m = 1 << P;
            registers = new int[m];
            setRegisters = new HashSet<int>();
        }

        /// <summary>
        /// Merge's two HyperLogLog's together to form a union HLL.
        /// </summary>
        /// <param name="first">the first HLL.</param>
        /// <param name="second">The second HLL.</param>
        /// <returns>A HyperLogLog with the combined values of the two sets of registers.</returns>
        public static HyperLogLog<T> Merge(HyperLogLog<T> first, HyperLogLog<T> second)
        {
            var output = new HyperLogLog<T>();
            for (var i = 0; i < second.registers.Length; i++)
            {
                output.registers[i] = Math.Max(first.registers[i], second.registers[i]);
            }

            output.setRegisters.UnionWith(first.setRegisters);
            output.setRegisters.UnionWith(second.setRegisters);
            return output;
        }

        /// <summary>
        /// Adds an item to the HyperLogLog.
        /// </summary>
        /// <param name="item">The Item to be added.</param>
        public void Add(T item)
        {
            var x = item.GetHashCode();
            var binString = Convert.ToString(x, 2); // converts hash to binary
            var j = Convert.ToInt32(binString.Substring(0, Math.Min(P, binString.Length)), 2); // convert first b bits to register index
            var w = (int)Math.Log2(x ^ (x & (x - 1))); // find position of the right most 1.
            registers[j] = Math.Max(registers[j], w); // set the appropriate register to the appropriate value.
            setRegisters.Add(j);
        }

        /// <summary>
        /// Determines the approximate cardinality of the HyperLogLog.
        /// </summary>
        /// <returns>the approximate cardinality.</returns>
        public int Cardinality()
        {
            // calculate the bottom part of the harmonic mean of the registers
            double z = setRegisters.Sum(index => Math.Pow(2, -1 * registers[index]));

            // calculate the harmonic mean of the set registers
            return (int)Math.Ceiling(Alpha * setRegisters.Count * (setRegisters.Count / z));
        }
    }
}
using System.Collections.Generic;

namespace DataStructures.Graph
{
    public interface IDirectedWeightedGraph<T>
    {
        int Count { get; }

        Vertex<T>?[] Vertices { get; }

        void AddEdge(Vertex<T> startVertex, Vertex<T> endVertex, double weight);

        Vertex<T> AddVertex(T data);

        bool AreAdjacent(Vertex<T> startVertex, Vertex<T> endVertex);

        double AdjacentDistance(Vertex<T> startVertex, Vertex<T> endVertex);

        IEnumerable<Vertex<T>?> GetNeighbors(Vertex<T> vertex);

        void RemoveEdge(Vertex<T> startVertex, Vertex<T> endVertex);

        void RemoveVertex(Vertex<T> vertex);
    }
}
namespace DataStructures.Graph
{
    /// <summary>
    ///     Implementation of graph vertex.
    /// </summary>
    /// <typeparam name="T">Generic Type.</typeparam>
    public class Vertex<T>
    {
        /// <summary>
        ///     Gets vertex data.
        /// </summary>
        public T Data { get; }

        /// <summary>
        ///     Gets an index of the vertex in graph adjacency matrix.
        /// </summary>
        public int Index { get; }

        /// <summary>
        ///     Gets reference to the graph this vertex belongs to.
        /// </summary>
        public DirectedWeightedGraph<T>? Graph { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="Vertex{T}"/> class.
        /// </summary>
        /// <param name="data">Vertex data. Generic type.</param>
        /// <param name="index">Index of the vertex in graph adjacency matrix.</param>
        /// <param name="graph">Graph this vertex belongs to.</param>
        public Vertex(T data, int index, DirectedWeightedGraph<T>? graph)
        {
            Data = data;
            Index = index;
            Graph = graph;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Vertex{T}"/> class.
        /// </summary>
        /// <param name="data">Vertex data. Generic type.</param>
        /// <param name="index">Index of the vertex in graph adjacency matrix.</param>
        public Vertex(T data, int index)
        {
            Data = data;
            Index = index;
        }

        /// <summary>
        ///     Sets graph reference to the null. This method called when vertex removed from the graph.
        /// </summary>
        public void SetGraphNull() => Graph = null;

        /// <summary>
        ///     Override of base ToString method. Prints vertex data and index in graph adjacency matrix.
        /// </summary>
        /// <returns>String which contains vertex data and index in graph adjacency matrix..</returns>
        public override string ToString() => $"Vertex Data: {Data}, Index: {Index}";
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.Graph
{
    /// <summary>
    ///     Implementation of the directed weighted graph via adjacency matrix.
    /// </summary>
    /// <typeparam name="T">Generic Type.</typeparam>
    public class DirectedWeightedGraph<T> : IDirectedWeightedGraph<T>
    {
        /// <summary>
        ///     Capacity of the graph, indicates the maximum amount of vertices.
        /// </summary>
        private readonly int capacity;

        /// <summary>
        ///     Adjacency matrix which reflects the edges between vertices and their weight.
        ///     Zero value indicates no edge between two vertices.
        /// </summary>
        private readonly double[,] adjacencyMatrix;

        /// <summary>
        ///     Initializes a new instance of the <see cref="DirectedWeightedGraph{T}"/> class.
        /// </summary>
        /// <param name="capacity">Capacity of the graph, indicates the maximum amount of vertices.</param>
        public DirectedWeightedGraph(int capacity)
        {
            ThrowIfNegativeCapacity(capacity);

            this.capacity = capacity;
            Vertices = new Vertex<T>[capacity];
            adjacencyMatrix = new double[capacity, capacity];
            Count = 0;
        }

        /// <summary>
        ///     Gets list of vertices of the graph.
        /// </summary>
        public Vertex<T>?[] Vertices { get; private set; }

        /// <summary>
        ///     Gets current amount of vertices in the graph.
        /// </summary>
        public int Count { get; private set; }

        /// <summary>
        ///     Adds new vertex to the graph.
        /// </summary>
        /// <param name="data">Data of the vertex.</param>
        /// <returns>Reference to created vertex.</returns>
        public Vertex<T> AddVertex(T data)
        {
            ThrowIfOverflow();
            var vertex = new Vertex<T>(data, Count, this);
            Vertices[Count] = vertex;
            Count++;
            return vertex;
        }

        /// <summary>
        ///     Creates an edge between two vertices of the graph.
        /// </summary>
        /// <param name="startVertex">Vertex, edge starts at.</param>
        /// <param name="endVertex">Vertex, edge ends at.</param>
        /// <param name="weight">Double weight of an edge.</param>
        public void AddEdge(Vertex<T> startVertex, Vertex<T> endVertex, double weight)
        {
            ThrowIfVertexNotInGraph(startVertex);
            ThrowIfVertexNotInGraph(endVertex);

            ThrowIfWeightZero(weight);

            var currentEdgeWeight = adjacencyMatrix[startVertex.Index, endVertex.Index];

            ThrowIfEdgeExists(currentEdgeWeight);

            adjacencyMatrix[startVertex.Index, endVertex.Index] = weight;
        }

        /// <summary>
        ///     Removes vertex from the graph.
        /// </summary>
        /// <param name="vertex">Vertex to be removed.</param>
        public void RemoveVertex(Vertex<T> vertex)
        {
            ThrowIfVertexNotInGraph(vertex);

            Vertices[vertex.Index] = null;
            vertex.SetGraphNull();

            for (var i = 0; i < Count; i++)
            {
                adjacencyMatrix[i, vertex.Index] = 0;
                adjacencyMatrix[vertex.Index, i] = 0;
            }

            Count--;
        }

        /// <summary>
        ///     Removes edge between two vertices.
        /// </summary>
        /// <param name="startVertex">Vertex, edge starts at.</param>
        /// <param name="endVertex">Vertex, edge ends at.</param>
        public void RemoveEdge(Vertex<T> startVertex, Vertex<T> endVertex)
        {
            ThrowIfVertexNotInGraph(startVertex);
            ThrowIfVertexNotInGraph(endVertex);
            adjacencyMatrix[startVertex.Index, endVertex.Index] = 0;
        }

        /// <summary>
        ///     Gets a neighbors of particular vertex.
        /// </summary>
        /// <param name="vertex">Vertex, method gets list of neighbors for.</param>
        /// <returns>Collection of the neighbors of particular vertex.</returns>
        public IEnumerable<Vertex<T>?> GetNeighbors(Vertex<T> vertex)
        {
            ThrowIfVertexNotInGraph(vertex);

            for (var i = 0; i < Count; i++)
            {
                if (adjacencyMatrix[vertex.Index, i] != 0)
                {
                    yield return Vertices[i];
                }
            }
        }

        /// <summary>
        ///     Returns true, if there is an edge between two vertices.
        /// </summary>
        /// <param name="startVertex">Vertex, edge starts at.</param>
        /// <param name="endVertex">Vertex, edge ends at.</param>
        /// <returns>True if edge exists, otherwise false.</returns>
        public bool AreAdjacent(Vertex<T> startVertex, Vertex<T> endVertex)
        {
            ThrowIfVertexNotInGraph(startVertex);
            ThrowIfVertexNotInGraph(endVertex);

            return adjacencyMatrix[startVertex.Index, endVertex.Index] != 0;
        }

        /// <summary>
        /// Return the distance between two vertices in the graph.
        /// </summary>
        /// <param name="startVertex">first vertex in edge.</param>
        /// <param name="endVertex">secnod vertex in edge.</param>
        /// <returns>distance between the two.</returns>
        public double AdjacentDistance(Vertex<T> startVertex, Vertex<T> endVertex)
        {
            if (AreAdjacent(startVertex, endVertex))
            {
                return adjacencyMatrix[startVertex.Index, endVertex.Index];
            }

            return 0;
        }

        private static void ThrowIfNegativeCapacity(int capacity)
        {
            if (capacity < 0)
            {
                throw new InvalidOperationException("Graph capacity should always be a non-negative integer.");
            }
        }

        private static void ThrowIfWeightZero(double weight)
        {
            if (weight.Equals(0.0d))
            {
                throw new InvalidOperationException("Edge weight cannot be zero.");
            }
        }

        private static void ThrowIfEdgeExists(double currentEdgeWeight)
        {
            if (!currentEdgeWeight.Equals(0.0d))
            {
                throw new InvalidOperationException($"Vertex already exists: {currentEdgeWeight}");
            }
        }

        private void ThrowIfOverflow()
        {
            if (Count == capacity)
            {
                throw new InvalidOperationException("Graph overflow.");
            }
        }

        private void ThrowIfVertexNotInGraph(Vertex<T> vertex)
        {
            if (vertex.Graph != this)
            {
                throw new InvalidOperationException($"Vertex does not belong to graph: {vertex}.");
            }
        }
    }
}
// Original Author: Christian Bender
// Class: BitArray
//
// implements IComparable, ICloneable, IEnumerator, IEnumerable
//
// This class implements a bit-array and provides some
// useful functions/operations to deal with this type of
// data structure. You see a overview about the functionality, below.
//
//
// Overview
//
// Constructor (N : int)
// The constructor receives a length (N) of the to create bit-field.
//
// Constructor (sequence : string)
// setups the array with the input sequence.
// assumes: the sequence may only be allowed contains onese or zeros.
//
// Constructor (bits : bool[] )
// setups the bit-field with the input array.
//
// Compile(sequence : string)
// compiles a string sequence of 0's and 1's in the inner structure.
// assumes: the sequence may only be allowed contains onese or zeros.
//
// Compile (number : int)
// compiles a positive integer number in the inner data structure.
//
// Compile (number : long)
// compiles a positive long integer number in the inner data structure.
//
// ToString ()
// returns a string representation of the inner structure.
// The returned string is a sequence of 0's and 1's.
//
// Length : int
// Is a property that returns the length of the bit-field.
//
// Indexer : bool
// indexer for selecting the individual bits of the bit array.
//
// NumberOfOneBits() : int
// returns the number of One-bits.
//
// NumberOfZeroBits() : int
// returns the number of Zero-Bits.
//
// EvenParity() : bool
// returns true if parity is even, otherwise false.
//
// OddParity() : bool
// returns true if parity is odd, otherwise false.
//
// ToInt64() : long
// returns a long integer representation of the bit-array.
// assumes: the bit-array length must been smaller or equal to 64 bit.
//
// ToInt32() : int
// returns a integer representation of the bit-array.
// assumes: the bit-array length must been smaller or equal to 32 bit.
//
// ResetField() : void
// sets all bits on false.
//
// SetAll(flag : bool) : void
// sets all bits on the value of the flag.
//
// GetHashCode() : int
// returns hash-code (ToInt32())
//
// Equals (other : Object) : bool
// returns true if there inputs are equal otherwise false.
// assumes: the input bit-arrays must have same length.
//
// CompareTo (other : Object) : int  (interface IComparable)
// output:  0 - if the bit-arrays a equal.
// -1 - if this bit-array is smaller.
// 1 - if this bit-array is greater.
// assumes: bit-array lentgh must been smaller or equal to 64 bit
//
// Clone () : object
// returns a copy of this bit-array
//
// Current : object
// returns the current selected bit.
//
// MoveNext() : bool
// purpose: increases the position of the enumerator
// returns true if 'position' successful increased otherwise false.
//
// Reset() : void
// resets the position of the enumerator.
//
// GetEnumerator() : IEnumerator
// returns a enumerator for this BitArray-object.
//
// Operations:
//
// &amp; bitwise AND
// | bitwise OR
// ~ bitwise NOT
// >> bitwise shift right
// >> bitwise shift left
// ^ bitwise XOR
//
// Each operation (above) returns a new BitArray-object.
//
// == equal operator. : bool
// returns true if there inputs are equal otherwise false.
// assumes: the input bit-arrays must have same length.
//
// != not-equal operator : bool
// returns true if there inputs aren't equal otherwise false.
// assumes: the input bit-arrays must have same length.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DataStructures
{
    /// <summary>
    ///     This class implements a bit-array and provides some
    ///     useful functions/operations to deal with this type of
    ///     data structure.
    /// </summary>
    public sealed class BitArray : ICloneable, IEnumerator<bool>, IEnumerable<bool>
    {
        private readonly bool[] field; // the actual bit-field
        private int position = -1; // position for enumerator

        /// <summary>
        ///     Initializes a new instance of the <see cref="BitArray" /> class.
        ///     setups the array with false-values.
        /// </summary>
        /// <param name="n">length of the array.</param>
        public BitArray(int n)
        {
            if (n < 1)
            {
                field = new bool[0];
            }

            field = new bool[n];
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="BitArray" /> class.
        ///     Setups the array with the input sequence.
        ///     purpose: Setups the array with the input sequence.
        ///     assumes: sequence must been greater or equal to 1.
        ///     the sequence may only contain ones or zeros.
        /// </summary>
        /// <param name="sequence">A string sequence of 0's and 1's.</param>
        public BitArray(string sequence)
        {
            // precondition I
            if (sequence.Length <= 0)
            {
                throw new ArgumentException("Sequence must been greater than or equal to 1");
            }

            // precondition II
            ThrowIfSequenceIsInvalid(sequence);

            field = new bool[sequence.Length];
            Compile(sequence);
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="BitArray" /> class.
        ///     Setups the bit-array with the input array.
        /// </summary>
        /// <param name="bits">A boolean array of bits.</param>
        public BitArray(bool[] bits) => field = bits;

        /// <summary>
        ///     Gets the length of the current bit array.
        /// </summary>
        private int Length => field.Length;

        /// <summary>
        ///     Gets element given an offset.
        /// </summary>
        /// <param name="offset">Position.</param>
        /// <returns>Element on array.</returns>
        public bool this[int offset]
        {
            get => field[offset];
            private set => field[offset] = value;
        }

        /// <summary>
        ///     Returns a copy of the current bit-array.
        /// </summary>
        /// <returns>Bit-array clone.</returns>
        public object Clone()
        {
            var theClone = new BitArray(Length);

            for (var i = 0; i < Length; i++)
            {
                theClone[i] = field[i];
            }

            return theClone;
        }

        /// <summary>
        ///     Gets a enumerator for this BitArray-Object.
        /// </summary>
        /// <returns>Returns a enumerator for this BitArray-Object.</returns>
        public IEnumerator<bool> GetEnumerator() => this;

        /// <summary>
        ///     Gets a enumerator for this BitArray-Object.
        /// </summary>
        /// <returns>Returns a enumerator for this BitArray-Object.</returns>
        IEnumerator IEnumerable.GetEnumerator() => this;

        /// <summary>
        ///     Gets a value indicating whether the current bit of the array is set.
        /// </summary>
        public bool Current => field[position];

        /// <summary>
        ///     Gets a value indicating whether the current bit of the array is set.
        /// </summary>
        object IEnumerator.Current => field[position];

        /// <summary>
        ///     MoveNext (for interface IEnumerator).
        /// </summary>
        /// <returns>Returns True if 'position' successful increased; False otherwise.</returns>
        public bool MoveNext()
        {
            if (position + 1 >= field.Length)
            {
                return false;
            }

            position++;
            return true;
        }

        /// <summary>
        ///     Resets the position of the enumerator.
        ///     Reset (for interface IEnumerator).
        /// </summary>
        public void Reset() => position = -1;

        /// <summary>
        ///     Disposes object, nothing to dispose here though.
        /// </summary>
        public void Dispose()
        {
            // Done
        }

        /// <summary>
        ///     Returns a bit-array that represents the bit by bit AND (&amp;).
        ///     Assumes arrays have the same length.
        /// </summary>
        /// <param name="one">First bit-array.</param>
        /// <param name="two">Second bit-array.</param>
        /// <returns>bit-array.</returns>
        public static BitArray operator &(BitArray one, BitArray two)
        {
            var sequence1 = one.ToString();
            var sequence2 = two.ToString();
            var result = new StringBuilder();
            var tmp = new StringBuilder();

            // for scaling of same length.
            if (one.Length != two.Length)
            {
                int difference;
                if (one.Length > two.Length)
                {
                    // one is greater
                    difference = one.Length - two.Length;

                    // fills up with 0's
                    for (var i = 0; i < difference; i++)
                    {
                        tmp.Append('0');
                    }

                    tmp.Append(two);
                    sequence2 = tmp.ToString();
                }
                else
                {
                    // two is greater
                    difference = two.Length - one.Length;

                    // fills up with 0's
                    for (var i = 0; i < difference; i++)
                    {
                        tmp.Append('0');
                    }

                    tmp.Append(one);
                    sequence1 = tmp.ToString();
                }
            } // end scaling

            var len = one.Length > two.Length ? one.Length : two.Length;
            var ans = new BitArray(len);

            for (var i = 0; i < one.Length; i++)
            {
                result.Append(sequence1[i].Equals('1') && sequence2[i].Equals('1') ? '1' : '0');
            }

            ans.Compile(result.ToString().Trim());

            return ans;
        }

        /// <summary>
        ///     Returns a bit-array that represents the bit by bit OR.
        ///     Assumes arrays have the same length.
        /// </summary>
        /// <param name="one">First bit-array.</param>
        /// <param name="two">Second bit-array.</param>
        /// <returns>bit-array that represents the bit by bit OR.</returns>
        public static BitArray operator |(BitArray one, BitArray two)
        {
            var sequence1 = one.ToString();
            var sequence2 = two.ToString();
            var result = string.Empty;
            var tmp = string.Empty;

            // for scaling of same length.
            if (one.Length != two.Length)
            {
                int difference;
                if (one.Length > two.Length)
                {
                    // one is greater
                    difference = one.Length - two.Length;

                    // fills up with 0's
                    for (var i = 0; i < difference; i++)
                    {
                        tmp += '0';
                    }

                    tmp += two.ToString();
                    sequence2 = tmp;
                }
                else
                {
                    // two is greater
                    difference = two.Length - one.Length;

                    // fills up with 0's
                    for (var i = 0; i < difference; i++)
                    {
                        tmp += '0';
                    }

                    tmp += one.ToString();
                    sequence1 = tmp;
                }
            } // end scaling

            var len = one.Length > two.Length ? one.Length : two.Length;
            var ans = new BitArray(len);

            for (var i = 0; i < len; i++)
            {
                result += sequence1[i].Equals('0') && sequence2[i].Equals('0') ? '0' : '1';
            }

            result = result.Trim();
            ans.Compile(result);

            return ans;
        }

        /// <summary>
        ///     Returns a bit-array that represents the operator ~ (NOT).
        ///     Assumes arrays have the same length.
        /// </summary>
        /// <param name="one">Bit-array.</param>
        /// <returns>bitwise not.</returns>
        public static BitArray operator ~(BitArray one)
        {
            var ans = new BitArray(one.Length);
            var sequence = one.ToString();
            var result = string.Empty;

            foreach (var ch in sequence)
            {
                if (ch == '1')
                {
                    result += '0';
                }
                else
                {
                    result += '1';
                }
            }

            result = result.Trim();
            ans.Compile(result);

            return ans;
        }

        /// <summary>
        ///     Returns a bit-array that represents bitwise shift left (&gt;&gt;).
        ///     Assumes arrays have the same length.
        /// </summary>
        /// <param name="other">Bit-array.</param>
        /// <param name="n">Number of bits.</param>
        /// <returns>Bitwise shifted BitArray.</returns>
        public static BitArray operator <<(BitArray other, int n)
        {
            var ans = new BitArray(other.Length + n);

            // actual shifting process
            for (var i = 0; i < other.Length; i++)
            {
                ans[i] = other[i];
            }

            return ans;
        }

        /// <summary>
        ///     Returns a bit-array that represents the bit by bit XOR.
        ///     Assumes arrays have the same length.
        /// </summary>
        /// <param name="one">First bit-array.</param>
        /// <param name="two">Second bit-array.</param>
        /// <returns>bit-array.</returns>
        public static BitArray operator ^(BitArray one, BitArray two)
        {
            var sequence1 = one.ToString();
            var sequence2 = two.ToString();
            var tmp = string.Empty;

            // for scaling of same length.
            if (one.Length != two.Length)
            {
                int difference;
                if (one.Length > two.Length)
                {
                    // one is greater
                    difference = one.Length - two.Length;

                    // fills up with 0's
                    for (var i = 0; i < difference; i++)
                    {
                        tmp += '0';
                    }

                    tmp += two.ToString();
                    sequence2 = tmp;
                }
                else
                {
                    // two is greater
                    difference = two.Length - one.Length;

                    // fills up with 0's
                    for (var i = 0; i < difference; i++)
                    {
                        tmp += '0';
                    }

                    tmp += one.ToString();
                    sequence1 = tmp;
                }
            } // end scaling

            var len = one.Length > two.Length ? one.Length : two.Length;
            var ans = new BitArray(len);

            var sb = new StringBuilder();

            for (var i = 0; i < len; i++)
            {
                _ = sb.Append(sequence1[i] == sequence2[i] ? '0' : '1');
            }

            var result = sb.ToString().Trim();
            ans.Compile(result);

            return ans;
        }

        /// <summary>
        ///     Returns a bit-array that represents bitwise shift right (>>).
        ///     Assumes arrays have the same length.
        /// </summary>
        /// <param name="other">Bit-array.</param>
        /// <param name="n">Number of bits.</param>
        /// <returns>Bitwise shifted BitArray.</returns>
        public static BitArray operator >>(BitArray other, int n)
        {
            var ans = new BitArray(other.Length - n);

            // actual shifting process.
            for (var i = 0; i < other.Length - n; i++)
            {
                ans[i] = other[i];
            }

            return ans;
        }

        /// <summary>
        ///     Checks if both arrays are == (equal).
        ///     The input assumes arrays have the same length.
        /// </summary>
        /// <param name="one">First bit-array.</param>
        /// <param name="two">Second bit-array.</param>
        /// <returns>Returns True if there inputs are equal; False otherwise.</returns>
        public static bool operator ==(BitArray one, BitArray two)
        {
            if (ReferenceEquals(one, two))
            {
                return true;
            }

            if (one.Length != two.Length)
            {
                return false;
            }

            var status = true;
            for (var i = 0; i < one.Length; i++)
            {
                if (one[i] != two[i])
                {
                    status = false;
                    break;
                }
            }

            return status;
        }

        /// <summary>
        ///     Checks if both arrays are != (not-equal).
        ///     The input assumes arrays have the same length.
        /// </summary>
        /// <param name="one">First bit-array.</param>
        /// <param name="two">Second bit-array.</param>
        /// <returns>Returns True if there inputs aren't equal; False otherwise.</returns>
        public static bool operator !=(BitArray one, BitArray two) => !(one == two);

        /// <summary>
        ///     Compiles the binary sequence into the inner data structure.
        ///     The sequence must have the same length, as the bit-array.
        ///     The sequence may only be allowed contains ones or zeros.
        /// </summary>
        /// <param name="sequence">A string sequence of 0's and 1's.</param>
        public void Compile(string sequence)
        {
            // precondition I
            if (sequence.Length > field.Length)
            {
                throw new ArgumentException($"{nameof(sequence)} must be not longer than the bit array length");
            }

            // precondition II
            ThrowIfSequenceIsInvalid(sequence);

            // for appropriate scaling
            var tmp = string.Empty;
            if (sequence.Length < field.Length)
            {
                var difference = field.Length - sequence.Length;

                for (var i = 0; i < difference; i++)
                {
                    tmp += '0';
                }

                tmp += sequence;
                sequence = tmp;
            }

            // actual compile procedure.
            for (var i = 0; i < sequence.Length; i++)
            {
                field[i] = sequence[i] == '1';
            }
        }

        /// <summary>
        ///     Compiles integer number into the inner data structure.
        ///     Assumes: the number must have the same bit length.
        /// </summary>
        /// <param name="number">A positive integer number.</param>
        public void Compile(int number)
        {
            var tmp = string.Empty;

            // precondition I
            if (number <= 0)
            {
                throw new ArgumentException($"{nameof(number)} must be positive");
            }

            // converts to binary representation
            var binaryNumber = Convert.ToString(number, 2);

            // precondition II
            if (binaryNumber.Length > field.Length)
            {
                throw new ArgumentException("Provided number is too big");
            }

            // for appropriate scaling
            if (binaryNumber.Length < field.Length)
            {
                var difference = field.Length - binaryNumber.Length;

                for (var i = 0; i < difference; i++)
                {
                    tmp += '0';
                }

                tmp += binaryNumber;
                binaryNumber = tmp;
            }

            // actual compile procedure.
            for (var i = 0; i < binaryNumber.Length; i++)
            {
                field[i] = binaryNumber[i] == '1';
            }
        }

        /// <summary>
        ///     Compiles integer number into the inner data structure.
        ///     The number must have the same bit length.
        /// </summary>
        /// <param name="number">A positive long integer number.</param>
        public void Compile(long number)
        {
            var tmp = string.Empty;

            // precondition I
            if (number <= 0)
            {
                throw new ArgumentException($"{nameof(number)} must be positive");
            }

            // converts to binary representation
            var binaryNumber = Convert.ToString(number, 2);

            // precondition II
            if (binaryNumber.Length > field.Length)
            {
                throw new ArgumentException("Provided number is too big");
            }

            // for appropriate scaling
            if (binaryNumber.Length < field.Length)
            {
                var difference = field.Length - binaryNumber.Length;

                for (var i = 0; i < difference; i++)
                {
                    tmp += '0';
                }

                tmp += binaryNumber;
                binaryNumber = tmp;
            }

            // actual compile procedure.
            for (var i = 0; i < binaryNumber.Length; i++)
            {
                field[i] = binaryNumber[i] == '1';
            }
        }

        /// <summary>
        ///     Is the opposit of the Compile(...) method.
        /// </summary>
        /// <returns>Returns a string representation of the inner data structure.</returns>
        public override string ToString()
        {
            // creates return-string
            return field.Aggregate(string.Empty, (current, t) => current + (t ? "1" : "0"));
        }

        /// <summary>
        ///     Gets the number of one-bits in the field.
        /// </summary>
        /// <returns>quantity of bits in current bit-array.</returns>
        public int NumberOfOneBits()
        {
            // counting one-bits.
            return field.Count(bit => bit);
        }

        /// <summary>
        ///     Gets the number of zero-bits in the field.
        /// </summary>
        /// <returns>quantity of bits.</returns>
        public int NumberOfZeroBits()
        {
            // counting zero-bits
            return field.Count(bit => !bit);
        }

        /// <summary>
        ///     To check for even parity.
        /// </summary>
        /// <returns>Returns True if parity is even; False otherwise.</returns>
        public bool EvenParity() => NumberOfOneBits() % 2 == 0;

        /// <summary>
        ///     To check for odd parity.
        /// </summary>
        /// <returns>Returns True if parity is odd; False otherwise.</returns>
        public bool OddParity() => NumberOfOneBits() % 2 != 0;

        /// <summary>
        ///     Returns a long integer representation of the bit-array.
        ///     Assumes the bit-array length must been smaller or equal to 64 bit.
        /// </summary>
        /// <returns>Long integer array.</returns>
        public long ToInt64()
        {
            // Precondition
            if (field.Length > 64)
            {
                throw new InvalidOperationException("Value is too big to fit into Int64");
            }

            var sequence = ToString();
            return Convert.ToInt64(sequence, 2);
        }

        /// <summary>
        ///     Returns a long integer representation of the bit-array.
        ///     Assumes the bit-array length must been smaller or equal to 32 bit.
        /// </summary>
        /// <returns>integer array.</returns>
        public int ToInt32()
        {
            // Precondition
            if (field.Length > 32)
            {
                throw new InvalidOperationException("Value is too big to fit into Int32");
            }

            var sequence = ToString();
            return Convert.ToInt32(sequence, 2);
        }

        /// <summary>
        ///     Sets all bits on false.
        /// </summary>
        public void ResetField()
        {
            for (var i = 0; i < field.Length; i++)
            {
                field[i] = false;
            }
        }

        /// <summary>
        ///     Sets all bits on the value of the flag.
        /// </summary>
        /// <param name="flag">Bollean flag (false-true).</param>
        public void SetAll(bool flag)
        {
            for (var i = 0; i < field.Length; i++)
            {
                field[i] = flag;
            }
        }

        /// <summary>
        ///     Checks if bit-array are equal.
        ///     Assumes the input bit-arrays must have same length.
        /// </summary>
        /// <param name="obj">Bit-array object.</param>
        /// <returns>Returns true if there inputs are equal otherwise false.</returns>
        public override bool Equals(object? obj)
        {
            if (obj is null)
            {
                return false;
            }

            var otherBitArray = (BitArray)obj;

            if (Length != otherBitArray.Length)
            {
                return false;
            }

            for (var i = 0; i < Length; i++)
            {
                if (field[i] != otherBitArray[i])
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        ///     Gets has-code of bit-array.
        ///     Assumes bit-array length must been smaller or equal to 32.
        /// </summary>
        /// <returns>hash-code for this BitArray instance.</returns>
        public override int GetHashCode() => ToInt32();

        private static void ThrowIfSequenceIsInvalid(string sequence)
        {
            if (!Match(sequence))
            {
                throw new ArgumentException("The sequence may only contain ones or zeros");
            }
        }

        /// <summary>
        ///     Utility method foir checking a given sequence contains only zeros and ones.
        ///     This method will used in Constructor (sequence : string) and Compile(sequence : string).
        /// </summary>
        /// <param name="sequence">String sequence.</param>
        /// <returns>returns True if sequence contains only zeros and ones; False otherwise.</returns>
        private static bool Match(string sequence) => sequence.All(ch => ch == '0' || ch == '1');
    }
}
/*
    Author: Lorenzo Lotti
    Name: Timeline (DataStructures.Timeline<TValue>)
    Type: Data structure (class)
    Description: A collection of dates/times and values sorted by dates/times easy to query.
    Usage:
        this data structure can be used to represent an ordered series of dates or times with which to associate values.
        An example is a chronology of events:
            306: Constantine is the new emperor,
            312: Battle of the Milvian Bridge,
            313: Edict of Milan,
            330: Constantine move the capital to Constantinople.
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures
{
    /// <summary>
    ///     A collection of <see cref="DateTime" /> and <see cref="TValue" />
    ///     sorted by <see cref="DateTime" /> field.
    /// </summary>
    /// <typeparam name="TValue">Value associated with a <see cref="DateTime" />.</typeparam>
    public class Timeline<TValue> : ICollection<(DateTime Time, TValue Value)>, IEquatable<Timeline<TValue>>
    {
        /// <summary>
        ///     Inner collection storing the timeline events as key-tuples.
        /// </summary>
        private readonly List<(DateTime Time, TValue Value)> timeline = new();

        /// <summary>
        ///     Initializes a new instance of the <see cref="Timeline{TValue}"/> class.
        /// </summary>
        public Timeline()
        {
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="Timeline{TValue}"/> class populated with an initial event.
        /// </summary>
        /// <param name="time">The time at which the given event occurred.</param>
        /// <param name="value">The event's content.</param>
        public Timeline(DateTime time, TValue value)
            => timeline = new List<(DateTime, TValue)>
            {
                (time, value),
            };

        /// <summary>
        ///     Initializes a new instance of the <see cref="Timeline{TValue}"/> class containing the provided events
        ///     ordered chronologically.
        /// </summary>
        /// <param name="timeline">The timeline to represent.</param>
        public Timeline(params (DateTime, TValue)[] timeline)
            => this.timeline = timeline
                .OrderBy(pair => pair.Item1)
                .ToList();

        /// <summary>
        /// Gets he number of unique times within this timeline.
        /// </summary>
        public int TimesCount
            => GetAllTimes().Length;

        /// <summary>
        ///     Gets all events that has occurred in this timeline.
        /// </summary>
        public int ValuesCount
            => GetAllValues().Length;

        /// <summary>
        ///     Get all values associated with <paramref name="time" />.
        /// </summary>
        /// <param name="time">Time to get values for.</param>
        /// <returns>Values associated with <paramref name="time" />.</returns>
        public TValue[] this[DateTime time]
        {
            get => GetValuesByTime(time);
            set
            {
                var overridenEvents = timeline.Where(@event => @event.Time == time).ToList();
                foreach (var @event in overridenEvents)
                {
                    timeline.Remove(@event);
                }

                foreach (var v in value)
                {
                    Add(time, v);
                }
            }
        }

        /// <inheritdoc />
        bool ICollection<(DateTime Time, TValue Value)>.IsReadOnly
            => false;

        /// <summary>
        ///     Gets the count of pairs.
        /// </summary>
        public int Count
            => timeline.Count;

        /// <summary>
        ///     Clear the timeline, removing all events.
        /// </summary>
        public void Clear()
            => timeline.Clear();

        /// <summary>
        ///     Copy a value to an array.
        /// </summary>
        /// <param name="array">Destination array.</param>
        /// <param name="arrayIndex">The start index.</param>
        public void CopyTo((DateTime, TValue)[] array, int arrayIndex)
            => timeline.CopyTo(array, arrayIndex);

        /// <summary>
        ///     Add an event at a given time.
        /// </summary>
        /// <param name="item">The tuple containing the event date and value.</param>
        void ICollection<(DateTime Time, TValue Value)>.Add((DateTime Time, TValue Value) item)
            => Add(item.Time, item.Value);

        /// <summary>
        ///     Check whether or not a event exists at a specific date in the timeline.
        /// </summary>
        /// <param name="item">The tuple containing the event date and value.</param>
        /// <returns>True if this event exists at the given date, false otherwise.</returns>
        bool ICollection<(DateTime Time, TValue Value)>.Contains((DateTime Time, TValue Value) item)
            => Contains(item.Time, item.Value);

        /// <summary>
        ///     Remove an event at a specific date.
        /// </summary>
        /// <param name="item">The tuple containing the event date and value.</param>
        /// <returns>True if the event was removed, false otherwise.</returns>
        bool ICollection<(DateTime Time, TValue Value)>.Remove((DateTime Time, TValue Value) item)
            => Remove(item.Time, item.Value);

        /// <inheritdoc />
        IEnumerator IEnumerable.GetEnumerator()
            => timeline.GetEnumerator();

        /// <inheritdoc />
        IEnumerator<(DateTime Time, TValue Value)> IEnumerable<(DateTime Time, TValue Value)>.GetEnumerator()
            => timeline.GetEnumerator();

        /// <inheritdoc />
        public bool Equals(Timeline<TValue>? other)
            => other is not null && this == other;

        /// <summary>
        ///     Checks whether or not two <see cref="Timeline{TValue}"/> are equals.
        /// </summary>
        /// <param name="left">The first timeline.</param>
        /// <param name="right">The other timeline to be checked against the <paramref name="left"/> one.</param>
        /// <returns>True if both timelines are similar, false otherwise.</returns>
        public static bool operator ==(Timeline<TValue> left, Timeline<TValue> right)
        {
            var leftArray = left.ToArray();
            var rightArray = right.ToArray();

            if (left.Count != rightArray.Length)
            {
                return false;
            }

            for (var i = 0; i < leftArray.Length; i++)
            {
                if (leftArray[i].Time != rightArray[i].Time
                    && !leftArray[i].Value!.Equals(rightArray[i].Value))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        ///     Checks whether or not two <see cref="Timeline{TValue}"/> are not equals.
        /// </summary>
        /// <param name="left">The first timeline.</param>
        /// <param name="right">The other timeline to be checked against the <paramref name="left"/> one.</param>
        /// <returns>False if both timelines are similar, true otherwise.</returns>
        public static bool operator !=(Timeline<TValue> left, Timeline<TValue> right)
            => !(left == right);

        /// <summary>
        ///     Get all <see cref="DateTime" /> of the timeline.
        /// </summary>
        public DateTime[] GetAllTimes()
            => timeline.Select(t => t.Time)
                .Distinct()
                .ToArray();

        /// <summary>
        ///     Get <see cref="DateTime" /> values of the timeline that have this <paramref name="value" />.
        /// </summary>
        public DateTime[] GetTimesByValue(TValue value)
            => timeline.Where(pair => pair.Value!.Equals(value))
                .Select(pair => pair.Time)
                .ToArray();

        /// <summary>
        ///     Get all <see cref="DateTime" /> before <paramref name="time" />.
        /// </summary>
        public DateTime[] GetTimesBefore(DateTime time)
            => GetAllTimes()
                .Where(t => t < time)
                .OrderBy(t => t)
                .ToArray();

        /// <summary>
        ///     Get all <see cref="DateTime" /> after <paramref name="time" />.
        /// </summary>
        public DateTime[] GetTimesAfter(DateTime time)
            => GetAllTimes()
                .Where(t => t > time)
                .OrderBy(t => t)
                .ToArray();

        /// <summary>
        ///     Get all <see cref="TValue" /> of the timeline.
        /// </summary>
        public TValue[] GetAllValues()
            => timeline.Select(pair => pair.Value)
                .ToArray();

        /// <summary>
        ///     Get all <see cref="TValue" /> associated with <paramref name="time" />.
        /// </summary>
        public TValue[] GetValuesByTime(DateTime time)
            => timeline.Where(pair => pair.Time == time)
                .Select(pair => pair.Value)
                .ToArray();

        /// <summary>
        ///     Get all <see cref="TValue" /> before <paramref name="time" />.
        /// </summary>
        public Timeline<TValue> GetValuesBefore(DateTime time)
            => new(this.Where(pair => pair.Time < time).ToArray());

        /// <summary>
        ///     Get all <see cref="TValue" /> before <paramref name="time" />.
        /// </summary>
        public Timeline<TValue> GetValuesAfter(DateTime time)
            => new(this.Where(pair => pair.Time > time).ToArray());

        /// <summary>
        ///     Gets all values that happened at specified millisecond.
        /// </summary>
        /// <param name="millisecond">Value to look for.</param>
        /// <returns>Array of values.</returns>
        public Timeline<TValue> GetValuesByMillisecond(int millisecond)
            => new(timeline.Where(pair => pair.Time.Millisecond == millisecond).ToArray());

        /// <summary>
        ///     Gets all values that happened at specified second.
        /// </summary>
        /// <param name="second">Value to look for.</param>
        /// <returns>Array of values.</returns>
        public Timeline<TValue> GetValuesBySecond(int second)
            => new(timeline.Where(pair => pair.Time.Second == second).ToArray());

        /// <summary>
        ///     Gets all values that happened at specified minute.
        /// </summary>
        /// <param name="minute">Value to look for.</param>
        /// <returns>Array of values.</returns>
        public Timeline<TValue> GetValuesByMinute(int minute)
            => new(timeline.Where(pair => pair.Time.Minute == minute).ToArray());

        /// <summary>
        ///     Gets all values that happened at specified hour.
        /// </summary>
        /// <param name="hour">Value to look for.</param>
        /// <returns>Array of values.</returns>
        public Timeline<TValue> GetValuesByHour(int hour)
            => new(timeline.Where(pair => pair.Time.Hour == hour).ToArray());

        /// <summary>
        ///     Gets all values that happened at specified day.
        /// </summary>
        /// <param name="day">Value to look for.</param>
        /// <returns>Array of values.</returns>
        public Timeline<TValue> GetValuesByDay(int day)
            => new(timeline.Where(pair => pair.Time.Day == day).ToArray());

        /// <summary>
        ///     Gets all values that happened at specified time of the day.
        /// </summary>
        /// <param name="timeOfDay">Value to look for.</param>
        /// <returns>Array of values.</returns>
        public Timeline<TValue> GetValuesByTimeOfDay(TimeSpan timeOfDay)
            => new(timeline.Where(pair => pair.Time.TimeOfDay == timeOfDay).ToArray());

        /// <summary>
        ///     Gets all values that happened at specified day of the week.
        /// </summary>
        /// <param name="dayOfWeek">Value to look for.</param>
        /// <returns>Array of values.</returns>
        public Timeline<TValue> GetValuesByDayOfWeek(DayOfWeek dayOfWeek)
            => new(timeline.Where(pair => pair.Time.DayOfWeek == dayOfWeek).ToArray());

        /// <summary>
        ///     Gets all values that happened at specified day of the year.
        /// </summary>
        /// <param name="dayOfYear">Value to look for.</param>
        /// <returns>Array of values.</returns>
        public Timeline<TValue> GetValuesByDayOfYear(int dayOfYear)
            => new(timeline.Where(pair => pair.Time.DayOfYear == dayOfYear).ToArray());

        /// <summary>
        ///     Gets all values that happened at specified month.
        /// </summary>
        /// <param name="month">Value to look for.</param>
        /// <returns>Array of values.</returns>
        public Timeline<TValue> GetValuesByMonth(int month)
            => new(timeline.Where(pair => pair.Time.Month == month).ToArray());

        /// <summary>
        ///     Gets all values that happened at specified year.
        /// </summary>
        /// <param name="year">Value to look for.</param>
        /// <returns>Array of values.</returns>
        public Timeline<TValue> GetValuesByYear(int year)
            => new(timeline.Where(pair => pair.Time.Year == year).ToArray());

        /// <summary>
        ///     Add an event at a given <paramref name="time"/>.
        /// </summary>
        /// <param name="time">The date at which the event occurred.</param>
        /// <param name="value">The event value.</param>
        public void Add(DateTime time, TValue value)
        {
            timeline.Add((time, value));
        }

        /// <summary>
        ///     Add a set of <see cref="DateTime" /> and <see cref="TValue" /> to the timeline.
        /// </summary>
        public void Add(params (DateTime, TValue)[] timeline)
        {
            this.timeline.AddRange(timeline);
        }

        /// <summary>
        ///     Append an existing timeline to this one.
        /// </summary>
        public void Add(Timeline<TValue> timeline)
            => Add(timeline.ToArray());

        /// <summary>
        ///     Add a <paramref name="value" /> associated with <see cref="DateTime.Now" /> to the timeline.
        /// </summary>
        public void AddNow(params TValue[] value)
        {
            var now = DateTime.Now;
            foreach (var v in value)
            {
                Add(now, v);
            }
        }

        /// <summary>
        ///     Check whether or not a event exists at a specific date in the timeline.
        /// </summary>
        /// <param name="time">The date at which the event occurred.</param>
        /// <param name="value">The event value.</param>
        /// <returns>True if this event exists at the given date, false otherwise.</returns>
        public bool Contains(DateTime time, TValue value)
            => timeline.Contains((time, value));

        /// <summary>
        ///     Check if timeline contains this set of value pairs.
        /// </summary>
        /// <param name="timeline">The events to checks.</param>
        /// <returns>True if any of the events has occurred in the timeline.</returns>
        public bool Contains(params (DateTime, TValue)[] timeline)
            => timeline.Any(@event => Contains(@event.Item1, @event.Item2));

        /// <summary>
        ///     Check if timeline contains any of the event of the provided <paramref name="timeline"/>.
        /// </summary>
        /// <param name="timeline">The events to checks.</param>
        /// <returns>True if any of the events has occurred in the timeline.</returns>
        public bool Contains(Timeline<TValue> timeline)
            => Contains(timeline.ToArray());

        /// <summary>
        ///     Check if timeline contains any of the time of the provided <paramref name="times"/>.
        /// </summary>
        /// <param name="times">The times to checks.</param>
        /// <returns>True if any of the times is stored in the timeline.</returns>
        public bool ContainsTime(params DateTime[] times)
        {
            var storedTimes = GetAllTimes();
            return times.Any(value => storedTimes.Contains(value));
        }

        /// <summary>
        ///     Check if timeline contains any of the event of the provided <paramref name="values"/>.
        /// </summary>
        /// <param name="values">The events to checks.</param>
        /// <returns>True if any of the events has occurred in the timeline.</returns>
        public bool ContainsValue(params TValue[] values)
        {
            var storedValues = GetAllValues();
            return values.Any(value => storedValues.Contains(value));
        }

        /// <summary>
        ///     Remove an event at a specific date.
        /// </summary>
        /// <param name="time">The date at which the event occurred.</param>
        /// <param name="value">The event value.</param>
        /// <returns>True if the event was removed, false otherwise.</returns>
        public bool Remove(DateTime time, TValue value)
            => timeline.Remove((time, value));

        /// <summary>
        ///     Remove a set of value pairs from the timeline.
        /// </summary>
        /// <param name="timeline">An collection of all events to remove.</param>
        /// <returns>Returns true if the operation completed successfully.</returns>
        public bool Remove(params (DateTime, TValue)[] timeline)
        {
            var result = false;
            foreach (var (time, value) in timeline)
            {
                result |= this.timeline.Remove((time, value));
            }

            return result;
        }

        /// <summary>
        ///     Remove an existing timeline from this timeline.
        /// </summary>
        /// <param name="timeline">An collection of all events to remove.</param>
        /// <returns>Returns true if the operation completed successfully.</returns>
        public bool Remove(Timeline<TValue> timeline)
            => Remove(timeline.ToArray());

        /// <summary>
        ///     Remove a value pair from the timeline if the time is equal to <paramref name="times" />.
        /// </summary>
        /// <returns>Returns true if the operation completed successfully.</returns>
        public bool RemoveTimes(params DateTime[] times)
        {
            var isTimeContainedInTheTimeline = times.Any(time => GetAllTimes().Contains(time));

            if (!isTimeContainedInTheTimeline)
            {
                return false;
            }

            var eventsToRemove = times.SelectMany(time =>
                timeline.Where(@event => @event.Time == time))
                .ToList();

            foreach (var @event in eventsToRemove)
            {
                timeline.Remove(@event);
            }

            return true;
        }

        /// <summary>
        ///     Remove a value pair from the timeline if the value is equal to <paramref name="values" />.
        /// </summary>
        /// <returns>Returns true if the operation completed successfully.</returns>
        public bool RemoveValues(params TValue[] values)
        {
            var isValueContainedInTheTimeline = values.Any(v => GetAllValues().Contains(v));

            if (!isValueContainedInTheTimeline)
            {
                return false;
            }

            var eventsToRemove = values.SelectMany(value =>
                timeline.Where(@event => EqualityComparer<TValue>.Default.Equals(@event.Value, value)))
                .ToList();

            foreach (var @event in eventsToRemove)
            {
                timeline.Remove(@event);
            }

            return true;
        }

        /// <summary>
        ///     Convert the timeline to an array.
        /// </summary>
        /// <returns>
        /// The timeline as an array of tuples of (<see cref="DateTime"/>, <typeparamref name="TValue"/>).
        /// </returns>
        public (DateTime Time, TValue Value)[] ToArray()
            => timeline.ToArray();

        /// <summary>
        ///     Convert the timeline to a list.
        /// </summary>
        /// <returns>
        /// The timeline as a list of tuples of (<see cref="DateTime"/>, <typeparamref name="TValue"/>).
        /// </returns>
        public IList<(DateTime Time, TValue Value)> ToList()
            => timeline;

        /// <summary>
        ///     Convert the timeline to a dictionary.
        /// </summary>
        /// <returns>
        /// The timeline as an dictionary of <typeparamref name="TValue"/> by <see cref="DateTime"/>.
        /// </returns>
        public IDictionary<DateTime, TValue> ToDictionary()
            => timeline.ToDictionary(@event => @event.Time, @event => @event.Value);

        /// <inheritdoc />
        public override bool Equals(object? obj)
            => obj is Timeline<TValue> otherTimeline
               && this == otherTimeline;

        /// <inheritdoc />
        public override int GetHashCode()
            => timeline.GetHashCode();
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.BinarySearchTree
{
    /// <summary>
    ///     An ordered tree with efficient insertion, removal, and lookup.
    /// </summary>
    /// <remarks>
    ///     A Binary Search Tree (BST) is a tree that satisfies the following properties:
    ///     <list type="bullet">
    ///         <item>All nodes in the tree contain two children, usually called Left and Right.</item>
    ///         <item>All nodes in the Left subtree contain keys that are less than the node's key.</item>
    ///         <item>All nodes in the Right subtree contain keys that are greater than the node's key.</item>
    ///     </list>
    ///     A BST will have an average complexity of O(log n) for insertion, removal, and lookup operations.
    /// </remarks>
    /// <typeparam name="TKey">Type of key for the BST. Keys must implement IComparable.</typeparam>
    public class BinarySearchTree<TKey>
    {
        /// <summary>
        ///     Comparer to use when comparing node elements/keys.
        /// </summary>
        private readonly Comparer<TKey> comparer;

        /// <summary>
        ///     The root of the BST.
        /// </summary>
        private BinarySearchTreeNode<TKey>? root;

        public BinarySearchTree()
        {
            root = null;
            Count = 0;
            comparer = Comparer<TKey>.Default;
        }

        public BinarySearchTree(Comparer<TKey> customComparer)
        {
            root = null;
            Count = 0;
            comparer = customComparer;
        }

        /// <summary>
        ///     Gets the number nodes currently in the BST.
        /// </summary>
        public int Count { get; private set; }

        /// <summary>
        ///     Insert a key into the BST.
        /// </summary>
        /// <param name="key">The key to insert.</param>
        /// <exception cref="ArgumentException">
        ///     Thrown if key is already in BST.
        /// </exception>
        public void Add(TKey key)
        {
            if (root is null)
            {
                root = new BinarySearchTreeNode<TKey>(key);
            }
            else
            {
                Add(root, key);
            }

            Count++;
        }

        /// <summary>
        ///     Insert multiple keys into the BST.
        ///     Keys are inserted in the order they appear in the sequence.
        /// </summary>
        /// <param name="keys">Sequence of keys to insert.</param>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys)
            {
                Add(key);
            }
        }

        /// <summary>
        ///     Find a node with the specified key.
        /// </summary>
        /// <param name="key">The key to search for.</param>
        /// <returns>The node with the specified key if it exists, otherwise a default value is returned.</returns>
        public BinarySearchTreeNode<TKey>? Search(TKey key) => Search(root, key);

        /// <summary>
        ///     Checks if the specified key is in the BST.
        /// </summary>
        /// <param name="key">The key to search for.</param>
        /// <returns>true if the key is in the BST, false otherwise.</returns>
        public bool Contains(TKey key) => Search(root, key) is not null;

        /// <summary>
        ///     Removes a node with a key that matches <paramref name="key" />.
        /// </summary>
        /// <param name="key">The key to search for.</param>
        /// <returns>true if the removal was successful, false otherwise.</returns>
        public bool Remove(TKey key)
        {
            if (root is null)
            {
                return false;
            }

            var result = Remove(root, root, key);
            if (result)
            {
                Count--;
            }

            return result;
        }

        /// <summary>
        ///     Returns a node with the smallest key.
        /// </summary>
        /// <returns>The node if possible, a default value otherwise.</returns>
        public BinarySearchTreeNode<TKey>? GetMin()
        {
            if (root is null)
            {
                return default;
            }

            return GetMin(root);
        }

        /// <summary>
        ///     Returns a node with the largest key.
        /// </summary>
        /// <returns>The node if possible, a default value otherwise.</returns>
        public BinarySearchTreeNode<TKey>? GetMax()
        {
            if (root is null)
            {
                return default;
            }

            return GetMax(root);
        }

        /// <summary>
        ///     Returns all the keys in the BST, sorted In-Order.
        /// </summary>
        /// <returns>A list of keys in the BST.</returns>
        public ICollection<TKey> GetKeysInOrder() => GetKeysInOrder(root);

        /// <summary>
        ///     Returns all the keys in the BST, sorted Pre-Order.
        /// </summary>
        /// <returns>A list of keys in the BST.</returns>
        public ICollection<TKey> GetKeysPreOrder() => GetKeysPreOrder(root);

        /// <summary>
        ///     Returns all the keys in the BST, sorted Post-Order.
        /// </summary>
        /// <returns>A list of keys in the BST.</returns>
        public ICollection<TKey> GetKeysPostOrder() => GetKeysPostOrder(root);

        /// <summary>
        ///     Recursive method to add a key to the BST.
        /// </summary>
        /// <param name="node">Node to search from.</param>
        /// <param name="key">Key to add.</param>
        /// <exception cref="ArgumentException">
        ///     Thrown if key is already in the BST.
        /// </exception>
        private void Add(BinarySearchTreeNode<TKey> node, TKey key)
        {
            var compareResult = comparer.Compare(node.Key, key);
            if (compareResult > 0)
            {
                if (node.Left is not null)
                {
                    Add(node.Left, key);
                }
                else
                {
                    var newNode = new BinarySearchTreeNode<TKey>(key);
                    node.Left = newNode;
                }
            }
            else if (compareResult < 0)
            {
                if (node.Right is not null)
                {
                    Add(node.Right, key);
                }
                else
                {
                    var newNode = new BinarySearchTreeNode<TKey>(key);
                    node.Right = newNode;
                }
            }

            // Key is already in tree.
            else
            {
                throw new ArgumentException($"Key \"{key}\" already exists in tree!");
            }
        }

        /// <summary>
        ///     Removes a node with the specified key from the BST.
        /// </summary>
        /// <param name="parent">The parent node of <paramref name="node" />.</param>
        /// <param name="node">The node to check/search from.</param>
        /// <param name="key">The key to remove.</param>
        /// <returns>true if the operation was successful, false otherwise.</returns>
        /// <remarks>
        ///     Removing a node from the BST can be split into three cases:
        ///     <br></br>
        ///     0. The node to be removed has no children. In this case, the node can just be removed from the tree.
        ///     <br></br>
        ///     1. The node to be removed has one child. In this case, the node's child is moved to the node's parent,
        ///     then the node is removed from the tree.
        ///     <br></br>
        ///     2. The node to be removed has two children. In this case, we must find a suitable node among the children
        ///     subtrees to replace the node. This can be done with either the in-order predecessor or the in-order successor.
        ///     The in-order predecessor is the largest node in Left subtree, or the largest node that is still smaller then the
        ///     current node. The in-order successor is the smallest node in the Right subtree, or the smallest node that is
        ///     still larger than the current node. Either way, once this suitable node is found, remove it from the tree (it
        ///     should be either a case 1 or 2 node) and replace the node to be removed with this suitable node.
        ///     <br></br>
        ///     More information: https://en.wikipedia.org/wiki/Binary_search_tree#Deletion .
        /// </remarks>
        private bool Remove(BinarySearchTreeNode<TKey>? parent, BinarySearchTreeNode<TKey>? node, TKey key)
        {
            if (node is null || parent is null)
            {
                return false;
            }

            var compareResult = comparer.Compare(node.Key, key);

            if (compareResult > 0)
            {
                return Remove(node, node.Left, key);
            }

            if (compareResult < 0)
            {
                return Remove(node, node.Right, key);
            }

            BinarySearchTreeNode<TKey>? replacementNode;

            // Case 0: Node has no children.
            // Case 1: Node has one child.
            if (node.Left is null || node.Right is null)
            {
                replacementNode = node.Left ?? node.Right;
            }

            // Case 2: Node has two children. (This implementation uses the in-order predecessor to replace node.)
            else
            {
                var predecessorNode = GetMax(node.Left);
                Remove(root, root, predecessorNode.Key);
                replacementNode = new BinarySearchTreeNode<TKey>(predecessorNode.Key)
                {
                    Left = node.Left,
                    Right = node.Right,
                };
            }

            // Replace the relevant node with a replacement found in the previous stages.
            // Special case for replacing the root node.
            if (node == root)
            {
                root = replacementNode;
            }
            else if (parent.Left == node)
            {
                parent.Left = replacementNode;
            }
            else
            {
                parent.Right = replacementNode;
            }

            return true;
        }

        /// <summary>
        ///     Recursive method to get node with largest key.
        /// </summary>
        /// <param name="node">Node to search from.</param>
        /// <returns>Node with largest value.</returns>
        private BinarySearchTreeNode<TKey> GetMax(BinarySearchTreeNode<TKey> node)
        {
            if (node.Right is null)
            {
                return node;
            }

            return GetMax(node.Right);
        }

        /// <summary>
        ///     Recursive method to get node with smallest key.
        /// </summary>
        /// <param name="node">Node to search from.</param>
        /// <returns>Node with smallest value.</returns>
        private BinarySearchTreeNode<TKey> GetMin(BinarySearchTreeNode<TKey> node)
        {
            if (node.Left is null)
            {
                return node;
            }

            return GetMin(node.Left);
        }

        /// <summary>
        ///     Recursive method to get a list with the keys sorted in in-order order.
        /// </summary>
        /// <param name="node">Node to traverse from.</param>
        /// <returns>List of keys in in-order order.</returns>
        private IList<TKey> GetKeysInOrder(BinarySearchTreeNode<TKey>? node)
        {
            if (node is null)
            {
                return new List<TKey>();
            }

            var result = new List<TKey>();
            result.AddRange(GetKeysInOrder(node.Left));
            result.Add(node.Key);
            result.AddRange(GetKeysInOrder(node.Right));
            return result;
        }

        /// <summary>
        ///     Recursive method to get a list with the keys sorted in pre-order order.
        /// </summary>
        /// <param name="node">Node to traverse from.</param>
        /// <returns>List of keys in pre-order order.</returns>
        private IList<TKey> GetKeysPreOrder(BinarySearchTreeNode<TKey>? node)
        {
            if (node is null)
            {
                return new List<TKey>();
            }

            var result = new List<TKey>();
            result.Add(node.Key);
            result.AddRange(GetKeysPreOrder(node.Left));
            result.AddRange(GetKeysPreOrder(node.Right));
            return result;
        }

        /// <summary>
        ///     Recursive method to get a list with the keys sorted in post-order order.
        /// </summary>
        /// <param name="node">Node to traverse from.</param>
        /// <returns>List of keys in post-order order.</returns>
        private IList<TKey> GetKeysPostOrder(BinarySearchTreeNode<TKey>? node)
        {
            if (node is null)
            {
                return new List<TKey>();
            }

            var result = new List<TKey>();
            result.AddRange(GetKeysPostOrder(node.Left));
            result.AddRange(GetKeysPostOrder(node.Right));
            result.Add(node.Key);
            return result;
        }

        /// <summary>
        ///     Recursive method to find a node with a matching key.
        /// </summary>
        /// <param name="node">Node to search from.</param>
        /// <param name="key">Key to find.</param>
        /// <returns>The node with the specified if it exists, a default value otherwise.</returns>
        private BinarySearchTreeNode<TKey>? Search(BinarySearchTreeNode<TKey>? node, TKey key)
        {
            if (node is null)
            {
                return default;
            }

            var compareResult = comparer.Compare(node.Key, key);
            if (compareResult > 0)
            {
                return Search(node.Left, key);
            }

            if (compareResult < 0)
            {
                return Search(node.Right, key);
            }

            return node;
        }
    }
}
namespace DataStructures.BinarySearchTree
{
    /// <summary>
    ///     Generic node class for BinarySearchTree.
    ///     Keys for each node are immutable.
    /// </summary>
    /// <typeparam name="TKey">Type of key for the node. Keys must implement IComparable.</typeparam>
    public class BinarySearchTreeNode<TKey>
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="BinarySearchTreeNode{TKey}" /> class.
        /// </summary>
        /// <param name="key">The key of this node.</param>
        public BinarySearchTreeNode(TKey key) => Key = key;

        /// <summary>
        ///     Gets the key for this node.
        /// </summary>
        public TKey Key { get; }

        /// <summary>
        ///     Gets or sets the reference to a child node that precedes/comes before this node.
        /// </summary>
        public BinarySearchTreeNode<TKey>? Left { get; set; }

        /// <summary>
        ///     Gets or sets the reference to a child node that follows/comes after this node.
        /// </summary>
        public BinarySearchTreeNode<TKey>? Right { get; set; }
    }
}
namespace DataStructures.AATree
{
    /// <summary>
    ///     Generic node class for AATree.
    /// </summary>
    /// <typeparam name="TKey">Type of key for node.</typeparam>
    public class AaTreeNode<TKey>
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="AaTreeNode{TKey}" /> class.
        /// </summary>
        /// <param name="key">The initial key of this node.</param>
        /// <param name="level">The level of this node. See <see cref="AaTree{TKey}" /> for more details.</param>
        public AaTreeNode(TKey key, int level)
        {
            Key = key;
            Level = level;
        }

        /// <summary>
        ///     Gets or Sets key for this node.
        /// </summary>
        public TKey Key { get; set; }

        /// <summary>
        ///     Gets or Sets level for this node.
        /// </summary>
        public int Level { get; set; }

        /// <summary>
        ///     Gets or sets the left subtree of this node.
        /// </summary>
        public AaTreeNode<TKey>? Left { get; set; }

        /// <summary>
        ///     Gets or sets the right subtree of this node.
        /// </summary>
        public AaTreeNode<TKey>? Right { get; set; }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.AATree
{
    /// <summary>
    ///     A simple self-balancing binary search tree.
    /// </summary>
    /// <remarks>
    ///     AA Trees are a form of self-balancing binary search tree named after their inventor
    ///     Arne Anderson. AA Trees are designed to be simple to understand and implement.
    ///     This is accomplished by limiting how nodes can be added to the tree.
    ///     This simplifies rebalancing operations.
    ///     More information: https://en.wikipedia.org/wiki/AA_tree .
    /// </remarks>
    /// <typeparam name="TKey">The type of key for the AA tree.</typeparam>
    public class AaTree<TKey>
    {
        /// <summary>
        ///     The comparer function to use to compare the keys.
        /// </summary>
        private readonly Comparer<TKey> comparer;

        /// <summary>
        ///     Initializes a new instance of the <see cref="AaTree{TKey}" /> class.
        /// </summary>
        public AaTree()
            : this(Comparer<TKey>.Default)
        {
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="AaTree{TKey}" /> class with a custom comparer.
        /// </summary>
        /// <param name="customComparer">The custom comparer to use to compare keys.</param>
        public AaTree(Comparer<TKey> customComparer) => comparer = customComparer;

        /// <summary>
        ///     Gets the root of the tree.
        /// </summary>
        public AaTreeNode<TKey>? Root { get; private set; }

        /// <summary>
        ///     Gets the number of elements in the tree.
        /// </summary>
        public int Count { get; private set; }

        /// <summary>
        ///     Add a single element to the tree.
        /// </summary>
        /// <param name="key">The element to add to the tree.</param>
        public void Add(TKey key)
        {
            Root = Add(key, Root);
            Count++;
        }

        /// <summary>
        ///     Add multiple elements to the tree.
        /// </summary>
        /// <param name="keys">The elements to add to the tree.</param>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys)
            {
                Root = Add(key, Root);
                Count++;
            }
        }

        /// <summary>
        ///     Remove a single element from the tree.
        /// </summary>
        /// <param name="key">Element to remove.</param>
        public void Remove(TKey key)
        {
            if (!Contains(key, Root))
            {
                throw new InvalidOperationException($"{nameof(key)} is not in the tree");
            }

            Root = Remove(key, Root);
            Count--;
        }

        /// <summary>
        ///     Checks if the specified element is in the tree.
        /// </summary>
        /// <param name="key">The element to look for.</param>
        /// <returns>true if the element is in the tree, false otherwise.</returns>
        public bool Contains(TKey key) => Contains(key, Root);

        /// <summary>
        ///     Gets the largest element in the tree. (ie. the element in the right most node).
        /// </summary>
        /// <returns>The largest element in the tree according to the stored comparer.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the tree is empty.</exception>
        public TKey GetMax()
        {
            if (Root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMax(Root).Key;
        }

        /// <summary>
        ///     Gets the smallest element in the tree. (ie. the element in the left most node).
        /// </summary>
        /// <returns>The smallest element in the tree according to the stored comparer.</returns>
        /// <throws>InvalidOperationException if the tree is empty.</throws>
        public TKey GetMin()
        {
            if (Root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMin(Root).Key;
        }

        /// <summary>
        ///     Gets all the elements in the tree in in-order order.
        /// </summary>
        /// <returns>Sequence of elements in in-order order.</returns>
        public IEnumerable<TKey> GetKeysInOrder()
        {
            var result = new List<TKey>();
            InOrderWalk(Root);
            return result;

            void InOrderWalk(AaTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                InOrderWalk(node.Left);
                result.Add(node.Key);
                InOrderWalk(node.Right);
            }
        }

        /// <summary>
        ///     Gets all the elements in the tree in pre-order order.
        /// </summary>
        /// <returns>Sequence of elements in pre-order order.</returns>
        public IEnumerable<TKey> GetKeysPreOrder()
        {
            var result = new List<TKey>();
            PreOrderWalk(Root);
            return result;

            void PreOrderWalk(AaTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                result.Add(node.Key);
                PreOrderWalk(node.Left);
                PreOrderWalk(node.Right);
            }
        }

        /// <summary>
        ///     Gets all the elements in the tree in post-order order.
        /// </summary>
        /// <returns>Sequence of elements in post-order order.</returns>
        public IEnumerable<TKey> GetKeysPostOrder()
        {
            var result = new List<TKey>();
            PostOrderWalk(Root);
            return result;

            void PostOrderWalk(AaTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                PostOrderWalk(node.Left);
                PostOrderWalk(node.Right);
                result.Add(node.Key);
            }
        }

        /// <summary>
        ///     Recursive function to add an element to the tree.
        /// </summary>
        /// <param name="key">The element to add.</param>
        /// <param name="node">The node to search for a empty spot.</param>
        /// <returns>The node with the added element.</returns>
        /// <exception cref="ArgumentException">Thrown if key is already in the tree.</exception>
        private AaTreeNode<TKey> Add(TKey key, AaTreeNode<TKey>? node)
        {
            if (node is null)
            {
                return new AaTreeNode<TKey>(key, 1);
            }

            if (comparer.Compare(key, node.Key) < 0)
            {
                node.Left = Add(key, node.Left);
            }
            else if (comparer.Compare(key, node.Key) > 0)
            {
                node.Right = Add(key, node.Right);
            }
            else
            {
                throw new ArgumentException($"Key \"{key}\" already in tree!", nameof(key));
            }

            return Split(Skew(node)) !;
        }

        /// <summary>
        ///     Recursive function to remove an element from the tree.
        /// </summary>
        /// <param name="key">The element to remove.</param>
        /// <param name="node">The node to search from.</param>
        /// <returns>The node with the specified element removed.</returns>
        private AaTreeNode<TKey>? Remove(TKey key, AaTreeNode<TKey>? node)
        {
            if (node is null)
            {
                return null;
            }

            if (comparer.Compare(key, node.Key) < 0)
            {
                node.Left = Remove(key, node.Left);
            }
            else if (comparer.Compare(key, node.Key) > 0)
            {
                node.Right = Remove(key, node.Right);
            }
            else
            {
                if (node.Left is null && node.Right is null)
                {
                    return null;
                }

                if (node.Left is null)
                {
                    var successor = GetMin(node.Right!);
                    node.Right = Remove(successor.Key, node.Right);
                    node.Key = successor.Key;
                }
                else
                {
                    var predecessor = GetMax(node.Left);
                    node.Left = Remove(predecessor.Key, node.Left);
                    node.Key = predecessor.Key;
                }
            }

            node = DecreaseLevel(node);
            node = Skew(node);
            node!.Right = Skew(node.Right);

            if (node.Right is not null)
            {
                node.Right.Right = Skew(node.Right.Right);
            }

            node = Split(node);
            node!.Right = Split(node.Right);
            return node;
        }

        /// <summary>
        ///     Recursive function to check if the element exists in the tree.
        /// </summary>
        /// <param name="key">The element to check for.</param>
        /// <param name="node">The node to search from.</param>
        /// <returns>true if the element exists in the tree, false otherwise.</returns>
        private bool Contains(TKey key, AaTreeNode<TKey>? node) =>
            node is { }
            && comparer.Compare(key, node.Key) is { } v
            && v switch
            {
                { } when v > 0 => Contains(key, node.Right),
                { } when v < 0 => Contains(key, node.Left),
                _ => true,
            };

        /// <summary>
        ///     Recursive to find the maximum/right-most element.
        /// </summary>
        /// <param name="node">The node to traverse from.</param>
        /// <returns>The node with the maximum/right-most element.</returns>
        private AaTreeNode<TKey> GetMax(AaTreeNode<TKey> node)
        {
            while (true)
            {
                if (node.Right is null)
                {
                    return node;
                }

                node = node.Right;
            }
        }

        /// <summary>
        ///     Recursive to find the minimum/left-most element.
        /// </summary>
        /// <param name="node">The node to traverse from.</param>
        /// <returns>The node with the minimum/left-most element.</returns>
        private AaTreeNode<TKey> GetMin(AaTreeNode<TKey> node)
        {
            while (true)
            {
                if (node.Left is null)
                {
                    return node;
                }

                node = node.Left;
            }
        }

        /// <summary>
        ///     Remove right-horizontal links and replaces them with left-horizontal links.
        ///     Accomplishes this by performing a right rotation.
        /// </summary>
        /// <param name="node">The node to rebalance from.</param>
        /// <returns>The rebalanced node.</returns>
        private AaTreeNode<TKey>? Skew(AaTreeNode<TKey>? node)
        {
            if (node?.Left is null || node.Left.Level != node.Level)
            {
                return node;
            }

            var left = node.Left;
            node.Left = left.Right;
            left.Right = node;
            return left;
        }

        /// <summary>
        ///     Reduces the number of right-horizontal links.
        ///     Accomplishes this by performing a left rotation, and incrementing level.
        /// </summary>
        /// <param name="node">The node to rebalance from.</param>
        /// <returns>The rebalanced node.</returns>
        private AaTreeNode<TKey>? Split(AaTreeNode<TKey>? node)
        {
            if (node?.Right?.Right is null || node.Level != node.Right.Right.Level)
            {
                return node;
            }

            var right = node.Right;
            node.Right = right.Left;
            right.Left = node;
            right.Level++;
            return right;
        }

        /// <summary>
        ///     Decreases the level of node if necessary.
        /// </summary>
        /// <param name="node">The node to decrease level from.</param>
        /// <returns>The node with modified level.</returns>
        private AaTreeNode<TKey> DecreaseLevel(AaTreeNode<TKey> node)
        {
            var newLevel = Math.Min(GetLevel(node.Left), GetLevel(node.Right)) + 1;
            if (newLevel >= node.Level)
            {
                return node;
            }

            node.Level = newLevel;
            if (node.Right is { } && newLevel < node.Right.Level)
            {
                node.Right.Level = newLevel;
            }

            return node;

            static int GetLevel(AaTreeNode<TKey>? x) => x?.Level ?? 0;
        }
    }
}
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
    <CodeAnalysisRuleSet>..\stylecop.ruleset</CodeAnalysisRuleSet>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DocumentationFile>./bin/DataStructures.xml</DocumentationFile>
  </PropertyGroup>

  <ItemGroup>
    <AdditionalFiles Include="..\stylecop.json" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="StyleCop.Analyzers" Version="1.1.118">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Utilities\Utilities.csproj" />
  </ItemGroup>

</Project>
using System.Collections.Generic;
using System.Linq;

namespace DataStructures
{
    /// <summary>
    /// Inverted index is the simplest form of document indexing,
    /// allowing performing boolean queries on text data.
    ///
    /// This realization is just simplified for better understanding the process of indexing
    /// and working on straightforward string inputs.
    /// </summary>
    public class InvertedIndex
    {
        private readonly Dictionary<string, List<string>> invertedIndex = new();

        /// <summary>
        /// Build inverted index with source name and source content.
        /// </summary>
        /// <param name="sourceName">Name of the source.</param>
        /// <param name="sourceContent">Content of the source.</param>
        public void AddToIndex(string sourceName, string sourceContent)
        {
            var context = sourceContent.Split(' ').Distinct();
            foreach (var word in context)
            {
                if (!invertedIndex.ContainsKey(word))
                {
                    invertedIndex.Add(word, new List<string> { sourceName });
                }
                else
                {
                    invertedIndex[word].Add(sourceName);
                }
            }
        }

        /// <summary>
        /// Returns the source names contains ALL terms inside at same time.
        /// </summary>
        /// <param name="terms">List of terms.</param>
        /// <returns>Source names.</returns>
        public IEnumerable<string> And(IEnumerable<string> terms)
        {
            var entries = terms
                .Select(term => invertedIndex
                    .Where(x => x.Key.Equals(term))
                    .SelectMany(x => x.Value))
                .ToList();

            var intersection = entries
                .Skip(1)
                .Aggregate(new HashSet<string>(entries.First()), (hashSet, enumerable) =>
                {
                    hashSet.IntersectWith(enumerable);
                    return hashSet;
                });

            return intersection;
        }

        /// <summary>
        /// Returns the source names contains AT LEAST ONE from terms inside.
        /// </summary>
        /// <param name="terms">List of terms.</param>
        /// <returns>Source names.</returns>
        public IEnumerable<string> Or(IEnumerable<string> terms)
        {
            var sources = new List<string>();
            foreach (var term in terms)
            {
                var source = invertedIndex
                    .Where(x => x.Key.Equals(term))
                    .SelectMany(x => x.Value);

                sources.AddRange(source);
            }

            return sources.Distinct();
        }
    }
}
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Heap.PairingHeap
{
    /// <summary>
    /// A pairing minMax heap implementation.
    /// </summary>
    /// <typeparam name="T">Base type.</typeparam>
    public class PairingHeap<T> : IEnumerable<T> where T : IComparable
    {
        private readonly Sorting sorting;
        private readonly IComparer<T> comparer;
        private readonly Dictionary<T, List<PairingHeapNode<T>>> mapping = new();

        private PairingHeapNode<T> root = null!;

        public int Count { get; private set; }

        public PairingHeap(Sorting sortDirection = Sorting.Ascending)
        {
            sorting = sortDirection;
            comparer = new PairingNodeComparer<T>(sortDirection, Comparer<T>.Default);
        }

        /// <summary>
        /// Insert a new Node [O(1)].
        /// </summary>
        public void Insert(T newItem)
        {
            var newNode = new PairingHeapNode<T>(newItem);

            root = RebuildHeap(root, newNode);
            Map(newItem, newNode);

            Count++;
        }

        /// <summary>
        /// Get the element from heap [O(log(n))].
        /// </summary>
        public T Extract()
        {
            var minMax = root;

            RemoveMapping(minMax.Value, minMax);
            RebuildHeap(root.ChildrenHead);

            Count--;
            return minMax.Value;
        }

        /// <summary>
        /// Update heap key [O(log(n))].
        /// </summary>
        public void UpdateKey(T currentValue, T newValue)
        {
            if(!mapping.ContainsKey(currentValue))
            {
                throw new ArgumentException("Current value is not present in this heap.");
            }

            var node = mapping[currentValue]?.Where(x => x.Value.Equals(currentValue)).FirstOrDefault();

            if (comparer.Compare(newValue, node!.Value) > 0)
            {
                throw new ArgumentException($"New value is not {(sorting != Sorting.Descending ? "less" : "greater")} than old value.");
            }

            UpdateNodeValue(currentValue, newValue, node);

            if (node == root)
            {
                return;
            }

            DeleteChild(node);

            root = RebuildHeap(root, node);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public IEnumerator<T> GetEnumerator()
        {
            return mapping.SelectMany(x => x.Value).Select(x => x.Value).GetEnumerator();
        }

        /// <summary>
        /// Rebuild heap on action [O(log(n))].
        /// </summary>
        private void RebuildHeap(PairingHeapNode<T> headNode)
        {
            if (headNode == null)
            {
                return;
            }

            var passOneResult = new List<PairingHeapNode<T>>();
            var current = headNode;

            if (current.Next == null)
            {
                headNode.Next = null!;
                headNode.Previous = null!;
                passOneResult.Add(headNode);
            }
            else
            {
                while (true)
                {
                    if (current == null)
                    {
                        break;
                    }

                    if (current.Next != null)
                    {
                        var next = current.Next;
                        var nextNext = next.Next;
                        passOneResult.Add(RebuildHeap(current, next));
                        current = nextNext;
                    }
                    else
                    {
                        var lastInserted = passOneResult[^1];
                        passOneResult[^1] = RebuildHeap(lastInserted, current);
                        break;
                    }
                }
            }

            var passTwoResult = passOneResult[^1];

            if (passOneResult.Count == 1)
            {
                root = passTwoResult;
                return;
            }

            for (var i = passOneResult.Count - 2; i >= 0; i--)
            {
                current = passOneResult[i];
                passTwoResult = RebuildHeap(passTwoResult, current);
            }

            root = passTwoResult;
        }

        private PairingHeapNode<T> RebuildHeap(PairingHeapNode<T> node1, PairingHeapNode<T> node2)
        {
            if (node2 != null)
            {
                node2.Previous = null!;
                node2.Next = null!;
            }

            if (node1 == null)
            {
                return node2!;
            }

            node1.Previous = null!;
            node1.Next = null!;

            if (node2 != null && comparer.Compare(node1.Value, node2.Value) <= 0)
            {
                AddChild(ref node1, node2);
                return node1;
            }

            AddChild(ref node2!, node1);
            return node2;
        }

        private void AddChild(ref PairingHeapNode<T> parent, PairingHeapNode<T> child)
        {
            if (parent.ChildrenHead == null)
            {
                parent.ChildrenHead = child;
                child.Previous = parent;
                return;
            }

            var head = parent.ChildrenHead;

            child.Previous = head;
            child.Next = head.Next;

            if (head.Next != null)
            {
                head.Next.Previous = child;
            }

            head.Next = child;
        }

        private void DeleteChild(PairingHeapNode<T> node)
        {
            if (node.IsHeadChild)
            {
                var parent = node.Previous;

                if (node.Next != null)
                {
                    node.Next.Previous = parent;
                }

                parent.ChildrenHead = node.Next!;
            }
            else
            {
                node.Previous.Next = node.Next;

                if (node.Next != null)
                {
                    node.Next.Previous = node.Previous;
                }
            }
        }

        private void Map(T newItem, PairingHeapNode<T> newNode)
        {
            if (mapping.ContainsKey(newItem))
            {
                mapping[newItem].Add(newNode);
            }
            else
            {
                mapping[newItem] = new List<PairingHeapNode<T>>(new[] { newNode });
            }
        }

        private void UpdateNodeValue(T currentValue, T newValue, PairingHeapNode<T> node)
        {
            RemoveMapping(currentValue, node);
            node.Value = newValue;
            Map(newValue, node);
        }

        private void RemoveMapping(T currentValue, PairingHeapNode<T> node)
        {
            mapping[currentValue].Remove(node);
            if (mapping[currentValue].Count == 0)
            {
                mapping.Remove(currentValue);
            }
        }
    }
}
namespace DataStructures.Heap.PairingHeap
{
    public enum Sorting
    {
        /// <summary>
        /// Ascending order.
        /// </summary>
        Ascending = 0,

        /// <summary>
        /// Descending order.
        /// </summary>
        Descending = 1,
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.Heap.PairingHeap
{
    /// <summary>
    /// Node comparer.
    /// </summary>
    /// <typeparam name="T">Node type.</typeparam>
    public class PairingNodeComparer<T> : IComparer<T> where T : IComparable
    {
        private readonly bool isMax;
        private readonly IComparer<T> nodeComparer;

        public PairingNodeComparer(Sorting sortDirection, IComparer<T> comparer)
        {
            isMax = sortDirection == Sorting.Descending;
            nodeComparer = comparer;
        }

        public int Compare(T? x, T? y)
        {
            return !isMax
                ? CompareNodes(x, y)
                : CompareNodes(y, x);
        }

        private int CompareNodes(T? one, T? second)
        {
            return nodeComparer.Compare(one, second);
        }
    }
}
using System;

namespace DataStructures.Heap.PairingHeap
{
    /// <summary>
    /// Node represented the value and connections.
    /// </summary>
    /// <typeparam name="T">Type, supported comparing.</typeparam>
    public class PairingHeapNode<T>
    {
        public PairingHeapNode(T value)
        {
            Value = value;
        }

        public T Value { get; set; }

        public PairingHeapNode<T> ChildrenHead { get; set; } = null!;

        public bool IsHeadChild => Previous != null && Previous.ChildrenHead == this;

        public PairingHeapNode<T> Previous { get; set; } = null!;

        public PairingHeapNode<T> Next { get; set; } = null!;
    }
}
using System;

namespace DataStructures.Heap.FibonacciHeap
{
    /// <summary>
    ///     These FHeapNodes are the bulk of the data structure. The have pointers to
    ///     their parent, a left and right sibling, and to a child. A node and its
    ///     siblings comprise a circularly doubly linked list.
    /// </summary>
    /// <typeparam name="T">A type that can be compared.</typeparam>
    public class FHeapNode<T> where T : IComparable
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="FHeapNode{T}" /> class.
        /// </summary>
        /// <param name="key">An item in the Fibonacci heap.</param>
        public FHeapNode(T key)
        {
            Key = key;

            // Since even a single node must form a circularly doubly linked list,
            // initialize it as such
            Left = Right = this;
            Parent = Child = null;
        }

        /// <summary>
        ///     Gets or sets the data of this node.
        /// </summary>
        public T Key { get; set; }

        /// <summary>
        ///     Gets or sets a reference to the parent.
        /// </summary>
        public FHeapNode<T>? Parent { get; set; }

        /// <summary>
        ///     Gets or sets a reference to the left sibling.
        /// </summary>
        public FHeapNode<T> Left { get; set; }

        /// <summary>
        ///     Gets or sets a reference to the right sibling.
        /// </summary>
        public FHeapNode<T> Right { get; set; }

        /// <summary>
        ///     Gets or sets a reference to one of the children, there may be more that
        ///     are siblings the this child, however this structure only maintains a
        ///     reference to one of them.
        /// </summary>
        public FHeapNode<T>? Child { get; set; }

        /// <summary>
        ///     Gets or sets a value indicating whether this node has been marked,
        ///     used in some operations.
        /// </summary>
        public bool Mark { get; set; }

        /// <summary>
        ///     Gets or sets the number of nodes in the child linked list.
        /// </summary>
        public int Degree { get; set; }

        public void SetSiblings(FHeapNode<T> left, FHeapNode<T> right)
        {
            Left = left;
            Right = right;
        }

        /// <summary>
        ///     A helper function to add a node to the right of this one in the current
        ///     circularly doubly linked list.
        /// </summary>
        /// <param name="node">A node to go in the linked list.</param>
        public void AddRight(FHeapNode<T> node)
        {
            Right.Left = node;
            node.Right = Right;
            node.Left = this;
            Right = node;
        }

        /// <summary>
        ///     Similar to AddRight, but adds the node as a sibling to the child node.
        /// </summary>
        /// <param name="node">A node to add to the child list of this node.</param>
        public void AddChild(FHeapNode<T> node)
        {
            Degree++;

            if (Child == null)
            {
                Child = node;
                Child.Parent = this;
                Child.Left = Child.Right = Child;

                return;
            }

            Child.AddRight(node);
        }

        /// <summary>
        ///     Remove this item from the linked list it's in.
        /// </summary>
        public void Remove()
        {
            Left.Right = Right;
            Right.Left = Left;
        }

        /// <summary>
        ///     Combine the linked list that <c>otherList</c> sits inside, with the
        ///     linked list this is in. Do this by cutting the link between this node,
        ///     and the node to the right of this, and inserting the contents of the
        ///     otherList in between.
        /// </summary>
        /// <param name="otherList">
        ///     A node from another list whose elements we want
        ///     to concatenate to this list.
        /// </param>
        public void ConcatenateRight(FHeapNode<T> otherList)
        {
            Right.Left = otherList.Left;
            otherList.Left.Right = Right;

            Right = otherList;
            otherList.Left = this;
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Heap.FibonacciHeap
{
    /// <summary>
    ///     A generic implementation of a Fibonacci heap.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         A Fibonacci heap is similar to a standard binary heap
    ///         <see cref="DataStructures.Heap.BinaryHeap{T}" />, however it uses concepts
    ///         of amortized analysis to provide theoretical speedups on common operations like
    ///         insert, union, and decrease-key while maintaining the same speed on all other
    ///         operations.
    ///     </para>
    ///     <para>
    ///         In practice, Fibonacci heaps are more complicated than binary heaps and require
    ///         a large input problems before the benifits of the theoretical speed up
    ///         begin to show.
    ///     </para>
    ///     <para>
    ///         References:
    ///         [1] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest,
    ///         and Clifford Stein. 2009. Introduction to Algorithms, Third Edition (3rd. ed.).
    ///         The MIT Press.
    ///     </para>
    /// </remarks>
    /// <typeparam name="T">Type of elements in binary heap.</typeparam>
    public class FibonacciHeap<T> where T : IComparable
    {
        /// <summary>
        ///     Gets or sets the count of the number of nodes in the Fibonacci heap.
        /// </summary>
        public int Count { get; set; }

        /// <summary>
        ///     Gets or sets a reference to the MinItem. The MinItem and all of its siblings
        ///     comprise the root list, a list of trees that satisfy the heap property and
        ///     are joined in a circularly doubly linked list.
        /// </summary>
        private FHeapNode<T>? MinItem { get; set; }

        /// <summary>
        ///     Add item <c>x</c> to this Fibonacci heap.
        /// </summary>
        /// <remarks>
        ///     To add an item to a Fibonacci heap, we simply add it to the "root list",
        ///     a circularly doubly linked list where our minimum item sits. Since adding
        ///     items to a linked list takes O(1) time, the overall time to perform this
        ///     operation is O(1).
        /// </remarks>
        /// <param name="x">An item to push onto the heap.</param>
        /// <returns>
        ///     A reference to the item as it is in the heap. This is used for
        ///     operations like decresing key.
        /// </returns>
        public FHeapNode<T> Push(T x)
        {
            Count++;

            var newItem = new FHeapNode<T>(x);

            if (MinItem == null)
            {
                MinItem = newItem;
            }
            else
            {
                MinItem.AddRight(newItem);

                if (newItem.Key.CompareTo(MinItem.Key) < 0)
                {
                    MinItem = newItem;
                }
            }

            return newItem;
        }

        /// <summary>
        ///     Combines all the elements of two fibonacci heaps.
        /// </summary>
        /// <remarks>
        ///     To union two Fibonacci heaps is a single fibonacci heap is a single heap
        ///     that contains all the elements of both heaps. This can be done in O(1) time
        ///     by concatenating the root lists together.
        ///     For more details on how two circularly linked lists are concatenated, see
        ///     <see cref="FHeapNode{T}.ConcatenateRight" />
        ///     Finally, check to see which of <c>this.MinItem</c> and <c>other.MinItem</c>
        ///     is smaller, and set <c>this.MinItem</c> accordingly
        ///     This operation destroys <c>other</c>.
        /// </remarks>
        /// <param name="other">
        ///     Another heap whose elements we wish to add to this heap.
        ///     The other heap will be destroyed as a result.
        /// </param>
        public void Union(FibonacciHeap<T> other)
        {
            // If there are no items in the other heap, then there is nothing to do.
            if (other.MinItem == null)
            {
                return;
            }

            // If this heap is empty, simply set it equal to the other heap
            if (MinItem == null)
            {
                // Set this heap to the other one
                MinItem = other.MinItem;
                Count = other.Count;

                // Destroy the other heap
                other.MinItem = null;
                other.Count = 0;

                return;
            }

            Count += other.Count;

            // <see cref="DataStructures.FibonacciHeap{T}.FHeapNode.ConcatenateRight(DataStructures.FibonacciHeap{T}.FHeapNode)"/>
            MinItem.ConcatenateRight(other.MinItem);

            // Set the MinItem to the smaller of the two MinItems
            if (other.MinItem.Key.CompareTo(MinItem.Key) < 0)
            {
                MinItem = other.MinItem;
            }

            other.MinItem = null;
            other.Count = 0;
        }

        /// <summary>
        ///     Return the MinItem and remove it from the heap.
        /// </summary>
        /// <remarks>
        ///     This function (with all of its helper functions) is the most complicated
        ///     part of the Fibonacci Heap. However, it can be broken down into a few steps.
        ///     <list type="number">
        ///         <item>
        ///             Add the children of MinItem to the root list. Either one of these children,
        ///             or another of the items in the root list is a candidate to become the new
        ///             MinItem.
        ///         </item>
        ///         <item>
        ///             Remove the MinItem from the root list and appoint a new MinItem temporarily.
        ///         </item>
        ///         <item>
        ///             <see cref="Consolidate" /> what's left
        ///             of the heap.
        ///         </item>
        ///     </list>
        /// </remarks>
        /// <returns>The minimum item from the heap.</returns>
        public T Pop()
        {
            FHeapNode<T>? z = null;
            if (MinItem == null)
            {
                throw new InvalidOperationException("Heap is empty!");
            }

            z = MinItem;

            // Since z is leaving the heap, add its children to the root list
            if (z.Child != null)
            {
                foreach (var x in SiblingIterator(z.Child))
                {
                    x.Parent = null;
                }

                // This effectively adds each child x to the root list
                z.ConcatenateRight(z.Child);
            }

            if (Count == 1)
            {
                MinItem = null;
                Count = 0;
                return z.Key;
            }

            // Temporarily reassign MinItem to an arbitrary item in the root
            // list
            MinItem = MinItem.Right;

            // Remove the old MinItem from the root list altogether
            z.Remove();

            // Consolidate the heap
            Consolidate();

            Count -= 1;

            return z.Key;
        }

        /// <summary>
        ///     A method to see what's on top of the heap without changing its structure.
        /// </summary>
        /// <returns>
        ///     Returns the top element without popping it from the structure of
        ///     the heap.
        /// </returns>
        public T Peek()
        {
            if (MinItem == null)
            {
                throw new InvalidOperationException("The heap is empty");
            }

            return MinItem.Key;
        }

        /// <summary>
        ///     Reduce the key of x to be k.
        /// </summary>
        /// <remarks>
        ///     k must be less than x.Key, increasing the key of an item is not supported.
        /// </remarks>
        /// <param name="x">The item you want to reduce in value.</param>
        /// <param name="k">The new value for the item.</param>
        public void DecreaseKey(FHeapNode<T> x, T k)
        {
            if (MinItem == null)
            {
                throw new ArgumentException($"{nameof(x)} is not from the heap");
            }

            if (x.Key == null)
            {
                throw new ArgumentException("x has no value");
            }

            if (k.CompareTo(x.Key) > 0)
            {
                throw new InvalidOperationException("Value cannot be increased");
            }

            x.Key = k;
            var y = x.Parent;
            if (y != null && x.Key.CompareTo(y.Key) < 0)
            {
                Cut(x, y);
                CascadingCut(y);
            }

            if (x.Key.CompareTo(MinItem.Key) < 0)
            {
                MinItem = x;
            }
        }

        /// <summary>
        ///     Remove x from the child list of y.
        /// </summary>
        /// <param name="x">A child of y we just decreased the value of.</param>
        /// <param name="y">The now former parent of x.</param>
        protected void Cut(FHeapNode<T> x, FHeapNode<T> y)
        {
            if (MinItem == null)
            {
                throw new InvalidOperationException("Heap malformed");
            }

            if (y.Degree == 1)
            {
                y.Child = null;
                MinItem.AddRight(x);
            }
            else if (y.Degree > 1)
            {
                x.Remove();
            }
            else
            {
                throw new InvalidOperationException("Heap malformed");
            }

            y.Degree--;
            x.Mark = false;
            x.Parent = null;
        }

        /// <summary>
        ///     Rebalances the heap after the decrease operation takes place.
        /// </summary>
        /// <param name="y">An item that may no longer obey the heap property.</param>
        protected void CascadingCut(FHeapNode<T> y)
        {
            var z = y.Parent;
            if (z != null)
            {
                if (!y.Mark)
                {
                    y.Mark = true;
                }
                else
                {
                    Cut(y, z);
                    CascadingCut(z);
                }
            }
        }

        /// <summary>
        ///     <para>
        ///         Consolidate is analogous to Heapify in <see cref="DataStructures.Heap.BinaryHeap{T}" />.
        ///     </para>
        ///     <para>
        ///         First, an array <c>A</c> [0...D(H.n)] is created where H.n is the number
        ///         of items in this heap, and D(x) is the max degree any node can have in a
        ///         Fibonacci heap with x nodes.
        ///     </para>
        ///     <para>
        ///         For each node <c>x</c> in the root list, try to add it to <c>A[d]</c> where
        ///         d is the degree of <c>x</c>.
        ///         If there is already a node in <c>A[d]</c>, call it <c>y</c>, and make
        ///         <c>y</c> a child of <c>x</c>. (Swap <c>x</c> and <c>y</c> beforehand if
        ///         <c>x</c> is greater than <c>y</c>). Now that <c>x</c> has one more child,
        ///         remove if from <c>A[d]</c> and add it to <c>A[d+1]</c> to reflect that its
        ///         degree is one more. Loop this behavior until we find an empty spot to put
        ///         <c>x</c>.
        ///     </para>
        ///     <para>
        ///         With <c>A</c> all filled, empty the root list of the heap. And add each item
        ///         from <c>A</c> into the root list, one by one, making sure to keep track of
        ///         which is smallest.
        ///     </para>
        /// </summary>
        protected void Consolidate()
        {
            if (MinItem == null)
            {
                return;
            }

            // There's a fact in Intro to Algorithms:
            // "the max degree of any node in an n-node fibonacci heap is O(lg(n)).
            // In particular, we shall show that D(n) <= floor(log_phi(n)) where phi is
            // the golden ratio, defined in equation 3.24 as phi = (1 + sqrt(5))/2"
            //
            // For a proof, see [1]
            var maxDegree = 1 + (int)Math.Log(Count, (1 + Math.Sqrt(5)) / 2);

            // Create slots for every possible node degree of x
            var a = new FHeapNode<T>?[maxDegree];
            var siblings = SiblingIterator(MinItem).ToList();
            foreach (var w in siblings)
            {
                var x = w;
                var d = x.Degree;

                var y = a[d];

                // While A[d] is not empty, we can't blindly put x here
                while (y != null)
                {
                    if (x.Key.CompareTo(y.Key) > 0)
                    {
                        // Exchange x and y
                        var temp = x;
                        x = y;
                        y = temp;
                    }

                    // Make y a child of x
                    FibHeapLink(y, x);

                    // Empty out this spot since x now has a higher degree
                    a[d] = null;

                    // Add 1 to x's degree before going back into the loop
                    d++;

                    y = a[d];
                }

                // Now that there's an empty spot for x, place it there
                a[d] = x;
            }

            ReconstructHeap(a);
        }

        /// <summary>
        ///     Reconstructs the heap based on the array of node degrees created by the consolidate step.
        /// </summary>
        /// <param name="a">An array of FHeapNodes where a[i] represents a node of degree i.</param>
        private void ReconstructHeap(FHeapNode<T>?[] a)
        {
            // Once all items are in A, empty out the root list
            MinItem = null;

            for (var i = 0; i < a.Length; i++)
            {
                var r = a[i];
                if (r == null)
                {
                    continue;
                }

                if (MinItem == null)
                {
                    // If the root list is completely empty, make this the new
                    // MinItem
                    MinItem = r;

                    // Make a new root list with just this item. Make sure to make
                    // it its own list.
                    MinItem.SetSiblings(MinItem, MinItem);
                    MinItem.Parent = null;
                }
                else
                {
                    // Add A[i] to the root list
                    MinItem.AddRight(r);

                    // If this item is smaller, make it the new min item
                    if (MinItem.Key.CompareTo(r.Key) > 0)
                    {
                        MinItem = a[i];
                    }
                }
            }
        }

        /// <summary>
        ///     Make y a child of x.
        /// </summary>
        /// <param name="y">A node to become the child of x.</param>
        /// <param name="x">A node to become the parent of y.</param>
        private void FibHeapLink(FHeapNode<T> y, FHeapNode<T> x)
        {
            y.Remove();
            x.AddChild(y);
            y.Mark = false;
        }

        /// <summary>
        ///     A helper function to iterate through all the siblings of this node in the
        ///     circularly doubly linked list.
        /// </summary>
        /// <param name="node">A node we want the siblings of.</param>
        /// <returns>An iterator over all of the siblings.</returns>
        private IEnumerable<FHeapNode<T>> SiblingIterator(FHeapNode<T> node)
        {
            var currentNode = node;
            yield return currentNode;

            currentNode = node.Right;
            while (currentNode != node)
            {
                yield return currentNode;
                currentNode = currentNode.Right;
            }
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Heap
{
    /// <summary>
    ///     This class implements min-max heap.
    ///     It provides functionality of both min-heap and max-heap with the same time complexity.
    ///     Therefore it provides constant time retrieval and logarithmic time removal
    ///     of both the minimum and maximum elements in it.
    /// </summary>
    /// <typeparam name="T">Generic type.</typeparam>
    public class MinMaxHeap<T>
    {
        private readonly List<T> heap;

        /// <summary>
        ///     Initializes a new instance of the <see cref="MinMaxHeap{T}" /> class that contains
        ///     elements copied from a specified enumerable collection and that uses a specified comparer.
        /// </summary>
        /// <param name="collection">The enumerable collection to be copied.</param>
        /// <param name="comparer">The default comparer to use for comparing objects.</param>
        public MinMaxHeap(IEnumerable<T>? collection = null, IComparer<T>? comparer = null)
        {
            Comparer = comparer ?? Comparer<T>.Default;
            collection ??= Enumerable.Empty<T>();

            heap = collection.ToList();
            for (var i = Count / 2 - 1; i >= 0; --i)
            {
                PushDown(i);
            }
        }

        /// <summary>
        ///     Gets the  <see cref="IComparer{T}" />. object that is used to order the values in the <see cref="MinMaxHeap{T}" />.
        /// </summary>
        public IComparer<T> Comparer { get; }

        /// <summary>
        ///     Gets the number of elements in the <see cref="MinMaxHeap{T}" />.
        /// </summary>
        public int Count => heap.Count;

        /// <summary>
        ///     Adds an element to the heap.
        /// </summary>
        /// <param name="item">The element to add to the heap.</param>
        public void Add(T item)
        {
            heap.Add(item);
            PushUp(Count - 1);
        }

        /// <summary>
        ///     Removes the maximum node from the heap and returns its value.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if heap is empty.</exception>
        /// <returns>Value of the removed maximum node.</returns>
        public T ExtractMax()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty");
            }

            var max = GetMax();
            RemoveNode(GetMaxNodeIndex());
            return max;
        }

        /// <summary>
        ///     Removes the minimum node from the heap and returns its value.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if heap is empty.</exception>
        /// <returns>Value of the removed minimum node.</returns>
        public T ExtractMin()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty");
            }

            var min = GetMin();
            RemoveNode(0);
            return min;
        }

        /// <summary>
        ///     Gets the maximum value in the heap, as defined by the comparer.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if heap is empty.</exception>
        /// <returns>The maximum value in the heap.</returns>
        public T GetMax()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty");
            }

            return heap[GetMaxNodeIndex()];
        }

        /// <summary>
        ///     Gets the minimum value in the heap, as defined by the comparer.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if heap is empty.</exception>
        /// <returns>The minimum value in the heap.</returns>
        public T GetMin()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty");
            }

            return heap[0];
        }

        /// <summary>
        ///     Finds maximum value among children and grandchildren of the specified node.
        /// </summary>
        /// <param name="index">Index of the node in the Heap array.</param>
        /// <returns>Index of the maximum descendant.</returns>
        private int IndexOfMaxChildOrGrandchild(int index)
        {
            var descendants = new[]
            {
                2 * index + 1,
                2 * index + 2,
                4 * index + 3,
                4 * index + 4,
                4 * index + 5,
                4 * index + 6,
            };
            var resIndex = descendants[0];
            foreach (var descendant in descendants)
            {
                if (descendant >= Count)
                {
                    break;
                }

                if (Comparer.Compare(heap[descendant], heap[resIndex]) > 0)
                {
                    resIndex = descendant;
                }
            }

            return resIndex;
        }

        /// <summary>
        ///     Finds minumum value among children and grandchildren of the specified node.
        /// </summary>
        /// <param name="index">Index of the node in the Heap array.</param>
        /// <returns>Index of the minimum descendant.</returns>
        private int IndexOfMinChildOrGrandchild(int index)
        {
            var descendants = new[] { 2 * index + 1, 2 * index + 2, 4 * index + 3, 4 * index + 4, 4 * index + 5, 4 * index + 6 };
            var resIndex = descendants[0];
            foreach (var descendant in descendants)
            {
                if (descendant >= Count)
                {
                    break;
                }

                if (Comparer.Compare(heap[descendant], heap[resIndex]) < 0)
                {
                    resIndex = descendant;
                }
            }

            return resIndex;
        }

        private int GetMaxNodeIndex()
        {
            return Count switch
            {
                0 => throw new InvalidOperationException("Heap is empty"),
                1 => 0,
                2 => 1,
                _ => Comparer.Compare(heap[1], heap[2]) > 0 ? 1 : 2,
            };
        }

        private bool HasChild(int index) => index * 2 + 1 < Count;

        private bool IsGrandchild(int node, int grandchild) => grandchild > 2 && Grandparent(grandchild) == node;

        /// <summary>
        ///     Checks if node at index belongs to Min or Max level of the heap.
        ///     Root node belongs to Min level, its children - Max level,
        ///     its grandchildren - Min level, and so on.
        /// </summary>
        /// <param name="index">Index to check.</param>
        /// <returns>true if index is at Min level; false if it is at Max Level.</returns>
        private bool IsMinLevelIndex(int index)
        {
            // For all Min levels, value (index + 1) has the leftmost bit set to '1' at even position.
            const uint minLevelsBits = 0x55555555;
            const uint maxLevelsBits = 0xAAAAAAAA;
            return ((index + 1) & minLevelsBits) > ((index + 1) & maxLevelsBits);
        }

        private int Parent(int index) => (index - 1) / 2;

        private int Grandparent(int index) => ((index - 1) / 2 - 1) / 2;

        /// <summary>
        ///     Assuming that children sub-trees are valid heaps, pushes node to lower levels
        ///     to make heap valid.
        /// </summary>
        /// <param name="index">Node index.</param>
        private void PushDown(int index)
        {
            if (IsMinLevelIndex(index))
            {
                PushDownMin(index);
            }
            else
            {
                PushDownMax(index);
            }
        }

        private void PushDownMax(int index)
        {
            if (!HasChild(index))
            {
                return;
            }

            var maxIndex = IndexOfMaxChildOrGrandchild(index);

            // If smaller element are put at min level (as result of swaping), it doesn't affect sub-tree validity.
            // If smaller element are put at max level, PushDownMax() should be called for that node.
            if (IsGrandchild(index, maxIndex))
            {
                if (Comparer.Compare(heap[maxIndex], heap[index]) > 0)
                {
                    SwapNodes(maxIndex, index);
                    if (Comparer.Compare(heap[maxIndex], heap[Parent(maxIndex)]) < 0)
                    {
                        SwapNodes(maxIndex, Parent(maxIndex));
                    }

                    PushDownMax(maxIndex);
                }
            }
            else
            {
                if (Comparer.Compare(heap[maxIndex], heap[index]) > 0)
                {
                    SwapNodes(maxIndex, index);
                }
            }
        }

        private void PushDownMin(int index)
        {
            if (!HasChild(index))
            {
                return;
            }

            var minIndex = IndexOfMinChildOrGrandchild(index);

            // If bigger element are put at max level (as result of swaping), it doesn't affect sub-tree validity.
            // If bigger element are put at min level, PushDownMin() should be called for that node.
            if (IsGrandchild(index, minIndex))
            {
                if (Comparer.Compare(heap[minIndex], heap[index]) < 0)
                {
                    SwapNodes(minIndex, index);
                    if (Comparer.Compare(heap[minIndex], heap[Parent(minIndex)]) > 0)
                    {
                        SwapNodes(minIndex, Parent(minIndex));
                    }

                    PushDownMin(minIndex);
                }
            }
            else
            {
                if (Comparer.Compare(heap[minIndex], heap[index]) < 0)
                {
                    SwapNodes(minIndex, index);
                }
            }
        }

        /// <summary>
        ///     Having a new node in the heap, swaps this node with its ancestors to make heap valid.
        ///     For node at min level. If new node is less than its parent, then it is surely less then
        ///     all other nodes on max levels on path to the root of the heap. So node are pushed up, by
        ///     swaping with its grandparent, until they are ordered correctly.
        ///     For node at max level algorithm is analogical.
        /// </summary>
        /// <param name="index">Index of the new node.</param>
        private void PushUp(int index)
        {
            if (index == 0)
            {
                return;
            }

            var parent = Parent(index);

            if (IsMinLevelIndex(index))
            {
                if (Comparer.Compare(heap[index], heap[parent]) > 0)
                {
                    SwapNodes(index, parent);
                    PushUpMax(parent);
                }
                else
                {
                    PushUpMin(index);
                }
            }
            else
            {
                if (Comparer.Compare(heap[index], heap[parent]) < 0)
                {
                    SwapNodes(index, parent);
                    PushUpMin(parent);
                }
                else
                {
                    PushUpMax(index);
                }
            }
        }

        private void PushUpMax(int index)
        {
            if (index > 2)
            {
                var grandparent = Grandparent(index);
                if (Comparer.Compare(heap[index], heap[grandparent]) > 0)
                {
                    SwapNodes(index, grandparent);
                    PushUpMax(grandparent);
                }
            }
        }

        private void PushUpMin(int index)
        {
            if (index > 2)
            {
                var grandparent = Grandparent(index);
                if (Comparer.Compare(heap[index], heap[grandparent]) < 0)
                {
                    SwapNodes(index, grandparent);
                    PushUpMin(grandparent);
                }
            }
        }

        private void RemoveNode(int index)
        {
            SwapNodes(index, Count - 1);
            heap.RemoveAt(Count - 1);
            if (Count != 0)
            {
                PushDown(index);
            }
        }

        private void SwapNodes(int i, int j)
        {
            var temp = heap[i];
            heap[i] = heap[j];
            heap[j] = temp;
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.Heap
{
    /// <summary>
    ///     A generic implementation of a binary heap.
    /// </summary>
    /// <remarks>
    ///     A binary heap is a complete binary tree that satisfies the heap property;
    ///     that is every node in the tree compares greater/less than or equal to its left and right
    ///     child nodes. Note that this is different from a binary search tree, where every node
    ///     must be the largest/smallest node of all of its children.
    ///     Although binary heaps are not very efficient, they are (probably) the simpliest heaps
    ///     to understand and implement.
    ///     More information: https://en.wikipedia.org/wiki/Binary_heap .
    /// </remarks>
    /// <typeparam name="T">Type of elements in binary heap.</typeparam>
    public class BinaryHeap<T>
    {
        /// <summary>
        ///     Comparer to use when comparing elements.
        /// </summary>
        private readonly Comparer<T> comparer;

        /// <summary>
        ///     List to hold the elements of the heap.
        /// </summary>
        private readonly List<T> data;

        /// <summary>
        ///     Initializes a new instance of the <see cref="BinaryHeap{T}" /> class.
        /// </summary>
        public BinaryHeap()
        {
            data = new List<T>();
            comparer = Comparer<T>.Default;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="BinaryHeap{T}" /> class with a custom comparision function.
        /// </summary>
        /// <param name="customComparer">The custom comparing function to use to compare elements.</param>
        public BinaryHeap(Comparer<T> customComparer)
        {
            data = new List<T>();
            comparer = customComparer;
        }

        /// <summary>
        ///     Gets the number of elements in the heap.
        /// </summary>
        public int Count => data.Count;

        /// <summary>
        ///     Add an element to the binary heap.
        /// </summary>
        /// <remarks>
        ///     Adding to the heap is done by append the element to the end of the backing list,
        ///     and pushing the added element up until the heap property is restored.
        /// </remarks>
        /// <param name="element">The element to add to the heap.</param>
        /// <exception cref="ArgumentException">Thrown if element is already in heap.</exception>
        public void Push(T element)
        {
            data.Add(element);
            HeapifyUp(data.Count - 1);
        }

        /// <summary>
        ///     Remove the top/root of the binary heap (ie: the largest/smallest element).
        /// </summary>
        /// <remarks>
        ///     Removing from the heap is done by swapping the top/root with the last element in
        ///     the backing list, removing the last element, and pushing the new root down
        ///     until the heap property is restored.
        /// </remarks>
        /// <returns>The top/root of the heap.</returns>
        /// <exception cref="InvalidOperationException">Thrown if heap is empty.</exception>
        public T Pop()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty!");
            }

            var elem = data[0];
            data[0] = data[^1];
            data.RemoveAt(data.Count - 1);
            HeapifyDown(0);

            return elem;
        }

        /// <summary>
        ///     Return the top/root of the heap without removing it.
        /// </summary>
        /// <returns>The top/root of the heap.</returns>
        /// <exception cref="InvalidOperationException">Thrown if heap is empty.</exception>
        public T Peek()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty!");
            }

            return data[0];
        }

        /// <summary>
        ///     Returns element if it compares larger to the top/root of the heap, else
        ///     inserts element into the heap and returns the top/root of the heap.
        /// </summary>
        /// <param name="element">The element to check/insert.</param>
        /// <returns>element if element compares larger than top/root of heap, top/root of heap otherwise.</returns>
        public T PushPop(T element)
        {
            if (Count == 0)
            {
                return element;
            }

            if (comparer.Compare(element, data[0]) < 0)
            {
                var tmp = data[0];
                data[0] = element;
                HeapifyDown(0);
                return tmp;
            }

            return element;
        }

        /// <summary>
        ///     Check if element is in the heap.
        /// </summary>
        /// <param name="element">The element to check for.</param>
        /// <returns>true if element is in the heap, false otherwise.</returns>
        public bool Contains(T element) => data.Contains(element);

        /// <summary>
        ///     Remove an element from the heap.
        /// </summary>
        /// <remarks>
        ///     In removing an element from anywhere in the heap, we only need to push down or up
        ///     the replacement value depending on how the removed value compares to its
        ///     replacement value.
        /// </remarks>
        /// <param name="element">The element to remove from the heap.</param>
        /// <exception cref="ArgumentException">Thrown if element is not in heap.</exception>
        public void Remove(T element)
        {
            var idx = data.IndexOf(element);

            if (idx == -1)
            {
                throw new ArgumentException($"{element} not in heap!");
            }

            Swap(idx, data.Count - 1);
            var tmp = data[^1];
            data.RemoveAt(data.Count - 1);

            if (idx < data.Count)
            {
                if (comparer.Compare(tmp, data[idx]) > 0)
                {
                    HeapifyDown(idx);
                }
                else
                {
                    HeapifyUp(idx);
                }
            }
        }

        /// <summary>
        ///     Swap the elements in the heap array at the given indices.
        /// </summary>
        /// <param name="idx1">First index.</param>
        /// <param name="idx2">Second index.</param>
        private void Swap(int idx1, int idx2)
        {
            var tmp = data[idx1];
            data[idx1] = data[idx2];
            data[idx2] = tmp;
        }

        /// <summary>
        ///     Recursive function to restore heap properties.
        /// </summary>
        /// <remarks>
        ///     Restores heap property by swapping the element at <paramref name="elemIdx" />
        ///     with its parent if the element compares greater than its parent.
        /// </remarks>
        /// <param name="elemIdx">The element to check with its parent.</param>
        private void HeapifyUp(int elemIdx)
        {
            var parent = (elemIdx - 1) / 2;

            if (parent >= 0 && comparer.Compare(data[elemIdx], data[parent]) > 0)
            {
                Swap(elemIdx, parent);
                HeapifyUp(parent);
            }
        }

        /// <summary>
        ///     Recursive function to restore heap properties.
        /// </summary>
        /// <remarks>
        ///     Restores heap property by swapping the element at <paramref name="elemIdx" />
        ///     with the larger of its children.
        /// </remarks>
        /// <param name="elemIdx">The element to check with its children.</param>
        private void HeapifyDown(int elemIdx)
        {
            var left = 2 * elemIdx + 1;
            var right = 2 * elemIdx + 2;

            var leftLargerThanElem = left < Count && comparer.Compare(data[elemIdx], data[left]) < 0;
            var rightLargerThanElem = right < Count && comparer.Compare(data[elemIdx], data[right]) < 0;
            var leftLargerThanRight = left < Count && right < Count && comparer.Compare(data[left], data[right]) > 0;

            if (leftLargerThanElem && leftLargerThanRight)
            {
                Swap(elemIdx, left);
                HeapifyDown(left);
            }
            else if (rightLargerThanElem && !leftLargerThanRight)
            {
                Swap(elemIdx, right);
                HeapifyDown(right);
            }
        }
    }
}
using System;

namespace DataStructures.Queue
{
    /// <summary>
    ///     Implementation of an array based queue. FIFO style.
    /// </summary>
    /// <typeparam name="T">Generic Type.</typeparam>
    public class ArrayBasedQueue<T>
    {
        private readonly T[] queue;
        private int endIndex;
        private bool isEmpty;
        private bool isFull;
        private int startIndex;

        /// <summary>
        ///     Initializes a new instance of the <see cref="ArrayBasedQueue{T}" /> class.
        /// </summary>
        public ArrayBasedQueue(int capacity)
        {
            queue = new T[capacity];
            Clear();
        }

        /// <summary>
        ///     Clears the queue.
        /// </summary>
        public void Clear()
        {
            startIndex = 0;
            endIndex = 0;
            isEmpty = true;
            isFull = false;
        }

        /// <summary>
        ///     Returns the first item in the queue and removes it from the queue.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if the queue is empty.</exception>
        public T Dequeue()
        {
            if (IsEmpty())
            {
                throw new InvalidOperationException("There are no items in the queue.");
            }

            var dequeueIndex = endIndex;
            endIndex++;
            if (endIndex >= queue.Length)
            {
                endIndex = 0;
            }

            isFull = false;
            isEmpty = startIndex == endIndex;

            return queue[dequeueIndex];
        }

        /// <summary>
        ///     Returns a boolean indicating whether the queue is empty.
        /// </summary>
        public bool IsEmpty() => isEmpty;

        /// <summary>
        ///     Returns a boolean indicating whether the queue is full.
        /// </summary>
        public bool IsFull() => isFull;

        /// <summary>
        ///     Returns the first item in the queue and keeps it in the queue.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if the queue is empty.</exception>
        public T Peek()
        {
            if (IsEmpty())
            {
                throw new InvalidOperationException("There are no items in the queue.");
            }

            return queue[endIndex];
        }

        /// <summary>
        ///     Adds an item at the last position in the queue.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if the queue is full.</exception>
        public void Enqueue(T item)
        {
            if (IsFull())
            {
                throw new InvalidOperationException("The queue has reached its capacity.");
            }

            queue[startIndex] = item;

            startIndex++;
            if (startIndex >= queue.Length)
            {
                startIndex = 0;
            }

            isEmpty = false;
            isFull = startIndex == endIndex;
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.Queue
{
    /// <summary>
    ///     Implementation of a stack based queue. FIFO style.
    /// </summary>
    /// <remarks>
    ///     Enqueue is O(1) and Dequeue is amortized O(1).
    /// </remarks>
    /// <typeparam name="T">Generic Type.</typeparam>
    public class StackBasedQueue<T>
    {
        private readonly Stack<T> input;
        private readonly Stack<T> output;

        /// <summary>
        ///     Initializes a new instance of the <see cref="StackBasedQueue{T}" /> class.
        /// </summary>
        public StackBasedQueue()
        {
            input = new Stack<T>();
            output = new Stack<T>();
        }

        /// <summary>
        ///     Clears the queue.
        /// </summary>
        public void Clear()
        {
            input.Clear();
            output.Clear();
        }

        /// <summary>
        ///     Returns the first item in the queue and removes it from the queue.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if the queue is empty.</exception>
        public T Dequeue()
        {
            if (input.Count == 0 && output.Count == 0)
            {
                throw new InvalidOperationException("The queue contains no items.");
            }

            if (output.Count == 0)
            {
                while (input.Count > 0)
                {
                    var item = input.Pop();
                    output.Push(item);
                }
            }

            return output.Pop();
        }

        /// <summary>
        ///     Returns a boolean indicating whether the queue is empty.
        /// </summary>
        public bool IsEmpty() => input.Count == 0 && output.Count == 0;

        /// <summary>
        ///     Returns a boolean indicating whether the queue is full.
        /// </summary>
        public bool IsFull() => false;

        /// <summary>
        ///     Returns the first item in the queue and keeps it in the queue.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if the queue is empty.</exception>
        public T Peek()
        {
            if (input.Count == 0 && output.Count == 0)
            {
                throw new InvalidOperationException("The queue contains no items.");
            }

            if (output.Count == 0)
            {
                while (input.Count > 0)
                {
                    var item = input.Pop();
                    output.Push(item);
                }
            }

            return output.Peek();
        }

        /// <summary>
        ///     Adds an item at the last position in the queue.
        /// </summary>
        public void Enqueue(T item) => input.Push(item);
    }
}
using System;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Queue
{
    /// <summary>
    ///     Implementation of a list based queue. FIFO style.
    /// </summary>
    /// <typeparam name="T">Generic Type.</typeparam>
    public class ListBasedQueue<T>
    {
        private readonly LinkedList<T> queue;

        /// <summary>
        ///     Initializes a new instance of the <see cref="ListBasedQueue{T}" /> class.
        /// </summary>
        public ListBasedQueue() => queue = new LinkedList<T>();

        /// <summary>
        ///     Clears the queue.
        /// </summary>
        public void Clear()
        {
            queue.Clear();
        }

        /// <summary>
        ///     Returns the first item in the queue and removes it from the queue.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if the queue is empty.</exception>
        public T Dequeue()
        {
            if (queue.First is null)
            {
                throw new InvalidOperationException("There are no items in the queue.");
            }

            var item = queue.First;
            queue.RemoveFirst();
            return item.Value;
        }

        /// <summary>
        ///     Returns a boolean indicating whether the queue is empty.
        /// </summary>
        public bool IsEmpty() => !queue.Any();

        /// <summary>
        ///     Returns a boolean indicating whether the queue is full.
        /// </summary>
        public bool IsFull() => false;

        /// <summary>
        ///     Returns the first item in the queue and keeps it in the queue.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if the queue is empty.</exception>
        public T Peek()
        {
            if (queue.First is null)
            {
                throw new InvalidOperationException("There are no items in the queue.");
            }

            return queue.First.Value;
        }

        /// <summary>
        ///     Adds an item at the last position in the queue.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if the queue is full.</exception>
        public void Enqueue(T item)
        {
            queue.AddLast(item);
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.Tries
{
    /// <summary>
    /// A Trie is a data structure (particular case of m-ary tree) used to efficiently represent strings with common prefixes.
    /// Originally posed by E. Fredkin in 1960.
    ///     Fredkin, Edward (Sept. 1960), "Trie Memory", Communications of the ACM 3 (9): 490-499.
    /// Its name is due to retrieval because its main application is in the field of "Information Retrieval" (information retrieval).
    /// </summary>
    public class Trie
    {
        /// <summary>
        /// This character marks the end of a string.
        /// </summary>
        private const char Mark = '$';

        /// <summary>
        /// This property represents the root node of the trie.
        /// </summary>
        private readonly TrieNode root;

        /// <summary>
        /// Initializes a new instance of the <see cref="Trie"/> class. This instances was created without text strings, generating the root node of the trie, without children.
        /// </summary>
        public Trie()
        {
            root = new TrieNode(Mark);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Trie"/> class. Given a set of text strings, each of those strings inserts them into the trie using the Insert (string) method.
        /// </summary>
        /// <param name="words">The array with text strings to insert in the trie.</param>
        public Trie(IEnumerable<string> words)
            : this()
        {
            foreach (string s in words)
            {
                Insert(s);
            }
        }

        /// <summary>
        /// Insert a string s to the trie. The $ mark is added to the end of the chain and then it is added, this in order to indicate the end of the chain in the trie.
        /// </summary>
        /// <param name="s">The string to insert into the trie.</param>
        public void Insert(string s)
        {
            s += Mark;

            int index = 0;
            TrieNode match = PrefixQuery(s, ref index);

            for (int i = index; i < s.Length; i++)
            {
                TrieNode t = new(s[i], match);
                match[s[i]] = t;
                match = t;
            }
        }

        /// <summary>
        /// Remove a text string from the trie.
        /// </summary>
        /// <param name="s">The text string to be removed from the trie.</param>
        public void Remove(string s)
        {
            s += Mark;
            int index = 0;
            TrieNode match = PrefixQuery(s, ref index);
            while(match.IsLeaf())
            {
                char c = match.Value;
                if(match.Parent == null)
                {
                    break;
                }

                match = match.Parent;
                match.Children.Remove(c);
            }
        }

        /// <summary>
        /// Know if a text string is in the trie.
        /// </summary>
        /// <param name="s">The string s that you want to know if it is in the trie.</param>
        /// <returns>If the string is found, it returns true, otherwise false.</returns>
        public bool Find(string s)
        {
            int index = 0;
            return PrefixQuery(s + Mark, ref index).IsLeaf();
        }

        /// <summary>
        /// This method analyzes which is the longest common prefix of a string s in the trie. If the string is in the trie then it is equivalent to doing Find (s).
        /// </summary>
        /// <param name="s">The string for which you want to know the longest common prefix.</param>
        /// <param name="index">The index to which the longest common prefix goes.</param>
        /// <returns>
        /// Returns the longest common prefix node found in the trie with the string s.
        /// </returns>
        private TrieNode PrefixQuery(string s, ref int index)
        {
            TrieNode current = root;
            for (int i = 0; i < s.Length && current != null; i++)
            {
                if (current[s[i]] != null)
                {
                    current = current[s[i]] ?? throw new NullReferenceException();
                    index = i + 1;
                }
                else
                {
                    break;
                }
            }

            return current ?? throw new NullReferenceException();
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.Tries
{
    /// <summary>
    /// This class represents the nodes of a trie.
    /// </summary>
    internal class TrieNode
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TrieNode"/> class. This instance was created with a character from the alphabet, and its parent will be null.
        /// </summary>
        /// <param name="value">Character of the alphabet that represents the node.</param>
        internal TrieNode(char value)
            : this(value, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TrieNode"/> class. This instance was created with a character from the alphabet, and its parent.
        /// </summary>
        /// <param name="value">Character of the alphabet that represents the node.</param>
        /// <param name="parent">The parent or ancestor of the node in the trie structure.</param>
        internal TrieNode(char value, TrieNode? parent)
        {
            Children = new SortedList<char, TrieNode>();
            Parent = parent;
            Value = value;
        }

        /// <summary>
        /// Gets all the descendants of the current node.
        /// </summary>
        /// <value>A sorted set with all the descendants.</value>
        internal SortedList<char, TrieNode> Children { get; private set; }

        /// <summary>
        /// Gets the parent or ancestor of the node in the trie structure.
        /// </summary>
        /// <value>A TrieNode that represent a parent.</value>
        internal TrieNode? Parent { get; private set; }

        /// <summary>
        /// Gets the character of the alphabet that represents the node.
        /// </summary>
        /// <value>A character of the alphabet.</value>
        internal char Value { get; private set; }

        /// <summary>
        /// Index the descendants of the current node given an alphabet character.
        /// </summary>
        /// <value>A TrieNode with the character c in Children.</value>
        public TrieNode? this[char c]
        {
            get => Children.ContainsKey(c) ? Children[c] : null;
            set => Children[c] = value ?? throw new NullReferenceException();
        }

        /// <summary>
        /// Method that checks if the current node is a trie leaf.
        /// </summary>
        /// <returns>Returns true if the current node has no children, false otherwise.</returns>
        public bool IsLeaf()
        {
            return Children.Count == 0;
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.Stack
{
    /// <summary>
    ///     Implementation of a list based stack. FILO style.
    /// </summary>
    /// <typeparam name="T">Generic Type.</typeparam>
    public class ListBasedStack<T>
    {
        /// <summary>
        ///     <see cref="List{T}" /> based stack.
        /// </summary>
        private readonly LinkedList<T> stack;

        /// <summary>
        ///     Initializes a new instance of the <see cref="ListBasedStack{T}" /> class.
        /// </summary>
        public ListBasedStack() => stack = new LinkedList<T>();

        /// <summary>
        ///     Initializes a new instance of the <see cref="ListBasedStack{T}" /> class.
        /// </summary>
        /// <param name="item">Item to push onto the <see cref="ListBasedStack{T}" />.</param>
        public ListBasedStack(T item)
            : this() => Push(item);

        /// <summary>
        ///     Initializes a new instance of the <see cref="ListBasedStack{T}" /> class.
        /// </summary>
        /// <param name="items">Items to push onto the <see cref="ListBasedStack{T}" />.</param>
        public ListBasedStack(IEnumerable<T> items)
            : this()
        {
            foreach (var item in items)
            {
                Push(item);
            }
        }

        /// <summary>
        ///     Gets the number of elements on the <see cref="ListBasedStack{T}" />.
        /// </summary>
        public int Count => stack.Count;

        /// <summary>
        ///     Removes all items from the <see cref="ListBasedStack{T}" />.
        /// </summary>
        public void Clear() => stack.Clear();

        /// <summary>
        ///     Determines whether an element is in the <see cref="ListBasedStack{T}" />.
        /// </summary>
        /// <param name="item">The item to locate in the <see cref="ListBasedStack{T}" />.</param>
        /// <returns>True, if the item is in the stack.</returns>
        public bool Contains(T item) => stack.Contains(item);

        /// <summary>
        ///     Returns the item at the top of the <see cref="ListBasedStack{T}" /> without removing it.
        /// </summary>
        /// <returns>The item at the top of the <see cref="ListBasedStack{T}" />.</returns>
        public T Peek()
        {
            if (stack.First is null)
            {
                throw new InvalidOperationException("Stack is empty");
            }

            return stack.First.Value;
        }

        /// <summary>
        ///     Removes and returns the item at the top of the <see cref="ListBasedStack{T}" />.
        /// </summary>
        /// <returns>The item removed from the top of the <see cref="ListBasedStack{T}" />.</returns>
        public T Pop()
        {
            if (stack.First is null)
            {
                throw new InvalidOperationException("Stack is empty");
            }

            var item = stack.First.Value;
            stack.RemoveFirst();
            return item;
        }

        /// <summary>
        ///     Inserts an item at the top of the <see cref="ListBasedStack{T}" />.
        /// </summary>
        /// <param name="item">The item to push onto the <see cref="ListBasedStack{T}" />.</param>
        public void Push(T item) => stack.AddFirst(item);
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.Stack
{
    /// <summary>
    ///     Implementation of an array-based stack. LIFO style.
    /// </summary>
    /// <typeparam name="T">Generic Type.</typeparam>
    public class ArrayBasedStack<T>
    {
        private const int DefaultCapacity = 10;
        private const string StackEmptyErrorMessage = "Stack is empty";

        /// <summary>
        ///     <see cref="Array" /> based stack.
        /// </summary>
        private T[] stack;

        /// <summary>
        ///     How many items are in the stack right now.
        /// </summary>
        private int top;

        /// <summary>
        ///     Initializes a new instance of the <see cref="ArrayBasedStack{T}" /> class.
        /// </summary>
        public ArrayBasedStack()
        {
            stack = new T[DefaultCapacity];
            top = -1;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ArrayBasedStack{T}" /> class.
        /// </summary>
        /// <param name="item">Item to push onto the <see cref="ArrayBasedStack{T}" />.</param>
        public ArrayBasedStack(T item)
            : this() => Push(item);

        /// <summary>
        ///     Initializes a new instance of the <see cref="ArrayBasedStack{T}" /> class.
        /// </summary>
        /// <param name="items">Items to push onto the <see cref="ArrayBasedStack{T}" />.</param>
        public ArrayBasedStack(IEnumerable<T> items)
            : this()
        {
            foreach (var item in items)
            {
                Push(item);
            }
        }

        /// <summary>
        ///     Gets the number of elements on the <see cref="ArrayBasedStack{T}" />.
        /// </summary>
        public int Top => top;

        /// <summary>
        ///     Gets or sets the Capacity of the <see cref="ArrayBasedStack{T}" />.
        /// </summary>
        public int Capacity
        {
            get => stack.Length;
            set => Array.Resize(ref stack, value);
        }

        /// <summary>
        ///     Removes all items from the <see cref="ArrayBasedStack{T}" />.
        /// </summary>
        public void Clear()
        {
            top = -1;
            Capacity = DefaultCapacity;
        }

        /// <summary>
        ///     Determines whether an element is in the <see cref="ArrayBasedStack{T}" />.
        /// </summary>
        /// <param name="item">The item to locate in the <see cref="ArrayBasedStack{T}" />.</param>
        /// <returns>True, if the item is in the stack.</returns>
        public bool Contains(T item) => Array.IndexOf(stack, item, 0, top + 1) > -1;

        /// <summary>
        ///     Returns the item at the top of the <see cref="ArrayBasedStack{T}" /> without removing it.
        /// </summary>
        /// <returns>The item at the top of the <see cref="ArrayBasedStack{T}" />.</returns>
        public T Peek()
        {
            if (top == -1)
            {
                throw new InvalidOperationException(StackEmptyErrorMessage);
            }

            return stack[top];
        }

        /// <summary>
        ///     Removes and returns the item at the top of the <see cref="ArrayBasedStack{T}" />.
        /// </summary>
        /// <returns>The item removed from the top of the <see cref="ArrayBasedStack{T}" />.</returns>
        public T Pop()
        {
            if (top == -1)
            {
                throw new InvalidOperationException(StackEmptyErrorMessage);
            }

            return stack[top--];
        }

        /// <summary>
        ///     Inserts an item at the top of the <see cref="ArrayBasedStack{T}" />.
        /// </summary>
        /// <param name="item">The item to push onto the <see cref="ArrayBasedStack{T}" />.</param>
        public void Push(T item)
        {
            if (top == Capacity - 1)
            {
                Capacity *= 2;
            }

            stack[++top] = item;
        }
    }
}
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Fenwick
{
    /// <summary>
    /// Represent classical realization of Fenwik tree or Binary Indexed tree.
    ///
    /// BITree[0..n] --> Array that represents Binary Indexed Tree.
    /// arr[0..n-1] --> Input array for which prefix sum is evaluated.
    /// </summary>
    public class BinaryIndexedTree
    {
        private readonly int[] fenwickTree;

        /// <summary>
        /// Initializes a new instance of the <see cref="BinaryIndexedTree"/> class.
        /// Create Binary indexed tree from the given array.
        /// </summary>
        /// <param name="array">Initial array.</param>
        public BinaryIndexedTree(int[] array)
        {
            fenwickTree = new int[array.Length + 1];

            for (var i = 0; i < array.Length; i++)
            {
                UpdateTree(i, array[i]);
            }
        }

        /// <summary>
        /// This method assumes that the array is preprocessed and
        /// partial sums of array elements are stored in BITree[].
        /// </summary>
        /// <param name="index">The position to sum from.</param>
        /// <returns>Returns sum of arr[0..index].</returns>
        public int GetSum(int index)
        {
            var sum = 0;
            var startFrom = index + 1;

            while (startFrom > 0)
            {
                sum += fenwickTree[startFrom];
                startFrom -= startFrom & (-startFrom);
            }

            return sum;
        }

        /// <summary>
        /// Updates a node in Binary Index Tree at given index.
        /// The given value 'val' is added to BITree[i] and all of its ancestors in tree.
        /// </summary>
        /// <param name="index">Given index.</param>
        /// <param name="val">Value to be update on.</param>
        public void UpdateTree(int index, int val)
        {
            var startFrom = index + 1;

            while (startFrom <= fenwickTree.Length)
            {
                fenwickTree[startFrom] += val;
                startFrom += startFrom & (-startFrom);
            }
        }
    }
}
using System;

namespace DataStructures.UnrolledList
{
    /// <summary>
    /// Single node with array buffer for unrolled list.
    /// </summary>
    public class UnrolledLinkedListNode
    {
        private readonly int[] array;

        public UnrolledLinkedListNode(int nodeSize)
        {
            Next = null!;

            Count = 0;
            array = new int[nodeSize];
        }

        public UnrolledLinkedListNode Next { get; set; }

        public int Count { get; set; }

        /// <summary>
        /// Set new item in array buffer.
        /// </summary>
        /// <param name="pos">Index in array.</param>
        /// <param name="val">The entered value.</param>
        /// <exception cref="ArgumentException">Index is out of scope.</exception>
        public void Set(int pos, int val)
        {
            if (pos < 0 || pos > array.Length - 1)
            {
                throw new ArgumentException("Position is out of size", nameof(pos));
            }

            array[pos] = val;
            Count++;
        }

        /// <summary>
        /// Get item from array buffer.
        /// </summary>
        /// <param name="pos">Index in array.</param>
        /// <exception cref="ArgumentException">Index is out of scope.</exception>
        public int Get(int pos)
        {
            if (pos < 0 || pos > array.Length - 1)
            {
                throw new ArgumentException("Position is out of size", nameof(pos));
            }

            return array[pos];
        }
    }
}
using System.Collections.Generic;

namespace DataStructures.UnrolledList
{
    /// <summary>
    /// Unrolled linked list is a linked list of small arrays,
    /// all of the same size where each is so small that the insertion
    /// or deletion is fast and quick, but large enough to fill the cache line.
    /// </summary>
    public class UnrolledLinkedList
    {
        private readonly int sizeNode;

        private UnrolledLinkedListNode start = null!;
        private UnrolledLinkedListNode end = null!;

        /// <summary>
        /// Initializes a new instance of the <see cref="UnrolledLinkedList"/> class.
        /// Create a unrolled list with start chunk size.
        /// </summary>
        /// <param name="chunkSize">The size of signe chunk.</param>
        public UnrolledLinkedList(int chunkSize)
        {
            sizeNode = chunkSize + 1;
        }

        /// <summary>
        /// Add value to list [O(n)].
        /// </summary>
        /// <param name="value">The entered value.</param>
        public void Insert(int value)
        {
            if (start == null)
            {
                start = new UnrolledLinkedListNode(sizeNode);
                start.Set(0, value);

                end = start;
                return;
            }

            if (end.Count + 1 < sizeNode)
            {
                end.Set(end.Count, value);
            }
            else
            {
                var pointer = new UnrolledLinkedListNode(sizeNode);
                var j = 0;
                for (var pos = end.Count / 2 + 1; pos < end.Count; pos++)
                {
                    pointer.Set(j++, end.Get(pos));
                }

                pointer.Set(j++, value);
                pointer.Count = j;

                end.Count = end.Count / 2 + 1;
                end.Next = pointer;
                end = pointer;
            }
        }

        /// <summary>
        /// Help method. Get all list inside to check the state.
        /// </summary>
        /// <returns>Items from all nodes.</returns>
        public IEnumerable<int> GetRolledItems()
        {
            UnrolledLinkedListNode pointer = start;
            List<int> result = new();

            while (pointer != null)
            {
                for (var i = 0; i < pointer.Count; i++)
                {
                    result.Add(pointer.Get(i));
                }

                pointer = pointer.Next;
            }

            return result;
        }
    }
}
using System;

namespace DataStructures.ScapegoatTree
{
    /// <summary>
    /// Scapegoat tree node class.
    /// </summary>
    /// <typeparam name="TKey">Scapegoat tree node key type.</typeparam>
    public class Node<TKey> where TKey : IComparable
    {
        private Node<TKey>? right;
        private Node<TKey>? left;

        public TKey Key { get; }

        public Node<TKey>? Right
        {
            get => right;
            set
            {
                if (value != null && !value.IsGreaterThanOrSameAs(Key))
                {
                    throw new ArgumentException("The value's key is smaller than or equal to node's right child's key.", nameof(value));
                }

                right = value;
            }
        }

        public Node<TKey>? Left
        {
            get => left;
            set
            {
                if (value != null && value.IsGreaterThanOrSameAs(Key))
                {
                    throw new ArgumentException("The value's key is greater than or equal to node's left child's key.", nameof(value));
                }

                left = value;
            }
        }

        public Node(TKey key) => Key = key;

        public Node(TKey key, Node<TKey>? right, Node<TKey>? left)
            : this(key)
        {
            Right = right;
            Left = left;
        }

        /// <summary>
        /// Returns number of elements in the tree.
        /// </summary>
        /// <returns>Number of elements in the tree.</returns>
        public int GetSize() => (Left?.GetSize() ?? 0) + 1 + (Right?.GetSize() ?? 0);

        /// <summary>
        /// Gets alpha height of the current node.
        /// </summary>
        /// <param name="alpha">Alpha value.</param>
        /// <returns>Alpha height value.</returns>
        public double GetAlphaHeight(double alpha) => Math.Floor(Math.Log(GetSize(), 1.0 / alpha));

        public Node<TKey> GetSmallestKeyNode() => Left?.GetSmallestKeyNode() ?? this;

        public Node<TKey> GetLargestKeyNode() => Right?.GetLargestKeyNode() ?? this;

        /// <summary>
        /// Checks if the current node is alpha weight balanced.
        /// </summary>
        /// <param name="a">Alpha value.</param>
        /// <returns>True - if node is alpha weight balanced. If not - false.</returns>
        public bool IsAlphaWeightBalanced(double a)
        {
            var isLeftBalanced = (Left?.GetSize() ?? 0) <= a * GetSize();
            var isRightBalanced = (Right?.GetSize() ?? 0) <= a * GetSize();

            return isLeftBalanced && isRightBalanced;
        }

        private bool IsGreaterThanOrSameAs(TKey key)
        {
            return Key.CompareTo(key) >= 0;
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.ScapegoatTree
{
    public static class Extensions
    {
        /// <summary>
        /// Flattens scapegoat tree into a list of nodes.
        /// </summary>
        /// <param name="root">Scapegoat tree provided as root node.</param>
        /// <param name="list">An empty list.</param>
        /// <typeparam name="TKey">Scapegoat tree node key type.</typeparam>
        public static void FlattenTree<TKey>(Node<TKey> root, List<Node<TKey>> list) where TKey : IComparable
        {
            if (root.Left != null)
            {
                FlattenTree(root.Left, list);
            }

            list.Add(root);

            if (root.Right != null)
            {
                FlattenTree(root.Right, list);
            }
        }

        /// <summary>
        /// Rebuilds a scapegoat tree from list of nodes.
        /// Use with <see cref="FlattenTree{TKey}"/> method.
        /// </summary>
        /// <param name="list">Flattened tree.</param>
        /// <param name="start">Start index.</param>
        /// <param name="end">End index.</param>
        /// <typeparam name="TKey">Scapegoat tree node key type.</typeparam>
        /// <returns>Scapegoat tree root node.</returns>
        /// <exception cref="ArgumentException">Thrown if start index is invalid.</exception>
        public static Node<TKey> RebuildFromList<TKey>(IList<Node<TKey>> list, int start, int end)
            where TKey : IComparable
        {
            if (start > end)
            {
                throw new ArgumentException("The parameter's value is invalid.", nameof(start));
            }

            var pivot = Convert.ToInt32(Math.Ceiling(start + (end - start) / 2.0));

            return new Node<TKey>(list[pivot].Key)
            {
                Left = start > (pivot - 1) ? null : RebuildFromList(list, start, pivot - 1),
                Right = (pivot + 1) > end ? null : RebuildFromList(list, pivot + 1, end),
            };
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.ScapegoatTree
{
    /// <summary>
    /// A scapegoat implementation class.
    /// See https://en.wikipedia.org/wiki/Scapegoat_tree for more information about scapegoat tree.
    /// </summary>
    /// <typeparam name="TKey">The scapegoat tree key type.</typeparam>
    public class ScapegoatTree<TKey> where TKey : IComparable
    {
        /// <summary>
        /// Gets the  (alpha) value of the tree.
        /// </summary>
        public double Alpha { get; private set; }

        /// <summary>
        /// Gets the root node of the tree.
        /// </summary>
        public Node<TKey>? Root { get; private set; }

        /// <summary>
        /// Gets the number of nodes in the tree.
        /// </summary>
        public int Size { get; private set; }

        /// <summary>
        /// Gets the maximal value of the tree Size since the last time the tree was completely rebuilt.
        /// </summary>
        public int MaxSize { get; private set; }

        /// <summary>
        /// Gets an event handler which will fire when tree is being balanced.
        /// </summary>
        public event EventHandler? TreeIsUnbalanced;

        public ScapegoatTree()
            : this(alpha: 0.5, size: 0)
        {
        }

        public ScapegoatTree(double alpha)
            : this(alpha, size: 0)
        {
        }

        public ScapegoatTree(Node<TKey> node, double alpha)
            : this(alpha, size: node.GetSize())
        {
            Root = node;
        }

        public ScapegoatTree(TKey key, double alpha = 0.5)
            : this(alpha, size: 1)
        {
            Root = new Node<TKey>(key);
        }

        private ScapegoatTree(double alpha, int size)
        {
            CheckAlpha(alpha);

            Alpha = alpha;

            Size = size;
            MaxSize = size;
        }

        /// <summary>
        /// Checks if current instance of the scapegoat tree is alpha weight balanced.
        /// </summary>
        /// <returns>True - if tree is alpha weight balanced. Otherwise, false.</returns>
        public bool IsAlphaWeightBalanced()
        {
            return Root?.IsAlphaWeightBalanced(Alpha) ?? true;
        }

        /// <summary>
        /// Check if any node in the tree has specified key value.
        /// </summary>
        /// <param name="key">Key value.</param>
        /// <returns>Returns true if node exists, false if not.</returns>
        public bool Contains(TKey key)
        {
            return Search(key) != null;
        }

        /// <summary>
        /// Searches current instance of the scapegoat tree for specified key.
        /// </summary>
        /// <param name="key">Key value.</param>
        /// <returns>Node with the specified key or null.</returns>
        public Node<TKey>? Search(TKey key)
        {
            if (Root == null)
            {
                return null;
            }

            var current = Root;

            while (true)
            {
                var result = current.Key.CompareTo(key);

                switch (result)
                {
                    case 0:
                        return current;
                    case > 0 when current.Left != null:
                        current = current.Left;
                        break;
                    case < 0 when current.Right != null:
                        current = current.Right;
                        break;
                    default:
                        return null;
                }
            }
        }

        /// <summary>
        /// Inserts a new key into current instance of the scapegoat tree. Rebuilds tree if it's unbalanced.
        /// </summary>
        /// <param name="key">Key value.</param>
        /// <returns>True - if insertion is successful, false - if the key is already present in the tree.</returns>
        public bool Insert(TKey key)
        {
            var node = new Node<TKey>(key);

            if (Root == null)
            {
                Root = node;

                UpdateSizes();

                return true;
            }

            var path = new Stack<Node<TKey>>();

            var current = Root;

            var found = false;

            while (!found)
            {
                path.Push(current);

                var result = current.Key.CompareTo(node.Key);

                switch (result)
                {
                    case < 0 when current.Right != null:
                        current = current.Right;
                        continue;
                    case < 0:
                        current.Right = node;
                        found = true;
                        break;
                    case > 0 when current.Left != null:
                        current = current.Left;
                        continue;
                    case > 0:
                        current.Left = node;
                        found = true;
                        break;
                    default:
                        return false;
                }
            }

            UpdateSizes();

            if (path.Count > Root.GetAlphaHeight(Alpha))
            {
                TreeIsUnbalanced?.Invoke(this, EventArgs.Empty);

                BalanceFromPath(path);

                MaxSize = Math.Max(MaxSize, Size);
            }

            return true;
        }

        /// <summary>
        /// Removes the specified key from the current instance of the scapegoat tree. Rebuilds tree if it's unbalanced.
        /// </summary>
        /// <param name="key">Key value.</param>
        /// <returns>True - if key was successfully removed, false - if the key wasn't found in the tree.</returns>
        public bool Delete(TKey key)
        {
            if (Root == null)
            {
                return false;
            }

            if (Remove(Root, Root, key))
            {
                Size--;

                if (Root != null && Size < Alpha * MaxSize)
                {
                    TreeIsUnbalanced?.Invoke(this, EventArgs.Empty);

                    var list = new List<Node<TKey>>();

                    Extensions.FlattenTree(Root, list);

                    Root = Extensions.RebuildFromList(list, 0, list.Count - 1);

                    MaxSize = Size;
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Clears the tree.
        /// </summary>
        public void Clear()
        {
            Size = 0;
            MaxSize = 0;
            Root = null;
        }

        /// <summary>
        /// Changes <see cref="Alpha"/> value to adjust balancing.
        /// </summary>
        /// <param name="value">New alpha value.</param>
        public void Tune(double value)
        {
            CheckAlpha(value);
            Alpha = value;
        }

        /// <summary>
        /// Searches for a scapegoat node in provided stack.
        /// </summary>
        /// <param name="path">Stack instance with nodes, starting with root node.</param>
        /// <returns>Scapegoat node with its parent node. Parent can be null if scapegoat node is root node.</returns>
        /// <exception cref="ArgumentException">Thrown if path stack is empty.</exception>
        /// <exception cref="InvalidOperationException">Thrown if scapegoat wasn't found.</exception>
        public (Node<TKey>? parent, Node<TKey> scapegoat) FindScapegoatInPath(Stack<Node<TKey>> path)
        {
            if (path.Count == 0)
            {
                throw new ArgumentException("The path collection should not be empty.", nameof(path));
            }

            var depth = 1;

            while (path.TryPop(out var next))
            {
                if (depth > next.GetAlphaHeight(Alpha))
                {
                    return path.TryPop(out var parent) ? (parent, next) : (null, next);
                }

                depth++;
            }

            throw new InvalidOperationException("Scapegoat node wasn't found. The tree should be unbalanced.");
        }

        private static void CheckAlpha(double alpha)
        {
            if (alpha is < 0.5 or > 1.0)
            {
                throw new ArgumentException("The alpha parameter's value should be in 0.5..1.0 range.", nameof(alpha));
            }
        }

        private bool Remove(Node<TKey>? parent, Node<TKey>? node, TKey key)
        {
            if (node is null || parent is null)
            {
                return false;
            }

            var compareResult = node.Key.CompareTo(key);

            if (compareResult > 0)
            {
                return Remove(node, node.Left, key);
            }

            if (compareResult < 0)
            {
                return Remove(node, node.Right, key);
            }

            Node<TKey>? replacementNode;

            // Case 0: Node has no children.
            // Case 1: Node has one child.
            if (node.Left is null || node.Right is null)
            {
                replacementNode = node.Left ?? node.Right;
            }

            // Case 2: Node has two children. (This implementation uses the in-order predecessor to replace node.)
            else
            {
                var predecessorNode = node.Left.GetLargestKeyNode();
                Remove(Root, Root, predecessorNode.Key);
                replacementNode = new Node<TKey>(predecessorNode.Key)
                {
                    Left = node.Left,
                    Right = node.Right,
                };
            }

            // Replace the relevant node with a replacement found in the previous stages.
            // Special case for replacing the root node.
            if (node == Root)
            {
                Root = replacementNode;
            }
            else if (parent.Left == node)
            {
                parent.Left = replacementNode;
            }
            else
            {
                parent.Right = replacementNode;
            }

            return true;
        }

        private void BalanceFromPath(Stack<Node<TKey>> path)
        {
            var (parent, scapegoat) = FindScapegoatInPath(path);

            var list = new List<Node<TKey>>();

            Extensions.FlattenTree(scapegoat, list);

            var tree = Extensions.RebuildFromList(list, 0, list.Count - 1);

            if (parent == null)
            {
                Root = tree;
            }
            else
            {
                var result = parent.Key.CompareTo(tree.Key);

                if (result < 0)
                {
                    parent.Right = tree;
                }
                else
                {
                    parent.Left = tree;
                }
            }
        }

        private void UpdateSizes()
        {
            Size += 1;
            MaxSize = Math.Max(Size, MaxSize);
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.AVLTree
{
    /// <summary>
    ///     A simple self-balancing binary tree.
    /// </summary>
    /// <remarks>
    ///     An AVL tree is a self-balancing binary search tree (BST) named after
    ///     its inventors: Adelson, Velsky, and Landis. It is the first self-
    ///     balancing BST invented. The primary property of an AVL tree is that
    ///     the height of both child subtrees for any node only differ by one.
    ///     Due to the balanced nature of the tree, its time complexities for
    ///     insertion, deletion, and search all have a worst-case time complexity
    ///     of O(log n). Which is an improvement over the worst-case O(n) for a
    ///     regular BST.
    ///     See https://en.wikipedia.org/wiki/AVL_tree for more information.
    ///     Visualizer: https://visualgo.net/en/bst.
    /// </remarks>
    /// <typeparam name="TKey">Type of key for the tree.</typeparam>
    public class AvlTree<TKey>
    {
        /// <summary>
        ///     Gets the number of nodes in the tree.
        /// </summary>
        public int Count { get; private set; }

        /// <summary>
        ///     Comparer to use when comparing key values.
        /// </summary>
        private readonly Comparer<TKey> comparer;

        /// <summary>
        ///     Reference to the root node.
        /// </summary>
        private AvlTreeNode<TKey>? root;

        /// <summary>
        ///     Initializes a new instance of the <see cref="AvlTree{TKey}"/> class.
        /// </summary>
        public AvlTree()
        {
            comparer = Comparer<TKey>.Default;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="AvlTree{TKey}"/> class
        ///     using the specified comparer.
        /// </summary>
        /// <param name="customComparer">Comparer to use when comparing keys.</param>
        public AvlTree(Comparer<TKey> customComparer)
        {
            comparer = customComparer;
        }

        /// <summary>
        ///     Add a single node to the tree.
        /// </summary>
        /// <param name="key">Key value to add.</param>
        public void Add(TKey key)
        {
            if (root is null)
            {
                root = new AvlTreeNode<TKey>(key);
            }
            else
            {
                root = Add(root, key);
            }

            Count++;
        }

        /// <summary>
        ///     Add multiple nodes to the tree.
        /// </summary>
        /// <param name="keys">Key values to add.</param>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach(var key in keys)
            {
                Add(key);
            }
        }

        /// <summary>
        ///     Remove a node from the tree.
        /// </summary>
        /// <param name="key">Key value to remove.</param>
        public void Remove(TKey key)
        {
            if (root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }
            else if (!Contains(key))
            {
                throw new KeyNotFoundException($"Key {key} is not in the tree");
            }
            else
            {
                root = Remove(root, key);
                Count--;
            }
        }

        /// <summary>
        ///     Check if given node is in the tree.
        /// </summary>
        /// <param name="key">Key value to search for.</param>
        /// <returns>Whether or not the node is in the tree.</returns>
        public bool Contains(TKey key)
        {
            var node = root;
            while (node is not null)
            {
                var compareResult = comparer.Compare(key, node.Key);
                if (compareResult < 0)
                {
                    node = node.Left;
                }
                else if (compareResult > 0)
                {
                    node = node.Right;
                }
                else
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        ///     Get the minimum value in the tree.
        /// </summary>
        /// <returns>Minimum value in tree.</returns>
        public TKey GetMin()
        {
            if(root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMin(root).Key;
        }

        /// <summary>
        ///     Get the maximum value in the tree.
        /// </summary>
        /// <returns>Maximum value in tree.</returns>
        public TKey GetMax()
        {
            if(root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMax(root).Key;
        }

        /// <summary>
        ///     Get keys in order from smallest to largest as defined by the comparer.
        /// </summary>
        /// <returns>Keys in tree in order from smallest to largest.</returns>
        public IEnumerable<TKey> GetKeysInOrder()
        {
            List<TKey> result = new();
            InOrderWalk(root);
            return result;

            void InOrderWalk(AvlTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                InOrderWalk(node.Left);
                result.Add(node.Key);
                InOrderWalk(node.Right);
            }
        }

        /// <summary>
        ///     Get keys in the pre-order order.
        /// </summary>
        /// <returns>Keys in pre-order order.</returns>
        public IEnumerable<TKey> GetKeysPreOrder()
        {
            var result = new List<TKey>();
            PreOrderWalk(root);
            return result;

            void PreOrderWalk(AvlTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                result.Add(node.Key);
                PreOrderWalk(node.Left);
                PreOrderWalk(node.Right);
            }
        }

        /// <summary>
        ///     Get keys in the post-order order.
        /// </summary>
        /// <returns>Keys in the post-order order.</returns>
        public IEnumerable<TKey> GetKeysPostOrder()
        {
            var result = new List<TKey>();
            PostOrderWalk(root);
            return result;

            void PostOrderWalk(AvlTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                PostOrderWalk(node.Left);
                PostOrderWalk(node.Right);
                result.Add(node.Key);
            }
        }

        /// <summary>
        ///     Recursively function to add a node to the tree.
        /// </summary>
        /// <param name="node">Node to check for null leaf.</param>
        /// <param name="key">Key value to add.</param>
        /// <returns>New node with key inserted.</returns>
        private AvlTreeNode<TKey> Add(AvlTreeNode<TKey> node, TKey key)
        {
            // Regular binary search tree insertion
            int compareResult = comparer.Compare(key, node.Key);
            if (compareResult < 0)
            {
                if (node.Left is null)
                {
                    var newNode = new AvlTreeNode<TKey>(key);
                    node.Left = newNode;
                }
                else
                {
                    node.Left = Add(node.Left, key);
                }
            }
            else if (compareResult > 0)
            {
                if (node.Right is null)
                {
                    var newNode = new AvlTreeNode<TKey>(key);
                    node.Right = newNode;
                }
                else
                {
                    node.Right = Add(node.Right, key);
                }
            }
            else
            {
                throw new ArgumentException($"Key \"{key}\" already exists in tree!");
            }

            // Check all of the new node's ancestors for inbalance and perform
            // necessary rotations
            node.UpdateBalanceFactor();

            return Rebalance(node);
        }

        /// <summary>
        ///     Recursive function to remove node from tree.
        /// </summary>
        /// <param name="node">Node to check for key.</param>
        /// <param name="key">Key value to remove.</param>
        /// <returns>New node with key removed.</returns>
        private AvlTreeNode<TKey>? Remove(AvlTreeNode<TKey> node, TKey key)
        {
            // Normal binary search tree removal
            var compareResult = comparer.Compare(key, node.Key);
            if (compareResult < 0)
            {
                node.Left = Remove(node.Left!, key);
            }
            else if (compareResult > 0)
            {
                node.Right = Remove(node.Right!, key);
            }
            else
            {
                if (node.Left is null && node.Right is null)
                {
                    return null;
                }
                else if (node.Left is null)
                {
                    var successor = GetMin(node.Right!);
                    node.Right = Remove(node.Right!, successor.Key);
                    node.Key = successor.Key;
                }
                else
                {
                    var predecessor = GetMax(node.Left!);
                    node.Left = Remove(node.Left!, predecessor.Key);
                    node.Key = predecessor.Key;
                }
            }

            // Check all of the removed node's ancestors for rebalance and
            // perform necessary rotations.
            node.UpdateBalanceFactor();

            return Rebalance(node);
        }

        /// <summary>
        ///     Helper function to rebalance the tree so that all nodes have a
        ///     balance factor in the range [-1, 1].
        /// </summary>
        /// <param name="node">Node to rebalance.</param>
        /// <returns>New node that has been rebalanced.</returns>
        private AvlTreeNode<TKey> Rebalance(AvlTreeNode<TKey> node)
        {
            if (node.BalanceFactor > 1)
            {
                if (node.Right!.BalanceFactor == -1)
                {
                    node.Right = RotateRight(node.Right);
                }

                return RotateLeft(node);
            }
            else if (node.BalanceFactor < -1)
            {
                if (node.Left!.BalanceFactor == 1)
                {
                    node.Left = RotateLeft(node.Left);
                }

                return RotateRight(node);
            }
            else
            {
                return node;
            }
        }

        /// <summary>
        ///     Perform a left (counter-clockwise) rotation.
        /// </summary>
        /// <param name="node">Node to rotate about.</param>
        /// <returns>New node with rotation applied.</returns>
        private AvlTreeNode<TKey> RotateLeft(AvlTreeNode<TKey> node)
        {
            var temp1 = node;
            var temp2 = node!.Right!.Left;
            node = node.Right;
            node.Left = temp1;
            node.Left.Right = temp2;

            node.Left.UpdateBalanceFactor();
            node.UpdateBalanceFactor();

            return node;
        }

        /// <summary>
        ///     Perform a right (clockwise) rotation.
        /// </summary>
        /// <param name="node">Node to rotate about.</param>
        /// <returns>New node with rotation applied.</returns>
        private AvlTreeNode<TKey> RotateRight(AvlTreeNode<TKey> node)
        {
            var temp1 = node;
            var temp2 = node!.Left!.Right;
            node = node.Left;
            node.Right = temp1;
            node.Right.Left = temp2;

            node.Right.UpdateBalanceFactor();
            node.UpdateBalanceFactor();

            return node;
        }

        /// <summary>
        ///     Helper function to get node instance with minimum key value
        ///     in the specified subtree.
        /// </summary>
        /// <param name="node">Node specifying root of subtree.</param>
        /// <returns>Minimum value in node's subtree.</returns>
        private AvlTreeNode<TKey> GetMin(AvlTreeNode<TKey> node)
        {
            while (node.Left is not null)
            {
                node = node.Left;
            }

            return node;
        }

        /// <summary>
        ///     Helper function to get node instance with maximum key value
        ///     in the specified subtree.
        /// </summary>
        /// <param name="node">Node specifyng root of subtree.</param>
        /// <returns>Maximum value in node's subtree.</returns>
        private AvlTreeNode<TKey> GetMax(AvlTreeNode<TKey> node)
        {
            while (node.Right is not null)
            {
                node = node.Right;
            }

            return node;
        }
    }
}
using System;

namespace DataStructures.AVLTree
{
    /// <summary>
    ///     Generic class to represent nodes in an <see cref="AvlTree{TKey}"/> instance.
    /// </summary>
    /// <typeparam name="TKey">The type of key for the node.</typeparam>
    public class AvlTreeNode<TKey>
    {
        /// <summary>
        ///     Gets or sets key value of node.
        /// </summary>
        public TKey Key { get; set; }

        /// <summary>
        ///     Gets the height of the node.
        /// </summary>
        public int Height { get; private set; }

        /// <summary>
        ///     Gets the balance factor of the node.
        /// </summary>
        public int BalanceFactor { get; private set; }

        /// <summary>
        ///     Gets or sets the left child of the node.
        /// </summary>
        public AvlTreeNode<TKey>? Left { get; set; }

        /// <summary>
        ///     Gets or sets the right child of the node.
        /// </summary>
        public AvlTreeNode<TKey>? Right { get; set; }

        /// <summary>
        ///     Initializes a new instance of the <see cref="AvlTreeNode{TKey}"/> class.
        /// </summary>
        /// <param name="key">Key value for node.</param>
        public AvlTreeNode(TKey key)
        {
            Key = key;
        }

        /// <summary>
        ///     Update the node's height and balance factor.
        /// </summary>
        public void UpdateBalanceFactor()
        {
            if(Left is null && Right is null)
            {
                Height = 0;
                BalanceFactor = 0;
            }
            else if(Left is null)
            {
                Height = Right!.Height + 1;
                BalanceFactor = Height;
            }
            else if(Right is null)
            {
                Height = Left!.Height + 1;
                BalanceFactor = -Height;
            }
            else
            {
                Height = Math.Max(Left.Height, Right.Height) + 1;
                BalanceFactor = Right.Height - Left.Height;
            }
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Strings
{
    public class KnuthMorrisPrattSearcher
    {
        /// <summary>
        ///     An implementation of KnuthMorrisPratt Algorithm.
        ///     Worst case time complexity: O(n + k)
        ///     where n - text length, k - pattern length.
        /// </summary>
        /// <param name="str">The string to look in.</param>
        /// <param name="pat">The pattern to look for.</param>
        /// <returns>
        ///     The zero-based positions of all occurrences of <paramref name="pat" /> in <paramref name="str" />.
        /// </returns>
        public IEnumerable<int> FindIndexes(string str, string pat)
        {
            var lps = FindLongestPrefixSuffixValues(pat);

            for (int i = 0, j = 0; i < str.Length;)
            {
                if (pat[j] == str[i])
                {
                    j++;
                    i++;
                }

                if (j == pat.Length)
                {
                    yield return i - j;
                    j = lps[j - 1];
                    continue;
                }

                if (i < str.Length && pat[j] != str[i])
                {
                    if (j != 0)
                    {
                        j = lps[j - 1];
                    }
                    else
                    {
                        i += 1;
                    }
                }
            }
        }

        /// <summary>
        ///     Return the longest prefix suffix values for pattern.
        /// </summary>
        /// <param name="pat">pattern to seek.</param>
        /// <returns>The longest prefix suffix values for <paramref name="pat" />.</returns>
        public int[] FindLongestPrefixSuffixValues(string pat)
        {
            var lps = new int[pat.Length];
            for (int i = 1, len = 0; i < pat.Length;)
            {
                if (pat[i] == pat[len])
                {
                    len++;
                    lps[i] = len;
                    i++;
                    continue;
                }

                if (len != 0)
                {
                    len = lps[len - 1];
                }
                else
                {
                    lps[i] = 0;
                    i++;
                }
            }

            return lps;
        }
    }
}
using System;

namespace Algorithms.Strings
{
    /// <summary>
    ///     The idea:   You compare the pattern with the text from right to left.
    ///     If the text symbol that is compared with the rightmost pattern symbol
    ///     does not occur in the pattern at all, then the pattern can be shifted
    ///     by m positions behind this text symbol.
    ///     Complexity:
    ///     Time:   Preprocessing: O(m)
    ///     Comparison: O(mn)
    ///     Space:  O(m + a)
    ///     where   m - pattern length
    ///     n - text length
    ///     a - alphabet length.
    ///     Source:     https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/bmen.htm
    ///     https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm.
    /// </summary>
    public static class BoyerMoore
    {
        /// <summary>
        ///     Finds the index of the first occurrence of the pattern <c>p</c> in <c>t</c>.
        /// </summary>
        /// <param name="t">Input text.</param>
        /// <param name="p">Search pattern.</param>
        /// <returns>Index of the pattern in text or -1 if the pattern  was not found.</returns>
        public static int FindFirstOccurrence(string t, string p)
        {
            // Pattern length
            var m = p.Length;

            // Text length
            var n = t.Length;

            // For each symbol of the alphabet, the position of its rightmost occurrence in the pattern,
            // or -1 if the symbol does not occur in the pattern.
            int[] badChar = BadCharacterRule(p, m);

            // Each entry goodSuffix[i] contains the shift distance of the pattern
            // if a mismatch at position i  1 occurs, i.e. if the suffix of the pattern starting at position i has matched.
            int[] goodSuffix = GoodSuffixRule(p, m);

            // Index in text
            var i = 0;

            // Index in pattern
            int j;

            while (i <= n - m)
            {
                // Starting at end of pattern
                j = m - 1;

                // While matching
                while (j >= 0 && p[j] == t[i + j])
                {
                    j--;
                }

                // Pattern found
                if (j < 0)
                {
                    return i;
                }

                // Pattern is shifted by the maximum of the values
                // given by the good-suffix and the bad-character heuristics
                i += Math.Max(goodSuffix[j + 1], j - badChar[t[i + j]]);
            }

            // Pattern not found
            return -1;
        }

        /// <summary>
        ///     Finds out the position of its rightmost occurrence in the pattern for each symbol of the alphabet,
        ///     or -1 if the symbol does not occur in the pattern.
        /// </summary>
        /// <param name="p">Search pattern.</param>
        /// <param name="m">Length of the pattern.</param>
        /// <returns>Array of the named postition for each symbol of the alphabet.</returns>
        private static int[] BadCharacterRule(string p, int m)
        {
            // For each character (note that there are more than 256 characters)
            int[] badChar = new int[256];
            Array.Fill(badChar, -1);

            // Iterate from left to right over the pattern
            for (var j = 0; j < m; j++)
            {
                badChar[p[j]] = j;
            }

            return badChar;
        }

        /// <summary>
        ///     Finds out the shift distance of the pattern if a mismatch at position i  1 occurs
        ///     for each character of the pattern, i.e. if the suffix of the pattern starting at position i has matched.
        /// </summary>
        /// <param name="p">Search pattern.</param>
        /// <param name="m">Length of the pattern.</param>
        /// <returns>Array of the named shift distance for each character of the pattern.</returns>
        private static int[] GoodSuffixRule(string p, int m)
        {
            // CASE 1
            // The matching suffix occurs somewhere else in the pattern
            // --> matching suffix is a border of a suffix of the pattern

            // f[i] contains starting position of the widest border of the suffix of the pattern beginning at position i
            int[] f = new int[p.Length + 1];

            // Suffix of p[m] has no border --> f[m] = m+1
            f[m] = m + 1;

            // Corresponding shift distance
            int[] s = new int[p.Length + 1];

            // Start of suffix including border of the pattern
            // (hint: https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/kmpen.htm#section2)
            var i = m;

            // Start of suffix of the pattern
            var j = m + 1;

            while (i > 0)
            {
                // checking if a shorter border that is already known can be extended to the left by the same symbol
                while (j <= m && p[i - 1] != p[j - 1])
                {
                    if (s[j] == 0)
                    {
                        s[j] = j - i;
                    }

                    j = f[j];
                }

                --i;
                --j;
                f[i] = j;
            }

            // CASE 2
            // Only a part of the matching suffix occurs at the beginning of the pattern
            // (filling remaining entries)
            j = f[0];
            for (i = 0; i <= m; i++)
            {
                // Starting postition of the greates border
                if (s[i] == 0)
                {
                    s[i] = j;
                }

                // From position i = j, it switches to the next narrower border f[j]
                if (i == j)
                {
                    j = f[j];
                }
            }

            return s;
        }
    }
}
using System.Collections.Generic;

// Implements the traditional naive string matching algorithm in C# for TheAlgorithms/C-Sharp.
namespace Algorithms.Strings
{
    /// <summary>
    ///     Implements the traditional naive string matching algorithm in C#.
    /// </summary>
    public static class NaiveStringSearch
    {
        /// <summary>
        ///     NaiveSearch(Content, Pattern) will return an array containing each index of Content in which Pattern appears.
        ///     Cost:  O(n*m).
        /// </summary>
        /// <param name="content">The text body across which to search for a given pattern.</param>
        /// <param name="pattern">The pattern against which to check the given text body.</param>
        /// <returns>Array containing each index of Content in which Pattern appears.</returns>
        public static int[] NaiveSearch(string content, string pattern)
        {
            var m = pattern.Length;
            var n = content.Length;
            List<int> indices = new();
            for (var e = 0; e <= n - m; e++)
            {
                int j;
                for (j = 0; j < m; j++)
                {
                    if (content[e + j] != pattern[j])
                    {
                        break;
                    }
                }

                if (j == m)
                {
                    indices.Add(e);
                }
            }

            return indices.ToArray();
        }
    }
}
using System;
using System.Text.RegularExpressions;

namespace Algorithms.Strings
{
    /// <summary>
    ///     TODO.
    /// </summary>
    public static class Palindrome
    {
        /// <summary>
        ///     TODO.
        /// </summary>
        /// <param name="word">TODO. 2.</param>
        /// <returns>TODO. 3.</returns>
        public static bool IsStringPalindrome(string word) =>
            TypifyString(word).Equals(TypifyString(ReverseString(word)));

        // Typify string to lower and remove white spaces.
        private static string TypifyString(string word) =>
            Regex.Replace(word.ToLowerInvariant(), @"\s+", string.Empty);

        private static string ReverseString(string s)
        {
            var arr = s.ToCharArray();
            Array.Reverse(arr);
            return new string(arr);
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Strings
{
    /// <summary>
    ///     The idea: You calculate the hash for the pattern <c>p</c> and the hash values for all the prefixes of the text
    ///     <c>t</c>.
    ///     Now, you can compare a substring in constant time using the calculated hashes.
    ///     time complexity: O(p + t),
    ///     space complexity: O(t),
    ///     where   t - text length
    ///     p - pattern length.
    /// </summary>
    public static class RabinKarp
    {
        /// <summary>
        ///     Finds the index of all occurrences of the pattern <c>p</c> int <c>t</c>.
        /// </summary>
        /// <returns>List of starting indices of the pattern in the text.</returns>
        public static List<int> FindAllOccurrences(string text, string pattern)
        {
            // Prime number
            const ulong p = 65537;

            // Modulo coefficient
            const ulong m = (ulong)1e9 + 7;

            // p_pow[i] = P^i mod M
            ulong[] pPow = new ulong[Math.Max(pattern.Length, text.Length)];
            pPow[0] = 1;
            for (var i = 1; i < pPow.Length; i++)
            {
                pPow[i] = pPow[i - 1] * p % m;
            }

            // hash_t[i] is the sum of the previous hash values of the letters (t[0], t[1], ..., t[i-1]) and the hash value of t[i] itself (mod M).
            // The hash value of a letter t[i] is equal to the product of t[i] and p_pow[i] (mod M).
            ulong[] hashT = new ulong[text.Length + 1];
            for (var i = 0; i < text.Length; i++)
            {
                hashT[i + 1] = (hashT[i] + text[i] * pPow[i]) % m;
            }

            // hash_s is equal to sum of the hash values of the pattern (mod M).
            ulong hashS = 0;
            for (var i = 0; i < pattern.Length; i++)
            {
                hashS = (hashS + pattern[i] * pPow[i]) % m;
            }

            // In the next step you iterate over the text with the pattern.
            List<int> occurrences = new();
            for (var i = 0; i + pattern.Length - 1 < text.Length; i++)
            {
                // In each step you calculate the hash value of the substring to be tested.
                // By storing the hash values of the letters as a prefixes you can do this in constant time.
                var currentHash = (hashT[i + pattern.Length] + m - hashT[i]) % m;

                // Now you can compare the hash value of the substring with the product of the hash value of the pattern and p_pow[i].
                if (currentHash == hashS * pPow[i] % m)
                {
                    // If the hash values are identical, do a double-check in case a hash collision occurs.
                    var j = 0;
                    while (j < pattern.Length && text[i + j] == pattern[j])
                    {
                        ++j;
                    }

                    if (j == pattern.Length)
                    {
                        // If the hash values are identical and the double-check passes, a substring was found that matches the pattern.
                        // In this case you add the index i to the list of occurences.
                        occurrences.Add(i);
                    }
                }
            }

            return occurrences;
        }
    }
}
using System;

namespace Algorithms.Strings
{
    /// <summary>
    ///     Implements simple algorithms on strings.
    /// </summary>
    public static class GeneralStringAlgorithms
    {
        /// <summary>
        ///     Finds character that creates longest consecutive substring with single character.
        /// </summary>
        /// <param name="input">String to find in.</param>
        /// <returns>Tuple containing char and number of times it appeared in a row.</returns>
        public static Tuple<char, int> FindLongestConsecutiveCharacters(string input)
        {
            var maxChar = input[0];

            var max = 1;
            var current = 1;

            for (var i = 1; i < input.Length; i++)
            {
                if (input[i] == input[i - 1])
                {
                    current++;
                    if (current > max)
                    {
                        max = current;
                        maxChar = input[i];
                    }
                }
                else
                {
                    current = 1;
                }
            }

            return new Tuple<char, int>(maxChar, max);
        }
    }
}
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Strings
{
    public static class Permutation
    {
        /// <summary>
        /// Returns every anagram of a given word.
        /// </summary>
        /// <returns>List of anagrams.</returns>
        public static List<string> GetEveryUniquePermutation(string word)
        {
            if (word.Length < 2)
            {
                return new List<string>
                {
                    word,
                };
            }

            var result = new HashSet<string>();

            for (var i = 0; i < word.Length; i++)
            {
                var temp = GetEveryUniquePermutation(word.Remove(i, 1));

                result.UnionWith(temp.Select(subPerm => word[i] + subPerm));
            }

            return result.ToList();
        }
    }
}
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
    <CodeAnalysisRuleSet>..\stylecop.ruleset</CodeAnalysisRuleSet>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DocumentationFile>./bin/Algorithms.xml</DocumentationFile>
  </PropertyGroup>

  <ItemGroup>
    <AdditionalFiles Include="..\stylecop.json" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="StyleCop.Analyzers" Version="1.1.118">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="System.Drawing.Common" Version="5.0.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\DataStructures\DataStructures.csproj" />
    <ProjectReference Include="..\Utilities\Utilities.csproj" />
  </ItemGroup>

</Project>
namespace Algorithms.Knapsack
{
    public class BranchAndBoundNode
    {
        // isTaken --> true = the item where index = level is taken, vice versa
        public bool IsTaken { get; }

        // cumulativeWeight --> um of weight of item associated in each nodes starting from root to this node (only item that is taken)
        public int CumulativeWeight { get; set; }

        // cumulativeValue --> sum of value of item associated in each nodes starting from root to this node (only item that is taken)
        public double CumulativeValue { get; set; }

        // upperBound --> largest possible value after taking/not taking the item associated to this node (fractional)
        public double UpperBound { get; set; }

        // level --> level of the node in the tree structure
        public int Level { get; }

        // parent node
        public BranchAndBoundNode? Parent { get; }

        public BranchAndBoundNode(int level, bool taken, BranchAndBoundNode? parent = null)
        {
            Level = level;
            IsTaken = taken;
            Parent = parent;
        }
    }
}
using System;

namespace Algorithms.Knapsack
{
    /// <summary>
    ///     Solves knapsack problem using some heuristics
    ///     Sum of values of taken items -> max
    ///     Sum of weights of taken items. &lt;= capacity.
    /// </summary>
    /// <typeparam name="T">Type of items in knapsack.</typeparam>
    public interface IHeuristicKnapsackSolver<T>
    {
        /// <summary>
        ///     Solves knapsack problem using some heuristics
        ///     Sum of values of taken items -> max
        ///     Sum of weights of taken items. &lt;= capacity.
        /// </summary>
        /// <param name="items">All items to choose from.</param>
        /// <param name="capacity">How much weight we can take.</param>
        /// <param name="weightSelector">Maps item to its weight.</param>
        /// <param name="valueSelector">Maps item to its value.</param>
        /// <returns>Items that were chosen.</returns>
        T[] Solve(T[] items, double capacity, Func<T, double> weightSelector, Func<T, double> valueSelector);
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Knapsack
{
    /// <summary>
    ///     Dynamic Programming Knapsack solver.
    /// </summary>
    /// <typeparam name="T">Type of items in knapsack.</typeparam>
    public class DynamicProgrammingKnapsackSolver<T>
    {
        /// <summary>
        ///     Returns the knapsack containing the items that
        ///     maximize value while not exceeding weight capacity.
        /// </summary>
        /// <param name="items">The list of items from which we select ones to be in the knapsack.</param>
        /// <param name="capacity">
        ///     The maximum weight capacity of the knapsack
        ///     to be filled. Only integer values of this capacity are tried. If
        ///     a greater resolution is needed, multiply the
        ///     weights/capacity by a factor of 10.
        /// </param>
        /// <param name="weightSelector">
        ///     A function that returns the value of the specified item
        ///     from the <paramref name="items">items</paramref> list.
        /// </param>
        /// <param name="valueSelector">
        ///     A function that returns the weight of the specified item
        ///     from the <paramref name="items">items</paramref> list.
        /// </param>
        /// <returns>
        ///     The array of items that provides the maximum value of the
        ///     knapsack without exceeding the specified weight <paramref name="capacity">capacity</paramref>.
        /// </returns>
        public T[] Solve(T[] items, int capacity, Func<T, int> weightSelector, Func<T, double> valueSelector)
        {
            var cache = Tabulate(items, weightSelector, valueSelector, capacity);
            return GetOptimalItems(items, weightSelector, cache, capacity);
        }

        private static T[] GetOptimalItems(T[] items, Func<T, int> weightSelector, double[,] cache, int capacity)
        {
            var currentCapacity = capacity;

            var result = new List<T>();
            for (var i = items.Length - 1; i >= 0; i--)
            {
                if (cache[i + 1, currentCapacity] > cache[i, currentCapacity])
                {
                    var item = items[i];
                    result.Add(item);
                    currentCapacity -= weightSelector(item);
                }
            }

            result.Reverse(); // we added items back to front
            return result.ToArray();
        }

        private static double[,] Tabulate(
            T[] items,
            Func<T, int> weightSelector,
            Func<T, double> valueSelector,
            int maxCapacity)
        {
            // Store the incremental results in a bottom up manner
            var n = items.Length;
            var results = new double[n + 1, maxCapacity + 1];
            for (var i = 0; i <= n; i++)
            {
                for (var w = 0; w <= maxCapacity; w++)
                {
                    if (i == 0 || w == 0)
                    {
                        // If we have no items to take, or
                        // if we have no capacity in our knapsack
                        // we cannot possibly have any value
                        results[i, w] = 0;
                    }
                    else if (weightSelector(items[i - 1]) <= w)
                    {
                        // Decide if it is better to take or not take this item
                        var iut = items[i - 1]; // iut = Item under test
                        var vut = valueSelector(iut); // vut = Value of item under test
                        var wut = weightSelector(iut); // wut = Weight of item under test
                        var valueIfTaken = vut + results[i - 1, w - wut];
                        var valueIfNotTaken = results[i - 1, w];
                        results[i, w] = Math.Max(valueIfTaken, valueIfNotTaken);
                    }
                    else
                    {
                        // There is not enough room to take this item
                        results[i, w] = results[i - 1, w];
                    }
                }
            }

            return results;
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Knapsack
{
    /// <summary>
    ///     Branch and bound Knapsack solver.
    /// </summary>
    /// <typeparam name="T">Type of items in knapsack.</typeparam>
    public class BranchAndBoundKnapsackSolver<T>
    {
        /// <summary>
        ///     Returns the knapsack containing the items that maximize value while not exceeding weight capacity.
        ///     Construct a tree structure with total number of items + 1 levels, each node have two child nodes,
        ///     starting with a dummy item root, each following levels are associated with 1 items, construct the
        ///     tree in breadth first order to identify the optimal item set.
        /// </summary>
        /// <param name="items">All items to choose from.</param>
        /// <param name="capacity">The maximum weight capacity of the knapsack to be filled.</param>
        /// <param name="weightSelector">
        ///     A function that returns the value of the specified item
        ///     from the <paramref name="items">items</paramref> list.
        /// </param>
        /// <param name="valueSelector">
        ///     A function that returns the weight of the specified item
        ///     from the <paramref name="items">items</paramref> list.
        /// </param>
        /// <returns>
        ///     The array of items that provides the maximum value of the
        ///     knapsack without exceeding the specified weight <paramref name="capacity">capacity</paramref>.
        /// </returns>
        public T[] Solve(T[] items, int capacity, Func<T, int> weightSelector, Func<T, double> valueSelector)
        {
            // This is required for greedy approach in upper bound calculation to work.
            items = items.OrderBy(i => valueSelector(i) / weightSelector(i)).ToArray();

            // nodesQueue --> used to construct tree in breadth first order
            Queue<BranchAndBoundNode> nodesQueue = new();

            // maxCumulativeValue --> maximum value while not exceeding weight capacity.
            var maxCumulativeValue = 0.0;

            // starting node, associated with a temporary created dummy item
            BranchAndBoundNode root = new(level: -1, taken: false);

            // lastNodeOfOptimalPat --> last item in the optimal item sets identified by this algorithm
            BranchAndBoundNode lastNodeOfOptimalPath = root;

            nodesQueue.Enqueue(root);

            while (nodesQueue.Count != 0)
            {
                // parent --> parent node which represents the previous item, may or may not be taken into the knapsack
                BranchAndBoundNode parent = nodesQueue.Dequeue();

                // IF it is the last level, branching cannot be performed
                if (parent.Level == items.Length - 1)
                {
                    continue;
                }

                // create a child node where the associated item is taken into the knapsack
                var left = new BranchAndBoundNode(parent.Level + 1, true, parent);

                // create a child node where the associated item is not taken into the knapsack
                var right = new BranchAndBoundNode(parent.Level + 1, false, parent);

                // Since the associated item on current level is taken for the first node,
                // set the cumulative weight of first node to cumulative weight of parent node + weight of the associated item,
                // set the cumulative value of first node to cumulative value of parent node + value of current level's item.
                left.CumulativeWeight = parent.CumulativeWeight + weightSelector(items[left.Level]);
                left.CumulativeValue = parent.CumulativeValue + valueSelector(items[left.Level]);
                right.CumulativeWeight = parent.CumulativeWeight;
                right.CumulativeValue = parent.CumulativeValue;

                // IF cumulative weight is smaller than the weight capacity of the knapsack AND
                // current cumulative value is larger then the current maxCumulativeValue, update the maxCumulativeValue
                if (left.CumulativeWeight <= capacity && left.CumulativeValue > maxCumulativeValue)
                {
                    maxCumulativeValue = left.CumulativeValue;
                    lastNodeOfOptimalPath = left;
                }

                left.UpperBound = ComputeUpperBound(left, items, capacity, weightSelector, valueSelector);
                right.UpperBound = ComputeUpperBound(right, items, capacity, weightSelector, valueSelector);

                // IF upperBound of this node is larger than maxCumulativeValue,
                // the current path is still possible to reach or surpass the maximum value,
                // add current node to nodesQueue so that nodes below it can be further explored
                if (left.UpperBound > maxCumulativeValue && left.CumulativeWeight < capacity)
                {
                    nodesQueue.Enqueue(left);
                }

                // Cumulative weight is the same as for parent node and < capacity
                if (right.UpperBound > maxCumulativeValue)
                {
                    nodesQueue.Enqueue(right);
                }
            }

            return GetItemsFromPath(items, lastNodeOfOptimalPath);
        }

        // determine items taken based on the path
        private static T[] GetItemsFromPath(T[] items, BranchAndBoundNode lastNodeOfPath)
        {
            List<T> takenItems = new();

            // only bogus initial node has no parent
            for (var current = lastNodeOfPath; current.Parent is not null; current = current.Parent)
            {
                if(current.IsTaken)
                {
                    takenItems.Add(items[current.Level]);
                }
            }

            return takenItems.ToArray();
        }

        /// <summary>
        ///     Returns the upper bound value of a given node.
        /// </summary>
        /// <param name="aNode">The given node.</param>
        /// <param name="items">All items to choose from.</param>
        /// <param name="capacity">The maximum weight capacity of the knapsack to be filled.</param>
        /// <param name="weightSelector">
        ///     A function that returns the value of the specified item
        ///     from the <paramref name="items">items</paramref> list.
        /// </param>
        /// <param name="valueSelector">
        ///     A function that returns the weight of the specified item
        ///     from the <paramref name="items">items</paramref> list.
        /// </param>
        /// <returns>
        ///     upper bound value of the given <paramref name="aNode">node</paramref>.
        /// </returns>
        private static double ComputeUpperBound(BranchAndBoundNode aNode, T[] items, int capacity, Func<T, int> weightSelector, Func<T, double> valueSelector)
        {
            var upperBound = aNode.CumulativeValue;
            var availableWeight = capacity - aNode.CumulativeWeight;
            var nextLevel = aNode.Level + 1;

            while (availableWeight > 0 && nextLevel < items.Length)
            {
                if (weightSelector(items[nextLevel]) <= availableWeight)
                {
                    upperBound += valueSelector(items[nextLevel]);
                    availableWeight -= weightSelector(items[nextLevel]);
                }
                else
                {
                    upperBound += valueSelector(items[nextLevel]) / weightSelector(items[nextLevel]) * availableWeight;
                    availableWeight = 0;
                }

                nextLevel++;
            }

            return upperBound;
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Knapsack
{
    /// <summary>
    ///     Greedy heurictic solver.
    /// </summary>
    /// <typeparam name="T">Type of items in knapsack.</typeparam>
    public class NaiveKnapsackSolver<T> : IHeuristicKnapsackSolver<T>
    {
        /// <summary>
        ///     TODO.
        /// </summary>
        /// <param name="items">TODO. 2.</param>
        /// <param name="capacity">TODO. 3.</param>
        /// <param name="weightSelector">TODO. 4.</param>
        /// <param name="valueSelector">TODO. 5.</param>
        /// <returns>TODO. 6.</returns>
        public T[] Solve(T[] items, double capacity, Func<T, double> weightSelector, Func<T, double> valueSelector)
        {
            var weight = 0d;
            var left = new List<T>();

            foreach (var item in items)
            {
                var weightDelta = weightSelector(item);
                if (weight + weightDelta <= capacity)
                {
                    weight += weightDelta;
                    left.Add(item);
                }
            }

            return left.ToArray();
        }
    }
}
namespace Algorithms.Knapsack
{
    /// <summary>
    ///     Solves knapsack problem:
    ///     to maximize sum of values of taken items,
    ///     while sum of weights of taken items is less than capacity.
    /// </summary>
    /// <typeparam name="T">Type of items in knapsack.</typeparam>
    public interface IKnapsackSolver<T> : IHeuristicKnapsackSolver<T>
    {
    }
}
using System.Collections.Generic;
using System.Linq;
using DataStructures.Graph;

namespace Algorithms.Graph
{
    /// <summary>
    /// Implementation of Kosaraju-Sharir's algorithm (also known as Kosaraju's algorithm) to find the
    /// strongly connected components (SCC) of a directed graph.
    /// See https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm.
    /// </summary>
    /// <typeparam name="T">Vertex data type.</typeparam>
    public static class Kosaraju<T>
    {
        /// <summary>
        /// First DFS for Kosaraju algorithm: traverse the graph creating a reverse order explore list <paramref name="reversed"/>.
        /// </summary>
        /// <param name="v">Vertex to explore.</param>
        /// <param name="graph">Graph instance.</param>
        /// <param name="visited">List of already visited vertex.</param>
        /// <param name="reversed">Reversed list of vertex for the second DFS.</param>
        public static void Visit(Vertex<T> v, IDirectedWeightedGraph<T> graph, HashSet<Vertex<T>> visited, Stack<Vertex<T>> reversed)
        {
            if (visited.Contains(v))
            {
                return;
            }

            // Set v as visited
            visited.Add(v);

            // Push v in the stack.
            // This can also be done with a List, inserting v at the begining of the list
            // after visit the neighbors.
            reversed.Push(v);

            // Visit neighbors
            foreach (var u in graph.GetNeighbors(v))
            {
                Visit(u!, graph, visited, reversed);
            }
        }

        /// <summary>
        /// Second DFS for Kosaraju algorithm. Traverse the graph in reversed order
        /// assigning a root vertex for every vertex that belong to the same SCC.
        /// </summary>
        /// <param name="v">Vertex to assign.</param>
        /// <param name="root">Root vertext, representative of the SCC.</param>
        /// <param name="graph">Graph with vertex and edges.</param>
        /// <param name="roots">
        /// Dictionary that assigns to each vertex the root of the SCC to which it corresponds.
        /// </param>
        public static void Assign(Vertex<T> v, Vertex<T> root, IDirectedWeightedGraph<T> graph, Dictionary<Vertex<T>, Vertex<T>> roots)
        {
            // If v already has a representative vertex (root) already assigned, do nothing.
            if (roots.ContainsKey(v))
            {
                return;
            }

            // Assign the root to the vertex.
            roots.Add(v, root);

            // Assign the current root vertex to v neighbors.
            foreach (var u in graph.GetNeighbors(v))
            {
                Assign(u!, root, graph, roots);
            }
        }

        /// <summary>
        /// Find the representative vertex of the SCC for each vertex on the graph.
        /// </summary>
        /// <param name="graph">Graph to explore.</param>
        /// <returns>A dictionary that assigns to each vertex a root vertex of the SCC they belong. </returns>
        public static Dictionary<Vertex<T>, Vertex<T>> GetRepresentatives(IDirectedWeightedGraph<T> graph)
        {
            HashSet<Vertex<T>> visited = new HashSet<Vertex<T>>();
            Stack<Vertex<T>> reversedL = new Stack<Vertex<T>>();
            Dictionary<Vertex<T>, Vertex<T>> representatives = new Dictionary<Vertex<T>, Vertex<T>>();

            foreach (var v in graph.Vertices)
            {
                if (v != null)
                {
                    Visit(v, graph, visited, reversedL);
                }
            }

            visited.Clear();

            while (reversedL.Count > 0)
            {
                Vertex<T> v = reversedL.Pop();
                Assign(v, v, graph, representatives);
            }

            return representatives;
        }

        /// <summary>
        /// Get the Strongly Connected Components for the graph.
        /// </summary>
        /// <param name="graph">Graph to explore.</param>
        /// <returns>An array of SCC.</returns>
        public static IEnumerable<Vertex<T>>[] GetScc(IDirectedWeightedGraph<T> graph)
        {
            var representatives = GetRepresentatives(graph);
            Dictionary<Vertex<T>, List<Vertex<T>>> scc = new Dictionary<Vertex<T>, List<Vertex<T>>>();
            foreach (var kv in representatives)
            {
                // Assign all vertex (key) that have the seem root (value) to a single list.
                if (scc.ContainsKey(kv.Value))
                {
                    scc[kv.Value].Add(kv.Key);
                }
                else
                {
                    scc.Add(kv.Value, new List<Vertex<T>> { kv.Key });
                }
            }

            return scc.Values.ToArray();
        }
    }
}
using System;
using DataStructures.Graph;

namespace Algorithms.Graph
{
    /// <summary>
    /// Floyd Warshall algorithm on directed weighted graph.
    /// </summary>
    /// <typeparam name="T">generic type of data in graph.</typeparam>
    public class FloydWarshall<T>
    {
        /// <summary>
        /// runs the algorithm.
        /// </summary>
        /// <param name="graph">graph upon which to run.</param>
        /// <returns>
        /// a 2D array of shortest paths between any two vertices.
        /// where there is no path between two vertices - double.PositiveInfinity is placed.
        /// </returns>
        public double[,] Run(DirectedWeightedGraph<T> graph)
        {
            var distances = SetupDistances(graph);
            var vertexCount = distances.GetLength(0);
            for (var k = 0; k < vertexCount; k++)
            {
                for (var i = 0; i < vertexCount; i++)
                {
                    for (var j = 0; j < vertexCount; j++)
                    {
                        distances[i, j] = distances[i, j] > distances[i, k] + distances[k, j]
                        ? distances[i, k] + distances[k, j]
                        : distances[i, j];
                    }
                }
            }

            return distances;
        }

        /// <summary>
        /// setup adjacency matrix for use by main algorithm run.
        /// </summary>
        /// <param name="graph">graph to dissect adjacency matrix from.</param>
        /// <returns>the adjacency matrix in the format mentioned in Run.</returns>
        private double[,] SetupDistances(DirectedWeightedGraph<T> graph)
        {
            var distances = new double[graph.Count, graph.Count];
            for (int i = 0; i < distances.GetLength(0); i++)
            {
                for (var j = 0; j < distances.GetLength(0); j++)
                {
                    var dist = graph.AdjacentDistance(graph.Vertices[i] !, graph.Vertices[j] !);
                    distances[i, j] = dist != 0 ? dist : double.PositiveInfinity;
                }
            }

            for (var i = 0; i < distances.GetLength(0); i++)
            {
                distances[i, i] = 0;
            }

            return distances;
        }
    }
}
using System;
using System.Collections.Generic;
using DataStructures.Graph;

namespace Algorithms.Graph
{
    /// <summary>
    /// Breadth First Search - algorithm for traversing graph.
    /// Algorithm starts from root node that is selected by the user.
    /// Algorithm explores all nodes at the present depth.
    /// </summary>
    /// <typeparam name="T">Vertex data type.</typeparam>
    public class BreadthFirstSearch<T> : IGraphSearch<T> where T : IComparable<T>
    {
        /// <summary>
        /// Traverses graph from start vertex.
        /// </summary>
        /// <param name="graph">Graph instance.</param>
        /// <param name="startVertex">Vertex that search starts from.</param>
        /// <param name="action">Action that needs to be executed on each graph vertex.</param>
        public void VisitAll(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action = default)
        {
            Bfs(graph, startVertex, action, new HashSet<Vertex<T>>());
        }

        /// <summary>
        /// Traverses graph from start vertex.
        /// </summary>
        /// <param name="graph">Graph instance.</param>
        /// <param name="startVertex">Vertex that search starts from.</param>
        /// <param name="action">Action that needs to be executed on each graph vertex.</param>
        /// <param name="visited">Hash set with visited vertices.</param>
        private void Bfs(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action, HashSet<Vertex<T>> visited)
        {
            var queue = new Queue<Vertex<T>>();

            queue.Enqueue(startVertex);

            while (queue.Count > 0)
            {
                var currentVertex = queue.Dequeue();

                if (currentVertex == null || visited.Contains(currentVertex))
                {
                    continue;
                }

                foreach (var vertex in graph.GetNeighbors(currentVertex))
                {
                    queue.Enqueue(vertex!);
                }

                action?.Invoke(currentVertex);

                visited.Add(currentVertex);
            }
        }
    }
}
using System;
using DataStructures.Graph;

namespace Algorithms.Graph
{
    public interface IGraphSearch<T>
    {
        /// <summary>
        /// Traverses graph from start vertex.
        /// </summary>
        /// <param name="graph">Graph instance.</param>
        /// <param name="startVertex">Vertex that search starts from.</param>
        /// <param name="action">Action that needs to be executed on each graph vertex.</param>
        void VisitAll(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action = null);
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using DataStructures.Graph;

namespace Algorithms.Graph.Dijkstra
{
    public static class DijkstraAlgorithm
    {
        /// <summary>
        /// Implementation of the Dijkstra shortest path algorithm for cyclic graphs.
        /// https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm.
        /// </summary>
        /// <param name="graph">Graph instance.</param>
        /// <param name="startVertex">Starting vertex instance.</param>
        /// <typeparam name="T">Generic Parameter.</typeparam>
        /// <returns>List of distances from current vertex to all other vertices.</returns>
        /// <exception cref="InvalidOperationException">Exception thrown in case when graph is null or start
        /// vertex does not belong to graph instance.</exception>
        public static DistanceModel<T>[] GenerateShortestPath<T>(DirectedWeightedGraph<T> graph, Vertex<T> startVertex)
        {
            ValidateGraphAndStartVertex(graph, startVertex);

            var visitedVertices = new List<Vertex<T>>();

            var distanceArray = InitializeDistanceArray(graph, startVertex);

            var currentVertex = startVertex;

            var currentPath = 0d;

            while (true)
            {
                visitedVertices.Add(currentVertex);

                var neighborVertices = graph
                    .GetNeighbors(currentVertex)
                    .Where(x => x != null && !visitedVertices.Contains(x))
                    .ToList();

                foreach (var vertex in neighborVertices)
                {
                    var adjacentDistance = graph.AdjacentDistance(currentVertex, vertex!);

                    var distance = distanceArray[vertex!.Index];

                    if (distance.Distance <= currentPath + adjacentDistance)
                    {
                        continue;
                    }

                    distance.Distance = currentPath + adjacentDistance;
                    distance.PreviousVertex = currentVertex;
                }

                var minimalAdjacentVertex = GetMinimalUnvisitedAdjacentVertex(graph, currentVertex, neighborVertices);

                if (neighborVertices.Count == 0 || minimalAdjacentVertex is null)
                {
                    break;
                }

                currentPath += graph.AdjacentDistance(currentVertex, minimalAdjacentVertex);

                currentVertex = minimalAdjacentVertex;
            }

            return distanceArray;
        }

        private static DistanceModel<T>[] InitializeDistanceArray<T>(
            IDirectedWeightedGraph<T> graph,
            Vertex<T> startVertex)
        {
            var distArray = new DistanceModel<T>[graph.Count];

            distArray[startVertex.Index] = new DistanceModel<T>(startVertex, startVertex, 0);

            foreach (var vertex in graph.Vertices.Where(x => x != null && !x.Equals(startVertex)))
            {
                distArray[vertex!.Index] = new DistanceModel<T>(vertex, null, double.MaxValue);
            }

            return distArray;
        }

        private static void ValidateGraphAndStartVertex<T>(DirectedWeightedGraph<T> graph, Vertex<T> startVertex)
        {
            if (graph is null)
            {
                throw new ArgumentNullException(nameof(graph));
            }

            if (startVertex.Graph != null && !startVertex.Graph.Equals(graph))
            {
                throw new ArgumentNullException(nameof(graph));
            }
        }

        private static Vertex<T>? GetMinimalUnvisitedAdjacentVertex<T>(
            IDirectedWeightedGraph<T> graph,
            Vertex<T> startVertex,
            IEnumerable<Vertex<T>?> adjacentVertices)
        {
            var minDistance = double.MaxValue;
            Vertex<T>? minVertex = default;

            foreach (var vertex in adjacentVertices)
            {
                var currentDistance = graph.AdjacentDistance(startVertex, vertex!);

                if (minDistance <= currentDistance)
                {
                    continue;
                }

                minDistance = currentDistance;
                minVertex = vertex;
            }

            return minVertex;
        }
    }
}
using DataStructures.Graph;

namespace Algorithms.Graph.Dijkstra
{
    /// <summary>
    /// Entity which represents the Dijkstra shortest distance.
    /// Contains: Vertex, Previous Vertex and minimal distance from start vertex.
    /// </summary>
    /// <typeparam name="T">Generic parameter.</typeparam>
    public class DistanceModel<T>
    {
        public Vertex<T>? Vertex { get; }

        public Vertex<T>? PreviousVertex { get; set; }

        public double Distance { get; set; }

        public DistanceModel(Vertex<T>? vertex, Vertex<T>? previousVertex, double distance)
        {
            Vertex = vertex;
            PreviousVertex = previousVertex;
            Distance = distance;
        }

        public override string ToString() =>
            $"Vertex: {Vertex} - Distance: {Distance} - Previous: {PreviousVertex}";
    }
}
using System;
using System.Collections.Generic;
using DataStructures.Graph;

namespace Algorithms.Graph
{
    /// <summary>
    /// Depth First Search - algorithm for traversing graph.
    /// Algorithm starts from root node that is selected by the user.
    /// Algorithm explores as far as possible along each branch before backtracking.
    /// </summary>
    /// <typeparam name="T">Vertex data type.</typeparam>
    public class DepthFirstSearch<T> : IGraphSearch<T> where T : IComparable<T>
    {
        /// <summary>
        /// Traverses graph from start vertex.
        /// </summary>
        /// <param name="graph">Graph instance.</param>
        /// <param name="startVertex">Vertex that search starts from.</param>
        /// <param name="action">Action that needs to be executed on each graph vertex.</param>
        public void VisitAll(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action = default)
        {
            Dfs(graph, startVertex, action, new HashSet<Vertex<T>>());
        }

        /// <summary>
        /// Traverses graph from start vertex.
        /// </summary>
        /// <param name="graph">Graph instance.</param>
        /// <param name="startVertex">Vertex that search starts from.</param>
        /// <param name="action">Action that needs to be executed on each graph vertex.</param>
        /// <param name="visited">Hash set with visited vertices.</param>
        private void Dfs(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action, HashSet<Vertex<T>> visited)
        {
            action?.Invoke(startVertex);

            visited.Add(startVertex);

            foreach (var vertex in graph.GetNeighbors(startVertex))
            {
                if (vertex == null || visited.Contains(vertex))
                {
                    continue;
                }

                Dfs(graph, vertex!, action, visited);
            }
        }
    }
}
using System;

namespace Algorithms.Graph.MinimumSpanningTree
{
    /// <summary>
    ///     Class that uses Prim's (Jarnik's algorithm) to determine the minimum
    ///     spanning tree (MST) of a given graph. Prim's algorithm is a greedy
    ///     algorithm that can determine the MST of a weighted undirected graph
    ///     in O(V^2) time where V is the number of nodes/vertices when using an
    ///     adjacency matrix representation.
    ///     More information: https://en.wikipedia.org/wiki/Prim%27s_algorithm
    ///     Pseudocode and runtime analysis: https://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/primAlgor.htm .
    /// </summary>
    public static class PrimMatrix
    {
        /// <summary>
        ///     Determine the minimum spanning tree for a given weighted undirected graph.
        /// </summary>
        /// <param name="adjacencyMatrix">Adjacency matrix for graph to find MST of.</param>
        /// <param name="start">Node to start search from.</param>
        /// <returns>Adjacency matrix of the found MST.</returns>
        public static float[,] Solve(float[,] adjacencyMatrix, int start)
        {
            ValidateMatrix(adjacencyMatrix);

            var numNodes = adjacencyMatrix.GetLength(0);

            // Create array to represent minimum spanning tree
            var mst = new float[numNodes, numNodes];

            // Create array to keep track of which nodes are in the MST already
            var added = new bool[numNodes];

            // Create array to keep track of smallest edge weight for node
            var key = new float[numNodes];

            // Create array to store parent of node
            var parent = new int[numNodes];

            for (var i = 0; i < numNodes; i++)
            {
                mst[i, i] = float.PositiveInfinity;
                key[i] = float.PositiveInfinity;

                for (var j = i + 1; j < numNodes; j++)
                {
                    mst[i, j] = float.PositiveInfinity;
                    mst[j, i] = float.PositiveInfinity;
                }
            }

            // Ensures that the starting node is added first
            key[start] = 0;

            // Keep looping until all nodes are in tree
            for (var i = 0; i < numNodes - 1; i++)
            {
                GetNextNode(adjacencyMatrix, key, added, parent);
            }

            // Build adjacency matrix for tree
            for (var i = 0; i < numNodes; i++)
            {
                if (i == start)
                {
                    continue;
                }

                mst[i, parent[i]] = adjacencyMatrix[i, parent[i]];
                mst[parent[i], i] = adjacencyMatrix[i, parent[i]];
            }

            return mst;
        }

        /// <summary>
        ///     Ensure that the given adjacency matrix represents a weighted undirected graph.
        /// </summary>
        /// <param name="adjacencyMatrix">Adjacency matric to check.</param>
        private static void ValidateMatrix(float[,] adjacencyMatrix)
        {
            // Matrix should be square
            if (adjacencyMatrix.GetLength(0) != adjacencyMatrix.GetLength(1))
            {
                throw new ArgumentException("Adjacency matrix must be square!");
            }

            // Graph needs to be undirected and connected
            for (var i = 0; i < adjacencyMatrix.GetLength(0); i++)
            {
                var connection = false;
                for (var j = 0; j < adjacencyMatrix.GetLength(0); j++)
                {
                    if (Math.Abs(adjacencyMatrix[i, j] - adjacencyMatrix[j, i]) > 1e-6)
                    {
                        throw new ArgumentException("Adjacency matrix must be symmetric!");
                    }

                    if (!connection && float.IsFinite(adjacencyMatrix[i, j]))
                    {
                        connection = true;
                    }
                }

                if (!connection)
                {
                    throw new ArgumentException("Graph must be connected!");
                }
            }
        }

        /// <summary>
        ///     Determine which node should be added next to the MST.
        /// </summary>
        /// <param name="adjacencyMatrix">Adjacency matrix of graph.</param>
        /// <param name="key">Currently known minimum edge weight connected to each node.</param>
        /// <param name="added">Whether or not a node has been added to the MST.</param>
        /// <param name="parent">The node that added the node to the MST. Used for building MST adjacency matrix.</param>
        private static void GetNextNode(float[,] adjacencyMatrix, float[] key, bool[] added, int[] parent)
        {
            var numNodes = adjacencyMatrix.GetLength(0);
            var minWeight = float.PositiveInfinity;

            var node = -1;

            // Find node with smallest node with known edge weight not in tree. Will always start with starting node
            for (var i = 0; i < numNodes; i++)
            {
                if (!added[i] && key[i] < minWeight)
                {
                    minWeight = key[i];
                    node = i;
                }
            }

            // Add node to mst
            added[node] = true;

            // Update smallest found edge weights and parent for adjacent nodes
            for (var i = 0; i < numNodes; i++)
            {
                if (!added[i] && adjacencyMatrix[node, i] < key[i])
                {
                    key[i] = adjacencyMatrix[node, i];
                    parent[i] = node;
                }
            }
        }
    }
}
using System;
using System.Collections.Generic;
using DataStructures.DisjointSet;

namespace Algorithms.Graph.MinimumSpanningTree
{
    /// <summary>
    ///     Algorithm to determine the minimum spanning forest of an undirected graph.
    /// </summary>
    /// <remarks>
    ///     Kruskal's algorithm is a greedy algorithm that can determine the
    ///     minimum spanning tree or minimum spanning forest of any undirected
    ///     graph. Unlike Prim's algorithm, Kruskal's algorithm will work on
    ///     graphs that are unconnected. This algorithm will always have a
    ///     running time of O(E log V) where E is the number of edges and V is
    ///     the number of vertices/nodes.
    ///     More information: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm .
    ///     Pseudocode and analysis: https://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/primAlgor.htm .
    /// </remarks>
    public static class Kruskal
    {
        /// <summary>
        ///     Determine the minimum spanning tree/forest of the given graph.
        /// </summary>
        /// <param name="adjacencyMatrix">Adjacency matrix representing the graph.</param>
        /// <returns>Adjacency matrix of the minimum spanning tree/forest.</returns>
        public static float[,] Solve(float[,] adjacencyMatrix)
        {
            ValidateGraph(adjacencyMatrix);

            var numNodes = adjacencyMatrix.GetLength(0);
            var set = new DisjointSet<int>();
            var nodes = new Node<int>[numNodes];
            var edgeWeightList = new List<float>();
            var nodeConnectList = new List<(int, int)>();

            // Add nodes to disjoint set
            for (var i = 0; i < numNodes; i++)
            {
                nodes[i] = set.MakeSet(i);
            }

            // Create lists with edge weights and associated connectivity
            for (var i = 0; i < numNodes - 1; i++)
            {
                for (var j = i + 1; j < numNodes; j++)
                {
                    if (float.IsFinite(adjacencyMatrix[i, j]))
                    {
                        edgeWeightList.Add(adjacencyMatrix[i, j]);
                        nodeConnectList.Add((i, j));
                    }
                }
            }

            var edges = Solve(set, nodes, edgeWeightList.ToArray(), nodeConnectList.ToArray());

            // Initialize minimum spanning tree
            var mst = new float[numNodes, numNodes];
            for (var i = 0; i < numNodes; i++)
            {
                mst[i, i] = float.PositiveInfinity;

                for (var j = i + 1; j < numNodes; j++)
                {
                    mst[i, j] = float.PositiveInfinity;
                    mst[j, i] = float.PositiveInfinity;
                }
            }

            foreach (var (node1, node2) in edges)
            {
                mst[node1, node2] = adjacencyMatrix[node1, node2];
                mst[node2, node1] = adjacencyMatrix[node1, node2];
            }

            return mst;
        }

        /// <summary>
        ///     Determine the minimum spanning tree/forest of the given graph.
        /// </summary>
        /// <param name="adjacencyList">Adjacency list representing the graph.</param>
        /// <returns>Adjacency list of the minimum spanning tree/forest.</returns>
        public static Dictionary<int, float>[] Solve(Dictionary<int, float>[] adjacencyList)
        {
            ValidateGraph(adjacencyList);

            var numNodes = adjacencyList.Length;
            var set = new DisjointSet<int>();
            var nodes = new Node<int>[numNodes];
            var edgeWeightList = new List<float>();
            var nodeConnectList = new List<(int, int)>();

            // Add nodes to disjoint set and create list of edge weights and associated connectivity
            for (var i = 0; i < numNodes; i++)
            {
                nodes[i] = set.MakeSet(i);

                foreach(var (node, weight) in adjacencyList[i])
                {
                    edgeWeightList.Add(weight);
                    nodeConnectList.Add((i, node));
                }
            }

            var edges = Solve(set, nodes, edgeWeightList.ToArray(), nodeConnectList.ToArray());

            // Create minimum spanning tree
            var mst = new Dictionary<int, float>[numNodes];
            for (var i = 0; i < numNodes; i++)
            {
                mst[i] = new Dictionary<int, float>();
            }

            foreach (var (node1, node2) in edges)
            {
                mst[node1].Add(node2, adjacencyList[node1][node2]);
                mst[node2].Add(node1, adjacencyList[node1][node2]);
            }

            return mst;
        }

        /// <summary>
        ///     Ensure that the given graph is undirected.
        /// </summary>
        /// <param name="adj">Adjacency matrix of graph to check.</param>
        private static void ValidateGraph(float[,] adj)
        {
            if (adj.GetLength(0) != adj.GetLength(1))
            {
                throw new ArgumentException("Matrix must be square!");
            }

            for (var i = 0; i < adj.GetLength(0) - 1; i++)
            {
                for (var j = i + 1; j < adj.GetLength(1); j++)
                {
                    if (Math.Abs(adj[i, j] - adj[j, i]) > 1e-6)
                    {
                        throw new ArgumentException("Matrix must be symmetric!");
                    }
                }
            }
        }

        /// <summary>
        ///     Ensure that the given graph is undirected.
        /// </summary>
        /// <param name="adj">Adjacency list of graph to check.</param>
        private static void ValidateGraph(Dictionary<int, float>[] adj)
        {
            for (var i = 0; i < adj.Length; i++)
            {
                foreach (var edge in adj[i])
                {
                    if (!adj[edge.Key].ContainsKey(i) || Math.Abs(edge.Value - adj[edge.Key][i]) > 1e-6)
                    {
                        throw new ArgumentException("Graph must be undirected!");
                    }
                }
            }
        }

        /// <summary>
        ///     Determine the minimum spanning tree/forest.
        /// </summary>
        /// <param name="set">Disjoint set needed for set operations.</param>
        /// <param name="nodes">List of nodes in disjoint set associated with each node.</param>
        /// <param name="edgeWeights">Weights of each edge.</param>
        /// <param name="connections">Nodes associated with each item in the <paramref name="edgeWeights"/> parameter.</param>
        /// <returns>Array of edges in the minimum spanning tree/forest.</returns>
        private static (int, int)[] Solve(DisjointSet<int> set, Node<int>[] nodes, float[] edgeWeights, (int, int)[] connections)
        {
            var edges = new List<(int, int)>();

            Array.Sort(edgeWeights, connections);

            foreach (var (node1, node2) in connections)
            {
                if (set.FindSet(nodes[node1]) != set.FindSet(nodes[node2]))
                {
                    set.UnionSet(nodes[node1], nodes[node2]);
                    edges.Add((node1, node2));
                }
            }

            return edges.ToArray();
        }
    }
}
using System;

namespace Algorithms.Other
{
    public static class GeoLocation
    {
        private const double EarthRadiusKm = 6371.01d;

        /// <summary>
        ///     Calculates spherical distance between 2 points given their latitude, longitude coordinates.
        ///     https://www.movable-type.co.uk/scripts/latlong.html.
        /// </summary>
        /// <param name="lat1">Latitude of point A.</param>
        /// <param name="lng1">Longitude of point A.</param>
        /// <param name="lat2">Latitude of point B.</param>
        /// <param name="lng2">Longitude of point B.</param>
        /// <returns>Spherical distance between A and B.</returns>
        public static double CalculateDistanceFromLatLng(double lat1, double lng1, double lat2, double lng2)
        {
            var pi180 = Math.PI / 180d;
            var lat1Radian = lat1 * pi180;
            var lng1Radian = lng1 * pi180;
            var lat2Radian = lat2 * pi180;
            var lng2Radian = lng2 * pi180;

            var diffLat = lat2Radian - lat1Radian;
            var diffLng = lng2Radian - lng1Radian;

            var haversine =
                Math.Sin(diffLat / 2) * Math.Sin(diffLat / 2)
                + Math.Cos(lat1Radian) * Math.Cos(lat2Radian) * Math.Sin(diffLng / 2) * Math.Sin(diffLng / 2);
            var distance = EarthRadiusKm * (2d * Math.Atan2(Math.Sqrt(haversine), Math.Sqrt(1 - haversine)));

            return distance * 1000; // Convert from km -> m
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Other
{
    /// <summary>
    ///     TODO.
    /// </summary>
    public static class SieveOfEratosthenes
    {
        /// <summary>
        ///     TODO.
        /// </summary>
        /// <param name="count">TODO. 2.</param>
        /// <returns>TODO. 3.</returns>
        public static List<BigInteger> GetPrimeNumbers(int count)
        {
            var output = new List<BigInteger>();
            for (BigInteger n = 2; output.Count < count; n++)
            {
                if (output.All(x => n % x != 0))
                {
                    output.Add(n);
                }
            }

            return output;
        }
    }
}
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Numerics;

namespace Algorithms.Other
{
    /// <summary>
    /// Flood fill, also called seed fill, is an algorithm that determines and
    /// alters the area connected to a given node in a multi-dimensional array with
    /// some matching attribute. It is used in the "bucket" fill tool of paint
    /// programs to fill connected, similarly-colored areas with a different color.
    /// (description adapted from https://en.wikipedia.org/wiki/Flood_fill)
    /// (see also: https://www.techiedelight.com/flood-fill-algorithm/).
    /// </summary>
    public static class FloodFill
    {
        private static readonly List<(int xOffset, int yOffset)> Neighbors = new() { (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1) };

        /// <summary>
        /// Implements the flood fill algorithm through a breadth-first approach using a queue.
        /// </summary>
        /// <param name="bitmap">The bitmap to which the algorithm is applied.</param>
        /// <param name="location">The start location on the bitmap.</param>
        /// <param name="targetColor">The old color to be replaced.</param>
        /// <param name="replacementColor">The new color to replace the old one.</param>
        public static void BreadthFirstSearch(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor)
        {
            if (location.x < 0 || location.x >= bitmap.Width || location.y < 0 || location.y >= bitmap.Height)
            {
                throw new ArgumentOutOfRangeException(nameof(location), $"{nameof(location)} should point to a pixel within the bitmap");
            }

            var queue = new List<(int x, int y)>();
            queue.Add(location);

            while (queue.Count > 0)
            {
                BreadthFirstFill(bitmap, location, targetColor, replacementColor, queue);
            }
        }

        /// <summary>
        /// Implements the flood fill algorithm through a depth-first approach through recursion.
        /// </summary>
        /// <param name="bitmap">The bitmap to which the algorithm is applied.</param>
        /// <param name="location">The start location on the bitmap.</param>
        /// <param name="targetColor">The old color to be replaced.</param>
        /// <param name="replacementColor">The new color to replace the old one.</param>
        public static void DepthFirstSearch(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor)
        {
            if (location.x < 0 || location.x >= bitmap.Width || location.y < 0 || location.y >= bitmap.Height)
            {
                throw new ArgumentOutOfRangeException(nameof(location), $"{nameof(location)} should point to a pixel within the bitmap");
            }

            DepthFirstFill(bitmap, location, targetColor, replacementColor);
        }

        private static void BreadthFirstFill(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor, List<(int x, int y)> queue)
        {
            (int x, int y) currentLocation = queue[0];
            queue.RemoveAt(0);

            if (bitmap.GetPixel(currentLocation.x, currentLocation.y) == targetColor)
            {
                bitmap.SetPixel(currentLocation.x, currentLocation.y, replacementColor);

                for (int i = 0; i < Neighbors.Count; i++)
                {
                    int x = currentLocation.x + Neighbors[i].xOffset;
                    int y = currentLocation.y + Neighbors[i].yOffset;
                    if (x >= 0 && x < bitmap.Width && y >= 0 && y < bitmap.Height)
                    {
                        queue.Add((x, y));
                    }
                }
            }
        }

        private static void DepthFirstFill(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor)
        {
            if (bitmap.GetPixel(location.x, location.y) == targetColor)
            {
                bitmap.SetPixel(location.x, location.y, replacementColor);

                for (int i = 0; i < Neighbors.Count; i++)
                {
                    int x = location.x + Neighbors[i].xOffset;
                    int y = location.y + Neighbors[i].yOffset;
                    if (x >= 0 && x < bitmap.Width && y >= 0 && y < bitmap.Height)
                    {
                        DepthFirstFill(bitmap, (x, y), targetColor, replacementColor);
                    }
                }
            }
        }
    }
}
using System.Text;

namespace Algorithms.Other
{
    /// <summary>
    ///     Manually converts an integer of certain size to a string of the binary representation.
    /// </summary>
    public static class Int2Binary
    {
        /// <summary>
        ///     Returns string of the binary representation of given Int.
        /// </summary>
        /// <param name="input">Number to be converted.</param>
        /// <returns>Binary representation of input.</returns>
        public static string Int2Bin(ushort input)
        {
            ushort msb = ushort.MaxValue / 2 + 1;
            var output = new StringBuilder();
            for (var i = 0; i < 16; i++)
            {
                if (input >= msb)
                {
                    output.Append("1");
                    input -= msb;
                    msb /= 2;
                }
                else
                {
                    output.Append("0");
                    msb /= 2;
                }
            }

            return output.ToString();
        }

        /// <summary>
        ///     Returns string of the binary representation of given Int.
        /// </summary>
        /// <param name="input">Number to be converted.</param>
        /// <returns>Binary representation of input.</returns>
        public static string Int2Bin(uint input)
        {
            var msb = uint.MaxValue / 2 + 1;
            var output = new StringBuilder();
            for (var i = 0; i < 32; i++)
            {
                if (input >= msb)
                {
                    output.Append("1");
                    input -= msb;
                    msb /= 2;
                }
                else
                {
                    output.Append("0");
                    msb /= 2;
                }
            }

            return output.ToString();
        }

        /// <summary>
        ///     Returns string of the binary representation of given Int.
        /// </summary>
        /// <param name="input">Number to be converted.</param>
        /// <returns>Binary representation of input.</returns>
        public static string Int2Bin(ulong input)
        {
            var msb = ulong.MaxValue / 2 + 1;
            var output = new StringBuilder();
            for (var i = 0; i < 64; i++)
            {
                if (input >= msb)
                {
                    output.Append("1");
                    input -= msb;
                    msb /= 2;
                }
                else
                {
                    output.Append("0");
                    msb /= 2;
                }
            }

            return output.ToString();
        }
    }
}
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Numerics;

namespace Algorithms.Other
{
    /// <summary>
    ///     The Koch snowflake is a fractal curve and one of the earliest fractals to
    ///     have been described. The Koch snowflake can be built up iteratively, in a
    ///     sequence of stages. The first stage is an equilateral triangle, and each
    ///     successive stage is formed by adding outward bends to each side of the
    ///     previous stage, making smaller equilateral triangles.
    ///     This can be achieved through the following steps for each line:
    ///     1. divide the line segment into three segments of equal length.
    ///     2. draw an equilateral triangle that has the middle segment from step 1
    ///     as its base and points outward.
    ///     3. remove the line segment that is the base of the triangle from step 2.
    ///     (description adapted from https://en.wikipedia.org/wiki/Koch_snowflake )
    ///     (for a more detailed explanation and an implementation in the
    ///     Processing language, see  https://natureofcode.com/book/chapter-8-fractals/
    ///     #84-the-koch-curve-and-the-arraylist-technique ).
    /// </summary>
    public static class KochSnowflake
    {
        /// <summary>
        ///     Go through the number of iterations determined by the argument "steps".
        ///     Be careful with high values (above 5) since the time to calculate increases
        ///     exponentially.
        /// </summary>
        /// <param name="initialVectors">
        ///     The vectors composing the shape to which
        ///     the algorithm is applied.
        /// </param>
        /// <param name="steps">The number of iterations.</param>
        /// <returns>The transformed vectors after the iteration-steps.</returns>
        public static List<Vector2> Iterate(List<Vector2> initialVectors, int steps = 5)
        {
            List<Vector2> vectors = initialVectors;
            for (var i = 0; i < steps; i++)
            {
                vectors = IterationStep(vectors);
            }

            return vectors;
        }

        /// <summary>
        ///     Method to render the Koch snowflake to a bitmap. To save the
        ///     bitmap the command 'GetKochSnowflake().Save("KochSnowflake.png")' can be used.
        /// </summary>
        /// <param name="bitmapWidth">The width of the rendered bitmap.</param>
        /// <param name="steps">The number of iterations.</param>
        /// <returns>The bitmap of the rendered Koch snowflake.</returns>
        public static Bitmap GetKochSnowflake(
            int bitmapWidth = 600,
            int steps = 5)
        {
            if (bitmapWidth <= 0)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(bitmapWidth),
                    $"{nameof(bitmapWidth)} should be greater than zero");
            }

            var offsetX = bitmapWidth / 10f;
            var offsetY = bitmapWidth / 3.7f;
            var vector1 = new Vector2(offsetX, offsetY);
            var vector2 = new Vector2(bitmapWidth / 2, (float)Math.Sin(Math.PI / 3) * bitmapWidth * 0.8f + offsetY);
            var vector3 = new Vector2(bitmapWidth - offsetX, offsetY);
            List<Vector2> initialVectors = new() { vector1, vector2, vector3, vector1 };
            List<Vector2> vectors = Iterate(initialVectors, steps);
            return GetBitmap(vectors, bitmapWidth, bitmapWidth);
        }

        /// <summary>
        ///     Loops through each pair of adjacent vectors. Each line between two adjacent
        ///     vectors is divided into 4 segments by adding 3 additional vectors in-between
        ///     the original two vectors. The vector in the middle is constructed through a
        ///     60 degree rotation so it is bent outwards.
        /// </summary>
        /// <param name="vectors">
        ///     The vectors composing the shape to which
        ///     the algorithm is applied.
        /// </param>
        /// <returns>The transformed vectors after the iteration-step.</returns>
        private static List<Vector2> IterationStep(List<Vector2> vectors)
        {
            List<Vector2> newVectors = new();
            for (var i = 0; i < vectors.Count - 1; i++)
            {
                var startVector = vectors[i];
                var endVector = vectors[i + 1];
                newVectors.Add(startVector);
                var differenceVector = endVector - startVector;
                newVectors.Add(startVector + differenceVector / 3);
                newVectors.Add(startVector + differenceVector / 3 + Rotate(differenceVector / 3, 60));
                newVectors.Add(startVector + differenceVector * 2 / 3);
            }

            newVectors.Add(vectors[^1]);
            return newVectors;
        }

        /// <summary>
        ///     Standard rotation of a 2D vector with a rotation matrix
        ///     (see https://en.wikipedia.org/wiki/Rotation_matrix ).
        /// </summary>
        /// <param name="vector">The vector to be rotated.</param>
        /// <param name="angleInDegrees">The angle by which to rotate the vector.</param>
        /// <returns>The rotated vector.</returns>
        private static Vector2 Rotate(Vector2 vector, float angleInDegrees)
        {
            var radians = angleInDegrees * (float)Math.PI / 180;
            var ca = (float)Math.Cos(radians);
            var sa = (float)Math.Sin(radians);
            return new Vector2(ca * vector.X - sa * vector.Y, sa * vector.X + ca * vector.Y);
        }

        /// <summary>
        ///     Utility-method to render the Koch snowflake to a bitmap.
        /// </summary>
        /// <param name="vectors">The vectors defining the edges to be rendered.</param>
        /// <param name="bitmapWidth">The width of the rendered bitmap.</param>
        /// <param name="bitmapHeight">The height of the rendered bitmap.</param>
        /// <returns>The bitmap of the rendered edges.</returns>
        private static Bitmap GetBitmap(
            List<Vector2> vectors,
            int bitmapWidth,
            int bitmapHeight)
        {
            Bitmap bitmap = new(bitmapWidth, bitmapHeight);

            using (Graphics graphics = Graphics.FromImage(bitmap))
            {
                // Set the background white
                var imageSize = new Rectangle(0, 0, bitmapWidth, bitmapHeight);
                graphics.FillRectangle(Brushes.White, imageSize);

                // Draw the edges
                for (var i = 0; i < vectors.Count - 1; i++)
                {
                    Pen blackPen = new(Color.Black, 1);

                    var x1 = vectors[i].X;
                    var y1 = vectors[i].Y;
                    var x2 = vectors[i + 1].X;
                    var y2 = vectors[i + 1].Y;

                    graphics.DrawLine(blackPen, x1, y1, x2, y2);
                }
            }

            return bitmap;
        }
    }
}
using System;
using System.Drawing;

namespace Algorithms.Other
{
    /// <summary>
    ///     The Mandelbrot set is the set of complex numbers "c" for which the series
    ///     "z_(n+1) = z_n * z_n + c" does not diverge, i.e. remains bounded. Thus, a
    ///     complex number "c" is a member of the Mandelbrot set if, when starting with
    ///     "z_0 = 0" and applying the iteration repeatedly, the absolute value of
    ///     "z_n" remains bounded for all "n > 0". Complex numbers can be written as
    ///     "a + b*i": "a" is the real component, usually drawn on the x-axis, and "b*i"
    ///     is the imaginary component, usually drawn on the y-axis. Most visualizations
    ///     of the Mandelbrot set use a color-coding to indicate after how many steps in
    ///     the series the numbers outside the set cross the divergence threshold.
    ///     Images of the Mandelbrot set exhibit an elaborate and infinitely
    ///     complicated boundary that reveals progressively ever-finer recursive detail
    ///     at increasing magnifications, making the boundary of the Mandelbrot set a
    ///     fractal curve.
    ///     (description adapted from https://en.wikipedia.org/wiki/Mandelbrot_set)
    ///     (see also https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set).
    /// </summary>
    public static class Mandelbrot
    {
        /// <summary>
        ///     Method to generate the bitmap of the Mandelbrot set. Two types of coordinates
        ///     are used: bitmap-coordinates that refer to the pixels and figure-coordinates
        ///     that refer to the complex numbers inside and outside the Mandelbrot set. The
        ///     figure-coordinates in the arguments of this method determine which section
        ///     of the Mandelbrot set is viewed. The main area of the Mandelbrot set is
        ///     roughly between "-1.5 &lt; x &lt; 0.5" and "-1 &lt; y &lt; 1" in the figure-coordinates.
        ///     To save the bitmap the command 'GetBitmap().Save("Mandelbrot.png")' can be used.
        /// </summary>
        /// <param name="bitmapWidth">The width of the rendered bitmap.</param>
        /// <param name="bitmapHeight">The height of the rendered bitmap.</param>
        /// <param name="figureCenterX">The x-coordinate of the center of the figure.</param>
        /// <param name="figureCenterY">The y-coordinate of the center of the figure.</param>
        /// <param name="figureWidth">The width of the figure.</param>
        /// <param name="maxStep">Maximum number of steps to check for divergent behavior.</param>
        /// <param name="useDistanceColorCoding">Render in color or black and white.</param>
        /// <returns>The bitmap of the rendered Mandelbrot set.</returns>
        public static Bitmap GetBitmap(
            int bitmapWidth = 800,
            int bitmapHeight = 600,
            double figureCenterX = -0.6,
            double figureCenterY = 0,
            double figureWidth = 3.2,
            int maxStep = 50,
            bool useDistanceColorCoding = true)
        {
            if (bitmapWidth <= 0)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(bitmapWidth),
                    $"{nameof(bitmapWidth)} should be greater than zero");
            }

            if (bitmapHeight <= 0)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(bitmapHeight),
                    $"{nameof(bitmapHeight)} should be greater than zero");
            }

            if (maxStep <= 0)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(maxStep),
                    $"{nameof(maxStep)} should be greater than zero");
            }

            var bitmap = new Bitmap(bitmapWidth, bitmapHeight);
            var figureHeight = figureWidth / bitmapWidth * bitmapHeight;

            // loop through the bitmap-coordinates
            for (var bitmapX = 0; bitmapX < bitmapWidth; bitmapX++)
            {
                for (var bitmapY = 0; bitmapY < bitmapHeight; bitmapY++)
                {
                    // determine the figure-coordinates based on the bitmap-coordinates
                    var figureX = figureCenterX + ((double)bitmapX / bitmapWidth - 0.5) * figureWidth;
                    var figureY = figureCenterY + ((double)bitmapY / bitmapHeight - 0.5) * figureHeight;

                    var distance = GetDistance(figureX, figureY, maxStep);

                    // color the corresponding pixel based on the selected coloring-function
                    bitmap.SetPixel(
                        bitmapX,
                        bitmapY,
                        useDistanceColorCoding ? ColorCodedColorMap(distance) : BlackAndWhiteColorMap(distance));
                }
            }

            return bitmap;
        }

        /// <summary>
        ///     Black and white color-coding that ignores the relative distance. The Mandelbrot
        ///     set is black, everything else is white.
        /// </summary>
        /// <param name="distance">Distance until divergence threshold.</param>
        /// <returns>The color corresponding to the distance.</returns>
        private static Color BlackAndWhiteColorMap(double distance) =>
            distance >= 1
                ? Color.FromArgb(255, 0, 0, 0)
                : Color.FromArgb(255, 255, 255, 255);

        /// <summary>
        ///     Color-coding taking the relative distance into account. The Mandelbrot set
        ///     is black.
        /// </summary>
        /// <param name="distance">Distance until divergence threshold.</param>
        /// <returns>The color corresponding to the distance.</returns>
        private static Color ColorCodedColorMap(double distance)
        {
            if (distance >= 1)
            {
                return Color.FromArgb(255, 0, 0, 0);
            }

            // simplified transformation of HSV to RGB
            // distance determines hue
            var hue = 360 * distance;
            double saturation = 1;
            double val = 255;
            var hi = (int)Math.Floor(hue / 60) % 6;
            var f = hue / 60 - Math.Floor(hue / 60);

            var v = (int)val;
            var p = 0;
            var q = (int)(val * (1 - f * saturation));
            var t = (int)(val * (1 - (1 - f) * saturation));

            switch (hi)
            {
                case 0: return Color.FromArgb(255, v, t, p);
                case 1: return Color.FromArgb(255, q, v, p);
                case 2: return Color.FromArgb(255, p, v, t);
                case 3: return Color.FromArgb(255, p, q, v);
                case 4: return Color.FromArgb(255, t, p, v);
                default: return Color.FromArgb(255, v, p, q);
            }
        }

        /// <summary>
        ///     Return the relative distance (ratio of steps taken to maxStep) after which the complex number
        ///     constituted by this x-y-pair diverges. Members of the Mandelbrot set do not
        ///     diverge so their distance is 1.
        /// </summary>
        /// <param name="figureX">The x-coordinate within the figure.</param>
        /// <param name="figureY">The y-coordinate within the figure.</param>
        /// <param name="maxStep">Maximum number of steps to check for divergent behavior.</param>
        /// <returns>The relative distance as the ratio of steps taken to maxStep.</returns>
        private static double GetDistance(double figureX, double figureY, int maxStep)
        {
            var a = figureX;
            var b = figureY;
            var currentStep = 0;
            for (var step = 0; step < maxStep; step++)
            {
                currentStep = step;
                var aNew = a * a - b * b + figureX;
                b = 2 * a * b + figureY;
                a = aNew;

                // divergence happens for all complex number with an absolute value
                // greater than 4 (= divergence threshold)
                if (a * a + b * b > 4)
                {
                    break;
                }
            }

            return (double)currentStep / (maxStep - 1);
        }
    }
}
using System;
using System.Numerics;

namespace Algorithms.Other
{
    /// <summary>
    ///     Fermat's prime tester https://en.wikipedia.org/wiki/Fermat_primality_test.
    /// </summary>
    public static class FermatPrimeChecker
    {
        /// <summary>
        ///     Checks if input number is a probable prime.
        /// </summary>
        /// <param name="numberToTest">Input number.</param>
        /// <param name="timesToCheck">Number of times to check.</param>
        /// <returns>True if is a prime; False otherwise.</returns>
        public static bool IsPrime(int numberToTest, int timesToCheck)
        {
            // You have to use BigInteger for two reasons:
            //   1. The pow operation between two int numbers usually overflows an int
            //   2. The pow and modular operation is very optimized
            var numberToTestBigInteger = new BigInteger(numberToTest);
            var exponentBigInteger = new BigInteger(numberToTest - 1);

            // Create a random number generator using the current time as seed
            var r = new Random(default(DateTime).Millisecond);

            var iterator = 1;
            var prime = true;

            while (iterator < timesToCheck && prime)
            {
                var randomNumber = r.Next(1, numberToTest);
                var randomNumberBigInteger = new BigInteger(randomNumber);
                if (BigInteger.ModPow(randomNumberBigInteger, exponentBigInteger, numberToTestBigInteger) != 1)
                {
                    prime = false;
                }

                iterator++;
            }

            return prime;
        }
    }
}
using System;

namespace Algorithms.Other
{
    /// <summary>
    ///     The RGB color model is an additive color model in which red, green, and
    ///     blue light are added together in various ways to reproduce a broad array of
    ///     colors. The name of the model comes from the initials of the three additive
    ///     primary colors, red, green, and blue. Meanwhile, the HSV representation
    ///     models how colors appear under light. In it, colors are represented using
    ///     three components: hue, saturation and (brightness-)value. This class
    ///     provides methods for converting colors from one representation to the other.
    ///     (description adapted from https://en.wikipedia.org/wiki/RGB_color_model and
    ///     https://en.wikipedia.org/wiki/HSL_and_HSV).
    /// </summary>
    public static class RgbHsvConversion
    {
        /// <summary>
        ///     Conversion from the HSV-representation to the RGB-representation.
        /// </summary>
        /// <param name="hue">Hue of the color.</param>
        /// <param name="saturation">Saturation of the color.</param>
        /// <param name="value">Brightness-value of the color.</param>
        /// <returns>The tuple of RGB-components.</returns>
        public static (byte red, byte green, byte blue) HsvToRgb(
            double hue,
            double saturation,
            double value)
        {
            if (hue < 0 || hue > 360)
            {
                throw new ArgumentOutOfRangeException(nameof(hue), $"{nameof(hue)} should be between 0 and 360");
            }

            if (saturation < 0 || saturation > 1)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(saturation),
                    $"{nameof(saturation)} should be between 0 and 1");
            }

            if (value < 0 || value > 1)
            {
                throw new ArgumentOutOfRangeException(nameof(value), $"{nameof(value)} should be between 0 and 1");
            }

            var chroma = value * saturation;
            var hueSection = hue / 60;
            var secondLargestComponent = chroma * (1 - Math.Abs(hueSection % 2 - 1));
            var matchValue = value - chroma;

            return GetRgbBySection(hueSection, chroma, matchValue, secondLargestComponent);
        }

        /// <summary>
        ///     Conversion from the RGB-representation to the HSV-representation.
        /// </summary>
        /// <param name="red">Red-component of the color.</param>
        /// <param name="green">Green-component of the color.</param>
        /// <param name="blue">Blue-component of the color.</param>
        /// <returns>The tuple of HSV-components.</returns>
        public static (double hue, double saturation, double value) RgbToHsv(
            byte red,
            byte green,
            byte blue)
        {
            var dRed = (double)red / 255;
            var dGreen = (double)green / 255;
            var dBlue = (double)blue / 255;
            var value = Math.Max(Math.Max(dRed, dGreen), dBlue);
            var chroma = value - Math.Min(Math.Min(dRed, dGreen), dBlue);
            var saturation = value.Equals(0) ? 0 : chroma / value;
            double hue;

            if (chroma.Equals(0))
            {
                hue = 0;
            }
            else if (value.Equals(dRed))
            {
                hue = 60 * (0 + (dGreen - dBlue) / chroma);
            }
            else if (value.Equals(dGreen))
            {
                hue = 60 * (2 + (dBlue - dRed) / chroma);
            }
            else
            {
                hue = 60 * (4 + (dRed - dGreen) / chroma);
            }

            hue = (hue + 360) % 360;

            return (hue, saturation, value);
        }

        private static (byte red, byte green, byte blue) GetRgbBySection(
            double hueSection,
            double chroma,
            double matchValue,
            double secondLargestComponent)
        {
            byte red;
            byte green;
            byte blue;

            if (hueSection >= 0 && hueSection <= 1)
            {
                red = ConvertToByte(chroma + matchValue);
                green = ConvertToByte(secondLargestComponent + matchValue);
                blue = ConvertToByte(matchValue);
            }
            else if (hueSection > 1 && hueSection <= 2)
            {
                red = ConvertToByte(secondLargestComponent + matchValue);
                green = ConvertToByte(chroma + matchValue);
                blue = ConvertToByte(matchValue);
            }
            else if (hueSection > 2 && hueSection <= 3)
            {
                red = ConvertToByte(matchValue);
                green = ConvertToByte(chroma + matchValue);
                blue = ConvertToByte(secondLargestComponent + matchValue);
            }
            else if (hueSection > 3 && hueSection <= 4)
            {
                red = ConvertToByte(matchValue);
                green = ConvertToByte(secondLargestComponent + matchValue);
                blue = ConvertToByte(chroma + matchValue);
            }
            else if (hueSection > 4 && hueSection <= 5)
            {
                red = ConvertToByte(secondLargestComponent + matchValue);
                green = ConvertToByte(matchValue);
                blue = ConvertToByte(chroma + matchValue);
            }
            else
            {
                red = ConvertToByte(chroma + matchValue);
                green = ConvertToByte(matchValue);
                blue = ConvertToByte(secondLargestComponent + matchValue);
            }

            return (red, green, blue);
        }

        private static byte ConvertToByte(double input) => (byte)Math.Round(255 * input);
    }
}
using System;

namespace Algorithms.Other
{
    /// <summary>
    ///     Luhn algorithm is a simple
    ///     checksum formula used to validate
    ///     a variety of identification numbers,
    ///     such as credit card numbers.
    ///     More information on the link:
    ///     https://en.wikipedia.org/wiki/Luhn_algorithm.
    /// </summary>
    public static class Luhn
    {
        /// <summary>
        ///     Checking the validity of a sequence of numbers.
        /// </summary>
        /// <param name="number">The number that will be checked for validity.</param>
        /// <returns>
        ///     True: Number is valid.
        ///     False: Number isn`t valid.
        /// </returns>
        public static bool Validate(string number) => GetSum(number) % 10 == 0;

        /// <summary>
        ///     This algorithm only finds one number.
        ///     In place of the unknown digit, put "x".
        /// </summary>
        /// <param name="number">The number in which to find the missing digit.</param>
        /// <returns>Missing digit.</returns>
        public static int GetLostNum(string number)
        {
            var lostIndex = number.Length - 1 - number.LastIndexOf("x", StringComparison.CurrentCultureIgnoreCase);
            var lostNum = GetSum(number.Replace("x", "0", StringComparison.CurrentCultureIgnoreCase)) * 9 % 10;

            // Case 1: If the index of the lost digit is even.
            if (lostIndex % 2 == 0)
            {
                return lostNum;
            }

            var tempLostNum = lostNum / 2;

            // Case 2: if the index of the lost digit isn`t even and that number <= 4.
            // Case 3: if the index of the lost digit isn`t even and that number > 4.
            return Validate(number.Replace("x", tempLostNum.ToString())) ? tempLostNum : (lostNum + 9) / 2;
        }

        /// <summary>
        ///     Computes the sum found by the algorithm.
        /// </summary>
        /// <param name="number">The number for which the sum will be found.</param>
        /// <returns>Sum.</returns>
        private static int GetSum(string number)
        {
            var sum = 0;
            for (var i = 0; i < number.Length; i++)
            {
                var d = number[i] - '0';
                d = (i + number.Length) % 2 == 0
                    ? 2 * d
                    : d;
                if (d > 9)
                {
                    d -= 9;
                }

                sum += d;
            }

            return sum;
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Problems.StableMarriage
{
    public static class GaleShapley
    {
        /// <summary>
        ///     Finds a stable matching between two equal sets of elements (fills EngagedTo properties).
        ///     time complexity: O(n^2), where n - array size.
        ///     Guarantees:
        ///     - Everyone is matched
        ///     - Matches are stable (there is no better accepter, for any given proposer, which would accept a new match).
        ///     Presented and proven by David Gale and Lloyd Shapley in 1962.
        /// </summary>
        public static void Match(Proposer[] proposers, Accepter[] accepters)
        {
            if (proposers.Length != accepters.Length)
            {
                throw new ArgumentException("Collections must have equal count");
            }

            while (proposers.Any(m => !IsEngaged(m)))
            {
                DoSingleMatchingRound(proposers.Where(m => !IsEngaged(m)));
            }
        }

        private static bool IsEngaged(Proposer proposer) => proposer.EngagedTo is not null;

        private static void DoSingleMatchingRound(IEnumerable<Proposer> proposers)
        {
            foreach (var newProposer in proposers)
            {
                var accepter = newProposer.PreferenceOrder.First!.Value;

                if (accepter.EngagedTo is null)
                {
                    Engage(newProposer, accepter);
                }
                else
                {
                    if (accepter.PrefersOverCurrent(newProposer))
                    {
                        Free(accepter.EngagedTo);
                        Engage(newProposer, accepter);
                    }
                }

                newProposer.PreferenceOrder.RemoveFirst();
            }
        }

        private static void Free(Proposer proposer)
        {
            proposer.EngagedTo = null;
        }

        private static void Engage(Proposer proposer, Accepter accepter)
        {
            proposer.EngagedTo = accepter;
            accepter.EngagedTo = proposer;
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Problems.StableMarriage
{
    public class Accepter
    {
        public Proposer? EngagedTo { get; set; }

        public List<Proposer> PreferenceOrder { get; set; } = new();

        public bool PrefersOverCurrent(Proposer newProposer) =>
            EngagedTo is null ||
            PreferenceOrder.IndexOf(newProposer) < PreferenceOrder.IndexOf(EngagedTo);
    }
}
using System.Collections.Generic;

namespace Algorithms.Problems.StableMarriage
{
    public class Proposer
    {
        public Accepter? EngagedTo { get; set; }

        public LinkedList<Accepter> PreferenceOrder { get; set; } = new();
    }
}
using System;
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Problems.CoinChange
{
    public static class DynamicCoinChangeSolver
    {
        /// <summary>
        /// Generates an array of changes for current coin.
        /// For instance, having coin C = 6 and array A = [1,3,4] it returns an array R = [2,3,5].
        /// Because, 6 - 4 = 2, 6 - 3 = 3, 6 - 1 = 5.
        /// </summary>
        /// <param name="coin">The value of the coin to be exchanged.</param>
        /// <param name="coins">An array of available coins.</param>
        /// <returns>Array of changes of current coins by available coins.</returns>
        public static int[] GenerateSingleCoinChanges(int coin, int[] coins)
        {
            ValidateCoin(coin);
            ValidateCoinsArray(coins);

            var coinsArrayCopy = new int[coins.Length];

            Array.Copy(coins, coinsArrayCopy, coins.Length);
            Array.Sort(coinsArrayCopy);
            Array.Reverse(coinsArrayCopy);

            var list = new List<int>();

            foreach (var item in coinsArrayCopy)
            {
                if (item > coin)
                {
                    continue;
                }

                var difference = coin - item;

                list.Add(difference);
            }

            var result = list.ToArray();

            return result;
        }

        /// <summary>
        /// Given a positive integer N, such as coin.
        /// Generates a change dictionary for all values [1,N].
        /// Used in so-called backward induction in search of the minimum exchange.
        /// </summary>
        /// <param name="coin">The value of coin.</param>
        /// <param name="coins">Array of available coins.</param>
        /// <returns>Change dictionary for all values [1,N], where N is the coin.</returns>
        public static Dictionary<int, int[]> GenerateChangesDictionary(int coin, int[] coins)
        {
            var dict = new Dictionary<int, int[]>();
            var currentCoin = 1;

            while (currentCoin <= coin)
            {
                var changeArray = GenerateSingleCoinChanges(currentCoin, coins);
                dict[currentCoin] = changeArray;
                currentCoin++;
            }

            return dict;
        }

        /// <summary>
        /// Gets a next coin value, such that changes array contains the minimal change overall possible changes.
        /// For example, having coin N = 6 and A = [1,3,4] coins array.
        /// The minimum next coin for 6 will be 3, because changes of 3 by A = [1,3,4] contains 0, the minimal change.
        /// </summary>
        /// <param name="coin">Coin to be exchanged.</param>
        /// <param name="exchanges">Dictionary of exchanges for [1, coin].</param>
        /// <returns>Index of the next coin with minimal exchange.</returns>
        public static int GetMinimalNextCoin(int coin, Dictionary<int, int[]> exchanges)
        {
            var nextCoin = int.MaxValue;
            var minChange = int.MaxValue;

            var coinChanges = exchanges[coin];

            foreach (var change in coinChanges)
            {
                if (change == 0)
                {
                    return 0;
                }

                var currentChange = exchanges[change];
                var min = currentChange.Min();

                var minIsLesser = min < minChange;

                if (minIsLesser)
                {
                    nextCoin = change;
                    minChange = min;
                }
            }

            return nextCoin;
        }

        /// <summary>
        /// Performs a coin change such that an amount of coins is minimal.
        /// </summary>
        /// <param name="coin">The value of coin to be exchanged.</param>
        /// <param name="coins">An array of available coins.</param>
        /// <returns>Array of exchanges.</returns>
        public static int[] MakeCoinChangeDynamic(int coin, int[] coins)
        {
            var changesTable = GenerateChangesDictionary(coin, coins);
            var list = new List<int>();

            var currentCoin = coin;
            var nextCoin = int.MaxValue;

            while (nextCoin != 0)
            {
                nextCoin = GetMinimalNextCoin(currentCoin, changesTable);
                var difference = currentCoin - nextCoin;
                list.Add(difference);
                currentCoin = nextCoin;
            }

            var result = list.ToArray();

            return result;
        }

        private static void ValidateCoin(int coin)
        {
            if (coin <= 0)
            {
                throw new InvalidOperationException($"The coin cannot be lesser or equal to zero {nameof(coin)}.");
            }
        }

        private static void ValidateCoinsArray(int[] coinsArray)
        {
            var coinsAsArray = coinsArray.ToArray();

            if (coinsAsArray.Length == 0)
            {
                throw new InvalidOperationException($"Coins array cannot be empty {nameof(coinsAsArray)}.");
            }

            var coinsContainOne = coinsAsArray.Any(x => x == 1);

            if (!coinsContainOne)
            {
                throw new InvalidOperationException($"Coins array must contain coin 1 {nameof(coinsAsArray)}.");
            }

            var containsNonPositive = coinsAsArray.Any(x => x <= 0);

            if (containsNonPositive)
            {
                throw new InvalidOperationException(
                    $"{nameof(coinsAsArray)} cannot contain numbers less than or equal to zero");
            }

            var containsDuplicates = coinsAsArray.GroupBy(x => x).Any(g => g.Count() > 1);

            if (containsDuplicates)
            {
                throw new InvalidOperationException($"Coins array cannot contain duplicates {nameof(coinsAsArray)}.");
            }
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Problems.NQueens
{
    public class BacktrackingNQueensSolver
    {
        /// <summary>
        ///     Solves N-Queen Problem given a n dimension chessboard and using backtracking with recursion algorithm.
        ///     If we find a dead-end within or current solution we go back and try another position for queen.
        /// </summary>
        /// <param name="n">Number of rows.</param>
        /// <returns>All solutions.</returns>
        public IEnumerable<bool[,]> BacktrackSolve(int n)
        {
            if (n < 0)
            {
                throw new ArgumentException(nameof(n));
            }

            return BacktrackSolve(new bool[n, n], 0);
        }

        private static IEnumerable<bool[,]> BacktrackSolve(bool[,] board, int col)
        {
            var solutions = col < board.GetLength(0) - 1
                ? HandleIntermediateColumn(board, col)
                : HandleLastColumn(board);
            return solutions;
        }

        private static IEnumerable<bool[,]> HandleIntermediateColumn(bool[,] board, int col)
        {
            // To start placing queens on possible spaces within the board.
            for (var i = 0; i < board.GetLength(0); i++)
            {
                if (CanPlace(board, i, col))
                {
                    board[i, col] = true;

                    foreach (var solution in BacktrackSolve(board, col + 1))
                    {
                        yield return solution;
                    }

                    board[i, col] = false;
                }
            }
        }

        private static IEnumerable<bool[,]> HandleLastColumn(bool[,] board)
        {
            var n = board.GetLength(0);
            for (var i = 0; i < n; i++)
            {
                if (CanPlace(board, i, n - 1))
                {
                    board[i, n - 1] = true;

                    yield return (bool[,])board.Clone();

                    board[i, n - 1] = false;
                }
            }
        }

        /// <summary>
        ///     Checks whether current queen can be placed in current position,
        ///     outside attacking range of another queen.
        /// </summary>
        /// <param name="board">Source board.</param>
        /// <param name="row">Row coordinate.</param>
        /// <param name="col">Col coordinate.</param>
        /// <returns>true if queen can be placed in given chessboard coordinates; false otherwise.</returns>
        private static bool CanPlace(bool[,] board, int row, int col)
        {
            // To check whether there are any queens on current row.
            for (var i = 0; i < col; i++)
            {
                if (board[row, i])
                {
                    return false;
                }
            }

            // To check diagonal attack top-left range.
            for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
            {
                if (board[i, j])
                {
                    return false;
                }
            }

            // To check diagonal attack bottom-left range.
            for (int i = row + 1, j = col - 1; j >= 0 && i < board.GetLength(0); i++, j--)
            {
                if (board[i, j])
                {
                    return false;
                }
            }

            // Return true if it can use position.
            return true;
        }
    }
}
namespace Algorithms.Sorters.Integer
{
    /// <summary>
    ///     Sorts array of integers without comparing them.
    /// </summary>
    public interface IIntegerSorter
    {
        /// <summary>
        ///     Sorts array in ascending order.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        void Sort(int[] array);
    }
}
using System;
using System.Linq;

namespace Algorithms.Sorters.Integer
{
    /// <summary>
    ///     Counting sort is an algorithm for sorting a collection of objects according to keys that are small integers; that
    ///     is, it is an integer sorting algorithm. It operates by counting the number of objects that have each distinct key
    ///     value, and using arithmetic on those counts to determine the positions of each key value in the output sequence.
    ///     Its running time is linear in the number of items and the difference between the maximum and minimum key values, so
    ///     it is only suitable for direct use in situations where the variation in keys is not significantly greater than the
    ///     number of items. However, it is often used as a subroutine in another sorting algorithm, radix sort, that can
    ///     handle larger keys more efficiently.
    /// </summary>
    public class CountingSorter : IIntegerSorter
    {
        /// <summary>
        ///     <para>
        ///         Sorts input array using counting sort algorithm.
        ///     </para>
        ///     <para>
        ///         Time complexity: O(n+k), where k is the range of the non-negative key values.
        ///     </para>
        ///     <para>
        ///         Space complexity: O(n+k), where k is the range of the non-negative key values.
        ///     </para>
        /// </summary>
        /// <param name="array">Input array.</param>
        public void Sort(int[] array)
        {
            if (array.Length == 0)
            {
                return;
            }

            var max = array.Max();
            var min = array.Min();
            var count = new int[max - min + 1];
            var output = new int[array.Length];
            for (var i = 0; i < array.Length; i++)
            {
                count[array[i] - min]++;
            }

            for (var i = 1; i < count.Length; i++)
            {
                count[i] += count[i - 1];
            }

            for (var i = array.Length - 1; i >= 0; i--)
            {
                output[count[array[i] - min] - 1] = array[i];
                count[array[i] - min]--;
            }

            Array.Copy(output, array, array.Length);
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Sorters.Integer
{
    /// <summary>
    ///     Class that implements bucket sort algorithm.
    /// </summary>
    public class BucketSorter : IIntegerSorter
    {
        private const int NumOfDigitsInBase10 = 10;

        /// <summary>
        ///     Sorts array elements using BucketSort Algorithm.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        public void Sort(int[] array)
        {
            if (array.Length <= 1)
            {
                return;
            }

            // store maximum number of digits in numbers to sort
            var totalDigits = NumberOfDigits(array);

            // bucket array where numbers will be placed
            var buckets = new int[NumOfDigitsInBase10, array.Length + 1];

            // go through all digit places and sort each number
            // according to digit place value
            for (var pass = 1; pass <= totalDigits; pass++)
            {
                DistributeElements(array, buckets, pass); // distribution pass
                CollectElements(array, buckets); // gathering pass

                if (pass != totalDigits)
                {
                    EmptyBucket(buckets); // set size of buckets to 0
                }
            }
        }

        /// <summary>
        ///     Determines the number of digits in the largest number.
        /// </summary>
        /// <param name="array">Input array.</param>
        /// <returns>Number of digits.</returns>
        private static int NumberOfDigits(IEnumerable<int> array) => (int)Math.Floor(Math.Log10(array.Max()) + 1);

        /// <summary>
        ///     To distribute elements into buckets based on specified digit.
        /// </summary>
        /// <param name="data">Input array.</param>
        /// <param name="buckets">Array of buckets.</param>
        /// <param name="digit">Digit.</param>
        private static void DistributeElements(IEnumerable<int> data, int[,] buckets, int digit)
        {
            // determine the divisor used to get specific digit
            var divisor = (int)Math.Pow(10, digit);

            foreach (var element in data)
            {
                // bucketNumber example for hundreds digit:
                // ( 1234 % 1000 ) / 100 --> 2
                var bucketNumber = NumOfDigitsInBase10 * (element % divisor) / divisor;

                // retrieve value in pail[ bucketNumber , 0 ] to
                // determine the location in row to store element
                var elementNumber = ++buckets[bucketNumber, 0]; // location in bucket to place element
                buckets[bucketNumber, elementNumber] = element;
            }
        }

        /// <summary>
        ///     Return elements to original array.
        /// </summary>
        /// <param name="data">Input array.</param>
        /// <param name="buckets">Array of buckets.</param>
        private static void CollectElements(IList<int> data, int[,] buckets)
        {
            var subscript = 0; // initialize location in data

            // loop over buckets
            for (var i = 0; i < NumOfDigitsInBase10; i++)
            {
                // loop over elements in each bucket
                for (var j = 1; j <= buckets[i, 0]; j++)
                {
                    data[subscript++] = buckets[i, j]; // add element to array
                }
            }
        }

        /// <summary>
        ///     Sets size of all buckets to zero.
        /// </summary>
        /// <param name="buckets">Array of buckets.</param>
        private static void EmptyBucket(int[,] buckets)
        {
            for (var i = 0; i < NumOfDigitsInBase10; i++)
            {
                buckets[i, 0] = 0; // set size of bucket to 0
            }
        }
    }
}
namespace Algorithms.Sorters.Integer
{
    /// <summary>
    ///     Radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the
    ///     individual
    ///     digits which share the same significant position and value. A positional notation is required, but because integers
    ///     can represent
    ///     strings of characters (e.g., names or dates) and specially formatted floating point numbers, radix sort is not
    ///     limited to integers.
    /// </summary>
    public class RadixSorter : IIntegerSorter
    {
        /// <summary>
        ///     Sorts array in ascending order.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        public void Sort(int[] array)
        {
            var bits = 4;
            var b = new int[array.Length];
            var rshift = 0;
            for (var mask = ~(-1 << bits); mask != 0; mask <<= bits, rshift += bits)
            {
                var cntarray = new int[1 << bits];
                foreach (var t in array)
                {
                    var key = (t & mask) >> rshift;
                    ++cntarray[key];
                }

                for (var i = 1; i < cntarray.Length; ++i)
                {
                    cntarray[i] += cntarray[i - 1];
                }

                for (var p = array.Length - 1; p >= 0; --p)
                {
                    var key = (array[p] & mask) >> rshift;
                    --cntarray[key];
                    b[cntarray[key]] = array[p];
                }

                var temp = b;
                b = array;
                array = temp;
            }
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Sorts arrays using quicksort (selecting median of three as a pivot).
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public sealed class MedianOfThreeQuickSorter<T> : QuickSorter<T>
    {
        protected override T SelectPivot(T[] array, IComparer<T> comparer, int left, int right)
        {
            var leftPoint = array[left];
            var middlePoint = array[left + (right - left) / 2];
            var rightPoint = array[right];

            return FindMedian(comparer, leftPoint, middlePoint, rightPoint);
        }

        private static T FindMedian(IComparer<T> comparer, T a, T b, T c)
        {
            if (comparer.Compare(a, b) <= 0)
            {
                // a <= b <= c
                if (comparer.Compare(b, c) <= 0)
                {
                    return b;
                }

                // a <= c < b
                if (comparer.Compare(a, c) <= 0)
                {
                    return c;
                }

                // c < a <= b
                return a;
            }

            // a > b >= c
            if (comparer.Compare(b, c) >= 0)
            {
                return b;
            }

            // a >= c > b
            if (comparer.Compare(a, c) >= 0)
            {
                return c;
            }

            // c > a > b
            return a;
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Class that implements pancake sort algorithm.
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public class PancakeSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts array using specified comparer,
        ///     internal, in-place, stable,
        ///     time complexity: O(n^2),
        ///     space complexity: O(1),
        ///     where n - array length.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Compares elements.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            var n = array.Length;

            // Start from the complete array and one by one
            // reduce current size by one
            for (var currSize = n; currSize > 1; --currSize)
            {
                // Find index of the maximum element in
                // array[0..curr_size-1]
                var mi = FindMax(array, currSize, comparer);

                // Move the maximum element to end of current array
                // if it's not already at  the end
                if (mi != currSize - 1)
                {
                    // To move to the end, first move maximum
                    // number to beginning
                    Flip(array, mi);

                    // Now move the maximum number to end by
                    // reversing current array
                    Flip(array, currSize - 1);
                }
            }
        }

        // Reverses array[0..i]
        private void Flip(T[] array, int i)
        {
            T temp;
            var start = 0;
            while (start < i)
            {
                temp = array[start];
                array[start] = array[i];
                array[i] = temp;
                start++;
                i--;
            }
        }

        // Returns index of the maximum element
        // in array[0..n-1]
        private int FindMax(T[] array, int n, IComparer<T> comparer)
        {
            var mi = 0;
            for (var i = 0; i < n; i++)
            {
                if (comparer.Compare(array[i], array[mi]) == 1)
                {
                    mi = i;
                }
            }

            return mi;
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Class that implements selection sort algorithm.
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public class SelectionSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts array using specified comparer,
        ///     internal, in-place, stable,
        ///     time complexity: O(n^2),
        ///     space complexity: O(1),
        ///     where n - array length.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Compares elements.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                var jmin = i;
                for (var j = i + 1; j < array.Length; j++)
                {
                    if (comparer.Compare(array[jmin], array[j]) > 0)
                    {
                        jmin = j;
                    }
                }

                var t = array[i];
                array[i] = array[jmin];
                array[jmin] = t;
            }
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Class that implements bubble sort algorithm.
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public class BubbleSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts array using specified comparer,
        ///     internal, in-place, stable,
        ///     time complexity: O(n^2),
        ///     space complexity: O(1),
        ///     where n - array length.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Compares elements.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                var wasChanged = false;
                for (var j = 0; j < array.Length - i - 1; j++)
                {
                    if (comparer.Compare(array[j], array[j + 1]) > 0)
                    {
                        var temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                        wasChanged = true;
                    }
                }

                if (!wasChanged)
                {
                    break;
                }
            }
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Sorts arrays using quicksort (selecting random point as a pivot).
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public sealed class RandomPivotQuickSorter<T> : QuickSorter<T>
    {
        private readonly Random random = new();

        protected override T SelectPivot(T[] array, IComparer<T> comparer, int left, int right) =>
            array[random.Next(left, right + 1)];
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Sorts array in ascending order using comparison sort.
    /// </summary>
    /// <typeparam name="T">Type of array item.</typeparam>
    public interface IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts array in ascending order.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Comparer to compare items of <paramref name="array" />.</param>
        void Sort(T[] array, IComparer<T> comparer);
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Comb sort is a relatively simple sorting algorithm that improves on bubble sort.
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public class CombSorter<T> : IComparisonSorter<T>
    {
        public CombSorter(double shrinkFactor = 1.3) => ShrinkFactor = shrinkFactor;

        private double ShrinkFactor { get; }

        /// <summary>
        ///     Sorts array using specified comparer,
        ///     internal, in-place, unstable,
        ///     worst case performance: O(n^2),
        ///     best case performance: O(n log(n)),
        ///     average performance: O(n^2 / 2^p),
        ///     space complexity: O(1),
        ///     where n - array length and p - number of increments.
        ///     See <a href="https://en.wikipedia.org/wiki/Comb_sort">here</a> for more info.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Compares elements.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            var gap = array.Length;
            var sorted = false;
            while (!sorted)
            {
                gap = (int)Math.Floor(gap / ShrinkFactor);
                if (gap <= 1)
                {
                    gap = 1;
                    sorted = true;
                }

                for (var i = 0; i < array.Length - gap; i++)
                {
                    if (comparer.Compare(array[i], array[i + gap]) > 0)
                    {
                        (array[i], array[i + gap]) = (array[i + gap], array[i]);
                        sorted = false;
                    }
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Divide and Conquer algorithm, which splits
    ///     array in two halves, calls itself for the two
    ///     halves and then merges the two sorted halves.
    /// </summary>
    /// <typeparam name="T">Type of array elements.</typeparam>
    public class MergeSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts array using merge sort algorithm,
        ///     originally designed as external sorting algorithm,
        ///     internal, stable,
        ///     time complexity: O(n log(n)),
        ///     space complexity: O(n),
        ///     where n - array length.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Comparer to compare elements of <paramref name="array" />.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            if (array.Length <= 1)
            {
                return;
            }

            var (left, right) = Split(array);
            Sort(left, comparer);
            Sort(right, comparer);
            Merge(array, left, right, comparer);
        }

        private static void Merge(T[] array, T[] left, T[] right, IComparer<T> comparer)
        {
            var mainIndex = 0;
            var leftIndex = 0;
            var rightIndex = 0;

            while (leftIndex < left.Length && rightIndex < right.Length)
            {
                var compResult = comparer.Compare(left[leftIndex], right[rightIndex]);
                array[mainIndex++] = compResult <= 0 ? left[leftIndex++] : right[rightIndex++];
            }

            while (leftIndex < left.Length)
            {
                array[mainIndex++] = left[leftIndex++];
            }

            while (rightIndex < right.Length)
            {
                array[mainIndex++] = right[rightIndex++];
            }
        }

        private static (T[] left, T[] right) Split(T[] array)
        {
            var mid = array.Length / 2;
            return (array.Take(mid).ToArray(), array.Skip(mid).ToArray());
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     TODO.
    /// </summary>
    /// <typeparam name="T">TODO. 2.</typeparam>
    public class BinaryInsertionSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts array using specified comparer,
        ///     variant of insertion sort where binary search is used to find place for next element
        ///     internal, in-place, unstable,
        ///     time complexity: O(n^2),
        ///     space complexity: O(1),
        ///     where n - array length.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Compares elements.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 1; i < array.Length; i++)
            {
                var target = array[i];
                var moveIndex = i - 1;
                var targetInsertLocation = BinarySearch(array, 0, moveIndex, target, comparer);
                Array.Copy(array, targetInsertLocation, array, targetInsertLocation + 1, i - targetInsertLocation);

                array[targetInsertLocation] = target;
            }
        }

        /// <summary>Implementation of Binary Search using an iterative approach.</summary>
        /// <param name="array">
        ///     An array of values sorted in ascending order between the index values left and right to search
        ///     through.
        /// </param>
        /// <param name="from">Left index to search from (inclusive).</param>
        /// <param name="to">Right index to search to (inclusive).</param>
        /// <param name="target">The value to find placefor in the provided array.</param>
        /// <param name="comparer">TODO.</param>
        /// <returns>The index where to insert target value.</returns>
        private static int BinarySearch(T[] array, int from, int to, T target, IComparer<T> comparer)
        {
            var left = from;
            var right = to;
            while (right > left)
            {
                var middle = (left + right) / 2;
                var comparisonResult = comparer.Compare(target, array[middle]);

                if (comparisonResult == 0)
                {
                    return middle + 1;
                }

                if (comparisonResult > 0)
                {
                    left = middle + 1;
                }
                else
                {
                    right = middle - 1;
                }
            }

            return comparer.Compare(target, array[left]) < 0 ? left : left + 1;
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Sorts arrays using quicksort.
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public abstract class QuickSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts array using Hoare partition scheme,
        ///     internal, in-place,
        ///     time complexity average: O(n log(n)),
        ///     time complexity worst: O(n^2),
        ///     space complexity: O(log(n)),
        ///     where n - array length.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Compares elements.</param>
        public void Sort(T[] array, IComparer<T> comparer) => Sort(array, comparer, 0, array.Length - 1);

        protected abstract T SelectPivot(T[] array, IComparer<T> comparer, int left, int right);

        private void Sort(T[] array, IComparer<T> comparer, int left, int right)
        {
            if (left >= right)
            {
                return;
            }

            var p = Partition(array, comparer, left, right);
            Sort(array, comparer, left, p);
            Sort(array, comparer, p + 1, right);
        }

        private int Partition(T[] array, IComparer<T> comparer, int left, int right)
        {
            var pivot = SelectPivot(array, comparer, left, right);
            var nleft = left;
            var nright = right;
            while (true)
            {
                while (comparer.Compare(array[nleft], pivot) < 0)
                {
                    nleft++;
                }

                while (comparer.Compare(array[nright], pivot) > 0)
                {
                    nright--;
                }

                if (nleft >= nright)
                {
                    return nright;
                }

                var t = array[nleft];
                array[nleft] = array[nright];
                array[nright] = t;

                nleft++;
                nright--;
            }
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data.
    ///     It was originally implemented by Tim Peters in 2002 for use in the Python programming language.
    ///
    ///     This class is based on a Java interpretation of Tim Peter's original work.
    ///     Java class is viewable here:
    ///     http://cr.openjdk.java.net/~martin/webrevs/openjdk7/timsort/raw_files/new/src/share/classes/java/util/TimSort.java
    ///
    ///     Tim Peters's list sort for Python, is described in detail here:
    ///     http://svn.python.org/projects/python/trunk/Objects/listsort.txt
    ///
    ///     Tim's C code may be found here: http://svn.python.org/projects/python/trunk/Objects/listobject.c
    ///
    ///     The underlying techniques are described in this paper (and may have even earlier origins):
    ///     "Optimistic Sorting and Information Theoretic Complexity"
    ///     Peter McIlroy
    ///     SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
    ///     pp 467-474, Austin, Texas, 25-27 January 1993.
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public class TimSorter<T> : IComparisonSorter<T>
    {
        private readonly int minMerge;
        private readonly int initMinGallop;
        private readonly int[] runBase;
        private readonly int[] runLengths;

        private int minGallop;
        private int stackSize;

        private IComparer<T> comparer = default!;

        /// <summary>
        /// Private class for handling gallop merges, allows for tracking array indexes and wins.
        /// </summary>
        /// <typeparam name="Tc">Type of array element.</typeparam>
        private class TimChunk<Tc>
        {
            public Tc[] Array { get; set; } = default!;

            public int Index { get; set; }

            public int Remaining { get; set; }

            public int Wins { get; set; }
        }

        public TimSorter(int minMerge = 32, int minGallop = 7)
        {
            initMinGallop = minGallop;
            this.minMerge = minMerge;
            runBase = new int[85];
            runLengths = new int[85];

            stackSize = 0;
            this.minGallop = minGallop;
        }

        /// <summary>
        ///     Sorts array using specified comparer
        ///     worst case performance: O(n log(n)),
        ///     best case performance:  O(n),
        ///     See <a href="https://en.wikipedia.org/wiki/Timsort">here</a> for more info.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Compares elements.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            this.comparer = comparer;
            var start = 0;
            var remaining = array.Length;

            if (remaining < minMerge)
            {
                if (remaining < 2)
                {
                    // Arrays of size 0 or 1 are always sorted.
                    return;
                }

                // Don't need to merge, just binary sort
                BinarySort(array, start, remaining, start);
                return;
            }

            var minRun = MinRunLength(remaining, minMerge);

            do
            {
                // Identify next run
                var runLen = CountRunAndMakeAscending(array, start);

                // If the run is too short extend to Min(MIN_RUN, remaining)
                if (runLen < minRun)
                {
                    var force = Math.Min(minRun, remaining);
                    BinarySort(array, start, start + force, start + runLen);
                    runLen = force;
                }

                runBase[stackSize] = start;
                runLengths[stackSize] = runLen;
                stackSize++;

                MergeCollapse(array);

                start += runLen;
                remaining -= runLen;
            }
            while (remaining != 0);

            MergeForceCollapse(array);
        }

        /// <summary>
        /// Returns the minimum acceptable run length for an array of the specified
        /// length.Natural runs shorter than this will be extended.
        ///
        /// Computation is:
        ///   If total less than minRun, return n (it's too small to bother with fancy stuff).
        ///   Else if total is an exact power of 2, return minRun/2.
        ///   Else return an int k, where <![CDATA[minRun/2 <= k <= minRun]]>, such that total/k
        ///     is close to, but strictly less than, an exact power of 2.
        /// </summary>
        /// <param name="total">Total length remaining to sort.</param>
        /// <returns>Minimum run length to be merged.</returns>
        private static int MinRunLength(int total, int minRun)
        {
            var r = 0;
            while (total >= minRun)
            {
                r |= total & 1;
                total >>= 1;
            }

            return total + r;
        }

        /// <summary>
        /// Reverse the specified range of the specified array.
        /// </summary>
        /// <param name="array">the array in which a range is to be reversed.</param>
        /// <param name="start">the index of the first element in the range to be reversed.</param>
        /// <param name="end">the index after the last element in the range to be reversed.</param>
        private static void ReverseRange(T[] array, int start, int end)
        {
            end--;
            while (start < end)
            {
                var t = array[start];
                array[start++] = array[end];
                array[end--] = t;
            }
        }

        /// <summary>
        /// Left shift a value, preventing a roll over to negative numbers.
        /// </summary>
        /// <param name="shiftable">int value to left shift.</param>
        /// <returns>Left shifted value, bound to 2,147,483,647.</returns>
        private static int BoundLeftShift(int shiftable) => (shiftable << 1) < 0
                ? (shiftable << 1) + 1
                : int.MaxValue;

        /// <summary>
        /// Check the chunks before getting in to a merge to make sure there's something to actually do.
        /// </summary>
        /// <param name="left">TimChunk of the left hand side.</param>
        /// <param name="right">TimChunk of the right hand side.</param>
        /// <param name="dest">The current target point for the remaining values.</param>
        /// <returns>If a merge is required.</returns>
        private static bool NeedsMerge(TimChunk<T> left, TimChunk<T> right, ref int dest)
        {
            right.Array[dest++] = right.Array[right.Index++];
            if (--right.Remaining == 0)
            {
                Array.Copy(left.Array, left.Index, right.Array, dest, left.Remaining);
                return false;
            }

            if (left.Remaining == 1)
            {
                Array.Copy(right.Array, right.Index, right.Array, dest, right.Remaining);
                right.Array[dest + right.Remaining] = left.Array[left.Index];
                return false;
            }

            return true;
        }

        /// <summary>
        /// Moves over the last parts of the chunks.
        /// </summary>
        /// <param name="left">TimChunk of the left hand side.</param>
        /// <param name="right">TimChunk of the right hand side.</param>
        /// <param name="dest">The current target point for the remaining values.</param>
        private static void FinalizeMerge(TimChunk<T> left, TimChunk<T> right, int dest)
        {
            if (left.Remaining == 1)
            {
                Array.Copy(right.Array, right.Index, right.Array, dest, right.Remaining);
                right.Array[dest + right.Remaining] = left.Array[left.Index];
            }
            else if (left.Remaining == 0)
            {
                throw new ArgumentException("Comparison method violates its general contract!");
            }
            else
            {
                Array.Copy(left.Array, left.Index, right.Array, dest, left.Remaining);
            }
        }

        /// <summary>
        /// Returns the length of the run beginning at the specified position in
        /// the specified array and reverses the run if it is descending (ensuring
        /// that the run will always be ascending when the method returns).
        ///
        /// A run is the longest ascending sequence with:
        ///
        ///    <![CDATA[a[lo] <= a[lo + 1] <= a[lo + 2] <= ...]]>
        ///
        /// or the longest descending sequence with:
        ///
        ///    <![CDATA[a[lo] >  a[lo + 1] >  a[lo + 2] >  ...]]>
        ///
        /// For its intended use in a stable mergesort, the strictness of the
        /// definition of "descending" is needed so that the call can safely
        /// reverse a descending sequence without violating stability.
        /// </summary>
        /// <param name="array">the array in which a run is to be counted and possibly reversed.</param>
        /// <param name="start">index of the first element in the run.</param>
        /// <returns>the length of the run beginning at the specified position in the specified array.</returns>
        private int CountRunAndMakeAscending(T[] array, int start)
        {
            var runHi = start + 1;
            if (runHi == array.Length)
            {
                return 1;
            }

            // Find end of run, and reverse range if descending
            if (comparer.Compare(array[runHi++], array[start]) < 0)
            { // Descending
                while (runHi < array.Length && comparer.Compare(array[runHi], array[runHi - 1]) < 0)
                {
                    runHi++;
                }

                ReverseRange(array, start, runHi);
            }
            else
            { // Ascending
                while (runHi < array.Length && comparer.Compare(array[runHi], array[runHi - 1]) >= 0)
                {
                    runHi++;
                }
            }

            return runHi - start;
        }

        /// <summary>
        /// Find the position in the array that a key should fit to the left of where it currently sits.
        /// </summary>
        /// <param name="array">Array to search.</param>
        /// <param name="key">Key to place in the array.</param>
        /// <param name="i">Base index for the key.</param>
        /// <param name="len">Length of the chunk to run through.</param>
        /// <param name="hint">Initial starting position to start from.</param>
        /// <returns>Offset for the key's location.</returns>
        private int GallopLeft(T[] array, T key, int i, int len, int hint)
        {
            var (offset, lastOfs) = comparer.Compare(key, array[i + hint]) > 0
                ? RightRun(array, key, i, len, hint, 0)
                : LeftRun(array, key, i, hint, 1);

            return FinalOffset(array, key, i, offset, lastOfs, 1);
        }

        /// <summary>
        /// Find the position in the array that a key should fit to the right of where it currently sits.
        /// </summary>
        /// <param name="array">Array to search.</param>
        /// <param name="key">Key to place in the array.</param>
        /// <param name="i">Base index for the key.</param>
        /// <param name="len">Length of the chunk to run through.</param>
        /// <param name="hint">Initial starting position to start from.</param>
        /// <returns>Offset for the key's location.</returns>
        private int GallopRight(T[] array, T key, int i, int len, int hint)
        {
            var (offset, lastOfs) = comparer.Compare(key, array[i + hint]) < 0
                ? LeftRun(array, key, i, hint, 0)
                : RightRun(array, key, i, len, hint, -1);

            return FinalOffset(array, key, i, offset, lastOfs, 0);
        }

        private (int offset, int lastOfs) LeftRun(T[] array, T key, int i, int hint, int lt)
        {
            var maxOfs = hint + 1;
            var (offset, tmp) = (1, 0);

            while (offset < maxOfs && comparer.Compare(key, array[i + hint - offset]) < lt)
            {
                tmp = offset;
                offset = BoundLeftShift(offset);
            }

            if (offset > maxOfs)
            {
                offset = maxOfs;
            }

            var lastOfs = hint - offset;
            offset = hint - tmp;

            return (offset, lastOfs);
        }

        private (int offset, int lastOfs) RightRun(T[] array, T key, int i, int len, int hint, int gt)
        {
            var (offset, lastOfs) = (1, 0);
            var maxOfs = len - hint;
            while (offset < maxOfs && comparer.Compare(key, array[i + hint + offset]) > gt)
            {
                lastOfs = offset;
                offset = BoundLeftShift(offset);
            }

            if (offset > maxOfs)
            {
                offset = maxOfs;
            }

            offset += hint;
            lastOfs += hint;

            return (offset, lastOfs);
        }

        private int FinalOffset(T[] array, T key, int i, int offset, int lastOfs, int lt)
        {
            lastOfs++;
            while (lastOfs < offset)
            {
                var m = lastOfs + (int)((uint)(offset - lastOfs) >> 1);

                if (comparer.Compare(key, array[i + m]) < lt)
                {
                    offset = m;
                }
                else
                {
                    lastOfs = m + 1;
                }
            }

            return offset;
        }

        /// <summary>
        /// Sorts the specified portion of the specified array using a binary
        /// insertion sort. It requires O(n log n) compares, but O(n^2) data movement.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="start">The index of the first element in the range to be sorted.</param>
        /// <param name="end">The index after the last element in the range to be sorted.</param>
        /// <param name="first">The index of the first element in the range that is not already known to be sorted, must be between start and end.</param>
        private void BinarySort(T[] array, int start, int end, int first)
        {
            if (first >= end || first <= start)
            {
                first = start + 1;
            }

            for (; first < end; first++)
            {
                var target = array[first];
                var targetInsertLocation = BinarySearch(array, start, first - 1, target);
                Array.Copy(array, targetInsertLocation, array, targetInsertLocation + 1, first - targetInsertLocation);

                array[targetInsertLocation] = target;
            }
        }

        private int BinarySearch(T[] array, int left, int right, T target)
        {
            while (left < right)
            {
                var mid = (left + right) >> 1;
                if (comparer.Compare(target, array[mid]) < 0)
                {
                    right = mid;
                }
                else
                {
                    left = mid + 1;
                }
            }

            return comparer.Compare(target, array[left]) < 0
                ? left
                : left + 1;
        }

        private void MergeCollapse(T[] array)
        {
            while (stackSize > 1)
            {
                var n = stackSize - 2;
                if (n > 0 && runLengths[n - 1] <= runLengths[n] + runLengths[n + 1])
                {
                    if (runLengths[n - 1] < runLengths[n + 1])
                    {
                        n--;
                    }

                    MergeAt(array, n);
                }
                else if (runLengths[n] <= runLengths[n + 1])
                {
                    MergeAt(array, n);
                }
                else
                {
                    break;
                }
            }
        }

        private void MergeForceCollapse(T[] array)
        {
            while (stackSize > 1)
            {
                var n = stackSize - 2;
                if (n > 0 && runLengths[n - 1] < runLengths[n + 1])
                {
                    n--;
                }

                MergeAt(array, n);
            }
        }

        private void MergeAt(T[] array, int index)
        {
            var baseA = runBase[index];
            var lenA = runLengths[index];
            var baseB = runBase[index + 1];
            var lenB = runLengths[index + 1];

            runLengths[index] = lenA + lenB;

            if (index == stackSize - 3)
            {
                runBase[index + 1] = runBase[index + 2];
                runLengths[index + 1] = runLengths[index + 2];
            }

            stackSize--;

            var k = GallopRight(array, array[baseB], baseA, lenA, 0);

            baseA += k;
            lenA -= k;

            if (lenA <= 0)
            {
                return;
            }

            lenB = GallopLeft(array, array[baseA + lenA - 1], baseB, lenB, lenB - 1);

            if (lenB <= 0)
            {
                return;
            }

            Merge(array, baseA, lenA, baseB, lenB);
        }

        private void Merge(T[] array, int baseA, int lenA, int baseB, int lenB)
        {
            var endA = baseA + lenA;
            var dest = baseA;

            TimChunk<T> left = new()
            {
                Array = array[baseA..endA],
                Remaining = lenA,
            };

            TimChunk<T> right = new()
            {
                Array = array,
                Index = baseB,
                Remaining = lenB,
            };

            // Move first element of the right chunk and deal with degenerate cases.
            if (!TimSorter<T>.NeedsMerge(left, right, ref dest))
            {
                // One of the chunks had 0-1 items in it, so no need to merge anything.
                return;
            }

            var gallop = minGallop;

            while (RunMerge(left, right, ref dest, ref gallop))
            {
                // Penalize for leaving gallop mode
                gallop = gallop > 0
                    ? gallop + 2
                    : 2;
            }

            minGallop = gallop >= 1
                ? gallop
                : 1;

            FinalizeMerge(left, right, dest);
        }

        private bool RunMerge(TimChunk<T> left, TimChunk<T> right, ref int dest, ref int gallop)
        {
            // Reset the number of times in row a run wins.
            left.Wins = 0;
            right.Wins = 0;

            // Run a stable merge sort until (if ever) one run starts winning consistently.
            if (StableMerge(left, right, ref dest, gallop))
            {
                // Stable merge sort completed with no viable gallops, time to exit.
                return false;
            }

            // One run is winning so consistently that galloping may be a huge win.
            // So try that, and continue galloping until (if ever) neither run appears to be winning consistently anymore.
            do
            {
                if (GallopMerge(left, right, ref dest))
                {
                    // Galloped all the way to the end, merge is complete.
                    return false;
                }

                // We had a bit of a run, so make it easier to get started again.
                gallop--;
            }
            while (left.Wins >= initMinGallop || right.Wins >= initMinGallop);

            return true;
        }

        private bool StableMerge(TimChunk<T> left, TimChunk<T> right, ref int dest, int gallop)
        {
            do
            {
                if (comparer.Compare(right.Array[right.Index], left.Array[left.Index]) < 0)
                {
                    right.Array[dest++] = right.Array[right.Index++];
                    right.Wins++;
                    left.Wins = 0;
                    if (--right.Remaining == 0)
                    {
                        return true;
                    }
                }
                else
                {
                    right.Array[dest++] = left.Array[left.Index++];
                    left.Wins++;
                    right.Wins = 0;
                    if (--left.Remaining == 1)
                    {
                        return true;
                    }
                }
            }
            while ((left.Wins | right.Wins) < gallop);

            return false;
        }

        private bool GallopMerge(TimChunk<T> left, TimChunk<T> right, ref int dest)
        {
            left.Wins = GallopRight(left.Array, right.Array[right.Index], left.Index, left.Remaining, 0);
            if (left.Wins != 0)
            {
                Array.Copy(left.Array, left.Index, right.Array, dest, left.Wins);
                dest += left.Wins;
                left.Index += left.Wins;
                left.Remaining -= left.Wins;
                if (left.Remaining <= 1)
                {
                    return true;
                }
            }

            right.Array[dest++] = right.Array[right.Index++];
            if (--right.Remaining == 0)
            {
                return true;
            }

            right.Wins = GallopLeft(right.Array, left.Array[left.Index], right.Index, right.Remaining, 0);
            if (right.Wins != 0)
            {
                Array.Copy(right.Array, right.Index, right.Array, dest, right.Wins);
                dest += right.Wins;
                right.Index += right.Wins;
                right.Remaining -= right.Wins;
                if (right.Remaining == 0)
                {
                    return true;
                }
            }

            right.Array[dest++] = left.Array[left.Index++];
            if (--left.Remaining == 1)
            {
                return true;
            }

            return false;
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Class that implements exchange sort algorithm.
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public class ExchangeSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts array using specified comparer,
        ///     internal, in-place, stable,
        ///     time complexity: O(n^2),
        ///     space complexity: O(1),
        ///     where n - array length.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Compares elements.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                for (var j = i + 1; j < array.Length; j++)
                {
                    if (comparer.Compare(array[i], array[j]) > 0)
                    {
                        (array[j], array[i]) = (array[i], array[j]);
                    }
                }
            }
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Cocktail Sort is a variation of Bubble sort, where Cocktail
    ///     Sort traverses through a given array in both directions alternatively.
    /// </summary>
    /// <typeparam name="T">Array input type.</typeparam>
    public class CocktailSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts array using Cocktail sort algorithm.
        /// </summary>
        /// <param name="array">Input array.</param>
        /// <param name="comparer">Type of comparer for array elements.</param>
        public void Sort(T[] array, IComparer<T> comparer) => CocktailSort(array, comparer);

        private static void CocktailSort(IList<T> array, IComparer<T> comparer)
        {
            var swapped = true;

            var startIndex = 0;
            var endIndex = array.Count - 1;

            while (swapped)
            {
                for (var i = startIndex; i < endIndex; i++)
                {
                    if (comparer.Compare(array[i], array[i + 1]) != 1)
                    {
                        continue;
                    }

                    var highValue = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = highValue;
                }

                endIndex--;
                swapped = false;

                for (var i = endIndex; i > startIndex; i--)
                {
                    if (comparer.Compare(array[i], array[i - 1]) != -1)
                    {
                        continue;
                    }

                    var highValue = array[i];
                    array[i] = array[i - 1];
                    array[i - 1] = highValue;

                    swapped = true;
                }

                startIndex++;
            }
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Sorts arrays using quicksort (selecting middle point as a pivot).
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public sealed class MiddlePointQuickSorter<T> : QuickSorter<T>
    {
        protected override T SelectPivot(T[] array, IComparer<T> comparer, int left, int right) =>
            array[left + (right - left) / 2];
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Class that implements insertion sort algorithm.
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public class InsertionSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts array using specified comparer,
        ///     internal, in-place, stable,
        ///     time complexity: O(n^2),
        ///     space complexity: O(1),
        ///     where n - array length.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Compares elements.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                var imin = i;
                for (var j = i + 1; j < array.Length; j++)
                {
                    if (comparer.Compare(array[j], array[imin]) < 0)
                    {
                        imin = j;
                    }
                }

                var t = array[imin];
                array[imin] = array[i];
                array[i] = t;
            }
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     TODO.
    /// </summary>
    /// <typeparam name="T">TODO. 2.</typeparam>
    public class ShellSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts array using specified comparer,
        ///     based on bubble sort,
        ///     internal, in-place, unstable,
        ///     worst-case time complexity: O(n^2),
        ///     space complexity: O(1),
        ///     where n - array length.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        /// <param name="comparer">Compares elements.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var step = array.Length / 2; step > 0; step /= 2)
            {
                for (var i = 0; i < step; i++)
                {
                    GappedBubbleSort(array, comparer, i, step);
                }
            }
        }

        private static void GappedBubbleSort(T[] array, IComparer<T> comparer, int start, int step)
        {
            for (var j = start; j < array.Length - step; j += step)
            {
                var wasChanged = false;
                for (var k = start; k < array.Length - j - step; k += step)
                {
                    if (comparer.Compare(array[k], array[k + step]) > 0)
                    {
                        var temp = array[k];
                        array[k] = array[k + step];
                        array[k + step] = temp;
                        wasChanged = true;
                    }
                }

                if (!wasChanged)
                {
                    break;
                }
            }
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Heap sort is a comparison based sorting technique
    ///     based on Binary Heap data structure.
    /// </summary>
    /// <typeparam name="T">Input array type.</typeparam>
    public class HeapSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts input array using heap sort algorithm.
        /// </summary>
        /// <param name="array">Input array.</param>
        /// <param name="comparer">Comparer type for elements.</param>
        public void Sort(T[] array, IComparer<T> comparer) => HeapSort(array, comparer);

        private static void HeapSort(IList<T> data, IComparer<T> comparer)
        {
            var heapSize = data.Count;
            for (var p = (heapSize - 1) / 2; p >= 0; p--)
            {
                MakeHeap(data, heapSize, p, comparer);
            }

            for (var i = data.Count - 1; i > 0; i--)
            {
                var temp = data[i];
                data[i] = data[0];
                data[0] = temp;

                heapSize--;
                MakeHeap(data, heapSize, 0, comparer);
            }
        }

        private static void MakeHeap(IList<T> input, int heapSize, int index, IComparer<T> comparer)
        {
            var rIndex = index;

            while (true)
            {
                var left = (rIndex + 1) * 2 - 1;
                var right = (rIndex + 1) * 2;
                var largest = left < heapSize && comparer.Compare(input[left], input[rIndex]) == 1 ? left : rIndex;

                // finds the index of the largest
                if (right < heapSize && comparer.Compare(input[right], input[largest]) == 1)
                {
                    largest = right;
                }

                if (largest == rIndex)
                {
                    return;
                }

                // process of reheaping / swapping
                var temp = input[rIndex];
                input[rIndex] = input[largest];
                input[largest] = temp;

                rIndex = largest;
            }
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Cycle sort is an in-place, unstable sorting algorithm,
    ///     a comparison sort that is theoretically optimal in terms of the total
    ///     number of writes to the original array.
    ///     It is based on the idea that the permutation to be sorted can be factored
    ///     into cycles, which can individually be rotated to give a sorted result.
    /// </summary>
    /// <typeparam name="T">Type array input.</typeparam>
    public class CycleSorter<T> : IComparisonSorter<T>
    {
        /// <summary>
        ///     Sorts input array using Cycle sort.
        /// </summary>
        /// <param name="array">Input array.</param>
        /// <param name="comparer">Integer comparer.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                MoveCycle(array, i, comparer);
            }
        }

        private static void MoveCycle(T[] array, int startingIndex, IComparer<T> comparer)
        {
            var item = array[startingIndex];
            var pos = startingIndex + CountSmallerElements(array, startingIndex + 1, item, comparer);

            if (pos == startingIndex)
            {
                return;
            }

            pos = SkipSameElements(array, pos, item, comparer);

            var temp = array[pos];
            array[pos] = item;
            item = temp;

            while (pos != startingIndex)
            {
                pos = startingIndex + CountSmallerElements(array, startingIndex + 1, item, comparer);
                pos = SkipSameElements(array, pos, item, comparer);

                temp = array[pos];
                array[pos] = item;
                item = temp;
            }
        }

        private static int SkipSameElements(T[] array, int nextIndex, T item, IComparer<T> comparer)
        {
            while (comparer.Compare(array[nextIndex], item) == 0)
            {
                nextIndex++;
            }

            return nextIndex;
        }

        private static int CountSmallerElements(T[] array, int startingIndex, T element, IComparer<T> comparer)
        {
            var smallerElements = 0;
            for (var i = startingIndex; i < array.Length; i++)
            {
                if (comparer.Compare(array[i], element) < 0)
                {
                    smallerElements++;
                }
            }

            return smallerElements;
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    /// <summary>
    ///     Class that implements bogo sort algorithm.
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public class BogoSorter<T> : IComparisonSorter<T>
    {
        private readonly Random random = new();

        /// <summary>
        ///     TODO.
        /// </summary>
        /// <param name="array">TODO. 2.</param>
        /// <param name="comparer">TODO. 3.</param>
        public void Sort(T[] array, IComparer<T> comparer)
        {
            while (!IsSorted(array, comparer))
            {
                Shuffle(array);
            }
        }

        private bool IsSorted(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                if (comparer.Compare(array[i], array[i + 1]) > 0)
                {
                    return false;
                }
            }

            return true;
        }

        private void Shuffle(T[] array)
        {
            var taken = new bool[array.Length];
            var newArray = new T[array.Length];
            for (var i = 0; i < array.Length; i++)
            {
                int nextPos;
                do
                {
                    nextPos = random.Next(0, int.MaxValue) % array.Length;
                }
                while (taken[nextPos]);

                taken[nextPos] = true;
                newArray[nextPos] = array[i];
            }

            for (var i = 0; i < array.Length; i++)
            {
                array[i] = newArray[i];
            }
        }
    }
}
namespace Algorithms.Sorters.String
{
    /// <summary>
    ///     Radix sort is a non-comparative sorting algorithm. It avoids comparison by creating
    ///     and distributing elements into buckets according to their radix.
    ///     Radix sorts can be implemented to start at either the most significant digit (MSD)
    ///     or least significant digit (LSD).
    ///     MSD radix sorts are most suitable for sorting array of strings with variable length
    ///     in lexicographical order.
    /// </summary>
    public class MsdRadixStringSorter : IStringSorter
    {
        /// <summary>
        ///     Sort array of strings using MSD radix sort algorithm.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        public void Sort(string[] array) => Sort(array, 0, array.Length - 1, 0, new string[array.Length]);

        private static void Sort(string[] array, int l, int r, int d, string[] temp)
        {
            if (l >= r)
            {
                return;
            }

            const int k = 256;

            var count = new int[k + 2];
            for (var i = l; i <= r; i++)
            {
                var j = Key(array[i]);
                count[j + 2]++;
            }

            for (var i = 1; i < count.Length; i++)
            {
                count[i] += count[i - 1];
            }

            for (var i = l; i <= r; i++)
            {
                var j = Key(array[i]);
                temp[count[j + 1]++] = array[i];
            }

            for (var i = l; i <= r; i++)
            {
                array[i] = temp[i - l];
            }

            for (var i = 0; i < k; i++)
            {
                Sort(array, l + count[i], l + count[i + 1] - 1, d + 1, temp);
            }

            int Key(string s) => d >= s.Length ? -1 : s[d];
        }
    }
}
namespace Algorithms.Sorters.String
{
    /// <summary>
    ///     Sorts array of strings without comparing them.
    /// </summary>
    public interface IStringSorter
    {
        /// <summary>
        ///     Sorts array in ascending order.
        /// </summary>
        /// <param name="array">Array to sort.</param>
        void Sort(string[] array);
    }
}
namespace Algorithms.Sorters.External.Storages
{
    public class IntInMemoryStorage : ISequentialStorage<int>
    {
        private readonly int[] storage;

        public IntInMemoryStorage(int[] array) => storage = array;

        public int Length => storage.Length;

        public ISequentialStorageReader<int> GetReader() => new InMemoryReader(storage);

        public ISequentialStorageWriter<int> GetWriter() => new InMemoryWriter(storage);

        private class InMemoryReader : ISequentialStorageReader<int>
        {
            private readonly int[] storage;
            private int offset;

            public InMemoryReader(int[] storage) => this.storage = storage;

            public void Dispose()
            {
                // Nothing to dispose here
            }

            public int Read() => storage[offset++];
        }

        private class InMemoryWriter : ISequentialStorageWriter<int>
        {
            private readonly int[] storage;
            private int offset;

            public InMemoryWriter(int[] storage) => this.storage = storage;

            public void Write(int value) => storage[offset++] = value;

            public void Dispose()
            {
                // Nothing to dispose here
            }
        }
    }
}
using System.IO;

namespace Algorithms.Sorters.External.Storages
{
    public class IntFileStorage : ISequentialStorage<int>
    {
        private readonly string filename;

        public IntFileStorage(string filename, int length)
        {
            Length = length;
            this.filename = filename;
        }

        public int Length { get; }

        public ISequentialStorageReader<int> GetReader() => new FileReader(filename);

        public ISequentialStorageWriter<int> GetWriter() => new FileWriter(filename);

        private class FileReader : ISequentialStorageReader<int>
        {
            private readonly BinaryReader reader;

            public FileReader(string filename) => reader = new BinaryReader(File.OpenRead(filename));

            public void Dispose() => reader.Dispose();

            public int Read() => reader.ReadInt32();
        }

        private class FileWriter : ISequentialStorageWriter<int>
        {
            private readonly BinaryWriter writer;

            public FileWriter(string filename) => writer = new BinaryWriter(File.OpenWrite(filename));

            public void Write(int value) => writer.Write(value);

            public void Dispose() => writer.Dispose();
        }
    }
}
namespace Algorithms.Sorters.External
{
    public interface ISequentialStorage<T>
    {
        public int Length { get; }

        ISequentialStorageReader<T> GetReader();

        ISequentialStorageWriter<T> GetWriter();
    }
}
using System;

namespace Algorithms.Sorters.External
{
    public interface ISequentialStorageWriter<in T> : IDisposable
    {
        void Write(T value);
    }
}
using System;

namespace Algorithms.Sorters.External
{
    public interface ISequentialStorageReader<out T> : IDisposable
    {
        T Read();
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.External
{
    public interface IExternalSorter<T>
    {
        /// <summary>
        ///     Sorts elements in sequential storage in ascending order.
        /// </summary>
        /// <param name="mainMemory">Memory that contains array to sort and will contain the result.</param>
        /// <param name="temporaryMemory">Temporary memory for working purposes.</param>
        void Sort(ISequentialStorage<T> mainMemory, ISequentialStorage<T> temporaryMemory, IComparer<T> comparer);
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.External
{
    public class ExternalMergeSorter<T> : IExternalSorter<T>
    {
        public void Sort(
            ISequentialStorage<T> mainMemory,
            ISequentialStorage<T> temporaryMemory,
            IComparer<T> comparer)
        {
            var originalSource = mainMemory;
            var source = mainMemory;
            var temp = temporaryMemory;
            var totalLength = mainMemory.Length;
            for (var stripLength = 1L; stripLength < totalLength; stripLength *= 2)
            {
                using var left = source.GetReader();
                using var right = source.GetReader();
                using var output = temp.GetWriter();

                for (var i = 0L; i < stripLength; i++)
                {
                    right.Read();
                }

                Merge(left, right, output, stripLength, Math.Min(stripLength, totalLength - stripLength), comparer);
                var step = 2 * stripLength;
                long rightStripStart;
                for (rightStripStart = stripLength + step; rightStripStart < mainMemory.Length; rightStripStart += step)
                {
                    for (var i = 0L; i < stripLength; i++)
                    {
                        left.Read();
                        right.Read();
                    }

                    Merge(
                        left,
                        right,
                        output,
                        stripLength,
                        Math.Min(stripLength, totalLength - rightStripStart),
                        comparer);
                }

                for (var i = 0L; i < totalLength + stripLength - rightStripStart; i++)
                {
                    output.Write(right.Read());
                }

                (source, temp) = (temp, source);
            }

            if (source == originalSource)
            {
                return;
            }

            using var sorted = source.GetReader();
            using var dest = originalSource.GetWriter();
            for (var i = 0; i < totalLength; i++)
            {
                dest.Write(sorted.Read());
            }
        }

        private static void Merge(
            ISequentialStorageReader<T> left,
            ISequentialStorageReader<T> right,
            ISequentialStorageWriter<T> output,
            long leftLength,
            long rightLength,
            IComparer<T> comparer)
        {
            var leftIndex = 0L;
            var rightIndex = 0L;

            var l = left.Read();
            var r = right.Read();
            while (true)
            {
                if (comparer.Compare(l, r) < 0)
                {
                    output.Write(l);
                    leftIndex++;
                    if (leftIndex == leftLength)
                    {
                        break;
                    }

                    l = left.Read();
                }
                else
                {
                    output.Write(r);
                    rightIndex++;
                    if (rightIndex == rightLength)
                    {
                        break;
                    }

                    r = right.Read();
                }
            }

            if (leftIndex < leftLength)
            {
                output.Write(l);
                Copy(left, output, leftLength - leftIndex - 1);
            }

            if (rightIndex < rightLength)
            {
                output.Write(r);
                Copy(right, output, rightLength - rightIndex - 1);
            }
        }

        private static void Copy(ISequentialStorageReader<T> from, ISequentialStorageWriter<T> to, long count)
        {
            for (var i = 0; i < count; i++)
            {
                to.Write(from.Read());
            }
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Search
{
    /// <summary>
    ///     RecursiveBinarySearcher.
    /// </summary>
    /// <typeparam name="T">Type of searcher target.</typeparam>
    public class RecursiveBinarySearcher<T> where T : IComparable<T>
    {
        /// <summary>
        ///     Finds index of item in collection that equals to item searched for,
        ///     time complexity: O(log(n)),
        ///     space complexity: O(1),
        ///     where n - collection size.
        /// </summary>
        /// <param name="collection">Sorted collection to search in.</param>
        /// <param name="item">Item to search for.</param>
        /// <exception cref="ArgumentNullException">Thrown if input collection is null.</exception>
        /// <returns>Index of item that equals to item searched for or -1 if none found.</returns>
        public int FindIndex(IList<T>? collection, T item)
        {
            if (collection is null)
            {
                throw new ArgumentNullException(nameof(collection));
            }

            var leftIndex = 0;
            var rightIndex = collection.Count - 1;

            return FindIndex(collection, item, leftIndex, rightIndex);
        }

        /// <summary>
        ///     Finds index of item in array that equals to item searched for,
        ///     time complexity: O(log(n)),
        ///     space complexity: O(1),
        ///     where n - array size.
        /// </summary>
        /// <param name="collection">Sorted array to search in.</param>
        /// <param name="item">Item to search for.</param>
        /// <param name="leftIndex">Minimum search range.</param>
        /// <param name="rightIndex">Maximum search range.</param>
        /// <returns>Index of item that equals to item searched for or -1 if none found.</returns>
        private int FindIndex(IList<T> collection, T item, int leftIndex, int rightIndex)
        {
            if (leftIndex > rightIndex)
            {
                return -1;
            }

            var middleIndex = leftIndex + (rightIndex - leftIndex) / 2;
            var result = item.CompareTo(collection[middleIndex]);

            return result switch
            {
                var r when r == 0 => middleIndex,
                var r when r > 0 => FindIndex(collection, item, middleIndex + 1, rightIndex),
                var r when r < 0 => FindIndex(collection, item, leftIndex, middleIndex - 1),
                _ => -1,
            };
        }
    }
}
using System;

namespace Algorithms.Search
{
    /// <summary>
    ///     Class that implements Fibonacci search algorithm.
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public class FibonacciSearcher<T> where T : IComparable<T>
    {
        /// <summary>
        ///     Finds the index of the item searched for in the array.
        ///     Time complexity:
        ///     worst-case: O(log n),
        ///     average-case: O(log n),
        ///     best-case: O(1).
        /// </summary>
        /// <param name="array">Sorted array to be searched in. Cannot be null.</param>
        /// <param name="item">Item to be searched for. Cannot be null.</param>
        /// <returns>If an item is found, return index. If the array is empty or an item is not found, return -1.</returns>
        /// <exception cref="ArgumentNullException">Gets thrown when the given array or item is null.</exception>
        public int FindIndex(T[] array, T item)
        {
            if (array is null)
            {
                throw new ArgumentNullException("array");
            }

            if (item is null)
            {
                throw new ArgumentNullException("item");
            }

            var arrayLength = array.Length;

            if (arrayLength > 0)
            {
                // find the smallest Fibonacci number that equals or is greater than the array length
                var fibonacciNumberBeyondPrevious = 0;
                var fibonacciNumPrevious = 1;
                var fibonacciNum = fibonacciNumPrevious;

                while (fibonacciNum <= arrayLength)
                {
                    fibonacciNumberBeyondPrevious = fibonacciNumPrevious;
                    fibonacciNumPrevious = fibonacciNum;
                    fibonacciNum = fibonacciNumberBeyondPrevious + fibonacciNumPrevious;
                }

                // offset to drop the left part of the array
                var offset = -1;

                while (fibonacciNum > 1)
                {
                    var index = Math.Min(offset + fibonacciNumberBeyondPrevious, arrayLength - 1);

                    switch (item.CompareTo(array[index]))
                    {
                        // reject approximately 1/3 of the existing array in front
                        // by moving Fibonacci numbers
                        case > 0:
                            fibonacciNum = fibonacciNumPrevious;
                            fibonacciNumPrevious = fibonacciNumberBeyondPrevious;
                            fibonacciNumberBeyondPrevious = fibonacciNum - fibonacciNumPrevious;
                            offset = index;
                            break;

                        // reject approximately 2/3 of the existing array behind
                        // by moving Fibonacci numbers
                        case < 0:
                            fibonacciNum = fibonacciNumberBeyondPrevious;
                            fibonacciNumPrevious = fibonacciNumPrevious - fibonacciNumberBeyondPrevious;
                            fibonacciNumberBeyondPrevious = fibonacciNum - fibonacciNumPrevious;
                            break;
                        default:
                            return index;
                    }
                }

                // check the last element
                if (fibonacciNumPrevious == 1 && item.Equals(array[^1]))
                {
                    return arrayLength - 1;
                }
            }

            return -1;
        }
    }
}
using System;
using System.Collections.Generic;

// todo: extract to data structures
namespace Algorithms.Search.AStar
{
    /// <summary>
    ///     Generic Priority Queue.
    ///     List based.
    /// </summary>
    /// <typeparam name="T">
    ///     The type that will be stored.
    ///     Has to be IComparable of T.
    /// </typeparam>
    public class PriorityQueue<T>
        where T : IComparable<T>
    {
        private readonly bool isDescending;

        // The underlying structure.
        private readonly List<T> list;

        public PriorityQueue(bool isDescending = false)
        {
            this.isDescending = isDescending;
            list = new List<T>();
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="PriorityQueue{T}" /> class.
        /// </summary>
        /// <param name="capacity">Initial capacity.</param>
        /// <param name="isDescending">Should Reverse Sort order? Default: false.</param>
        public PriorityQueue(int capacity, bool isDescending = false)
        {
            list = new List<T>(capacity);
            this.isDescending = isDescending;
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="PriorityQueue{T}" /> class.
        /// </summary>
        /// <param name="collection">Internal data.</param>
        /// <param name="isDescending">Should Reverse Sort order? Default: false.</param>
        public PriorityQueue(IEnumerable<T> collection, bool isDescending = false)
            : this()
        {
            this.isDescending = isDescending;
            foreach (var item in collection)
            {
                Enqueue(item);
            }
        }

        /// <summary>
        ///     Gets Number of enqueued items.
        /// </summary>
        public int Count => list.Count;

        /// <summary>
        ///     Enqueues an item into the Queue.
        /// </summary>
        /// <param name="x">The item to Enqueue.</param>
        public void Enqueue(T x)
        {
            list.Add(x);
            var i = Count - 1; // Position of x

            while (i > 0)
            {
                var p = (i - 1) / 2; // Start at half of i
                if ((isDescending ? -1 : 1) * list[p].CompareTo(x) <= 0)
                {
                    break;
                }

                list[i] = list[p]; // Put P to position of i
                i = p; // I = (I-1)/2
            }

            if (Count > 0)
            {
                list[i] = x; // If while loop way executed at least once(X got replaced by some p), add it to the list
            }
        }

        /// <summary>
        ///     Dequeues the item at the end of the queue.
        /// </summary>
        /// <returns>The dequeued item.</returns>
        public T Dequeue()
        {
            var target = Peek(); // Get first in list
            var root = list[Count - 1]; // Hold last of the list
            list.RemoveAt(Count - 1); // But remove it from the list

            var i = 0;
            while (i * 2 + 1 < Count)
            {
                var a = i * 2 + 1; // Every second entry starting by 1
                var b = i * 2 + 2; // Every second entries neighbour
                var c = b < Count && (isDescending ? -1 : 1) * list[b].CompareTo(list[a]) < 0
                    ? b
                    : a; // Whether B(B is in range && B is smaller than A) or A

                if ((isDescending ? -1 : 1) * list[c].CompareTo(root) >= 0)
                {
                    break;
                }

                list[i] = list[c];
                i = c;
            }

            if (Count > 0)
            {
                list[i] = root;
            }

            return target;
        }

        /// <summary>
        ///     Returns the next element in the queue without dequeuing.
        /// </summary>
        /// <returns>The next element of the queue.</returns>
        public T Peek()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Queue is empty.");
            }

            return list[0];
        }

        /// <summary>
        ///     Clears the Queue.
        /// </summary>
        public void Clear() => list.Clear();

        /// <summary>
        ///     Returns the Internal Data.
        /// </summary>
        /// <returns>The internal data structure.</returns>
        public List<T> GetData() => list;
    }
}
using System;

namespace Algorithms.Search.AStar
{
    /// <summary>
    ///     Contains Positional and other information about a single node.
    /// </summary>
    public class Node : IComparable<Node>, IEquatable<Node>
    {
        public Node(VecN position, bool traversable, double traverseMultiplier)
        {
            Traversable = traversable;
            Position = position;
            TraversalCostMultiplier = traverseMultiplier;
        }

        /// <summary>
        ///     Gets the Total cost of the Node.
        ///     The Current Costs + the estimated costs.
        /// </summary>
        public double TotalCost => EstimatedCost + CurrentCost;

        /// <summary>
        ///     Gets or sets the Distance between this node and the target node.
        /// </summary>
        public double EstimatedCost { get; set; }

        /// <summary>
        ///     Gets a value indicating whether how costly it is to traverse over this node.
        /// </summary>
        public double TraversalCostMultiplier { get; }

        /// <summary>
        ///     Gets or sets a value indicating whether to go from the start node to this node.
        /// </summary>
        public double CurrentCost { get; set; }

        /// <summary>
        ///     Gets or sets the state of the Node
        ///     Can be Unconsidered(Default), Open and Closed.
        /// </summary>
        public NodeState State { get; set; }

        /// <summary>
        ///     Gets a value indicating whether the node is traversable.
        /// </summary>
        public bool Traversable { get; }

        /// <summary>
        ///     Gets or sets a list of all connected nodes.
        /// </summary>
        public Node[] ConnectedNodes { get; set; } = new Node[0];

        /// <summary>
        ///     Gets or sets he "previous" node that was processed before this node.
        /// </summary>
        public Node? Parent { get; set; }

        /// <summary>
        ///     Gets the positional information of the node.
        /// </summary>
        public VecN Position { get; }

        /// <summary>
        ///     Compares the Nodes based on their total costs.
        ///     Total Costs: A* Pathfinding.
        ///     Current: Djikstra Pathfinding.
        ///     Estimated: Greedy Pathfinding.
        /// </summary>
        /// <param name="other">The other node.</param>
        /// <returns>A comparison between the costs.</returns>
        public int CompareTo(Node? other) => TotalCost.CompareTo(other?.TotalCost ?? 0);

        public bool Equals(Node? other) => CompareTo(other) == 0;

        public static bool operator ==(Node left, Node right) => left?.Equals(right) != false;

        public static bool operator >(Node left, Node right) => left.CompareTo(right) > 0;

        public static bool operator <(Node left, Node right) => left.CompareTo(right) < 0;

        public static bool operator !=(Node left, Node right) => !(left == right);

        public static bool operator <=(Node left, Node right) => left.CompareTo(right) <= 0;

        public static bool operator >=(Node left, Node right) => left.CompareTo(right) >= 0;

        public override bool Equals(object? obj) => obj is Node other && Equals(other);

        public override int GetHashCode() =>
            Position.GetHashCode()
            + Traversable.GetHashCode()
            + TraversalCostMultiplier.GetHashCode();

        /// <summary>
        ///     Returns the distance to the other node.
        /// </summary>
        /// <param name="other">The other node.</param>
        /// <returns>Distance between this and other.</returns>
        public double DistanceTo(Node other) => Math.Sqrt(Position.SqrDistance(other.Position));
    }
}
namespace Algorithms.Search.AStar
{
    /// <summary>
    ///     The states the nodes can have.
    /// </summary>
    public enum NodeState
    {
        /// <summary>
        ///     TODO.
        /// </summary>
        Unconsidered = 0,

        /// <summary>
        ///     TODO.
        /// </summary>
        Open = 1,

        /// <summary>
        ///     TODO.
        /// </summary>
        Closed = 2,
    }
}
using System;

namespace Algorithms.Search.AStar
{
    /// <summary>
    ///     A pathfinding exception is thrown when the Pathfinder encounters a critical error and can not continue.
    /// </summary>
    public class PathfindingException : ApplicationException
    {
        public PathfindingException(string message)
            : base(message)
        {
        }
    }
}
using System;

namespace Algorithms.Search.AStar
{
    /// <summary>
    ///     Vector Struct with N Dimensions.
    /// </summary>
    public struct VecN : IEquatable<VecN>
    {
        private readonly double[] data;

        /// <summary>
        ///     Initializes a new instance of the <see cref="VecN" /> struct.
        /// </summary>
        /// <param name="vals">Vector components as array.</param>
        public VecN(params double[] vals) => data = vals;

        /// <summary>
        ///     Gets the dimension count of this vector.
        /// </summary>
        public int N => data.Length;

        /// <summary>
        ///     Returns the Length squared.
        /// </summary>
        /// <returns>The squared length of the vector.</returns>
        public double SqrLength()
        {
            double ret = 0;
            for (var i = 0; i < data.Length; i++)
            {
                ret += data[i] * data[i];
            }

            return ret;
        }

        /// <summary>
        ///     Returns the Length of the vector.
        /// </summary>
        /// <returns>Length of the Vector.</returns>
        public double Length() => Math.Sqrt(SqrLength());

        /// <summary>
        ///     Returns the Distance between this and other.
        /// </summary>
        /// <param name="other">Other vector.</param>
        /// <returns>The distance between this and other.</returns>
        public double Distance(VecN other)
        {
            var delta = Subtract(other);
            return delta.Length();
        }

        /// <summary>
        ///     Returns the squared Distance between this and other.
        /// </summary>
        /// <param name="other">Other vector.</param>
        /// <returns>The squared distance between this and other.</returns>
        public double SqrDistance(VecN other)
        {
            var delta = Subtract(other);
            return delta.SqrLength();
        }

        /// <summary>
        ///     Substracts other from this vector.
        /// </summary>
        /// <param name="other">Other vector.</param>
        /// <returns>The new vector.</returns>
        public VecN Subtract(VecN other)
        {
            var dd = new double[Math.Max(data.Length, other.data.Length)];
            for (var i = 0; i < dd.Length; i++)
            {
                double val = 0;
                if (data.Length > i)
                {
                    val = data[i];
                }

                if (other.data.Length > i)
                {
                    val -= other.data[i];
                }

                dd[i] = val;
            }

            return new VecN(dd);
        }

        /// <summary>
        ///     Is used to compare Vectors with each other.
        /// </summary>
        /// <param name="other">The vector to be compared.</param>
        /// <returns>A value indicating if other has the same values as this.</returns>
        public bool Equals(VecN other)
        {
            if (other.N != N)
            {
                return false;
            }

            for (var i = 0; i < other.data.Length; i++)
            {
                if (Math.Abs(data[i] - other.data[i]) > 0.000001)
                {
                    return false;
                }
            }

            return true;
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Search.AStar
{
    /// <summary>
    ///     Contains the code for A* Pathfinding.
    /// </summary>
    public static class AStar
    {
        /// <summary>
        ///     Resets the Nodes in the list.
        /// </summary>
        /// <param name="nodes">Resets the nodes to be used again.</param>
        public static void ResetNodes(List<Node> nodes)
        {
            foreach (var node in nodes)
            {
                node.CurrentCost = 0;
                node.EstimatedCost = 0;
                node.Parent = null;
                node.State = NodeState.Unconsidered;
            }
        }

        /// <summary>
        ///     Generates the Path from an (solved) node graph, before it gets reset.
        /// </summary>
        /// <param name="target">The node where we want to go.</param>
        /// <returns>The Path to the target node.</returns>
        public static List<Node> GeneratePath(Node target)
        {
            var ret = new List<Node>();
            var current = target;
            while (!(current is null))
            {
                ret.Add(current);
                current = current.Parent;
            }

            ret.Reverse();
            return ret;
        }

        /// <summary>
        ///     Computes the path from => to.
        /// </summary>
        /// <param name="from">Start node.</param>
        /// <param name="to">end node.</param>
        /// <returns>Path from start to end.</returns>
        public static List<Node> Compute(Node from, Node to)
        {
            var done = new List<Node>();

            // A priority queue that will sort our nodes based on the total cost estimate
            var open = new PriorityQueue<Node>();
            foreach (var node in from.ConnectedNodes)
            {
                // Add connecting nodes if traversable
                if (node.Traversable)
                {
                    // Calculate the Costs
                    node.CurrentCost = from.CurrentCost + from.DistanceTo(node) * node.TraversalCostMultiplier;
                    node.EstimatedCost = from.CurrentCost + node.DistanceTo(to);

                    // Enqueue
                    open.Enqueue(node);
                }
            }

            while (true)
            {
                // End Condition( Path not found )
                if (open.Count == 0)
                {
                    ResetNodes(done);
                    ResetNodes(open.GetData());
                    return new List<Node>();
                }

                // Selecting next Element from queue
                var current = open.Dequeue();

                // Add it to the done list
                done.Add(current);

                current.State = NodeState.Closed;

                // EndCondition( Path was found )
                if (current == to)
                {
                    var ret = GeneratePath(to); // Create the Path

                    // Reset all Nodes that were used.
                    ResetNodes(done);
                    ResetNodes(open.GetData());
                    return ret;
                }

                AddOrUpdateConnected(current, to, open);
            }
        }

        private static void AddOrUpdateConnected(Node current, Node to, PriorityQueue<Node> queue)
        {
            foreach (var connected in current.ConnectedNodes)
            {
                if (!connected.Traversable ||
                    connected.State == NodeState.Closed)
                {
                    continue; // Do ignore already checked and not traversable nodes.
                }

                // Adds a previously not "seen" node into the Queue
                if (connected.State == NodeState.Unconsidered)
                {
                    connected.Parent = current;
                    connected.CurrentCost =
                        current.CurrentCost + current.DistanceTo(connected) * connected.TraversalCostMultiplier;
                    connected.EstimatedCost = connected.CurrentCost + connected.DistanceTo(to);
                    connected.State = NodeState.Open;
                    queue.Enqueue(connected);
                }
                else if (current != connected)
                {
                    // Updating the cost of the node if the current way is cheaper than the previous
                    var newCCost = current.CurrentCost + current.DistanceTo(connected);
                    var newTCost = newCCost + current.EstimatedCost;
                    if (newTCost < connected.TotalCost)
                    {
                        connected.Parent = current;
                        connected.CurrentCost = newCCost;
                    }
                }
                else
                {
                    // Codacy made me do it.
                    throw new PathfindingException(
                        "Detected the same node twice. Confusion how this could ever happen");
                }
            }
        }
    }
}
using System;

namespace Algorithms.Search
{
    /// <summary>
    ///     TODO.
    /// </summary>
    /// <typeparam name="T">TODO. 2.</typeparam>
    public class BinarySearcher<T> where T : IComparable<T>
    {
        /// <summary>
        ///     Finds index of item in array that equals to item searched for,
        ///     time complexity: O(log(n)),
        ///     space complexity: O(1),
        ///     where n - array size.
        /// </summary>
        /// <param name="sortedData">Sorted array to search in.</param>
        /// <param name="item">Item to search for.</param>
        /// <returns>Index of item that equals to item searched for or -1 if none found.</returns>
        public int FindIndex(T[] sortedData, T item)
        {
            var leftIndex = 0;
            var rightIndex = sortedData.Length - 1;

            while (leftIndex <= rightIndex)
            {
                var middleIndex = leftIndex + (rightIndex - leftIndex) / 2;

                if (item.CompareTo(sortedData[middleIndex]) > 0)
                {
                    leftIndex = middleIndex + 1;
                    continue;
                }

                if (item.CompareTo(sortedData[middleIndex]) < 0)
                {
                    rightIndex = middleIndex - 1;
                    continue;
                }

                return middleIndex;
            }

            return -1;
        }
    }
}
using System;

namespace Algorithms.Search
{
    /// <summary>
    ///     Jump Search checks fewer elements by jumping ahead by fixed steps.
    ///     The optimal steps to jump is n, where n refers to the number of elements in the array.
    ///     Time Complexity: O(n)
    ///     Note: The array has to be sorted beforehand.
    /// </summary>
    /// <typeparam name="T">Type of the array element.</typeparam>
    public class JumpSearcher<T> where T : IComparable<T>
    {
        /// <summary>
        ///     Find the index of the item searched for in the array.
        /// </summary>
        /// <param name="sortedArray">Sorted array to be search in. Cannot be null.</param>
        /// <param name="searchItem">Item to be search for. Cannot be null.</param>
        /// <returns>If item is found, return index. If array is empty or item not found, return -1.</returns>
        public int FindIndex(T[] sortedArray, T searchItem)
        {
            if (sortedArray is null)
            {
                throw new ArgumentNullException("sortedArray");
            }

            if (searchItem is null)
            {
                throw new ArgumentNullException("searchItem");
            }

            int jumpStep = (int)Math.Floor(Math.Sqrt(sortedArray.Length));
            int currentIndex = 0;
            int nextIndex = jumpStep;

            if (sortedArray.Length != 0)
            {
                while (sortedArray[nextIndex - 1].CompareTo(searchItem) < 0)
                {
                    currentIndex = nextIndex;
                    nextIndex += jumpStep;

                    if (nextIndex >= sortedArray.Length)
                    {
                        nextIndex = sortedArray.Length - 1;
                        break;
                    }
                }

                for (int i = currentIndex; i <= nextIndex; i++)
                {
                    if (sortedArray[i].CompareTo(searchItem) == 0)
                    {
                        return i;
                    }
                }
            }

            return -1;
        }
    }
}
using System;
using Utilities.Exceptions;

namespace Algorithms.Search
{
    /// <summary>
    ///     Class that implements linear search algorithm.
    /// </summary>
    /// <typeparam name="T">Type of array element.</typeparam>
    public class LinearSearcher<T>
    {
        /// <summary>
        ///     Finds first item in array that satisfies specified term
        ///     Time complexity: O(n)
        ///     Space complexity: O(1).
        /// </summary>
        /// <param name="data">Array to search in.</param>
        /// <param name="term">Term to check against.</param>
        /// <returns>First item that satisfies term.</returns>
        public T Find(T[] data, Func<T, bool> term)
        {
            for (var i = 0; i < data.Length; i++)
            {
                if (term(data[i]))
                {
                    return data[i];
                }
            }

            throw new ItemNotFoundException();
        }

        /// <summary>
        ///     Finds index of first item in array that satisfies specified term
        ///     Time complexity: O(n)
        ///     Space complexity: O(1).
        /// </summary>
        /// <param name="data">Array to search in.</param>
        /// <param name="term">Term to check against.</param>
        /// <returns>Index of first item that satisfies term or -1 if none found.</returns>
        public int FindIndex(T[] data, Func<T, bool> term)
        {
            for (var i = 0; i < data.Length; i++)
            {
                if (term(data[i]))
                {
                    return i;
                }
            }

            return -1;
        }
    }
}
using System;
using Utilities.Exceptions;

namespace Algorithms.Search
{
    /// <summary>
    ///     The idea: you could combine the advantages from both binary-search and interpolation search algorithm.
    ///     Time complexity:
    ///     worst case: Item couldn't be found: O(log n),
    ///     average case: O(log log n),
    ///     best case: O(1).
    ///     Note: This algorithm is recursive and the array has to be sorted beforehand.
    /// </summary>
    public class FastSearcher
    {
        /// <summary>
        ///     Finds index of first item in array that satisfies specified term
        ///     throws ItemNotFoundException if the item couldn't be found.
        /// </summary>
        /// <param name="array">Span of sorted numbers which will be used to find the item.</param>
        /// <param name="item">Term to check against.</param>
        /// <returns>Index of first item that satisfies term.</returns>
        /// <exception cref="ItemNotFoundException"> Gets thrown when the given item couldn't be found in the array.</exception>
        public int FindIndex(Span<int> array, int item)
        {
            if (array.Length == 0)
            {
                throw new ItemNotFoundException();
            }

            if (item < array[0] || item > array[^1])
            {
                throw new ItemNotFoundException();
            }

            if (array[0] == array[^1])
            {
                return item == array[0] ? 0 : throw new ItemNotFoundException();
            }

            var (left, right) = ComputeIndices(array, item);
            var (from, to) = SelectSegment(array, left, right, item);

            return from + FindIndex(array.Slice(from, to - from + 1), item);
        }

        private (int left, int right) ComputeIndices(Span<int> array, int item)
        {
            var indexBinary = array.Length / 2;

            int[] section =
            {
                array.Length - 1,
                item - array[0],
                array[^1] - array[0],
            };
            var indexInterpolation = section[0] * section[1] / section[2];

            // Left is min and right is max of the indices
            return indexInterpolation > indexBinary
                ? (indexBinary, indexInterpolation)
                : (indexInterpolation, indexBinary);
        }

        private (int from, int to) SelectSegment(Span<int> array, int left, int right, int item)
        {
            if (item < array[left])
            {
                return (0, left - 1);
            }

            if (item < array[right])
            {
                return (left, right - 1);
            }

            return (right, array.Length - 1);
        }
    }
}
using System;
using System.Linq;

namespace Algorithms.Numeric.Series
{
    /// <summary>
    ///     Maclaurin series calculates nonlinear functions approximation
    ///     starting from point x = 0 in a form of infinite power series:
    ///     f(x) = f(0) + f'(0) * x + ... + (f'n(0) * (x ^ n)) / n! + ...,
    ///     where n is natural number.
    /// </summary>
    public static class Maclaurin
    {
        /// <summary>
        ///     Calculates approximation of e^x function:
        ///     e^x = 1 + x + x^2 / 2! + ... + x^n / n! + ...,
        ///     where n is number of terms (natural number),
        ///     and x is given point (rational number).
        /// </summary>
        /// <param name="x">Given point.</param>
        /// <param name="n">The number of terms in polynomial.</param>
        /// <returns>Approximated value of the function in the given point.</returns>
        public static double Exp(double x, int n) =>
            Enumerable.Range(0, n).Sum(i => ExpTerm(x, i));

        /// <summary>
        ///     Calculates approximation of sin(x) function:
        ///     sin(x) = x - x^3 / 3! + ... + (-1)^n * x^(2*n + 1) / (2*n + 1)! + ...,
        ///     where n is number of terms (natural number),
        ///     and x is given point (rational number).
        /// </summary>
        /// <param name="x">Given point.</param>
        /// <param name="n">The number of terms in polynomial.</param>
        /// <returns>Approximated value of the function in the given point.</returns>
        public static double Sin(double x, int n) =>
            Enumerable.Range(0, n).Sum(i => SinTerm(x, i));

        /// <summary>
        ///     Calculates approximation of cos(x) function:
        ///     cos(x) = 1 - x^2 / 2! + ... + (-1)^n * x^(2*n) / (2*n)! + ...,
        ///     where n is number of terms (natural number),
        ///     and x is given point (rational number).
        /// </summary>
        /// <param name="x">Given point.</param>
        /// <param name="n">The number of terms in polynomial.</param>
        /// <returns>Approximated value of the function in the given point.</returns>
        public static double Cos(double x, int n) =>
            Enumerable.Range(0, n).Sum(i => CosTerm(x, i));

        /// <summary>
        ///     Calculates approximation of e^x function:
        ///     e^x = 1 + x + x^2 / 2! + ... + x^n / n! + ...,
        ///     and x is given point (rational number).
        /// </summary>
        /// <param name="x">Given point.</param>
        /// <param name="error">Last term error value.</param>
        /// <returns>Approximated value of the function in the given point.</returns>
        /// <exception cref="ArgumentException">Error value is not on interval (0.0; 1.0).</exception>
        public static double Exp(double x, double error = 0.00001) => ErrorTermWrapper(x, error, ExpTerm);

        /// <summary>
        ///     Calculates approximation of sin(x) function:
        ///     sin(x) = x - x^3 / 3! + ... + (-1)^n * x^(2*n + 1) / (2*n + 1)! + ...,
        ///     and x is given point (rational number).
        /// </summary>
        /// <param name="x">Given point.</param>
        /// <param name="error">Last term error value.</param>
        /// <returns>Approximated value of the function in the given point.</returns>
        /// <exception cref="ArgumentException">Error value is not on interval (0.0; 1.0).</exception>
        public static double Sin(double x, double error = 0.00001) => ErrorTermWrapper(x, error, SinTerm);

        /// <summary>
        ///     Calculates approximation of cos(x) function:
        ///     cos(x) = 1 - x^2 / 2! + ... + (-1)^n * x^(2*n) / (2*n)! + ...,
        ///     and x is given point (rational number).
        /// </summary>
        /// <param name="x">Given point.</param>
        /// <param name="error">Last term error value.</param>
        /// <returns>Approximated value of the function in the given point.</returns>
        /// <exception cref="ArgumentException">Error value is not on interval (0.0; 1.0).</exception>
        public static double Cos(double x, double error = 0.00001) => ErrorTermWrapper(x, error, CosTerm);

        /// <summary>
        ///     Wrapper function for calculating approximation with estimated
        ///     count of terms, where last term value is less than given error.
        /// </summary>
        /// <param name="x">Given point.</param>
        /// <param name="error">Last term error value.</param>
        /// <param name="term">Indexed term of approximation series.</param>
        /// <returns>Approximated value of the function in the given point.</returns>
        /// <exception cref="ArgumentException">Error value is not on interval (0.0; 1.0).</exception>
        private static double ErrorTermWrapper(double x, double error, Func<double, int, double> term)
        {
            if (error <= 0.0 || error >= 1.0)
            {
                throw new ArgumentException("Error value is not on interval (0.0; 1.0).");
            }

            var i = 0;
            var termCoefficient = 0.0;
            var result = 0.0;

            do
            {
                result += termCoefficient;
                termCoefficient = term(x, i);
                i++;
            }
            while (Math.Abs(termCoefficient) > error);

            return result;
        }

        /// <summary>
        ///     Single term for e^x function approximation: x^i / i!.
        /// </summary>
        /// <param name="x">Given point.</param>
        /// <param name="i">Term index from 0 to n.</param>
        /// <returns>Single term value.</returns>
        private static double ExpTerm(double x, int i) => Math.Pow(x, i) / Factorial.Calculate(i);

        /// <summary>
        ///     Single term for sin(x) function approximation: (-1)^i * x^(2*i + 1) / (2*i + 1)!.
        /// </summary>
        /// <param name="x">Given point.</param>
        /// <param name="i">Term index from 0 to n.</param>
        /// <returns>Single term value.</returns>
        private static double SinTerm(double x, int i) =>
            Math.Pow(-1, i) / Factorial.Calculate(2 * i + 1) * Math.Pow(x, 2 * i + 1);

        /// <summary>
        ///     Single term for cos(x) function approximation: (-1)^i * x^(2*i) / (2*i)!.
        /// </summary>
        /// <param name="x">Given point.</param>
        /// <param name="i">Term index from 0 to n.</param>
        /// <returns>Single term value.</returns>
        private static double CosTerm(double x, int i) =>
            Math.Pow(-1, i) / Factorial.Calculate(2 * i) * Math.Pow(x, 2 * i);
    }
}
using System;

namespace Algorithms.Numeric
{
    /// <summary>
    ///  In number theory, a Keith number or repfigit number is a natural number n in a given number base b with k digits such that
    ///  when a sequence is created such that the first k terms are the k digits of n and each subsequent term is the sum of the
    ///  previous k terms, n is part of the sequence.
    /// </summary>
    public static class KeithNumberChecker
    {
        /// <summary>
        ///     Checks if a number is a Keith number or not.
        /// </summary>
        /// <param name="number">Number to check.</param>
        /// <returns>True if it is a Keith number; False otherwise.</returns>
        public static bool IsKeithNumber(int number)
        {
            if (number < 0)
            {
                throw new ArgumentException($"{nameof(number)} cannot be negative");
            }

            var tempNumber = number;

            var stringNumber = number.ToString();

            var digitsInNumber = stringNumber.Length;

            /* storing the terms of the series */
            var termsArray = new int[number];

            for (var i = digitsInNumber - 1; i >= 0; i--)
            {
                termsArray[i] = tempNumber % 10;
                tempNumber /= 10;
            }

            var sum = 0;
            var k = digitsInNumber;
            while (sum < number)
            {
                sum = 0;

                for (var j = 1; j <= digitsInNumber; j++)
                {
                    sum += termsArray[k - j];
                }

                termsArray[k] = sum;
                k++;
            }

            return sum == number;
        }
    }
}
using System;

namespace Algorithms.Numeric
{
    /// <summary>
    ///     A Narcissistic number is equal to the sum of the cubes of its digits. For example, 370 is a
    ///     Narcissistic number because 3*3*3 + 7*7*7 + 0*0*0 = 370.
    /// </summary>
    public static class NarcissisticNumberChecker
    {
        /// <summary>
        ///     Checks if a number is a Narcissistic number or not.
        /// </summary>
        /// <param name="number">Number to check.</param>
        /// <returns>True if is a Narcissistic number; False otherwise.</returns>
        public static bool IsNarcissistic(int number)
        {
            var sum = 0;
            var temp = number;
            var numberOfDigits = 0;
            while (temp != 0)
            {
                numberOfDigits++;
                temp /= 10;
            }

            temp = number;
            while (number > 0)
            {
                var remainder = number % 10;
                var power = (int)Math.Pow(remainder, numberOfDigits);

                sum += power;
                number /= 10;
            }

            return sum == temp;
        }
    }
}
using System;

namespace Algorithms.Numeric
{
    /// <summary>
    ///     A perfect square is an element of algebraic structure that is equal to the square of another element.
    /// </summary>
    public static class PerfectSquareChecker
    {
        /// <summary>
        ///     Checks if a number is a perfect square or not.
        /// </summary>
        /// <param name="number">Number too check.</param>
        /// <returns>True if is a perfect square; False otherwise.</returns>
        public static bool IsPerfectSquare(int number)
        {
            if (number < 0)
            {
                return false;
            }

            var sqrt = (int)Math.Sqrt(number);
            return sqrt * sqrt == number;
        }
    }
}
namespace Algorithms.Numeric.Factorization
{
    /// <summary>
    ///     Finds a factor of a given number or returns false if it's prime.
    /// </summary>
    public interface IFactorizer
    {
        /// <summary>
        ///     Finds a factor of a given number or returns false if it's prime.
        /// </summary>
        /// <param name="n">Integer to factor.</param>
        /// <param name="factor">Found factor.</param>
        /// <returns><see langword="true" /> if factor is found, <see langword="false" /> if <paramref name="n" /> is prime.</returns>
        bool TryFactor(int n, out int factor);
    }
}
using System;
using System.Linq;

namespace Algorithms.Numeric.Factorization
{
    /// <summary>
    ///     Factors number using trial division algorithm.
    /// </summary>
    public class TrialDivisionFactorizer : IFactorizer
    {
        /// <summary>
        ///     Finds a factor of a given number or returns false if it's prime.
        /// </summary>
        /// <param name="n">Integer to factor.</param>
        /// <param name="factor">Found factor.</param>
        /// <returns><see langword="true" /> if factor is found, <see langword="false" /> if <paramref name="n" /> is prime.</returns>
        public bool TryFactor(int n, out int factor)
        {
            n = Math.Abs(n);
            factor = Enumerable.Range(2, (int)Math.Sqrt(n) - 1).FirstOrDefault(i => n % i == 0);
            return factor != 0;
        }
    }
}
using System;

namespace Algorithms.Numeric
{
    /// <summary>
    ///     Modular exponentiation is a type of exponentiation performed over a modulus
    ///     Modular exponentiation c is: c = b^e mod m where b is base, e is exponent, m is modulus
    ///     (Wiki: https://en.wikipedia.org/wiki/Modular_exponentiation).
    /// </summary>
    public class ModularExponentiation
    {
        /// <summary>
        ///     Performs Modular Exponentiation on b, e, m.
        /// </summary>
        /// <param name="b">Base.</param>
        /// <param name="e">Exponent.</param>
        /// <param name="m">Modulus.</param>
        /// <returns>Modular Exponential.</returns>
        public int ModularPow(int b, int e, int m)
        {
            // initialize result in variable res
            int res = 1;
            if (m == 1)
            {
                // 1 divides every number
                return 0;
            }

            if (m <= 0)
            {
                // exponential not defined in this case
                throw new ArgumentException(string.Format("{0} is not a positive integer", m));
            }

            for (int i = 0; i < e; i++)
            {
                res = (res * b) % m;
            }

            return res;
        }
    }
}
using System;
using Algorithms.Numeric.Decomposition;
using Utilities.Extensions;

namespace Algorithms.Numeric.Pseudoinverse
{
    /// <summary>
    ///     The MoorePenrose pseudo-inverse A+ of a matrix A,
    ///     is a general way to find the solution to the following system of linear equations:
    ///     ~b = A ~y. ~b e R^m; ~y e R^n; A e Rmn.
    ///     There are varios methods for construction the pseudo-inverse.
    ///     This one is based on Singular Value Decomposition (SVD).
    /// </summary>
    public static class PseudoInverse
    {
        /// <summary>
        ///     Return the pseudoinverse of a matrix based on the Moore-Penrose Algorithm.
        ///     using Singular Value Decomposition (SVD).
        /// </summary>
        /// <param name="inMat">Input matrix to find its inverse to.</param>
        /// <returns>The inverse matrix approximation of the input matrix.</returns>
        public static double[,] PInv(double[,] inMat)
        {
            // To compute the SVD of the matrix to find Sigma.
            var (u, s, v) = ThinSvd.Decompose(inMat);

            // To take the reciprocal of each non-zero element on the diagonal.
            var len = s.Length;

            var sigma = new double[len];
            for (var i = 0; i < len; i++)
            {
                sigma[i] = Math.Abs(s[i]) < 0.0001 ? 0 : 1 / s[i];
            }

            // To construct a diagonal matrix based on the vector result.
            var diag = sigma.ToDiagonalMatrix();

            // To construct the pseudo-inverse using the computed information above.
            var matinv = u.Multiply(diag).Multiply(v.Transpose());

            // To Transpose the result matrix.
            return matinv.Transpose();
        }
    }
}
using System;

namespace Algorithms.Numeric
{
    /// <summary>
    ///     The binomial coefficients are the positive integers
    ///     that occur as coefficients in the binomial theorem.
    /// </summary>
    public static class BinomialCoefficient
    {
        /// <summary>
        ///     Calculates Binomial coefficients for given input.
        /// </summary>
        /// <param name="num">First number.</param>
        /// <param name="k">Second number.</param>
        /// <returns>Binimial Coefficients.</returns>
        public static long Calculate(int num, int k)
        {
            if (num < k || k < 0)
            {
                throw new ArgumentException("n  k  0");
            }

            return Factorial.Calculate(num) / (Factorial.Calculate(k) * Factorial.Calculate(num - k));
        }
    }
}
using System;

namespace Algorithms.Numeric.GreatestCommonDivisor
{
    /// <summary>
    ///     Finds greatest common divisor for numbers u and v
    ///     using binary algorithm.
    ///     Wiki: https://en.wikipedia.org/wiki/Binary_GCD_algorithm.
    /// </summary>
    public class BinaryGreatestCommonDivisorFinder : IGreatestCommonDivisorFinder
    {
        public int FindGcd(int u, int v)
        {
            // GCD(0, 0) = 0
            if (u == 0 && v == 0)
            {
                return 0;
            }

            // GCD(0, v) = v; GCD(u, 0) = u
            if (u == 0 || v == 0)
            {
                return u + v;
            }

            // GCD(-a, -b) = GCD(-a, b) = GCD(a, -b) = GCD(a, b)
            u = Math.Sign(u) * u;
            v = Math.Sign(v) * v;

            // Let shift := lg K, where K is the greatest power of 2 dividing both u and v
            var shift = 0;
            while (((u | v) & 1) == 0)
            {
                u >>= 1;
                v >>= 1;
                shift++;
            }

            while ((u & 1) == 0)
            {
                u >>= 1;
            }

            // From here on, u is always odd
            do
            {
                // Remove all factors of 2 in v as they are not common
                // v is not zero, so while will terminate
                while ((v & 1) == 0)
                {
                    v >>= 1;
                }

                // Now u and v are both odd. Swap if necessary so u <= v,
                if (u > v)
                {
                    var t = v;
                    v = u;
                    u = t;
                }

                // Here v >= u and v - u is even
                v -= u;
            }
            while (v != 0);

            // Restore common factors of 2
            return u << shift;
        }
    }
}
namespace Algorithms.Numeric.GreatestCommonDivisor
{
    public interface IGreatestCommonDivisorFinder
    {
        int FindGcd(int a, int b);
    }
}
namespace Algorithms.Numeric.GreatestCommonDivisor
{
    /// <summary>
    ///     TODO.
    /// </summary>
    public class EuclideanGreatestCommonDivisorFinder : IGreatestCommonDivisorFinder
    {
        /// <summary>
        ///     Finds greatest common divisor for numbers a and b
        ///     using euclidean algorithm.
        /// </summary>
        /// <param name="a">TODO.</param>
        /// <param name="b">TODO. 2.</param>
        /// <returns>Greatest common divisor.</returns>
        public int FindGcd(int a, int b)
        {
            if (a == 0 && b == 0)
            {
                return int.MaxValue;
            }

            if (a == 0 || b == 0)
            {
                return a + b;
            }

            var aa = a;
            var bb = b;
            var cc = aa % bb;

            while (cc != 0)
            {
                aa = bb;
                bb = cc;
                cc = aa % bb;
            }

            return bb;
        }
    }
}
using System;

namespace Algorithms.Numeric
{
    /// <summary>
    ///     TODO.
    /// </summary>
    public class GaussJordanElimination
    {
        private int RowCount { get; set; }

        /// <summary>
        ///     Method to find a linear equation system using gaussian elimination.
        /// </summary>
        /// <param name="matrix">The key matrix to solve via algorithm.</param>
        /// <returns>
        ///     whether the input matrix has a unique solution or not.
        ///     and solves on the given matrix.
        /// </returns>
        public bool Solve(double[,] matrix)
        {
            RowCount = matrix.GetUpperBound(0) + 1;

            if (!CanMatrixBeUsed(matrix))
            {
                throw new ArgumentException("Please use a n*(n+1) matrix with Length > 0.");
            }

            var pivot = PivotMatrix(ref matrix);
            if (!pivot)
            {
                return false;
            }

            Elimination(ref matrix);

            return ElementaryReduction(ref matrix);
        }

        /// <summary>
        ///     To make simple validation of the matrix to be used.
        /// </summary>
        /// <param name="matrix">Multidimensional array matrix.</param>
        /// <returns>
        ///     True: if algorithm can be use for given matrix;
        ///     False: Otherwise.
        /// </returns>
        private bool CanMatrixBeUsed(double[,] matrix) => matrix?.Length == RowCount * (RowCount + 1) && RowCount > 1;

        /// <summary>
        ///     To prepare given matrix by pivoting rows.
        /// </summary>
        /// <param name="matrix">Input matrix.</param>
        /// <returns>Matrix.</returns>
        private bool PivotMatrix(ref double[,] matrix)
        {
            for (var col = 0; col + 1 < RowCount; col++)
            {
                if (matrix[col, col] == 0)
                {
                    // To find a non-zero coefficient
                    var rowToSwap = FindNonZeroCoefficient(ref matrix, col);

                    if (matrix[rowToSwap, col] != 0)
                    {
                        var tmp = new double[RowCount + 1];
                        for (var i = 0; i < RowCount + 1; i++)
                        {
                            // To make the swap with the element above.
                            tmp[i] = matrix[rowToSwap, i];
                            matrix[rowToSwap, i] = matrix[col, i];
                            matrix[col, i] = tmp[i];
                        }
                    }
                    else
                    {
                        // To return that the matrix doesn't have a unique solution.
                        return false;
                    }
                }
            }

            return true;
        }

        private int FindNonZeroCoefficient(ref double[,] matrix, int col)
        {
            var rowToSwap = col + 1;

            // To find a non-zero coefficient
            for (; rowToSwap < RowCount; rowToSwap++)
            {
                if (matrix[rowToSwap, col] != 0)
                {
                    return rowToSwap;
                }
            }

            return col + 1;
        }

        /// <summary>
        ///     Applies REF.
        /// </summary>
        /// <param name="matrix">Input matrix.</param>
        private void Elimination(ref double[,] matrix)
        {
            for (var srcRow = 0; srcRow + 1 < RowCount; srcRow++)
            {
                for (var destRow = srcRow + 1; destRow < RowCount; destRow++)
                {
                    var df = matrix[srcRow, srcRow];
                    var sf = matrix[destRow, srcRow];

                    for (var i = 0; i < RowCount + 1; i++)
                    {
                        matrix[destRow, i] = matrix[destRow, i] * df - matrix[srcRow, i] * sf;
                    }
                }
            }
        }

        /// <summary>
        ///     To continue reducing the matrix using RREF.
        /// </summary>
        /// <param name="matrix">Input matrix.</param>
        /// <returns>True if it has a unique solution; false otherwise.</returns>
        private bool ElementaryReduction(ref double[,] matrix)
        {
            for (var row = RowCount - 1; row >= 0; row--)
            {
                var element = matrix[row, row];
                if (element == 0)
                {
                    return false;
                }

                for (var i = 0; i < RowCount + 1; i++)
                {
                    matrix[row, i] /= element;
                }

                for (var destRow = 0; destRow < row; destRow++)
                {
                    matrix[destRow, RowCount] -= matrix[destRow, row] * matrix[row, RowCount];
                    matrix[destRow, row] = 0;
                }
            }

            return true;
        }
    }
}
using System;
using System.Numerics;

namespace Algorithms.Numeric
{
    /// <summary>
    /// https://en.wikipedia.org/wiki/Miller-Rabin_primality_test
    /// The MillerRabin primality test or RabinMiller primality test is a probabilistic primality test:
    /// an algorithm which determines whether a given number is likely to be prime,
    /// similar to the Fermat primality test and the SolovayStrassen primality test.
    /// It is of historical significance in the search for a polynomial-time deterministic primality test.
    /// Its probabilistic variant remains widely used in practice, as one of the simplest and fastest tests known.
    /// </summary>
    public static class MillerRabinPrimalityChecker
    {
        /// <summary>
        ///     Run the probabilistic primality test.
        ///     </summary>
        /// <param name="n">Number to check.</param>
        /// <param name="rounds">Number of rounds, the parameter determines the accuracy of the test, recommended value is Log2(n).</param>
        /// <returns>True if is a highly likely prime number; False otherwise.</returns>
        /// <exception cref="ArgumentException">Error: number should be morhe than 3.</exception>
        public static bool IsProbablyPrimeNumber(BigInteger n, BigInteger rounds)
        {
            if (n <= 3)
            {
                throw new ArgumentException($"{nameof(n)} should be more than 3");
            }

            // Input #1: n > 3, an odd integer to be tested for primality
            // Input #2: k, the number of rounds of testing to perform, recommended k = Log2(n)
            // Output:   false = composite
            //           true  = probably prime

            // write n as 2rd + 1 with d odd(by factoring out powers of 2 from n  1)
            BigInteger r = 0;
            BigInteger d = n - 1;
            while (d % 2 == 0)
            {
                r++;
                d /= 2;
            }

            BigInteger x;
            Random rand = new();

            // as there is no native random function for BigInteger we suppose a random int number is sufficient
            int nMaxValue = (n > int.MaxValue) ? int.MaxValue : (int)n;
            BigInteger a = rand.Next(2, nMaxValue - 2); // ; pick a random integer a in the range[2, n  2]

            while (rounds > 0)
            {
                rounds--;
                x = BigInteger.ModPow(a, d, n);
                if (x == 1 || x == (n - 1))
                {
                    continue;
                }

                BigInteger tempr = r - 1;
                while (tempr > 0 && (x != n - 1))
                {
                    tempr--;
                    x = BigInteger.ModPow(x, 2, n);
                }

                if (x == n - 1)
                {
                    continue;
                }

                return false;
            }

            return true;
        }
    }
}
using System;

namespace Algorithms.Numeric
{
    /// <summary>
    ///     In number theory, a perfect number is a positive integer that is equal to the sum of its positive
    ///     divisors, excluding the number itself.For instance, 6 has divisors 1, 2 and 3 (excluding
    ///     itself), and 1 + 2 + 3 = 6, so 6 is a perfect number.
    /// </summary>
    public static class PerfectNumberChecker
    {
        /// <summary>
        ///     Checks if a number is a perfect number or not.
        /// </summary>
        /// <param name="number">Number to check.</param>
        /// <returns>True if is a perfect number; False otherwise.</returns>
        /// <exception cref="ArgumentException">Error number is not on interval (0.0; int.MaxValue).</exception>
        public static bool IsPerfectNumber(int number)
        {
            if (number < 0)
            {
                throw new ArgumentException($"{nameof(number)} cannot be negative");
            }

            var sum = 0; /* sum of its positive divisors */
            for (var i = 1; i < number; ++i)
            {
                if (number % i == 0)
                {
                    sum += i;
                }
            }

            return sum == number;
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Numeric
{
    /// <summary>
    ///     In mathematics and computational science, the Euler method (also called forward Euler method)
    ///     is a first-order numerical procedure for solving ordinary differential equations (ODEs)
    ///     with a given initial value (aka. Cauchy problem). It is the most basic explicit method for numerical integration
    ///     of ordinary differential equations. The method proceeds in a series of steps. At each step
    ///     the y-value is calculated by evaluating the differential equation at the previous step,
    ///     multiplying the result with the step-size and adding it to the last y-value:
    ///     y_n+1 = y_n + stepSize * f(x_n, y_n).
    ///     (description adapted from https://en.wikipedia.org/wiki/Euler_method )
    ///     (see also: https://www.geeksforgeeks.org/euler-method-solving-differential-equation/ ).
    /// </summary>
    public static class EulerMethod
    {
        /// <summary>
        ///     Loops through all the steps until xEnd is reached, adds a point for each step and then
        ///     returns all the points.
        /// </summary>
        /// <param name="xStart">Initial conditions x-value.</param>
        /// <param name="xEnd">Last x-value.</param>
        /// <param name="stepSize">Step-size on the x-axis.</param>
        /// <param name="yStart">Initial conditions y-value.</param>
        /// <param name="yDerivative">The right hand side of the differential equation.</param>
        /// <returns>The solution of the Cauchy problem.</returns>
        public static List<double[]> EulerFull(
            double xStart,
            double xEnd,
            double stepSize,
            double yStart,
            Func<double, double, double> yDerivative)
        {
            if (xStart >= xEnd)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(xEnd),
                    $"{nameof(xEnd)} should be greater than {nameof(xStart)}");
            }

            if (stepSize <= 0)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(stepSize),
                    $"{nameof(stepSize)} should be greater than zero");
            }

            List<double[]> points = new();
            double[] firstPoint = { xStart, yStart };
            points.Add(firstPoint);
            var yCurrent = yStart;
            var xCurrent = xStart;

            while (xCurrent < xEnd)
            {
                yCurrent = EulerStep(xCurrent, stepSize, yCurrent, yDerivative);
                xCurrent += stepSize;
                double[] point = { xCurrent, yCurrent };
                points.Add(point);
            }

            return points;
        }

        /// <summary>
        ///     Calculates the next y-value based on the current value of x, y and the stepSize.
        /// </summary>
        /// <param name="xCurrent">Current x-value.</param>
        /// <param name="stepSize">Step-size on the x-axis.</param>
        /// <param name="yCurrent">Current y-value.</param>
        /// <param name="yDerivative">The right hand side of the differential equation.</param>
        /// <returns>The next y-value.</returns>
        private static double EulerStep(
            double xCurrent,
            double stepSize,
            double yCurrent,
            Func<double, double, double> yDerivative)
        {
            var yNext = yCurrent + stepSize * yDerivative(xCurrent, yCurrent);
            return yNext;
        }
    }
}
using System;

namespace Algorithms.Numeric
{
    /// <summary>
    ///     In number theory, the aliquot sum s(n) of a positive integer n is the sum of all proper divisors
    ///     of n, that is, all divisors of n other than n itself. For example, the proper divisors of 15
    ///     (that is, the positive divisors of 15 that are not equal to 15) are 1, 3 and 5, so the aliquot
    ///     sum of 15 is 9 i.e. (1 + 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum.
    /// </summary>
    public static class AliquotSumCalculator
    {
        /// <summary>
        ///     Finds the aliquot sum of an integer number.
        /// </summary>
        /// <param name="number">Positive number.</param>
        /// <returns>The Aliquot Sum.</returns>
        /// <exception cref="ArgumentException">Error number is not on interval (0.0; int.MaxValue).</exception>
        public static int CalculateAliquotSum(int number)
        {
            if (number < 0)
            {
                throw new ArgumentException($"{nameof(number)} cannot be negative");
            }

            var sum = 0;
            for (int i = 1, limit = number / 2; i <= limit; ++i)
            {
                if (number % i == 0)
                {
                    sum += i;
                }
            }

            return sum;
        }
    }
}
using System;
using Utilities.Extensions;
using M = Utilities.Extensions.MatrixExtensions;
using V = Utilities.Extensions.VectorExtensions;

namespace Algorithms.Numeric.Decomposition
{
    /// <summary>
    ///     Singular Vector Decomposition decomposes any general matrix into its
    ///     singular values and a set of orthonormal bases.
    /// </summary>
    public static class ThinSvd
    {
        /// <summary>
        ///     Computes a random unit vector.
        /// </summary>
        /// <param name="dimensions">The dimensions of the required vector.</param>
        /// <returns>The unit vector.</returns>
        public static double[] RandomUnitVector(int dimensions)
        {
            Random random = new();
            double[] result = new double[dimensions];
            for (var i = 0; i < dimensions; i++)
            {
                result[i] = 2 * random.NextDouble() - 1;
            }

            var magnitude = result.Magnitude();
            result = result.Scale(1 / magnitude);
            return result;
        }

        /// <summary>
        ///     Computes a single singular vector for the given matrix, corresponding to the largest singular value.
        /// </summary>
        /// <param name="matrix">The matrix.</param>
        /// <returns>A singular vector, with dimension equal to number of columns of the matrix.</returns>
        public static double[] Decompose1D(double[,] matrix) =>
            Decompose1D(matrix, 1E-5, 100);

        /// <summary>
        ///     Computes a single singular vector for the given matrix, corresponding to the largest singular value.
        /// </summary>
        /// <param name="matrix">The matrix.</param>
        /// <param name="epsilon">The error margin.</param>
        /// <param name="maxIterations">The maximum number of iterations.</param>
        /// <returns>A singular vector, with dimension equal to number of columns of the matrix.</returns>
        public static double[] Decompose1D(double[,] matrix, double epsilon, int maxIterations)
        {
            var n = matrix.GetLength(1);
            var iterations = 0;
            double mag;
            double[] lastIteration;
            double[] currIteration = RandomUnitVector(n);
            double[,] b = matrix.Transpose().Multiply(matrix);
            do
            {
                lastIteration = currIteration.Copy();
                currIteration = b.MultiplyVector(lastIteration);
                currIteration = currIteration.Scale(100);
                mag = currIteration.Magnitude();
                if (mag > epsilon)
                {
                    currIteration = currIteration.Scale(1 / mag);
                }

                iterations++;
            }
            while (lastIteration.Dot(currIteration) < 1 - epsilon && iterations < maxIterations);

            return currIteration;
        }

        public static (double[,] U, double[] S, double[,] V) Decompose(double[,] matrix) =>
            Decompose(matrix, 1E-5, 100);

        /// <summary>
        ///     Computes the SVD for the given matrix, with singular values arranged from greatest to least.
        /// </summary>
        /// <param name="matrix">The matrix.</param>
        /// <param name="epsilon">The error margin.</param>
        /// <param name="maxIterations">The maximum number of iterations.</param>
        /// <returns>The SVD.</returns>
        public static (double[,] U, double[] S, double[,] V) Decompose(
            double[,] matrix,
            double epsilon,
            int maxIterations)
        {
            var m = matrix.GetLength(0);
            var n = matrix.GetLength(1);
            var numValues = Math.Min(m, n);

            // sigmas is be a diagonal matrix, hence only a vector is needed
            double[] sigmas = new double[numValues];
            double[,] us = new double[m, numValues];
            double[,] vs = new double[n, numValues];

            // keep track of progress
            double[,] remaining = matrix.Copy();

            // for each singular value
            for (var i = 0; i < numValues; i++)
            {
                // compute the v singular vector
                double[] v = Decompose1D(remaining, epsilon, maxIterations);
                double[] u = matrix.MultiplyVector(v);

                // compute the contribution of this pair of singular vectors
                double[,] contrib = u.OuterProduct(v);

                // extract the singular value
                var s = u.Magnitude();

                // v and u should be unit vectors
                if (s < epsilon)
                {
                    u = new double[m];
                    v = new double[n];
                }
                else
                {
                    u = u.Scale(1 / s);
                }

                // save u, v and s into the result
                for (var j = 0; j < u.Length; j++)
                {
                    us[j, i] = u[j];
                }

                for (var j = 0; j < v.Length; j++)
                {
                    vs[j, i] = v[j];
                }

                sigmas[i] = s;

                // remove the contribution of this pair and compute the rest
                remaining = remaining.Subtract(contrib);
            }

            return (U: us, S: sigmas, V: vs);
        }
    }
}
using System;

namespace Algorithms.Numeric.Decomposition
{
    /// <summary>
    ///     LU-decomposition factors the "source" matrix as the product of lower triangular matrix
    ///     and upper triangular matrix.
    /// </summary>
    public static class Lu
    {
        /// <summary>
        ///     Performs LU-decomposition on "source" matrix.
        ///     Lower and upper matrices have same shapes as source matrix.
        ///     Note: Decomposition can be applied only to square matrices.
        /// </summary>
        /// <param name="source">Square matrix to decompose.</param>
        /// <returns>Tuple of lower and upper matrix.</returns>
        /// <exception cref="ArgumentException">Source matrix is not square shaped.</exception>
        public static (double[,] L, double[,] U) Decompose(double[,] source)
        {
            if (source.GetLength(0) != source.GetLength(1))
            {
                throw new ArgumentException("Source matrix is not square shaped.");
            }

            var pivot = source.GetLength(0);
            var lower = new double[pivot, pivot];
            var upper = new double[pivot, pivot];

            for (var i = 0; i < pivot; i++)
            {
                for (var k = i; k < pivot; k++)
                {
                    double sum = 0;

                    for (var j = 0; j < i; j++)
                    {
                        sum += lower[i, j] * upper[j, k];
                    }

                    upper[i, k] = source[i, k] - sum;
                }

                for (var k = i; k < pivot; k++)
                {
                    if (i == k)
                    {
                        lower[i, i] = 1;
                    }
                    else
                    {
                        double sum = 0;

                        for (var j = 0; j < i; j++)
                        {
                            sum += lower[k, j] * upper[j, i];
                        }

                        lower[k, i] = (source[k, i] - sum) / upper[i, i];
                    }
                }
            }

            return (L: lower, U: upper);
        }

        /// <summary>
        ///     Eliminates linear equations system represented as A*x=b, using LU-decomposition,
        ///     where A - matrix of equation coefficients, b - vector of absolute terms of equations.
        /// </summary>
        /// <param name="matrix">Matrix of equation coefficients.</param>
        /// <param name="coefficients">Vector of absolute terms of equations.</param>
        /// <returns>Vector-solution for linear equations system.</returns>
        /// <exception cref="ArgumentException">Matrix of equation coefficients is not square shaped.</exception>
        public static double[] Eliminate(double[,] matrix, double[] coefficients)
        {
            if (matrix.GetLength(0) != matrix.GetLength(1))
            {
                throw new ArgumentException("Matrix of equation coefficients is not square shaped.");
            }

            var pivot = matrix.GetLength(0);
            var upperTransform = new double[pivot, 1]; // U * upperTransform = coefficients
            var solution = new double[pivot]; // L * solution = upperTransform
            (double[,] l, double[,] u) = Decompose(matrix);

            for (var i = 0; i < pivot; i++)
            {
                double pivotPointSum = 0;

                for (var j = 0; j < i; j++)
                {
                    pivotPointSum += upperTransform[j, 0] * l[i, j];
                }

                upperTransform[i, 0] = (coefficients[i] - pivotPointSum) / l[i, i];
            }

            for (var i = pivot - 1; i >= 0; i--)
            {
                double pivotPointSum = 0;

                for (var j = i; j < pivot; j++)
                {
                    pivotPointSum += solution[j] * u[i, j];
                }

                solution[i] = (upperTransform[i, 0] - pivotPointSum) / u[i, i];
            }

            return solution;
        }
    }
}
using System;

namespace Algorithms.Numeric
{
    /// <summary>
    ///     The factorial of a positive integer n, denoted by n!,
    ///     is the product of all positive integers less than or equal to n.
    /// </summary>
    public static class Factorial
    {
        /// <summary>
        ///     Calculates factorial of a number.
        /// </summary>
        /// <param name="num">Input number.</param>
        /// <returns>Factorial of input number.</returns>
        public static long Calculate(int num)
        {
            if (num < 0)
            {
                throw new ArgumentException("Only for num >= 0");
            }

            return num == 0 ? 1 : num * Calculate(num - 1);
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using Algorithms.Sorters.Comparison;
using Utilities.Extensions;

namespace Algorithms.DataCompression
{
    /// <summary>
    ///     Greedy lossless compression algorithm.
    /// </summary>
    public class HuffmanCompressor
    {
        // TODO: Use partial sorter
        private readonly IComparisonSorter<ListNode> sorter;
        private readonly Translator translator;

        public HuffmanCompressor(IComparisonSorter<ListNode> sorter, Translator translator)
        {
            this.sorter = sorter;
            this.translator = translator;
        }

        /// <summary>
        ///     Given an input string, returns a new compressed string
        ///     using huffman encoding.
        /// </summary>
        /// <param name="uncompressedText">Text message to compress.</param>
        /// <returns>Compressed string and keys to decompress it.</returns>
        public (string compressedText, Dictionary<string, string> decompressionKeys) Compress(string uncompressedText)
        {
            if (string.IsNullOrEmpty(uncompressedText))
            {
                return (string.Empty, new Dictionary<string, string>());
            }

            if (uncompressedText.Distinct().Count() == 1)
            {
                var dict = new Dictionary<string, string>
                {
                    { "1", uncompressedText[0].ToString() },
                };
                return (new string('1', uncompressedText.Length), dict);
            }

            var nodes = GetListNodesFromText(uncompressedText);
            var tree = GenerateHuffmanTree(nodes);
            var (compressionKeys, decompressionKeys) = GetKeys(tree);
            return (translator.Translate(uncompressedText, compressionKeys), decompressionKeys);
        }

        /// <summary>
        ///     Finds frequency for each character in the text.
        /// </summary>
        /// <returns>Symbol-frequency array.</returns>
        private static ListNode[] GetListNodesFromText(string text)
        {
            var occurenceCounts = new Dictionary<char, int>();

            foreach (var ch in text)
            {
                if (!occurenceCounts.ContainsKey(ch))
                {
                    occurenceCounts.Add(ch, 0);
                }

                occurenceCounts[ch]++;
            }

            return occurenceCounts.Select(kvp => new ListNode(kvp.Key, 1d * kvp.Value / text.Length)).ToArray();
        }

        private (Dictionary<string, string> compressionKeys, Dictionary<string, string> decompressionKeys) GetKeys(
            ListNode tree)
        {
            var compressionKeys = new Dictionary<string, string>();
            var decompressionKeys = new Dictionary<string, string>();

            if (tree.HasData)
            {
                compressionKeys.Add(tree.Data.ToString(), string.Empty);
                decompressionKeys.Add(string.Empty, tree.Data.ToString());
                return (compressionKeys, decompressionKeys);
            }

            if (tree.LeftChild is not null)
            {
                var (lsck, lsdk) = GetKeys(tree.LeftChild);
                compressionKeys.AddMany(lsck.Select(kvp => (kvp.Key, "0" + kvp.Value)));
                decompressionKeys.AddMany(lsdk.Select(kvp => ("0" + kvp.Key, kvp.Value)));
            }

            if (tree.RightChild is not null)
            {
                var (rsck, rsdk) = GetKeys(tree.RightChild);
                compressionKeys.AddMany(rsck.Select(kvp => (kvp.Key, "1" + kvp.Value)));
                decompressionKeys.AddMany(rsdk.Select(kvp => ("1" + kvp.Key, kvp.Value)));

                return (compressionKeys, decompressionKeys);
            }

            return (compressionKeys, decompressionKeys);
        }

        private ListNode GenerateHuffmanTree(ListNode[] nodes)
        {
            var comparer = new ListNodeComparer();
            while (nodes.Length > 1)
            {
                sorter.Sort(nodes, comparer);

                var left = nodes[0];
                var right = nodes[1];

                var newNodes = new ListNode[nodes.Length - 1];
                Array.Copy(nodes, 2, newNodes, 1, nodes.Length - 2);
                newNodes[0] = new ListNode(left, right);
                nodes = newNodes;
            }

            return nodes[0];
        }

        /// <summary>
        ///     Represents tree structure for the algorithm.
        /// </summary>
        public class ListNode
        {
            public ListNode(char data, double frequency)
            {
                HasData = true;
                Data = data;
                Frequency = frequency;
            }

            public ListNode(ListNode leftChild, ListNode rightChild)
            {
                LeftChild = leftChild;
                RightChild = rightChild;
                Frequency = leftChild.Frequency + rightChild.Frequency;
            }

            public char Data { get; }

            public bool HasData { get; }

            public double Frequency { get; }

            public ListNode? RightChild { get; }

            public ListNode? LeftChild { get; }
        }

        public class ListNodeComparer : IComparer<ListNode>
        {
            public int Compare(ListNode? x, ListNode? y)
            {
                if (x is null || y is null)
                {
                    return 0;
                }

                return x.Frequency.CompareTo(y.Frequency);
            }
        }
    }
}
using System.Collections.Generic;
using System.Text;

namespace Algorithms.DataCompression
{
    /// <summary>
    ///     TODO.
    /// </summary>
    public class Translator
    {
        /// <summary>
        ///     TODO.
        /// </summary>
        /// <param name="text">TODO. 2.</param>
        /// <param name="translationKeys">TODO. 3.</param>
        /// <returns>TODO. 4.</returns>
        public string Translate(string text, Dictionary<string, string> translationKeys)
        {
            var sb = new StringBuilder();

            var start = 0;
            for (var i = 0; i < text.Length; i++)
            {
                var key = text.Substring(start, i - start + 1);
                if (translationKeys.ContainsKey(key))
                {
                    _ = sb.Append(translationKeys[key]);
                    start = i + 1;
                }
            }

            return sb.ToString();
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using Algorithms.Knapsack;
using Utilities.Extensions;

namespace Algorithms.DataCompression
{
    /// <summary>
    ///     Greedy lossless compression algorithm.
    /// </summary>
    public class ShannonFanoCompressor
    {
        private readonly IHeuristicKnapsackSolver<(char symbol, double frequency)> splitter;
        private readonly Translator translator;

        public ShannonFanoCompressor(
            IHeuristicKnapsackSolver<(char symbol, double frequency)> splitter,
            Translator translator)
        {
            this.splitter = splitter;
            this.translator = translator;
        }

        /// <summary>
        ///     Given an input string, returns a new compressed string
        ///     using Shannon-Fano encoding.
        /// </summary>
        /// <param name="uncompressedText">Text message to compress.</param>
        /// <returns>Compressed string and keys to decompress it.</returns>
        public (string compressedText, Dictionary<string, string> decompressionKeys) Compress(string uncompressedText)
        {
            if (string.IsNullOrEmpty(uncompressedText))
            {
                return (string.Empty, new Dictionary<string, string>());
            }

            if (uncompressedText.Distinct().Count() == 1)
            {
                var dict = new Dictionary<string, string>
                {
                    { "1", uncompressedText[0].ToString() },
                };
                return (new string('1', uncompressedText.Length), dict);
            }

            var node = GetListNodeFromText(uncompressedText);
            var tree = GenerateShannonFanoTree(node);
            var (compressionKeys, decompressionKeys) = GetKeys(tree);
            return (translator.Translate(uncompressedText, compressionKeys), decompressionKeys);
        }

        private (Dictionary<string, string> compressionKeys, Dictionary<string, string> decompressionKeys) GetKeys(
            ListNode tree)
        {
            var compressionKeys = new Dictionary<string, string>();
            var decompressionKeys = new Dictionary<string, string>();

            if (tree.Data.Length == 1)
            {
                compressionKeys.Add(tree.Data[0].symbol.ToString(), string.Empty);
                decompressionKeys.Add(string.Empty, tree.Data[0].symbol.ToString());
                return (compressionKeys, decompressionKeys);
            }

            if (tree.LeftChild is not null)
            {
                var (lsck, lsdk) = GetKeys(tree.LeftChild);
                compressionKeys.AddMany(lsck.Select(kvp => (kvp.Key, "0" + kvp.Value)));
                decompressionKeys.AddMany(lsdk.Select(kvp => ("0" + kvp.Key, kvp.Value)));
            }

            if (tree.RightChild is not null)
            {
                var (rsck, rsdk) = GetKeys(tree.RightChild);
                compressionKeys.AddMany(rsck.Select(kvp => (kvp.Key, "1" + kvp.Value)));
                decompressionKeys.AddMany(rsdk.Select(kvp => ("1" + kvp.Key, kvp.Value)));
            }

            return (compressionKeys, decompressionKeys);
        }

        private ListNode GenerateShannonFanoTree(ListNode node)
        {
            if (node.Data.Length == 1)
            {
                return node;
            }

            var left = splitter.Solve(node.Data, 0.5 * node.Data.Sum(x => x.frequency), x => x.frequency, _ => 1);
            var right = node.Data.Except(left).ToArray();

            node.LeftChild = GenerateShannonFanoTree(new ListNode(left));
            node.RightChild = GenerateShannonFanoTree(new ListNode(right));

            return node;
        }

        /// <summary>
        ///     Finds frequency for each character in the text.
        /// </summary>
        /// <returns>Symbol-frequency array.</returns>
        private ListNode GetListNodeFromText(string text)
        {
            var occurenceCounts = new Dictionary<char, double>();

            for (var i = 0; i < text.Length; i++)
            {
                var ch = text[i];
                if (!occurenceCounts.ContainsKey(ch))
                {
                    occurenceCounts.Add(ch, 0);
                }

                occurenceCounts[ch]++;
            }

            return new ListNode(occurenceCounts.Select(kvp => (kvp.Key, 1d * kvp.Value / text.Length)).ToArray());
        }

        /// <summary>
        ///     Represents tree structure for the algorithm.
        /// </summary>
        public class ListNode
        {
            public ListNode((char symbol, double frequency)[] data) => Data = data;

            public (char symbol, double frequency)[] Data { get; }

            public ListNode? RightChild { get; set; }

            public ListNode? LeftChild { get; set; }
        }
    }
}
using System;
using System.Linq;

namespace Algorithms.DataCompression
{
    /// <summary>
    ///     The BurrowsWheeler transform (BWT) rearranges a character string into runs of similar characters.
    ///     This is useful for compression, since it tends to be easy to compress a string that has runs of repeated
    ///     characters.
    ///     See <a href="https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform">here</a> for more info.
    /// </summary>
    public class BurrowsWheelerTransform
    {
        /// <summary>
        ///     Encodes the input string using BWT and returns encoded string and the index of original string in the sorted
        ///     rotation matrix.
        /// </summary>
        /// <param name="s">Input string.</param>
        public (string encoded, int index) Encode(string s)
        {
            if (s.Length == 0)
            {
                return (string.Empty, 0);
            }

            var rotations = GetRotations(s);
            Array.Sort(rotations, StringComparer.Ordinal);
            var lastColumn = rotations
                .Select(x => x[^1])
                .ToArray();
            var encoded = new string(lastColumn);
            return (encoded, Array.IndexOf(rotations, s));
        }

        /// <summary>
        ///     Decodes the input string and returns original string.
        /// </summary>
        /// <param name="s">Encoded string.</param>
        /// <param name="index">Index  of original string in the sorted rotation matrix.</param>
        public string Decode(string s, int index)
        {
            if (s.Length == 0)
            {
                return string.Empty;
            }

            var rotations = new string[s.Length];

            for (var i = 0; i < s.Length; i++)
            {
                for (var j = 0; j < s.Length; j++)
                {
                    rotations[j] = s[j] + rotations[j];
                }

                Array.Sort(rotations, StringComparer.Ordinal);
            }

            return rotations[index];
        }

        private string[] GetRotations(string s)
        {
            var result = new string[s.Length];

            for (var i = 0; i < s.Length; i++)
            {
                result[i] = s.Substring(i) + s.Substring(0, i);
            }

            return result;
        }
    }
}
using System;
using System.Linq;
using Algorithms.Numeric;

namespace Algorithms.Encoders
{
    /// <summary>
    ///     Lester S. Hill's polygraphic substitution cipher,
    ///     without representing letters using mod26, using
    ///     corresponding "(char)value" instead.
    /// </summary>
    public class HillEncoder : IEncoder<double[,]>
    {
        private readonly GaussJordanElimination linearEquationSolver;

        public HillEncoder() => linearEquationSolver = new GaussJordanElimination(); // TODO: add DI

        public string Encode(string text, double[,] key)
        {
            var preparedText = FillGaps(text);
            var chunked = ChunkTextToArray(preparedText);
            var splitted = SplitToCharArray(chunked);

            var ciphered = new double[chunked.Length][];

            for (var i = 0; i < chunked.Length; i++)
            {
                var vector = new double[3];
                Array.Copy(splitted, i * 3, vector, 0, 3);
                var product = MatrixCipher(vector, key);
                ciphered[i] = product;
            }

            var merged = MergeArrayList(ciphered);

            return BuildStringFromArray(merged);
        }

        public string Decode(string text, double[,] key)
        {
            var chunked = ChunkTextToArray(text);
            var split = SplitToCharArray(chunked);

            var deciphered = new double[chunked.Length][];

            for (var i = 0; i < chunked.Length; i++)
            {
                var vector = new double[3];
                Array.Copy(split, i * 3, vector, 0, 3);
                var product = MatrixDeCipher(vector, key);
                deciphered[i] = product;
            }

            var merged = MergeArrayList(deciphered);
            var str = BuildStringFromArray(merged);

            return UnFillGaps(str);
        }

        /// <summary>
        ///     Converts elements from the array to their corresponding Unicode characters.
        /// </summary>
        /// <param name="arr">array of vectors.</param>
        /// <returns>Message.</returns>
        private static string BuildStringFromArray(double[] arr) => new(arr.Select(c => (char)c).ToArray());

        /// <summary>
        ///     Multiplies the key for the given scalar.
        /// </summary>
        /// <param name="vector">list of splitted words as numbers.</param>
        /// <param name="key">Cipher selected key.</param>
        /// <returns>Ciphered vector.</returns>
        private static double[] MatrixCipher(double[] vector, double[,] key)
        {
            var multiplied = new double[vector.Length];

            for (var i = 0; i < key.GetLength(1); i++)
            {
                for (var j = 0; j < key.GetLength(0); j++)
                {
                    multiplied[i] += key[i, j] * vector[j];
                }
            }

            return multiplied;
        }

        /// <summary>
        ///     Given a list of vectors, returns a single array of elements.
        /// </summary>
        /// <param name="list">List of ciphered arrays.</param>
        /// <returns>unidimensional list.</returns>
        private static double[] MergeArrayList(double[][] list)
        {
            var merged = new double[list.Length * 3];

            for (var i = 0; i < list.Length; i++)
            {
                Array.Copy(list[i], 0, merged, i * 3, list[0].Length);
            }

            return merged;
        }

        /// <summary>
        ///     Splits the input text message as chunks of words.
        /// </summary>
        /// <param name="chunked">chunked words list.</param>
        /// <returns>spliiter char array.</returns>
        private static char[] SplitToCharArray(string[] chunked)
        {
            var splitted = new char[chunked.Length * 3];

            for (var i = 0; i < chunked.Length; i++)
            {
                for (var j = 0; j < 3; j++)
                {
                    splitted[i * 3 + j] = chunked[i].ToCharArray()[j];
                }
            }

            return splitted;
        }

        /// <summary>
        ///     Chunks the input text message.
        /// </summary>
        /// <param name="text">text message.</param>
        /// <returns>array of words.</returns>
        private static string[] ChunkTextToArray(string text)
        {
            // To split the message into chunks
            var div = text.Length / 3;
            var chunks = new string[div];

            for (var i = 0; i < div; i++)
            {
                chunks.SetValue(text.Substring(i * 3, 3), i);
            }

            return chunks;
        }

        /// <summary>
        ///     Fills a text message with spaces at the end
        ///     to enable a simple split by 3-length-word.
        /// </summary>
        /// <param name="text">Text Message.</param>
        /// <returns>Modified text Message.</returns>
        private static string FillGaps(string text)
        {
            var remainder = text.Length % 3;
            return remainder == 0 ? text : text + new string(' ', 3 - remainder);
        }

        /// <summary>
        ///     Removes the extra spaces included on the cipher phase.
        /// </summary>
        /// <param name="text">Text message.</param>
        /// <returns>Deciphered Message.</returns>
        private static string UnFillGaps(string text) => text.TrimEnd();

        /// <summary>
        ///     Finds the inverse of the given matrix using a linear equation solver.
        /// </summary>
        /// <param name="vector">Splitted words vector.</param>
        /// <param name="key">Key used for the cipher.</param>
        /// <returns>TODO.</returns>
        private double[] MatrixDeCipher(double[] vector, double[,] key)
        {
            // To augment the original key with the given vector.
            var augM = new double[3, 4];

            for (var i = 0; i < key.GetLength(0); i++)
            {
                for (var j = 0; j < key.GetLength(1); j++)
                {
                    augM[i, j] = key[i, j];
                }
            }

            for (var k = 0; k < vector.Length; k++)
            {
                augM[k, 3] = vector[k];
            }

            _ = linearEquationSolver.Solve(augM);

            return new[] { augM[0, 3], augM[1, 3], augM[2, 3] };
        }
    }
}
using System.Text;

namespace Algorithms.Encoders
{
    /// <summary>
    ///     Encodes using caesar cypher.
    /// </summary>
    public class CaesarEncoder : IEncoder<int>
    {
        /// <summary>
        ///     Encodes text using specified key,
        ///     time complexity: O(n),
        ///     space complexity: O(n),
        ///     where n - text length.
        /// </summary>
        /// <param name="text">Text to be encoded.</param>
        /// <param name="key">Key that will be used to encode the text.</param>
        /// <returns>Encoded text.</returns>
        public string Encode(string text, int key) => Cipher(text, key);

        /// <summary>
        ///     Decodes text that was encoded using specified key,
        ///     time complexity: O(n),
        ///     space complexity: O(n),
        ///     where n - text length.
        /// </summary>
        /// <param name="text">Text to be decoded.</param>
        /// <param name="key">Key that was used to encode the text.</param>
        /// <returns>Decoded text.</returns>
        public string Decode(string text, int key) => Cipher(text, -key);

        private static string Cipher(string text, int key)
        {
            var newText = new StringBuilder(text.Length);
            for (var i = 0; i < text.Length; i++)
            {
                if (!char.IsLetter(text[i]))
                {
                    _ = newText.Append(text[i]);
                    continue;
                }

                var letterA = char.IsUpper(text[i]) ? 'A' : 'a';
                var letterZ = char.IsUpper(text[i]) ? 'Z' : 'z';

                var c = text[i] + key;
                c -= c > letterZ ? 26 * (1 + (c - letterZ - 1) / 26) : 0;
                c += c < letterA ? 26 * (1 + (letterA - c - 1) / 26) : 0;

                _ = newText.Append((char)c);
            }

            return newText.ToString();
        }
    }
}
namespace Algorithms.Encoders
{
    /// <summary>
    ///     Encodes and decodes text based on specified key.
    /// </summary>
    /// <typeparam name="TKey">Type of the key.</typeparam>
    public interface IEncoder<TKey>
    {
        /// <summary>
        ///     Encodes text using specified key.
        /// </summary>
        /// <param name="text">Text to be encoded.</param>
        /// <param name="key">Key that will be used to encode the text.</param>
        /// <returns>Encoded text.</returns>
        string Encode(string text, TKey key);

        /// <summary>
        ///     Decodes text that was encoded using specified key.
        /// </summary>
        /// <param name="text">Text to be decoded.</param>
        /// <param name="key">Key that was used to encode the text.</param>
        /// <returns>Decoded text.</returns>
        string Decode(string text, TKey key);
    }
}
using System;
using System.Collections.Generic;
using System.Text;

namespace Algorithms.Encoders
{
    /// <summary>
    ///     Encodes using Feistel cipher.
    ///     https://en.wikipedia.org/wiki/Feistel_cipher
    ///     In cryptography, a Feistel cipher (also known as LubyRackoff block cipher)
    ///     is a symmetric structure used in the construction of block ciphers,
    ///     named after the German-born physicist and cryptographer Horst Feistel
    ///     who did pioneering research while working for IBM (USA)
    ///     A large proportion of block ciphers use the scheme, including the US DES,
    ///     the Soviet/Russian GOST and the more recent Blowfish and Twofish ciphers.
    /// </summary>
    public class FeistelCipher : IEncoder<uint>
    {
        // number of rounds to transform data block, each round a new "round" key is generated.
        private const int Rounds = 32;

        /// <summary>
        ///     Encodes text using specified key,
        ///     where n - text length.
        /// </summary>
        /// <param name="text">Text to be encoded.</param>
        /// <param name="key">Key that will be used to encode the text.</param>
        /// <exception cref="ArgumentException">Error: key should be more than 0x00001111 for better encoding, key=0 will throw DivideByZero exception.</exception>
        /// <returns>Encoded text.</returns>
        public string Encode(string text, uint key)
        {
            List<ulong> blocksListPlain = SplitTextToBlocks(text);
            StringBuilder encodedText = new();

            foreach (ulong block in blocksListPlain)
            {
                uint temp = 0;

                // decompose a block to two subblocks 0x0123456789ABCDEF => 0x01234567 & 0x89ABCDEF
                uint rightSubblock = (uint)(block & 0x00000000FFFFFFFF);
                uint leftSubblock = (uint)(block >> 32);

                uint roundKey;

                // Feistel "network" itself
                for (int round = 0; round < Rounds; round++)
                {
                    roundKey = GetRoundKey(key, round);
                    temp = rightSubblock ^ BlockModification(leftSubblock, roundKey);
                    rightSubblock = leftSubblock;
                    leftSubblock = temp;
                }

                // compile text string formating the block value to text (hex based), length of the output = 16 byte always
                ulong encodedBlock = leftSubblock;
                encodedBlock = (encodedBlock << 32) | rightSubblock;
                encodedText.Append(string.Format("{0:X16}", encodedBlock));
            }

            return encodedText.ToString();
        }

        /// <summary>
        ///     Decodes text that was encoded using specified key.
        /// </summary>
        /// <param name="text">Text to be decoded.</param>
        /// <param name="key">Key that was used to encode the text.</param>
        /// <exception cref="ArgumentException">Error: key should be more than 0x00001111 for better encoding, key=0 will throw DivideByZero exception.</exception>
        /// <exception cref="ArgumentException">Error: The length of text should be divisible by 16 as it the block lenght is 16 bytes.</exception>
        /// <returns>Decoded text.</returns>
        public string Decode(string text, uint key)
        {
            // The plain text will be padded to fill the size of block (16 bytes)
            if (text.Length % 16 != 0)
            {
                throw new ArgumentException($"The length of {nameof(key)} should be divisible by 16");
            }

            List<ulong> blocksListEncoded = GetBlocksFromEncodedText(text);
            StringBuilder decodedTextHex = new();

            foreach (ulong block in blocksListEncoded)
            {
                uint temp = 0;

                // decompose a block to two subblocks 0x0123456789ABCDEF => 0x01234567 & 0x89ABCDEF
                uint rightSubblock = (uint)(block & 0x00000000FFFFFFFF);
                uint leftSubblock = (uint)(block >> 32);

                // Feistel "network" - decoding, the order of rounds and operations on the blocks is reverted
                uint roundKey;
                for (int round = Rounds - 1; round >= 0; round--)
                {
                    roundKey = GetRoundKey(key, round);
                    temp = leftSubblock ^ BlockModification(rightSubblock, roundKey);
                    leftSubblock = rightSubblock;
                    rightSubblock = temp;
                }

                // compose decoded block
                ulong decodedBlock = leftSubblock;
                decodedBlock = (decodedBlock << 32) | rightSubblock;

                for(int i = 0; i < 8; i++)
                {
                    ulong a = (decodedBlock & 0xFF00000000000000) >> 56;

                    // it's a trick, the code works with non zero characters, if your text has ASCII code 0x00 it will be skipped.
                    if (a != 0)
                    {
                        decodedTextHex.Append((char)a);
                    }

                    decodedBlock = decodedBlock << 8;
                }
            }

            return decodedTextHex.ToString();
        }

        // Using the size of block = 8 bytes this function splts the text and returns set of 8 bytes (ulong) blocks
        // the last block is extended up to 8 bytes if the tail of the text is smaller than 8 bytes
        private static List<ulong> SplitTextToBlocks(string text)
        {
            List<ulong> blocksListPlain = new();
            byte[] textArray = Encoding.ASCII.GetBytes(text);
            int offset = 8;
            for(int i = 0; i < text.Length; i += 8)
            {
                // text not always has len%16 == 0, that's why the offset should be adjusted for the last part of the text
                if (i > text.Length - 8)
                {
                    offset = text.Length - i;
                }

                string block = Convert.ToHexString(textArray, i, offset);
                blocksListPlain.Add(Convert.ToUInt64(block, 16));
            }

            return blocksListPlain;
        }

        // convert the encoded text to the set of ulong values (blocks for decoding)
        private static List<ulong> GetBlocksFromEncodedText(string text)
        {
            List<ulong> blocksListPlain = new();
            for(int i = 0; i < text.Length; i += 16)
            {
                ulong block = Convert.ToUInt64(text.Substring(i, 16), 16);
                blocksListPlain.Add(block);
            }

            return blocksListPlain;
        }

        // here might be any deterministic math formula
        private static uint BlockModification(uint block, uint key)
        {
            for (int i = 0; i < 32; i++)
            {
                // 0x55555555 for the better distribution 0 an 1 in the block
                block = ((block ^ 0x55555555) * block) % key;
                block = block ^ key;
            }

            return block;
        }

        // There are many ways to generate a round key, any deterministic math formula does work
        private static uint GetRoundKey(uint key, int round)
        {
            // "round + 2" - to avoid a situation when pow(key,1) ^ key  = key ^ key = 0
            uint a = (uint)Math.Pow((double)key, round + 2);
            return a ^ key;
        }
    }
}
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Encoders
{
    /// <summary>
    ///     Class for Soundex encoding strings.
    /// </summary>
    public class SoundexEncoder
    {
        /// <summary>
        ///     Encodes a string using the Soundex Algorithm.
        /// </summary>
        /// <param name="text">The string to encode.</param>
        /// <returns>The Soundex encoded string (one uppercase character and three digits).</returns>
        public string Encode(string text)
        {
            text = text.ToLowerInvariant();
            var chars = OmitHAndW(text);
            IEnumerable<int> numbers = ProduceNumberCoding(chars);
            numbers = CollapseDoubles(numbers);
            numbers = OmitVowels(numbers);
            numbers = CollapseLeadingDigit(numbers, text[0]);
            numbers = numbers.Take(3);
            numbers = PadTo3Numbers(numbers);
            var final = numbers.ToArray();
            return $"{text.ToUpperInvariant()[0]}{final[0]}{final[1]}{final[2]}";
        }

        private IEnumerable<int> CollapseLeadingDigit(IEnumerable<int> numbers, char c)
        {
            using var enumerator = numbers.GetEnumerator();
            enumerator.MoveNext();
            if (enumerator.Current == MapToNumber(c))
            {
                enumerator.MoveNext();
            }

            do
            {
                yield return enumerator.Current;
            }
            while (enumerator.MoveNext());
        }

        private IEnumerable<int> PadTo3Numbers(IEnumerable<int> numbers)
        {
            using var enumerator = numbers.GetEnumerator();
            for (var i = 0; i < 3; i++)
            {
                yield return enumerator.MoveNext()
                    ? enumerator.Current
                    : 0;
            }
        }

        private IEnumerable<int> OmitVowels(IEnumerable<int> numbers) => numbers.Where(i => i != 0);

        private IEnumerable<char> OmitHAndW(string text) => text.Where(c => c != 'h' && c != 'w');

        private IEnumerable<int> CollapseDoubles(IEnumerable<int> numbers)
        {
            var previous = int.MinValue;
            foreach (var i in numbers)
            {
                if (previous != i)
                {
                    yield return i;
                    previous = i;
                }
            }
        }

        private IEnumerable<int> ProduceNumberCoding(IEnumerable<char> text) => text.Select(MapToNumber);

        private int MapToNumber(char ch)
        {
            var mapping = new Dictionary<char, int>
            {
                ['a'] = 0,
                ['e'] = 0,
                ['i'] = 0,
                ['o'] = 0,
                ['u'] = 0,
                ['y'] = 0,
                ['h'] = 8,
                ['w'] = 8,
                ['b'] = 1,
                ['f'] = 1,
                ['p'] = 1,
                ['v'] = 1,
                ['c'] = 2,
                ['g'] = 2,
                ['j'] = 2,
                ['k'] = 2,
                ['q'] = 2,
                ['s'] = 2,
                ['x'] = 2,
                ['z'] = 2,
                ['d'] = 3,
                ['t'] = 3,
                ['l'] = 4,
                ['m'] = 5,
                ['n'] = 5,
                ['r'] = 6,
            };

            return mapping[ch];
        }
    }
}
using System;
using System.Text;

namespace Algorithms.Encoders
{
    /// <summary>
    ///     Encodes using vigenere cypher.
    /// </summary>
    public class VigenereEncoder : IEncoder<string>
    {
        private readonly CaesarEncoder caesarEncoder = new();

        /// <summary>
        ///     Encodes text using specified key,
        ///     time complexity: O(n),
        ///     space complexity: O(n),
        ///     where n - text length.
        /// </summary>
        /// <param name="text">Text to be encoded.</param>
        /// <param name="key">Key that will be used to encode the text.</param>
        /// <returns>Encoded text.</returns>
        public string Encode(string text, string key) => Cipher(text, key, caesarEncoder.Encode);

        /// <summary>
        ///     Decodes text that was encoded using specified key,
        ///     time complexity: O(n),
        ///     space complexity: O(n),
        ///     where n - text length.
        /// </summary>
        /// <param name="text">Text to be decoded.</param>
        /// <param name="key">Key that was used to encode the text.</param>
        /// <returns>Decoded text.</returns>
        public string Decode(string text, string key) => Cipher(text, key, caesarEncoder.Decode);

        private string Cipher(string text, string key, Func<string, int, string> symbolCipher)
        {
            key = AppendKey(key, text.Length);
            var encodedTextBuilder = new StringBuilder(text.Length);
            for (var i = 0; i < text.Length; i++)
            {
                if (!char.IsLetter(text[i]))
                {
                    _ = encodedTextBuilder.Append(text[i]);
                    continue;
                }

                var letterZ = char.IsUpper(key[i]) ? 'Z' : 'z';
                var encodedSymbol = symbolCipher(text[i].ToString(), letterZ - key[i]);
                _ = encodedTextBuilder.Append(encodedSymbol);
            }

            return encodedTextBuilder.ToString();
        }

        private string AppendKey(string key, int length)
        {
            if (string.IsNullOrEmpty(key))
            {
                throw new ArgumentOutOfRangeException($"{nameof(key)} must be non-empty string");
            }

            var keyBuilder = new StringBuilder(key, length);
            while (keyBuilder.Length < length)
            {
                _ = keyBuilder.Append(key);
            }

            return keyBuilder.ToString();
        }
    }
}
using System.Globalization;
using System.Linq;
using System.Text;

namespace Algorithms.Encoders
{
    /// <summary>
    ///     Class for NYSIIS encoding strings.
    /// </summary>
    public class NysiisEncoder
    {
        private static readonly char[] Vowels = { 'A', 'E', 'I', 'O', 'U' };

        /// <summary>
        ///     Encodes a string using the NYSIIS Algorithm.
        /// </summary>
        /// <param name="text">The string to encode.</param>
        /// <returns>The NYSIIS encoded string (all uppercase).</returns>
        public string Encode(string text)
        {
            text = text.ToUpper(CultureInfo.CurrentCulture);
            text = TrimSpaces(text);
            text = StartReplace(text);
            text = EndReplace(text);

            for (var i = 1; i < text.Length; i++)
            {
                text = ReplaceStep(text, i);
            }

            text = RemoveDuplicates(text);
            return TrimEnd(text);
        }

        private string TrimSpaces(string text) => text.Replace(" ", string.Empty);

        private string RemoveDuplicates(string text)
        {
            var sb = new StringBuilder();
            sb.Append(text[0]);
            foreach (var c in text)
            {
                if (sb[^1] != c)
                {
                    sb.Append(c);
                }
            }

            return sb.ToString();
        }

        private string TrimEnd(string text)
        {
            var checks = new (string from, string to)?[]
            {
                ("S", string.Empty),
                ("AY", "Y"),
                ("A", string.Empty),
            };
            var replacement = checks.FirstOrDefault(t => text.EndsWith(t!.Value.from));
            if (replacement is { })
            {
                var (from, to) = replacement!.Value;
                text = Replace(text, text.Length - from.Length, from.Length, to);
            }

            return text;
        }

        private string ReplaceStep(string text, int i)
        {
            (string from, string to)[] replacements =
            {
                ("EV", "AF"),
                ("E", "A"),
                ("I", "A"),
                ("O", "A"),
                ("U", "A"),
                ("Q", "G"),
                ("Z", "S"),
                ("M", "N"),
                ("KN", "NN"),
                ("K", "C"),
                ("SCH", "SSS"),
                ("PH", "FF"),
            };
            var replaced = TryReplace(text, i, replacements, out text);
            if (replaced)
            {
                return text;
            }

            // H[vowel] or [vowel]H -> text[i-1]
            if (text[i] == 'H')
            {
                if (!Vowels.Contains(text[i - 1]))
                {
                    return ReplaceWithPrevious();
                }

                if (i < text.Length - 1 && !Vowels.Contains(text[i + 1]))
                {
                    return ReplaceWithPrevious();
                }
            }

            // [vowel]W -> [vowel]
            if (text[i] == 'W' && Vowels.Contains(text[i - 1]))
            {
                return ReplaceWithPrevious();
            }

            return text;

            string ReplaceWithPrevious() => Replace(text, i, 1, text[i - 1].ToString());
        }

        private bool TryReplace(string text, int index, (string, string)[] opts, out string result)
        {
            for (var i = 0; i < opts.Length; i++)
            {
                var check = opts[i].Item1;
                var repl = opts[i].Item2;
                if (text.Length >= index + check.Length && text.Substring(index, check.Length) == check)
                {
                    result = Replace(text, index, check.Length, repl);
                    return true;
                }
            }

            result = text;
            return false;
        }

        private string StartReplace(string start)
        {
            var checks = new (string from, string to)?[]
            {
                ("MAC", "MCC"),
                ("KN", "NN"),
                ("K", "C"),
                ("PH", "FF"),
                ("PF", "FF"),
                ("SCH", "SSS"),
            };
            var replacement = checks.FirstOrDefault(t => start.StartsWith(t!.Value.from));
            if (replacement is { })
            {
                var (from, to) = replacement!.Value;
                start = Replace(start, 0, from.Length, to);
            }

            return start;
        }

        private string EndReplace(string end)
        {
            var checks = new (string from, string to)?[]
            {
                ("EE", "Y"),
                ("IE", "Y"),
                ("DT", "D"),
                ("RT", "D"),
                ("NT", "D"),
                ("ND", "D"),
            };
            var replacement = checks.FirstOrDefault(t => end.EndsWith(t!.Value.from));
            if (replacement is { })
            {
                var (from, to) = replacement!.Value;
                end = Replace(end, end.Length - from.Length, from.Length, to);
            }

            return end;
        }

        private string Replace(string text, int index, int length, string substitute) =>
            text[..index] + substitute + text[(index + length) ..];
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Fibonacci sequence.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Fibonacci_number.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000045.
    ///     </para>
    /// </summary>
    public class FibonacciSequence : ISequence
    {
        /// <summary>
        ///     Gets Fibonacci sequence.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 0;
                yield return 1;
                BigInteger previous = 0;
                BigInteger current = 1;
                while (true)
                {
                    var next = previous + current;
                    previous = current;
                    current = next;
                    yield return next;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Number of halving and tripling steps to reach 1 in the '3n+1' problem.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://en.wikipedia.org/wiki/Collatz_conjecture.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A006577.
    ///     </para>
    /// </summary>
    public class ThreeNPlusOneStepsSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of number of halving and tripling steps to reach 1 in the '3n+1' problem.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                BigInteger startingValue = 1;

                while (true)
                {
                    BigInteger counter = 0;
                    BigInteger currentValue = startingValue;

                    while (currentValue != 1)
                    {
                        if (currentValue.IsEven)
                        {
                            currentValue /= 2;
                        }
                        else
                        {
                            currentValue = 3 * currentValue + 1;
                        }

                        counter++;
                    }

                    yield return counter;
                    startingValue++;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Catalan numbers: C[n+1] = (2*(2*n+1)*C[n])/(n+2).
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://en.wikipedia.org/wiki/Catalan_number.
    ///     </para>
    ///     <para>
    ///         OEIS:http://oeis.org/A000108.
    ///     </para>
    /// </summary>
    public class CatalanSequence : ISequence
    {
        /// <summary>
        ///     Gets sequence of Catalan numbers.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                // initialize the first element (1) and define it's enumerator (0)
                var catalan = new BigInteger(1);
                var n = 0;
                while (true)
                {
                    yield return catalan;
                    catalan = (2 * (2 * n + 1) * catalan) / (n + 2);
                    n++;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of Euclid numbers: 1 + product of the first n primes.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Euclid_number.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A006862.
    ///     </para>
    /// </summary>
    public class EuclidNumbersSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of Euclid numbers.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var primorialNumbers = new PrimorialNumbersSequence().Sequence;

                foreach (var n in primorialNumbers)
                {
                    yield return n + 1;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of binary prime constant
    ///         (Characteristic function of primes: 1 if n is prime, else 0).
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Prime_constant.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A010051.
    ///     </para>
    /// </summary>
    public class BinaryPrimeConstantSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of binary prime constant.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                ISequence primes = new PrimesSequence();
                var n = new BigInteger(0);

                foreach (var p in primes.Sequence)
                {
                    for (n++; n < p; n++)
                    {
                        yield return 0;
                    }

                    yield return 1;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Golomb's sequence. a(n) is the number of times n occurs in the sequence, starting with a(1) = 1.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://en.wikipedia.org/wiki/Golomb_sequence.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A001462.
    ///     </para>
    /// </summary>
    public class GolombsSequence : ISequence
    {
        /// <summary>
        ///     Gets Golomb's sequence.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 1;
                yield return 2;
                yield return 2;

                var queue = new Queue<BigInteger>();
                queue.Enqueue(2);

                for (var i = 3; ; i++)
                {
                    var repetitions = queue.Dequeue();
                    for (var j = 0; j < repetitions; j++)
                    {
                        queue.Enqueue(i);
                        yield return i;
                    }
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of primorial numbers: product of first n primes.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Primorial.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A002110.
    ///     </para>
    /// </summary>
    public class PrimorialNumbersSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of primorial numbers.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var primes = new PrimesSequence().Sequence;
                var n = new BigInteger(1);

                foreach (var p in primes)
                {
                    yield return n;
                    n *= p;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of binomial coefficients.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://en.wikipedia.org/wiki/Binomial_coefficient.
    ///     </para>
    ///     <para>
    ///         OEIS: http://oeis.org/A007318.
    ///     </para>
    /// </summary>
    public class BinomialSequence : ISequence
    {
        /// <summary>
        ///     Gets sequence of binomial coefficients.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var i = 0;

                while (true)
                {
                    var row = GenerateRow(i);
                    foreach (var coefficient in row)
                    {
                        yield return coefficient;
                    }

                    i++;
                }
            }
        }

        private static BigInteger BinomialCoefficient(long n, long k)
        {
            if (k == 0 || k == n)
            {
                return new BigInteger(1);
            }

            if (n < 0)
            {
                return new BigInteger(0);
            }

            return BinomialCoefficient(n - 1, k) + BinomialCoefficient(n - 1, k - 1);
        }

        private static IEnumerable<BigInteger> GenerateRow(long n)
        {
            long k = 0;

            while (k <= n)
            {
                yield return BinomialCoefficient(n, k);
                k++;
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of the number of divisors of n, starting with 1.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000005.
    ///     </para>
    /// </summary>
    public class DivisorsCountSequence : ISequence
    {
        /// <summary>
        ///     Gets sequence of number of divisors for n, starting at 1.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return BigInteger.One;
                for (var n = new BigInteger(2); ; n++)
                {
                    var count = 2;
                    for (var k = 2; k < n; k++)
                    {
                        BigInteger.DivRem(n, k, out var remainder);
                        if (remainder == 0)
                        {
                            count++;
                        }
                    }

                    yield return count;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of natural numbers.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Natural_number.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000027.
    ///     </para>
    /// </summary>
    public class NaturalSequence : ISequence
    {
        /// <summary>
        ///     Gets sequence of natural numbers.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(1);
                while (true)
                {
                    yield return n++;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of Fermat primes: primes of the form 2^(2^k) + 1, for some k >= 0.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Fermat_number.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A019434.
    ///     </para>
    /// </summary>
    public class FermatPrimesSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of Fermat primes.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var fermatNumbers = new FermatNumbersSequence().Sequence.Take(5);

                foreach (var n in fermatNumbers)
                {
                    yield return n;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     Common interface for all integer sequences.
    /// </summary>
    public interface ISequence
    {
        /// <summary>
        ///     Gets sequence as enumerable.
        /// </summary>
        IEnumerable<BigInteger> Sequence { get; }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of negative integers.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Negative_number.
    ///     </para>
    ///     <para>
    ///         OEIS: http://oeis.org/A001478.
    ///     </para>
    /// </summary>
    public class NegativeIntegersSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of negative integers.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(-1);

                while (true)
                {
                    yield return n--;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of number of truth tables generated by Boolean expressions of n variables
    ///         (Double exponentials of 2: a(n) = 2^(2^n)).
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Truth_table.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A001146.
    ///     </para>
    /// </summary>
    public class NumberOfBooleanFunctionsSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of number Of Boolean functions.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(2);

                while (true)
                {
                    yield return n;
                    n *= n;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of Kummer numbers (also called Euclid numbers of the second kind):
    ///         -1 + product of first n consecutive primes.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Euclid_number.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A057588.
    ///     </para>
    /// </summary>
    public class KummerNumbersSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of Kummer numbers.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var primorialNumbers = new PrimorialNumbersSequence().Sequence.Skip(1);

                foreach (var n in primorialNumbers)
                {
                    yield return n - 1;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Kolakoski sequence; n-th element is the length of the n-th run in the sequence itself.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://en.wikipedia.org/wiki/Kolakoski_sequence.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000002.
    ///     </para>
    /// </summary>
    public class KolakoskiSequence : ISequence
    {
        /// <summary>
        /// Gets Kolakoski sequence.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 1;
                yield return 2;
                yield return 2;

                var queue = new Queue<int>();
                queue.Enqueue(2);
                var nextElement = 1;
                while (true)
                {
                    var nextRun = queue.Dequeue();
                    for (var i = 0; i < nextRun; i++)
                    {
                        queue.Enqueue(nextElement);
                        yield return nextElement;
                    }

                    nextElement = 1 + nextElement % 2;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of prime numbers.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Prime_number.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000040.
    ///     </para>
    /// </summary>
    public class PrimesSequence : ISequence
    {
        /// <summary>
        ///     Gets sequence of prime numbers.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 2;
                var primes = new List<BigInteger>
                {
                    2,
                };
                var n = new BigInteger(3);

                while (true)
                {
                    if (primes.All(p => n % p != 0))
                    {
                        yield return n;
                        primes.Add(n);
                    }

                    n += 2;
                }
            }
        }
    }
}
using System;
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Number of ways of making change for n cents using coins of 1, 2, 5, 10 cents.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000008.
    ///     </para>
    /// </summary>
    public class MakeChangeSequence : ISequence
    {
        /// <summary>
        ///     <para>
        ///         Gets sequence of number of ways of making change for n cents
        ///         using coins of 1, 2, 5, 10 cents.
        ///     </para>
        ///     <para>
        ///         Uses formula from OEIS page by Michael Somos
        ///         along with first 17 values to prevent index issues.
        ///     </para>
        ///     <para>
        ///         Formula:
        ///         a(n) = a(n-2) +a(n-5) - a(n-7) + a(n-10) - a(n-12) - a(n-15) + a(n-17) + 1.
        ///     </para>
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var seed = new List<BigInteger>
                           {
                               1, 1, 2, 2, 3, 4, 5, 6, 7, 8,
                               11, 12, 15, 16, 19, 22, 25,
                           };
                foreach (var value in seed)
                {
                    yield return value;
                }

                for(var index = 17; ; index++)
                {
                    BigInteger newValue = seed[index - 2] + seed[index - 5] - seed[index - 7]
                                        + seed[index - 10] - seed[index - 12] - seed[index - 15]
                                        + seed[index - 17] + 1;

                    seed.Add(newValue);
                    yield return newValue;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of number of primes less than 10^n (with at most n digits).
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Prime-counting_function.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A006880.
    ///     </para>
    /// </summary>
    public class NumberOfPrimesByPowersOf10Sequence : ISequence
    {
        /// <summary>
        /// Gets sequence of numbers of primes.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                ISequence primes = new PrimesSequence();
                var powerOf10 = new BigInteger(1);
                var counter = new BigInteger(0);

                foreach (var p in primes.Sequence)
                {
                    if (p > powerOf10)
                    {
                        yield return counter;
                        powerOf10 *= 10;
                    }

                    counter++;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of Fermat numbers: a(n) = 2^(2^n) + 1.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Fermat_number.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000215.
    ///     </para>
    /// </summary>
    public class FermatNumbersSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of Fermat numbers.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(2);

                while (true)
                {
                    yield return n + 1;
                    n *= n;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Van Eck's sequence. For n >= 1, if there exists an m &lt; n such that a(m) = a(n), take the largest such m and set a(n+1) = n-m; otherwise a(n+1) = 0. Start with a(1)=0.
    ///     </para>
    ///     <para>
    ///         OEIS: http://oeis.org/A181391.
    ///     </para>
    /// </summary>
    public class VanEcksSequence : ISequence
    {
        /// <summary>
        ///     Gets Van Eck's sequence.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 0;
                var dictionary = new Dictionary<BigInteger, BigInteger>();
                BigInteger previous = 0;
                BigInteger currentIndex = 2; // 1-based index
                while (true)
                {
                    BigInteger element = 0;
                    if (dictionary.TryGetValue(previous, out var previousIndex))
                    {
                        element = currentIndex - previousIndex;
                    }

                    yield return element;

                    dictionary[previous] = currentIndex;
                    previous = element;
                    currentIndex++;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of factorial numbers.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://en.wikipedia.org/wiki/Factorial.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000142.
    ///     </para>
    /// </summary>
    public class FactorialSequence : ISequence
    {
        /// <summary>
        ///     Gets sequence of factorial numbers.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = 0;
                var factorial = new BigInteger(1);
                while (true)
                {
                    yield return factorial;
                    n++;
                    factorial *= n;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of Euler totient function phi(n).
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://en.wikipedia.org/wiki/Euler%27s_totient_function.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000010.
    ///     </para>
    /// </summary>
    public class EulerTotientSequence : ISequence
    {
        /// <summary>
        ///     <para>
        ///         Gets sequence of Euler totient function phi(n).
        ///     </para>
        ///     <para>
        ///         'n' is copied from value of the loop of i that's being enumerated over.
        ///         1) Initialize result as n
        ///         2) Consider every number 'factor' (where 'factor' is a prime divisor of n).
        ///            If factor divides n, then do following
        ///            a) Subtract all multiples of factor from 1 to n [all multiples of factor
        ///               will have gcd more than 1 (at least factor) with n]
        ///            b) Update n by repeatedly dividing it by factor.
        ///         3) If the reduced n is more than 1, then remove all multiples
        ///            of n from result.
        ///     </para>
        ///     <para>
        ///         Base code was from https://www.geeksforgeeks.org/eulers-totient-function/.
        ///      </para>
        ///     <para>
        ///         Implementation avoiding floating point operations was used for base
        ///         and replacement of loop going from 1 to sqrt(n) was replaced with
        ///         List of prime factors.
        ///     </para>
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return BigInteger.One;

                for (BigInteger i = 2; ; i++)
                {
                    var n = i;
                    var result = n;

                    var factors = PrimeFactors(i);
                    foreach (var factor in factors)
                    {
                        while (n % factor == 0)
                        {
                            n /= factor;
                        }

                        result -= result / factor;
                    }

                    if (n > 1)
                    {
                        result -= result / n;
                    }

                    yield return result;
                }
            }
        }

        /// <summary>
        ///     <para>
        ///         Uses the prime sequence to find all prime factors of the
        ///         number we're looking at.
        ///     </para>
        ///     <para>
        ///         The prime sequence is examined until its value squared is
        ///         less than or equal to target, and checked to make sure it
        ///         evenly divides the target.  If it evenly divides, it's added
        ///         to the result which is returned as a List.
        ///     </para>
        /// </summary>
        /// <param name="target">Number that is being factored.</param>
        /// <returns>List of prime factors of target.</returns>
        private static IEnumerable<BigInteger> PrimeFactors(BigInteger target)
        {
            return new PrimesSequence()
                  .Sequence.TakeWhile(prime => prime * prime <= target)
                  .Where(prime => target % prime == 0)
                  .ToList();
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of cube numbers.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://en.wikipedia.org/wiki/Cube_(algebra).
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000578.
    ///     </para>
    /// </summary>
    public class CubesSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of cube numbers.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = BigInteger.Zero;

                while (true)
                {
                    yield return n * n * n;
                    n++;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of square numbers.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Square_number.
    ///     </para>
    ///     <para>
    ///         OEIS: http://oeis.org/A000290.
    ///     </para>
    /// </summary>
    public class SquaresSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of square numbers.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(0);

                while (true)
                {
                    yield return n * n;
                    n++;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of powers of 2: a(n) = 2^n.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Power_of_two.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000079.
    ///     </para>
    /// </summary>
    public class PowersOf2Sequence : ISequence
    {
        /// <summary>
        /// Gets sequence of powers of 2.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(1);

                while (true)
                {
                    yield return n;
                    n *= 2;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Number of primes with n digits
    ///         (The number of primes between 10^(n-1) and 10^n).
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Prime-counting_function.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A006879.
    ///     </para>
    /// </summary>
    public class NumberOfPrimesByNumberOfDigitsSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of number of primes.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                ISequence primes = new PrimesSequence();
                var powerOf10 = new BigInteger(1);
                var counter = new BigInteger(0);

                foreach (var p in primes.Sequence)
                {
                    if (p > powerOf10)
                    {
                        yield return counter;
                        counter = 0;
                        powerOf10 *= 10;
                    }

                    counter++;
                }
            }
        }
    }
}
using System.Collections;
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         The zero sequence.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000004.
    ///     </para>
    /// </summary>
    public class ZeroSequence : ISequence
    {
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                while (true)
                {
                    yield return 0;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of powers of 10: a(n) = 10^n.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Power_of_10.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A011557.
    ///     </para>
    /// </summary>
    public class PowersOf10Sequence : ISequence
    {
        /// <summary>
        /// Gets sequence of powers of 10.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(1);

                while (true)
                {
                    yield return n;
                    n *= 10;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Recaman's sequence. a(0) = 0; for n > 0, a(n) = a(n-1) - n if nonnegative and not already in the sequence, otherwise a(n) = a(n-1) + n.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://en.wikipedia.org/wiki/Recam%C3%A1n%27s_sequence.
    ///     </para>
    ///     <para>
    ///         OEIS: http://oeis.org/A005132.
    ///     </para>
    /// </summary>
    public class RecamansSequence : ISequence
    {
        /// <summary>
        ///     Gets Recaman's sequence.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 0;
                var elements = new HashSet<BigInteger> { 0 };
                var previous = 0;
                var i = 1;

                while (true)
                {
                    var current = previous - i;
                    if (current < 0 || elements.Contains(current))
                    {
                        current = previous + i;
                    }

                    yield return current;
                    previous = current;
                    elements.Add(current);
                    i++;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Kolakoski sequence; n-th element is the length of the n-th run in the sequence itself.
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://en.wikipedia.org/wiki/Kolakoski_sequence.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000002.
    ///     </para>
    /// </summary>
    public class KolakoskiSequence2 : ISequence
    {
        /// <summary>
        /// Gets Kolakoski sequence.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 1;
                yield return 2;
                yield return 2;

                var inner = new KolakoskiSequence2().Sequence.Skip(2);
                var nextElement = 1;
                foreach (var runLength in inner)
                {
                    yield return nextElement;
                    if (runLength > 1)
                    {
                        yield return nextElement;
                    }

                    nextElement = 1 + nextElement % 2;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    /// <summary>
    ///     <para>
    ///         Sequence of number of primes less than or equal to n (PrimePi(n)).
    ///     </para>
    ///     <para>
    ///         Wikipedia: https://wikipedia.org/wiki/Prime-counting_function.
    ///     </para>
    ///     <para>
    ///         OEIS: https://oeis.org/A000720.
    ///     </para>
    /// </summary>
    public class PrimePiSequence : ISequence
    {
        /// <summary>
        /// Gets sequence of number of primes.
        /// </summary>
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                ISequence primes = new PrimesSequence();
                var n = new BigInteger(0);
                var counter = new BigInteger(0);

                foreach (var p in primes.Sequence)
                {
                    for (n++; n < p; n++)
                    {
                        yield return counter;
                    }

                    yield return ++counter;
                }
            }
        }
    }
}
using System;

namespace Algorithms.Shufflers
{
    /// <summary>
    ///     Fisher-Yates shuffle is a simple shuffling algorithm,
    ///     which is usually used to shuffle a deck of cards.
    /// </summary>
    /// <typeparam name="T">Type array input.</typeparam>
    public class FisherYatesShuffler<T> : IShuffler<T>
    {
        /// <summary>
        ///     Shuffles input array using Fisher-Yates algorithm.
        ///     The algorithm starts shuffling from the last element
        ///     and swap elements one by one. We use random index to
        ///     choose element we use in swap operation.
        /// </summary>
        /// <param name="array">Array to shuffle.</param>
        public void Shuffle(T[] array)
        {
            var random = new Random();

            for (var i = array.Length - 1; i > 0; i--)
            {
                var j = random.Next(0, i + 1);

                (array[i], array[j]) = (array[j], array[i]);
            }
        }
    }
}
namespace Algorithms.Shufflers
{
    /// <summary>
    ///     Shuffles array.
    /// </summary>
    /// <typeparam name="T">Type of array item.</typeparam>
    public interface IShuffler<in T>
    {
        /// <summary>
        ///     Shuffles array.
        /// </summary>
        /// <param name="array">Array to Shuffle.</param>
        void Shuffle(T[] array);
    }
}
using System;
using System.Linq;
using Utilities.Extensions;

namespace Algorithms.LinearAlgebra.Eigenvalue
{
    /// <summary>
    ///     Power iteration method - eigenvalue numeric algorithm, based on recurrent relation:
    ///     Li+1 = (A * Li) / || A * Li ||, where Li - eigenvector approximation.
    /// </summary>
    public static class PowerIteration
    {
        /// <summary>
        ///     Returns approximation of the dominant eigenvalue and eigenvector of <paramref name="source" /> matrix.
        /// </summary>
        /// <list type="bullet">
        ///     <item>
        ///         <description>The algorithm will not converge if the start vector is orthogonal to the eigenvector.</description>
        ///     </item>
        ///     <item>
        ///         <description>The <paramref name="source" /> matrix must be square-shaped.</description>
        ///     </item>
        /// </list>
        /// <param name="source">Source square-shaped matrix.</param>
        /// <param name="startVector">Start vector.</param>
        /// <param name="error">Accuracy of the result.</param>
        /// <returns>Dominant eigenvalue and eigenvector pair.</returns>
        /// <exception cref="ArgumentException">The <paramref name="source" /> matrix is not square-shaped.</exception>
        /// <exception cref="ArgumentException">The length of the start vector doesn't equal the size of the source matrix.</exception>
        public static (double eigenvalue, double[] eigenvector) Dominant(
            double[,] source,
            double[] startVector,
            double error = 0.00001)
        {
            if (source.GetLength(0) != source.GetLength(1))
            {
                throw new ArgumentException("The source matrix is not square-shaped.");
            }

            if (source.GetLength(0) != startVector.Length)
            {
                throw new ArgumentException(
                    "The length of the start vector doesn't equal the size of the source matrix.");
            }

            double eigenNorm;
            double[] previousEigenVector;
            double[] currentEigenVector = startVector;

            do
            {
                previousEigenVector = currentEigenVector;
                currentEigenVector = source.Multiply(
                        previousEigenVector.ToColumnVector())
                    .ToRowVector();

                eigenNorm = currentEigenVector.Magnitude();
                currentEigenVector = currentEigenVector.Select(x => x / eigenNorm).ToArray();
            }
            while (Math.Abs(currentEigenVector.Dot(previousEigenVector)) < 1.0 - error);

            var eigenvalue = source.Multiply(currentEigenVector.ToColumnVector()).ToRowVector().Magnitude();

            return (eigenvalue, eigenvector: currentEigenVector);
        }

        /// <summary>
        ///     Returns approximation of the dominant eigenvalue and eigenvector of <paramref name="source" /> matrix.
        ///     Random normalized vector is used as the start vector to decrease chance of orthogonality to the eigenvector.
        /// </summary>
        /// <list type="bullet">
        ///     <item>
        ///         <description>The algorithm will not converge if the start vector is orthogonal to the eigenvector.</description>
        ///     </item>
        ///     <item>
        ///         <description>The <paramref name="source" /> matrix should be square-shaped.</description>
        ///     </item>
        /// </list>
        /// <param name="source">Source square-shaped matrix.</param>
        /// <param name="error">Accuracy of the result.</param>
        /// <returns>Dominant eigenvalue and eigenvector pair.</returns>
        /// <exception cref="ArgumentException">The <paramref name="source" /> matrix is not square-shaped.</exception>
        /// <exception cref="ArgumentException">The length of the start vector doesn't equal the size of the source matrix.</exception>
        public static (double eigenvalue, double[] eigenvector) Dominant(double[,] source, double error = 0.00001) =>
            Dominant(source, new Random().NextVector(source.GetLength(1)), error);
    }
}
using System;

namespace Utilities.Exceptions
{
    /// <summary>
    ///     Signs that sequence doesn't contain any items that one was looking for.
    /// </summary>
    public class ItemNotFoundException : ApplicationException
    {
    }
}
using System;

namespace Utilities.Extensions
{
    public static class VectorExtensions
    {
        /// <summary>
        ///     Makes a copy of a vector. Changes to the copy should not affect the original.
        /// </summary>
        /// <param name="vector">The vector.</param>
        /// <returns>The copy.</returns>
        public static double[] Copy(this double[] vector)
        {
            var result = new double[vector.Length];
            for (var i = 0; i < vector.Length; i++)
            {
                result[i] = vector[i];
            }

            return result;
        }

        /// <summary>
        ///     Computes the outer product of two vectors.
        /// </summary>
        /// <param name="lhs">The LHS vector.</param>
        /// <param name="rhs">The RHS vector.</param>
        /// <returns>The outer product of the two vector.</returns>
        public static double[,] OuterProduct(this double[] lhs, double[] rhs)
        {
            var result = new double[lhs.Length, rhs.Length];
            for (var i = 0; i < lhs.Length; i++)
            {
                for (var j = 0; j < rhs.Length; j++)
                {
                    result[i, j] = lhs[i] * rhs[j];
                }
            }

            return result;
        }

        /// <summary>
        ///     Computes the dot product of two vectors.
        /// </summary>
        /// <param name="lhs">The LHS vector.</param>
        /// <param name="rhs">The RHS vector.</param>
        /// <returns>The dot product of the two vector.</returns>
        /// <exception cref="ArgumentException">Dimensions of vectors do not match.</exception>
        public static double Dot(this double[] lhs, double[] rhs)
        {
            if (lhs.Length != rhs.Length)
            {
                throw new ArgumentException("Dot product arguments must have same dimension");
            }

            double result = 0;
            for (var i = 0; i < lhs.Length; i++)
            {
                result += lhs[i] * rhs[i];
            }

            return result;
        }

        /// <summary>
        ///     Computes the magnitude of a vector.
        /// </summary>
        /// <param name="vector">The vector.</param>
        /// <returns>The magnitude.</returns>
        public static double Magnitude(this double[] vector)
        {
            var magnitude = Dot(vector, vector);
            magnitude = Math.Sqrt(magnitude);
            return magnitude;
        }

        /// <summary>
        ///     Returns the scaled vector.
        /// </summary>
        /// <param name="vector">The vector.</param>
        /// <param name="factor">Scale factor.</param>
        /// <returns>The unit vector.</returns>
        public static double[] Scale(this double[] vector, double factor)
        {
            var result = new double[vector.Length];
            for (var i = 0; i < vector.Length; i++)
            {
                result[i] = vector[i] * factor;
            }

            return result;
        }

        /// <summary>
        ///     Transpose 1d row vector to column vector.
        /// </summary>
        /// <param name="source">Input 1d vector.</param>
        /// <returns>Column vector.</returns>
        public static double[,] ToColumnVector(this double[] source)
        {
            var columnVector = new double[source.Length, 1];

            for (var i = 0; i < source.Length; i++)
            {
                columnVector[i, 0] = source[i];
            }

            return columnVector;
        }

        /// <summary>
        ///     Transpose column vector to 1d row vector.
        /// </summary>
        /// <param name="source">Input column vector.</param>
        /// <returns>Row vector.</returns>
        /// <exception cref="InvalidOperationException">The column vector should have only 1 element in width.</exception>
        public static double[] ToRowVector(this double[,] source)
        {
            if (source.GetLength(1) != 1)
            {
                throw new InvalidOperationException("The column vector should have only 1 element in width.");
            }

            var rowVector = new double[source.Length];

            for (var i = 0; i < rowVector.Length; i++)
            {
                rowVector[i] = source[i, 0];
            }

            return rowVector;
        }

        /// <summary>
        ///     Generates a diagonal matrix from an specified vector.
        /// </summary>
        /// <param name="vector">The input vector.</param>
        /// <returns>A Diagonal matrix.</returns>
        public static double[,] ToDiagonalMatrix(this double[] vector)
        {
            var len = vector.Length;
            var result = new double[len, len];

            for (var i = 0; i < len; i++)
            {
                result[i, i] = vector[i];
            }

            return result;
        }
    }
}
using System.Collections.Generic;

namespace Utilities.Extensions
{
    public static class DictionaryExtensions
    {
        public static void AddMany<TKey, TValue>(
            this Dictionary<TKey, TValue> keys,
            IEnumerable<(TKey, TValue)> enumerable) where TKey : notnull
        {
            foreach (var (key, value) in enumerable)
            {
                keys.Add(key, value);
            }
        }
    }
}
using System;

namespace Utilities.Extensions
{
    public static class MatrixExtensions
    {
        /// <summary>
        ///     Performs immutable dot product multiplication on source matrix to operand.
        /// </summary>
        /// <param name="source">Source left matrix.</param>
        /// <param name="operand">Operand right matrix.</param>
        /// <returns>Dot product result.</returns>
        /// <exception cref="InvalidOperationException">The width of a first operand should match the height of a second.</exception>
        public static double[,] Multiply(this double[,] source, double[,] operand)
        {
            if (source.GetLength(1) != operand.GetLength(0))
            {
                throw new InvalidOperationException(
                    "The width of a first operand should match the height of a second.");
            }

            var result = new double[source.GetLength(0), operand.GetLength(1)];

            for (var i = 0; i < result.GetLength(0); i++)
            {
                for (var j = 0; j < result.GetLength(1); j++)
                {
                    double elementProduct = 0;

                    for (var k = 0; k < source.GetLength(1); k++)
                    {
                        elementProduct += source[i, k] * operand[k, j];
                    }

                    result[i, j] = elementProduct;
                }
            }

            return result;
        }

        /// <summary>
        ///     Makes a copy of a matrix. Changes to the copy should not affect the original.
        /// </summary>
        /// <param name="matrix">The matrix.</param>
        /// <returns>A copy of the matrix.</returns>
        public static double[,] Copy(this double[,] matrix)
        {
            var result = new double[matrix.GetLength(0), matrix.GetLength(1)];
            for (var i = 0; i < matrix.GetLength(0); i++)
            {
                for (var j = 0; j < matrix.GetLength(1); j++)
                {
                    result[i, j] = matrix[i, j];
                }
            }

            return result;
        }

        /// <summary>
        ///     Transposes a matrix.
        /// </summary>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The transposed matrix.</returns>
        public static double[,] Transpose(this double[,] matrix)
        {
            var result = new double[matrix.GetLength(1), matrix.GetLength(0)];
            for (var i = 0; i < matrix.GetLength(0); i++)
            {
                for (var j = 0; j < matrix.GetLength(1); j++)
                {
                    result[j, i] = matrix[i, j];
                }
            }

            return result;
        }

        /// <summary>
        ///     Multiplies a matrix by a vector.
        /// </summary>
        /// <param name="matrix">The matrix.</param>
        /// <param name="vector">The vector.</param>
        /// <returns>The product of the matrix and the vector, which is a vector.</returns>
        /// <exception cref="ArgumentException">Dimensions of matrix and vector do not match.</exception>
        public static double[] MultiplyVector(this double[,] matrix, double[] vector)
        {
            var vectorReshaped = new double[vector.Length, 1];
            for (var i = 0; i < vector.Length; i++)
            {
                vectorReshaped[i, 0] = vector[i];
            }

            var resultMatrix = matrix.Multiply(vectorReshaped);
            var result = new double[resultMatrix.GetLength(0)];
            for (var i = 0; i < result.Length; i++)
            {
                result[i] = resultMatrix[i, 0];
            }

            return result;
        }

        /// <summary>
        ///     Performs matrix subtraction.
        /// </summary>
        /// <param name="lhs">The LHS matrix.</param>
        /// <param name="rhs">The RHS matrix.</param>
        /// <returns>The difference of the two matrices.</returns>
        /// <exception cref="ArgumentException">Dimensions of matrices do not match.</exception>
        public static double[,] Subtract(this double[,] lhs, double[,] rhs)
        {
            if (lhs.GetLength(0) != rhs.GetLength(0) ||
                lhs.GetLength(1) != rhs.GetLength(1))
            {
                throw new ArgumentException("Dimensions of matrices must be the same");
            }

            var result = new double[lhs.GetLength(0), lhs.GetLength(1)];
            for (var i = 0; i < lhs.GetLength(0); i++)
            {
                for (var j = 0; j < lhs.GetLength(1); j++)
                {
                    result[i, j] = lhs[i, j] - rhs[i, j];
                }
            }

            return result;
        }

        /// <summary>
        ///     Performs an element by element comparison on both matrices.
        /// </summary>
        /// <param name="source">Source left matrix.</param>
        /// <param name="operand">Openrand right matrix.</param>
        /// <returns>true: if all elements are the same; false otherwise.</returns>
        public static bool IsEqual(this double[,] source, double[,] operand)
        {
            if (source.Length != operand.Length ||
                source.GetLength(0) != operand.GetLength(0) ||
                source.GetLength(1) != operand.GetLength(1))
            {
                return false;
            }

            for (var i = 0; i < source.GetLength(0); i++)
            {
                for (var j = 0; j < source.GetLength(0); j++)
                {
                    if (Math.Abs(source[i, j] - operand[i, j]) >= 0.0001)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        ///     Performs a round operation on every element of the input matrix up to the neareast integer.
        /// </summary>
        /// <param name="source">Input matrix.</param>
        /// <returns>Matrix with rounded elements.</returns>
        public static double[,] RoundToNextInt(this double[,] source)
        {
            var rows = source.GetLength(0);
            var cols = source.GetLength(1);

            var result = new double[rows, cols];

            for (var i = 0; i < rows; i++)
            {
                for (var j = 0; j < cols; j++)
                {
                    result[i, j] = Math.Round(source[i, j]);
                }
            }

            return result;
        }
    }
}
using System;
using System.Linq;

namespace Utilities.Extensions
{
    public static class RandomExtensions
    {
        public static double[] NextVector(this Random rand, int size)
        {
            var vector = Enumerable.Range(0, size)
                .Select(_ => rand.NextDouble()).ToArray();
            var norm = vector.Magnitude();
            return vector.Select(x => x / norm).ToArray();
        }
    }
}
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
    <CodeAnalysisRuleSet>..\stylecop.ruleset</CodeAnalysisRuleSet>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DocumentationFile>./bin/Utilities.xml</DocumentationFile>
  </PropertyGroup>

  <ItemGroup>
    <AdditionalFiles Include="..\stylecop.json" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="StyleCop.Analyzers" Version="1.1.118">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

</Project>
