#include <stdio.h>

// Euclid's algorithm
int GCD(int x, int y)
{
    if (y == 0)
        return x;
    return GCD(y, x % y);
}

int main()
{
    int a, b;
    printf("Input two numbers:\n");
    scanf("%d %d", &a, &b);
    printf("Greatest common divisor: %d\n", GCD(a, b));
}
/**
 * @file
 * @brief Implementation of [Addition of two polynomials]
 * (https://en.wikipedia.org/wiki/Polynomial#Addition)
 * @author [Ankita Roy Chowdhury](https://github.com/Ankita19ms0010)
 * @details
 * This code takes two polynomials as input
 * and prints their sum using linked list.
 * The polynomials must be in increasing or decreasing order of degree.
 * Degree must be positive.
 */
#include <stdio.h>  // for io operations
#include <stdlib.h>

/**
 * @brief identifier for single-variable polynomial coefficients as a linked
 * list
 */
struct term
{
    int coef;          /**< coefficient value */
    int pow;           /**< power of the polynomial term */
    struct term *next; /**< pointer to the successive term */
};

/**
 * @brief Frees memory space
 * @param poly first term of polynomial
 * @returns void
 */
void free_poly(struct term *poly)
{
    if (!poly)
    {
        return;  // NULL pointer does not need delete
    }
    else
    {
        while (!poly->next)
        {
            free(poly->next);  // Deletes next term
        }
        free(poly);  // delete the current term
    }
}

/**
 * The function will create a polynomial
 * @param poly stores the address of the polynomial being created
 * @param coef contains the coefficient of the node
 * @param pow contains the degree
 * @returns none
 */
void create_polynomial(struct term **poly, int coef, int pow)
{
    // Creating the polynomial using temporary linked lists
    struct term *temp1, *temp2;
    temp1 = *poly;  // Contains the null pointer

    // Initiating first term
    if (temp1 == NULL)
    {
        temp2 = (struct term *)malloc(
            sizeof(struct term));  // Dynamic node creation
        temp2->coef = coef;
        temp2->pow = pow;
        // Updating the null pointer with the address of the first node of the
        // polynomial just created
        *poly = temp2;
        temp2->next = NULL;  // Increasing the pointer temp2
    }
    // Creating the rest of the nodes
    else
    {
        temp2->next = (struct term *)malloc(
            sizeof(struct term));  // Dynamic node creation
        temp2 = temp2->next;       // Increasing the pointer temp2
        temp2->coef = coef;
        temp2->pow = pow;
        temp2->next = NULL;
    }
}

/**
 * The function will add 2 polynomials
 * @param poly1 first polynomial of the addition
 * @param poly2 second polynomial of the addition
 * @param pol  the resultant polynomial
 */

void poly_add(struct term **pol, struct term *poly1, struct term *poly2)
{
    // Creating a temporary linked list to store the resultant polynomial
    struct term *temp = (struct term *)malloc(sizeof(struct term));
    temp->next = NULL;
    *pol =
        temp;  //*pol always points to the 1st node of the resultant polynomial

    // Comparing the powers of the nodes of both the polynomials
    // until one gets exhausted
    while (poly1 && poly2)
    {
        /* If the power of the first polynomial is greater than the power of the
       second one place the power and coefficient of that node of the first
       polynomial in temp and increase the pointer poly1
       */
        if (poly1->pow > poly2->pow)
        {
            temp->coef = poly1->coef;
            temp->pow = poly1->pow;
            poly1 = poly1->next;
        }
        /* If the power of the second polynomial is greater than the power of
          the first one place the power and coefficient of that node of the
          second polynomial in temp and increase the pointer poly2
        */
        else if (poly1->pow < poly2->pow)
        {
            temp->coef = poly2->coef;
            temp->pow = poly2->pow;
            poly2 = poly2->next;
        }
        /* If both of them have same power then sum the coefficients
          place both the summed coefficient and the power in temp
          increase both the pointers poly1 and poly2
        */
        else
        {
            temp->coef = poly1->coef + poly2->coef;
            temp->pow = poly1->pow;
            poly1 = poly1->next;
            poly2 = poly2->next;
        }
        /* If none of the polynomials are exhausted
         dynamically create a node in temp
         */
        if (poly1 && poly2)
        {
            temp->next = (struct term *)malloc(
                sizeof(struct term));  // Dynamic node creation
            temp = temp->next;         // Increase the pointer temp
            temp->next = NULL;
        }
    }
    /* If one of the polynomials is exhausted
    place the rest of the other polynomial as it is in temp
    by creating nodes dynamically
    */
    while (poly1 || poly2)
    {
        temp->next = (struct term *)malloc(
            sizeof(struct term));  // Dynamic node creation
        temp = temp->next;         // Increasing the pointer
        temp->next = NULL;

        /* If poly1 is not exhausted
        place rest of that polynomial in temp
        */
        if (poly1)
        {
            temp->coef = poly1->coef;
            temp->pow = poly1->pow;
            poly1 = poly1->next;
        }
        /* If poly2 is not exhausted
       place rest of that polynomial in temp
       */
        else if (poly2)
        {
            temp->coef = poly2->coef;
            temp->pow = poly2->pow;
            poly2 = poly2->next;
        }
    }
}

/**
 * The function will display the polynomial
 * @param poly first term of the polynomial to be displayed
 * @returns none
 */
void display_polynomial(struct term *poly)
{
    while (poly != NULL)
    {
        printf("%d x^%d", poly->coef, poly->pow);
        poly = poly->next;
        if (poly != NULL)
        {
            printf(" + ");
        }
    }
}

/**
 * @brief Test function 1
 *
 * @details
 * Polynomial 1 is 5 x^2 + 3 x^1 + 2 x^0
 * Polynomial 2 is 7 x^3 + 9 x^1 + 10 x^0
 * Resultant polynomial is 7 x^3 + 5 x^2 + 12 x^1 + 12 x^0
 * @returns void
 */
static void test1(struct term *poly1, struct term *poly2, struct term *poly3)
{
    printf("\n----Test 1----\n");
    printf("\nFirst Polynomial:\n");  // Defining the 1st polynomial
    create_polynomial(&poly1, 5, 2);
    create_polynomial(&poly1, 3, 1);
    create_polynomial(&poly1, 2, 0);
    display_polynomial(poly1);

    printf("\nSecond Polynomial:\n");  // Defining the 2nd polynomial
    create_polynomial(&poly2, 7, 3);
    create_polynomial(&poly2, 9, 1);
    create_polynomial(&poly2, 10, 0);
    display_polynomial(poly2);

    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials
    printf("\nResultant polynomial:\n");
    display_polynomial(poly3);
    printf("\n");

    // Frees memory space
    free_poly(poly1);
    free_poly(poly2);
    free_poly(poly3);
}

/**
 * @brief Test function 2
 *
 * @details
 * Polynomial 1 is 3 x^5 + 1 x^4 + 2 x^3 + -2 x^1 + 5 x^0
 * Polynomial 2 is 2 x^5 + 3 x^3 + 7 x^1 + 2 x^0
 * Resultant polynomial is 5 x^5 + 1 x^4 + 5 x^3 + 5 x^1 + 7 x^0
 * @returns void
 */
static void test2(struct term *poly1, struct term *poly2, struct term *poly3)
{
    printf("\n----Test 2----\n");
    printf("\nFirst Polynomial:\n");  // Defining the 1st polynomial
    create_polynomial(&poly1, 3, 5);
    create_polynomial(&poly1, 1, 4);
    create_polynomial(&poly1, 2, 3);
    create_polynomial(&poly1, -2, 1);
    create_polynomial(&poly1, 5, 0);

    display_polynomial(poly1);

    printf("\nSecond Polynomial:\n");  // Defining the 2nd polynomial
    create_polynomial(&poly2, 2, 5);
    create_polynomial(&poly2, 3, 3);
    create_polynomial(&poly2, 7, 1);
    create_polynomial(&poly2, 2, 0);

    display_polynomial(poly2);

    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials
    printf("\nResultant polynomial:\n");
    display_polynomial(poly3);
    printf("\n");

    // Frees memory space
    free_poly(poly1);
    free_poly(poly2);
    free_poly(poly3);
}

/**
 * @brief Test function 3
 *
 * @details
 * Polynomial 1 is -12 x^0 + 8 x^1 + 4 x^3
 * Polynomial 2 is 5 x^0 + -13 x^1 + 3 x^3
 * Resultant polynomial is -7 x^0 + -5 x^1 + 7 x^3
 * @returns void
 */
static void test3(struct term *poly1, struct term *poly2, struct term *poly3)
{
    printf("\n----Test 3----\n");
    printf("\nFirst Polynomial:\n");  // Defining the 1st polynomial
    create_polynomial(&poly1, -12, 0);
    create_polynomial(&poly1, 8, 1);
    create_polynomial(&poly1, 4, 3);

    display_polynomial(poly1);

    printf("\nSecond Polynomial:\n");  // Defining the 2nd polynomial
    create_polynomial(&poly2, 5, 0);
    create_polynomial(&poly2, -13, 1);
    create_polynomial(&poly2, 3, 3);

    display_polynomial(poly2);

    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials
    printf("\nResultant polynomial:\n");
    display_polynomial(poly3);
    printf("\n");

    // Frees memory space
    free_poly(poly1);
    free_poly(poly2);
    free_poly(poly3);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main(void)
{
    struct term *poly1 = NULL, *poly2 = NULL, *poly3 = NULL;
    test1(poly1, poly2, poly3);
    test2(poly1, poly2, poly3);
    test3(poly1, poly2, poly3);

    return 0;
}
#include <stdio.h>

int main()
{
    int a[16500], T;
    long long int i, j;

    printf("Enter number of test cases : ");
    scanf("%d", &T);

    while (T--)
    {
        for (i = 0; i < 16500; i++)
        {
            a[i] = 0;
        }

        a[1] = 1;
        int N, carry = 0, count = 0;
        printf("Enter a number : ");
        scanf("%d", &N);

        for (i = 1; i <= N; i++)
        {
            carry = 0;
            for (j = 0; j < 16500; j++)
            {
                a[j] = a[j] * i + carry;
                carry = a[j] / 10;
                a[j] = a[j] % 10;
            }
        }

        for (i = 0; i < 16500; i++)
        {
            if (a[i] != 0)
            {
                count = i;
            }
        }

        for (i = count; i > 0; i--)
        {
            printf("%d", a[i]);
        }
        printf("\n");
    }

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
void swap(int *a, int *b)
{
    int t;
    t = *a;
    *a = *b;
    *b = t;
}
int part(int a[], int l, int r, int n, int pivot, int pindex)
{
    int p1 = l, p2 = r;
    while (p2 > p1)
    {
        if (a[p1] > pivot && a[p2] < pivot)
        {
            swap(&a[p1], &a[p2]);
        }
        else
        {
            if (a[p1] <= pivot)
            {
                p1++;
            }
            if (a[p2] >= pivot)
            {
                p2--;
            }
        }
    }
    swap(&a[pindex], &a[p2]);
    return p2;
}
int rselect(int a[], int l, int r, int n, int o)
{
    int pivot, pindex, pactual;
    if (r > l)
    {
        pindex = rand() % (r - l + 1);
        pivot = a[pindex];
        pactual = part(a, l, r, n, pivot, pindex);

        if (pactual == o)
        {
            return a[pactual];
        }

        if (o < pactual)
        {
            rselect(a, l, pactual - 1, n, o);
        }

        if (o > pactual)
        {
            rselect(a, pactual + 1, r, n, o - pactual);
        }
    }
    if (r == l)
    {
        return a[l];
    }
    return -1;
}
int main()
{
    srand(time(NULL));
    int n, o, i, *a;
    scanf("%d %d", &n, &o);
    a = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", a + i);
    }
    printf("\n\n%d", rselect(a, 0, n - 1, n, o));
    return 0;
}
/**
 * @file
 * @brief [Prime Seive](https://leetcode.com/problems/count-primes/)
 * algorithm implementation.
 * @author [Divyansh Kushwaha](https://github.com/webdesignbydivyansh)
 */
#include <assert.h>	/// for assert
#include <stdio.h>	/// for standard input output
#include <stdlib.h>	/// for general purpose standard library

const unsigned long long MAX_SIZE = 1000000;  /// variable upto which prime numbers are to be found out
/**
 * @addtogroup misc
 * @{
 */
/**
 * @brief Prime Sieve works in O(nlogn) time
 * @param p array to be updated
 * @returns void
 */
void prime(int *p)
{
	for(long long int i=3;i<=MAX_SIZE;i+=2) { p[i]=1; }
	for(long long int i=3;i<=MAX_SIZE;i+=2)
	{
		if(p[i]==1) {
		    for(long long int j=i*i;j<=MAX_SIZE;j+=i) {
			p[j]=0;
		    }
		}
	}
	p[2]=1;
	p[0]=p[1]=0;    
}
/**
 * @brief Count func counts the number of 
 * prime numbers.
 * @param arr contains the prime numbers
 * @param size denotes upto which prime numbers are to be found out
 * @returns count of prime numbers
 */
int count(int *arr, const int size){
  int k=0;
  for(int i=0;i<=size;i++){
    if(arr[i]==1){
      k++;
    }
  }
  return k;
}

/**
 * @brief Test implementations
 * @returns void
 */
static void test()
{
    // Test Case 1
    const int size = 10; /* array size */
    printf("Test Case 1...");
    int arr[1000005]={0};   /* array to store prime numbers */
    prime(arr);
    assert(count(arr,size)==4);
    printf("Passed\n");
}

/** 
 * @brief Main function
 * @param argc commandline argument count (ignored)
 * @param argv commandline array of arguments (ignored)
 * @returns 0 on exit
 */
int main(int argc, const char *argv[])
{
    test();	// execute the tests
    return 0;
}
/**
 * @file
 * @brief Function to convert a Cartesian co-ordinate to polar form.
 */
#define _USE_MATH_DEFINES /**< required for MS Visual C */
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

/**
 * @brief Function to convert cartesian coordinates to polar.
 *\f{eqnarray*}{
 r &=& \sqrt{x^2+y^2}\\
 \theta &=& \atan\frac{y}{x}
 \f}
 * @param [in] x absicca value
 * @param [in] y ordinate value
 * @param [out] r pointer to store polar radius
 * @param [out] theta pointer to store polar angle (in radian)
 */
void to_polar(double x, double y, double *r, double *theta)
{
    double thetaFinal = 0.f;

    *r = sqrt(x * x + y * y);

    if (x != 0)
    {
        if (y != 0)
        {
            *theta = atan(y / x);
            if ((x > 0 && y > 0) || (x == -y))
            {  // Q1
                thetaFinal = *theta;
            }
            else if (x < 0 && y > 0)
            {  // Q2
                thetaFinal = *theta + M_PI;
            }
            else if (x < 0 && y < 0)
            {  // Q3
                thetaFinal = *theta - M_PI;
            }
            else if (x > 0 && y < 0)
            {  // Q4
                thetaFinal = 2 * M_PI - *theta;
            }
            else
            {
                fprintf(stderr, "Should not reach here!\n");
            }
        }
    }
    else
    {  // exceptions when no actual angle is present
        if (y > 0)
        {
            thetaFinal = M_PI / 2;
        }
        else
        {
            thetaFinal = -(M_PI / 2);
        }
    }
    if (y == 0)
    {
        if (x > 0)
        {
            thetaFinal = 0;
        }
        else
        {
            thetaFinal = -M_PI;
        }
    }

    *theta = thetaFinal;
}

/**
 * @brief Generate a random number in the given limits
 *
 * @param lim1 lower limit
 * @param lim2 upper limit
 * @return random number in the given range
 */
double get_rand(double lim1, double lim2)
{
    double r = (double)rand() / RAND_MAX;  // value in [0,1)
    return (lim2 - lim1) * r + lim1;       // scale to range
}

/**
 * @brief Test implementation
 *
 */
void test()
{
    srand(10);
    int NUM_TESTS = 5;

    for (int i = 0; i < NUM_TESTS; i++)
    {
        double r, theta;
        printf("Test %d.... ", i);
        double x = get_rand(-5, 5);
        double y = get_rand(-5, 5);
        printf("(%.2g, %.2g).... ", x, y);
        to_polar(x, y, &r, &theta);
        assert(fabs(r - hypot(x, y)) < 0.01);
        assert(fabs(theta - atan2(y, x)) < 0.01);
        printf("passed\n");
    }
}

/** Main function */
int main()
{
    test();

    return 0;
}
// Recursion problem
// Given the denominations of currencies available in a system, find the number
// of ways an ATM machine can generate notes for an entered amount N.

#include <stdio.h>
#include <stdlib.h>

int ways(int n, int *a, int k)
{
    if (n < 0 || k < 0)
        return 0;
    if (n == 0)
        return 1;
    if (k == 0)
        return 0;
    return ways(n, a, k - 1) + ways(n - a[k - 1], a, k);
}

int main()
{
    int m;
    int t;
    int n;

    printf("Number of coins? ");
    scanf("%d", &m);
    int *coin = (int *)malloc(m * sizeof(int)), i;
    for (i = 0; i < m; i++)
    {
        printf("coin? ");
        scanf("%d", &coin[i]);
    }

    printf("---- your requests --- \n");
    while (1)
    {
        printf("amount? exit(0) ");
        scanf("%d", &n);
        if (!n)
        {
            break;
        }
        printf("%d\n", ways(n, coin, m));
    }

    free(coin);
    return 0;
}
/*
    AUTHOR: Christian Bender
    DATE: 12.02.2019
    DESCRIPTION: This program calculates the prime factoriziation of a positive
   integer > 1
*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* initial length of the dynamic array */
#define LEN 10

/* increasing range */
#define STEP 5

/*
    this type is for the representation of the prim factoriziation
    - its series/range of prime factors
    - its length : numbers of prime factors
*/
typedef struct data
{
    int *range;
    int length;
} range;
typedef range *Range;

/* int_fac : calculates the prime factoriziation of positive integers */
Range int_fact(int);

/* print_arr : prints the integer (heap) array*/
void print_arr(Range);

/* increase : increases the dynamic integer array */
int *increase(int *, int);

/* destroy: destroys the range-structure */
void destroy(Range);

/*
    main : simle frame program with a simple UI
*/
int main()
{
    int n = 0; /* for user input */

    printf("\t\tPrim factoriziation\n\n");
    printf("positive integer (> 1) ? ");
    scanf("%d", &n);
    Range r = int_fact(n);
    printf("\nThe factoriziation are: ");
    print_arr(r);
    destroy(r);
    return 0;
}

Range int_fact(int n)
{
    assert(n > 1); /* precondition : n must be greater then 1*/

    int len = LEN;
    int count = 0;
    int i = 0;
    int *range = (int *)malloc(sizeof(int) * len);
    assert(range);
    Range pstr = (Range)malloc(sizeof(range));
    assert(pstr);

    while (n % 2 == 0)
    {
        n /= 2;
        if (i < len)
        {
            range[i] = 2;
            i++;
        }
        else
        {
            range = increase(range, len);
            len += STEP;
            range[i] = 2;
            i++;
        }
        count++;
    }

    int j = 3;
    while (j * j <= n)
    {
        while (n % j == 0)
        {
            n /= j;
            if (i < len)
            {
                range[i] = j;
                i++;
            }
            else
            {
                range = increase(range, len);
                len += STEP;
                range[i] = j;
                i++;
            }
            count++;
        }

        j += 2;
    }

    if (n > 1)
    {
        if (i < len)
        {
            range[i] = n;
            i++;
        }
        else
        {
            range = increase(range, len);
            len += STEP;
            range[i] = n;
            i++;
        }
        count++;
    }

    pstr->range = range;
    pstr->length = count;
    return pstr;
}

void print_arr(Range pStr)
{
    assert(pStr); /* checks whether pStr is a null-pointer */
    int i = 0;
    printf("\n");
    for (i; i < pStr->length; i++)
    {
        if (i == 0)
            printf("%d", pStr->range[0]);
        else
            printf("-%d", pStr->range[i]);
    }
    printf("\n");
}

int *increase(int *arr, int len)
{
    assert(arr); /* checks whether arr is a null-pointer */
    int *tmp = (int *)realloc(arr, sizeof(int) * (len + STEP));
    assert(tmp);
    return tmp;
    //    assert(arr);
}

void destroy(Range r)
{
    free(r->range);
    free(r);
}

#include <stdio.h>
#include <stdlib.h>

// Function for Tower of Hanoi algorithm
void hanoi(int noOfDisks, char where, char to, char extra)
{
    if (noOfDisks != 0)
    {
        hanoi(noOfDisks - 1, where, extra, to);
        printf("Move disk : %d from %c to %c\n", noOfDisks, where, to);
        hanoi(noOfDisks - 1, extra, to, where);
    }
}
int main(void)
{
    int noOfDisks;

    // Asks the number of disks in the tower
    printf("Number of disks: \n");
    scanf("%d", &noOfDisks);

    hanoi(noOfDisks, 'A', 'B', 'C');

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void longestSub(int *ARRAY, int ARRAY_LENGTH, int **RESULT, int *RESULT_LENGTH)
{  // RESULT and RESULT_LENGTH will be modified by their pointers

    if (ARRAY_LENGTH <= 1)
    {
        *RESULT = ARRAY;
        *RESULT_LENGTH = ARRAY_LENGTH;
    }
    else
    {
        int PIVOT = ARRAY[0];
        int *LONGEST_SUB = NULL;
        int i, j, LONGEST_SUB_LENGTH = 0;
        int TEMPORARY_ARRAY_LENGTH = 0, *TEMPORARY_ARRAY = NULL;

        for (i = 1; i < ARRAY_LENGTH; i++)
        {
            if (ARRAY[i] < PIVOT)
            {
                TEMPORARY_ARRAY_LENGTH = 0;
                TEMPORARY_ARRAY = NULL;

                for (j = i + 1; j < ARRAY_LENGTH; j++)
                {
                    if (ARRAY[j] >= ARRAY[i])
                    {
                        TEMPORARY_ARRAY_LENGTH++;
                        TEMPORARY_ARRAY = (int *)realloc(
                            TEMPORARY_ARRAY,
                            TEMPORARY_ARRAY_LENGTH * sizeof(int));
                        TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[j];
                    }
                }

                longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH,
                           &TEMPORARY_ARRAY, &TEMPORARY_ARRAY_LENGTH);
                if (LONGEST_SUB_LENGTH < TEMPORARY_ARRAY_LENGTH + 1)
                {
                    LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;
                    LONGEST_SUB = (int *)realloc(
                        LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));
                    LONGEST_SUB[0] = ARRAY[i];

                    for (i = 1; i < LONGEST_SUB_LENGTH; i++)
                        LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];
                }
            }
        }

        TEMPORARY_ARRAY = NULL;
        TEMPORARY_ARRAY_LENGTH = 0;
        for (i = 1; i < ARRAY_LENGTH; i++)
        {
            if (ARRAY[i] >= PIVOT)
            {
                TEMPORARY_ARRAY_LENGTH++;
                TEMPORARY_ARRAY = (int *)realloc(
                    TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH * sizeof(int));
                TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[i];
            }
        }

        longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH, &TEMPORARY_ARRAY,
                   &TEMPORARY_ARRAY_LENGTH);
        if (TEMPORARY_ARRAY_LENGTH + 1 > LONGEST_SUB_LENGTH)
        {
            LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;
            LONGEST_SUB =
                (int *)realloc(LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));
            LONGEST_SUB[0] = PIVOT;
            for (i = 1; i < LONGEST_SUB_LENGTH; i++)
                LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];
        }
        *RESULT = LONGEST_SUB;
        *RESULT_LENGTH = LONGEST_SUB_LENGTH;
    }
}

int main()
{
    int EXAMPLE_LENGTH = 8;
    int EXAMPLE[] = {18, 2, 15, 4, 30, 0, 11, 12};

    int *RESULT = NULL;
    int RESULT_LENGTH, i;

    longestSub(EXAMPLE, EXAMPLE_LENGTH, &RESULT, &RESULT_LENGTH);

    printf("Longest Sub Sequence length: %d and it's:\n", RESULT_LENGTH);
    for (i = 0; i < RESULT_LENGTH; i++) printf("%d ", RESULT[i]);
    printf("\n");

    return 0;
}/**
 * PID Controller
 *
 * The PID controller is a linear control algorithm that has three terms:
 *  - Proportional: A simple scaling of the error value by a gain kP
 *  - Integral: Integration of the error value over time, then multipled by gain
 * kI
 *  - Derivative: Rate of change of the error value over time, multiplied by
 * gain kD
 *
 * Terms of the controller can be removed by setting their gain to 0, creating a
 * PI (kD = 0) or PD (kI = 0) controller. Depending on the control problem at
 * hand, some terms may not increase the performance of the system, or may have
 * a negative effect.
 *
 * For a more mathematical expanation of the PID Controller, see
 * https://en.wikipedia.org/wiki/PID_controller
 *
 * Limitations of this implementation:
 *  - Since this implementation is just for demonstration, the pid_step function
 * takes the dt as a parameter, and it can be provided by the user in main().
 * This allows deterministic experimentation with the algorithm, rather than
 * using time(NULL) which would make the function non-deterministic.
 *
 * Inputs: e(t) - Current error at time t. For example, how far a servo is off
 * the desired angle Output: u(t) - Controller output at time t.
 */
#include <stdio.h>

struct pid
{
    // Controller gains
    float kP;
    float kI;
    float kD;

    // State variables
    float lastError;
    float integral;
};

float pid_step(struct pid *controller, float dt, float error)
{
    // Calculate p term
    float p = error * controller->kP;

    // Calculate i term
    controller->integral += error * dt * controller->kI;

    // Calculate d term, taking care to not divide by zero
    float d =
        dt == 0 ? 0 : ((error - controller->lastError) / dt) * controller->kD;
    controller->lastError = error;

    return p + controller->integral + d;
}

int main()
{
    printf("PID Controller Example\n");

    struct pid controller = {.lastError = 0, .integral = 0};

    // Take the controller gains from the user
    printf(
        "Please enter controller gains in format kP, kI, KD. For example, "
        "\"1.2 2.1 3.2\"\n> ");
    scanf("%f %f %f", &controller.kP, &controller.kI, &controller.kD);
    printf("Using kP: %f, kI: %f, kD: %f\n", controller.kP, controller.kI,
           controller.kD);

    // How often the pid_step algorithm expects to be called. In a real life
    // scenario this would be provided by calling time(NULL) - last_time, or by
    // calling the function reliably at X Hz (using a timer or RTOS etc) For
    // demonstration of this algorithm though, it is defined below as 1 second,
    // allowing easy testing of integral and derivative terms.
    float time_step = 1;

    float error_value;
    while (1)
    {
        printf("Enter error value\n>");
        scanf("%f", &error_value);

        float output = pid_step(&controller, time_step, error_value);
        printf("Output: %f\n", output);
    }
}
/**
 * \file
 *
 * \brief Implementation of [Collatz'
 * conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture)
 *
 * Collatz conjecture: a series for a number \f$n\f$ in which if \f$n\f$ even
 * then the next number is \f$\frac{n}{2}\f$ ,but if n is odd then the next
 * number is \f$3n+1\f$. This series continues till \f$n\f$ reaches 1
 */

#include <stdio.h>
#include <stdlib.h>

/** Main function */
int main(int argc, char *argv[])
{
    unsigned long long n, curr_no, num_steps = 0;
    if (argc == 2)
        n = strtoull(argv[1], NULL, 10);
    else
    {
        printf("Enter starting number: ");
        scanf("%lu", &n);  // input number
    }

    curr_no = n;          // curr_no stores input number n
    while (curr_no != 1)  // loop till series reaches 1
    {
        num_steps++;
        printf("%llu->", curr_no);
        if (curr_no % 2 == 0)  // condition   for even number
            curr_no = curr_no / 2;
        else
            curr_no = (curr_no * 3) + 1;  // condition for odd number
    }
    printf("1\nNumber of steps: %llu\n", num_steps);
    return 0;
}
/**
 * @file union_find.c
 * @brief [Union
 * find](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) algorithm.
 */
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 1000 /**< maximum number of elements in the set */

/**
 * @brief Find index of or value in an array
 *
 * @param [in,out] p array to search and update
 * @param x value to search
 * @return value at the index `x`
 */
int find(int *p, int x)
{
    if (x >= MAX_SIZE)
    {
        fprintf(stderr, "Out-of bounds value\n");
        exit(EXIT_FAILURE);
    }

    if (p[x] == x)
    {
        return x;
    }
    else
    {
        p[x] = find(p, p[x]);
        return p[x];
    }
}

/**
 * @brief Function to join
 * @param [in,out] p array to join in
 * @param x value or index to join to
 * @param y value or index to join from
 */
void join(int *p, int x, int y) { p[find(p, x)] = find(p, y); }

/** Main function */
int main()
{
    int union_set[MAX_SIZE];

    // Have all array indexes that you need to use reference themselves
    for (int i = 0; i < 10; i++)
    {
        union_set[i] = i;
    }
    // p = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

    join(union_set, 3, 5);
    printf("The array is now: ");
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", union_set[i]);
    }
    printf("\n");
    // Now 3 and 5 are groupped together, that is find(3) = find(5)
    // p = {0, 1, 2, 5, 4, 5, 6, 7, 8, 9}

    join(union_set, 3, 8);
    printf("The array is now: ");
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", union_set[i]);
    }
    printf("\n");

    // Now 3, 5 and are groupped together, find(3) = find(5) = find(8)
    // p = {0, 1, 2, 5, 4, 8, 6, 7, 8, 9}
    join(union_set, 0, 5);
    if (find(union_set, 0) == find(union_set, 3))
    {
        printf("0 and 3 are groupped together\n");
    }
    printf("The array is now: ");
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", union_set[i]);
    }
    printf("\n");

    return 0;
}
// A number is called as Armstrong number if sum of cubes of digits of number is
// equal to the number itself.
// For Example 153 is an Armstrong number because 153 = 1³+5³+3³.
#include <stdio.h>

// Function to calculate x raised to the power y
int power(int x, unsigned int y)
{
    if (y == 0)
        return 1;
    if (y % 2 == 0)
        return power(x, y / 2) * power(x, y / 2);
    return x * power(x, y / 2) * power(x, y / 2);
}

// Function to calculate order of the number
int order(int x)
{
    int n = 0;
    while (x)
    {
        n++;
        x = x / 10;
    }
    return n;
}

// Function to check whether the given number is
// Armstrong number or not
int isArmstrong(int x)
{
    // Calling order function
    int n = order(x);
    int temp = x, sum = 0;
    while (temp)
    {
        int r = temp % 10;
        sum += power(r, n);
        temp = temp / 10;
    }

    // If satisfies Armstrong condition
    if (sum == x)
        return 1;
    else
        return 0;
}

//
int main()
{
    int x = 153;
    if (isArmstrong(x) == 1)
        printf("True\n");
    else
        printf("False\n");

    x = 1253;
    if (isArmstrong(x) == 1)
        printf("True\n");
    else
        printf("False\n");

    return 0;
}
#include <stdio.h>

// Fibonnacci function
int fib(int number)
{
    if (number == 1 || number == 2)
        return 1;
    else
        return fib(number - 1) + fib(number - 2);
}

int main()
{
    int number;

    // Asks for the number that is in n position in Fibonnacci sequence
    printf("Number: ");
    scanf("%d", &number);

    printf("%d \n", fib(number));

    return 0;
}/**
 * @file
 * \brief Compute factorial of arbitrarily large numbers by
 * storing individual digits in a byte.
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * dynamically large number
 */
typedef struct _large_num
{
    char *digits;            /**< array to store individual digits */
    unsigned int num_digits; /**< number of digits in the number */
} large_num;

/**
 * create a new large number
 * \returns pointer to a large number
 */
large_num *new_number(void)
{
    large_num *new_num = (large_num *)malloc(sizeof(large_num));
    new_num->num_digits = 1;
    new_num->digits = (char *)malloc(1 * sizeof(char));
    new_num->digits[0] = 1;
    return new_num;
}

/**
 * delete all memory allocated for large number
 * \param[in] num pointer to large_num to delete
 */
void delete_number(large_num *num)
{
    free(num->digits);
    free(num);
}

/**
 * add a digit to the large number
 * \param[in,out] num
 * \param[in] value value of the digit to insert
 */
void add_digit(large_num *num, unsigned int value)
{
    if (value > 9)
    {
        fprintf(stderr, "digit > 9!!\n");
        delete_number(num);
        exit(EXIT_FAILURE);
    }

    num->num_digits++;
    num->digits = (char *)realloc(num->digits, num->num_digits * sizeof(char));
    num->digits[num->num_digits - 1] = value;
}

/**
 * multiply large number with another integer and
 * store the result in the same large number
 */
void multiply(large_num *num, unsigned long n)
{
    int i;
    unsigned long carry = 0, temp;
    for (i = 0; i < num->num_digits; i++)
    {
        temp = num->digits[i] * n;
        temp += carry;
        if (temp < 10)
            carry = 0;
        else
        {
            carry = temp / 10;
            temp = temp % 10;
        }
        num->digits[i] = temp;
    }

    while (carry != 0)
    {
        add_digit(num, carry % 10);
        carry /= 10;
    }
}

/**
 * main function
 */
int main(int argc, char *argv[])
{
    int number, i;

    // Asks for the number/position of term in Fibonnacci sequence
    if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf("Enter the value of n(n starts from 0 ): ");
        scanf("%d", &number);
    }

    large_num *result = new_number();

    clock_t start_time = clock();
    for (i = 2; i <= number; i++) /* Multiply every number from 2 thru N */
        multiply(result, i);
    double time_taken = (clock() - start_time) * (double)1e3 / CLOCKS_PER_SEC;
    // time_taken = (clock() - start_time) / (double) CLOCKS_PER_SEC;

    printf("%d! = ", number);
    for (i = result->num_digits; i > 0; i--)
        putchar(result->digits[i - 1] + '0');
    printf("\nTime taken: %.4g ms\n", time_taken);

    delete_number(result);
    return 0;
}
/*
programme for computing number of zeroes at the end of factorial of a given
number n
*/
#include <math.h>  //including math.h header file to use pow function
#include <stdio.h>
int main()
{
    int i, n, test = 0, count = 0;
    // taking input number n
    scanf("%d", &n);

    // looping from 1 till loop break
    for (i = 1;; i++)
    {
        test =
            n /
            pow(5,
                i);  // division of n by ith power of 5(storing in integer form)
        if (test !=
            0)  // condition for zeroes at end corresponding individual ith case
        {
            count = count + test;
        }
        else
            break;  // break the loop for if test=0
    }
    printf("%d\n", count);
    return 0;
}
// C program to find LCM of two numbers
/*
    suppose we have two numbers a and b.
    Property: Since product of LCM and GCD of two numbers are equal to product
   of that number itself. i.e, LCM(a,b)*GCD(a,b)=a*b. So,here we first find the
   GCD of two numbers and using above property we find LCM of that two numbers.
*/
#include <stdio.h>

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

// Function to return LCM of two numbers
int lcm(int a, int b) { return (a * b) / gcd(a, b); }

// Driver program
int main()
{
    int a, b;
    printf("Enter two numbers to find their LCM \n");
    scanf("%d%d", &a, &b);
    printf("LCM of %d and %d is %d ", a, b, lcm(a, b));
    return 0;
}
/*
Test Case1:
a=15,b=20
LCM(a,b)=60
Test Case2:
a=12,b=18
LCM(a,b)=36
*/
/**
 * @file
 * @brief Sudoku Solver using recursive implementation of brute-force algorithm
 *
 * @details
 * Given an incomplete N*N Sudoku and asked to solve it using the
 * following recursive algorithm:
 * 1. Scan the Sudoku from left to right row-wise to search for an empty cell.
 * 2. If there are no empty cells, print the Sudoku. Go to step 5.
 * 3. In the empty cell, try putting numbers 1 to N
 * while ensuring that no two numbers in a single row, column, or box are same.
 * Go back to step 1.
 * 4. Declare that the Sudoku is Invalid.
 * 5. Exit.
 *
 * @authors [Anuj Shah](https://github.com/anujms1999)
 * @authors [Krishna Vedala](https://github.com/kvedala)
 */
#include <assert.h>
#include <inttypes.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/** @addtogroup sudoku Sudoku solver
 * @{
 */
/** Structure to hold the matrix and dimensions
 */
struct sudoku
{
    uint8_t *a; /**< matrix as a flattened 1D row-major array */
    uint8_t N;  /**< number of elements */
    uint8_t N2; /**< block of elements */
};

/**
 * Check if `x`^th row is valid
 * @param a ::sudoku to check
 * @param x row to check
 * @param y ignored column
 * @param v value to check if it repeats
 * @returns `true` if valid
 * @returns `false` if in-valid
 */
bool OKrow(const struct sudoku *a, int x, int y, int v)
{
    int offset = x * a->N;
    for (int j = 0; j < a->N; j++)
        if (a->a[offset + j] == v)
            // if the value is found in the row
            return false;
    return true;
}

/**
 * Check if `y`^th column is valid
 * @param a ::sudoku to check
 * @param x ignored row
 * @param y column to check
 * @param v value to check if it repeats
 * @returns `true` if valid
 * @returns `false` if in-valid
 */
bool OKcol(const struct sudoku *a, int x, int y, int v)
{
    for (int i = 0; i < a->N; i++)
        if (a->a[i * a->N + y] == v)
            // if the value is found in the column
            return false;
    return true;
}

/**
 * Check if a 3x3 box is valid
 * @param a matrix to check
 * @param x row index of the element to check
 * @param y column index of the element to check
 * @param v value to check if it repeats
 * @returns `true` if valid
 * @returns `false` if in-valid
 */
bool OKbox(const struct sudoku *a, int x, int y, int v)
{
    /* get start indices of the box that the current (x,y) lies in
       remember that in C/C++, division operation always rounds towards
       -infinity for signed integers and towards 0 for unsigned integers
    */
    int bi = x - x % a->N2, bj = y - y % a->N2;
    // printf("Checking box: (%d,%d)\n", bi, bj);

    for (int i = bi; i < (bi + a->N2); i++)
        for (int j = bj; j < (bj + a->N2); j++)
            if (a->a[i * a->N + j] == v)
                // if the value is found in the box
                return false;
    return true;
}

/**
 * Check if element `v` is valid to place at (x,y) location.
 * @param a ::sudoku to check
 * @param x row to place value
 * @param y column to place value
 * @param v value to check if it is valid
 * @returns `true` if valid
 * @returns `false` if in-valid
 */
bool OK(const struct sudoku *a, int x, int y, int v)
{
    bool result = OKrow(a, x, y, v);
    if (result)
        result = OKcol(a, x, y, v);
    if (result)
        result = OKbox(a, x, y, v);

    return result;
}

/**
 * Print the matrix to stdout
 * @param [in] a array to print
 */
void print(const struct sudoku *a)
{
    int i, j;
    for (i = 0; i < a->N; i++)
        for (j = 0; j < a->N; j++)
            printf("%" SCNu8 "%c", a->a[i * a->N + j],
                   (j == a->N - 1 ? '\n' : ' '));
}

/**
 * @brief Find and get the location for next empty cell.
 *
 * @param [in] a pointer to sudoku instance
 * @param [out] x pointer to row index of next unknown
 * @param [out] y pointer to column index of next unknown
 * @returns `true` if an empty location was found
 * @returns `false` if no more empty locations found
 */
bool get_next_unknown(const struct sudoku *a, int *x, int *y)
{
    for (int i = 0; i < a->N; i++)
    {
        for (int j = 0; j < a->N; j++)
        {
            if (a->a[i * a->N + j] == 0)
            {
                *x = i;
                *y = j;
                return true;
            }
        }
    }

    /* no unknown locations found */
    return false;
}

/**
 * @brief Function to solve a partially filled sudoku matrix. For each unknown
 * value (0), the function fills a possible value and calls the function again
 * to check forvalid solution.
 *
 * @param [in,out] a sudoku matrix to solve
 * @return `true` if solution found
 * @return `false` if no solution found
 */
bool solve(struct sudoku *a)
{
    static uint32_t counter = 0;
    int i, j;
    static char prefix[100] = "";  // enough memory

    if (!get_next_unknown(a, &i, &j))
    {
        /* no more empty location found
           implies all good in the matrix
         */
        return true;
    }

    /* try all possible values for the unknown */
    for (uint8_t v = 1; v <= a->N; v++)
    { /* try all possible values 1 thru N */
        printf("%sTry (%d,%d) = %" SCNu8 "... ", prefix, i, j, v);
        counter++;
        if (OK(a, i, j, v))
        {
            /* if assignment checks satisfy, set the value and
             continue with remaining elements */
            printf("passed (counter=%" SCNu32 ")\n", counter);
            a->a[i * a->N + j] = v;
            strcat(prefix, "  ");
            if (solve(a))
            {
                /* solution found */
                return true;
            }

            printf("%sBacktrack (%d,%d) <- %" SCNu8 " (counter=%" SCNu32 ")\n",
                   prefix, i, j, a->a[i * a->N + j], counter);

            prefix[strlen(prefix) - 2] = '\0';  // truncate the prefix
            a->a[i * a->N + j] = 0;
        }
        else
        {
            printf("\r");
        }
    }

    return false;
}

/** @} */

void test()
{
    printf("Test begin...\n");

    uint8_t test_array[] = {3, 0, 6, 5, 0, 8, 4, 0, 0, 5, 2, 0, 0, 0, 0, 0, 0,
                            0, 0, 8, 7, 0, 0, 0, 0, 3, 1, 0, 0, 3, 0, 1, 0, 0,
                            8, 0, 9, 0, 0, 8, 6, 3, 0, 0, 5, 0, 5, 0, 0, 9, 0,
                            6, 0, 0, 1, 3, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0,
                            0, 0, 7, 4, 0, 0, 5, 2, 0, 6, 3, 0, 0};
    struct sudoku a = {.N = 9, .N2 = 3, .a = test_array};
    assert(solve(&a));  // ensure that solution is obtained

    uint8_t expected[] = {3, 1, 6, 5, 7, 8, 4, 9, 2, 5, 2, 9, 1, 3, 4, 7, 6,
                          8, 4, 8, 7, 6, 2, 9, 5, 3, 1, 2, 6, 3, 4, 1, 5, 9,
                          8, 7, 9, 7, 4, 8, 6, 3, 1, 2, 5, 8, 5, 1, 7, 9, 2,
                          6, 4, 3, 1, 3, 8, 9, 4, 7, 2, 5, 6, 6, 9, 2, 3, 5,
                          1, 8, 7, 4, 7, 4, 5, 2, 8, 6, 3, 1, 9};
    for (int i = 0; i < a.N; i++)
        for (int j = 0; j < a.N; j++)
            assert(a.a[i * a.N + j] == expected[i * a.N + j]);

    printf("Test passed\n");
}

/** \brief Main function */
int main()
{
    test();

    struct sudoku a;  // store the matrix as a 1D array
    scanf("%" SCNu8, &(a.N));
    a.a = (uint8_t *)malloc(a.N * a.N * sizeof(uint8_t));
    a.N2 = (uint8_t)sqrt(a.N);

    for (int i = 0; i < a.N; i++)
        for (int j = 0; j < a.N; j++) scanf("%" SCNu8, &(a.a[i * a.N + j]));

    printf("Entered a %udx%ud matrix with block size: %" SCNu8 "\n", a.N, a.N,
           a.N2);
    // print(&a);
    printf("\n\n");
    if (solve(&a))
        printf("Valid solution found!\n");
    else
        printf("Invalid\n");
    print(&a);

    free(a.a);
    return 0;
}
/**
 * @file
 * @brief Strong number is a number whose sum of all digits’ factorial is equal
 * to the number n For example: 145 = 1!(1) + 4!(24) + 5!(120)
 */
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>

/**
 * Check if given number is strong number or not
 * @param number
 * @return `true` if given number is strong number, otherwise `false`
 */
bool isStrong(int number)
{
    if (number < 0)
    {
        return false;
    }
    int sum = 0;
    int originalNumber = number;
    while (originalNumber != 0)
    {
        int remainder = originalNumber % 10;
        int factorial = remainder == 0 ? 0 : 1; /* 0! == 1 */

        /* calculate factorial of n */
        for (int i = 1; i <= remainder; factorial *= i, i++)
        {
            ;
        }
        sum += factorial;
        originalNumber /= 10;
    }
    return number == sum;
}

/**
 * Test function
 * @return void
 */
void test()
{
    assert(isStrong(145));  /* 145 = 1! + 4! + 5! */
    assert(!isStrong(543)); /* 543 != 5!+ 4! + 3! */
}

/**
 * Driver Code
 * @return None
 */
int main()
{
    test();
    return 0;
}
#include <stdio.h>
int main()
{
    int a[200], n, counter, temp, i;
    a[0] = 1;
    counter = 0;
    printf("Enter a whole number to Find its Factorial: ");
    scanf("%d", &n);
    if (n < 0)
        printf("Cannot Calculate factorials for negative numbers.");
    else
    {
        for (; n >= 2; n--)
        {
            temp = 0;
            for (i = 0; i <= counter; i++)
            {
                temp = (a[i] * n) + temp;
                a[i] = temp % 10;
                temp = temp / 10;
            }
            while (temp > 0)
            {
                a[++counter] = temp % 10;
                temp = temp / 10;
            }
        }
        for (i = counter; i >= 0; i--) printf("%d", a[i]);
    }
    return 0;
}
/**
    @file
    @author [Krishna Vedala](https://github.com/kvedala)
    @date 2 October, 2019
    @brief Compute \f$m^{mth}\f$ Fibonacci number using the formulae:
    \f{eqnarray*}{
        F_{2n-1} &=& F_n^2 + F_{n-1}^2 \\
        F_{2n}   &=& F_n\left(2F_{n-1} + F_n\right)
   \f}
*/

#include <locale.h>
#include <stdio.h>
#include <stdlib.h>

/**
 * Get the \f$n^{th}\f$ and \f$n+1^{th}\f$ Fibonacci number using recursive
 * half-interval decimation.
 * \param [in] n index of Fibonacci number to get
 * \param [out] C left half interval value - end result here. Cannot be NULL
 * \param [out] D right half interval can be discarded at end and can be NULL
 */
void fib(unsigned long n, unsigned long *C, unsigned long *D)
{
    // Out of Range checking
    // commented out since `n` is unsigned integer
    // if (n < 0)
    // {
    //     printf("\nNo Such term !\n");
    //     exit(0);
    // }

    unsigned long a, b, c, d;

    if (n == 0)
    {
        C[0] = 0;
        if (D) /* if D is not NULL */
            D[0] = 1;
        return;
    }

    fib(n >> 1, &c, &d); /* Compute F(n/2) */

    a = c * ((d << 1) - c);
    b = c * c + d * d;
    if (n % 2 == 0) /* If n is even */
    {
        C[0] = a;
        if (D)
            D[0] = b;
        return;
    }

    /**< If n is odd */
    C[0] = b;
    if (D) /* if D is not NULL */
        D[0] = a + b;
    return;
}

/**
 * main function
 */
int main(int argc, char *argv[])
{
    unsigned long number, result;

    setlocale(LC_NUMERIC, "");  // format the printf output

    // Asks for the number/position of term in Fibonnacci sequence
    if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf("Enter the value of n(n starts from 0 ): ");
        scanf("%lu", &number);
    }

    fib(number, &result, NULL);

    printf("The nth term is : %'lu \n", result);

    return 0;
}
/**
 * @file
 * @brief Program to identify if a number is [palindrome
 * number](https://en.wikipedia.org/wiki/Palindrome) or not.
 * @see project_euler/problem_4/sol1.c
 */
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>

bool isPalindrome(int number);

/** Driver Code */
int main()
{
    assert(isPalindrome(0));
    assert(isPalindrome(1));
    assert(isPalindrome(12321));
    assert(!isPalindrome(1234));
    return 0;
}

/**
 * Check given number whether is palindrome number or not
 * @param number number to check
 * @return `true` if given number is palindrome number
 * @return `false` if number is not a palindrome number
 */
bool isPalindrome(int number)
{
    int reversedNumber = 0;
    int originalNumber = number;
    while (number != 0)
    {
        int remainder = number % 10;
        reversedNumber = reversedNumber * 10 + remainder;
        number /= 10;
    }
    return originalNumber == reversedNumber;
}
#include <stdio.h>
#include <string.h>  // we include the library string.h to the use of string

void saisie(
    char *cpointeur);  // Prototypes of the three functions used in the program
int compte(char *s);
char *miroir(char *s);

int main(int argc, char *argv[])
{
    char chaine[20];
    saisie(chaine);
    printf("miroir est %s", miroir(chaine));
}
// this function is used to put a string
void saisie(char *cpointeur)
{
    printf("saisir une chaine\n");
    scanf("%s", cpointeur);
}
/* the function miroir (in french ) it means "mirror" , the major idea is to
permute the first caractere with the last using an auxilary variable (aux) the
the 2nd character with the penultimate one and so on . we made a call to the
function (compte) which counts the length of the string . As you can see clearly
, I substruct 1 from the equation k = compte(s)-1 ; to get rid of the EOF
caractere which is '\0' because it is not a caractere from the string typed */
char *miroir(char *s)
{
    int i;
    char aux;
    int k;
    k = compte(s) - 1;
    i = 0;
    while (i <= k)
    {
        aux = s[i];
        s[i] = s[k];
        s[k] = aux;
        k--;
        i++;
    }

    return s;
}

// compte plays the role of strlen so we can change it by an strlen function if
// you want that
int compte(char *s)
{
    char *p;
    int k;
    p = s;
    k = 0;
    while (*p != '\0')
    {
        p++;
        k++;
    }
    return k;
}
/**
 * @file
 * @brief Program to identify if a number is [prime
 * number](https://en.wikipedia.org/wiki/Prime_number) or not
 */
#include <assert.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>

/**
 * Check if a given number is prime number or not
 * @param x number to check
 * @return `true` if given number is prime number, otherwise `false`
 */
bool isPrime(int x)
{
    if (x == 2)
    {
        return true;
    }
    if (x < 2 || x % 2 == 0)
    {
        return false;
    }

    double squareRoot = sqrt(x);

    for (int i = 3; i <= squareRoot; i += 2)
    {
        if (x % i == 0)
        {
            return false;
        }
    }
    return true;
}

/**
 * Test function
 * @return void
 */
void test()
{
    /* all the prime numbers less than 100 */
    int primers[] = {2,  3,  5,  7,  11, 13, 17, 19, 23, 29, 31, 37, 41,
                     43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};
    for (size_t i = 0, size = sizeof(primers) / sizeof(primers[0]); i < size;
         ++i)
    {
        assert(isPrime(primers[i]));
    }

    /* Example Non-prime numbers */
    int NonPrimers[] = {-1, 0, 1, 4, 6, 8, 9, 10};
    for (size_t i = 0, size = sizeof(NonPrimers) / sizeof(NonPrimers[0]);
         i < size; ++i)
    {
        assert(!isPrime(NonPrimers[i]));
    }
}

/**
 * Driver Code
 * @return None
 */
int main()
{
    test();
    return 0;
}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int a[10], n, i, j, temp;
    float q1, q3, iqr;

    printf("Enter no. for Random Numbers :");
    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
    }
    printf("Random Numbers Generated are :\n");
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }
    printf("\n");
    printf("\nSorted Data:");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            if (a[i] < a[j])
            {
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }
    q1 = a[n / 4];
    printf("\nFirst Quartile : %f", q1);
    q3 = a[(3 * n) / 4];
    printf("\nThird Quartile : %f", q3);
    iqr = q3 - q1;
    printf("\nInterQuartile Range is : %f", iqr);

    return 0;
}/**
 * @file
 * @brief [Postfix evaluation algorithm](https://www.includehelp.com/c/evaluation-of-postfix-expressions-using-stack-with-c-program.aspx) implementation
 * @details
 * The input postfix expression is of type string upto 49 characters (including space delimiters).
 * Supported operations- '+', '-', '/', '*', '%'
 * @author [Kumar Yash](https://github.com/kumaryash18)
 */
 
#include <stdio.h>	/// for IO operations
#include <string.h>	/// for strlen()
#include <ctype.h>	/// for isdigit()
#include <stdlib.h>	/// for exit()
#include <stdint.h>	/// for int8_t
#include <assert.h>	/// for assert

/**
 * @brief array implementation of stack using structure
 */
struct Stack {
	int8_t stack[20];		///< array stack
	int top;		///< stores index of the top element
};
struct Stack st;		///< global declaration of stack st

/**
 * @brief Function to push on the stack
 * @param opd number to be pushed in the stack
 * @returns void
 */
void push(int8_t opd) {
	if(st.top == 19)	{		// overflow condition
		printf("Stack overflow...");
		exit(1);
	}
	st.top++;
	st.stack[st.top] = opd;
}

/**
 * @brief Function to pop from the stack
 * @returns popped number
 */
int8_t pop() {
	int8_t item;				///< to store the popped value to be returned
	if(st.top == -1) {		// underflow condition
		printf("Stack underflow...");
		exit(1);
	}
	item = st.stack[st.top];
	st.top--;
	return item;
}

/**
 * @brief Function to evaluate postfix expression
 * @param post the input postfix expression
 * @returns evaluated answer
 */
int8_t evaluate(char post[]) {
	int8_t it1;
	int8_t it2;
	int8_t temp;
	int8_t number;
    int i;
    for(i = 0; i < strlen(post); i++) {
		if(post[i] == ' ') {
			continue;			// ignore delimiter
		}
		else if(isdigit(post[i])) {
			number = 0;
			do {
				number = number * 10 + (post[i]-'0');
				i++;
			} while(i < strlen(post) && isdigit(post[i]));
			push(number);
		}
		else {
			it2 = pop();
			it1 = pop();
			switch(post[i]) {
				case '+':
				temp = it1 + it2; break;
				case '-':
				temp = it1 - it2; break;
				case '*':
				temp = it1 * it2; break;
				case '/':
				temp = it1 / it2; break;
				case '%':
				temp = it1 % it2; break;
				default:
				printf("Invalid operator"); exit(1);
			}
			push(temp);
		}
	}
	return pop();
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test() {
    /* check sample test case
	   input: "2 10 + 9 6 - /"
	   expected output: 4
	 */
	char temp1[50] = "2 10 + 9 6 - /";
	assert(evaluate(temp1) == 4); 			/// this ensures that the algorithm works as expected
	/* input: "4 2 + 3 5 1 - * +"
	   expected output: 18
	 */
	char temp2[50] = "4 2 + 3 5 1 - * +";
	assert(evaluate(temp2) == 18); 			/// this ensures that the algorithm works as expected
	printf("All tests have successfully passed!\n");
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main() {
	st.top = -1;			/// initialize
	test();				/// run self-test implementations
	return 0;
}
#include <math.h>
#include <stdio.h>

float lerp(float k0, float k1, float t) { return k0 + t * (k1 - k0); }

float lerp_precise(int k0, int k1, float t) { return (1 - t) * k0 + t * k1; }

int main()
{
    float start = 0;
    float finish = 5;
    float steps = 0;

    printf("Input a number, this is the bigger bound of the lerp:\n");
    scanf("%f", &finish);

    printf(
        "Input a number, this is in how many steps you want to divide the "
        "lerp:\n");
    scanf("%f", &steps);

    for (int i = 0; i < steps + 1; i++)
    {
        printf("%f\n", lerp(start, finish, i / steps));
    }

    return 0;
}
// Fibonacci Series using Dynamic Programming

/* Author: Moinak Banerjee(moinak878)
   Date : 1 October ,2019
*/

#include <stdio.h>
#include <stdlib.h>

int fib(int n)
{
    // Out of Range checking
    if (n < 0)
    {
        printf("\nNo Such term !\n");
        exit(0);
    }
    // declaring array to store fibonacci numbers -- memoization
    int *f = (int *)malloc(
        (n + 2) * sizeof(int));  //  one extra to handle edge case, n = 0
    int i;

    /* let 0th and 1st number of the series be 0 and 1*/
    f[0] = 0;
    f[1] = 1;

    for (i = 2; i <= n; i++)
    {
        // Adding the previous 2 terms to make the 3rd term
        f[i] = f[i - 1] + f[i - 2];
    }

    int out = f[n];
    free(f);
    return out;
}

int main(int argc, char *argv[])
{
    int number;

    // Asks for the number/position of term in Fibonnacci sequence
    if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf("Enter the value of n(n starts from 0 ): ");
        scanf("%d", &number);
    }

    printf("The nth term is : %d \n", fib(number));

    return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void swap(char *left, char *right)
{
    char temp = *left;
    *left = *right;
    *right = temp;
}

int compare(const void *a, const void *b) { return (*(char *)a - *(char *)b); }

void PrintSortedPermutations(char *str)
{
    int strSize = strlen(str);
    qsort(str, strSize, sizeof(char), compare);

    int largerPermFound = 1;
    do
    {
        // 1. Print permutation
        printf("%s\n", str);
        // 2. Find rightmost char that is smaller than char to its right
        int i;
        for (i = strSize - 2; i >= 0 && str[i] >= str[i + 1]; --i)
        {
        }

        // if we couldn't find one, we're finished, else we can swap
        if (i >= 0)
        {
            // 3. find character at index j such that str[j] = min(str[k]) &&
            // str[k] > str[i] for all k > i
            int j = i + 1, k;
            for (k = j; k < strSize && str[k]; k++)
            {
                if (str[k] > str[i] && str[k] < str[j])
                    j = k;
            }
            // 3. Swap chars at i and j
            swap(&str[i], &str[j]);
            // 4. Sort string to the right of i
            qsort(str + i + 1, strSize - i - 1, sizeof(char), compare);
        }
        else
            largerPermFound = 0;
    } while (largerPermFound);
}

int main()
{
    int n;  // size of string
    scanf("%d\n", &n);
    if (n <= 0 || n >= 1000)
    {
        perror("Input number out of range: >0 and <1000\n");
        return -1;
    }
    char *str = (char *)malloc(n * sizeof(char));
    scanf("%s", str);
    PrintSortedPermutations(str);
    free(str);
    return 0;
}
/*
code for computing nth catalan number
*/
#include <stdio.h>
long int factorial(int x)  // long int for more than 10 factorial
{
    int i;
    long int fac;  // fac stores x factorial
    fac = x;
    for (i = 1; i < x; i++)  // loop to calculate x factorial
    {
        fac = fac * (x - i);
    }
    return fac;  // returning x factorial
}
int main()
{
    long int f1, f2, f3;  // long int for more than 10 factorial
    int n;
    float C;  // C is catalan number for n;
    scanf("%d", &n);
    f1 = factorial(2 * n);
    f2 = factorial(n + 1);
    f3 = factorial(n);
    C = f1 / (f2 * f3);  // formula for catalan number for n
    printf("%0.2f", C);
    return 0;
}
/**
 * @file
 * @brief Program to generate [Cantor ternary
 * set](https://en.wikipedia.org/wiki/Cantor_set)
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/** structure to define Cantor set */
typedef struct _cantor_set
{
    double start;             /**< start of interval */
    double end;               /**< end of interval */
    struct _cantor_set *next; /**< pointer to next set */
} CantorSet;

/** Iterative constructor of all sets in the current level. This function
 * dynamically allocates memory when creating new sets. These are freed by the
 * function ::free_memory.
 * @param head pointer to interval set instance to update
 */
void propagate(CantorSet *head)
{
    // if input is NULL, ignore the process
    if (head == NULL)
        return;

    CantorSet *temp = head;  // local pointer to track propagation

    // create new node for the new set
    CantorSet *newNode = (CantorSet *)malloc(sizeof(CantorSet));

    // get 1/3rd of interval
    double diff = (((temp->end) - (temp->start)) / 3);

    // update interval ranges
    newNode->end = temp->end;
    temp->end = ((temp->start) + diff);
    newNode->start = (newNode->end) - diff;

    // update pointer to next set in this level
    newNode->next = temp->next;

    // point to next set
    temp->next = newNode;

    // create next set
    propagate(temp->next->next);
}

/** Print sets in the current range to `stdout`
 * @param head pointer to first set in the current level
 */
void print(CantorSet *head)
{
    CantorSet *temp = head;
    while (temp != NULL)  // print while a valid set is found
    {
        printf("\t");
        printf("[%lf] -- ", temp->start);
        printf("[%lf]", temp->end);
        temp = temp->next;
    }

    printf("\n");
}

/** Clear memory allocated by ::propagate function.
 * @param head pointer to first allocated instance.
 */
void free_memory(CantorSet *head)
{
    if (!head)
        return;

    if (head->next)
        free_memory(head->next);

    free(head);
}

/** Main function */
int main(int argc, char const *argv[])
{
    int start_num, end_num, levels;

    if (argc < 2)
    {
        printf("Enter 3 arguments: start_num \t end_num \t levels\n");
        scanf("%d %d %d", &start_num, &end_num, &levels);
    }
    else
    {
        start_num = atoi(argv[1]);
        end_num = atoi(argv[2]);
        levels = atoi(argv[3]);
    }

    if (start_num < 0 || end_num < 0 || levels < 0)
    {
        fprintf(stderr, "All numbers must be positive\n");
        return -1;
    }

    CantorSet head = {.start = start_num, .end = end_num, .next = NULL};

    // loop to propagate each level from top to bottom
    for (int i = 0; i < levels; i++)
    {
        printf("Level %d\t", i);
        print(&head);
        propagate(&head);
        printf("\n");
    }
    printf("Level %d\t", levels);
    print(&head);

    // delete all memory allocated
    free_memory(head.next);

    return 0;
}
#include <stdio.h>

int main()
{
    int n, sum = 0, i, num;
    printf("Enter number: ");
    scanf("%d", &n);
    num = n;
    while (n != 0)
    {
        i = n % 10;
        sum = sum + (i * i * i);
        n = n / 10;
    }
    if (sum == num)
    {
        printf("%d is an armstrong number!\n", num);
    }
    else
    {
        printf("%d is not an armstrong number!\n", num);
    }
    return 0;
}
/**
 * @file
 * @author [NVombat](https://github.com/NVombat)
 * @brief Server-side implementation of [TCP Half Duplex
 * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)
 * @see tcp_half_duplex_server.c
 *
 * @details
 * The algorithm is based on the simple TCP client and server model. However,
 * instead of the server only sending and the client only receiving data,
 * The server and client can both send data but only one at a time. This is
 * implemented by using a particular ordering of the `send()` and `recv()`
 * functions. When one of the clients or servers is sending, the other can only
 * receive and vice-versa. In this way, the Half Duplex Form of communication
 * can be represented using the TCP server-client model & socket programming
 */

#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 8100  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t sockfd,
        conn;  ///< socket descriptors - Like file handles but for sockets
    char server_msg[10000],
        client_msg[10000];  ///< character arrays to read and store string data
                            /// for communication
    struct sockaddr_in server_addr,
        client_addr;  ///< asic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses

    /**
     * The TCP socket is created using the socket function
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();  ///< Error if the socket descriptor has a value lower than 0 -
                  /// socket wasnt created
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;    /// Domain/Family to be used
    server_addr.sin_port = htons(PORT);  /// Port to be used
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf("Server is running...\n");

    /**
     * This binds the socket descriptor to the server thus enabling the server
     * to listen for connections and communicate with other clients
     */
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        error();  /// If binding is unsuccessful
    }

    /**
     * This is to listen for clients or connections made to the server
     *
     * The limit is currently at 5 but can be increased to listen for
     * more connections
     *
     * It listens to connections through the socket descriptor
     */
    listen(sockfd, 5);

    printf("Server is listening...\n");

    /**
     * When a connection is found, a socket is created and connection is
     * accepted and established through the socket descriptor
     */
    conn = accept(sockfd, (struct sockaddr *)NULL, NULL);

    printf("Server is connected...\n");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * First the SERVER is prompted to type a message which is read from
     * stdin and then sent over the connection that was established - the socket
     * - to be received by the client (send())
     *
     * The SERVER then waits for the client to reply. It then receives the reply
     * in the string variable and displays it (recv())
     *
     * The server and client can communicate till one of them exits the
     * connection
     *
     * Since the exchange of information between the server and client take
     * place one at a time this represents HALF DUPLEX COMMUNICATION
     */
    while (1)
    {
        bzero(&server_msg, sizeof(server_msg));
        bzero(&client_msg, sizeof(client_msg));

        /// Send message
        printf("\nEnter message here: ");
        fgets(server_msg, 10000, stdin);
        send(conn, server_msg, strlen(server_msg) + 1, 0);

        /// Receive Message
        recv(conn, client_msg, sizeof(client_msg), 0);
        printf("\nClient Message: %s\n", client_msg);
    }

    /// Close socket
    close(sockfd);
    printf("Server is offline...\n");
    return 0;
}
/**
 * @file
 * @author [NVombat](https://github.com/NVombat)
 * @brief Server-side implementation of [Remote Command
 * Execution Using
 * UDP](https://www.imperva.com/learn/ddos/udp-user-datagram-protocol/)
 * @see remote_command_exec_udp_server.c
 *
 * @details
 * The algorithm is based on the simple UDP client and server model. It
 * runs an infinite loop which takes user input and sends it to the server
 * for execution. The server receives the commands and executes them
 * until the user exits the loop. In this way, Remote Command Execution
 * using UDP is shown using the server-client model & socket programming
 */

#include <arpa/inet.h>  /// For the type in_addr_t and in_port_t
#include <errno.h>      /// To indicate what went wrong if an error occurs
#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 10000  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    char recv_msg[1024],
        success_message[] =
            "Command Executed Successfully!\n";  ///< character arrays to read
                                                 /// and store string data
                                                 /// for communication & Success
                                                 /// message

    struct sockaddr_in server_addr,
        client_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    socklen_t clientLength = sizeof(client_addr);  /// size of address

    /**
     * The UDP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_DGRAM (Type) - Indicates UDP Connection - UDP does not require the
     * source and destination to establish a three-way handshake before
     * transmission takes place. Additionally, there is no need for an
     * end-to-end connection
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    /**
     * This binds the socket descriptor to the server thus enabling the server
     * to listen for connections and communicate with other clients
     */
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        error();  /// If binding is unsuccessful
    }

    printf("Server is Connected Successfully...\n");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * The server receives data from the client which is a command. It then
     * executes the command.
     *
     * The client then receives a response from the server when the
     * command has been executed
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * The client sends the server a command which it executes thus showing
     * remote command execution using UDP
     */
    while (1)
    {
        bzero(recv_msg, sizeof(recv_msg));
        recvfrom(sockfd, recv_msg, sizeof(recv_msg), 0,
                 (struct sockaddr *)&client_addr, &clientLength);
        printf("Command Output: \n");
        system(recv_msg);
        printf("Command Executed\n");
        sendto(sockfd, success_message, sizeof(success_message), 0,
               (struct sockaddr *)&client_addr, clientLength);
    }

    /// Close socket
    close(sockfd);
    printf("Server is offline...\n");
    return 0;
}
/**
 * @file
 * @author [TheShubham99](https://github.com/TheShubham99)
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief Server side implementation of UDP client-server model
 * @see client_server/udp_client.c
 */
#ifdef _WIN32                            // if compiling for Windows
#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next
                                         // MSVC compiler versions
#define close closesocket                /**< map BSD name to Winsock */
#include <winsock2.h>
#else  // if not windows platform
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PORT 8080    /**< port number to connect to */
#define MAXLINE 1024 /**< maximum characters per line */

#ifdef _WIN32
/** Cleanup function will be automatically called on program exit */
void cleanup() { WSACleanup(); }
#endif

/** Driver code */
int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror("WSA Startup error: \n");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd;
    char buffer[MAXLINE];
    char *hello = "Hello from server";
    struct sockaddr_in servaddr, cliaddr;

    // Creating socket file descriptor
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));
    memset(&cliaddr, 0, sizeof(cliaddr));

    // Filling server information
    servaddr.sin_family = AF_INET;  // IPv4
    servaddr.sin_addr.s_addr = INADDR_ANY;
    servaddr.sin_port = htons(PORT);

    // Bind the socket with the server address
    if (bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    unsigned int len;
    int n;
    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,
                 (struct sockaddr *)&cliaddr, &len);
    buffer[n] = '\0';
    printf("Client : %s\n", buffer);
    sendto(sockfd, (const char *)hello, strlen(hello), 0,
           (const struct sockaddr *)&cliaddr, len);
    printf("Hello message sent.\n");

    close(sockfd);

    return 0;
}
/**
 * @file
 * @author [NVombat](https://github.com/NVombat)
 * @brief Server-side implementation of [TCP Full Duplex
 * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)
 * @see tcp_full_duplex_server.c
 *
 * @details
 * The algorithm is based on the simple TCP client and server model. However,
 * instead of the server only sending and the client only receiving data,
 * The server and client can both send and receive data simultaneously. This is
 * implemented by using the `fork` function call so that in the server the child
 * process can recieve data and  parent process can send data, and in the client
 * the child process can send data and the parent process can receive data. It
 * runs an infinite loop and can send and receive messages indefinitely until
 * the user exits the loop. In this way, the Full Duplex Form of communication
 * can be represented using the TCP server-client model & socket programming
 */

#include <arpa/inet.h>  /// For the type in_addr_t and in_port_t
#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 10000  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t sockfd,
        conn;  ///< socket descriptors - Like file handles but for sockets
    char recvbuff[1024],
        sendbuff[1024];  ///< character arrays to read and store string data
                         /// for communication

    struct sockaddr_in server_addr,
        client_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    socklen_t ClientLen;  /// size of address

    /**
     * The TCP socket is created using the socket function
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();  ///< Error if the socket descriptor has a value lower than 0 -
                  /// socket wasnt created
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf("Server is running...\n");

    /**
     * This binds the socket descriptor to the server thus enabling the server
     * to listen for connections and communicate with other clients
     */
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        error();  /// If binding is unsuccessful
    }
    /**
     * This is to listen for clients or connections made to the server
     *
     * The limit is currently at 5 but can be increased to listen for
     * more connections
     *
     * It listens to connections through the socket descriptor
     */
    listen(sockfd, 5);

    printf("Server is listening...\n");

    /**
     * When a connection is found, a socket is created and connection is
     * accepted and established through the socket descriptor
     */
    conn = accept(sockfd, (struct sockaddr *)NULL, NULL);

    printf("Server is connected...\n");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * The fork function call is used to create a child and parent process
     * which run and execute code simultaneously
     *
     * The child process is used to receive data and after doing so
     * sleeps for 5 seconds to wait for the parent to send data
     *
     * The parent process is used to send data and after doing so
     * sleeps for 5 seconds to wait for the child to receive data
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * Since the exchange of information between the server and client takes
     * place simultaneously this represents FULL DUPLEX COMMUNICATION
     */
    pid_t pid;
    pid = fork();
    if (pid == 0)  /// Value of 0 is for child process
    {
        while (1)
        {
            bzero(&recvbuff, sizeof(recvbuff));
            recv(conn, recvbuff, sizeof(recvbuff), 0);
            printf("\nCLIENT : %s\n", recvbuff);
            sleep(5);
            // break;
        }
    }
    else  /// Parent process
    {
        while (1)
        {
            bzero(&sendbuff, sizeof(sendbuff));
            printf("\nType message here: ");
            fgets(sendbuff, 1024, stdin);
            send(conn, sendbuff, strlen(sendbuff) + 1, 0);
            printf("\nMessage Sent!\n");
            sleep(5);
            // break;
        }
    }

    /// Close socket
    close(sockfd);
    printf("Server is offline...\n");
    return 0;
}
/**
 * @file
 * @author [Nairit11](https://github.com/Nairit11)
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief Server side implementation of Server-Client system.
 * @see client_server/client.c
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// #ifdef HAS_UNISTD
// #include <unistd.h>
// #endif

#ifdef _WIN32
#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next
                                         // MSVC compiler versions
#include <winsock2.h>
#define bzero(b, len) \
    (memset((b), '\0', (len)), (void)0) /**< BSD name not in windows */
#define read(a, b, c) recv(a, b, c, 0)  /**< map BSD name to Winsock */
#define write(a, b, c) send(a, b, c, 0) /**< map BSD name to Winsock */
#define close closesocket               /**< map BSD name to Winsock */
#else
// if not windows platform
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#endif

#define MAX 80             /**< max. characters per message */
#define PORT 8080          /**< port number to connect to */
#define SA struct sockaddr /**< shortname for sockaddr */

#ifdef _WIN32
/** Cleanup function will be automatically called on program exit */
void cleanup() { WSACleanup(); }
#endif

/**
 * Continuous loop to send and receive over the socket.
 * Exits when "exit" is sent from commandline.
 * @param sockfd socket handle number
 */
void func(int sockfd)
{
    char buff[MAX];
    int n;
    // infinite loop for chat
    for (;;)
    {
        bzero(buff, MAX);

        // read the message from client and copy it in buffer
        read(sockfd, buff, sizeof(buff));
        // print buffer which contains the client contents
        printf("From client: %s\t To client : ", buff);
        bzero(buff, MAX);
        n = 0;
        // copy server message in the buffer
        while ((buff[n++] = getchar()) != '\n')
        {
            ;
        }

        // and send that buffer to client
        write(sockfd, buff, sizeof(buff));

        // if msg contains "Exit" then server exit and chat ended.
        if (strncmp("exit", buff, 4) == 0)
        {
            printf("Server Exit...\n");
            break;
        }
    }
}

/** Driver code */
int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror("WSA Startup error: \n");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd, connfd;
    unsigned int len;
    struct sockaddr_in servaddr, cli;

    // socket create and verification
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1)
    {
        perror("socket creation failed...\n");
        exit(0);
    }
    else
    {
        printf("Socket successfully created..\n");
    }
    bzero(&servaddr, sizeof(servaddr));

    // assign IP, PORT
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(PORT);

    // Binding newly created socket to given IP and verification
    if ((bind(sockfd, (SA *)&servaddr, sizeof(servaddr))) != 0)
    {
        perror("socket bind failed...\n");
        exit(0);
    }
    else
    {
        printf("Socket successfully binded..\n");
    }

    // Now server is ready to listen and verification
    if ((listen(sockfd, 5)) != 0)
    {
        perror("Listen failed...\n");
        exit(0);
    }
    else
    {
        printf("Server listening..\n");
    }
    len = sizeof(cli);

    // Accept the data packet from client and verification
    connfd = accept(sockfd, (SA *)&cli, &len);
    if (connfd < 0)
    {
        perror("server acccept failed...\n");
        exit(0);
    }
    else
    {
        printf("server acccept the client...\n");
    }

    // Function for chatting between client and server
    func(connfd);

    // After chatting close the socket
    close(sockfd);
    return 0;
}
/**
 * @file
 * @author [Nairit11](https://github.com/Nairit11)
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief Client side implementation of Server-Client system.
 * @see client_server/server.c
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32                            // if compiling for Windows
#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next
                                         // MSVC compiler versions
#include <winsock2.h>
#define bzero(b, len) \
    (memset((b), '\0', (len)), (void)0) /**< BSD name not in windows */
#define read(a, b, c) recv(a, b, c, 0)  /**< map BSD name to Winsock */
#define write(a, b, c) send(a, b, c, 0) /**< map BSD name to Winsock */
#define close closesocket               /**< map BSD name to Winsock */
#else                                   // if not windows platform
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#endif

#define MAX 80             /**< max. characters per message */
#define PORT 8080          /**< port number to connect to */
#define SA struct sockaddr /**< shortname for sockaddr */

/**
 * Continuous loop to send and receive over the socket.
 * Exits when "exit" is sent from commandline.
 * @param sockfd socket handle number
 */
void func(int sockfd)
{
    char buff[MAX];
    int n;
    for (;;)
    {
        bzero(buff, sizeof(buff));
        printf("Enter the string : ");
        n = 0;
        while ((buff[n++] = getchar()) != '\n')
        {
            ;
        }
        write(sockfd, buff, sizeof(buff));
        bzero(buff, sizeof(buff));
        read(sockfd, buff, sizeof(buff));
        printf("From Server : %s", buff);
        if ((strncmp(buff, "exit", 4)) == 0)
        {
            printf("Client Exit...\n");
            break;
        }
    }
}

#ifdef _WIN32
/** Cleanup function will be automatically called on program exit */
void cleanup() { WSACleanup(); }
#endif

/**
 * @brief Driver code
 */
int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror("WSA Startup error: \n");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd, connfd;
    struct sockaddr_in servaddr, cli;

    // socket create and verification
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1)
    {
        printf("socket creation failed...\n");
        exit(0);
    }
    else
    {
        printf("Socket successfully created..\n");
    }
    bzero(&servaddr, sizeof(servaddr));

    // assign IP, PORT
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
    servaddr.sin_port = htons(PORT);

    // connect the client socket to server socket
    if (connect(sockfd, (SA *)&servaddr, sizeof(servaddr)) != 0)
    {
        printf("connection with the server failed...\n");
        exit(0);
    }
    else
    {
        printf("connected to the server..\n");
    }

    // function for chat
    func(sockfd);

    // close the socket
    close(sockfd);
    return 0;
}
/**
 * @file
 * @author [NVombat](https://github.com/NVombat)
 * @brief Client-side implementation of [TCP Full Duplex
 * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)
 * @see tcp_full_duplex_server.c
 *
 * @details
 * The algorithm is based on the simple TCP client and server model. However,
 * instead of the server only sending and the client only receiving data,
 * The server and client can both send and receive data simultaneously. This is
 * implemented by using the `fork` function call so that in the server the child
 * process can recieve data and  parent process can send data, and in the client
 * the child process can send data and the parent process can receive data. It
 * runs an infinite loop and can send and receive messages indefinitely until
 * the user exits the loop. In this way, the Full Duplex Form of communication
 * can be represented using the TCP server-client model & socket programming
 */

#include <arpa/inet.h>  /// For the type in_addr_t and in_port_t
#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 10000  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    char sendbuff[1024],
        recvbuff[1024];  ///< character arrays to read and store string data
                         /// for communication

    struct sockaddr_in
        server_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses

    /**
     * The TCP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes.
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf("Client is running...\n");

    /**
     * Connects the client to the server address using the socket descriptor
     * This enables the two to communicate and exchange data
     */
    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));

    printf("Client is connected...\n");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * The fork function call is used to create a child and parent process
     * which run and execute code simultaneously
     *
     * The child process is used to send data and after doing so
     * sleeps for 5 seconds to wait for the parent to receive data
     *
     * The parent process is used to receive data and after doing so
     * sleeps for 5 seconds to wait for the child to send data
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * Since the exchange of information between the server and client takes
     * place simultaneously this represents FULL DUPLEX COMMUNICATION
     */
    pid_t pid;
    pid = fork();
    if (pid == 0)  /// Value of 0 is for child process
    {
        while (1)
        {
            bzero(&sendbuff, sizeof(sendbuff));
            printf("\nType message here: ");
            fgets(sendbuff, 1024, stdin);
            send(sockfd, sendbuff, strlen(sendbuff) + 1, 0);
            printf("\nMessage sent!\n");
            sleep(5);
            // break;
        }
    }
    else  /// Parent Process
    {
        while (1)
        {
            bzero(&recvbuff, sizeof(recvbuff));
            recv(sockfd, recvbuff, sizeof(recvbuff), 0);
            printf("\nSERVER: %s\n", recvbuff);
            sleep(5);
            // break;
        }
    }

    /// Close Socket
    close(sockfd);
    printf("Client is offline...\n");
    return 0;
}
/**
 * @file
 * @author [TheShubham99](https://github.com/TheShubham99)
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief Client side implementation of UDP client-server model
 * @see client_server/udp_server.c
 */
#ifdef _WIN32                            // if compiling for Windows
#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next
                                         // MSVC compiler versions
#include <winsock2.h>
#define close closesocket /**< map BSD name to Winsock */
#else                     // if not windows platform
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PORT 8080    /**< port number to connect to */
#define MAXLINE 1024 /**< maximum characters per line */

#ifdef _WIN32
/** Cleanup function will be automatically called on program exit */
void cleanup() { WSACleanup(); }
#endif

/** Driver code */
int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror("WSA Startup error: \n");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd;
    char buffer[MAXLINE];
    char *hello = "Hello from client";
    struct sockaddr_in servaddr;

    // Creating socket file descriptor
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));

    // Filling server information
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(PORT);
    servaddr.sin_addr.s_addr = INADDR_ANY;

    int n;
    unsigned int len;

    sendto(sockfd, (const char *)hello, strlen(hello), 0,
           (const struct sockaddr *)&servaddr, sizeof(servaddr));
    printf("Hello message sent.\n");

    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,
                 (struct sockaddr *)&servaddr, &len);
    buffer[n] = '\0';
    printf("Server : %s\n", buffer);

    close(sockfd);
    return 0;
}
/**
 * @file
 * @author [NVombat](https://github.com/NVombat)
 * @brief Client-side implementation of [Remote Command
 * Execution Using
 * UDP](https://www.imperva.com/learn/ddos/udp-user-datagram-protocol/)
 * @see remote_command_exec_udp_server.c
 *
 * @details
 * The algorithm is based on the simple UDP client and server model. It
 * runs an infinite loop which takes user input and sends it to the server
 * for execution. The server receives the commands and executes them
 * until the user exits the loop. In this way, Remote Command Execution
 * using UDP is shown using the server-client model & socket programming
 */

#include <arpa/inet.h>  /// For the type in_addr_t and in_port_t
#include <errno.h>      /// To indicate what went wrong if an error occurs
#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 10000  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    char send_msg[1024],
        recv_msg[1024];  ///< character arrays to read and store string data
                         /// for communication

    struct sockaddr_in
        server_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    socklen_t serverLength = sizeof(server_addr);  ///< length of socket

    /**
     * The UDP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_DGRAM (Type) - Indicates UDP Connection - UDP does not require the
     * source and destination to establish a three-way handshake before
     * transmission takes place. Additionally, there is no need for an
     * end-to-end connection
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf("Client is running...\n");

    /**
     * Connects the client to the server address using the socket descriptor
     * This enables the two to communicate and exchange data
     */
    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));

    printf("Client is Connected Successfully...\n");

    /**
     * Communication between client and server
     *
     * The client sends data to the server after taking the input
     * from the user
     *
     * The client then receives a response from the server when the
     * command has been executed
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * The client sends the server a command which it executes thus showing
     * remote command execution using UDP
     */
    while (1)
    {
        printf("\nEnter Command To Be Executed Remotely: \n");
        fgets(send_msg, sizeof(send_msg), stdin);
        sendto(sockfd, send_msg, sizeof(send_msg), 0,
               (struct sockaddr *)&server_addr, serverLength);
        recvfrom(sockfd, recv_msg, sizeof(recv_msg), 0,
                 (struct sockaddr *)&server_addr, &serverLength);
        printf("Server Reply: %s\n", recv_msg);
    }

    /// Close Socket
    close(sockfd);
    printf("Client is offline...\n");
    return 0;
}
/**
 * @file
 * @author [Nikhill Vombatkere](https://github.com/NVombat)
 * @brief Client-side implementation of [TCP Half Duplex
 * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)
 * @see tcp_half_duplex_server.c
 *
 * @details
 * The algorithm is based on the simple TCP client and server model. However,
 * instead of the server only sending and the client only receiving data,
 * the server and client can both send data but only one at a time. This is
 * implemented by using a particular ordering of the `send()` and `recv()`
 * functions. When one of the clients or servers is sending, the other can only
 * receive and vice-versa. In this way, the Half Duplex Form of communication
 * can be represented using the TCP server-client model & socket programming
 */

#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 8100  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    struct sockaddr_in
        server_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    char serverResponse[10000],
        clientResponse[10000];  ///< Character arrays to read and store string
                                /// data for communication

    /**
     * The TCP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes.
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf("Client is running...\n");

    /**
     * Connects the client to the server address using the socket descriptor
     * This enables the two to communicate and exchange data
     */
    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));

    printf("Client is connected...\n");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * First the CLIENT receives the servers message and displays it (recv())
     *
     * The CLIENT is then prompted to type in a message and send it to the
     * server. (send())
     *
     * The server and client can communicate till one of them exits the
     * connection
     *
     * Since the exchange of information between the server and client take
     * place one at a time this represents HALF DUPLEX COMMUNICATION
     */
    while (1)
    {
        bzero(&serverResponse, sizeof(serverResponse));
        bzero(&clientResponse, sizeof(clientResponse));

        /// Receive Message
        recv(sockfd, serverResponse, sizeof(serverResponse), 0);
        printf("\nServer message: %s \n", serverResponse);

        /// Send Message
        printf("\nEnter message here: ");
        fgets(clientResponse, 10000, stdin);
        send(sockfd, clientResponse, strlen(clientResponse) + 1, 0);
    }

    /// Close Socket
    close(sockfd);
    printf("Client is offline...\n");
    return 0;
}
/**
 * Kyler Smith, 2017
 * Stack data structure implementation.
 */

////////////////////////////////////////////////////////////////////////////////
// INCLUDES
#include <stdio.h>
#include <stdlib.h>

////////////////////////////////////////////////////////////////////////////////
// MACROS: CONSTANTS

////////////////////////////////////////////////////////////////////////////////
// DATA STRUCTURES
/**
 * creating a stucture with 'data'(type:int), two pointers 'next','pre' (type: struct node) .
 */
struct node
{
    int data;
    struct node *next;
    struct node *pre;
} * head, *tmp;

////////////////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
int count = 0;

////////////////////////////////////////////////////////////////////////////////
// FUNCTION PROTOTYPES
void create();
void push(int x);
int pop();
int peek();
int size();
int isEmpty();

////////////////////////////////////////////////////////////////////////////////
// MAIN ENTRY POINT

int main(int argc, char const *argv[])
{
    int x, y, z;

    create();
    push(4);
    x = pop();
    // 4. Count: 0. Empty: 1.
    printf("%d.\t\tCount: %d.\tEmpty: %d.\n", x, size(), isEmpty());

    push(1);
    push(2);
    push(3);
    x = pop();
    y = pop();
    // 3, 2. Count: 1. Empty: 0;
    printf("%d, %d.\t\tCount: %d.\tEmpty: %d.\n", x, y, size(), isEmpty());
    pop();  // Empty the stack.

    push(5);
    push(6);
    x = peek();
    push(7);
    y = pop();
    push(8);
    z = pop();
    // 1, 6, 7, 8. Count: 2. Empty: 0.
    printf("%d, %d, %d.\tCount: %d.\tEmpty: %d.\n", x, y, z, size(), isEmpty());

    return 0;
}

/**
 * Initialize the stack to NULL.
 */
void create() { head = NULL; }

/**
 * Push data onto the stack.
 */
void push(int x)
{
    if (head == NULL)
    {
        head = (struct node *)malloc(1 * sizeof(struct node));
        head->next = NULL;
        head->pre = NULL;
        head->data = x;
    }
    else
    {
        tmp = (struct node *)malloc(1 * sizeof(struct node));
        tmp->data = x;
        tmp->next = NULL;
        tmp->pre = head;
        head->next = tmp;
        head = tmp;
    }
    ++count;
}

/**
 * Pop data from the stack
 */
int pop()
{
    int returnData;
    if (head == NULL)
    {
        printf("ERROR: Pop from empty stack.\n");
        exit(1);
    }
    else
    {
        returnData = head->data;

        if (head->pre == NULL)
        {
            free(head);
            head = NULL;
        }
        else
        {
            head = head->pre;
            free(head->next);
        }
    }
    --count;
    return returnData;
}

/**
 * Returns the next value to be popped.
 */
int peek()
{
    if (head != NULL)
        return head->data;
    else
    {
        printf("ERROR: Peeking from empty stack.");
        exit(1);
    }
}

/**
 * Returns the size of the stack.
 */
int size() { return count; }

/**
 * Returns 1 if stack is empty, returns 0 if not empty.
 */
int isEmpty()
{
    if (count == 0)
        return 1;
    return 0;
}
/*
 * CArrayTests.c
 *
 * Author: Leonardo Vencovsky
 * Created on 19/03/2018
 *
 * Modified by: Leonardo Vencovsky
 * Last modified: 19/03/2018
 *
 * Test Cases for Array Implementations in C
 *
 * Compiled in Visual Studio 2017
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "carray.h"

int CArrayTests()
{
    printf("\n");
    printf(" +-------------------------------------+\n");
    printf(" |                                     |\n");
    printf(" |               C Array               |\n");
    printf(" |                                     |\n");
    printf(" +-------------------------------------+\n");
    printf("\n");

    CArray *array = getCArray(10);

    int i;
    for (i = 0; i < array->size; i++)
    {
        insertValueCArray(array, i, i + 1);
    }
    printf("Entered array is:\n");
    displayCArray(array);
    printf("\nCode: %d\n", pushValueCArray(array, 11));  // 5

    for (i = 0; i < array->size; i++)
    {
        removeValueCArray(array, i);
    }

    displayCArray(array);

    printf("\nCode: %d", removeValueCArray(array, -1));       // 1
    printf("\nCode: %d\n", insertValueCArray(array, -1, 1));  // 1

    // Erase
    for (i = 0; i < array->size; i++)
    {
        insertValueCArray(array, i, i + 1);
    }
    eraseCArray(array);
    displayCArray(array);  // Should give all 0s

    // Switching
    CArray *arr = getCArray(13);
    for (i = 0; i < arr->size; i++)
    {
        insertValueCArray(arr, i, i + 1);
    }
    displayCArray(arr);
    for (i = 0; i < arr->size / 2; i++)
    {
        switchValuesCArray(arr, i, arr->size - i - 1);
    }

    displayCArray(arr);

    // Or simply...
    reverseCArray(arr);

    displayCArray(arr);

    // Sorting
    srand(time(NULL));
    CArray *barray = getCArray(20);
    for (i = 0; i < barray->size; i++)
    {
        insertValueCArray(barray, i, rand());
    }
    CArray *carray = getCopyCArray(barray);
    CArray *darray = getCopyCArray(barray);
    printf("\nNot sorted Array:");
    displayCArray(barray);

    printf("\nBubble Sort:");
    clock_t begin1 = clock();
    // Timing bubble sort
    bubbleSortCArray(barray);
    clock_t end1 = clock();
    double time_spent1 = (double)(end1 - begin1) / CLOCKS_PER_SEC;
    displayCArray(barray);

    printf("\nSelection Sort:");
    clock_t begin2 = clock();
    // Timing selection sort
    selectionSortCArray(carray);
    clock_t end2 = clock();
    double time_spent2 = (double)(end2 - begin2) / CLOCKS_PER_SEC;
    displayCArray(carray);

    printf("\nInsertion Sort:");
    clock_t begin3 = clock();
    // Timing insertion sort
    insertionSortCArray(darray);
    clock_t end3 = clock();
    double time_spent3 = (double)(end3 - begin3) / CLOCKS_PER_SEC;
    displayCArray(carray);

    // Descending order
    reverseCArray(barray);
    // displayCArray(barray);

    //	printf("\nBlender:");
    //	blenderCArray(barray);
    //	displayCArray(barray);

    printf("\nTotal time spent for bubble sort: %lf seconds", time_spent1);
    printf("\nTotal time spent for selection sort: %lf seconds", time_spent2);
    printf("\nTotal time spent for insertion sort: %lf seconds", time_spent3);

    // Searching
    CArray *aarray = getCArray(1000);
    for (i = 0; i < aarray->size; i++)
    {
        insertValueCArray(aarray, i, rand() % 100);
    }

    int j = 24;
    printf("\nOccurrences of the number %d in the array: %d", j,
           valueOcurranceCArray(aarray, j));
    printf("\nAnd its positions:\n");
    CArray *positions = valuePositionsCArray(aarray, j);
    displayCArray(positions);
    // This should all give value of j
    printf("\nAll %d s", j);
    for (i = 0; i < positions->size; i++)
    {
        printf("\nPosition %d has a value of %d", positions->array[i],
               aarray->array[positions->array[i]]);
    }
    printf("\nThe list has a minimum value of %d and a maximum value of %d",
           findMinCArray(aarray), findMaxCArray(aarray));
    insertionSortCArray(aarray);
    // displayCArray(aarray);

    free(arr);
    free(array);
    free(aarray);
    free(barray);
    free(carray);
    free(darray);
    printf("\n");
    return 0;
}
/*
 * CArray.h
 *
 * Author: Leonardo Vencovsky
 * Created on 18/03/2018
 *
 * Modified by: Leonardo Vencovsky
 * Last modified: 19/03/2018
 *
 * Header for Array in C
 *
 * Compiled in Visual Studio 2017
 *
 */

#pragma once

#ifdef __cplusplus
extern "C"
{
#endif

#define ARRAY_ERASED -1
#define SUCCESS 0
#define INVALID_POSITION 1
#define POSITION_INIT 2
#define POSITION_NOT_INIT 3
#define POSITION_EMPTY 4
#define ARRAY_FULL 5

    typedef struct CArray
    {
        int *array;
        int size;
    } CArray;

    // +-------------------------------------+
    // |           Returns array             |
    // +-------------------------------------+
    CArray *getCArray(int size);
    CArray *getCopyCArray(CArray *array);

    // +-------------------------------------+
    // |           Input / Output            |
    // +-------------------------------------+
    int insertValueCArray(CArray *array, int position, int value);
    int removeValueCArray(CArray *array, int position);
    int pushValueCArray(CArray *array, int value);
    int updateValueCArray(CArray *array, int position, int value);

    // +-------------------------------------+
    // |               Erase                 |
    // +-------------------------------------+
    int eraseCArray(CArray *array);

    // +-------------------------------------+
    // |             Switching               |
    // +-------------------------------------+
    int switchValuesCArray(CArray *array, int position1, int position2);
    int reverseCArray(CArray *array);

    // +-------------------------------------+
    // |              Sorting                |
    // +-------------------------------------+
    int bubbleSortCArray(CArray *array);
    int selectionSortCArray(CArray *array);
    int insertionSortCArray(CArray *array);
    int blenderCArray(CArray *array);

    // +-------------------------------------+
    // |             Searching               |
    // +-------------------------------------+
    int valueOcurranceCArray(CArray *array, int value);
    CArray *valuePositionsCArray(CArray *array, int value);
    int findMaxCArray(CArray *array);
    int findMinCArray(CArray *array);

    // +-------------------------------------+
    // |              Display                |
    // +-------------------------------------+
    int displayCArray(CArray *array);

#ifdef __cplusplus
}
#endif
/*
 * CArray.c
 *
 * Author: Leonardo Vencovsky
 * Created on 19/03/2018
 *
 * Modified by: Leonardo Vencovsky
 * Last modified: 19/03/2018
 *
 * Array Implementations in C
 *
 * Compiled in Visual Studio 2017
 *
 */

/*
Return Codes

-1 - Array Erased
0 - Success
1 - Invalid Position
2 - Position already initialized (use update function)
3 - Position not initialized (use insert function)
4 - Position already empty
5 - Array is full

*/

#include "carray.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void swap(CArray *array, int position1, int position2);

CArray *getCArray(int size)
{
    CArray *array = (CArray *)malloc(sizeof(CArray));
    array->array = (int *)malloc(sizeof(int) * size);
    array->size = size;
    int i;
    for (i = 0; i < size; i++)
    {
        array->array[i] = 0;
    }
    return array;
}

int insertValueCArray(CArray *array, int position, int value)
{
    if (position >= 0 && position < array->size)
    {
        if (array->array[position] == 0)
        {
            array->array[position] = value;
            return SUCCESS;
        }
        else
            return POSITION_INIT;
    }
    return INVALID_POSITION;
}

int removeValueCArray(CArray *array, int position)
{
    if (position >= 0 && position < array->size)
    {
        if (array->array[position] != 0)
        {
            array->array[position] = 0;
        }
        else
            return POSITION_EMPTY;
    }
    return INVALID_POSITION;
}

int pushValueCArray(CArray *array, int value)
{
    int i;
    int ok = 0;
    for (i = 0; i < array->size; i++)
    {
        if (array->array[i] == 0)
        {
            array->array[i] = value;
            ok = 1;
            break;
        }
    }
    if (ok == 1)
        return SUCCESS;
    else
        return ARRAY_FULL;
}

int updateValueCArray(CArray *array, int position, int value)
{
    if (position >= 0 && position < array->size)
    {
        if (array->array[position] != 0)
        {
            array->array[position] = value;
            return SUCCESS;
        }

        else
            return POSITION_NOT_INIT;
    }
    return INVALID_POSITION;
}

int eraseCArray(CArray *array)
{
    int i;
    for (i = 0; i < array->size; i++)
    {
        array->array[i] = 0;
    }
    return 0;
}

int switchValuesCArray(CArray *array, int position1, int position2)
{
    if (position1 >= 0 && position1 < array->size && position2 >= 0 &&
        position2 < array->size)
    {
        int temp = array->array[position1];
        array->array[position1] = array->array[position2];
        array->array[position2] = temp;
    }
    return INVALID_POSITION;
}

int reverseCArray(CArray *array)
{
    int i;
    for (i = 0; i < array->size / 2; i++)
    {
        swap(array, i, array->size - i - 1);
    }
    return SUCCESS;
}

int displayCArray(CArray *array)
{
    int i;
    printf("\nC ARRAY\n");
    for (i = 0; i < array->size; i++)
    {
        printf("%d ", array->array[i]);
    }
    printf("\n");
    return 0;
}

int blenderCArray(CArray *array)
{
    srand(time(NULL) * array->size);
    int i;
    int total = array->size * 100;
    for (i = 0; i < total; i++)
    {
        swap(array, rand() % array->size, rand() % array->size);
    }
    return 0;
}

CArray *getCopyCArray(CArray *arr)
{
    CArray *array = (CArray *)malloc(sizeof(CArray));
    array->array = (int *)malloc(sizeof(int) * arr->size);
    array->size = arr->size;
    int i;
    for (i = 0; i < arr->size; i++)
    {
        array->array[i] = arr->array[i];
    }
    return array;
}

void swap(CArray *array, int position1, int position2)
{
    int temp = array->array[position1];
    array->array[position1] = array->array[position2];
    array->array[position2] = temp;
}

int bubbleSortCArray(CArray *array)
{
    int i, j;
    for (i = 0; i < array->size - 1; i++)
    {
        for (j = 0; j < array->size - i - 1; j++)
        {
            if (array->array[j] > array->array[j + 1])
            {
                swap(array, j, j + 1);
            }
        }
    }
    return 0;
}

int selectionSortCArray(CArray *array)
{
    int i, j, min;
    for (i = 0; i < array->size - 1; i++)
    {
        min = i;
        for (j = i + 1; j < array->size; j++)
            if (array->array[j] < array->array[min])
                min = j;
        swap(array, min, i);
    }
    return 0;
}

int insertionSortCArray(CArray *array)
{
    int i, j, num;
    for (i = 1; i < array->size; i++)
    {
        num = array->array[i];
        j = i - 1;
        while (j >= 0 && array->array[j] > num)
        {
            array->array[j + 1] = array->array[j];
            j--;
        }
        array->array[j + 1] = num;
    }
    return 0;
}

int valueOcurranceCArray(CArray *array, int value)
{
    int i, total = 0;
    for (i = 0; i < array->size; i++)
    {
        if (array->array[i] == value)
            total++;
    }
    return total;
}

CArray *valuePositionsCArray(CArray *array, int value)
{
    int i, j = 0;
    int total = valueOcurranceCArray(array, value);
    CArray *resultArray = getCArray(total);
    for (i = 0; i < array->size; i++)
    {
        if (array->array[i] == value)
        {
            // Hopefully this won't overflow
            resultArray->array[j] = i;
            j++;
        }
    }
    return resultArray;
}

int findMinCArray(CArray *array)
{
    int i;
    int min = array->array[0];
    for (i = 1; i < array->size; i++)
    {
        if (array->array[i] < min)
        {
            min = array->array[i];
        }
    }
    return min;
}

int findMaxCArray(CArray *array)
{
    int i;
    int max = array->array[0];
    for (i = 1; i < array->size; i++)
    {
        if (array->array[i] > max)
        {
            max = array->array[i];
        }
    }
    return max;
}
#include <stdio.h>
#include <stdlib.h>

#include "hash_set.h"

extern hash_set_t *init_hash_set()
{
    hash_set_t *set = (hash_set_t *)malloc(sizeof(hash_set_t));
    set->keys = calloc(DEFAULT_HASH_SET_CAPACITY, sizeof(void **));
    set->values = calloc(DEFAULT_HASH_SET_CAPACITY, sizeof(void **));
    set->length = 0;
    set->capacity = DEFAULT_HASH_SET_CAPACITY;

    return set;
}

unsigned add(hash_set_t *set, void *value)
{
    return put(set, hash(value), value);
}

unsigned put(hash_set_t *set, long long hash, void *value)
{
    if (contains_hash(set, hash))
    {
        if (set->keys[retrieve_index_from_hash(hash, set->capacity)] == value)
        {
            return 0;
        }

        // collision
        resize(set);

        return put(set, hash, value);
    }

    set->keys[retrieve_index_from_hash(hash, set->capacity)] = value;
    set->values[set->length++] = value;

    return 1;
}

int contains(hash_set_t *set, void *value)
{
    return set->keys[retrieve_index_from_hash(hash(value), set->capacity)] ==
                   value
               ? 1
               : 0;
}

int contains_hash(hash_set_t *set, long long hash)
{
    return set->keys[retrieve_index_from_hash(hash, set->capacity)] ? 1 : 0;
}

void delete (hash_set_t *set, void *value)
{
    set->keys[retrieve_index_from_hash(hash(value), set->capacity)] = NULL;
}

// adler_32 hash
long long hash(void *value)
{
    char *str = value;

    int a = 1;
    int b = 0;
    const int MODADLER = 65521;

    for (int i = 0; str[i] != '\0'; i++)
    {
        a = (a + str[i]) % MODADLER;
        b = (b + a) % MODADLER;
    }

    return (b << 16) | a;
}

unsigned retrieve_index_from_hash(const long long hash, const unsigned capacity)
{
    return (capacity - 1) & (hash ^ (hash >> 12));
}

void resize(hash_set_t *set)
{
    void **keys_resized = calloc((set->capacity <<= 1), sizeof(void **));

    for (int i = 0; i < set->length; i++)
    {
        keys_resized[retrieve_index_from_hash(hash(set->values[i]),
                                              set->capacity)] = set->values[i];
    }

    free(set->keys);

    set->keys = keys_resized;

    void **new_values =
        (void **)realloc(set->values, set->capacity * sizeof(void **));
    set->values = new_values;
}
#include <stdio.h>

#include "hash_set.h"

int main()
{
    hash_set_t *set = init_hash_set();

    int v1 = 10, v2 = 20, v3 = 30, v4 = 40, v5 = 50, v6 = 60, v7 = 70;

    printf("Value %d was add ? %d\n", v1, add(set, &v1));
    printf("Value %d was add ? %d\n", v1, add(set, &v1));
    printf("contains %d ? %d\n", v1, contains(set, &v1));

    printf("Value %d was add ? %d\n", v2, add(set, &v2));
    printf("Value %d was add ? %d\n", v2, add(set, &v2));
    printf("contains %d ? %d\n", v2, contains(set, &v2));

    printf("Value %d was add ? %d\n", v3, add(set, &v3));
    printf("Value %d is add ? %d\n", v3, add(set, &v3));
    printf("contains %d ? %d\n", v3, contains(set, &v3));

    printf("Value %d was add ? %d\n", v4, add(set, &v4));
    printf("Value %d was add ? %d\n", v4, add(set, &v4));
    printf("contains %d ? %d\n", v4, contains(set, &v4));

    printf("Value %d was add ? %d\n", v5, add(set, &v5));
    printf("Value %d was add ? %d\n", v5, add(set, &v5));
    printf("contains %d ? %d\n", v5, contains(set, &v5));

    printf("Value %d is add ? %d\n", v6, add(set, &v6));
    printf("Value %d is add ? %d\n", v6, add(set, &v6));
    printf("contains %d ? %d\n", v6, contains(set, &v6));

    printf("contains %d ? %d\n", v7, contains(set, &v7));

    delete (set, &v6);

    printf("contains %d ? %d\n", v6, contains(set, &v6));

    return 0;
}#ifndef __HASH_SET__
#define __HASH_SET__

#define DEFAULT_HASH_SET_CAPACITY 1 << 10

typedef struct
{
    unsigned capacity;
    unsigned length;
    void **values;
    void **keys;
} hash_set_t;

extern hash_set_t *init_hash_set();

extern unsigned add(hash_set_t *set, void *value);

unsigned put(hash_set_t *set, long long hash, void *value);

extern int contains(hash_set_t *set, void *value);

int contains_hash(hash_set_t *set, long long hash);

extern void delete (hash_set_t *set, void *value);

extern long long hash(void *value);

extern unsigned retrieve_index_from_hash(const long long hash,
                                         const unsigned capacity);

extern void resize(hash_set_t *set);

#endif/* Circularly Linked List (Basic Operations) - Program to create a Circularly linked list abstract data type and perform various operations on it (Variable first and last declared globally) */

#include  <stdio.h>
#include <conio.h>
#include  <stdlib.h>
#define  NULL  0

/* Assume that the data portion of each node consists of ONLY an integer.*/
struct  node
{
  int  data ;
  struct  node  *next ;
} ;

struct  node  *first=NULL ;
struct  node  *last=NULL ;
/* first and last are global variables and need not be passed to any function. Any changes made to variables first and last by any of the functions in the program will be reflected in the entire program */

/* This function is responsible for creating the Circularly Linked List right from the BEGINING. */
void  create()
{
  int  i , n ;
  struct  node  *pnode , *p ;

  printf("Enter the number of nodes required:\n") ;
  scanf("%d",&n) ;

  printf("Enter the data value of each node:\n") ;
  for(i=1 ; i<=n ; i++)
  {
    pnode=(struct node*)malloc(sizeof(struct node)) ;
    if(pnode==NULL)
    {
      printf("Memory overflow. Unable to create.\n") ;
      return ;
    }

    scanf("%d",&pnode->data) ;

    if(first==NULL)
	 first=last=pnode ;
    else
    {
	  last->next=pnode ;
	  last=pnode ;    /* last keeps track of last node */
    }

    last->next=first ;
  }
}

/* This function will delete a node with value k from the Linked List if such a node exists */
void  deletenode(int  k)
{
  struct  node  *p , *follow ;

  /* searching the required node */
  p=first ;
  follow=NULL ;
  while(follow!=last)
  {
    if(p->data==k)
	  break ;
    follow=p ;
    p=p->next ;
  }

  if(follow==last)
    printf("Required node not found.\n") ;
  else
  {
    if(p==first&&p==last)  /* deleting the one and the only node */
	  first=last=NULL ;
    else if(p==first)       /* deleting the first node */
    {
      first=first->next ;
      last->next=first ;
    }
    else if(p==last)      /* deleting the last node */
    {
      last=follow ;
      last->next=first ;
    }
    else		/* deleting any other node */
      follow->next=p->next ;

    free(p) ;
  }
}

/* This function will go through all the nodes of Linked List exactly once and will display data value of each node */
void  traverse()
{
  struct  node  *p , *follow ;
  if(first==NULL)
    printf("Circularly Linked List Empty") ;
  else
  {
    printf("Circularly Linked List is as shown: \n") ;

    p=first ;
    follow = NULL ;
    while(follow!=last)
    {
      printf("%d " , p->data) ;
      follow=p ;
      p=p->next ;
    }

    printf("\n") ;
  }
}

void main()
{
  int  x , k , ch ;
  clrscr() ;
  do
  {
    printf("\n Menu: \n") ;
    printf("1:Create Linked List \n") ;
    printf("2:Delete Node \n") ;
    printf("3:Traverse \n") ;
    printf("4:Exit \n") ;

    printf("\nEnter your choice: ") ;
    scanf("%d",&ch) ;

    switch(ch)
    {
      case 1:
      create() ;
      break ;

      case 2:
      printf("Enter the data value of the node to be deleted: ") ;
      scanf("%d",&k) ;
      deletenode(k) ;
      break ;

      case 3:
      traverse() ;
      break ;

      case 4:
      break ;
    }
 }
 while(ch!=4) ;

 getch() ;
}



/* Ascending priority queue using Linked List - Program to implement Ascending
 * priority queue using Linked List */

/*A priority queue is a special type of queue in which each element is
associated with a priority and is served according to its priority. If elements
with the same priority occur, they are served according to their order in the
queue.

Generally, the value of the element itself is considered for assigning the
priority.

For example: The element with the highest value is considered as the highest
priority element. However, in other cases, we can assume the element with the
lowest value as the highest priority element. In other cases, we can set
priorities according to our needs.

In a queue, the first-in-first-out rule is implemented whereas, in a priority
queue, the values are removed on the basis of priority. The element with the
highest priority is removed first.

insert() - Would insert an element in a queue
delete() -  Would delete the smallest element in the queue
*/

#include <stdio.h>
#include <stdlib.h>
#define NULL ((void *)0)

struct node
{
    int data;
    struct node *next;
};

struct node *front, *rear;

/* This function initializes the queue to empty by making both front and rear as
 * NULL */
void createqueue() { front = rear = NULL; }

int empty()
{
    if (front == NULL)
        return 1;
    else
        return 0;
}

void insert(int x)
{
    struct node *pnode;

    pnode = (struct node *)malloc(sizeof(struct node));
    if (pnode == NULL)
    {
        printf("Memory overflow. Unable to insert.\n");
        exit(1);
    }

    pnode->data = x;
    pnode->next = NULL; /* New node is always last node */

    if (empty())
        front = rear = pnode;
    else
    {
        rear->next = pnode;
        rear = pnode;
    }
}

int removes()
{
    int min;
    struct node *follow, *follow1, *p, *p1;

    if (empty())
    {
        printf("\nQueue Underflow. Unable to remove.");
        exit(1);
    }

    /* finding the node with minimum value in the APQ.*/
    p = p1 = front;
    follow = follow1 = NULL;
    min = front->data;
    while (p != NULL)
    {
        if (p->data < min)
        {
            min = p->data;
            follow1 = follow;
            p1 = p;
        }
        follow = p;
        p = p->next;
    }

    /* Deleting the node with min value */

    if (p1 == front) /* deleting first node.*/
    {
        front = front->next;
        if (front == NULL) /* Deleting the only one node */
            rear = NULL;
    }
    else if (p1 == rear) /* Deleting last node */
    {
        rear = follow1;
        rear->next = NULL;
    }
    else /* deleting any other node.*/
        follow1->next = p1->next;

    free(p1);
    return min; /* DONT FORGET LAST 2 STATEMENTS.*/
}

void show()
{
    struct node *p;

    if (empty())
        printf("Queue empty. No data to display \n");
    else
    {
        printf("Queue from front to rear is as shown: \n");

        p = front;
        while (p != NULL)
        {
            printf("%d ", p->data);
            p = p->next;
        }

        printf("\n");
    }
}

void destroyqueue() { front = rear = NULL; }

int main()
{
    int x, ch;

    createqueue();

    do
    {
        printf("\n\n  Menu: \n");
        printf("1:Insert \n");
        printf("2:Remove \n");
        printf("3:exit \n");
        printf("Enter your choice: ");
        scanf("%d", &ch);

        switch (ch)
        {
        case 1:
            printf("Enter element to be inserted: ");
            scanf("%d", &x);
            insert(x);
            show();
            break;

        case 2:
            x = removes();
            printf("Element removed is: %d\n", x);
            show();
            break;

        case 3:
            break;
        }
    } while (ch != 3);

    destroyqueue();

    return 0;
}

/* Output of the Program*/

/*
  Menu:
1:Insert
2:Remove
3:exit
Enter your choice: 1
Enter element to be inserted: 12
Queue from front to rear is as shown:
12


  Menu:
1:Insert
2:Remove
3:exit
Enter your choice: 1
Enter element to be inserted: 1
Queue from front to rear is as shown:
12 1


  Menu:
1:Insert
2:Remove
3:exit
Enter your choice: 1
Enter element to be inserted: 14
Queue from front to rear is as shown:
12 1 14


  Menu:
1:Insert
2:Remove
3:exit
Enter your choice: 1
Enter element to be inserted: 3
Queue from front to rear is as shown:
12 1 14 3


  Menu:
1:Insert
2:Remove
3:exit
Enter your choice: 1
Enter element to be inserted: 5
Queue from front to rear is as shown:
12 1 14 3 5


  Menu:
1:Insert
2:Remove
3:exit
Enter your choice: 2
Element removed is: 1
Queue from front to rear is as shown:
12 14 3 5


  Menu:
1:Insert
2:Remove
3:exit
Enter your choice: 2
Element removed is: 3
Queue from front to rear is as shown:
12 14 5


  Menu:
1:Insert
2:Remove
3:exit
Enter your choice: 2
Element removed is: 5
Queue from front to rear is as shown:
12 14


  Menu:
1:Insert
2:Remove
3:exit
Enter your choice: 2
Element removed is: 12
Queue from front to rear is as shown:
14


  Menu:
1:Insert
2:Remove
3:exit
Enter your choice: 2
Element removed is: 14
Queue empty. No data to display

*/
/* Queue using Linked List - Program to create a queue ADT using linked list.
ADT should support the following operations 1)  Createqueue 2)  Insert into the
queue 3)  Delete from the queue 4)  destroyqueue
*/

/* queue q declared globally */

#include <stdio.h>
#include <stdlib.h>
#define NULL 0

struct node
{
    int data;
    struct node *next;
};

struct queue
{
    struct node *front, *rear;
};

struct queue q;

/* This function initializes the queue to empty by making both front and rear as
 * NULL */
void createqueue() { q.front = q.rear = NULL; }

int empty()
{
    if (q.front == NULL)
        return 1;
    else
        return 0;
}

void insert(int x)
{
    struct node *pnode;

    pnode = (struct node *)malloc(sizeof(struct node));
    if (pnode == NULL)
    {
        printf("Memory overflow. Unable to insert.\n");
        exit(1);
    }

    pnode->data = x;
    pnode->next = NULL; /* New node is always last node */

    if (empty())
        q.front = q.rear = pnode;
    else
    {
        (q.rear)->next = pnode;
        q.rear = pnode;
    }
}

int removes()
{
    int x;
    struct node *p;

    if (empty())
    {
        printf("Queue Underflow. Unable to remove.\n");
        exit(1);
    }

    p = q.front;
    x = (q.front)->data;
    q.front = (q.front)->next;
    if (q.front == NULL) /* Queue contained only one node */
        q.rear = NULL;
    free(p);
    return x;
}

void show()
{
    struct node *p;

    if (empty())
        printf("Queue empty. No data to display \n");
    else
    {
        printf("Queue from front to rear is as shown: \n");

        p = q.front;
        while (p != NULL)
        {
            printf("%d ", p->data);
            p = p->next;
        }

        printf("\n");
    }
}

void destroyqueue() { q.front = q.rear = NULL; }

int main()
{
    int x, ch;

    createqueue();

    do
    {
        printf("\n\n  Menu: \n");
        printf("1:Insert \n");
        printf("2:Remove \n");
        printf("3:exit \n");
        printf("Enter your choice: ");
        scanf("%d", &ch);

        switch (ch)
        {
        case 1:
            printf("Enter element to be inserted: ");
            scanf("%d", &x);
            insert(x);
            show();
            break;

        case 2:
            x = removes();
            printf("Element removed is: %d\n", x);
            show();
            break;

        case 3:
            break;
        }
    } while (ch != 3);

    destroyqueue();

    return 0;
}
/**
 * @file
 * @brief Implementation of [Doubly linked list](https://en.wikipedia.org/wiki/Doubly_linked_list)
 * @details
 * A doubly linked list is a data structure with a sequence
 * of components called nodes. Within that nodes there are
 * three elements: a value recorded, a pointer to the next
 * node, and a pointer to the previous node.
 *
 * In this implementation, the functions of creating the list,
 * inserting by position, deleting by position, searching 
 * for value, printing the list, and an example of how the
 * list works were coded.
 *
 * @author  [Gabriel Mota Bromonschenkel Lima](https://github.com/GabrielMotaBLima)
 */
#include <stdio.h>
#include <stdlib.h>

/**
 * @brief Doubly linked list struct
 */
typedef struct list
{
    double value;               ///< value saved on each node
    struct list *next, *prev;   ///< directing to other nodes or NULL
} List;

/**
 * @brief   Create list function, a new list containing one node will be created
 * @param   value       a value to be saved into the first list node
 * @returns new_list    the list created
 */
List *create(double value);

/**
 * @brief   Insertion by position into the list function
 * @param   list    a doubly linked List
 * @param   value   a value to be inserted into the list
 * @param   pos     a position into the list for value insertion
 * @returns list    the input list with a node more or the same list
 */
List *insert(List *list, double value, int pos);

/**
 * @brief   Deletion by position into the list function
 * @param   list    a doubly linked List
 * @param   pos     a position into the list for value Deletion
 * @returns list    the input list with deleted values or the same list
 */
List *delete(List *list, int pos);

/**
 * @brief   Search value into the list function
 * @param   list    a doubly linked list
 * @param   value   a value to be looked for into the list
 * @returns `1`     if the looked up value exists
 * @returns `0`     if the looked up value doesn't exist
 */
int search(List *list, double value);

/**
 * @brief   Print list function
 * @param   list    a doubly linked List
 * @returns void
 */
void print(List *list);

/**
 * @brief   Example function
 * @returns void
 */
void example();

/**
 * @brief   Main function
 * @returns 0   on exit
 */
int main()
{
    // examples for better understanding
    example();
    // code here
    return 0;
}

/**
 * @brief   Create list function, a new list containing one node will be created
 * @param   value       a value to be saved into the first list node
 * @returns new_list    the list created
 */
List *create(double value)
{
    List *new_list = (List *)malloc(sizeof(List));
    new_list->value = value;
    new_list->next = NULL;
    new_list->prev = NULL;
    return new_list;
}

/**
 * @brief   Insertion by position into the list function
 * @param   list    a doubly linked List
 * @param   value   a value to be inserted into the list
 * @param   pos     a position into the list for value insertion
 * @returns list    the input list with a node more or the same list
 */
List *insert(List *list, double value, int pos)
{
    // list NULL case
    if (list == NULL)
    {
        list = create(value);
        return list;
    }

    // position existing case
    if (pos > 0)
    {
        List *cpy = list, *tmp = cpy;
        int flag = 1, index = 1, size = 0;

        while (tmp != NULL)
        {
            size++;
            tmp = tmp->next;
        }

        // first position case
        if (pos == 1)
        {
            List *new_node = create(value);
            new_node->next = cpy;
            cpy->prev = new_node;
            list = new_node;
            return list;
        }

        // position existing in list range case
        if (size + 2 > pos)
        {
            while (cpy->next != NULL && index < pos)
            {
                flag++;
                index++;
                cpy = cpy->next;
            }

            List *new_node = (List *)malloc(sizeof(List));
            new_node->value = value;

            // position into list with no poiting for NULL
            if (flag == pos)
            {
                cpy->prev->next = new_node;
                new_node->next = cpy;
                new_node->prev = cpy->prev;
                cpy->prev = new_node;
            }

            // last position case
            if (flag < pos)
            {
                new_node->next = cpy->next;
                new_node->prev = cpy;
                cpy->next = new_node;
            }
        }
        return list;
    }
}

/**
 * @brief   Deletion by position into the list function
 * @param   list    a doubly linked List
 * @param   pos     a position into the list for value Deletion
 * @returns list    the input list with deleted values or the same list
 */
List *delete(List *list, int pos)
{
    // list NULL case
    if (list == NULL)
        return list;

    // position existing case
    if (pos > 0)
    {
        List *cpy = list, *tmp = cpy;
        int flag = 1, index = 1, size = 0;

        while (tmp != NULL)
        {
            size++;
            tmp = tmp->next;
        }

        // first position case
        if (pos == 1)
        {
            if (size == 1)
                return NULL;
            cpy = cpy->next;
            cpy->prev = NULL;
            return cpy;
        }

        // position existing in list range case
        if (size + 2 > pos)
        {
            while (cpy->next != NULL && index < pos)
            {
                flag++;
                index++;
                cpy = cpy->next;
            }

            if (flag == pos)
            {
                // position into list with no poiting for NULL
                if (cpy->next != NULL)
                {
                    cpy->prev->next = cpy->next;
                    cpy->next->prev = cpy->prev;
                }

                // last position case
                else
                    cpy->prev->next = NULL;
            }
        }
        return list;
    }
}

/**
 * @brief   Search value into the list function
 * @param   list    a doubly linked list
 * @param   value   a value to be looked for into the list
 * @returns `1`     if the looked up value exists
 * @returns `0`     if the looked up value doesn't exist
 */
int search(List *list, double value)
{
    if (list == NULL)
        return 0;
    if (list->value == value)
        return 1;
    search(list->next, value);
}

/**
 * @brief   Print list function
 * @param   list    a doubly linked List
 * @returns void
 */
void print(List *list)
{
    if (list != NULL)
    {
        printf("%f\t", list->value);
        print(list->next);
    }
}

/**
 * @brief   Example function
 * @returns void
 */
void example()
{
    List *my_list = NULL;
    double node_value = 0;
    int searching;

    my_list = create(node_value);
    my_list = insert(my_list, 3, 1);
    my_list = insert(my_list, 5, 3);
    my_list = insert(my_list, 10, 3);
    my_list = insert(my_list, 20, 3);

    print(my_list);
    searching = search(my_list, 20);
    printf("\n%d\n", searching);

    my_list = delete (my_list, 1);
    my_list = delete (my_list, 1);
    my_list = delete (my_list, 1);
    my_list = delete (my_list, 1);

    print(my_list);
    searching = search(my_list, 20);
    printf("\n%d\n", searching);
}
#include <stdio.h>
#include <stdlib.h>
struct node
{
    int info;
    struct node *link;
};
struct node *top = NULL, *temp;
void push(struct node *);
void pop(struct node *);
void display(struct node *);

int main()
{
    int x = 0, item;
    printf("\t****stack using linked list****\n");
    while (x != 4)
    {
        printf("\n1. Push\n2. Pop\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &x);
        switch (x)
        {
        case 1:
            push(top);
            break;
        case 2:
            pop(top);
            break;
        case 3:
            display(top);
            break;
        case 4:
            return 0;
        }
    }
}

void push(struct node *p)
{
    int item;
    struct node *temp;
    temp = (struct node *)malloc(sizeof(struct node));
    printf("\nEnter element to be inserted: ");
    scanf("%d", &item);
    temp->info = item;

    temp->link = top;
    top = temp;

    printf("Inserted succesfully.\n");
}
void pop(struct node *p)
{
    int item;
    struct node *temp;

    if (top == NULL)
        printf("\nStack is empty.\n");
    else
    {
        item = top->info;
        temp = top;
        top = top->link;
        free(temp);
        printf("\nElement popped is %d.\n", item);
    }
}

void display(struct node *p)
{
    if (top == NULL)
        printf("\nStack is empty.\n");
    else
    {
        printf("\nElements in the stack are:\n");
        while (p != NULL)
        {
            printf("\t%d\n", p->info);
            p = p->link;
        }
        // printf("%d\n",p->info);
    }
}
#include <stdio.h>
#include <stdlib.h>
struct node
{
    int data;
    struct node *next;
};

struct node *head1 = NULL;
struct node *head2 = NULL;

///// MAIN ALGORITHMIC FUNCTION to MERGE the two input linked lists ///////

void merge()
{
    struct node *temp1 = head1;
    struct node *temp2 = head2;

    struct node *holder1 = NULL;
    struct node *holder2 = NULL;
    // Temporary pointer variables to store the address of next node of the two
    // input linked list

    while (temp1 != NULL && temp2 != NULL)
    {
        holder1 = temp1->next;
        // Storing the address of next node of first linked list
        temp1->next = temp2;
        // Making the first node of first linked list point to first node of
        // second linked list

        if (holder1 != NULL)
        {
            // Making the first node of second linked list point to second node
            // of first linked list
            holder2 = temp2->next;
            temp2->next = holder1;
        }
        temp1 = holder1;
        temp2 = holder2;
        // Updating the address location of two pointer variables temp1 and
        // temp2
    }
}

void printlist(struct node *temp)
{
    printf("%d", temp->data);
    temp = temp->next;
    while (temp != NULL)
    {
        printf("->%d", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main()
{
    // Linked List 1: 1->3->5->7   :   Linked List 2: 2->4->6
    //  making lists
    struct node *one = (struct node *)malloc(sizeof(struct node));
    struct node *two = (struct node *)malloc(sizeof(struct node));
    struct node *three = (struct node *)malloc(sizeof(struct node));
    struct node *four = (struct node *)malloc(sizeof(struct node));
    struct node *five = (struct node *)malloc(sizeof(struct node));
    struct node *six = (struct node *)malloc(sizeof(struct node));
    struct node *seven = (struct node *)malloc(sizeof(struct node));
    // Seven nodes are created

    head1 = one;
    head2 = two;
    // head1 points to first node of first linked list
    // head2 points to first node of second linked list

    one->data = 1;
    one->next = three;

    two->data = 2;
    two->next = four;

    three->data = 3;
    three->next = five;

    four->data = 4;
    four->next = six;

    five->data = 5;
    five->next = seven;

    six->data = 6;
    six->next = NULL;
    // Last node of second input linked list

    seven->data = 7;
    seven->next = NULL;
    // Last node of first input linked list

    printf("Linked List 1: ");
    printlist(head1);
    printf("\nLinked List 2: ");
    printlist(head2);

    // Merging the two linked list into single linked list
    merge();

    printf("\nMerged Linked List: ");
    printlist(head1);  // list one has been modified

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

/* Link list node */
struct Node
{
    int data;
    struct Node *next;
};

/* Function to get the middle of the linked list*/
void printMiddle(struct Node *head)
{
    struct Node *slow_ptr = head;
    struct Node *fast_ptr = head;

    if (head != NULL)
    {
        while (fast_ptr != NULL && fast_ptr->next != NULL)
        {
            fast_ptr = fast_ptr->next->next;
            slow_ptr = slow_ptr->next;
        }
        printf("The middle element is [%d]\n\n", slow_ptr->data);
    }
}

void push(struct Node **head_ref, int new_data)
{
    /* allocate node */
    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));

    /* put in the data */
    new_node->data = new_data;

    /* link the old list off the new node */
    new_node->next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref) = new_node;
}

// A utility function to print a given linked list
void printList(struct Node *ptr)
{
    while (ptr != NULL)
    {
        printf("%d->", ptr->data);
        ptr = ptr->next;
    }
    printf("NULL\n");
}

/* Drier program to test above function*/
int main()
{
    /* Start with the empty list */
    struct Node *head = NULL;
    int i;

    for (i = 5; i > 0; i--)
    {
        push(&head, i);
        printList(head);
        printMiddle(head);
    }

    return 0;
}
/*Includes structure for a node which can be use to make new nodes of the Linked
  List. It is assumed that the data in nodes will be an integer, though function
  can be modified according to the data type, easily. deleteNode deletes a node
  when passed with a key of the node.
*/
#include <stdio.h>
struct node
{
    int info;
    struct node *link;
};
struct node *start = NULL;
///////////////////////////////////////////////////////////
struct node *createnode()  // function to create node
{
    struct node *t;
    t = (struct node *)malloc(sizeof(struct node));
    return (t);
}
////////////////////////////////////////////////////////
void insert()  // function to insert at first location
{
    struct node *p;
    p = createnode();
    printf("\nenter the number to insert");
    scanf("%d", &p->info);
    p->link = NULL;
    if (start == NULL)
    {
        start = p;
    }
    else
    {
        p->link = start;
        start = p;
    }
}
///////////////////////////////////////////////////////////
void deletion()  // function to delete from first position
{
    struct node *t;
    if (start == NULL)
    {
        printf("\nlist is empty");
    }
    else
    {
        struct node *p;
        p = start;
        start = start->link;
        free(p);
    }
}
///////////////////////////////////////////////////////
void viewlist()  // function to display values
{
    struct node *p;
    if (start == NULL)
    {
        printf("\nlist is empty");
    }
    else
    {
        p = start;
        while (p != NULL)
        {
            printf("%d ", p->info);
            p = p->link;
        }
    }
}
//////////////////////////////////////////////////////////////////////

int main()
{
    int n;
    while (1)
    {
        printf("\n1.add value at first location");
        printf("\n2.delete value from first location");
        printf("\n3.view value");
        printf("\nenter your choice");
        scanf("%d", &n);
        switch (n)
        {
        case 1:
            insert();
            break;
        case 2:
            deletion();
            break;
        case 3:
            viewlist();
            break;
        default:
            printf("\ninvalid choice");
        }
    }
    return (0);
}
#ifndef __DYNAMIC_ARRAY__
#define __DYNAMIC_ARRAY__
#define DEFAULT_CAPACITY 1 << 4
#define INDEX_OUT_OF_BOUNDS NULL

typedef struct dynamic_array
{
    void **items;
    unsigned size;
    unsigned capacity;
} dynamic_array_t;

extern dynamic_array_t *init_dynamic_array();

extern void *add(dynamic_array_t *da, const void *value);

extern void *put(dynamic_array_t *da, const void *value, unsigned index);

extern void *get(dynamic_array_t *da, const unsigned index);

extern void delete (dynamic_array_t *da, const unsigned index);

unsigned contains(const unsigned size, const unsigned index);

extern void *retrive_copy_of_value(const void *value);

#endif#include <stdio.h>
#include <stdlib.h>
#include "dynamic_array.h"

int main()
{
    dynamic_array_t *da = init_dynamic_array();

    for (int i = 1; i <= 50; i++)
    {
        add(da, &i);
    }

    delete (da, 10);

    int value = 1000;

    put(da, &value, 0);

    value = 5000;

    int another_value = 7000;

    add(da, &another_value);

    for (int i = 0; i < da->size; i++)
    {
        printf("value %d\n", *(int *)get(da, i));
    }

    int value_for_invalid_index = 10000;

    put(da, &value_for_invalid_index, 150);
    return 0;
}#include "dynamic_array.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

dynamic_array_t *init_dynamic_array()
{
    dynamic_array_t *da = malloc(sizeof(dynamic_array_t));
    da->items = calloc(DEFAULT_CAPACITY, sizeof(void *));
    da->capacity = DEFAULT_CAPACITY;

    return da;
}

void *add(dynamic_array_t *da, const void *value)
{
    if (da->size >= da->capacity)
    {
        void **newItems =
            realloc(da->items, (da->capacity <<= 1) * sizeof(void **));
        free(da->items);

        da->items = newItems;
    }

    void *copy_value = retrive_copy_of_value(value);
    da->items[da->size++] = copy_value;

    return copy_value;
}

void *put(dynamic_array_t *da, const void *value, const unsigned index)
{
    if (!contains(da->size, index))
        return INDEX_OUT_OF_BOUNDS;

    free(da->items[index]);
    void *copy_value = retrive_copy_of_value(value);
    da->items[index] = copy_value;

    return copy_value;
}

void *get(dynamic_array_t *da, const unsigned index)
{
    if (!contains(da->size, index))
        return INDEX_OUT_OF_BOUNDS;

    return da->items[index];
}

void delete (dynamic_array_t *da, const unsigned index)
{
    if (!contains(da->size, index))
        return;

    for (unsigned i = index; i < da->size; i++)
    {
        da->items[i] = da->items[i + 1];
    }

    da->size--;

    free(da->items[da->size]);
}

unsigned contains(const unsigned size, const unsigned index)
{
    if (size >= 0 && index < size)
        return 1;

    printf("index [%d] out of bounds!\n", index);
    return 0;
}

void *retrive_copy_of_value(const void *value)
{
    void *value_copy = malloc(sizeof(void *));
    memcpy(value_copy, value, sizeof(void *));

    return value_copy;
}/*------------------Trie Data Structure----------------------------------*/
/*-------------Implimented for search a word in dictionary---------------*/

/*-----character - 97 used for get the character from the ASCII value-----*/

// needed for strnlen
#define _POSIX_C_SOURCE 200809L

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ALPHABET_SIZE 26

/*--Node in the Trie--*/
struct trie {
    struct trie *children[ALPHABET_SIZE];
    bool end_of_word;
};


/*--Create new trie node--*/
int trie_new (
    struct trie ** trie
)
{
    *trie = calloc(1, sizeof(struct trie));
    if (NULL == *trie) {
        // memory allocation failed
        return -1;
    }
    return 0;
}


/*--Insert new word to Trie--*/
int trie_insert (
    struct trie * trie,
    char *word,
    unsigned word_len
)
{
    int ret = 0;

    // this is the end of this word; add an end-of-word marker here and we're
    // done.
    if (0 == word_len) {
        trie->end_of_word = true;
        return 0;
    }

    // if you have some more complex mapping, you could introduce one here. In
    // this easy example, we just subtract 'a' (97) from it, meaning that 'a' is 0,
    // 'b' is 1, and so on.
    const unsigned int index = word[0] - 'a';

    // this index is outside the alphabet size; indexing this would mean an
    // out-of-bound memory access (bad!). If you introduce a separate map
    // function for indexing, then you could move the out-of-bounds index in
    // there.
    if (ALPHABET_SIZE <= index) {
        return -1;
    }

    // The index does not exist yet, allocate it.
    if (NULL == trie->children[index]) {
        ret = trie_new(&trie->children[index]);
        if (-1 == ret) {
            // creating new trie node failed
            return -1;
        }
    }
    
    // recurse into the child node
    return trie_insert(
        /* trie = */ trie->children[index],
        /* word = */ word + 1,
        /* word_len = */ word_len - 1
    );
}


/*--Search a word in the Trie--*/
int trie_search(
    struct trie * trie,
    char *word,
    unsigned word_len,
    struct trie ** result
)
{
    // we found a match
    if (0 == word_len) {
        *result = trie;
        return 0;
    }

    // same here as in trie_insert, if you have a separate index mapping, add
    // it here. In this example, we just subtract 'a'.
    const unsigned int index = word[0] - 'a';

    // This word contains letters outside the alphabet length; it's invalid.
    // Remember to do this to prevent buffer overflows.
    if (ALPHABET_SIZE <= index) {
        return -1;
    }

    // No match
    if (NULL == trie->children[index]) {
        return -1;
    }

    // traverse the trie
    return trie_search(
        /* trie = */ trie->children[index],
        /* word = */ word + 1,
        /* word_len = */ word_len - 1,
        /* result = */ result
    );
}

/*---Return all the related words------*/
void trie_print (
    struct trie * trie,
    char prefix[],
    unsigned prefix_len
)
{

    // An end-of-word marker means that this is a complete word, print it.
    if (true == trie->end_of_word) {
        printf("%.*s\n", prefix_len, prefix);
    }

    // However, there can be longer words with the same prefix; traverse into
    // those as well.
    for (int i = 0; i < ALPHABET_SIZE; i++) {

        // No words on this character
        if (NULL == trie->children[i]) {
            continue;
        }

        // If you have a separate index mapping, then you'd need the inverse of
        // the map here. Since we subtracted 'a' for the index, we can just add
        // 'a' to get the inverse map function.
        prefix[prefix_len] = i + 'a';

        // traverse the print into the child
        trie_print(trie->children[i], prefix, prefix_len + 1);
    }
}


/*------Demonstrate purposes uses text file called dictionary -------*/

int main() {
    int ret = 0;
    struct trie * root = NULL;
    struct trie * trie = NULL;
    char word[100] = {0};

    // Create a root trie
    ret = trie_new(&root);
    if (-1 == ret) {
        fprintf(stderr, "Could not create trie\n");
        exit(1);
    }

    // open the dictionary file
    FILE *fp = fopen("dictionary.txt", "r");
    if (NULL == fp) {
        fprintf(stderr, "Error while opening dictionary file");
        exit(1);
    }

    // insert all the words from the dictionary
    while (1 == fscanf(fp, "%100s\n", word)) {
        ret = trie_insert(root, word, strnlen(word, 100));
        if (-1 == ret) {
            fprintf(stderr, "Could not insert word into trie\n");
            exit(1);
        }
    }

    while (1) {
        printf("Enter keyword: ");
        if (1 != scanf("%100s", word)) {
            break;
        }

        printf(
            "\n==========================================================\n");
        printf("\n********************* Possible Words ********************\n");

        ret = trie_search(root, word, strnlen(word, 100), &trie);
        if (-1 == ret) {
            printf("No results\n");
            continue;
        }

        trie_print(trie, word, strnlen(word, 100));

        printf("\n==========================================================\n");
    }
}
/**
 * @file
 * \brief This file is a simple implementation of a Threaded Binary Tree
 *
 * Threaded Binary Tree is a binary tree variant in which all left child
 * pointers that are NULL (in Linked list representation) point to its
 * in-order predecessor, and all right child pointers that are NULL
 * (in Linked list representation) point to its in-order successor.
 * It has the following functionalities:
 * - Insertion
 * - Search
 * - Deletion
 * - Listing of node keys inorder,preorder,postorder
 *
 * -see binary_search_tree.c
 *
 * \author [Amitha Nayak](https://github.com/amitnayakblr)
 */

#include <stdio.h>
#include <stdlib.h>

/**
 * Node, the basic data structure of the tree
 */
typedef struct Node
{
    int data;           /**< stores the number */
    struct Node *llink; /**< link to left child */
    struct Node *rlink; /**< link to right child */
} node;

/**
 * creates a new node
 * param[in] data value to be inserted
 * \returns a pointer to the new node
 */
node *create_node(int data)
{
    node *ptr = (node *)malloc(sizeof(node));
    ptr->rlink = ptr->llink = NULL;
    ptr->data = data;
    return ptr;
}

/**
 * inserts a node into the tree
 * param[in,out] root pointer to node pointer to the topmost node of the tree
 * param[in] data value to be inserted into the tree
 */
void insert_bt(node **root, int data)
{
    node *new_node = create_node(data);
    node *temp;  // to be deleted
    node *prev;  // keeps track of the parent of the element deleted
    if (*root == NULL)
    {
        *root = new_node;
    }
    else
    {
        temp = *root;
        prev = NULL;
        while (temp != NULL)
        {
            if (new_node->data > temp->data)
            {
                prev = temp;
                temp = temp->rlink;
            }
            else if (new_node->data < temp->data)
            {
                prev = temp;
                temp = temp->llink;
            }
            else
            {
                return;
            }
        }

        if (new_node->data > prev->data)
        {
            prev->rlink = new_node;
        }
        else
        {
            prev->llink = new_node;
        }
    }
}

/**
 * searches for the element
 * \param[in] root node pointer to the topmost node of the tree
 * \param[in] ele value searched for
 */
void search(node *root, int ele)
{
    node *temp = root;
    while (temp != NULL)
    {
        if (temp->data == ele)
        {
            break;
        }
        else if (ele > temp->data)
        {
            temp = temp->rlink;
        }
        else
        {
            temp = temp->llink;
        }
    }

    if (temp == NULL)
    {
        printf("%s\n", "Element not found.");
    }
    else
        printf("%s\n", "Element found.");
}

/**
 * performs inorder traversal
 * param[in] curr node pointer to the topmost node of the tree
 */
void inorder_display(node *curr)
{
    if (curr != NULL)
    {
        inorder_display(curr->llink);
        printf("%d\t", curr->data);
        inorder_display(curr->rlink);
    }
}

/**
 * performs postorder traversal
 * param[in] curr node pointer to the topmost node of the tree
 */
void postorder_display(node *curr)
{
    if (curr != NULL)
    {
        postorder_display(curr->llink);
        postorder_display(curr->rlink);
        printf("%d\t", curr->data);
    }
}

/**
 * performs preorder traversal
 * param[in] curr node pointer to the topmost node of the tree
 */
void preorder_display(node *curr)
{
    if (curr != NULL)
    {
        printf("%d\t", curr->data);
        preorder_display(curr->llink);
        preorder_display(curr->rlink);
    }
}

/**
 * deletion of a node from the tree
 * if the node isn't present in the tree, it takes no action.
 * param[in,out] root pointer to node pointer to the topmost node of the tree
 * param[in] ele value to be deleted from the tree
 */
void delete_bt(node **root, int ele)
{
    node *temp;
    node *prev;
    if (*root == NULL)
        return;
    else
    {
        temp = *root;
        prev = NULL;
        // search
        while (temp != NULL)
        {
            if (temp->data == ele)
            {
                break;
            }
            else if (ele > temp->data)
            {
                prev = temp;
                temp = temp->rlink;
            }
            else
            {
                prev = temp;
                temp = temp->llink;
            }
        }
    }

    if (temp == NULL)
        return;
    else
    {
        node *replacement;  // deleted node's replacement
        node *t;
        if (temp->llink == NULL && temp->rlink == NULL)
        {
            replacement = NULL;
        }
        else if (temp->llink == NULL && temp->rlink != NULL)
        {
            replacement = temp->rlink;
        }
        else if (temp->llink != NULL && temp->rlink == NULL)
        {
            replacement = temp->llink;
        }
        else
        {
            replacement = temp->rlink;  // replaced with inorder successor
            t = replacement;
            while (t->llink != NULL)
            {
                t = t->llink;
            }
            t->llink =
                temp->llink;  // leftmost node of the replacement is linked to
                              // the left child of the deleted node
        }

        if (temp == *root)
        {
            free(*root);
            *root = replacement;
        }
        else if (prev->llink == temp)
        {
            free(prev->llink);
            prev->llink = replacement;
        }
        else if (prev->rlink == temp)
        {
            free(prev->rlink);
            prev->rlink = replacement;
        }
    }
}

/**
 * main function
 */
int main()
{
    printf("BINARY THREADED TREE: \n");
    node *root = NULL;
    int choice, n;
    do
    {
        printf("%s\n", "1. Insert into BT");
        printf("%s\n", "2. Print BT - inorder");
        printf("%s\n", "3. Print BT - preorder");
        printf("%s\n", "4. print BT - postorder");
        printf("%s\n", "5. delete from BT");
        printf("%s\n", "6. search in BT");
        printf("%s\n", "Type 0 to exit");
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
            printf("%s\n", "Enter a no:");
            scanf("%d", &n);
            insert_bt(&root, n);
            break;
        case 2:
            inorder_display(root);
            printf("\n");
            break;
        case 3:
            preorder_display(root);
            printf("\n");
            break;
        case 4:
            postorder_display(root);
            printf("\n");
            break;
        case 5:
            printf("%s\n", "Enter a no:");
            scanf("%d", &n);
            delete_bt(&root, n);
            break;
        case 6:
            printf("%s\n", "Enter a no:");
            scanf("%d", &n);
            search(root, n);
            break;
        }
    } while (choice != 0);
    return 0;
}
/**
 * @file segment_tree.c
 * @brief segment trees with only point updates
 * @details
 * This code implements segment trees. Segment trees are general structures
 * which allow range based queries in a given array in logN time.
 * Segment tree with point updates allow update of single element in the array
 * in logN time.
 * [Learn more about segment trees
 * here](https://codeforces.com/blog/entry/18051)
 * @author [Lakhan Nad](https://github.com/Lakhan-Nad)
 */

#include <assert.h>   /* for assert */
#include <inttypes.h> /* for int32 */
#include <stdio.h>    /* for scanf printf */
#include <stdlib.h>   /* for malloc, free */
#include <string.h>   /* for memcpy, memset */

/**
 * Function that combines two data to generate a new one
 * The name of function might be misleading actually combine here signifies the
 * fact that in segment trees we take partial result from two ranges and using
 * partial results we derive the result for joint range of those two ranges
 * For Example: array(1,2,3,4,5,6) sum of range [0,2] = 6
 * and sum of range [3,5] = 15 the combined sum of two range is 6+15=21
 * @note The function is same to binary function in Discrete Mathematics
 * @param a pointer to first data
 * @param b pointer to second data
 * @param result pointer to memory location where result of combining a and b is
 * to be stored
 */
typedef void (*combine_function)(const void *a, const void *b, void *result);

/**
 * This structures holds all the data that is required by a segment tree
 */
typedef struct segment_tree
{
    void *root;       /**< the root of formed segment tree */
    void *identity;   /**< identity element for combine function */
    size_t elem_size; /**< size in bytes of each data element */
    size_t length;    /**< total size of array which segment tree represents*/
    /** the function to be used to combine two node's
     * data to form parent's data
     */
    combine_function combine;
} segment_tree;

/**
 * Builds a Segment tree
 * It is assumed that leaves of tree already contains data.
 * @param tree pointer to segment tree to be build
 */
void segment_tree_build(segment_tree *tree)
{
    size_t elem_size = tree->elem_size;
    int index = (tree->length - 2);
    size_t b, l, r;
    char *ptr = (char *)tree->root;
    for (; index >= 0; index--)
    {
        b = index * elem_size;
        l = (2 * index + 1) * elem_size;
        r = (2 * index + 2) * elem_size;
        tree->combine(ptr + l, ptr + r, ptr + b);
    }
}

/**
 * For point updates
 * This function updates the element at given index and also updates segment
 * tree accordingly
 *
 * @param tree pointer to segment tree
 * @param index the index whose element is to be updated (0 based indexing used)
 * @param val pointer to value that is to be replaced at given index
 */
void segment_tree_update(segment_tree *tree, size_t index, void *val)
{
    size_t elem_size = tree->elem_size;
    index = index + tree->length - 1;
    char *base = (char *)tree->root;
    char *t = base + index * elem_size;
    memcpy(t, val, elem_size);
    while (index > 0)
    {
        index = ((index - 1) >> 1);
        tree->combine(base + (2 * index + 1) * elem_size,
                      base + (2 * index + 2) * elem_size,
                      base + index * elem_size);
    }
}

/**
 * Query the segment tree
 * This function helps in range query of segment tree
 * This function assumes that the given range is valid
 * Performs the query in range [l,r]
 * @param tree pointer to segment tree
 * @param l the start of range
 * @param r the end of range
 * @param res the pointer to memory where result of query is stored
 */
void segment_tree_query(segment_tree *tree, long long l, long long r, void *res)
{
    size_t elem_size = tree->elem_size;
    memcpy(res, tree->identity, elem_size);
    elem_size = tree->elem_size;
    char *root = (char *)tree->root;
    l += tree->length - 1;
    r += tree->length - 1;
    while (l <= r)
    {
        if (!(l & 1))
        {
            tree->combine(res, root + l * elem_size, res);
        }
        if (r & 1)
        {
            tree->combine(res, root + r * elem_size, res);
        }
        r = (r >> 1) - 1;
        l = (l >> 1);
    }
}

/**
 * Initializes Segment Tree
 * Accquires memory for segment tree
 * and fill the leaves of segment tree with data from array
 * @param arr the array data upon which segment tree is build
 * @param elem_size size of each element in segment tree
 * @param len total no of elements in array
 * @param identity the identity element for combine_function
 * @param func the combine_function used to build segment tree
 *
 * @returns pointer to sgement tree build
 */
segment_tree *segment_tree_init(void *arr, size_t elem_size, size_t len,
                                void *identity, combine_function func)
{
    segment_tree *tree = malloc(sizeof(segment_tree));
    tree->elem_size = elem_size;
    tree->length = len;
    tree->combine = func;
    tree->root = malloc(sizeof(char) * elem_size * (2 * len - 1));
    tree->identity = malloc(sizeof(char) * elem_size);
    char *ptr = (char *)tree->root;
    memset(ptr, 0, (len - 1) * elem_size);  // Initializing memory
    ptr = ptr + (len - 1) * elem_size;
    memcpy(ptr, arr, elem_size * len);  // copy the leaf nodes i.e. array data
    memcpy(tree->identity, identity, elem_size);  // copy identity element
    return tree;
}

/**
 * Dispose Segment Tree
 * Frees all heap memory accquired by segment tree
 * @param tree pointer to segment tree
 */
void segment_tree_dispose(segment_tree *tree)
{
    free(tree->root);
    free(tree->identity);
}

/**
 * Prints the data in segment tree
 * The data should be of int type
 * A utility to print segment tree
 * with data type of int
 * @param tree pointer to segment tree
 */
void segment_tree_print_int(segment_tree *tree)
{
    char *base = (char *)tree->root;
    size_t i = 0;
    for (; i < 2 * tree->length - 1; i++)
    {
        printf("%d ", *(int *)(base + i * tree->elem_size));
    }
    printf("\n");
}

/**
 * Utility for test
 * A function compare for minimum between two integers
 * This function is used as combine_function for RMQ
 * @param a pointer to integer a
 * @param b pointer to integer b
 * @param c pointer where minimum of a and b is tored as result
 */
void minimum(const void *a, const void *b, void *c)
{
    *(int *)c = *(int *)a < *(int *)b ? *(int *)a : *(int *)b;
}

/**
 * Test RMQ
 * Testing Segment tree using
 * Range Minimum Queries
 * @returns void
 */
static void test()
{
    int32_t arr[10] = {1, 0, 3, 5, 7, 2, 11, 6, -2, 8};
    int32_t identity = __INT32_MAX__;
    segment_tree *tree =
        segment_tree_init(arr, sizeof(*arr), 10, &identity, minimum);
    segment_tree_build(tree);
    int32_t result;
    segment_tree_query(tree, 3, 6, &result);
    assert(result == 2);
    segment_tree_query(tree, 8, 9, &result);
    assert(result == -2);
    result = 12;
    segment_tree_update(tree, 5, &result);
    segment_tree_update(tree, 8, &result);
    segment_tree_query(tree, 0, 3, &result);
    assert(result == 0);
    segment_tree_query(tree, 8, 9, &result);
    assert(result == 8);
    segment_tree_dispose(tree);
}

/**
 * @brief Main Function
 * @returns 0 on exit
 */
int main()
{
    test();
    return 0;
}
/**
 * @file
 * @brief Printing the [words contained in a
 * file](http://www.dailyfreecode.com/Code/word-list-reads-text-file-makes-2050.aspx)
 * named `file.txt` in alphabetical order and also their frequencies in to
 * another file "wordcount.txt"
 * @details
 * Given a file (`file.txt`) containing words (like a publication or a novel),
 * where words are separated by a space, newline, or underscore.
 * This program prints (writes or outputs) to another file (`wordcount.txt`),
 * the individual words contained in 'file.txt' with their frequencies (number
 * of occurences) each on a newline and in alphabetical order. This program uses
 * the binary tree data structure to accomplish this task.
 * @author [Randy Kwalar](https://github.com/RandyKdev)
 */

#include <assert.h>    /// for assert
#include <ctype.h>     /// for type checks
#include <inttypes.h>  /// for uint64_t based types, int64_t based types
#include <stdbool.h>   /// for boolean data type
#include <stdio.h>     /// for IO operations
#include <stdlib.h>    /// for memory allocation
#include <string.h>    /// for string operations

/**
 * @brief structure defining a node in the binary tree
 */
struct Node
{
    char *word;          ///< the word (value) of the node
    uint64_t frequency;  ///< number of occurences of the word
    struct Node *left;   ///< pointer to the left child node
    struct Node *right;  ///< pointer to the right child node
};

/**
 * @brief Ends program due to an error
 * @param errorMessage the error message to be printed
 * @returns void
 */
void endProgramAbruptly(char *errorMessage)
{
    fprintf(stderr, "%s\n", errorMessage);
    exit(EXIT_FAILURE);
}

/**
 * @brief Frees memory when program is terminating
 * @param node pointer to current node
 * @returns void
 */
void freeTreeMemory(struct Node *node)
{
    if (node != NULL)
    {
        freeTreeMemory(node->left);
        freeTreeMemory(node->right);
        free(node->word);  // freeing node->word because memory was allocated
                           // using malloc
        free(node);  // freeing node because memory was allocated using malloc
    }
}

/**
 * @brief Stores word in memory
 * @param word word to be stored in memory
 * @returns a pointer to the newly allocated word if the word IS stored successfully
 * @returns `NULL` if the word is NOT stored
 */
char *getPointerToWord(char *word)
{
    char *string =
        (char *)malloc((strlen(word) + 1) * sizeof(char));  ///< pointer to string
    // + 1 is for the '\0' character
    if (string != NULL)
    {
        strcpy(string, word);
        return string;
    }
    endProgramAbruptly(
        "\nA problem occurred while reserving memory for the word\n");
    return NULL;
}

/**
 * @brief Closes the file after reading or writing
 * @param file pointer to the file to be closed
 * @returns void
 */
void closeFile(FILE *file)
{
    if (fclose(file)) {
        endProgramAbruptly("\nA Problem Occurred while closing a file\n");
     }
}

/**
 * @brief Reserves memory for new node
 * @returns a pointer to the newly allocated node if memory IS successfully reserved
 * @returns `NULL` if memory is NOT reserved
 */
struct Node *allocateMemoryForNode()
{
    struct Node *node =
        (struct Node *)malloc(sizeof(struct Node));  ///< pointer to the node
    if (node != NULL)
    {
        return node;
    }
    endProgramAbruptly(
        "\nA problem occurred while reserving memory for the structure\n");
    return NULL;
}

/**
 * @brief Writes contents of tree to another file alphabetically
 * @param node pointer to current node
 * @param file pointer to file
 * @returns void
 */
void writeContentOfTreeToFile(struct Node *node, FILE *file)
{
    static uint64_t i = 1;  ///< for word numbering in the write file
    if (node != NULL)       // checks if the node is valid
    {
        writeContentOfTreeToFile(
            node->left,
            file);  // calls `writeContentOfTreeToFile` for left sub tree
        fprintf(file, "%-5lu \t %-9lu \t %s \n", i++, node->frequency,
                node->word);  // prints the word number, word frequency and word
                              // in tabular format to the file
        writeContentOfTreeToFile(
            node->right,
            file);  // calls `writeContentOfTreeToFile` for right sub tree
    }
}

/**
 * @brief Adds word (node) to the correct position in tree
 * @param word word to be inserted in to the tree
 * @param currentNode node which is being compared
 * @returns a pointer to the root node
 */
struct Node *addWordToTree(char *word, struct Node *currentNode)
{
    if (currentNode == NULL)  // checks if `currentNode` is `NULL`
    {
        struct Node *currentNode =
            allocateMemoryForNode();  // allocates memory for new node
        currentNode->word = getPointerToWord(word);  // stores `word` in memory
        currentNode->frequency = 1;  // initializes the word frequency to 1
        currentNode->left = NULL;    // sets left node to `NULL`
        currentNode->right = NULL;   // sets right node to `NULL`
        return currentNode;          // returns pointer to newly created node
    }

    int64_t compared = strcmp(word, currentNode->word);  ///< holds compare state

    if (compared > 0) {
        currentNode->right = addWordToTree(word,
            currentNode->right);  // adds `word` to right sub tree if `word` is
                                  // alphabetically greater than `currentNode->word`
    }
    else if (compared < 0) {
        currentNode->left = addWordToTree(word,
            currentNode->left);  // adds `word` to left sub tree if `word` is
                                 // alphabetically less than `currentNode->word`
    }
    else {
        currentNode->frequency++; // increments `currentNode` frequency if `word` is the same as `currentNode->word`
    }

    return currentNode; // returns pointer to current node
}

/**
 * @brief Reads words from file to tree
 * @param file file to be read from
 * @param root root node of tree
 * @returns a pointer to the root node
 */
struct Node *readWordsInFileToTree(FILE *file, struct Node *root)
{
    // longest english word = 45 chars
    // +1 for '\0' = 46 chars
    char *inputString =
        (char *)malloc(46 * sizeof(char));  ///< pointer to the input string

    char inputChar;                ///< temp storage of characters
    bool isPrevCharAlpha = false;  ///< bool to mark the end of a word
    uint8_t pos = 0;  ///< position in inputString to place the inputChar

    while ((inputChar = fgetc(file)) != EOF)
    {
        if (pos > 0)
            isPrevCharAlpha = isalpha(inputString[pos - 1]);

        // checks if character is letter
        if (isalpha(inputChar))
        {
            inputString[pos++] = tolower(inputChar);
            continue;
        }

        // checks if character is ' or - and if it is preceded by a letter eg
        // yours-not, persons' (valid)
        if ((inputChar == '\'' || inputChar == '-') && isPrevCharAlpha)
        {
            inputString[pos++] = inputChar;
            continue;
        }

        // makes sure that there is something valid in inputString
        if (pos == 0)
            continue;

        // if last character is not letter and is not ' then replace by \0
        if (!isPrevCharAlpha && inputString[pos - 1] != '\'')
            pos--;
        inputString[pos] = '\0';
        pos = 0;
        isPrevCharAlpha = false;
        root = addWordToTree(inputString, root);
    }

    // this is to catch the case for the EOF being immediately after the last
    // letter or '
    if (pos > 0)
    {
        if (!isPrevCharAlpha && inputString[pos - 1] != '\'')
            pos--;
        inputString[pos] = '\0';
        root = addWordToTree(inputString, root);
    }

    free(inputString);
    return root;
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
    struct Node *root = NULL;  ///< pointer to the root node
    FILE *file = NULL;         ///< pointer to the file

    file = fopen("file.txt", "w");  // creates test file in write mode

    fprintf(file,
            "hey_this, is a. test input \n to a_file");  // writes test data to
                                                         // test file

    closeFile(file);                // closes test file
    file = fopen("file.txt", "r");  // reopens test file in read mode

    root = readWordsInFileToTree(file,
                                 root);  // reads words from test file to tree

    // Tests to check if words were added to correct position in tree and also
    // if their frequencies were added correctly
    assert(strcmp(root->word, "hey") == 0);
    assert(root->frequency == 1);
    assert(strcmp(root->left->word, "a") == 0);
    assert(root->left->frequency == 2);
    assert(strcmp(root->right->word, "this") == 0);
    assert(strcmp(root->left->right->word, "file") == 0);
    assert(strcmp(root->right->left->word, "is") == 0);

    closeFile(file);     // closes test file
    remove("file.txt");  // deletes test file from storage

    file = fopen("wordcount.txt", "a");  // creates write file
    fprintf(file, "%-5s \t %9s \t %s \n", "S/N", "FREQUENCY",
            "WORD");  // prints the heading to `wordcount.txt`
    writeContentOfTreeToFile(
        root, file);  // writes content of tree to file (`wordcount.txt`)

    // Here is how the output to `wordcount.txt` should look like
    char *correctString =
        "S/N   	 FREQUENCY 	 WORD \n"
        "1     	 2         	 a \n"
        "2     	 1         	 file \n"
        "3     	 1         	 hey \n"
        "4     	 1         	 input \n"
        "5     	 1         	 is \n"
        "6     	 1         	 n \n"
        "7     	 1         	 test \n"
        "8     	 1         	 this \n"
        "9     	 1         	 to \n";

    int16_t inputChar;  // holds the current character in `wordcount.txt`
    uint64_t i = 0;     // holds the current index in `correctString`

    // Checks if the content in `wordcount.txt` is as expected (the same as in
    // `correctString`)
    while ((inputChar = fgetc(file)) != EOF) {
        assert(inputChar == correctString[i++]);
    }

    closeFile(file);          // closes `wordcount.txt`
    remove("wordcount.txt");  // deletes `wordcount.txt`

    freeTreeMemory(root);  // frees memory taken up by the tree
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    test();  // run self-test implementations
    return 0;
}
/* Includes structure for a node and a newNode() function which
   can be used to create a new node in the tree.
   It is assumed that the data in nodes will be an integer, though
   function can be modified according to the data type, easily.
 */

#include <stdio.h>
#include <stdlib.h>

struct node
{
    struct node *leftNode;
    int data;
    struct node *rightNode;
};

struct node *newNode(int data)
{
    struct node *node = (struct node *)malloc(sizeof(struct node));

    node->leftNode = NULL;
    node->data = data;
    node->rightNode = NULL;

    return node;
}

int main(void)
{
    /* new node can be created here as :-

       struct node *nameOfNode = newNode(data);

       and tree can be formed by creating further nodes at
       nameOfNode->leftNode and so on.
    */

    return 0;
}#include <math.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
    int val;
    struct node *par;
    struct node *left;
    struct node *right;
    int color;
} Node;

// Create a new node
Node *newNode(int val, Node *par)
{
    Node *create = (Node *)(malloc(sizeof(Node)));
    create->val = val;
    create->par = par;
    create->left = NULL;
    create->right = NULL;
    create->color = 1;
}

// Check if the node is the leaf
int isLeaf(Node *n)
{
    if (n->left == NULL && n->right == NULL)
    {
        return 1;
    }
    return 0;
}

// Left Rotate
Node *leftRotate(Node *node)
{
    Node *parent = node->par;
    Node *grandParent = parent->par;

    parent->right = node->left;
    if (node->left != NULL)
    {
        node->left->par = parent;
    }
    node->par = grandParent;
    parent->par = node;
    node->left = parent;
    if (grandParent != NULL)
    {
        if (grandParent->right == parent)
        {
            grandParent->right = node;
        }
        else
        {
            grandParent->left = node;
        }
    }
    return node;
}

// Right Rotate
Node *rightRotate(Node *node)
{
    Node *parent = node->par;
    Node *grandParent = parent->par;

    parent->left = node->right;
    if (node->right != NULL)
    {
        node->right->par = parent;
    }
    node->par = grandParent;
    parent->par = node;
    node->right = parent;
    if (grandParent != NULL)
    {
        if (grandParent->right == parent)
        {
            grandParent->right = node;
        }
        else
        {
            grandParent->left = node;
        }
    }
    return node;
}

// Check the node after the insertion step
void checkNode(Node *node)
{
    // If the node is the root
    if (node == NULL || node->par == NULL)
    {
        return;
    }
    Node *child = node;
    // If it is a black node or its parent is a black node
    if (node->color == 0 || (node->par)->color == 0)
    {
        // Dont Do Anything
        return;
    }

    // Both parent and child are red
    // Check For Uncle
    Node *parent = node->par;
    Node *grandParent = parent->par;

    // If grandParent is NULL, then parent is the root.
    // Just make the root black.
    if (grandParent == NULL)
    {
        parent->color = 0;
        return;
    }

    // If both the children of the grandParent are red
    if (grandParent->right != NULL && (grandParent->right)->color == 1 &&
        grandParent->left != NULL && (grandParent->left)->color == 1)
    {
        // Make the grandParent red and both of its children black
        (grandParent->right)->color = 0;
        (grandParent->left)->color = 0;
        grandParent->color = 1;
        return;
    }
    else
    {
        // The only option left is rotation.
        Node *greatGrandParent = grandParent->par;
        // Right Case
        if (grandParent->right == parent)
        {
            // Right Right Case
            if (parent->right == node)
            {
                grandParent->right = parent->left;
                if (parent->left != NULL)
                {
                    (parent->left)->par = grandParent;
                }
                parent->left = grandParent;
                grandParent->par = parent;

                // Attach to existing Tree;
                parent->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = parent;
                    }
                    else
                    {
                        greatGrandParent->right = parent;
                    }
                }

                // Change the colors
                parent->color = 0;
                grandParent->color = 1;
            }
            else
            {  // Right Left Case
                // First step -> Parent Child Rotation
                parent->left = child->right;
                if (child->right != NULL)
                {
                    (child->right)->par = parent;
                }
                child->right = parent;
                parent->par = child;

                // Second step -> Child and GrandParent Rotation
                grandParent->right = child->left;
                if (child->left != NULL)
                {
                    (child->left)->par = grandParent;
                }
                child->left = grandParent;
                grandParent->par = child;

                // Attach to the existing tree
                child->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = child;
                    }
                    else
                    {
                        greatGrandParent->right = child;
                    }
                }

                // Change The Colors
                child->color = 0;
                grandParent->color = 1;
            }
        }
        else
        {  // Left Case
            // Left Left Case
            if (parent->left == node)
            {
                grandParent->left = parent->right;
                if (parent->right != NULL)
                {
                    (parent->right)->par = grandParent;
                }
                parent->right = grandParent;
                grandParent->par = parent;

                // Attach to existing Tree;
                parent->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = parent;
                    }
                    else
                    {
                        greatGrandParent->right = parent;
                    }
                }

                // Change the colors
                parent->color = 0;
                grandParent->color = 1;
            }
            else
            {  // Left Right Case

                // First step -> Parent Child Rotation
                parent->right = child->left;
                if (child->left != NULL)
                {
                    (child->left)->par = parent;
                }
                child->left = parent;
                parent->par = child;

                // Second step -> Child and GrandParent Rotation
                grandParent->left = child->right;
                if (child->right != NULL)
                {
                    (child->right)->par = grandParent;
                }
                child->right = grandParent;
                grandParent->par = child;

                // Attach to the existing tree
                child->par = greatGrandParent;
                if (greatGrandParent != NULL)
                {
                    if (greatGrandParent->left != NULL &&
                        greatGrandParent->left == grandParent)
                    {
                        greatGrandParent->left = child;
                    }
                    else
                    {
                        greatGrandParent->right = child;
                    }
                }

                // Change The Colors
                child->color = 0;
                grandParent->color = 1;
            }
        }
    }
}

// To insert a node in the existing tree
void insertNode(int val, Node **root)
{
    Node *buffRoot = *root;
    while (buffRoot)
    {
        if (buffRoot->val > val)
        {
            // Go left
            if (buffRoot->left != NULL)
            {
                buffRoot = buffRoot->left;
            }
            else
            {
                // Insert The Node
                Node *toInsert = newNode(val, buffRoot);
                buffRoot->left = toInsert;
                buffRoot = toInsert;

                // Check For Double Red Problems
                break;
            }
        }
        else
        {
            // Go right
            if (buffRoot->right != NULL)
            {
                buffRoot = buffRoot->right;
            }
            else
            {
                // Insert The Node
                Node *toInsert = newNode(val, buffRoot);
                buffRoot->right = toInsert;
                buffRoot = toInsert;

                // Check For Double Red Problems
                break;
            }
        }
    }

    while (buffRoot != *root)
    {
        checkNode(buffRoot);
        if (buffRoot->par == NULL)
        {
            *root = buffRoot;
            break;
        }
        buffRoot = buffRoot->par;
        if (buffRoot == *root)
        {
            buffRoot->color = 0;
        }
    }
}

void checkForCase2(Node *toDelete, int delete, int fromDirection, Node **root)
{
    if (toDelete == (*root))
    {
        (*root)->color = 0;
        return;
    }

    if (!delete &&toDelete->color == 1)
    {
        if (!fromDirection)
        {
            if (toDelete->right != NULL)
            {
                toDelete->right->color = 1;
            }
        }
        else
        {
            if (toDelete->left != NULL)
            {
                toDelete->left->color = 1;
            }
        }
        toDelete->color = 0;
        return;
    }

    // Get the sibling for further inspection
    Node *sibling;
    Node *parent = toDelete->par;
    int locateChild = 0;  // 0 if toDeleted is left of its parent else 1
    if (parent->right == toDelete)
    {
        sibling = parent->left;
        locateChild = 1;
    }
    else
    {
        sibling = parent->right;
    }

    // Case 2.1. i.e. if the any children of the sibling is red
    if ((sibling->right != NULL && sibling->right->color == 1) ||
        (sibling->left != NULL && sibling->left->color == 1))
    {
        if (sibling->right != NULL && sibling->right->color == 1)
        {
            // Sibling is left and child is right. i.e. LEFT RIGHT ROTATION
            if (locateChild == 1)
            {
                int parColor = parent->color;

                // Step 1: Left rotate sibling
                sibling = leftRotate(sibling->right);

                // Step 2: Right rotate updated sibling
                parent = rightRotate(sibling);

                // Check if the root is rotated
                if (parent->par == NULL)
                {
                    *root = parent;
                }

                // Step 3: Update the colors
                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                // Delete the node (present at parent->right->right)
                if (delete)
                {
                    if (toDelete->left != NULL)
                    {
                        toDelete->left->par = parent->right;
                    }
                    parent->right->right = toDelete->left;
                    free(toDelete);
                }
            }
            else
            {  // Sibling is right and child is also right. i.e. LEFT LEFT
               // ROTATION

                int parColor = parent->color;

                // Left Rotate the sibling
                parent = leftRotate(sibling);

                // Check if the root is rotated
                if (parent->par == NULL)
                {
                    *root = parent;
                }

                // Update Colors
                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                // Delete the node (present at parent->left->left)
                if (delete)
                {
                    if (toDelete->right != NULL)
                    {
                        toDelete->right->par = parent->left;
                    }
                    parent->left->left = toDelete->left;
                    free(toDelete);
                }
            }
        }
        else
        {
            // Sibling is right and child is left. i.e. RIGHT LEFT ROTATION
            if (locateChild == 0)
            {
                int parColor = parent->color;

                // Step 1: Right rotate sibling
                sibling = rightRotate(sibling->left);

                // printf("%d - reached\n", sibling->val);
                // return;

                // Step 2: Left rotate updated sibling
                parent = leftRotate(sibling);

                // Check if the root is rotated
                if (parent->par == NULL)
                {
                    *root = parent;
                }

                // Step 3: Update the colors
                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                // Delete the node (present at parent->left->left)
                if (delete)
                {
                    if (toDelete->right != NULL)
                    {
                        toDelete->right->par = parent->left;
                    }
                    parent->left->left = toDelete->right;
                    free(toDelete);
                }
            }
            else
            {  // Sibling is left and child is also left. i.e. RIGHT RIGHT
               // ROTATION

                int parColor = parent->color;

                // Right Rotate the sibling
                parent = rightRotate(sibling);

                // Check if the root is rotated
                if (parent->par == NULL)
                {
                    *root = parent;
                }

                // Update Colors
                parent->color = parColor;
                parent->left->color = 0;
                parent->right->color = 0;

                // Delete the node (present at parent->right->right)
                if (delete)
                {
                    if (toDelete->left != NULL)
                    {
                        toDelete->left->par = parent->right;
                    }
                    parent->right->right = toDelete->left;
                    free(toDelete);
                }
            }
        }
    }
    else if (sibling->color == 0)
    {  // Make the sibling red and recur for its parent

        // Recolor the sibling
        sibling->color = 1;

        // Delete if necessary
        if (delete)
        {
            if (locateChild)
            {
                toDelete->par->right = toDelete->left;
                if (toDelete->left != NULL)
                {
                    toDelete->left->par = toDelete->par;
                }
            }
            else
            {
                toDelete->par->left = toDelete->right;
                if (toDelete->right != NULL)
                {
                    toDelete->right->par = toDelete->par;
                }
            }
        }

        checkForCase2(parent, 0, locateChild, root);
    }
    else
    {  // Bring the sibling on top and apply 2.1 or 2.2 accordingly
        if (locateChild)
        {  // Right Rotate

            toDelete->par->right = toDelete->left;
            if (toDelete->left != NULL)
            {
                toDelete->left->par = toDelete->par;
            }

            parent = rightRotate(sibling);

            // Check if the root is rotated
            if (parent->par == NULL)
            {
                *root = parent;
            }

            parent->color = 0;
            parent->right->color = 1;
            checkForCase2(parent->right, 0, 1, root);
        }
        else
        {  // Left Rotate

            toDelete->par->left = toDelete->right;
            if (toDelete->right != NULL)
            {
                toDelete->right->par = toDelete->par;
            }
            parent = leftRotate(sibling);

            // Check if the root is rotated
            if (parent->par == NULL)
            {
                *root = parent;
            }

            printf("\nroot - %d - %d\n", parent->val, parent->left->val);

            parent->color = 0;
            parent->left->color = 1;
            checkForCase2(parent->left, 0, 0, root);
        }
    }
}

// To delete a node from the tree
void deleteNode(int val, Node **root)
{
    Node *buffRoot = *root;

    // Search for the element in the tree
    while (1)
    {
        if (val == buffRoot->val)
        {
            // Node Found
            break;
        }

        if (val > buffRoot->val)
        {
            if (buffRoot->right != NULL)
            {
                buffRoot = buffRoot->right;
            }
            else
            {
                printf("Node Not Found!!!");
                return;
            }
        }
        else
        {
            if (buffRoot->left != NULL)
            {
                buffRoot = buffRoot->left;
            }
            else
            {
                printf("Node Not Found!!!");
                return;
            }
        }
    }

    Node *toDelete = buffRoot;

    // Look for the leftmost of right node or right most of left node
    if (toDelete->left != NULL)
    {
        toDelete = toDelete->left;
        while (toDelete->right != NULL)
        {
            toDelete = toDelete->right;
        }
    }
    else if (toDelete->right != NULL)
    {
        toDelete = toDelete->right;
        while (toDelete->left != NULL)
        {
            toDelete = toDelete->left;
        }
    }

    if (toDelete == *root)
    {
        *root = NULL;
        return;
    }

    // Swap the values
    buffRoot->val = toDelete->val;
    toDelete->val = val;

    // Checking for case 1
    if (toDelete->color == 1 ||
        (toDelete->left != NULL && toDelete->left->color == 1) ||
        (toDelete->right != NULL && toDelete->right->color == 1))
    {
        // if it is a leaf
        if (toDelete->left == NULL && toDelete->right == NULL)
        {
            // Delete instantly
            if (toDelete->par->left == toDelete)
            {
                toDelete->par->left = NULL;
            }
            else
            {
                toDelete->par->right = NULL;
            }
        }
        else
        {  // else its child should be red

            // Check for the exitstence of left node
            if (toDelete->left != NULL)
            {
                // The node should be right to its parent
                toDelete->par->right = toDelete->left;
                toDelete->left->par = toDelete->par;
                toDelete->left->color = 1;
            }
            else
            {  // else the right node should be red
                toDelete->par->left = toDelete->right;
                toDelete->right->par = toDelete->par;
                toDelete->right->color = 1;
            }
        }

        // Remove the node from memory
        free(toDelete);
    }
    else
    {  // Case 2
        checkForCase2(toDelete, 1, ((toDelete->par->right == toDelete)), root);
    }
}

void printInorder(Node *root)
{
    if (root != NULL)
    {
        printInorder(root->left);
        printf("%d c-%d ", root->val, root->color);
        printInorder(root->right);
    }
}

void checkBlack(Node *temp, int c)
{
    if (temp == NULL)
    {
        printf("%d ", c);
        return;
    }
    if (temp->color == 0)
    {
        c++;
    }
    checkBlack(temp->left, c);
    checkBlack(temp->right, c);
}

int main()
{
    Node *root = NULL;
    int scanValue, choice = 1;
    printf(
        "1 - Input\n2 - Delete\n3 - Inorder Traversel\n0 - Quit\n\nPlease "
        "Enter the Choice - ");
    scanf("%d", &choice);
    while (choice)
    {
        switch (choice)
        {
        case 1:
            printf("\n\nPlease Enter A Value to insert - ");
            scanf("%d", &scanValue);
            if (root == NULL)
            {
                root = newNode(scanValue, NULL);
                root->color = 0;
            }
            else
            {
                insertNode(scanValue, &root);
            }
            printf("\nSuccessfully Inserted %d in the tree\n\n", scanValue);
            break;
        case 2:
            printf("\n\nPlease Enter A Value to Delete - ");
            scanf("%d", &scanValue);
            deleteNode(scanValue, &root);
            printf("\nSuccessfully Inserted %d in the tree\n\n", scanValue);
            break;
        case 3:
            printf("\nInorder Traversel - ");
            printInorder(root);
            printf("\n\n");
            // checkBlack(root,0);
            // printf("\n");
            break;
        default:
            if (root != NULL)
            {
                printf("Root - %d\n", root->val);
            }
        }
        printf(
            "1 - Input\n2 - Delete\n3 - Inorder Traversel\n0 - "
            "Quit\n\nPlease Enter the Choice - ");
        scanf("%d", &choice);
    }
}

// 32 12 50 53 1 2 3 4 5 6 7 8 9
#include <stdio.h>
#include <stdlib.h>

struct AVLnode
{
    int key;
    struct AVLnode *left;
    struct AVLnode *right;
    int height;
};
typedef struct AVLnode avlNode;

int max(int a, int b) { return (a > b) ? a : b; }

avlNode *newNode(int key)
{
    avlNode *node = (avlNode *)malloc(sizeof(avlNode));

    if (node == NULL)
        printf("!! Out of Space !!\n");
    else
    {
        node->key = key;
        node->left = NULL;
        node->right = NULL;
        node->height = 0;
    }

    return node;
}

int nodeHeight(avlNode *node)
{
    if (node == NULL)
        return -1;
    else
        return (node->height);
}

int heightDiff(avlNode *node)
{
    if (node == NULL)
        return 0;
    else
        return (nodeHeight(node->left) - nodeHeight(node->right));
}

/* Returns the node with min key in the left subtree*/
avlNode *minNode(avlNode *node)
{
    avlNode *temp = node;

    while (temp->left != NULL) temp = temp->left;

    return temp;
}

void printAVL(avlNode *node, int level)
{
    int i;
    if (node != NULL)
    {
        printAVL(node->right, level + 1);
        printf("\n\n");

        for (i = 0; i < level; i++) printf("\t");

        printf("%d", node->key);

        printAVL(node->left, level + 1);
    }
}

avlNode *rightRotate(avlNode *z)
{
    avlNode *y = z->left;
    avlNode *T3 = y->right;

    y->right = z;
    z->left = T3;

    z->height = (max(nodeHeight(z->left), nodeHeight(z->right)) + 1);
    y->height = (max(nodeHeight(y->left), nodeHeight(y->right)) + 1);

    return y;
}

avlNode *leftRotate(avlNode *z)
{
    avlNode *y = z->right;
    avlNode *T3 = y->left;

    y->left = z;
    z->right = T3;

    z->height = (max(nodeHeight(z->left), nodeHeight(z->right)) + 1);
    y->height = (max(nodeHeight(y->left), nodeHeight(y->right)) + 1);

    return y;
}

avlNode *LeftRightRotate(avlNode *z)
{
    z->left = leftRotate(z->left);

    return (rightRotate(z));
}

avlNode *RightLeftRotate(avlNode *z)
{
    z->right = rightRotate(z->right);

    return (leftRotate(z));
}

avlNode *insert(avlNode *node, int key)
{
    if (node == NULL)
        return (newNode(key));

    /*Binary Search Tree insertion*/

    if (key < node->key)
        node->left =
            insert(node->left, key); /*Recursive insertion in L subtree*/
    else if (key > node->key)
        node->right =
            insert(node->right, key); /*Recursive insertion in R subtree*/

    /* Node  Height as per the AVL formula*/
    node->height = (max(nodeHeight(node->left), nodeHeight(node->right)) + 1);

    /*Checking for the balance condition*/
    int balance = heightDiff(node);

    /*Left Left */
    if (balance > 1 && key < (node->left->key))
        return rightRotate(node);

    /*Right Right */
    if (balance < -1 && key > (node->right->key))
        return leftRotate(node);

    /*Left Right */
    if (balance > 1 && key > (node->left->key))
    {
        node = LeftRightRotate(node);
    }

    /*Right Left */
    if (balance < -1 && key < (node->right->key))
    {
        node = RightLeftRotate(node);
    }

    return node;
}

avlNode *delete (avlNode *node, int queryNum)
{
    if (node == NULL)
        return node;

    if (queryNum < node->key)
        node->left =
            delete (node->left, queryNum); /*Recursive deletion in L subtree*/
    else if (queryNum > node->key)
        node->right =
            delete (node->right, queryNum); /*Recursive deletion in R subtree*/
    else
    {
        /*Single or No Child*/
        if ((node->left == NULL) || (node->right == NULL))
        {
            avlNode *temp = node->left ? node->left : node->right;

            /* No Child*/
            if (temp == NULL)
            {
                temp = node;
                node = NULL;
            }
            else /*Single Child : copy data to the parent*/
                *node = *temp;

            free(temp);
        }
        else
        {
            /*Two Child*/

            /*Get the smallest key in the R subtree*/
            avlNode *temp = minNode(node->right);
            node->key = temp->key; /*Copy that to the root*/
            node->right =
                delete (node->right,
                        temp->key); /*Delete the smallest in the R subtree.*/
        }
    }

    /*single node in tree*/
    if (node == NULL)
        return node;

    /*Update height*/
    node->height = (max(nodeHeight(node->left), nodeHeight(node->right)) + 1);

    int balance = heightDiff(node);

    /*Left Left */
    if ((balance > 1) && (heightDiff(node->left) >= 0))
        return rightRotate(node);

    /*Left Right */
    if ((balance > 1) && (heightDiff(node->left) < 0))
    {
        node = LeftRightRotate(node);
    }

    /*Right Right */
    if ((balance < -1) && (heightDiff(node->right) >= 0))
        return leftRotate(node);

    /*Right Left */
    if ((balance < -1) && (heightDiff(node->right) < 0))
    {
        node = RightLeftRotate(node);
    }

    return node;
}

avlNode *findNode(avlNode *node, int queryNum)
{
    if (node != NULL)
    {
        if (queryNum < node->key)
            node = findNode(node->left, queryNum);
        else if (queryNum > node->key)
            node = findNode(node->right, queryNum);
    }

    return node;
}

void printPreOrder(avlNode *node)
{
    if (node == NULL)
        return;

    printf("  %d  ", (node->key));
    printPreOrder(node->left);
    printPreOrder(node->right);
}

void printInOrder(avlNode *node)
{
    if (node == NULL)
        return;
    printInOrder(node->left);
    printf("  %d  ", (node->key));
    printInOrder(node->right);
}

void printPostOrder(avlNode *node)
{
    if (node == NULL)
        return;
    printPostOrder(node->left);
    printPostOrder(node->right);
    printf("  %d  ", (node->key));
}

int main()
{
    int choice;
    int flag = 1;
    int insertNum;
    int queryNum;

    avlNode *root = NULL;
    avlNode *tempNode;

    while (flag == 1)
    {
        printf("\n\nEnter the Step to Run : \n");

        printf("\t1: Insert a node into AVL tree\n");
        printf("\t2: Delete a node in AVL tree\n");
        printf("\t3: Search a node into AVL tree\n");
        printf("\t4: printPreOrder (Ro L R) Tree\n");
        printf("\t5: printInOrder (L Ro R) Tree\n");
        printf("\t6: printPostOrder (L R Ro) Tree\n");
        printf("\t7: printAVL Tree\n");

        printf("\t0: EXIT\n");
        scanf("%d", &choice);

        switch (choice)
        {
        case 0:
        {
            flag = 0;
            printf("\n\t\tExiting, Thank You !!\n");
            break;
        }

        case 1:
        {
            printf("\n\tEnter the Number to insert: ");
            scanf("%d", &insertNum);

            tempNode = findNode(root, insertNum);

            if (tempNode != NULL)
                printf("\n\t %d Already exists in the tree\n", insertNum);
            else
            {
                printf("\n\tPrinting AVL Tree\n");
                printAVL(root, 1);
                printf("\n");

                root = insert(root, insertNum);
                printf("\n\tPrinting AVL Tree\n");
                printAVL(root, 1);
                printf("\n");
            }

            break;
        }

        case 2:
        {
            printf("\n\tEnter the Number to Delete: ");
            scanf("%d", &queryNum);

            tempNode = findNode(root, queryNum);

            if (tempNode == NULL)
                printf("\n\t %d Does not exist in the tree\n", queryNum);
            else
            {
                printf("\n\tPrinting AVL Tree\n");
                printAVL(root, 1);
                printf("\n");
                root = delete (root, queryNum);

                printf("\n\tPrinting AVL Tree\n");
                printAVL(root, 1);
                printf("\n");
            }

            break;
        }

        case 3:
        {
            printf("\n\tEnter the Number to Search: ");
            scanf("%d", &queryNum);

            tempNode = findNode(root, queryNum);

            if (tempNode == NULL)
                printf("\n\t %d : Not Found\n", queryNum);
            else
            {
                printf("\n\t %d : Found at height %d \n", queryNum,
                       tempNode->height);

                printf("\n\tPrinting AVL Tree\n");
                printAVL(root, 1);
                printf("\n");
            }

            break;
        }

        case 4:
        {
            printf("\nPrinting Tree preOrder\n");
            printPreOrder(root);

            break;
        }

        case 5:
        {
            printf("\nPrinting Tree inOrder\n");
            printInOrder(root);

            break;
        }

        case 6:
        {
            printf("\nPrinting Tree PostOrder\n");
            printPostOrder(root);

            break;
        }

        case 7:
        {
            printf("\nPrinting AVL Tree\n");
            printAVL(root, 1);

            break;
        }

        default:
        {
            flag = 0;
            printf("\n\t\tExiting, Thank You !!\n");
            break;
        }
        }
    }

    return 0;
}
/**
 * @file
 * @brief A basic unbalanced binary search tree implementation in C.
 * @details The implementation has the following functionalities implemented:
 * - Insertion
 * - Deletion
 * - Search by key value
 * - Listing of node keys in order of value (from left to right)
 */
#include <stdio.h>
#include <stdlib.h>

/** Node, the basic data structure in the tree */
typedef struct node
{
    struct node *left;  /**< left child */
    struct node *right; /**< right child */
    int data;           /**< data of the node */
} node;

/** The node constructor, which receives the key value input and returns a node
 * pointer
 * @param data data to store in a new node
 * @returns new node with the provided data
 * @note the node must be deleted before program terminates to avoid memory
 * leaks
 */
node *newNode(int data)
{
    // creates a slug
    node *tmp = (node *)malloc(sizeof(node));

    // initializes the slug
    tmp->data = data;
    tmp->left = NULL;
    tmp->right = NULL;

    return tmp;
}

/** Insertion procedure, which inserts the input key in a new node in the tree
 * @param root pointer to parent node
 * @param data value to store int he new node
 * @returns pointer to parent node
 */
node *insert(node *root, int data)
{
    // If the root of the subtree is null, insert key here
    if (root == NULL)
    {
        root = newNode(data);
    }
    else if (data > root->data)
    {
        // If it isn't null and the input key is greater than the root key,
        // insert in the right leaf
        root->right = insert(root->right, data);
    }
    else if (data < root->data)
    {  // If it isn't null and the input key is lower than the root key, insert
       // in the left leaf
        root->left = insert(root->left, data);
    }
    // Returns the modified tree
    return root;
}

/** Utilitary procedure to find the greatest key in the left subtree
 * @param root pointer to parent node
 * @returns pointer to parent node
 */
node *getMax(node *root)
{
    // If there's no leaf to the right, then this is the maximum key value
    if (root->right != NULL)
    {
        return getMax(root->right);
    }
    return root;
}

/** Deletion procedure, which searches for the input key in the tree and removes
 * it if present
 * @param root pointer to parent node
 * @param data value to search for int the node
 * @returns pointer to parent node
 */
node *delete (node *root, int data)
{
    // If the root is null, nothing to be done
    if (root == NULL)
    {
        return root;
    }
    else if (data > root->data)
    {  // If the input key is greater than the root's, search in the right
        // subtree
        root->right = delete (root->right, data);
    }
    else if (data < root->data)
    {  // If the input key is lower than the root's, search in the left subtree
        root->left = delete (root->left, data);
    }
    else if (data == root->data)
    {
        // If the input key matches the root's, check the following cases
        // termination condition
        if ((root->left == NULL) && (root->right == NULL))
        {  // Case 1: the root has no leaves, remove the node
            free(root);
            return NULL;
        }
        else if (root->left == NULL)
        {  // Case 2: the root has one leaf, make the leaf the new root and
            // remove
            // the old root
            node *tmp = root;
            root = root->right;
            free(tmp);
            return root;
        }
        else if (root->right == NULL)
        {
            node *tmp = root;
            root = root->left;
            free(tmp);
            return root;
        }
        else
        {  // Case 3: the root has 2 leaves, find the greatest key in the left
            // subtree and switch with the root's

            // finds the biggest node in the left branch.
            node *tmp = getMax(root->left);

            // sets the data of this node equal to the data of the biggest node
            // (lefts)
            root->data = tmp->data;
            root->left = delete (root->left, tmp->data);
        }
    }
    return root;
}

/** Search procedure, which looks for the input key in the tree and returns 1 if
 * it's present or 0 if it's not in the tree
 * @param root pointer to parent node
 * @param data value to store int he new node
 * @returns 0 if value not found in the nodes
 * @returns 1 if value was found
 */
int find(node *root, int data)
{
    // If the root is null, the key's not present
    if (root == NULL)
    {
        return 0;
    }
    else if (data > root->data)
    {
        // If the input key is greater than the root's, search in the right
        // subtree
        return find(root->right, data);
    }
    else if (data < root->data)
    {
        // If the input key is lower than the root's, search in the left subtree
        return find(root->left, data);
    }
    else if (data == root->data)
    {
        // If the input and the root key match, return 1
        return 1;
    }
    else
    {  // unknown result!!
        return 0;
    }
}

/** Utilitary procedure to measure the height of the binary tree
 * @param root pointer to parent node
 * @param data value to store int he new node
 * @returns 0 if value not found in the nodes
 * @returns height of nodes to get to data from parent node
 */
int height(node *root)
{
    // If the root is null, this is the bottom of the tree (height 0)
    if (root == NULL)
    {
        return 0;
    }
    else
    {
        // Get the height from both left and right subtrees to check which is
        // the greatest
        int right_h = height(root->right);
        int left_h = height(root->left);

        // The final height is the height of the greatest subtree(left or right)
        // plus 1(which is the root's level)
        if (right_h > left_h)
        {
            return (right_h + 1);
        }
        else
        {
            return (left_h + 1);
        }
    }
}

/** Utilitary procedure to free all nodes in a tree
 * @param root pointer to parent node
 */
void purge(node *root)
{
    if (root != NULL)
    {
        if (root->left != NULL)
        {
            purge(root->left);
        }
        if (root->right != NULL)
        {
            purge(root->right);
        }
        free(root);
        root = NULL;  // reset pointer
    }
}

/** Traversal procedure to list the current keys in the tree in order of value
 * (from the left to the right)
 * @param root pointer to parent node
 */
void inOrder(node *root)
{
    if (root != NULL)
    {
        inOrder(root->left);
        printf("\t[ %d ]\t", root->data);
        inOrder(root->right);
    }
}

/** Main funcion */
int main()
{
    // this reference don't change.
    // only the tree changes.
    node *root = NULL;
    int opt = -1;
    int data = 0;

    // event-loop.
    while (opt != 0)
    {
        printf(
            "\n\n[1] Insert Node\n[2] Delete Node\n[3] Find a Node\n[4] Get "
            "current Height\n[5] Print Tree in Crescent Order\n[0] Quit\n");
        scanf("%d", &opt);  // reads the choice of the user

        // processes the choice
        switch (opt)
        {
        case 1:
            printf("Enter the new node's value:\n");
            scanf("%d", &data);
            root = insert(root, data);
            break;

        case 2:
            printf("Enter the value to be removed:\n");
            if (root != NULL)
            {
                scanf("%d", &data);
                root = delete (root, data);
            }
            else
            {
                printf("Tree is already empty!\n");
            }
            break;

        case 3:
            printf("Enter the searched value:\n");
            scanf("%d", &data);
            find(root, data) ? printf("The value is in the tree.\n")
                             : printf("The value is not in the tree.\n");
            break;

        case 4:
            printf("Current height of the tree is: %d\n", height(root));
            break;

        case 5:
            inOrder(root);
            break;
        }
    }

    // deletes the tree from the heap.
    purge(root);

    return 0;
}
/* Includes the functions for Recursive Traversals
   of a Binary Tree. It is assumed that nodes and
   tree have been created as per create_node.c
 */

#include <stdio.h>

void inOrderTraversal(struct node *node)
{
    if (node == NULL)  // if tree is empty
        return;

    inOrderTraversal(node->leftNode);
    printf("\t%d\t", node->data);
    inOrderTraversal(node->rightNode);
}

void preOrderTraversal(struct node *node)
{
    if (node == NULL)  // if tree is empty
        return;

    printf("\t%d\t", node->data);
    preOrderTraversal(node->leftNode);
    preOrderTraversal(node->rightNode);
}

void postOrderTraversal(struct node *node)
{
    if (node == NULL)  // if tree is empty
        return;

    postOrderTraversal(node->leftNode);
    postOrderTraversal(node->rightNode);
    printf("\t%d\t", node->data);
}

int main(void)
{
    /* traversals can be done by simply invoking the
       function with a pointer to the root node.
    */

    return 0;
}#include <limits.h>  /// for INT_MIN
#include <stdio.h>   /// for IO operations
#include <stdlib.h>  /// for dynamic memory allocation

typedef struct max_heap
{
    int *p;
    int size;
    int count;
} Heap;

Heap *create_heap(Heap *heap); /*Creates a max_heap structure and returns a
                                  pointer to the struct*/
void down_heapify(Heap *heap, int index); /*Pushes an element downwards in the
                                             heap to find its correct position*/
void up_heapify(Heap *heap, int index); /*Pushes an element upwards in the heap
                                           to find its correct position*/
void push(Heap *heap, int x);           /*Inserts an element in the heap*/
void pop(Heap *heap); /*Removes the top element from the heap*/
int top(Heap *heap); /*Returns the top element of the heap or returns INT_MIN if
                        heap is empty*/
int empty(Heap *heap); /*Checks if heap is empty*/
int size(Heap *heap);  /*Returns the size of heap*/

int main()
{
    Heap *head = create_heap(head);
    push(head, 10);
    printf("Pushing element : 10\n");
    push(head, 3);
    printf("Pushing element : 3\n");
    push(head, 2);
    printf("Pushing element : 2\n");
    push(head, 8);
    printf("Pushing element : 8\n");
    printf("Top element = %d \n", top(head));
    push(head, 1);
    printf("Pushing element : 1\n");
    push(head, 7);
    printf("Pushing element : 7\n");
    printf("Top element = %d \n", top(head));
    pop(head);
    printf("Popping an element.\n");
    printf("Top element = %d \n", top(head));
    pop(head);
    printf("Popping an element.\n");
    printf("Top element = %d \n", top(head));
    printf("\n");
    return 0;
}
Heap *create_heap(Heap *heap)
{
    heap = (Heap *)malloc(sizeof(Heap));
    heap->size = 1;
    heap->p = (int *)malloc(heap->size * sizeof(int));
    heap->count = 0;
    return heap;
}

void down_heapify(Heap *heap, int index)
{
    if (index >= heap->count)
        return;
    int left = index * 2 + 1;
    int right = index * 2 + 2;
    int leftflag = 0, rightflag = 0;

    int maximum = *((heap->p) + index);
    if (left < heap->count && maximum < *((heap->p) + left))
    {
        maximum = *((heap->p) + left);
        leftflag = 1;
    }
    if (right < heap->count && maximum < *((heap->p) + right))
    {
        maximum = *((heap->p) + right);
        leftflag = 0;
        rightflag = 1;
    }
    if (leftflag)
    {
        *((heap->p) + left) = *((heap->p) + index);
        *((heap->p) + index) = maximum;
        down_heapify(heap, left);
    }
    if (rightflag)
    {
        *((heap->p) + right) = *((heap->p) + index);
        *((heap->p) + index) = maximum;
        down_heapify(heap, right);
    }
}
void up_heapify(Heap *heap, int index)
{
    int parent = (index - 1) / 2;
    if (parent < 0)
        return;
    if (*((heap->p) + index) > *((heap->p) + parent))
    {
        int temp = *((heap->p) + index);
        *((heap->p) + index) = *((heap->p) + parent);
        *((heap->p) + parent) = temp;
        up_heapify(heap, parent);
    }
}

void push(Heap *heap, int x)
{
    if (heap->count >= heap->size)
        return;
    *((heap->p) + heap->count) = x;
    heap->count++;
    if (4 * heap->count >= 3 * heap->size)
    {
        heap->size *= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
    up_heapify(heap, heap->count - 1);
}
void pop(Heap *heap)
{
    if (heap->count == 0)
        return;
    heap->count--;
    int temp = *((heap->p) + heap->count);
    *((heap->p) + heap->count) = *(heap->p);
    *(heap->p) = temp;
    down_heapify(heap, 0);
    if (4 * heap->count <= heap->size)
    {
        heap->size /= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
}
int top(Heap *heap)
{
    if (heap->count != 0)
        return *(heap->p);
    else
        return INT_MIN;
}
int empty(Heap *heap)
{
    if (heap->count != 0)
        return 0;
    else
        return 1;
}
int size(Heap *heap) { return heap->count; }
#include <stdio.h>
#include <stdlib.h>

typedef struct min_heap
{
    int *p;
    int size;
    int count;
} Heap;

Heap *create_heap(Heap *heap); /*Creates a min_heap structure and returns a
                                  pointer to the struct*/
void down_heapify(Heap *heap, int index); /*Pushes an element downwards in the
                                             heap to find its correct position*/
void up_heapify(Heap *heap, int index); /*Pushes an element upwards in the heap
                                           to find its correct position*/
void push(Heap *heap, int x);           /*Inserts an element in the heap*/
void pop(Heap *heap); /*Removes the top element from the heap*/
int top(Heap *heap); /*Returns the top element of the heap or returns INT_MIN if
                        heap is empty*/
int empty(Heap *heap); /*Checks if heap is empty*/
int size(Heap *heap);  /*Returns the size of heap*/

int main()
{
    Heap *head = create_heap(head);
    push(head, 10);
    printf("Pushing element : 10\n");
    push(head, 3);
    printf("Pushing element : 3\n");
    push(head, 2);
    printf("Pushing element : 2\n");
    push(head, 8);
    printf("Pushing element : 8\n");
    printf("Top element = %d \n", top(head));
    push(head, 1);
    printf("Pushing element : 1\n");
    push(head, 7);
    printf("Pushing element : 7\n");
    printf("Top element = %d \n", top(head));
    pop(head);
    printf("Popping an element.\n");
    printf("Top element = %d \n", top(head));
    pop(head);
    printf("Popping an element.\n");
    printf("Top element = %d \n", top(head));
    printf("\n");
    return 0;
}
Heap *create_heap(Heap *heap)
{
    heap = (Heap *)malloc(sizeof(Heap));
    heap->size = 1;
    heap->p = (int *)malloc(heap->size * sizeof(int));
    heap->count = 0;
    return heap;
}

void down_heapify(Heap *heap, int index)
{
    if (index >= heap->count)
        return;
    int left = index * 2 + 1;
    int right = index * 2 + 2;
    int leftflag = 0, rightflag = 0;

    int minimum = *((heap->p) + index);
    if (left < heap->count && minimum > *((heap->p) + left))
    {
        minimum = *((heap->p) + left);
        leftflag = 1;
    }
    if (right < heap->count && minimum > *((heap->p) + right))
    {
        minimum = *((heap->p) + right);
        leftflag = 0;
        rightflag = 1;
    }
    if (leftflag)
    {
        *((heap->p) + left) = *((heap->p) + index);
        *((heap->p) + index) = minimum;
        down_heapify(heap, left);
    }
    if (rightflag)
    {
        *((heap->p) + right) = *((heap->p) + index);
        *((heap->p) + index) = minimum;
        down_heapify(heap, right);
    }
}
void up_heapify(Heap *heap, int index)
{
    int parent = (index - 1) / 2;
    if (parent < 0)
        return;
    if (*((heap->p) + index) < *((heap->p) + parent))
    {
        int temp = *((heap->p) + index);
        *((heap->p) + index) = *((heap->p) + parent);
        *((heap->p) + parent) = temp;
        up_heapify(heap, parent);
    }
}

void push(Heap *heap, int x)
{
    if (heap->count >= heap->size)
        return;
    *((heap->p) + heap->count) = x;
    heap->count++;
    if (4 * heap->count >= 3 * heap->size)
    {
        heap->size *= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
    up_heapify(heap, heap->count - 1);
}
void pop(Heap *heap)
{
    if (heap->count == 0)
        return;
    heap->count--;
    int temp = *((heap->p) + heap->count);
    *((heap->p) + heap->count) = *(heap->p);
    *(heap->p) = temp;
    down_heapify(heap, 0);
    if (4 * heap->count <= heap->size)
    {
        heap->size /= 2;
        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));
    }
}
int top(Heap *heap)
{
    if (heap->count != 0)
        return *(heap->p);
    else
        return INT_MIN;
}
int empty(Heap *heap)
{
    if (heap->count != 0)
        return 0;
    else
        return 1;
}
int size(Heap *heap) { return heap->count; }
#include "dict.h"
#include <stdio.h>
#include <stdlib.h>

/* simple constructor */
Dictionary *create_dict(void)
{
    Dictionary *p_dic = malloc(sizeof(Dictionary));
    if (p_dic)
    {
        p_dic->number_of_elements = 0;

        /* initializes the elemens of the array with NULL-pointer */
        for (int i = 0; i < MAXELEMENTS; i++)
        {
            p_dic->elements[i] = NULL;
        }

        return p_dic;
    }
    else
    {
        printf("unable to create a dictionary\n");
        return NULL;
    }
}

/*
    utility function
    sdbm hash algorithm
    returns a hashcode for the given string 's'
*/
int get_hash(char s[])
{
    unsigned int hash_code = 0;

    /* iterates over string at each character */
    for (int counter = 0; s[counter] != '\0'; counter++)
    {
        /* actual computing of the hash code */
        hash_code =
            s[counter] + (hash_code << 6) + (hash_code << 16) - hash_code;
    }

    /* % modulo is for fitting the index in array. */
    return hash_code % MAXELEMENTS;
}

int add_item_label(Dictionary *dic, char label[], void *item)
{
    unsigned int index = get_hash(label);

    /* make sure index is fitting */
    if (index < MAXELEMENTS)
    {
        dic->elements[index] = item;
        return 0;
    }

    /* error case */
    return -1;
}

int add_item_index(Dictionary *dic, int index, void *item)
{
    /* make sure whether this place is already given */
    if (!dic->elements[index])
    {
        dic->elements[index] = item;
        return 0;
    }

    /* error case */
    return -1;
}

void *get_element_label(Dictionary *dict, char s[])
{
    int index = get_hash(s);
    if (dict->elements[index])
    {
        return dict->elements[index];
    }

    printf("None entry at given label\n");
    return NULL;
}

void *get_element_index(Dictionary *dict, int index)
{
    if (index >= 0 && index < MAXELEMENTS)
    {
        return dict->elements[index];
    }

    printf("index out of bounds!\n");
    return NULL;
}

void destroy(Dictionary *dict) { free(dict); }/*
    author: Christian Bender
    public interface for the dictionary.

    The dictionary prepares space for 1000 elements.
*/

#ifndef __DICT__H
#define __DICT__H

#define MAXELEMENTS 1000

/*
    special data type called 'Dictionary'
    for generic use
*/
typedef struct Dict
{
    /*
        void* array for generic use of the dictionary.
        there actual saves the entries.
    */
    void *elements[MAXELEMENTS];

    /* contains the number of elements in this dictionary */
    int number_of_elements;

} Dictionary;

/*
    create_dict: is a simple constructor for creating
                a dictionary and setting up the
                member field 'number_of_elements'
                and prepares the inner array 'elements'
*/
Dictionary *create_dict(void);

/*
    add_item_label: adds item (void*) to the dictionary at given label
    returns 0 if adding was sucessful otherwise -1
*/
int add_item_label(Dictionary *, char label[], void *);

/*
    add_item_index: adds item (void*) to the dictionary at given index (int)
    returns 0 if adding was sucessful otherwise -1
*/
int add_item_index(Dictionary *, int index, void *);

/*
    get_element: returns the element at given label
*/
void *get_element_label(Dictionary *, char[]);

/*
    get_element: returns the element at given index
*/
void *get_element_index(Dictionary *, int);

/*
    simple destrcutor function
*/
void destroy(Dictionary *);

#endif/*
    author: Christian Bender
    This is a simple test program for the dictionary.
*/

#include <stdio.h>

/* includes the dictionary */
#include "dict.h"

int main(void)
{
    Dictionary *testObj1;
    Dictionary *testObj2;

    int value = 28;

    testObj1 = create_dict();
    testObj2 = create_dict();

    add_item_label(testObj1, "age", &value);
    add_item_label(testObj2, "name", "Christian");

    /*
        test for function add_item_label

        attention:
        The void* pointer must be convert into an int* pointer.
        After that you can dereference it.
    */
    printf("My age is %d\n", *((int *)get_element_label(testObj1, "age")));
    printf("My name is %s\n", get_element_label(testObj2, "name"));

    /* test for function add_item_index */
    if (!add_item_index(testObj1, 0, &value))
    {
        printf("My age at index %d is %d\n", 0,
               *((int *)get_element_index(testObj1, 0)));
    }

    /* error scenario */
    /* get_element_label(testObj,"none"); */

    /* tidy up */
    destroy(testObj1);
    destroy(testObj2);

    return 0;
}#include "list.h"
#include <assert.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

#define L List_T

/* Initial list */
L List_init(void)
{
    L list;
    list = (L)malloc(sizeof(L));
    list->next = NULL;
    return list;
}

/* Push an element into top of the list */
L List_push(L list, void *val)
{
    L new_elem = (L)malloc(sizeof(L));
    new_elem->val = val;
    new_elem->next = list;
    return new_elem;
}

/* Length of list */
int List_length(L list)
{
    int n;
    for (n = 0; list; list = list->next) n++;
    return n;
}

/* Convert list to array */
void **List_toArray(L list)
{
    int i, n = List_length(list);
    void **array = (void **)malloc((n + 1) * sizeof(*array));

    for (i = 0; i < n; i++)
    {
        array[i] = list->val;
        list = list->next;
    }
    array[i] = NULL;
    return array;
}

/* Create and return a list */
L List_list(L list, void *val, ...)
{
    va_list ap;
    L *p = &list;

    va_start(ap, val);
    for (; val; val = va_arg(ap, void *))
    {
        *p = malloc(sizeof(L));
        (*p)->val = val;
        p = &(*p)->next;
    }
    *p = NULL;
    va_end(ap);
    return list;
}

/* Append 2 lists together */
L List_append(L list, L tail)
{
    L *p = &list;
    while ((*p)->next)
    {
        p = &(*p)->next;
    }

    *p = tail;
    return list;
}
#ifndef __LIST__
#define __LIST__

#define L List_T
typedef struct L *L;

struct L
{
    void *val;
    L next;
};

extern L List_init(void);
extern L List_push(L list, void *val);
extern int List_length(L list);
extern void **List_toArray(L list);
extern L List_append(L list, L tail);
extern L List_list(L list, void *val, ...);
/* TODO */
extern L List_copy(L list);
extern int List_pop(L *list);

#undef L
#endif
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "list.h"

void print_list(char **array)
{
    int i;
    for (i = 0; array[i]; i++) printf("%s", array[i]);
    printf("\n");
}

int main()
{
    List_T list1, list2, list3;
    char **str1 = (char **)malloc(100 * sizeof(char *));

    list1 = List_init();
    list1 = List_push(list1, "Dang ");
    list1 = List_push(list1, "Hoang ");
    list1 = List_push(list1, "Hai ");
    printf("List 1: ");
    str1 = (char **)List_toArray(list1);
    print_list(str1);

    list2 = List_init();
    list2 = List_list(list2, "Mentor ", "Graphics ", "Siemens", NULL);
    printf("List 2: ");
    print_list((char **)List_toArray(list2));

    list3 = List_append(list1, list2);
    printf("Test append list2 into list1: ");
    print_list((char **)List_toArray(list3));

    return 0;
}
//////////////////////////////////////////////////////////////////////////////////////
/// INCLUDES

#include <stdio.h>
#include <stdlib.h>
////////////////////////////////////////////////////////////////////////////////
// DATA STRUCTURES
/**
 * Defining the structure of the node which contains 'data' (type : integer),
 * two pointers 'next' and 'pre' (type : struct node).
 */

struct node
{
    int data;
    struct node *next;
    struct node *pre;
} * head, *tail, *tmp;

////////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

void create();
void enque(int x);
int deque();
int peek();
int size();
int isEmpty();
////////////////////////////////////////////////////////////////////////////////
// INCLUDES
#include "include.h";

////////////////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
int count;

////////////////////////////////////////////////////////////////////////////////
// MAIN ENTRY POINT

int main(int argc, char const *argv[])
{
    create();
    enque(5);

    return 0;
}

void create()
{
    head = NULL;
    tail = NULL;
}

/**
 * Puts an item into the Queue.
 */
void enque(int x)
{
    if (head == NULL)
    {
        head = (struct node *)malloc(sizeof(struct node));
        head->data = x;
        head->pre = NULL;
        tail = head;
    }
    else
    {
        tmp = (struct node *)malloc(sizeof(struct node));
        tmp->data = x;
        tmp->next = tail;
        tail = tmp;
    }
}

/**
 * Takes the next item from the Queue.
 */
int deque()
{
    int returnData = 0;
    if (head == NULL)
    {
        printf("ERROR: Deque from empty queue.\n");
        exit(1);
    }
    else
    {
        returnData = head->data;
        if (head->pre == NULL)
            head = NULL;
        else
            head = head->pre;
        head->next = NULL;
    }
    return returnData;
}

/**
 * Returns the size of the Queue.
 */
int size() { return count; }
#include <stdbool.h>
#include <stdio.h>
#include "Graph.h"
#include "queue.h"

#define MAX_NODES 1000

int visited[MAX_NODES];  // array to store visiting order
                         // indexed by vertex 0..nV-1

bool findPathBFS(Graph g, int nV, Vertex src, Vertex dest)
{
    Vertex v;
    for (v = 0; v < nV; v++) visited[v] = -1;

    visited[src] = src;
    queue Q = newQueue();
    QueueEnqueue(Q, src);
    while (!QueueIsEmpty(Q))
    {
        v = QueueDequeue(Q);
        Vertex w;
        for (w = 0; w < nV; w++)
            if (adjacent(g, v, w) && visited[w] == -1)
            {
                visited[w] = v;
                if (w == dest)
                    return true;
                else
                    QueueEnqueue(Q, w);
            }
    }
    return false;
}

int main(void)
{
    int V = 10;
    Graph g = newGraph(V);

    Edge e;
    e.v = 0;
    e.w = 1;
    insertEdge(g, e);
    e.v = 0;
    e.w = 2;
    insertEdge(g, e);
    e.v = 0;
    e.w = 5;
    insertEdge(g, e);
    e.v = 1;
    e.w = 5;
    insertEdge(g, e);
    e.v = 2;
    e.w = 3;
    insertEdge(g, e);
    e.v = 3;
    e.w = 4;
    insertEdge(g, e);
    e.v = 3;
    e.w = 5;
    insertEdge(g, e);
    e.v = 3;
    e.w = 8;
    insertEdge(g, e);
    e.v = 4;
    e.w = 5;
    insertEdge(g, e);
    e.v = 4;
    e.w = 7;
    insertEdge(g, e);
    e.v = 4;
    e.w = 8;
    insertEdge(g, e);
    e.v = 5;
    e.w = 6;
    insertEdge(g, e);
    e.v = 7;
    e.w = 8;
    insertEdge(g, e);
    e.v = 7;
    e.w = 9;
    insertEdge(g, e);
    e.v = 8;
    e.w = 9;
    insertEdge(g, e);

    int src = 0, dest = 6;
    if (findPathBFS(g, V, src, dest))
    {
        Vertex v = dest;
        while (v != src)
        {
            printf("%d - ", v);
            v = visited[v];
        }
        printf("%d\n", src);
    }
    return 0;
}

// By
//  .----------------.  .----------------.  .----------------.
//  .-----------------.  .----------------.  .----------------.
// | .--------------. || .--------------. || .--------------. ||
// .--------------. | | .--------------. || .--------------. | | |  _________ |
// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____
// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \
// | || ||_   \|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |
// \_|  | || |  | |    | |  | || |    / /\ \    | || |  |   \ | |   | | | |   |
// |__| |   | || |  /  .--.  \  | | | |     | |      | || |  | '    ' |  | || |
// / ____ \   | || |  | |\ \| |   | | | |   |  __  |   | || |  | |    | |  | |
// | |    _| |_     | || |   \ `--' /   | || | _/ /    \ \_ | || | _| |_\   |_
// | | | |  _| |  | |_  | || |  \  `--'  /  | | | |   |_____|    | || | `.__.'
// | || ||____|  |____|| || ||_____|\____| | | | | |____||____| | || | `.____.'
// | | | |              | || |              | || |              | || | | | | |
// | || |              | | | '--------------' || '--------------' ||
// '--------------' || '--------------' | | '--------------' || '--------------'
// |
//  '----------------'  '----------------'  '----------------'
//  '----------------'   '----------------'  '----------------'

//  Email :    z5261243@unsw.edu.au
//             hhoanhtuann@gmail.com
#include <stdbool.h>
#include <stdio.h>
#include "Graph.h"

#define MAX_NODES 1000

int visited[MAX_NODES];  // array to store visiting order
                         // indexed by vertex 0..nV-1

bool dfsPathCheck(Graph g, int nV, Vertex v, Vertex dest)
{
    Vertex w;
    for (w = 0; w < nV; w++)
        if (adjacent(g, v, w) && visited[w] == -1)
        {
            visited[w] = v;
            if (w == dest)
                return true;
            else if (dfsPathCheck(g, nV, w, dest))
                return true;
        }
    return false;
}

bool findPathDFS(Graph g, int nV, Vertex src, Vertex dest)
{
    Vertex v;
    for (v = 0; v < nV; v++) visited[v] = -1;
    visited[src] = src;
    return dfsPathCheck(g, nV, src, dest);
}

int main(void)
{
    int V = 6;
    Graph g = newGraph(V);

    Edge e;
    e.v = 0;
    e.w = 1;
    insertEdge(g, e);
    e.v = 0;
    e.w = 4;
    insertEdge(g, e);
    e.v = 0;
    e.w = 5;
    insertEdge(g, e);
    e.v = 5;
    e.w = 4;
    insertEdge(g, e);
    e.v = 4;
    e.w = 2;
    insertEdge(g, e);
    e.v = 4;
    e.w = 3;
    insertEdge(g, e);
    e.v = 5;
    e.w = 3;
    insertEdge(g, e);
    e.v = 1;
    e.w = 2;
    insertEdge(g, e);
    e.v = 3;
    e.w = 2;
    insertEdge(g, e);

    int src = 0, dest = 5;
    if (findPathDFS(g, V, src, dest))
    {
        Vertex v = dest;
        while (v != src)
        {
            printf("%d - ", v);
            v = visited[v];
        }
        printf("%d\n", src);
    }
    return 0;
}

// By
//  .----------------.  .----------------.  .----------------.
//  .-----------------.  .----------------.  .----------------.
// | .--------------. || .--------------. || .--------------. ||
// .--------------. | | .--------------. || .--------------. | | |  _________ |
// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____
// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \
// | || ||_   \|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |
// \_|  | || |  | |    | |  | || |    / /\ \    | || |  |   \ | |   | | | |   |
// |__| |   | || |  /  .--.  \  | | | |     | |      | || |  | '    ' |  | || |
// / ____ \   | || |  | |\ \| |   | | | |   |  __  |   | || |  | |    | |  | |
// | |    _| |_     | || |   \ `--' /   | || | _/ /    \ \_ | || | _| |_\   |_
// | | | |  _| |  | |_  | || |  \  `--'  /  | | | |   |_____|    | || | `.__.'
// | || ||____|  |____|| || ||_____|\____| | | | | |____||____| | || | `.____.'
// | | | |              | || |              | || |              | || | | | | |
// | || |              | | | '--------------' || '--------------' ||
// '--------------' || '--------------' | | '--------------' || '--------------'
// |
//  '----------------'  '----------------'  '----------------'
//  '----------------'   '----------------'  '----------------'

//  Email :    z5261243@unsw.edu.au
//             hhoanhtuann@gmail.com
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure for storing a graph
struct Graph
{
    int vertexNum;
    int **edges;
};

// Constructs a graph with V vertices and E edges
void createGraph(struct Graph *G, int V)
{
    G->vertexNum = V;
    G->edges = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
    {
        G->edges[i] = (int *)malloc(V * sizeof(int));
        for (int j = 0; j < V; j++) G->edges[i][j] = INT_MAX;
        G->edges[i][i] = 0;
    }
}

// Adds the given edge to the graph
void addEdge(struct Graph *G, int src, int dst, int weight)
{
    G->edges[src][dst] = weight;
}

// Utility function to find minimum distance vertex in mdist
int minDistance(int mdist[], int vset[], int V)
{
    int minVal = INT_MAX;
    static int minInd = -1; //remembers the previous value if not modified in the loop
    for (int i = 0; i < V; i++)
        if (vset[i] == 0 && mdist[i] < minVal)
        {
            minVal = mdist[i];
            minInd = i;
        }

    return minInd;
}

// Utility function to print distances
void print(int dist[], int V)
{
    printf("\nVertex  Distance\n");
    for (int i = 0; i < V; i++)
    {
        if (dist[i] != INT_MAX)
            printf("%d\t%d\n", i, dist[i]);
        else
            printf("%d\tINF", i);
    }
}

// The main function that finds the shortest path from given source
// to all other vertices using Dijkstra's Algorithm.It doesn't work on negative
// weights
void Dijkstra(struct Graph *graph, int src)
{
    int V = graph->vertexNum;
    int mdist[V];  // Stores updated distances to vertex
    int vset[V];   // vset[i] is true if the vertex i included
                   // in the shortest path tree

    // Initialise mdist and vset. Set distance of source as zero
    for (int i = 0; i < V; i++) mdist[i] = INT_MAX, vset[i] = 0;

    mdist[src] = 0;

    // iterate to find shortest path
    for (int count = 0; count < V - 1; count++)
    {
        int u = minDistance(mdist, vset, V);
        vset[u] = 1;

        for (int v = 0; v < V; v++)
        {
            if (!vset[v] && graph->edges[u][v] != INT_MAX &&
                mdist[u] + graph->edges[u][v] < mdist[v])
                mdist[v] = mdist[u] + graph->edges[u][v];
        }
    }

    print(mdist, V);

    return;
}

// Driver Function
int main()
{
    int V, E, gsrc;
    int src, dst, weight;
    struct Graph G;
    printf("Enter number of vertices: ");
    scanf("%d", &V);
    printf("Enter number of edges: ");
    scanf("%d", &E);
    createGraph(&G, V);
    for (int i = 0; i < E; i++)
    {
        printf("\nEdge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        printf("Enter weight: ");
        scanf("%d", &weight);
        addEdge(&G, src, dst, weight);
    }
    printf("\nEnter source:");
    scanf("%d", &gsrc);
    Dijkstra(&G, gsrc);

    return 0;
}
#include <stdbool.h>
#include <stdio.h>

#define NODES 4

int digraph[NODES][NODES] = {
    {0, 1, 1, 1}, {1, 0, 1, 0}, {0, 1, 0, 0}, {0, 0, 0, 0}};
int tc[NODES][NODES];

void warshall()
{
    int i, s, t;
    for (s = 0; s < NODES; s++)
        for (t = 0; t < NODES; t++) tc[s][t] = digraph[s][t];

    for (i = 0; i < NODES; i++)
        for (s = 0; s < NODES; s++)
            for (t = 0; t < NODES; t++)
                if (tc[s][i] && tc[i][t])
                    tc[s][t] = 1;
}

int main(void)
{
    warshall();
    int i, j;
    for (i = 0; i < NODES; i++)
    {
        for (j = 0; j < NODES; j++)
        {
            printf("%d ", tc[i][j]);
        }
        putchar('\n');
    }
    return 0;
}

// By
//  .----------------.  .----------------.  .----------------.
//  .-----------------.  .----------------.  .----------------.
// | .--------------. || .--------------. || .--------------. ||
// .--------------. | | .--------------. || .--------------. | | |  _________ |
// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____
// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \
// | || ||_   \|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |
// \_|  | || |  | |    | |  | || |    / /\ \    | || |  |   \ | |   | | | |   |
// |__| |   | || |  /  .--.  \  | | | |     | |      | || |  | '    ' |  | || |
// / ____ \   | || |  | |\ \| |   | | | |   |  __  |   | || |  | |    | |  | |
// | |    _| |_     | || |   \ `--' /   | || | _/ /    \ \_ | || | _| |_\   |_
// | | | |  _| |  | |_  | || |  \  `--'  /  | | | |   |_____|    | || | `.__.'
// | || ||____|  |____|| || ||_____|\____| | | | | |____||____| | || | `.____.'
// | | | |              | || |              | || |              | || | | | | |
// | || |              | | | '--------------' || '--------------' ||
// '--------------' || '--------------' | | '--------------' || '--------------'
// |
//  '----------------'  '----------------'  '----------------'
//  '----------------'   '----------------'  '----------------'

//  Email :    z5261243@unsw.edu.au
//             hhoanhtuann@gmail.com
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure for storing edge
struct Edge
{
    int src, dst, weight;
};

// Structure for storing a graph
struct Graph
{
    int vertexNum;
    int edgeNum;
    struct Edge *edges;
};

// Constructs a graph with V vertices and E edges
void createGraph(struct Graph *G, int V, int E)
{
    G->vertexNum = V;
    G->edgeNum = E;
    G->edges = (struct Edge *)malloc(E * sizeof(struct Edge));
}

// Adds the given edge to the graph
void addEdge(struct Graph *G, int src, int dst, int weight)
{
    static int ind;
    struct Edge newEdge;
    newEdge.src = src;
    newEdge.dst = dst;
    newEdge.weight = weight;
    G->edges[ind++] = newEdge;
}

// Utility function to find minimum distance vertex in mdist
int minDistance(int mdist[], int vset[], int V)
{
    int minVal = INT_MAX, minInd;
    for (int i = 0; i < V; i++)
        if (vset[i] == 0 && mdist[i] < minVal)
        {
            minVal = mdist[i];
            minInd = i;
        }

    return minInd;
}

// Utility function to print distances
void print(int dist[], int V)
{
    printf("\nVertex  Distance\n");
    for (int i = 0; i < V; i++)
    {
        if (dist[i] != INT_MAX)
            printf("%d\t%d\n", i, dist[i]);
        else
            printf("%d\tINF", i);
    }
}

// The main function that finds the shortest path from given source
// to all other vertices using Bellman-Ford.It also detects negative
// weight cycle
void BellmanFord(struct Graph *graph, int src)
{
    int V = graph->vertexNum;
    int E = graph->edgeNum;
    int dist[V];

    // Initialize distances array as INF for all except source
    // Intialize source as zero
    for (int i = 0; i < V; i++) dist[i] = INT_MAX;
    dist[src] = 0;

    // Calculate shortest path distance from source to all edges
    // A path can contain maximum (|V|-1) edges
    for (int i = 0; i <= V - 1; i++)
        for (int j = 0; j < E; j++)
        {
            int u = graph->edges[j].src;
            int v = graph->edges[j].dst;
            int w = graph->edges[j].weight;

            if (dist[u] != INT_MAX && dist[u] + w < dist[v])
                dist[v] = dist[u] + w;
        }

    // Iterate inner loop once more to check for negative cycle
    for (int j = 0; j < E; j++)
    {
        int u = graph->edges[j].src;
        int v = graph->edges[j].dst;
        int w = graph->edges[j].weight;

        if (dist[u] != INT_MAX && dist[u] + w < dist[v])
        {
            printf(
                "Graph contains negative weight cycle. Hence, shortest "
                "distance not guaranteed.");
            return;
        }
    }

    print(dist, V);

    return;
}

// Driver Function
int main()
{
    int V, E, gsrc;
    int src, dst, weight;
    struct Graph G;
    printf("Enter number of vertices: ");
    scanf("%d", &V);
    printf("Enter number of edges: ");
    scanf("%d", &E);
    createGraph(&G, V, E);
    for (int i = 0; i < E; i++)
    {
        printf("\nEdge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        printf("Enter weight: ");
        scanf("%d", &weight);
        addEdge(&G, src, dst, weight);
    }
    printf("\nEnter source:");
    scanf("%d", &gsrc);
    BellmanFord(&G, gsrc);

    return 0;
}
// Queue ADT implementation ... COMP2521

#include "queue.h"
#include <assert.h>
#include <stdlib.h>

typedef struct node
{
    int data;
    struct node *next;
} NodeT;

typedef struct QueueRep
{
    int length;
    NodeT *head;
    NodeT *tail;
} QueueRep;

// set up empty queue
queue newQueue()
{
    queue Q = malloc(sizeof(QueueRep));
    Q->length = 0;
    Q->head = NULL;
    Q->tail = NULL;
    return Q;
}

// remove unwanted queue
void dropQueue(queue Q)
{
    NodeT *curr = Q->head;
    while (curr != NULL)
    {
        NodeT *temp = curr->next;
        free(curr);
        curr = temp;
    }
    free(Q);
}

// check whether queue is empty
int QueueIsEmpty(queue Q) { return (Q->length == 0); }

// insert an int at end of queue
void QueueEnqueue(queue Q, int v)
{
    NodeT *new = malloc(sizeof(NodeT));
    assert(new != NULL);
    new->data = v;
    new->next = NULL;
    if (Q->tail != NULL)
    {
        Q->tail->next = new;
        Q->tail = new;
    }
    else
    {
        Q->head = new;
        Q->tail = new;
    }
    Q->length++;
}

// remove int from front of queue
int QueueDequeue(queue Q)
{
    assert(Q->length > 0);
    NodeT *p = Q->head;
    Q->head = Q->head->next;
    if (Q->head == NULL)
    {
        Q->tail = NULL;
    }
    Q->length--;
    int d = p->data;
    free(p);
    return d;
}

// By
//  .----------------.  .----------------.  .----------------.
//  .-----------------.  .----------------.  .----------------.
// | .--------------. || .--------------. || .--------------. ||
// .--------------. | | .--------------. || .--------------. | | |  _________ |
// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____
// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \
// | || ||_   \|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |
// \_|  | || |  | |    | |  | || |    / /\ \    | || |  |   \ | |   | | | |   |
// |__| |   | || |  /  .--.  \  | | | |     | |      | || |  | '    ' |  | || |
// / ____ \   | || |  | |\ \| |   | | | |   |  __  |   | || |  | |    | |  | |
// | |    _| |_     | || |   \ `--' /   | || | _/ /    \ \_ | || | _| |_\   |_
// | | | |  _| |  | |_  | || |  \  `--'  /  | | | |   |_____|    | || | `.__.'
// | || ||____|  |____|| || ||_____|\____| | | | | |____||____| | || | `.____.'
// | | | |              | || |              | || |              | || | | | | |
// | || |              | | | '--------------' || '--------------' ||
// '--------------' || '--------------' | | '--------------' || '--------------'
// |
//  '----------------'  '----------------'  '----------------'
//  '----------------'   '----------------'  '----------------'

//  Email :    z5261243@unsw.edu.au
//             hhoanhtuann@gmail.com
#include <stdbool.h>
#include <stdio.h>
#include "Graph.h"

// Return the number of vertices that v is
// connected to
int degree(Graph g, int nV, Vertex v)
{
    int deg = 0;
    Vertex w;
    for (w = 0; w < nV; w++)
        if (adjacent(g, v, w))
            deg++;
    return deg;
}

// If start from vertex v, decide if the
// graph has euler path
bool hasEulerPath(Graph g, int nV, Vertex v, Vertex w)
{
    if (v != w)
    {
        if (degree(g, nV, v) % 2 == 0 || degree(g, nV, w) % 2 == 0)
            return false;
    }
    else if (degree(g, nV, v) % 2 != 0)
    {
        return false;
    }
    Vertex x;
    for (x = 0; x < nV; x++)
        if (x != v && x != w && degree(g, nV, x) % 2 != 0)
            return false;
    return true;
}

int main(void)
{
    Edge e;
    int n;

    printf("Enter the number of vertices: ");
    scanf("%d", &n);
    Graph g = newGraph(n);

    Vertex src, dest;
    printf("Enter source node: ");
    scanf("%d", &src);
    printf("Enter destination node: ");
    scanf("%d", &dest);

    printf("Enter an edge (from): ");
    while (scanf("%d", &e.v) == 1)
    {
        printf("Enter an edge (to): ");
        scanf("%d", &e.w);
        insertEdge(g, e);
        printf("Enter an edge (from): ");
    }
    printf("Finished.\n");

    printf("The graph has ");
    if (hasEulerPath(g, n, src, dest))
        printf("an");
    else
        printf("no");
    printf(" Euler path from %d to %d.\n", src, dest);

    freeGraph(g);
    return 0;
}

// By
//  .----------------.  .----------------.  .----------------.
//  .-----------------.  .----------------.  .----------------.
// | .--------------. || .--------------. || .--------------. ||
// .--------------. | | .--------------. || .--------------. | | |  _________ |
// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____
// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \
// | || ||_   \|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |
// \_|  | || |  | |    | |  | || |    / /\ \    | || |  |   \ | |   | | | |   |
// |__| |   | || |  /  .--.  \  | | | |     | |      | || |  | '    ' |  | || |
// / ____ \   | || |  | |\ \| |   | | | |   |  __  |   | || |  | |    | |  | |
// | |    _| |_     | || |   \ `--' /   | || | _/ /    \ \_ | || | _| |_\   |_
// | | | |  _| |  | |_  | || |  \  `--'  /  | | | |   |_____|    | || | `.__.'
// | || ||____|  |____|| || ||_____|\____| | | | | |____||____| | || | `.____.'
// | | | |              | || |              | || |              | || | | | | |
// | || |              | | | '--------------' || '--------------' ||
// '--------------' || '--------------' | | '--------------' || '--------------'
// |
//  '----------------'  '----------------'  '----------------'
//  '----------------'   '----------------'  '----------------'

//  Email :    z5261243@unsw.edu.au
//             hhoanhtuann@gmail.com
// Graph ADT interface ... COMP2521
#include <stdbool.h>

typedef struct GraphRep *Graph;

// vertices are ints
typedef int Vertex;

// edges are pairs of vertices (end-points)
typedef struct Edge
{
    Vertex v;
    Vertex w;
} Edge;

Graph newGraph(int);
void insertEdge(Graph, Edge);
void removeEdge(Graph, Edge);
bool adjacent(Graph, Vertex, Vertex);
void showGraph(Graph);
void freeGraph(Graph);

// By
//  .----------------.  .----------------.  .----------------.
//  .-----------------.  .----------------.  .----------------.
// | .--------------. || .--------------. || .--------------. ||
// .--------------. | | .--------------. || .--------------. | | |  _________ |
// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____
// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \
// | || ||_   \|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |
// \_|  | || |  | |    | |  | || |    / /\ \    | || |  |   \ | |   | | | |   |
// |__| |   | || |  /  .--.  \  | | | |     | |      | || |  | '    ' |  | || |
// / ____ \   | || |  | |\ \| |   | | | |   |  __  |   | || |  | |    | |  | |
// | |    _| |_     | || |   \ `--' /   | || | _/ /    \ \_ | || | _| |_\   |_
// | | | |  _| |  | |_  | || |  \  `--'  /  | | | |   |_____|    | || | `.__.'
// | || ||____|  |____|| || ||_____|\____| | | | | |____||____| | || | `.____.'
// | | | |              | || |              | || |              | || | | | | |
// | || |              | | | '--------------' || '--------------' ||
// '--------------' || '--------------' | | '--------------' || '--------------'
// |
//  '----------------'  '----------------'  '----------------'
//  '----------------'   '----------------'  '----------------'

//  Email :    z5261243@unsw.edu.au
//             hhoanhtuann@gmail.com
// C program for Kruskal's algorithm to find Minimum Spanning Tree
// of a given connected, undirected and weighted graph
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// a structure to represent a weighted edge in graph
struct Edge
{
    int src, dest, weight;
};

// a structure to represent a connected, undirected
// and weighted graph
struct Graph
{
    // V-> Number of vertices, E-> Number of edges
    int V, E;

    // graph is represented as an array of edges.
    // Since the graph is undirected, the edge
    // from src to dest is also edge from dest
    // to src. Both are counted as 1 edge here.
    struct Edge *edge;
};

// Creates a graph with V vertices and E edges
struct Graph *createGraph(int V, int E)
{
    struct Graph *graph = new Graph();
    graph->V = V;
    graph->E = E;

    graph->edge = new Edge[E];

    return graph;
}

// A structure to represent a subset for union-find
struct subset
{
    int parent;
    int rank;
};

// A utility function to find set of an element i
// (uses path compression technique)
int find(struct subset subsets[], int i)
{
    // find root and make root as parent of i
    // (path compression)
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);

    return subsets[i].parent;
}

// A function that does union of two sets of x and y
// (uses union by rank)
void Union(struct subset subsets[], int x, int y)
{
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);

    // Attach smaller rank tree under root of high
    // rank tree (Union by Rank)
    if (subsets[xroot].rank < subsets[yroot].rank)
        subsets[xroot].parent = yroot;
    else if (subsets[xroot].rank > subsets[yroot].rank)
        subsets[yroot].parent = xroot;

    // If ranks are same, then make one as root and
    // increment its rank by one
    else
    {
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
    }
}

// Compare two edges according to their weights.
// Used in qsort() for sorting an array of edges
int myComp(const void *a, const void *b)
{
    struct Edge *a1 = (struct Edge *)a;
    struct Edge *b1 = (struct Edge *)b;
    return a1->weight > b1->weight;
}

// The main function to construct MST using Kruskal's algorithm
void KruskalMST(struct Graph *graph)
{
    int V = graph->V;
    struct Edge result[V];  // Tnis will store the resultant MST
    int e = 0;              // An index variable, used for result[]
    int i = 0;              // An index variable, used for sorted edges

    // Step 1: Sort all the edges in non-decreasing
    // order of their weight. If we are not allowed to
    // change the given graph, we can create a copy of
    // array of edges
    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);

    // Allocate memory for creating V ssubsets
    struct subset *subsets = (struct subset *)malloc(V * sizeof(struct subset));

    // Create V subsets with single elements
    for (int v = 0; v < V; ++v)
    {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }

    // Number of edges to be taken is equal to V-1
    while (e < V - 1 && i < graph->E)
    {
        // Step 2: Pick the smallest edge. And increment
        // the index for next iteration
        struct Edge next_edge = graph->edge[i++];

        int x = find(subsets, next_edge.src);
        int y = find(subsets, next_edge.dest);

        // If including this edge does't cause cycle,
        // include it in result and increment the index
        // of result for next edge
        if (x != y)
        {
            result[e++] = next_edge;
            Union(subsets, x, y);
        }
        // Else discard the next_edge
    }

    // print the contents of result[] to display the
    // built MST
    printf("Following are the edges in the constructed MST\n");
    for (i = 0; i < e; ++i)
        printf("%d -- %d == %d\n", result[i].src, result[i].dest,
               result[i].weight);
    return;
}

// Driver program to test above functions
int main()
{
    /* Let us create following weighted graph
            10
        0--------1
        | \	 |
    6| 5\ |15
        |	 \ |
        2--------3
            4	 */
    int V = 4;  // Number of vertices in graph
    int E = 5;  // Number of edges in graph
    struct Graph *graph = createGraph(V, E);

    // add edge 0-1
    graph->edge[0].src = 0;
    graph->edge[0].dest = 1;
    graph->edge[0].weight = 10;

    // add edge 0-2
    graph->edge[1].src = 0;
    graph->edge[1].dest = 2;
    graph->edge[1].weight = 6;

    // add edge 0-3
    graph->edge[2].src = 0;
    graph->edge[2].dest = 3;
    graph->edge[2].weight = 5;

    // add edge 1-3
    graph->edge[3].src = 1;
    graph->edge[3].dest = 3;
    graph->edge[3].weight = 15;

    // add edge 2-3
    graph->edge[4].src = 2;
    graph->edge[4].dest = 3;
    graph->edge[4].weight = 4;

    KruskalMST(graph);

    return 0;
}
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure for storing a graph
struct Graph
{
    int vertexNum;
    int **edges;
};

// Constructs a graph with V vertices and E edges
void createGraph(struct Graph *G, int V)
{
    G->vertexNum = V;
    G->edges = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
    {
        G->edges[i] = (int *)malloc(V * sizeof(int));
        for (int j = 0; j < V; j++) G->edges[i][j] = INT_MAX;
        G->edges[i][i] = 0;
    }
}

// Adds the given edge to the graph
void addEdge(struct Graph *G, int src, int dst, int weight)
{
    G->edges[src][dst] = weight;
}

// Utility function to print distances
void print(int dist[], int V)
{
    printf("\nThe Distance matrix for Floyd - Warshall\n");
    for (int i = 0; i < V; i++)
    {
        for (int j = 0; j < V; j++)
        {
            if (dist[i * V + j] != INT_MAX)
                printf("%d\t", dist[i * V + j]);
            else
                printf("INF\t");
        }
        printf("\n");
    }
}

// The main function that finds the shortest path from a vertex
// to all other vertices using Floyd-Warshall Algorithm.
void FloydWarshall(struct Graph *graph)
{
    int V = graph->vertexNum;
    int dist[V][V];

    // Initialise distance array
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++) dist[i][j] = graph->edges[i][j];

    // Calculate distances
    for (int k = 0; k < V; k++)
        // Choose an intermediate vertex

        for (int i = 0; i < V; i++)
            // Choose a source vertex for given intermediate

            for (int j = 0; j < V; j++)
                // Choose a destination vertex for above source vertex

                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX &&
                    dist[i][k] + dist[k][j] < dist[i][j])
                    // If the distance through intermediate vertex is less than
                    // direct edge then update value in distance array
                    dist[i][j] = dist[i][k] + dist[k][j];

    // Convert 2d array to 1d array for print
    int dist1d[V * V];
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++) dist1d[i * V + j] = dist[i][j];

    print(dist1d, V);
}

// Driver Function
int main()
{
    int V, E;
    int src, dst, weight;
    struct Graph G;
    printf("Enter number of vertices: ");
    scanf("%d", &V);
    printf("Enter number of edges: ");
    scanf("%d", &E);
    createGraph(&G, V);
    for (int i = 0; i < E; i++)
    {
        printf("\nEdge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        printf("Enter weight: ");
        scanf("%d", &weight);
        addEdge(&G, src, dst, weight);
    }
    FloydWarshall(&G);

    return 0;
}
#include <stdbool.h>
#include <stdio.h>
#include "Graph.h"

#define MAX_NODES 1000

bool visited[MAX_NODES];

bool hamiltonR(Graph g, int nV, Vertex v, Vertex dest, int d)
{
    // v = current vertex considered
    // dest = destination vertex
    // d = distance "remaining" until path found

    Vertex w;
    if (v == dest)
    {
        return (d == 0);
    }
    else
    {
        visited[v] = true;
        for (w = 0; w < nV; w++)
        {
            if (adjacent(g, v, w) && !visited[w])
            {
                if (hamiltonR(g, nV, w, dest, d - 1))
                {
                    return true;
                }
            }
        }
    }
    visited[v] = false;
    return false;
}

bool hasHamiltonianPath(Graph g, int nV, Vertex src, Vertex dest)
{
    Vertex v;
    for (v = 0; v < nV; v++) visited[v] = false;
    return hamiltonR(g, nV, src, dest, nV - 1);
}

int main(void)
{
    Edge e;
    int n;

    printf("Enter the number of vertices: ");
    scanf("%d", &n);
    Graph g = newGraph(n);

    Vertex src, dest;
    printf("Enter source node: ");
    scanf("%d", &src);
    printf("Enter destination node: ");
    scanf("%d", &dest);

    printf("Enter an edge (from): ");
    while (scanf("%d", &e.v) == 1)
    {
        printf("Enter an edge (to): ");
        scanf("%d", &e.w);
        insertEdge(g, e);
        printf("Enter an edge (from): ");
    }
    printf("Finished.\n");

    printf("The graph has ");
    if (hasHamiltonianPath(g, n, src, dest))
        printf("a");
    else
        printf("no");
    printf(" Hamiltonian path from %d to %d.\n", src, dest);

    freeGraph(g);
    return 0;
}

// By
//  .----------------.  .----------------.  .----------------.
//  .-----------------.  .----------------.  .----------------.
// | .--------------. || .--------------. || .--------------. ||
// .--------------. | | .--------------. || .--------------. | | |  _________ |
// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____
// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \
// | || ||_   \|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |
// \_|  | || |  | |    | |  | || |    / /\ \    | || |  |   \ | |   | | | |   |
// |__| |   | || |  /  .--.  \  | | | |     | |      | || |  | '    ' |  | || |
// / ____ \   | || |  | |\ \| |   | | | |   |  __  |   | || |  | |    | |  | |
// | |    _| |_     | || |   \ `--' /   | || | _/ /    \ \_ | || | _| |_\   |_
// | | | |  _| |  | |_  | || |  \  `--'  /  | | | |   |_____|    | || | `.__.'
// | || ||____|  |____|| || ||_____|\____| | | | | |____||____| | || | `.____.'
// | | | |              | || |              | || |              | || | | | | |
// | || |              | | | '--------------' || '--------------' ||
// '--------------' || '--------------' | | '--------------' || '--------------'
// |
//  '----------------'  '----------------'  '----------------'
//  '----------------'   '----------------'  '----------------'

//  Email :    z5261243@unsw.edu.au
//             hhoanhtuann@gmail.com
#include <stdio.h>
#include <stdlib.h>

// A vertex of the graph
struct node
{
    int vertex;
    struct node *next;
};
// Some declarations
struct node *createNode(int v);
struct Graph
{
    int numVertices;
    int *visited;
    struct node *
        *adjLists;  // we need int** to store a two dimensional array. Similary,
                    // we need struct node** to store an array of Linked lists
};
struct Graph *createGraph(int);
void addEdge(struct Graph *, int, int);
void printGraph(struct Graph *);
void dfs(struct Graph *, int);

int main()
{
    int vertices, edges, source, i, src, dst;
    printf("Enter the number of vertices\n");
    scanf("%d", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf("Enter the number of edges\n");
    scanf("%d", &edges);
    for (i = 0; i < edges; i++)
    {
        printf("Edge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        addEdge(graph, src, dst);
    }
    printf("Enter source of DFS\n");
    scanf("%d", &source);
    printf("DFS from %d is:\n", source);
    dfs(graph, source);
    printf("\n");

    // Uncomment below part to get a ready-made example
    /*struct Graph* graph = createGraph(4);
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 2);
    addEdge(graph, 2, 3);
    printf("DFS from 0 is:\n");
    dfs(graph,0);
    printf("\n");*/

    return 0;
}
// Recursive dfs approach
void dfs(struct Graph *graph, int vertex)
{
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;

    // Add vertex to visited list and print it
    graph->visited[vertex] = 1;
    printf("%d ", vertex);

    // Recursively call the dfs function on all unvisited neighbours
    while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            dfs(graph, connectedVertex);
        }
        temp = temp->next;
    }
}
// Allocate memory for a node
struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}
// Allocate memory for the entire graph structure
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjLists = malloc(vertices * sizeof(struct node *));

    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}
// Creates a bidirectional graph
void addEdge(struct Graph *graph, int src, int dest)
{
    // Add edge from src to dest
    struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    // Add edge from dest to src
    newNode = createNode(src);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}
// Utility function to see state of graph at a given time
void printGraph(struct Graph *graph)
{
    int v;
    for (v = 0; v < graph->numVertices; v++)
    {
        struct node *temp = graph->adjLists[v];
        printf("\n Adjacency list of vertex %d\n ", v);
        while (temp)
        {
            printf("%d -> ", temp->vertex);
            temp = temp->next;
        }
        printf("\n");
    }
}
// Graph ADT
// Adjacency Matrix Representation
#include "Graph.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct GraphRep
{
    int **edges;  // adjacency matrix
    int nV;       // #vertices
    int nE;       // #edges
} GraphRep;

Graph newGraph(int V)
{
    assert(V >= 0);
    int i;

    Graph g = malloc(sizeof(GraphRep));
    assert(g != NULL);
    g->nV = V;
    g->nE = 0;

    // allocate memory for each row
    g->edges = malloc(V * sizeof(int *));
    assert(g->edges != NULL);
    // allocate memory for each column and initialise with 0
    for (i = 0; i < V; i++)
    {
        g->edges[i] = calloc(V, sizeof(int));
        assert(g->edges[i] != NULL);
    }

    return g;
}

// check if vertex is valid in a graph
bool validV(Graph g, Vertex v) { return (g != NULL && v >= 0 && v < g->nV); }

void insertEdge(Graph g, Edge e)
{
    assert(g != NULL && validV(g, e.v) && validV(g, e.w));

    if (!g->edges[e.v][e.w])
    {  // edge e not in graph
        g->edges[e.v][e.w] = 1;
        g->edges[e.w][e.v] = 1;
        g->nE++;
    }
}

void removeEdge(Graph g, Edge e)
{
    assert(g != NULL && validV(g, e.v) && validV(g, e.w));

    if (g->edges[e.v][e.w])
    {  // edge e in graph
        g->edges[e.v][e.w] = 0;
        g->edges[e.w][e.v] = 0;
        g->nE--;
    }
}

bool adjacent(Graph g, Vertex v, Vertex w)
{
    assert(g != NULL && validV(g, v) && validV(g, w));

    return (g->edges[v][w] != 0);
}

void showGraph(Graph g)
{
    assert(g != NULL);
    int i, j;

    printf("Number of vertices: %d\n", g->nV);
    printf("Number of edges: %d\n", g->nE);
    for (i = 0; i < g->nV; i++)
        for (j = i + 1; j < g->nV; j++)
            if (g->edges[i][j])
                printf("Edge %d - %d\n", i, j);
}

void freeGraph(Graph g)
{
    assert(g != NULL);

    int i;
    for (i = 0; i < g->nV; i++) free(g->edges[i]);
    free(g->edges);
    free(g);
}

// By
//  .----------------.  .----------------.  .----------------.
//  .-----------------.  .----------------.  .----------------.
// | .--------------. || .--------------. || .--------------. ||
// .--------------. | | .--------------. || .--------------. | | |  _________ |
// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____
// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \
// | || ||_   \|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |
// \_|  | || |  | |    | |  | || |    / /\ \    | || |  |   \ | |   | | | |   |
// |__| |   | || |  /  .--.  \  | | | |     | |      | || |  | '    ' |  | || |
// / ____ \   | || |  | |\ \| |   | | | |   |  __  |   | || |  | |    | |  | |
// | |    _| |_     | || |   \ `--' /   | || | _/ /    \ \_ | || | _| |_\   |_
// | | | |  _| |  | |_  | || |  \  `--'  /  | | | |   |_____|    | || | `.__.'
// | || ||____|  |____|| || ||_____|\____| | | | | |____||____| | || | `.____.'
// | | | |              | || |              | || |              | || | | | | |
// | || |              | | | '--------------' || '--------------' ||
// '--------------' || '--------------' | | '--------------' || '--------------'
// |
//  '----------------'  '----------------'  '----------------'
//  '----------------'   '----------------'  '----------------'

//  Email :    z5261243@unsw.edu.au
//             hhoanhtuann@gmail.com
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 40  // Assume 40 nodes at max in graph
#define INT_MIN 0
// A vertex of the graph
struct node
{
    int vertex;
    struct node *next;
};
// Some declarations
struct node *createNode(int v);
struct Graph
{
    int numVertices;
    int *visited;
    struct node *
        *adjLists;  // we need int** to store a two dimensional array. Similary,
                    // we need struct node** to store an array of Linked lists
};
// Structure to create a stack, necessary for topological sorting
struct Stack
{
    int arr[MAX_SIZE];
    int top;
};
struct Graph *createGraph(int);
void addEdge(struct Graph *, int, int);
void printGraph(struct Graph *);
void topologicalSortHelper(int, struct Graph *, struct Stack *);
void topologicalSort(struct Graph *);
struct Stack *createStack();
void push(struct Stack *, int);
int pop(struct Stack *);

int main()
{
    int vertices, edges, i, src, dst;
    printf("Enter the number of vertices\n");
    scanf("%d", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf("Enter the number of edges\n");
    scanf("%d", &edges);
    for (i = 0; i < edges; i++)
    {
        printf("Edge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        addEdge(graph, src, dst);
    }
    printf("One topological sort order is:\n");
    topologicalSort(graph);
    printf("\n");

    // Uncomment below part to get a ready-made example
    /*struct Graph* graph2 = createGraph(4);
    addEdge(graph2, 0, 1);
    addEdge(graph2, 0, 2);
    addEdge(graph2, 1, 2);
    addEdge(graph2, 2, 3);
    printf("One topological sort is:\n");
    topologicalSort(graph2);
    printf("\n");*/
    return 0;
}

void topologicalSortHelper(int vertex, struct Graph *graph, struct Stack *stack)
{
    graph->visited[vertex] = 1;
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;
    // First add all dependents (that is, children) to stack
    while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            topologicalSortHelper(connectedVertex, graph, stack);
        }
        temp = temp->next;
    }
    // and then add itself
    push(stack, vertex);
}

// Recursive topologial sort approach
void topologicalSort(struct Graph *graph)
{
    struct Stack *stack = createStack();
    int i = 0;
    for (i = 0; i < graph->numVertices; i++)
    {
        // Execute topological sort on all elements
        if (graph->visited[i] == 0)
        {
            topologicalSortHelper(i, graph, stack);
        }
    }
    while (stack->top != -1) printf("%d ", pop(stack));
}
// Allocate memory for a node
struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}
// Allocate memory for the entire graph structure
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->adjLists = malloc(vertices * sizeof(struct node *));
    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}
// Creates a unidirectional graph
void addEdge(struct Graph *graph, int src, int dest)
{
    // Add edge from src to dest
    struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;
}
// Utility function to see state of graph at a given time
void printGraph(struct Graph *graph)
{
    int v;
    for (v = 0; v < graph->numVertices; v++)
    {
        struct node *temp = graph->adjLists[v];
        printf("\n Adjacency list of vertex %d\n ", v);
        while (temp)
        {
            printf("%d -> ", temp->vertex);
            temp = temp->next;
        }
        printf("\n");
    }
}
// Creates a stack
struct Stack *createStack()
{
    struct Stack *stack = malloc(sizeof(struct Stack));
    stack->top = -1;
    return stack;
}
// Pushes element into stack
void push(struct Stack *stack, int element)
{
    stack->arr[++stack->top] =
        element;  // Increment then add, as we start from -1
}
// Removes element from stack, or returns INT_MIN if stack empty
int pop(struct Stack *stack)
{
    if (stack->top == -1)
        return INT_MIN;
    else
        return stack->arr[stack->top--];
}
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 40  // Assume 40 nodes at max in graph
#define INT_MIN 0
// A vertex of the graph
struct node
{
    int vertex;
    struct node *next;
};
// Some declarations
struct node *createNode(int v);
struct Graph
{
    int numVertices;
    int *visited;
    struct node *
        *adjLists;  // we need int** to store a two dimensional array. Similary,
                    // we need struct node** to store an array of Linked lists
};
// Structure to create a stack, necessary for topological sorting
struct Stack
{
    int arr[MAX_SIZE];
    int top;
};
struct Graph *createGraph(int);
void addEdge(struct Graph *, int, int);
void printGraph(struct Graph *);
struct Graph *transpose(struct Graph *);
void fillOrder(int, struct Graph *, struct Stack *);
void scc(struct Graph *);
void dfs(struct Graph *, int);
struct Stack *createStack();
void push(struct Stack *, int);
int pop(struct Stack *);

int main()
{
    int vertices, edges, i, src, dst;
    printf("Enter the number of vertices\n");
    scanf("%d", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf("Enter the number of edges\n");
    scanf("%d", &edges);
    for (i = 0; i < edges; i++)
    {
        printf("Edge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        addEdge(graph, src, dst);
    }
    printf("The strongly connected conponents are:\n");
    scc(graph);
    printf("\n");

    // Uncomment below part to get a ready-made example
    /*struct Graph* graph2 = createGraph(4);
    addEdge(graph2, 0, 1);
    addEdge(graph2, 1, 2);
    addEdge(graph2, 2, 0);
    addEdge(graph2, 2, 3);
    printf("The strongly connected components are:\n");
    scc(graph2);
    printf("\n");*/
    return 0;
}
// Creates a topological sorting of the graph
void fillOrder(int vertex, struct Graph *graph, struct Stack *stack)
{
    graph->visited[vertex] = 1;
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;
    // First add all dependents (that is, children) to stack
    while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            fillOrder(connectedVertex, graph, stack);
        }
        temp = temp->next;
    }
    // and then add itself
    push(stack, vertex);
}
// Transpose the adjacency list
struct Graph *transpose(struct Graph *g)
{
    struct Graph *graph =
        createGraph(g->numVertices);  // Number of vertices is same
    int i = 0;
    for (i = 0; i < g->numVertices; i++)
    {
        struct node *temp = g->adjLists[i];
        while (temp != NULL)
        {
            addEdge(graph, temp->vertex, i);  // Reverse all edges
            temp = temp->next;
        }
    }
    return graph;
}
// Recursive dfs aproach
void dfs(struct Graph *graph, int vertex)
{
    struct node *adjList = graph->adjLists[vertex];
    struct node *temp = adjList;

    // Add vertex to visited list and print it
    graph->visited[vertex] = 1;
    printf("%d ", vertex);

    // Recursively call the dfs function on all unvisited neighbours
    while (temp != NULL)
    {
        int connectedVertex = temp->vertex;
        if (graph->visited[connectedVertex] == 0)
        {
            dfs(graph, connectedVertex);
        }
        temp = temp->next;
    }
}

// Strongly connected components
void scc(struct Graph *graph)
{
    // Step I: Create a topological sort of the graph and store it in a stack
    struct Stack *stack = createStack();
    int i = 0;
    for (i = 0; i < graph->numVertices; i++)
    {
        // Execute topological sort on all elements
        if (graph->visited[i] == 0)
        {
            fillOrder(i, graph, stack);
        }
    }
    // Step 2: Get the transpose graph
    struct Graph *graphT = transpose(graph);
    // Step 3: Perform a simple dfs by popping nodes from stack
    while (stack->top != -1)
    {
        int v = pop(stack);
        if (graphT->visited[v] == 0)
        {
            dfs(graphT, v);
            printf("\n");
        }
    }
}

// Allocate memory for a node
struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}
// Allocate memory for the entire graph structure
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->adjLists = malloc(vertices * sizeof(struct node *));
    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}
// Creates a unidirectional graph
void addEdge(struct Graph *graph, int src, int dest)
{
    // Add edge from src to dest
    struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;
}
// Utility function to see state of graph at a given time
void printGraph(struct Graph *graph)
{
    int v;
    for (v = 0; v < graph->numVertices; v++)
    {
        struct node *temp = graph->adjLists[v];
        printf("\n Adjacency list of vertex %d\n ", v);
        while (temp)
        {
            printf("%d -> ", temp->vertex);
            temp = temp->next;
        }
        printf("\n");
    }
}
// Creates a stack
struct Stack *createStack()
{
    struct Stack *stack = malloc(sizeof(struct Stack));
    stack->top = -1;
    return stack;
}
// Pushes element into stack
void push(struct Stack *stack, int element)
{
    stack->arr[++stack->top] =
        element;  // Increment then add, as we start from -1
}
// Removes element from stack, or returns INT_MIN if stack empty
int pop(struct Stack *stack)
{
    if (stack->top == -1)
        return INT_MIN;
    else
        return stack->arr[stack->top--];
}
// Queue ADT header file ... COMP2521

typedef struct QueueRep *queue;

queue newQueue();               // set up empty queue
void dropQueue(queue);          // remove unwanted queue
int QueueIsEmpty(queue);        // check whether queue is empty
void QueueEnqueue(queue, int);  // insert an int at end of queue
int QueueDequeue(queue);        // remove int from front of queue

// By
//  .----------------.  .----------------.  .----------------.
//  .-----------------.  .----------------.  .----------------.
// | .--------------. || .--------------. || .--------------. ||
// .--------------. | | .--------------. || .--------------. | | |  _________ |
// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____
// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \
// | || ||_   \|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |
// \_|  | || |  | |    | |  | || |    / /\ \    | || |  |   \ | |   | | | |   |
// |__| |   | || |  /  .--.  \  | | | |     | |      | || |  | '    ' |  | || |
// / ____ \   | || |  | |\ \| |   | | | |   |  __  |   | || |  | |    | |  | |
// | |    _| |_     | || |   \ `--' /   | || | _/ /    \ \_ | || | _| |_\   |_
// | | | |  _| |  | |_  | || |  \  `--'  /  | | | |   |_____|    | || | `.__.'
// | || ||____|  |____|| || ||_____|\____| | | | | |____||____| | || | `.____.'
// | | | |              | || |              | || |              | || | | | | |
// | || |              | | | '--------------' || '--------------' ||
// '--------------' || '--------------' | | '--------------' || '--------------'
// |
//  '----------------'  '----------------'  '----------------'
//  '----------------'   '----------------'  '----------------'

//  Email :    z5261243@unsw.edu.au
//             hhoanhtuann@gmail.com
#include <stdio.h>
#include <stdlib.h>
#define SIZE 40
// Assume max size of graph is 40 nodes
struct queue
{
    int items[SIZE];
    int front;
    int rear;
};

// Some declarations
struct queue *createQueue();
void enqueue(struct queue *q, int);
int dequeue(struct queue *q);
void display(struct queue *q);
int isEmpty(struct queue *q);
int pollQueue(struct queue *q);

// Structure to create a graph node
struct node
{
    int vertex;
    struct node *next;
};

struct node *createNode(int);

// Graph data structure
struct Graph
{
    int numVertices;
    struct node **adjLists;
    int *visited;
};
struct Graph *createGraph(int vertices);
void addEdge(struct Graph *graph, int src, int dest);
void printGraph(struct Graph *graph);
void bfs(struct Graph *graph, int startVertex);

int main()
{
    int vertices, edges, source, i, src, dst;
    printf("Enter the number of vertices\n");
    scanf("%d", &vertices);
    struct Graph *graph = createGraph(vertices);
    printf("Enter the number of edges\n");
    scanf("%d", &edges);
    for (i = 0; i < edges; i++)
    {
        printf("Edge %d \nEnter source: ", i + 1);
        scanf("%d", &src);
        printf("Enter destination: ");
        scanf("%d", &dst);
        addEdge(graph, src, dst);
    }
    printf("Enter source of bfs\n");
    scanf("%d", &source);
    bfs(graph, source);

    // Uncomment below part to get a ready-made example
    /*struct Graph* graph = createGraph(6);
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 2);
    addEdge(graph, 1, 4);
    addEdge(graph, 1, 3);
    addEdge(graph, 2, 4);
    addEdge(graph, 3, 4);
    bfs(graph,0);*/

    return 0;
}
void bfs(struct Graph *graph, int startVertex)
{
    struct queue *q = createQueue();

    // Add to visited list and put in queue
    graph->visited[startVertex] = 1;
    enqueue(q, startVertex);
    printf("Breadth first traversal from vertex %d is:\n", startVertex);

    // Iterate while queue not empty
    while (!isEmpty(q))
    {
        printf("%d ", pollQueue(q));
        int currentVertex = dequeue(q);

        struct node *temp = graph->adjLists[currentVertex];
        // Add all unvisited neighbours of current vertex to queue to be printed
        // next
        while (temp)
        {
            int adjVertex = temp->vertex;
            // Only add if neighbour is unvisited
            if (graph->visited[adjVertex] == 0)
            {
                graph->visited[adjVertex] = 1;
                enqueue(q, adjVertex);
            }
            temp = temp->next;
        }
    }
}
// Memory for a graph node
struct node *createNode(int v)
{
    struct node *newNode = malloc(sizeof(struct node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}
// Allocates memory for graph data structure, in adjacency list format
struct Graph *createGraph(int vertices)
{
    struct Graph *graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;

    graph->adjLists = malloc(vertices * sizeof(struct node *));
    graph->visited = malloc(vertices * sizeof(int));

    int i;
    for (i = 0; i < vertices; i++)
    {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }

    return graph;
}
// Adds bidirectional edge to graph
void addEdge(struct Graph *graph, int src, int dest)
{
    // Add edge from src to dest
    struct node *newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    // Add edge from dest to src; comment it out for directed graph
    newNode = createNode(src);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}
// Allocates memory for our queue data structure
struct queue *createQueue()
{
    struct queue *q = malloc(sizeof(struct queue));
    q->front = -1;
    q->rear = -1;
    return q;
}
// Checks for empty queue
int isEmpty(struct queue *q)
{
    if (q->rear == -1)
        return 1;
    else
        return 0;
}
// Inserts item at start of queue
void enqueue(struct queue *q, int value)
{
    if (q->rear == SIZE - 1)
        printf("\nQueue is Full!!");
    else
    {
        if (q->front == -1)
            q->front = 0;
        q->rear++;
        q->items[q->rear] = value;
    }
}
// Returns item at front of queue and removes it from queue
int dequeue(struct queue *q)
{
    int item;
    if (isEmpty(q))
    {
        printf("Queue is empty");
        item = -1;
    }
    else
    {
        item = q->items[q->front];
        q->front++;
        if (q->front > q->rear)
        {
            q->front = q->rear = -1;
        }
    }
    return item;
}

// Returns element at front of queue
int pollQueue(struct queue *q) { return q->items[q->front]; }
/*
    author: Christian Bender

    This is the implementation of the (generic) stack.
    The implementation uses the dynamic memory management and the principle
    of data hiding.
*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "stack.h"

/*
   actual stack data structure
   This pointer will pointing at the actual field (of void * pointers)
   that represents the stack.
 */
void **array;

/* the current capacity of the stack */
int max = 10;

/* counter variable for counting the elements of the stack. */
int counter = 0;

/*
    offset address
    points at the top element of the stack.
*/
int offset = -1;

void initStack()
{
    array = malloc(sizeof(void *) * max);
    assert(array); /* tests whether pointer is assigned to memory. */
}

/*
    grow: increases the stack by 10 elements.
          This utility function isn't part of the public interface
*/
void grow()
{
    max += 10; /* increases the capacity */

    int i;  // for the loop
    void **tmp = malloc(sizeof(void *) * max);

    /* copies the elements from the origin array in the new one. */
    for (i = 0; i < max - 10; i++)
    {
        *(tmp + i) = *(array + i);
    }
    /*free the memory */
    free(array);
    array = tmp;
}

/* push: pushs the argument onto the stack */
void push(void *object)
{
    assert(object); /* tests whether pointer isn't null */

    if (counter < max)
    {
        offset++; /* increases the element-pointer */

        /*
            moves pointer by the offset address
            pushs the object onto stack
         */
        *(array + offset) = object;

        /* increases the inner counter */
        counter++;
    }
    else /* stack is full */
    {
        grow();       /* lets grow stack */
        push(object); /* recursive call */
    }
}

/*
    pop: pops the top element of the stack from the stack.
*/
void *pop()
{
    void *top = *(array + offset);

    /* check pointers */
    assert(top);

    /* if use the pop-function, stack must not empty. */
    assert(!isEmpty());

    /* decreases the offset address for pointing of
        the new top element */
    offset--;

    /* decreases the inner counter */
    counter--;

    return top;
}

/*
    size: gets the number of elements of the stack.
*/
int size() { return counter; }

/*
    isEmpty(): returns 1 if stack is empty otherwise 0.
*/
int isEmpty() { return counter == 0; }

/*
    top: returns the top element from the stack without removing it.
*/
void *top()
{
    /* offset address points to the top element */
    return array[offset];
}
// program for stack using array

#include <stdio.h>

void push();
void pop();
void peek();
void update();

int a[100], top = -1;

int main()
{
    int x;
    while (1)
    {
        printf("\n0.exit");
        printf("\n1.push");
        printf("\n2.pop");
        printf("\n3.peek");
        printf("\n4.update");
        printf("\nenter your choice? ");
        scanf("%d", &x);
        switch (x)
        {
        case 0:
            return 0;
        case 1:
            push();
            break;
        case 2:
            pop();
            break;
        case 3:
            peek();
            break;
        case 4:
            update();
            break;
        default:
            printf("\ninvalid choice");
        }
    }
    return (0);
}

// function for pushing the element
void push()
{
    int n = 0;
    printf("\nenter the value to insert? ");
    scanf("%d", &n);
    top += 1;
    a[top] = n;
}

// function for poping the element out
void pop()
{
    if (top == -1)
    {
        printf("\nstack is empty");
    }
    else
    {
        int item;
        item = a[top];
        top -= 1;
        printf("\npoped item is %d ", item);
    }
}

// function for peeping the element from top of the stack
void peek()
{
    if (top >= 0)
        printf("\n the top element is %d", a[top]);
    else
        printf("\nstack is empty");
}

// function to update the element of stack
void update()
{
    int i, n;
    printf("\nenter the position to update? ");
    scanf("%d", &i);
    printf("\nenter the item to insert? ");
    scanf("%d", &n);
    if (top - i + 1 < 0)
    {
        printf("\nunderflow condition");
    }
    else
    {
        a[top - i + 1] = n;
    }
}/*
    author: Christian Bender

    This header represents the public stack-interface.
    The stack is generic and self growing.
*/

#ifndef __STACK__
#define __STACK__

/*
    initStack: initializes the stack with a capacity of 10 elements.
*/
void initStack();

/*
    push: pushs the argument onto the stack
*/
void push(void *object);

/*
    pop: pops the top element of the stack from the stack.
    assumes: stack not empty.
*/
void *pop();

/*
    size: gets the number of elements of the stack.
*/
int size();

/*
    isEmpty(): returns 1 if stack is empty otherwise 0.
*/
int isEmpty();

/*
    top: returns the top element from the stack without removing it.
*/
void *top();

#endif#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SIZE 100

struct node
{
    char data;
    struct node *link;
};

int c = 0;          // c used as counter to check if stack is empty or not
struct node *head;  // declaring head pointer globally assigned to NULL

void push(char x)  // function for pushing
{
    struct node *p = head, *temp;
    temp = (struct node *)malloc(sizeof(struct node));
    temp->data = x;
    if (head ==
        NULL)  // will be execute only one time i.e, 1st time push is called
    {
        head = temp;
        p = head;
        p->link = NULL;
        c++;
    }
    else
    {
        temp->link = p;
        p = temp;
        head = p;
        c++;
    }
}

char pop(void)  // function for pop
{
    char x;
    struct node *p = head;
    x = p->data;
    head = p->link;
    free(p);
    c--;
    return x;
}

int isBalanced(char *s)
{
    int i = 0;
    char x;
    while (s[i] != '\0')  // loop for covering entire string of brackets
    {
        // printf("\t s[i]=%c\n", s[i]); //DEBUG
        if (s[i] == '{' || s[i] == '(' ||
            s[i] == '[')  // if opening bracket then push
            push(s[i]);
        else
        {
            if (c <= 0)  // i.e, stack is empty as only opening brackets are
                         // added to stack
                return 0;

            x = pop();
            if (x == '{' && s[i] != '}')
                return 0;
            if (x == '[' && s[i] != ']')
                return 0;
            if (x == '(' && s[i] != ')')
                return 0;
        }
        i++;
    }

    // at end if stack is empy which means whole process has been performed
    // correctly so return 1
    return (c == 0) ? 1 : 0;
}

void destroyStack(void)
{
    struct node *p = head;
    if (c > 0)
    {
        while (p->link)
        {
            struct node *tmp = p;
            p = p->link;
            free(tmp);
        }

        c = 0;
    }
}

int main(void)
{
    int t;
    printf("\t\tBalanced parenthesis\n\n");
    printf("\nPlease enter the number of processing rounds? ");
    scanf("%d", &t);
    for (int a0 = 0; a0 < t; a0++)
    {
        char s[SIZE];
        printf("\nPlease enter the expression? ");
        scanf("%s", s);

        if (isBalanced(s))
            printf("\nYES\n");
        else
            printf("\nNO\n");

        /* tidy up stack for new round */
        destroyStack();
    }
    return 0;
}
/**
 * \file
 * \brief [Problem 401](https://projecteuler.net/problem=401) solution -
 * Sum of squares of divisors
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#ifdef _OPENMP
#include <omp.h>
#endif

#define MOD_LIMIT (uint64_t)1e9 /**< modulo limit */
#define MAX_LENGTH 5000         /**< chunk size of array allocation */

/**
 * Check if a number is present in given array
 * \param[in] N number to check
 * \param[in] D array to check
 * \param[in] L length of array
 * \returns 1 if present
 * \returns 0 if absent
 */
char is_in(uint64_t N, uint64_t *D, uint64_t L)
{
    uint64_t i;
    for (i = 0; i < L; i++)
    {
        if (D[i] == N)
        {
            return 1;
        }
    }
    return 0;
}

/**
 * Get all integer divisors of a number
 * \param[in] N number to find divisors for
 * \param[out] D array to store divisors in
 * \returns number of divisors found
 */
uint64_t get_divisors(uint64_t N, uint64_t *D)
{
    uint64_t q, r;
    int64_t i, num = 0;

    if (N == 1)
    {
        D[0] = 1;
        return 1;
    }

    // search till sqrt(N)
    // because after this, the pair of divisors will repeat themselves
    for (i = 1; i * i <= N + 1; i++)
    {
        r = N % i;  // get reminder

        // reminder = 0 if 'i' is a divisor of 'N'
        if (r == 0)
        {
            q = N / i;
            if (!is_in(i, D, num))  // if divisor was already stored
            {
                D[num] = i;
                num++;
            }
            if (!is_in(q, D, num))  // if divisor was already stored
            {
                D[num] = q;
                num++;
            }
        }

        if (num == MAX_LENGTH)
        {  // limit of array reached, allocate more space
            D = (uint64_t *)realloc(D, MAX_LENGTH * sizeof(uint64_t) << 1);
        }
    }
    return num;
}

/**
 * compute sum of squares of all integer factors of a number
 * \param[in] N
 * \returns sum of squares
 */
uint64_t sigma2(uint64_t N)
{
    uint64_t sum = 0, L;
    int64_t i;
    uint64_t *D = (uint64_t *)malloc(MAX_LENGTH * sizeof(uint64_t));

    L = get_divisors(N, D);
    for (i = 1; i < L; i++)
    {
        uint64_t DD = (D[i] * D[i]) % MOD_LIMIT;
        sum += DD;
    }

    free(D);
    return sum % MOD_LIMIT;
}

/**
 * sum of squares of factors of numbers
 * from 1 thru N
 */
uint64_t sigma(uint64_t N)
{
    uint64_t s, sum = 0;
    int64_t i;

#ifdef _OPENMP
// parallelize on threads
#pragma omp parallel for reduction(+ : sum)
#endif
    for (i = 0; i <= N; i++)
    {
        s = sigma2(i);
        sum += s;
    }
    return sum % MOD_LIMIT;
}

/** Main function */
int main(int argc, char **argv)
{
    uint64_t N = 1000;

    if (argc == 2)
    {
        N = strtoll(argv[1], NULL, 10);
    }
    else if (argc > 2)
    {
        fprintf(stderr, "Wrong number of input arguments!\n");
        printf("Usage:\t ./sol1.c [N=1000]");
        return -1;
    }

    clock_t start_time = clock();
    uint64_t result = sigma(N);
    double dtime = clock() - start_time;

    printf("N = %" PRIu64 "\nSum: %" PRIu64 "\n", N, result);
    printf("Time taken: %.4gms\n", dtime * 1e3 / CLOCKS_PER_SEC);

    return 0;
}
/**
 * \file
 * \brief [Problem 5](https://projecteuler.net/problem=5) solution (Fastest).
 * @details Solution is the LCM of all numbers between 1 and 20.
 *
 * \see Slowest: problem_5/sol1.c
 * \see Slower: problem_5/sol2.c
 */
#include <stdio.h>

/** Compute [Greatest Common Divisor
 * (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of two numbers
 * using Euclids algorithm
 * @param a first number
 * @param b second number
 * @return GCD of `a` and `b`
 */
unsigned long gcd(unsigned long a, unsigned long b)
{
    unsigned long r;
    if (a > b)
    {
        unsigned long t = a;
        a = b;
        b = t;
    }
    while ((r = (a % b)))
    {
        a = b;
        b = r;
    }
    return b;
}

/** Compute [Least Common Multiple
 * (LCM)](https://en.wikipedia.org/wiki/Least_common_multiple) of two numbers
 * @param a first number
 * @param b second number
 * @return LCM of `a` and `b`
 */
unsigned long lcm(unsigned long a, unsigned long b)
{
    unsigned long long p = (unsigned long long)a * b;
    return p / gcd(a, b);
}

/** Main function
 * @returns 0 on exit
 */
int main(void)
{
    unsigned long ans = 1;
    unsigned long i;
    for (i = 1; i <= 20; i++)
    {
        ans = lcm(ans, i);
    }
    printf("%lu\n", ans);
    return 0;
}
/**
 * \file
 * \brief [Problem 5](https://projecteuler.net/problem=5) solution - Naive
 * algorithm (Improved over problem_5/sol1.c)
 * @details Little bit improved version of the naive `problem_5/sol1.c`. Since
 * the number has to be divisable by 20, we can start at 20 and go in 20 steps.
 * Also we don't have to check against any number, since most of them are
 * implied by other divisions (i.e. if a number is divisable by 20, it's also
 * divisable by 2, 5, and 10). This all gives a 97% perfomance increase on my
 * machine (9.562 vs 0.257)
 *
 * \see Slower: problem_5/sol1.c
 * \see Faster: problem_5/sol3.c
 */
#include <stdio.h>
#include <stdlib.h>

/**
 * @brief Hack to store divisors between 1 & 20
 */
static unsigned int divisors[] = {
    11, 13, 14, 16, 17, 18, 19, 20,
};

/** Checks if a given number is devisable by every number between 1 and 20
 * @param n number to check
 * @returns 0 if not divisible
 * @returns 1 if divisible
 */
static int check_number(unsigned long long n)
{
    for (size_t i = 0; i < 7; ++i)
    {
        if (n % divisors[i] != 0)
        {
            return 0;
        }
    }

    return 1;
}

/**
 * @brief Main function
 *
 * @return 0 on exit
 */
int main(void)
{
    for (unsigned long long n = 20;; n += 20)
    {
        if (check_number(n))
        {
            printf("Result: %llu\n", n);
            break;
        }
    }
    return 0;
}
/**
 * \file
 * \brief [Problem 5](https://projecteuler.net/problem=5) solution - Naive
 * algorithm (slowest)
 *
 * \see Faster: problem_5/sol2.c
 * \see Fastest: problem_5/sol3.c
 */
#include <stdio.h>
#include <stdlib.h>

/** Pretty naive implementation. Just checks every number if it's devisable by 1
 * through 20
 * @param n number to check
 * @returns 0 if not divisible
 * @returns 1 if divisible
 */
static char check_number(unsigned long long n)
{
    for (unsigned long long i = 1; i <= 20; ++i)
    {
        if (n % i != 0)
        {
            return 0;
        }
    }

    return 1;
}

/**
 * @brief Main function
 *
 * @return 0 on exit
 */
int main(void)
{
    for (unsigned long long n = 1;; ++n)
    {
        if (check_number(n))
        {
            printf("Result: %llu\n", n);
            break;
        }
    }

    return 0;
}
/**
 * \file
 * \brief [Problem 2](https://projecteuler.net/problem=2) solution
 *
 * Problem:
 *
 * Each new term in the Fibonacci sequence is generated by adding the previous
 * two terms. By starting with 1 and 2, the first 10 terms will be:
 * `1,2,3,5,8,13,21,34,55,89,..`
 * By considering the terms in the Fibonacci sequence whose values do not exceed
 * n, find the sum of the even-valued terms. e.g. for n=10, we have {2,8}, sum
 * is 10.
 */
#include <stdio.h>

/** Main function */
int main()
{
    int n = 0;
    int sum = 0;
    int i = 1;
    int j = 2;
    int temp;
    scanf("%d", &n);

    while (j <= n)
    {
        if ((j & 1) == 0)  // can also use(j%2 == 0)
            sum += j;
        temp = i;
        i = j;
        j = temp + i;
    }

    printf("%d\n", sum);
    return 0;
}/**
 * \file
 * \brief [Problem 3](https://projecteuler.net/problem=3) solution
 *
 * Problem:
 *
 * The prime factors of 13195 are 5,7,13 and 29. What is the largest prime
 * factor of a given number N? e.g. for 10, largest prime factor = 5. For 17,
 * largest prime factor = 17.
 */
#include <stdio.h>

/** Main function */
int main()
{
    int n = 0;
    scanf("%d", &n);
    int prime = 1;
    int i = 2;
    while (i * i <= n)
    {
        while (n % i == 0)
        {
            prime = i;
            n /= i;
        }
        i += 1;
    }
    if (n > 1)
        prime = n;
    printf("%d\n", prime);
    return 0;
}/**
 * \file
 * \brief [Problem 3](https://projecteuler.net/problem=3) solution
 *
 * Problem:
 *
 * The prime factors of 13195 are 5,7,13 and 29. What is the largest prime
 * factor of a given number N? e.g. for 10, largest prime factor = 5. For 17,
 * largest prime factor = 17.
 */
#include <math.h>
#include <stdio.h>

/** Check if the given number is prime */
char isprime(int no)
{
    int sq;

    if (no == 2)
    {
        return 1;
    }
    else if (no % 2 == 0)
    {
        return 0;
    }
    sq = ((int)(sqrt(no))) + 1;
    for (int i = 3; i < sq; i += 2)
    {
        if (no % i == 0)
        {
            return 0;
        }
    }
    return 1;
}

/** Main function */
int main()
{
    int maxNumber = 0;
    int n = 0;
    int n1;
    scanf("%d", &n);
    if (isprime(n) == 1)
        printf("%d", n);
    else
    {
        while (n % 2 == 0)
        {
            n = n / 2;
        }
        if (isprime(n) == 1)
        {
            printf("%d\n", n);
        }
        else
        {
            n1 = ((int)(sqrt(n))) + 1;
            for (int i = 3; i < n1; i += 2)
            {
                if (n % i == 0)
                {
                    if (isprime((int)(n / i)) == 1)
                    {
                        maxNumber = n / i;
                        break;
                    }
                    else if (isprime(i) == 1)
                    {
                        maxNumber = i;
                    }
                }
            }
            printf("%d\n", maxNumber);
        }
    }
    return 0;
}/**
 * \file
 * \brief [Problem 4](https://projecteuler.net/problem=4) solution
 */
#include <stdio.h>

/** Check if number is palindromic
 * \param[in] n number to check
 * \returns 1 if palindromic
 * \returns 0 if not palindromic
 */
int is_palindromic(unsigned int n)
{
    unsigned int reversed = 0, t = n;

    while (t > 0)
    {
        reversed = 10 * reversed + (t % 10);
        t /= 10;
    }
    return reversed == n;
}

/** Main function */
int main(void)
{
    unsigned int i, j, max = 0;
    for (i = 100; i <= 999; i++)
    {
        for (j = 100; j <= 999; j++)
        {
            unsigned int p = i * j;
            if (is_palindromic(p) && p > max)
            {
                max = p;
            }
        }
    }
    printf("%u\n", max);
    return 0;
}
/**
 * \file
 * \brief [Problem 19](https://projecteuler.net/problem=19) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>

/**
 * Function to get the number of days in a month.
 * \param month month identified by an integer -\n
 * > 0 = Jan and 11 = December
 * \returns number of days in given month
 * \note For February, adjust for leap year outside the function.
 */
char get_month_days(short month)
{
    if (month == 1) /* February has 28 days. Adjust leap year in the loop */
        return 28;
    else if (month <= 6) /* odd months till July have 30 days - Jan = 0 (even)*/
    {
        if (month & 0x01)
            return 30;
        else
            return 31;
    }

    // else if (month >= 7) /* odd months after July have 31 days*/

    if (month & 0x01)
        return 31;

    return 30;
}

/**
 * @brief Check if input year is a leap year.
 * \param year year to check
 * \return 1 if input year is a leap year
 * \return 0 if input year is not a leap year
 */
char is_leap_year(short year)
{
    if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0)))
        return 1;

    return 0;
}

#ifdef DEBUG
/** Function to convert integer month to string
 * \param day integer identifier of day (0 = Sunday and 7 = Saturday
 * \return pointer to string representation)
 */
const char *day_string(int day)
{
    switch (day)
    {
    case 0:
        return "Sunday";
    case 1:
        return "Monday";
    case 2:
        return "Tuesday";
    case 3:
        return "Wednesday";
    case 4:
        return "Thursday";
    case 5:
        return "Friday";
    case 6:
        return "Saturday";
    default:
        return "Shouldn't see this!";
    }
}
#endif

/** Main function */
int main(int argc, char **argv)
{
    int count_sundays = 0;
    const short start_year = 1901;
    const short end_year = 2000;

    /*
     * Let us identify days i.e., Sunday thru Saturday with integers - 0 thru 6
     * respectively Jan 1 1901 was a Tuesday
     */
    char start_day = 2;

    for (int year = start_year; year <= end_year; year++)
    {
        char is_leap = is_leap_year(year);
        for (char month = 0; month < 12; month++)
        {
            /*
             * These two for-loops count the start of day for the next month.
             * Hence, we have to skip the last December count
             */
            if (year == end_year && month == 11)
                continue;

            int days = get_month_days(month);

            if (is_leap && month == 1) /* for a leap year february, add a day */
                days++;

#ifdef DEBUG
            if (year == end_year)
            {
                printf("Year: %d\t Month: %d\t Days: %d\t First of day: %s\n",
                       year, month, days, day_string(start_day));
            }
#endif

            /* Main Algorithm:
             * every week has 7 days hence, the start of next day would be
             * modulo 7 add to this, the current start date and ensure the
             * result is still modulo 7!
             */
            start_day = ((days % 7) + start_day) % 7;

            /* If start-day is a Sunday, increment counter */
            if (start_day == 0)
                count_sundays++;
        }
    }

    printf(
        "Total number of Sundays that happened on the 1st of a month in the "
        "last century: %d\n",
        count_sundays);

    return 0;
}
/**
 * \file
 * \brief [Problem 26](https://projecteuler.net/problem=26) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#ifdef _OPENMP
#include <omp.h>
#endif

#define MAX_DENO 2000 /**< limit of unit fractions */
#define MAX_LEN \
    (MAX_DENO + 10) /**< length of resulting recurring fraction number */

/** comparison function for use with internal `qsort` algorithm */
int compare(const void *a, const void *b)
{
    return (*(unsigned short *)a - *(unsigned short *)b);
}

/** Main function */
int main(int argc, char *argv[])
{
    unsigned short max_digits = 0, max_idx_number = 0;

    clock_t start_time = clock();
    short deno;
#ifdef _OPENMP
#pragma omp for
#endif
    for (deno = 2; deno < MAX_DENO; deno++)
    {
        unsigned short remainders[MAX_LEN];
        unsigned short rem = 1, *rem_ptr = remainders;
        memset(remainders, (unsigned short)-1,
               MAX_LEN * sizeof(unsigned short));
        // remainders[0] = 1;
        // printf("1/%-4u\t ", deno);
        unsigned short index = 0, num_digits;

        while (rem != 0)
        {
            rem = (rem * 10) % deno;
            if (rem == 0)
            {
                index = 0;
                break;
            }
            rem_ptr = (unsigned short *)bsearch(
                &rem, remainders, MAX_LEN, sizeof(unsigned short), compare);
            // printf("%2d, ", rem);
            // printf("(%14p), ", rem_ptr);
            if (rem_ptr != NULL)
                break;
            remainders[index] = rem;
            rem_ptr = remainders;
            index++;
        }

        num_digits = index - (rem_ptr - remainders);
        // printf("\n\t(%14p, %14p, %4u, %4u)\n", rem_ptr, remainders, index,
        // num_digits);
#ifdef _OPENMP
#pragma omp critical
        {
#endif
            if (num_digits > max_digits)
            {
                max_digits = num_digits;
                max_idx_number = deno;
                // printf("\t (%u, %u)\n ", max_digits, max_idx_number);
            }
#ifdef _OPENMP
        }
#endif
    }
    clock_t end_time = clock();

    printf("Time taken: %.4g ms\n",
           1e3 * (double)(end_time - start_time) / CLOCKS_PER_SEC);
    printf("Maximum digits: %hu\t Denominator: %hu\n", max_digits,
           max_idx_number);

    return 0;
}
/**
 * \file
 * \brief [Problem 21](https://projecteuler.net/problem=21) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * function to return the sum of proper divisors of N
 */
unsigned long sum_of_divisors(unsigned int N)
{
    unsigned long sum = 1 + N; /* 1 and itself are always a divisor */
    /* divisors are symmertically distributed about the square-root */
    for (unsigned int i = 2; i * i < N; i++)
    {
        if ((N % i) != 0)
            /* i is not a divisor of N */
            continue;

        // #ifdef DEBUG
        //         printf("%4d, %4d,", i, N / i);
        // #endif

        sum += i + (N / i);
    }
    // #ifdef DEBUG
    //     printf("\nSum of divisors of %4d: %4d\n", N, sum);
    // #endif
    return sum;
}

/** Main function */
int main(int argc, char **argv)
{
    unsigned long sum = 0;
    unsigned int MAX_N = 500;
    if (argc == 2)
        MAX_N = atoi(argv[1]);

    /*
     * We use an array of flags to check if a number at the index was:
     * not-processed = 0
     * is amicable = 1
     * not amicable = -1
     */
    char *flags = (char *)calloc(MAX_N, sizeof(char));

    clock_t start_time = clock();
    int i;
    /* there are no such numbers till 10. Lets search from there on */
    for (i = 10; i < MAX_N; i++)
    {
        if (flags[i] != 0)
            /* already processed, skip */
            continue;

        unsigned int b = sum_of_divisors(i);
        if (b >= MAX_N)
            flags[i] = -1;
        else if (flags[b] == -1)
            continue;

        unsigned int c = sum_of_divisors(b);
        if (c == i && b != i)
        {
            /* found amicable */
            flags[b] = 1;
            flags[i] = 1;
            sum += b + i;
#ifdef DEBUG
            printf("Amicable: %4d : %4d\n", i, b);
#endif
        }
        else
        {
            flags[i] = -1;
            if (b < MAX_N)
                flags[b] = -1;
        }
    }

    clock_t end_time = clock();

    printf("\nTime taken: %.4g millisecond\n",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    printf("Sum of all numbers = %lu\n", sum);

    free(flags);
    return 0;
}
/**
 * \file
 * \brief [Problem 10](https://projecteuler.net/problem=10) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

/** Main function */
int main(int argc, char *argv[])
{
    long n = 100;
    long long sum = 0;
    char *sieve = NULL;

    if (argc == 2)         /* if command line argument is provided */
        n = atol(argv[1]); /* use that as the upper limit */

    /* allocate memory for the sieve */
    sieve = calloc(n, sizeof(*sieve));
    if (!sieve)
    {
        perror("Unable to allocate memory!");
        return -1;
    }

    /* build sieve of Eratosthenes
        In the array,
        * if i^th cell is '1', then 'i' is composite
        * if i^th cell is '0', then 'i' is prime
    */
    for (long i = 2; i < sqrtl(n); i++)
    {
        /* if i^th element is prime, mark all its multiples
        as composites */
        if (!sieve[i])
        {
            for (long j = i * i; j < n + 1; j += i)
            {
                sieve[j] = 1;
            }
            sum += i;
        }
    }

    for (long i = sqrtl(n) + 1; i < n; i++)
        if (!sieve[i])
            sum += i;

    free(sieve);

    printf("%ld: %lld\n", n, sum);

    return 0;
}
/**
 * \file
 * \brief [Problem 10](https://projecteuler.net/problem=10) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

/** Function to check if a number is prime */
char is_prime(unsigned long n)
{
    for (unsigned long i = 2; i < sqrtl(n) + 1; i++)
        if (n % i == 0)
            return 0;

    return 1;
}

/** Computes sum of prime numbers less than N */
unsigned long long sum_of_primes(unsigned long N)
{
    unsigned long long sum = 2;

    for (long i = 3; i < N; i += 2) /* skip even numbers */
        if (is_prime(i))
            sum += i;

    return sum;
}

/** Main function */
int main(int argc, char *argv[])
{
    unsigned long n = 100;

    if (argc == 2)         /* if command line argument is provided */
        n = atol(argv[1]); /* use that as the upper limit */

    printf("%ld: %llu\n", n, sum_of_primes(n));

    return 0;
}/**
 * \file
 * \brief [Problem 16](https://projecteuler.net/problem=16) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

/** Main function */
int main(int argc, char **argv)
{
    const double tmp = log(10) / log(2); /* required to get number of digits */
    unsigned long MAX_NUM_DIGITS;
    uint8_t *digits =
        NULL; /* array to store individual digits. index 0 = units place */
    int N = 1000, sum = 0;

    if (argc == 2)
        N = atoi(argv[1]);

    MAX_NUM_DIGITS = (N + tmp) / tmp;

    digits = calloc(MAX_NUM_DIGITS, sizeof(uint8_t));
    digits[0] = 1;

    if (!digits)
    {
        perror("Unable to allocate memory!");
        return -1;
    }

    for (int i = 0; i < N; i++)
    {
        int carry = 0;
        for (int j = 0; j < MAX_NUM_DIGITS; j++)
        {
            digits[j] = (digits[j] << 1) + carry; /* digit * 2 + carry */
            // printf("\t value: %d\t", digits[j]);
            if (digits[j] > 9)
            {
                carry = 1;
                digits[j] -= 10;
            }
            else
                carry = 0;
            // printf("carry: %d\t value: %d\n", carry, digits[j]);

            /* accumulate sum for last multiplication */
            if (i == N - 1)
                sum += digits[j];
        }
    }

    printf("2^%d = ", N);
    for (int i = MAX_NUM_DIGITS - 1; i >= 0; i--) putchar(digits[i] + 0x30);
    printf("\n\t Sum: %d\t Num. digits: %lu\n", sum, MAX_NUM_DIGITS);

    free(digits);
    return 0;
}
/**
 * \file
 * \brief [Problem 20](https://projecteuler.net/problem=20) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 *
 * Implementation uses a custom `big_int` structure that can store arbitrarily
 * large integer numbers.
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * store arbitratily large integer values
 * as a linked list of digits.
 */
typedef struct _big_int
{
    char value;                  /**< tens place (single digit) */
    struct _big_int *next_digit; /**< hundreds place */
    struct _big_int *prev_digit; /**< units place */
} big_int;

#ifdef DEBUG
/** print a digit from large integer */
void print_digit(const big_int *my_int)
{
    printf("\tValue : %d\n\tNext : %p\n\tPrev : %p\n", my_int->value,
           my_int->next_digit, my_int->prev_digit);
}
#endif

/**
 * Function that allocates memory to add another
 * digit at the MSB
 */
big_int *add_digit(big_int *digit, char value)
{
    if (digit == NULL)
    {
        digit = (big_int *)malloc(sizeof(big_int));
        if (!digit)
        {
            perror("Unable to allocate memory!");
            return NULL;
        }
        digit->value = value;
        digit->next_digit = NULL;
        digit->prev_digit = NULL;

        return digit;
    }

    if (digit->next_digit)
    {
        digit->next_digit->value = value;
        return digit->next_digit;
    }

    digit->next_digit = (big_int *)malloc(sizeof(big_int));
    if (digit->next_digit == NULL)
    {
        perror("Unable to allocate memory!");
        return NULL;
    }
    digit->next_digit->value = value;
    digit->next_digit->next_digit = NULL;
    digit->next_digit->prev_digit = digit;
    return digit->next_digit;
}

/**
 * Function to remove digits preceeding the
 * current digit.
 */
char remove_digits(big_int *digit, int N)
{
    if (digit == NULL)
        return 0;

    if (digit->next_digit == NULL)
    {
        free(digit);
        digit = NULL;
        return 0;
    }

    if (N > 0)
        return remove_digits(digit->next_digit, N - 1);

    return remove_digits(digit->next_digit, 0);
}

/** Main function */
int main(int argc, char **argv)
{
    unsigned int N = 5;
    big_int *ptr = add_digit(NULL, 1); /* start with 1 */
    const big_int *ptr0 = ptr;         /* save the first location */
    unsigned long sum_digits = 0;
    unsigned long num_digits = 0;

    if (argc == 2)
        N = atoi(argv[1]);

    clock_t start_time = clock();

    for (unsigned int i = 1; i <= N; i++)
    {
        int carry = 0;
#ifdef DEBUG
        printf("%3d: ", i);
#endif
        ptr = (big_int *)ptr0; /* multiply every digit with i */
        while (ptr)
        {
#ifdef DEBUG
            printf("%p\t", ptr);
#endif
            unsigned int tmp = ptr->value * i + carry;
            if (tmp >= 10)
            {
                div_t tmp2 = div(tmp, 10);
                carry = tmp2.quot;
                tmp = tmp2.rem;
            }
            else
                carry = 0;

            if (carry > 0 && ptr->next_digit == NULL)
                add_digit(ptr, 0);

            ptr->value = tmp;

            if (i == N)
                /*
                 * sum digits on the last iteration
                 * this avoid having another loop over all digits
                 */
                sum_digits += tmp;

            if (ptr->next_digit)
                /* more digits available */
                ptr = ptr->next_digit;
            else
                /* no more digits left - reached MSB */
                break;
        }
#ifdef DEBUG
        printf("\n");
#endif
    }

    clock_t end_time = clock();

#ifdef DEBUG
    printf("ptr = %p\n", ptr);
    printf("%d! = ", N);
#endif

    /* Notice that in the loop above, we make sure that at the end of the loop,
     * ptr is pointing to the last digit. Thus we can avoid using another loop.
     */
    // ptr = &my_int;
    // /* move ptr to the MSB digit */
    // while (ptr->next_digit)
    //     ptr = ptr->next_digit;
    do
    {
        putchar(ptr->value + 0x30); /* convert digit to ASCII char */
        ptr = ptr->prev_digit;
        num_digits++;
    } while (ptr); /* after coming to units place, there will be no valid ptr */

    printf("\nTime taken: %.4g millisecond\n",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    printf(
        "Digit Sum = %lu\tNumber of digits = %lu\tStorage space = %.3gkb\t \n",
        sum_digits, num_digits, num_digits * sizeof(big_int) / 1024.0);

    remove_digits((big_int *)ptr0, -1);
    return 0;
}
/**
 * \file
 * \brief [Problem 8](https://projecteuler.net/problem=8) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h> /* for memmove */

/** Main function */
int main(int argc, char *argv[])
{
    int position = 0, num_bad_chars = 0;
    int num_digits = 4;
    char ch;
    unsigned char num, num_prev;
    unsigned char *buffer = NULL;
    long long int prod = 1, max_prod = 0;

    /* if second command-line argument is given,
     * use it as the number of digits to compute
     * successive product for
     */
    if (argc == 2)
        num_digits = atoi(argv[1]);

    /* allocate memory to store past values */
    buffer = calloc(num_digits, sizeof(unsigned char));
    if (!buffer)
    {
        perror("Unable to allocate memory for buffer");
        return -1;
    }

    /* open file to read digits from */
    FILE *fp = fopen("digits.txt", "rt");
    if (!fp)
    {
        perror("Unable to open file");
        free(buffer); /* free allocated memory */
        return -1;
    }

    /* loop through all digits in the file */
    do
    {
        /* get character from file */
        ch = getc(fp);

        /* the ASCII codes of digits is between 0x30 and 0x39.
         * any character not in this range implies an invalid character
         */
        if (ch < 0x30 || ch > 0x39)
        {
            num_bad_chars++; /* this is used to get the bad characters in the
                                sequence of 13 characters */
            continue;
        }
        else if (num_bad_chars > 0)
            num_bad_chars--;

        num = ch - 0x30;      /* convert character digit to number */
        num_prev = buffer[0]; /* previous n^th digit */

        /* left shift the buffer -
         *  using a for loop or a faster memory move
         */
        memmove(buffer, buffer + 1, num_digits - 1);
        /*
        for (int i = 1; i < num_digits; i++)
            buffer[i-1] = buffer[i];
        */

        buffer[num_digits - 1] = num; /* save the latest number in buffer */

        if (num_prev != 0)
        {
            /* since product is accumulated, the new product can be obtained by
             * simply multiplying the new digit and dividing with the oldest
             * digit
             */
            prod /= num_prev; /* divide first to avoid over-flows */
            prod *= num;
        }
        else
        {
            prod = 1;
            for (int i = 0; i < num_digits; i++)
            {
                if (buffer[i] == 0)
                {
                    prod = 0;
                    break; /* break innermost for-loop */
                }
                prod *= buffer[i];
            }
        }

        /* check if a new maxima was found */
        if (prod > max_prod)
        {
            max_prod = prod;
            position = ftell(fp) - num_bad_chars - num_digits - 1;
        }
    } while (!feof(fp)); /* loop till end of file is reached */

    printf("Maximum product: %lld\t Location: %d^th position\n\t", max_prod,
           position);
    fseek(fp, position,
          SEEK_SET); /* move cursor to identified position in file */
    /* loop through all digits */
    for (; num_digits > 0; num_digits--)
    {
        char ch = getc(fp); /* get character */
        /* skip invalid character */
        if (ch < 0x30 || ch > 0x39)
            continue;
        if (num_digits > 1)
            printf("%c x ", ch);
        else
            printf("%c = %lld\n", ch, max_prod);
    }

    fclose(fp);   /* close file */
    free(buffer); /* free allocated memory */

    return 0;
}
/**
 * \file
 * \brief [Problem 8](https://projecteuler.net/problem=8) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>

/** Compute the product of two numbers in a file
 *
 * \param[in] fp pointer to file that is already open
 * \param[in] start_pos line number of the first numer
 * \param[in] num_digits number of digits on the line to multiply
 * \returns expected product
 */
long long int get_product(FILE *fp, long start_pos, int num_digits)
{
    char ch = ' '; /* temporary variable to store character read from file */
    unsigned char num = 0;  /* temporary variable to store digit read */
    long long int prod = 1; /* product accumulator */
    int count =
        0; /* we use this variable to count number of bytes of file read */

    /* accumulate product for num_digits */
    for (int i = 0; i < num_digits; i++, count++)
    {
        /* get character from file */
        ch = getc(fp);

        /* the ASCII codes of digits is between 0x30 and 0x39.
         * any character not in this range implies an invalid character
         */
        if (ch < 0x30 || ch > 0x39)
        {
            if (ch == EOF)
                return 0;
            i--;
            continue;
        }

        num = ch - 0x30; /* convert character digit to number */
        if (num == 0)
        {
            /* If number is zero, we can skip the next 'num_digits'
             * because this '0' will repeat in the next 'num_digit'
             * multiplications. Hence, we also do not update the file position
             */
            /* NOTE: this is not needed but helps get results faster :) */
            return 0;
        }

        prod *= num; /* accumulate product */
    }

    /* set file position to the next starting character + 1 */
    fseek(fp, -count + 1, SEEK_CUR);

    return prod;
}

/** Main function */
int main(int argc, char *argv[])
{
    int position = 0;
    int num_digits = 4;
    long long int prod, max_prod = 0;

    /* if second command-line argument is ge=iven,
     * use it as the number of digits to compute
     * successive product for
     */
    if (argc == 2)
        num_digits = atoi(argv[1]);

    /* open file to read digits from */
    FILE *fp = fopen("digits.txt", "rt");
    if (!fp)
    {
        perror("Unable to open file");
        return -1;
    }

    /* loop through all digits in the file */
    do
    {
        /* get product of 'num_digits' from current position in file */
        prod = get_product(fp, ftell(fp), num_digits);

        if (prod > max_prod)
        {
            max_prod = prod;
            position = ftell(fp) - 1;
        }
    } while (!feof(fp)); /* loop till end of file is reached */

    printf("Maximum product: %lld\t Location: %d^th position\n\t", max_prod,
           position);
    fseek(fp, position,
          SEEK_SET); /* move cursor to identified position in file */
    /* loop through all digits */
    for (; num_digits > 0; num_digits--)
    {
        char ch = getc(fp); /* get character */
        /* skip invalid character */
        if (ch < 0x30 || ch > 0x39)
            continue;
        if (num_digits > 1)
            printf("%c x ", ch);
        else
            printf("%c = %lld\n", ch, max_prod);
    }

    fclose(fp); /* close file */

    return 0;
}
/**
 * \file
 * \brief [Problem 1](https://projecteuler.net/problem=1) solution
 *
 * An Efficient code to print all the sum of all numbers that are multiples of 3
 * & 5 below N.
 */

#include <stdio.h>

/** Main function */
int main()
{
    int t;
    printf("Enter number of times you want to try");
    scanf("%d", &t);
    while (t--)
    {
        unsigned long long N, p = 0, sum = 0;
        printf("Enter the value of N ");

        scanf("%lld", &N);  // Take input of N from user
        for (int i = 0; i < N; i++)
        {
            if (i % 3 == 0 || i % 5 == 0)
            {
                sum = sum + i;
            }
        }
        printf("%lld\n", sum);  // print the sum of all numbers that are
                                // multiples of 3 & 5 below N
    }
    return 0;
}
/**
 * \file
 * \brief [Problem 1](https://projecteuler.net/problem=1) solution.
 * This solution is based on the pattern that the successive numbers in the
 * series follow: 0+3,+2,+1,+3,+1,+2,+3.
 *
 * If we list all the natural numbers below 10 that are multiples of 3 or 5,
 * we get 3,5,6 and 9. The sum of these multiples is 23.
 * Find the sum of all the multiples of 3 or 5 below N.
 */
#include <stdio.h>

/** Main function */
int main()
{
    int n = 0;
    int sum = 0;
    int num = 0;
    scanf("%d", &n);

    while (1)
    {
        num += 3;
        if (num >= n)
            break;
        sum += num;
        num += 2;
        if (num >= n)
            break;
        sum += num;
        num += 1;
        if (num >= n)
            break;
        sum += num;
        num += 3;
        if (num >= n)
            break;
        sum += num;
        num += 1;
        if (num >= n)
            break;
        sum += num;
        num += 2;
        if (num >= n)
            break;
        sum += num;
        num += 3;
        if (num >= n)
            break;
        sum += num;
    }

    printf("%d\n", sum);
    return 0;
}/**
 * \file
 * \brief [Problem 1](https://projecteuler.net/problem=1) solution
 *
 * If we list all the natural numbers below 10 that are multiples of 3 or 5,
 * we get 3,5,6 and 9. The sum of these multiples is 23.
 * Find the sum of all the multiples of 3 or 5 below N.
 *
 * This solution is based on the pattern that the successive numbers in the
 * series follow: 0+3,+2,+1,+3,+1,+2,+3.
 */
#include <stdio.h>

/** Main function */
int main()
{
    int n = 0;
    int sum = 0;
    scanf("%d", &n);

    int terms = (n - 1) / 3;
    sum += ((terms) * (6 + (terms - 1) * 3)) / 2;  // sum of an A.P.
    terms = (n - 1) / 5;
    sum += ((terms) * (10 + (terms - 1) * 5)) / 2;
    terms = (n - 1) / 15;
    sum -= ((terms) * (30 + (terms - 1) * 15)) / 2;

    printf("%d\n", sum);
}/**
 * \file
 * \brief [Problem 1](https://projecteuler.net/problem=1) solution
 * \details
 * An Efficient code to print all the sum of all numbers that are multiples of 3
 * & 5 below N.
 */

#include <stdio.h>

/** Main function */
int main()
{
    int t;
    printf("Enter number of times you want to try");
    scanf("%d", &t);
    while (t--)  // while t > 0, decrement 't' before every iteration
    {
        unsigned long long N, p = 0, sum = 0;
        printf("Enter the value of N ");

        scanf("%lld", &N);  // Take input of N from user
        p = (N - 1) / 3;
        sum = ((3 * p * (p + 1)) / 2);

        p = (N - 1) / 5;
        sum = sum + ((5 * p * (p + 1)) / 2);

        p = (N - 1) / 15;
        sum = sum - ((15 * p * (p + 1)) / 2);
        printf("%lld\n", sum);  // print the sum of all numbers that are
                                // multiples of 3 & 5 below N
    }
    return 0;
}
/**
 * \file
 * \brief [Problem 6](https://projecteuler.net/problem=6) solution
 */
#include <stdio.h>

/** Main function */
int main(void)
{
    unsigned s1 = 0, s2 = 0, i;
    for (i = 1; i <= 100; i++)
    {
        s1 += i * i;
        s2 += i;
    }
    unsigned ans = s2 * s2 - s1;
    printf("%u\n", ans);
    return 0;
}
/**
 * \file
 * \brief [Problem 7](https://projecteuler.net/problem=7) solution.
 * @see Another version: problem_7/sol2.c
 */
#include <stdio.h>
#include <stdlib.h>

/** Main function
 * @return 0 on exit
 */
int main(void)
{
    char *sieve;
    size_t i;
    unsigned count = 0;
    size_t n = 1000000;
    const unsigned target = 10001;

    sieve = (char *)calloc(n, sizeof(char));
    for (i = 2; i < n; i++)
    {
        if (!sieve[i])
        {
            size_t j;
            count++;
            if (count == target)
            {
                printf("%lu\n", i);
                break;
            }
            for (j = i * 2; j < n; j += i)
            {
                sieve[j] = 1;
            }
        }
    }
    free(sieve);
    return 0;
}
/**
 * \file
 * \brief [Problem 7](https://projecteuler.net/problem=7) solution.
 * @see Faster version problem_7/sol.c
 */
#include <stdio.h>

/** Main function
 * @return 0 on exit
 */
int main()
{
    int n;
    scanf("%d", &n);
    int number_of_prime = 0;
    for (int i = 2;; i++)
    {
        int divisors = 0;
        for (int j = 1; j <= i; j++)
        {
            if (i % j == 0)
            {
                divisors++;
            }
        }
        if (divisors == 2)
        {
            number_of_prime++;
            if (number_of_prime == n)
            {
                printf("%d", i);
                break;
            }
        }
    }

    return 0;
}
/**
 * \file
 * \brief [Problem 9](https://projecteuler.net/problem=9) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 *
 Problem Statement:
    A Pythagorean triplet is a set of three natural numbers, \f$a < b < c\f$,
 for which, \f$a^2 + b^2 = c^2\f$. For example, \f$3^2 + 4^2 = 9 + 16 = 25 =
 5^2\f$. There exists exactly one Pythagorean triplet for which \f$a + b + c =
 1000\f$. Find the product abc.


    Given \f$a^2 + b^2 = c^2\f$ and \f$a+b+c = n\f$, we can write:
    \f{eqnarray*}{
        b &=& \frac{n^2 - 2an}{2n - 2a}\\
        c &=& n - a - b
    \f}
 */
#include <stdio.h>
#include <stdlib.h>

/** Main function */
int main(void)
{
    int N = 1000;

    for (int a = 1; a < 300; a++)
    {
        long tmp1 = N * N - 2 * a * N;
        long tmp2 = 2 * (N - a);
        div_t tmp3 = div(tmp1, tmp2);
        int b = tmp3.quot;
        int c = N - a - b;

        if (a * a + b * b == c * c)
        {
            printf("%d x %d x %d = %ld\n", a, b, c, (long int)a * b * c);
            return 0;
        }
    }

    return 0;
}/**
 * \file
 * \brief [Problem 9](https://projecteuler.net/problem=9) solution - A naive
 * implementation
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>

/** Main function */
int main(void)
{
    for (int a = 1; a < 300; a++)
        for (int b = a + 1; b < 400; b++)
            for (int c = b + 1; c < 500; c++)
            {
                if (a * a + b * b == c * c)
                    if (a + b + c == 1000)
                    {
                        printf("%d x %d x %d = %ld\n", a, b, c,
                               (long int)a * b * c);
                        return 0;
                    }
            }

    return 0;
}
/**
 * \file
 * \brief [Problem 22](https://projecteuler.net/problem=22) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#ifdef _OPENMP
#include <omp.h>
#endif

#define MAX_NAMES 6000  /**< Maximum number of names to store */
#define MAX_NAME_LEN 20 /**< Maximum length of each name */

/**
 * Alphabetical sorting using 'shell sort' algorithm
 */
void shell_sort(char data[][MAX_NAME_LEN], int LEN)
{
    const int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};
    const int gap_len = 8;
    int i, j, g;

    for (g = 0; g < gap_len; g++)
    {
        int gap = gaps[g];
        for (i = gap; i < LEN; i++)
        {
            char tmp_buffer[MAX_NAME_LEN];
            strcpy(tmp_buffer, data[i]);

            for (j = i; j >= gap && strcmp(data[j - gap], tmp_buffer) > 0;
                 j -= gap)
                strcpy(data[j], data[j - gap]);
            strcpy(data[j], tmp_buffer);
        }
    }
#ifdef DEBUG
    for (i = 0; i < LEN; i++) printf("%s\t", data[i]);
#endif
}

/**
 * Alphabetical sorting using 'lazy sort' algorithm
 */
void lazy_sort(char data[][MAX_NAME_LEN], int LEN)
{
    int i, j;
    for (i = 0; i < LEN; i++)
    {
        for (j = i + 1; j < LEN; j++)
        {
            if (strcmp(data[i], data[j]) > 0)
            {
                char tmp_buffer[MAX_NAME_LEN];
                strcpy(tmp_buffer, data[i]);
                strcpy(data[i], data[j]);
                strcpy(data[j], tmp_buffer);
            }
        }
    }
#ifdef DEBUG
    for (i = 0; i < LEN; i++) printf("%s\t", data[i]);
#endif
}

/** Main function */
int main(int argc, char **argv)
{
    unsigned long COUNT = 0;
    char *fname = "names.txt";
    char names[MAX_NAMES][MAX_NAME_LEN];
    short method = 0; /* sorting algorithm to use. 0 = lazy, 1 = shell-sort */

    if (argc == 2)
        method = atoi(argv[1]);

    FILE *fp = fopen(fname, "rt");
    if (!fp)
    {
        perror("Unable to open file");
        return -1;
    }

    /*
     * Loops to get total number of rows and columns in the file
     */
    do
    {
        int ret = fscanf(fp, "\"%[^\",]\",", names[COUNT++]);
        if (ret <= 0)
            continue;
        // printf("%s\t", names[COUNT - 1]);
    } while (!feof(fp));
    fclose(fp);

    printf("\nTotal number of names: %lu\n", COUNT);

    if (method == 0)
    {
        clock_t start_time = clock();
        shell_sort(names, COUNT);
        clock_t end_time = clock();
        printf("\nShell sort: %.4g millisecond\n",
               1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    }
    else if (method == 1)
    {
        clock_t start_time = clock();
        lazy_sort(names, COUNT);
        clock_t end_time = clock();
        printf("\nLazy sort: %.4g millisecond\n",
               1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    }

    long sum_score = 0;
    clock_t start_time = clock();
    int i;

#ifdef _OPENMP
#pragma omp parallel for schedule(runtime) reduction(+ : sum_score)
#endif
#ifdef DEBUG
    for (i = 935; i < 940; i++)
#else
    for (i = 0; i < COUNT; i++)
#endif
    {
        long score = 0;
        /* score the alphabets in i^th name */
        for (int j = 0; names[i][j] != '\0'; j++)
            score += names[i][j] - 'A' +
                     1; /* convert ASCII character to integer score */
        sum_score += score * (i + 1);
#ifdef DEBUG
        printf("Name: %s\tScore: %u x %u = %lu\n", names[i], score, i + 1,
               (unsigned long)score * (i + 1));
#endif
    }
    clock_t end_time = clock();
    printf("Scoring time: %.4g millisecond\n",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);

    printf("Total Score = %lu\n", sum_score);

    return 0;
}
/**
 * \file
 * \brief [Problem 25](https://projecteuler.net/problem=25) solution implemented
 * using arbitrarily large numbers represented as arrays
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_DIGITS 1000 /**< maximum number of digits */

/**
 * Function to add arbitraty length decimal integers stored in an array.\n
 * a + b = c = new b
 */
unsigned int add_numbers(unsigned char *a, unsigned char *b, unsigned char *c,
                         int N)
{
    unsigned char carry = 0;
    unsigned int i;

    for (i = 0; i < N; i++)
    {
        // printf("\t%d + %d + %d ", a[i], b[i], carry);
        c[i] = carry + a[i] + b[i];
        if (c[i] > 9) /* check for carry */
        {
            carry = 1;
            c[i] -= 10;
        }
        else
        {
            carry = 0;
        }
        // printf("= %d, %d\n", carry, c[i]);
    }

    while (carry != 0)
    {
        // printf("\t\t...adding new digit\n");
        // printf("\t0 + %d + %d ", b[i], carry);
        c[i] = carry + c[i];
        if (c[i] > 9)
        {
            carry = 1;
            c[i] -= 10;
        }
        else
        {
            carry = 0;
        }
        // printf("= %d, %d\n", carry, c[i]);
        i++;
    }
    return i;
}

/** Print a large number */
int print_number(unsigned char *number, int N)
{
    int start_pos = N - 1;

    /* skip all initial zeros */
    while (number[start_pos] == 0) start_pos--;

    for (int i = start_pos; i >= 0; i--) putchar(number[i] + 0x30);

    return 0;
}

/** Get number of digits in a large number */
unsigned int get_digits(unsigned char *number)
{
    unsigned int digits = MAX_DIGITS;
    while (number[digits] == 0) digits--;
    return digits;
}

/** Main function */
int main(int argc, char *argv[])
{
    unsigned char
        fn[MAX_DIGITS + 1]; /* array to store digits of a large number */
    unsigned char fn1[MAX_DIGITS + 1];
    unsigned char sum[MAX_DIGITS + 1];

    memset(fn, 0, MAX_DIGITS);
    memset(fn1, 0, MAX_DIGITS);
    memset(sum, 0, MAX_DIGITS);

    fn[0] = 1;
    fn1[1] = 1;

    unsigned int index = 1, digit_count = 1;

    clock_t start_time = clock();
    do
    {
        digit_count = add_numbers(fn, fn1, sum, digit_count);
        // digit_count = get_digits(sum);

        // printf("%5u (%u) (%u) ", index, digit_count, get_digits(sum));
        // print_number(sum, digit_count);
        // putchar('\n');

        if (digit_count == MAX_DIGITS)
        {
            break;
        }
        memcpy(fn, fn1, MAX_DIGITS);
        memcpy(fn1, sum, MAX_DIGITS);
        index++;
    } while (digit_count < MAX_DIGITS);
    clock_t end_time = clock();

    printf("Time taken: %.4g ms\n",
           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);
    printf("The nth term for %d digits: %u \n", MAX_DIGITS, index--);
    print_number(sum, digit_count);

    return 0;
}
/**
 * \file
 * \brief [Problem 13](https://projecteuler.net/problem=13) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/** Function to read the number from a file and store it in array.
    \n index 0 of output buffer => units place
    \n index 1 of output buffer => tens place and so on
    i.e., index i => 10^i th place
 */
int get_number(FILE *fp, char *buffer, uint8_t *out_int)
{
    long l = fscanf(fp, "%s\n", buffer);
    if (!l)
    {
        perror("Error reading line.");
        return -1;
    }
    // printf("Number: %s\t length: %ld, %ld\n", buffer, strlen(buffer), l);

    long L = strlen(buffer);

    for (int i = 0; i < L; i++)
    {
        if (buffer[i] < 0x30 || buffer[i] > 0x39)
        {
            perror("found inavlid character in the number!");
            return -1;
        }
        else
        {
            out_int[L - i - 1] = buffer[i] - 0x30;
        }
    }

    return 0;
}

/**
 * Function to add arbitrary length decimal integers stored in an array.
 * a + b = c = new b
 */
int add_numbers(uint8_t *a, uint8_t *b, uint8_t N)
{
    int carry = 0;
    uint8_t *c = b; /* accumulate the result in the array 'b' */

    for (int i = 0; i < N; i++)
    {
        // printf("\t%d + %d + %d ", a[i], b[i], carry);
        c[i] = carry + a[i] + b[i];  // NOLINT // This is a known false-positive
        if (c[i] > 9)                /* check for carry */
        {
            carry = 1;
            c[i] -= 10;
        }
        else
        {
            carry = 0;
        }
        // printf("= %d, %d\n", carry, c[i]);
    }

    for (int i = N; i < N + 10; i++)
    {
        if (carry == 0)
        {
            break;
        }
        // printf("\t0 + %d + %d ", b[i], carry);
        c[i] = carry + c[i];
        if (c[i] > 9)
        {
            carry = 1;
            c[i] -= 10;
        }
        else
        {
            carry = 0;
        }
        // printf("= %d, %d\n", carry, c[i]);
    }
    return 0;
}

/** Function to print a long number */
int print_number(uint8_t *number, uint8_t N, int8_t num_digits_to_print)
{
    uint8_t start_pos = N - 1;
    uint8_t end_pos;

    /* skip all initial zeros */
    while (number[start_pos] == 0) start_pos--;

    /* if end_pos < 0, print all digits */
    if (num_digits_to_print < 0)
    {
        end_pos = 0;
    }
    else if (num_digits_to_print <= start_pos)
    {
        end_pos = start_pos - num_digits_to_print + 1;
    }
    else
    {
        fprintf(stderr, "invalid number of digits argumet!\n");
        return -1;
    }

    for (int i = start_pos; i >= end_pos; i--) putchar(number[i] + 0x30);

    putchar('\n');

    return 0;
}

/** Main function */
int main(void)
{
    /* number of digits of the large number */
    const int N = 10;
    /* number of digits in output number */
    const int N2 = N + 10;

    // const char N = 50, N2 = N+10;          /* length of numbers */
    char *txt_buffer =
        (char *)calloc(N + 5, sizeof(char)); /* temporary buffer */
    uint8_t *number = (uint8_t *)calloc(
        N, sizeof(uint8_t)); /* array to store digits of a large number */
    uint8_t *sum = (uint8_t *)calloc(
        N2, sizeof(uint8_t)); /* array to store the sum of the large
numbers. For safety, we make it twice the length of a number. */

    FILE *fp = fopen("num.txt", "rt"); /* open text file to read */
    if (!fp)
    {
        perror("Unable to open file 'num.txt'.");
        free(txt_buffer);
        free(sum);
        free(number);
        return -1;
    }

    int count = 0;
    get_number(fp, txt_buffer, sum); /* 0 + = first_number = first_number */
    do
    {
        count++;
        if (get_number(fp, txt_buffer, number) != 0)
        {
            break;
        }
        add_numbers(number, sum, N);
    } while (!feof(fp));

    printf("\nSum   : ");
    print_number(sum, N2, -1);

    printf("first 10 digits: \t");
    print_number(sum, N2, 10);

    fclose(fp); /* close file */
    free(txt_buffer);
    free(sum);
    free(number);
    return 0;
}
/**
 * \file
 * \brief [Problem 14](https://projecteuler.net/problem=14) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 *
 * Since the computational values for each iteration step are independent,
 * we can compute them in parallel. However, the maximum values should be
 * updated in synchrony so that we do not get into a "race condition".
 *
 * To compile with supporintg gcc or clang, the flag "-fopenmp" should be
 * passes while with Microsoft C compiler, the flag "/fopenmp" should be
 * used. If you are using the provided CMAKE compilation, it will automatically
 * detect OPENMP and compile with it for you.
 *
 * Automatically detects for OPENMP using the _OPENMP macro.
 */
#include <stdio.h>
#include <stdlib.h>
#ifdef _OPENMP
#include <omp.h>
#endif

/**
 * Computes the length of collatz sequence for a given
 * starting number
 */
long long collatz(long long start_num)
{
    long long length = 1;

    while (start_num != 1) /* loop till we reach 1 */
    {
        if (start_num & 0x01) /* check for odd */
            start_num = 3 * start_num + 1;
        else
            start_num >>= 1; /* simpler divide by 2 */
        length++;
    }

    return length;
}

/** Main function */
int main(int argc, char **argv)
{
    long long max_len = 0, max_len_num = 0;
    long long MAX_NUM = 1000000;

    if (argc ==
        2) /* set commandline argumnet as the maximum iteration number */
    {
        MAX_NUM = atoll(argv[1]);
        printf("Maximum number: %lld\n", MAX_NUM);
    }

    long long i;
#ifdef _OPENMP
#pragma omp parallel for shared(max_len, max_len_num) schedule(guided)
#endif
    for (i = 1; i < MAX_NUM; i++)
    {
        long long L = collatz(i);
        if (L > max_len)
        {
            max_len = L;     /* length of sequence */
            max_len_num = i; /* starting number */
        }

#if defined(_OPENMP) && defined(DEBUG)
        printf("Thread: %2d\t %3lld: \t%5lld\n", omp_get_thread_num(), i, L);
#elif defined(DEBUG)
        printf("%3lld: \t%5lld\n", i, L);
#endif
    }

    printf("Start: %3lld: \tLength: %5lld\n", max_len_num, max_len);

    return 0;
}
/**
 * \file
 * \brief [Problem 15](https://projecteuler.net/problem=15) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

/**
 * At every node, there are 2 possible ways to move -> down or right.
 * Since it is a square grid, there are in all, 2N steps with N down
 * and N right options, without preference for order.
 * Hence, the path can be be traced in N out of 2N number of ways.
 * This is the same as binomial coeeficient.
 */
unsigned long long number_of_paths(int N)
{
    unsigned long long path = 1;
    for (int i = 0; i < N; i++)
    {
        path *= (N << 1) - i;
        path /= i + 1;
    }

    return path;
}

/** Main function */
int main(int argc, char **argv)
{
    int N = 20;

    if (argc == 2)
        N = atoi(argv[1]);

    printf("Number of ways to traverse diagonal of %dx%d grid = %llu\n", N, N,
           number_of_paths(N));

    return 0;
}
/**
 * \file
 * \brief [Problem 12](https://projecteuler.net/problem=12) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

/**
 * Get number of divisors of a given number
 *
 * If \f$x = a \times b\f$, then both \f$a\f$ and \f$b\f$ are divisors of
 * \f$x\f$. Since multiplication is commutative, we only need to search till a
 * maximum of \f$a=b = a^2\f$ i.e., till \f$\sqrt{x}\f$. At every integer till
 * then, there are eaxctly 2 divisors and at \f$a=b\f$, there is only one
 * divisor.
 */
long count_divisors(long long n)
{
    long num_divisors = 0;

    for (long long i = 1; i < sqrtl(n) + 1; i++)
        if (n % i == 0)
            num_divisors += 2;
        else if (i * i == n)
            num_divisors += 1;

    return num_divisors;
}

/** Main function */
int main(int argc, char **argv)
{
    int MAX_DIVISORS = 500;
    long i = 1, num_divisors;
    long long triangle_number = 1;

    if (argc == 2)
        MAX_DIVISORS = atoi(argv[1]);

    while (1)
    {
        i++;
        triangle_number += i;
        num_divisors = count_divisors(triangle_number);
        if (num_divisors > MAX_DIVISORS)
            break;
    }

    printf("First Triangle number with more than %d divisors: %lld\n",
           MAX_DIVISORS, triangle_number);

    return 0;
}
/**
 * \file
 * \brief [Problem 23](https://projecteuler.net/problem=23) solution -
 * optimization using look-up array
 * \author [Krishna Vedala](https://github.com/kvedala)
 *
 * Optimization applied - compute & store abundant numbers once
 * into a look-up array.
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP
#include <omp.h>
#endif

/**
 * This is the global array to be used to store a flag to identify
 * if a particular number is abundant (1) or not (0).
 * Using a whole byte to store a binary info would be redundant.
 * We will use each byte to represent 8 numbers by relying on bits.
 * This saves memory required by 1/8
 */
char *abundant_flags = NULL;

/**
 * \returns -1 if N is deficient
 * \returns 1 if N is abundant
 * \returns 0 if N is perfect
 */
char get_perfect_number(unsigned long N)
{
    unsigned long sum = 1;
    char ret = 0;

    for (unsigned long i = 2; i * i <= N; i++)
    {
        if (N % i == 0)
        {
            sum += i;
            unsigned long tmp = N / i;
            if (tmp != i)
            {
                sum += tmp;
            }
        }
    }

    ret = sum == N ? 0 : (sum > N ? 1 : -1);
#ifdef DEBUG
    printf("%5lu: %5lu : %d\n", N, sum, ret);
#endif
    return ret;
}

/**
 * Is the given number an abundant number (1) or not (0)
 */
char is_abundant(unsigned long N)
{
    // return abundant_flags[N >> 3] & (1 << N % 8) ? 1 : 0;
    return abundant_flags[N >> 3] & (1 << (N & 7))
               ? 1
               : 0; /* optimized modulo operation */
}

/**
 * Find the next abundant number after N and not including N
 */
unsigned long get_next_abundant(unsigned long N)
{
    unsigned long i;
    /* keep checking successive numbers till an abundant number is found */
    for (i = N + 1; !is_abundant(i); ++i)
    {
        ;
    }
    return i;
}

/**
 * check if a given number can be represented as a sum
 * of two abundant numbers.
 * \returns 1 - if yes
 * \returns 0 - if not
 */
char is_sum_of_abundant(unsigned long N)
{
    /* optimized logic:
     * i + j = N   where both i and j should be abundant
     * hence we can simply check for j = N - i as we loop through i
     */
    for (unsigned long i = get_next_abundant(1); i <= (N >> 1);
         i = get_next_abundant(i))
    {
        if (is_abundant(N - i))
        {
#ifdef DEBUG
            printf("\t%4lu + %4lu = %4lu\n", i, N - i, N);
#endif
            return 1;
        }
    }
    return 0;
}

/** Main function */
int main(int argc, char **argv)
{
    long MAX_N = 28123; /* Limit of numbers to check */

    unsigned long sum = 0;
    if (argc == 2)
    {
        MAX_N = strtoul(argv[1], NULL, 10);
    }

    /* byte array to store flags to identify abundant numbers
     * the flags are identified by bits
     */
    abundant_flags = (char *)calloc(MAX_N >> 3, 1);
    if (!abundant_flags)
    {
        perror("Unable to allocate memoey!");
        return -1;
    }

#ifdef _OPENMP
    printf("Using OpenMP parallleization with %d threads\n",
           omp_get_max_threads());
#else
    printf("Not using parallleization!\n");
#endif

    clock_t start_time = clock();

    /* Loop to set abundant flags */
    long N;
#ifdef _OPENMP
#pragma omp for schedule(runtime)
#endif
    for (N = 1; N <= MAX_N; N++)
    {
        char ret = get_perfect_number(N);
        if (ret == 1)
        {
            // int byte_offset = N % 8, index = N >> 3;
            int byte_offset = N & 7, index = N >> 3;
#ifdef _OPENMP
#pragma omp critical
#endif
            abundant_flags[index] |= ret << byte_offset;
        }
        // if (i % 100 == 0)
        //     printf("... %5lu: %8lu\r", i, sum);
    }

    clock_t end_time = clock();
    double t1 = 1e3 * (end_time - start_time) / CLOCKS_PER_SEC;
    printf("Time taken to get abundant numbers: %.4g ms\n", t1);

    clock_t t2 = 0;
    long i;
#ifdef _OPENMP
#pragma omp parallel for schedule(runtime) reduction(+ : sum)
#endif
    for (i = 1; i < MAX_N; i++)
    {
        clock_t start_time1 = clock();
        if (!is_sum_of_abundant(i))
        {
            // #ifdef _OPENMP
            // #pragma omp critical
            // #endif
            sum += i;
        }
        clock_t end_time1 = clock();
#ifdef _OPENMP
#pragma omp critical
#endif
        t2 += end_time1 - start_time1;

        printf("... %5lu: %8lu\r", i, sum);
        if (i % 100 == 0)
        {
            fflush(stdout);
        }
    }

#ifdef DEBUG
    putchar('\n');
#endif
    double t22 = 1e3 * t2 / CLOCKS_PER_SEC;
    printf("Time taken for final sum: %.4g ms\nTotal Time taken: %.4g ms\n",
           t22, t1 + t22);
    printf("Memory used: %lu bytes\n", MAX_N >> 3);
    printf(
        "Sum of numbers that cannot be represented as sum of two abundant "
        "numbers : %lu\n",
        sum);

    free(abundant_flags);

    return 0;
}
/**
 * \file
 * \brief [Problem 23](https://projecteuler.net/problem=23) solution
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP
#include <omp.h>
#endif

/**
 * Returns:
 * -1 if N is deficient
 *  1 if N is abundant
 *  0 if N is perfect
 */
char get_perfect_number(unsigned long N)
{
    unsigned long sum = 1;
    char ret = 0;

    for (unsigned long i = 2; i * i <= N; i++)
    {
        if (N % i == 0)
        {
            sum += i;
            unsigned long tmp = N / i;
            if (tmp != i)
            {
                sum += tmp;
            }
        }
    }

    ret = sum == N ? 0 : (sum > N ? 1 : -1);
    // #ifdef DEBUG
    //     printf("%5lu: %5lu : %d\n", N, sum, ret);
    // #endif
    return ret;
}

/**
 * Is the given number an abundant number (1) or not (0)
 */
unsigned long is_abundant(unsigned long N)
{
    return get_perfect_number(N) == 1 ? 1 : 0;
}

/**
 * Find the next abundant number after N and not including N
 */
unsigned long get_next_abundant(unsigned long N)
{
    unsigned long i;
    for (i = N + 1; !is_abundant(i); i++)
    {
        ;
    }
    return i;
}

/**
 * check if a given number can be represented as a sum
 * of two abundant numbers.
 * \returns 1 - if yes
 * \returns 0 - if not
 */
char is_sum_of_abundant(unsigned long N)
{
    /* optimized logic:
     * i + j = N   where both i and j should be abundant
     * hence we can simply check for j = N - i as we loop through i
     */
    for (unsigned long i = get_next_abundant(1); i <= (N >> 1);
         i = get_next_abundant(i))
    {
        if (is_abundant(N - i))
        {
#ifdef DEBUG
            printf("\t%4lu + %4lu = %4lu\n", i, N - i, N);
#endif
            return 1;
        }
    }
    return 0;
}

/** Main function */
int main(int argc, char **argv)
{
    unsigned long MAX_N = 28123; /* upper limit of numbers to check */

    unsigned long sum = 0;
    if (argc == 2)
    {
        MAX_N = strtoul(argv[1], NULL, 10);
    }

#ifdef _OPENMP
    printf("Using OpenMP parallleization with %d threads\n",
           omp_get_max_threads());
#else
    printf("Not using parallleization!\n");
#endif

    double total_duration = 0.f;
    long i;
#ifdef _OPENMP
#pragma omp parallel for reduction(+ : sum) schedule(runtime)
#endif
    for (i = 1; i <= MAX_N; i++)
    {
        clock_t start_time = clock();
        if (!is_sum_of_abundant(i))
        {
            sum += i;
        }
        clock_t end_time = clock();
        total_duration += (double)(end_time - start_time) / CLOCKS_PER_SEC;

        printf("... %5lu: %8lu\r", i, sum);
        if (i % 100 == 0)
        {
            fflush(stdout);
        }
    }

    printf("Time taken: %.4g s\n", total_duration);
    printf(
        "Sum of numbers that cannot be represented as sum of two abundant "
        "numbers : %lu\n",
        sum);

    return 0;
}
/**
 * @addtogroup hash Hash algorithms
 * @{
 * @file hash_djb2.c
 * @author [Christian Bender](https://github.com/christianbender)
 * @brief [DJB2 hash algorithm](http://www.cse.yorku.ca/~oz/hash.html)
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>

/**
 * @brief DJB2 algorithm implementation
 *
 * @param s NULL terminated string to hash
 * @return 64-bit hash result
 */
uint64_t djb2(const char* s)
{
    uint64_t hash = 5381; /* init value */
    size_t i = 0;
    while (s[i] != '\0')
    {
        hash = ((hash << 5) + hash) + s[i];
        i++;
    }
    return hash;
}

/**
 * Test function for ::djb2
 * \returns none
 */
void test_djb2(void)
{
    assert(djb2("Hello World") == 13827776004929097857);
    assert(djb2("Hello World!") == 13594750393630990530);
    assert(djb2("Hello world") == 13827776004967047329);
    assert(djb2("Hello world!") == 13594750394883323106);
    printf("Tests passed\n");
}

/** @} */

/** Main function */
int main()
{
    test_djb2();
    return 0;
}
/**
 * @addtogroup hash Hash algorithms
 * @{
 * @file hash_xor8.c
 * @author [Christian Bender](https://github.com/christianbender)
 * @brief 8-bit [XOR hash](https://en.wikipedia.org/wiki/XOR_cipher) algorithm
 * for ASCII characters
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>

/**
 * @brief 8-bit XOR algorithm implementation
 *
 * @param s NULL terminated ASCII string to hash
 * @return 8-bit hash result
 */
uint8_t xor8(const char* s)
{
    uint8_t hash = 0;
    size_t i = 0;
    while (s[i] != '\0')
    {
        hash = (hash + s[i]) & 0xff;
        i++;
    }
    return (((hash ^ 0xff) + 1) & 0xff);
}

/**
 * @brief Test function for ::xor8
 * \returns None
 */
void test_xor8()
{
    assert(xor8("Hello World") == 228);
    assert(xor8("Hello World!") == 195);
    assert(xor8("Hello world") == 196);
    assert(xor8("Hello world!") == 163);
    printf("Tests passed\n");
}

/** @} */

/** Main function */
int main()
{
    test_xor8();
    return 0;
}
/**
 * @addtogroup hash Hash algorithms
 * @{
 * @file hash_adler32.c
 * @author [Christian Bender](https://github.com/christianbender)
 * @brief 32-bit [Adler hash](https://en.wikipedia.org/wiki/Adler-32) algorithm
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>

/**
 * @brief 32-bit Adler algorithm implementation
 *
 * @param s NULL terminated ASCII string to hash
 * @return 32-bit hash result
 */
uint32_t adler32(const char* s)
{
    uint32_t a = 1;
    uint32_t b = 0;
    const uint32_t MODADLER = 65521;

    size_t i = 0;
    while (s[i] != '\0')
    {
        a = (a + s[i]) % MODADLER;
        b = (b + a) % MODADLER;
        i++;
    }
    return (b << 16) | a;
}

/**
 * @brief Test function for ::adler32
 * \returns None
 */
void test_adler32()
{
    assert(adler32("Hello World") == 403375133);
    assert(adler32("Hello World!") == 474547262);
    assert(adler32("Hello world") == 413860925);
    assert(adler32("Hello world!") == 487130206);
    printf("Tests passed\n");
}

/** @} */

/** Main function */
int main()
{
    test_adler32();
    return 0;
}
/**
 * @addtogroup hash Hash algorithms
 * @{
 * @file hash_sdbm.c
 * @author [Christian Bender](https://github.com/christianbender)
 * @brief [SDBM hash algorithm](http://www.cse.yorku.ca/~oz/hash.html)
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>

/**
 * @brief SDBM algorithm implementation
 *
 * @param s NULL terminated string to hash
 * @return 64-bit hash result
 */
uint64_t sdbm(const char* s)
{
    uint64_t hash = 0;
    size_t i = 0;
    while (s[i] != '\0')
    {
        hash = s[i] + (hash << 6) + (hash << 16) - hash;
        i++;
    }
    return hash;
}

/**
 * @brief Test function for ::sdbm
 * \returns None
 */
void test_sdbm()
{
    assert(sdbm("Hello World") == 12881824461405877380U);
    assert(sdbm("Hello World!") == 7903571203300273309);
    assert(sdbm("Hello world") == 15154913742888948900U);
    assert(sdbm("Hello world!") == 15254999417003201661U);
    printf("Tests passed\n");
}

/** @} */

/** Main function */
int main()
{
    test_sdbm();
    return 0;
}
/**
 * @addtogroup hash Hash algorithms
 * @{
 * @file hash_crc32.c
 * @author [Christian Bender](https://github.com/christianbender)
 * @brief 32-bit [CRC
 * hash](https://en.wikipedia.org/wiki/Cyclic_redundancy_check#CRC-32_algorithm)
 * algorithm
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>

/**
 * @brief 32-bit CRC algorithm implementation
 *
 * @param s NULL terminated ASCII string to hash
 * @return 32-bit hash result
 */
uint32_t crc32(const char* s)
{
    uint32_t crc = 0xffffffff;
    size_t i = 0;
    while (s[i] != '\0')
    {
        uint8_t byte = s[i];
        crc = crc ^ byte;
        for (uint8_t j = 8; j > 0; --j)
        {
            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));
        }

        i++;
    }
    return crc ^ 0xffffffff;
}

/**
 * @brief Test function for ::crc32
 * \returns None
 */
void test_crc32()
{
    assert(crc32("Hello World") == 1243066710);
    assert(crc32("Hello World!") == 472456355);
    assert(crc32("Hello world") == 2346098258);
    assert(crc32("Hello world!") == 461707669);
    printf("Tests passed\n");
}

/** @} */

/** Main function */
int main()
{
    test_crc32();
    return 0;
}
/**
 * Modified 07/12/2017, Kyler Smith
 *
 */

#include <stdio.h>

int main()
{
    int remainder, number = 0, decimal_number = 0, temp = 1;
    printf("\n Enter any binary number= ");
    scanf("%d", &number);

    // Iterate over the number until the end.
    while (number > 0)
    {
        remainder = number % 10;
        number = number / 10;
        decimal_number += remainder * temp;
        temp = temp * 2;  // used as power of 2
    }

    printf("%d\n", decimal_number);
}
/**
 * @file
 * @brief [Infix to Postfix converter](https://www.includehelp.com/c/infix-to-postfix-conversion-using-stack-with-c-program.aspx) implementation
 * @details
 * The input infix expression is of type string upto 24 characters.
 * Supported operations- '+', '-', '/', '*', '%'
 * @author [Kumar Yash](https://github.com/kumaryash18)
 * @see infix_to_postfix.c
 */
 
#include <stdio.h>	/// for IO operations
#include <string.h>	/// for strlen(), strcmp()
#include <ctype.h>	/// for isalnum()
#include <stdlib.h>	/// for exit()
#include <stdint.h>	/// for uint16_t, int16_t
#include <assert.h>	/// for assert

/**
 * @brief array implementation of stack using structure
 */
struct Stack {
	char stack[10];		///< array stack
	int top;		///< stores index of the top element
};
struct Stack st;		///< global declaration of stack st

/**
 * @brief Function to push on the stack
 * @param opd character to be pushed in the stack
 * @returns void
 */
void push(char opd) {
	if(st.top == 9)	{		// overflow condition
		printf("Stack overflow...");
		exit(1);
	}
	st.top++;
	st.stack[st.top] = opd;
}

/**
 * @brief Function to pop from the stack
 * @returns popped character
 */
char pop() {
	char item;				///< to store the popped value to be returned
	if(st.top == -1) {		// underflow condition
		printf("Stack underflow...");
		exit(1);
	}
	item = st.stack[st.top];
	st.top--;
	return item;
}

/**
 * @brief Function to check whether the stack is empty or not
 * @returns 1 if the stack IS empty
 * @returns 0 if the stack is NOT empty
 */
uint16_t isEmpty() {
	if(st.top == -1) {
		return 1;
	}
	return 0;
}

/**
 * @brief Function to get top of the stack
 * @returns top of stack
 */
char Top() {
	return st.stack[st.top];
}

/**
 * @brief Function to check priority of operators
 * @param opr operator whose priority is to be checked
 * @returns 0 if operator is '+' or '-'
 * @returns 1 if operator is '/' or '*' or '%'
 * @returns -1 otherwise
 */
int16_t priority(char opr) {
	if(opr == '+' || opr == '-') {
		return 0;
	}
	else if(opr == '/' || opr == '*' || opr == '%') {
		return 1;
	}
	else {
		return -1;
	}
}

/**
 * @brief Function to convert infix expression to postfix expression
 * @param inf the input infix expression
 * @returns output postfix expression
 */
char *convert(char inf[]) {
	static char post[25];				///< to store the postfix expression
	int i;								///< loop iterator
	int j = 0;							///< keeps track of end of postfix string
	for(i = 0; i < strlen(inf); i++) {
		if(isalnum(inf[i]))	{			// if scanned element is an alphabet or number
			post[j] = inf[i];			// append in postfix expression
			j++;
		}
		else if(inf[i] == '(') {		// if scanned element is opening parentheses
			push(inf[i]);				// push on stack.
		}
		else if(inf[i] == ')') {		// if scanned element is closing parentheses,
			while(Top() != '(') {		// pop elements from stack and append in postfix expression
				post[j] = pop();		// until opening parentheses becomes top.
				j++;
			}
			pop();						// pop opening parentheses
		}
		else {							// if scanned element is an operator
			while( (!isEmpty()) && (priority(inf[i]) <= priority(Top())) ) {	// pop and append until stack becomes
				post[j] = pop();												// empty or priority of top operator
				j++;															// becomes smaller than scanned operator
			}																	// '(' has priority -1
			push(inf[i]);				// push the scanned operator
		}
	}
	while(!isEmpty()) {					// pop and append residual operators from stack
		post[j] = pop();
		j++;
	}
	post[j] = '\0';						// end postfix string with null character
	return post;
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test() {
    /* check sample test case
	   input- "(A/(B-C)*D+E)"
	   expected output- "ABC-/D*E+"
	 */
	assert(strcmp(convert("(A/(B-C)*D+E)"), "ABC-/D*E+") == 0); 			/// this ensures that the algorithm works as expected
	/* input- "7-(2*3+5)*(8-4/2)"
	   expected output- "723*5+842/-*-"
	 */
	assert(strcmp(convert("7-(2*3+5)*(8-4/2)"), "723*5+842/-*-") == 0); 			/// this ensures that the algorithm works as expected
	printf("All tests have successfully passed!\n");
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main() {
	st.top = -1;			/// initialize
	test();				/// run self-test implementations
	char inf[25];			///< to store input infix expression
	printf("Enter infix: ");
	scanf("%s", inf);
	printf("Postfix: %s", convert(inf));
	return 0;
}
/**
 * @file
 * @brief Convert a positive integer to string (non-standard function)
 * representation.
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/**
 * Converts an integer value to a null-terminated string using the specified
 * base and stores the result in the array given by str parameter.
 * @param value Value to be converted to a string.
 * @param dest pointer to array in memory to store the resulting null-terminated
 * string.
 * @param base Numerical base used to represent the value as a string, between 2
 * and 16, where 10 means decimal base, 16 hexadecimal, 8 octal, and 2 binary.
 * @returns A pointer to the resulting null-terminated string, same as parameter
 * str.
 * @note The destination array must be pre-allocated by the calling function.
 */
char *int_to_string(uint16_t value, char *dest, int base)
{
    const char hex_table[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    int len = 0;
    do
    {
        dest[len++] = hex_table[value % base];
        value /= base;
    } while (value != 0);

    /* reverse characters */
    for (int i = 0, limit = len / 2; i < limit; ++i)
    {
        char t = dest[i];
        dest[i] = dest[len - 1 - i];
        dest[len - 1 - i] = t;
    }
    dest[len] = '\0';
    return dest;
}

/** Test function
 * @returns `void`
 */
static void test()
{
    const int MAX_SIZE = 100;
    char *str1 = (char *)calloc(sizeof(char), MAX_SIZE);
    char *str2 = (char *)calloc(sizeof(char), MAX_SIZE);

    for (int i = 1; i <= 100; ++i) /* test 100 random numbers */
    {
        /* Generate value from 0 to 100 */
        int value = rand() % 100;

        // assert(strcmp(itoa(value, str1, 2), int_to_string(value, str2, 2)) ==
        //        0);
        snprintf(str1, MAX_SIZE, "%o", value);  //* standard C - to octal */
        assert(strcmp(str1, int_to_string(value, str2, 8)) == 0);
        snprintf(str1, MAX_SIZE, "%d", value); /* standard C - to decimal */
        assert(strcmp(str1, int_to_string(value, str2, 10)) == 0);
        snprintf(str1, MAX_SIZE, "%x", value); /* standard C - to hexadecimal */
        assert(strcmp(str1, int_to_string(value, str2, 16)) == 0);
    }

    free(str1);
    free(str2);
}

/** Driver Code */
int main()
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
/*
 * C Program to Convert Binary to Hexadecimal
 */
#include <stdio.h>

int main()
{
    long int binary, hexa = 0, i = 1, remainder;

    printf("Enter the binary number: ");
    scanf("%ld", &binary);
    while (binary != 0)
    {
        remainder = binary % 10;
        hexa = hexa + remainder * i;
        i = i * 2;
        binary = binary / 10;
    }
    printf("The equivalent hexadecimal value: %lX", hexa);
    return 0;
}
/*****Decimal to octal conversion*******************/
#include <stdio.h>
void decimal2Octal(long decimalnum);

int main()
{
    long decimalnum;

    printf("Enter the decimal number: ");
    scanf("%ld", &decimalnum);

    decimal2Octal(decimalnum);

    return 0;
}

/********function for convert decimal numbers to octal numbers************/
void decimal2Octal(long decimalnum)
{
    long remainder, quotient;

    int octalNumber[100], i = 1, j;
    quotient = decimalnum;

    while (quotient != 0)
    {
        octalNumber[i++] = quotient % 8;

        quotient = quotient / 8;
    }

    for (j = i - 1; j > 0; j--) printf("%d", octalNumber[j]);

    printf("\n");
}
// Binary number to octal number conversion
#include <stdio.h>

// Function that returns the last three digits
int three_digits(int n)
{
    int r, d = 0, p = 1;

    for (int i = 0; i < 3; i++)
    {
        r = n % 10;
        d += r * p;
        p *= 10;
        n /= 10;
    }
    return d;
}

int main(void)
{
    int binary_num, d = 0, base = 1, remainder, td, res = 0, ord = 1;

    printf("Enter the binary no: ");
    scanf("%d", &binary_num);

    while (binary_num > 0)
    {
        if (binary_num >
            111)  // Checking if binary number is greater than three digits
            td = three_digits(binary_num);

        else
            td = binary_num;

        binary_num /= 1000;

        d = 0, base = 1;

        // Converting the last three digits to decimal
        while (td > 0)
        {
            remainder = td % 10;
            td /= 10;
            d += (base * remainder);
            base *= 2;
        }

        res += d * ord;  // Calculating the octal value
        ord *= 10;
    }

    printf("\nOctal equivalent is: %d", res);
    return 0;
}
/**
 * @file
 * @brief [Infix to
 * Postfix](https://condor.depaul.edu/ichu/csc415/notes/notes9/Infix.htm)
 * Expression Conversion
 * @details Convert Infixed expressions to Postfix expression.
 * @author [Harsh Karande](https://github.com/harshcut)
 */

// include header files
#include <stdio.h>  /// for printf() and scanf()

/**
 * @brief a globally declared structure with an array and an variable that
 * points to the topmost index of the array
 */
struct Stack
{
    char arr[10];  ///> static array of integers
    int tos;       ///> stores index on topmost element in stack
};

// function headers
void push(struct Stack *p, char ch);  // pust element in stack
char pop(struct Stack *p);            // pop topmost element from the stack
int isOprnd(char ch);                 // check if element is operand or not
int isEmpty(struct Stack s);          // check if stack is empty
int getPrecedence (char op1, char op2);        // check operator precedence
void convert(char infix[],
             char postfix[]);  // convert infix to postfix expression

/**
 * @brief main function
 * @returns 0 on exit
 */
int main()
{
    char infix[20], postfix[20];  // initialize empty infix and postfix array

    printf("Enter infix expression: ");  // example : A+B-C*D/E$F
    scanf("%s", infix);                  // get values for infix array

    convert(infix, postfix);
    printf("Postfix expression is %s", postfix);  // output : AB+CD*EF$/-

    return 0;
}

/**
 * @brief push function
 * @param *p : used as a pointer variable of stack
 * @param x : char to be pushed in stack
 * @returns void
 */
void push(struct Stack *p, char x)
{
    if (p->tos == 9)  // check if stack has reached its max limit
    {
        printf("Stack Overflow!");
        return;
    }

    p->tos += 1;         // increment tos
    p->arr[p->tos] = x;  // assign char x to index of stack pointed by tos
}

/**
 * @brief pop function
 * @param *p : used as a pointer variable of stack
 * @returns x or \0 on exit
 */
char pop(struct Stack *p)
{
    char x;

    if (p->tos == -1)
    {
        printf("Stack Underflow!");
        return '\0';
    }

    x = p->arr[p->tos];  // assign the value of stack at index tos to x
    p->tos -= 1;         // decrement tos

    return x;
}

/**
 * @brief isOprnd function
 * @param ch : this is the element from the infix array
 * @returns 1 or 0 on exit
 */
int isOprnd(char ch)
{
    if ((ch >= 65 && ch <= 90) ||
        (ch >= 97 && ch <= 122) ||  // check if ch is an operator or
        (ch >= 48 && ch <= 57))     // operand using ASCII values
    {
        return 1;  // return for true result
    }
    else
    {
        return 0;  // return for false result
    }
}

/**
 * @brief isEmpty function
 * @param s : it is the object reference of stack
 * @returns 1 or 0 on exit
 */
int isEmpty(struct Stack s)
{
    if (s.tos == -1)  // check if stack is empty
    {
        return 1;  // return for true result
    }
    else
    {
        return 0;  // return for false result
    }
}

/**
 * @brief convert function
 * @param infix[] : infix array provided by user
 * @param postfix[] : empty array to be given to convert()
 * @returns postfixed expresion or \0 on exit
 */
void convert(char infix[], char postfix[])
{
    struct Stack s;  // initialze object reference of stack
    s.tos = -1;      // initalize the tos

    int i, j = 0, pr;
    char ch, temp;

    for (i = 0; infix[i] != '\0'; i++)
    {
        ch = infix[i];

        if (isOprnd(ch) == 1)  // check if char is operand or operator
        {
            postfix[j] = ch;  // assign ch to postfix array with index j
            j++;              // incement j
        }
        else
        {
            if (ch == '(')
            {
                push(&s, ch);
            }
            else
            {
                if (ch == ')')
                {
                    while ((temp = pop(&s)) != '(')
                    {
                        postfix[j] = temp;
                        j++;
                    }
                }
                else
                {
                    while (isEmpty(s) == 0)  // check if stack is empty
                    {
                        pr = getPrecedence (ch,
                                   s.arr[s.tos]);  // check operator precedence

                        if (pr == 1)
                        {
                            break;  // if ch has a greater precedence than
                                    // s.arr[s.top]
                        }

                        postfix[j] = pop(&s);
                        j++;
                    }

                    push(&s, ch);  // push ch to stack
                }
            }
        }
    }

    while (isEmpty(s) == 0)  // check if stack is empty
    {
        postfix[j] = pop(&s);
        j++;
    }

    postfix[j] = '\0';
}

/**
 * @brief getPrecedence function returns the precedence after comparing two operators passed as parameter.
 * @param op1 : first operator
 * @param op2 : second operator
 * @returns 1 or 0 on exit
 */
int getPrecedence (char op1, char op2)
{
    if (op2 == '$')
    {
        return 0;
    }
    else if (op1 == '$')
    {
        return 1;
    }
    else if (op2 == '*' || op2 == '/' || op2 == '%')
    {
        return 0;
    }
    else if (op1 == '*' || op1 == '/' || op1 == '%')
    {
        return 1;
    }
    else if (op2 == '+' || op2 == '-')
    {
        return 0;
    }
    else
    {
        return 1;
    }
}
/**
 * @file
 * @author [jucollet972](https://github.com/jucollet972)
 * @brief [Decimal to any-base](http://codeofthedamned.com/index.php/number-base-conversion) is a C function wich convert positive decimal
 * integer to any positive ascii base with the base's alphabet given in input and return it in a dynamically allocated string(recursive way)
 */

#include <stdio.h>   /// for IO operations
#include <string.h>  /// for strchr and strlen
#include <stdint.h>  /// for CPU arch's optimized int types
#include <stdbool.h> /// for boolean types
#include <assert.h>  /// for assert
#include <stdlib.h>  /// for malloc and free

/**
 * @brief Checking if alphabet is valid
 * @param base alphabet inputed by user
 * @return int64_t as success or not
 */
bool isbad_alphabet(const char* alphabet) {
	uint64_t len = strlen(alphabet);
	
	/* Checking th lenght */	
	if (len < 2) {
		return true;
	}
	/* Browse the alphabet */
	for (int i = 0; i < len ; i++) {
		/* Searching for duplicates */ 
		if (strchr(alphabet + i + 1, alphabet[i]))
			return true;
	}
	return false;
}

/**
 * @brief Calculate the final length of the converted number
 * @param nb to convert
 * @param base calculated from alphabet
 * @return Converted nb string length 
 */
uint64_t converted_len(uint64_t nb, short base) {
	/* Counting the number of characters translated to the base*/
	if (nb > base - 1) {
		return (converted_len(nb/base, base) + 1);
	}
	return 1;
}

/**
 * @brief Convert positive decimal integer into anybase recursively
 * @param nb to convert
 * @param alphabet inputed by user used for base convertion
 * @param base calculated from alphabet
 * @param converted string filled with the convertion's result
 * @return void
 */
void convertion(uint64_t nb, const char* alphabet, short base, char* converted) {
	/* Recursive convertion */
	*(converted) = *(alphabet + nb%base);
	if (nb > base - 1) {
		convertion(nb/base, alphabet, base, --converted);
	}
}

/**
 * @brief decimal_to_anybase ensure the validity of the parameters and convert any unsigned integers into any ascii positive base
 * @param nb to convert
 * @param base's alphabet
 * @returns nb converted on success
 * @returns NULL on error
 */
char* decimal_to_anybase(uint64_t nb, const char* alphabet) {
	char* converted;

	/* Verify that alphabet is valid */
	if (isbad_alphabet(alphabet)) {
		return NULL;
	}
	/* Convertion */
	uint64_t base = strlen(alphabet);
	uint64_t final_len = converted_len(nb, base);
	converted = malloc(sizeof(char) * (final_len + 1));
	converted[final_len] = 0;
	convertion(nb, alphabet, base, converted + final_len - 1);
	return converted;
}


/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
	char* ret = NULL;
	char* reference = NULL;

	/* min dec*/
	reference = "0";
	ret = decimal_to_anybase(0, "0123456789");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* max dec*/
	reference = "18446744073709551615";
	ret = decimal_to_anybase(18446744073709551615, "0123456789");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* negative dec*/
	reference = "18446744073709551615";
	ret = decimal_to_anybase(-1, "0123456789");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}

	/* bin */
	reference = "101010";
	ret = decimal_to_anybase(42, "01");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* octal */
	reference = "52";
	ret = decimal_to_anybase(42, "01234567");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* hexa */
	reference = "2A";
	ret = decimal_to_anybase(42, "0123456789ABCDEF");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	printf("[+] All tests have successfully passed!\n");
}

/**
 * @brief Main function
 * @returns 0 on exit 
 */
int main()
{
	test(); // run self-test implementations
	return 0;
}
/**
 * @file
 * @brief Convert hexadecimal number to octal number (with decimal intermediary)
 * @details
 * The input is valid from 0 to 0xFFFF_FFFF_FFFF_FFFF.
 *
 * At first, this program converts a hex string to an unsigned long long
 * decimal, and then to an octal string.
 *
 * When there is an invalid character in input string, this program stops
 * parsing and converts the string until that character.
 *
 * @see hexadecimal_to_octal.c
 */

#include <stdio.h>  /// for printf() and fgets()
#include <string.h> /// for memset()

/**
 * @brief Convert a hexadecimal number to octal number.
 * @param hex Hexadecimal number to convert.
 * @returns A pointer to the converted octal string.
 */
const char *hex_to_oct(const char *hex)
{
#define MAX_OCT_STR_LEN 23 /* 17_7777_7777_7777_7777_7777 */
    static char octal[MAX_OCT_STR_LEN];
    memset(octal, '\0', MAX_OCT_STR_LEN); // Initialize as NULL string

    unsigned long long decimal = 0;
    int i = 0;
    int len;

    if (hex == NULL)
    {
        // Return an empty string
        return octal;
    }

    /* Hexadecimal to decimal conversion */
    while (*hex != '\n' && *hex != '\0')
    {
        char ch = *hex;

        if (ch >= '0' && ch <= '9')
        {
            ch -= '0';
        }
        else if (ch >= 'a' && ch <= 'f')
        {
            ch = ch - 'a' + 10;
        }
        else if (ch >= 'A' && ch <= 'F')
        {
            ch = ch - 'A' + 10;
        }
        else
        {
            printf("Invalid hexadecimal input: %c\n", ch);
            break;
        }

        decimal *= 16;
        decimal += ch;
        hex++;
    }

    /* Decimal to octal conversion */
    if (decimal == 0)
    {
        octal[0] = '0';
        len = 1;
    }
    else
    {
        i = 0;
        while (decimal > 0)
        {
            octal[i] = '0' + decimal % 8;
            i++;
            decimal /= 8;
        }

        len = i;
    }

    octal[len] = '\0';

    /* Reverse the octal string */
    for (i = 0; i < len / 2; i++)
    {
        char tmp = octal[i];
        octal[i] = octal[len - i - 1];
        octal[len - i - 1] = tmp;
    }

    return octal;
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
#define MAX_HEX_STR_LEN 17 /* FFFF_FFFF_FFFF_FFFF */
    char hex[MAX_HEX_STR_LEN];

    /* Input hexadecimal number from user */
    printf("Enter any hexadecimal number: ");
    fgets(hex, MAX_HEX_STR_LEN, stdin);

    const char *octal = hex_to_oct(hex);

    printf("Hexadecimal number = %s\n", hex);
    printf("Octal number = %s\n", octal);

    return 0;
}
/*
 * convert from any base to decimal
 */

#include <ctype.h>
#include <stdio.h>

int main(void)
{
    int base, i, j;
    char number[100];
    unsigned long decimal = 0;

    printf("Enter the base: ");
    scanf("%d", &base);
    printf("Enter the number: ");
    scanf("%s", &number[0]);

    for (i = 0; number[i] != '\0'; i++)
    {
        if (isdigit(number[i]))
            number[i] -= '0';
        else if (isupper(number[i]))
            number[i] -= 'A' - 10;
        else if (islower(number[i]))
            number[i] -= 'a' - 10;
        else
            number[i] = base + 1;

        if (number[i] >= base)
        {
            printf("invalid number\n");
            return 0;
        }
    }

    for (j = 0; j < i; j++)
    {
        decimal *= base;
        decimal += number[j];
    }

    printf("%lu\n", decimal);
}
/**
 * \file
 * \brief Recoding the original atoi function in stdlib.h
 * \author [Mohammed YMIK](https://github.com/medymik)W
 * The function convert a string passed to an integer
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * the function take a string and return an integer
 * \param[out] str pointer to a char address
 */
int c_atoi(const char *str)
{
    int i;
    int sign;
    long value;
    long prev;

    i = 0;
    sign = 1;
    value = 0;

    /* skipping the spaces */
    while (((str[i] <= 13 && str[i] >= 9) || str[i] == 32) && str[i] != '\0')
        i++;

    /* store the sign if it is negative sign */
    if (str[i] == '-')
	{
        sign = -1;
	i++;
	}
    else if (str[i] == '+')
	{
        sign = 1;
	i++;
	}

    /* converting char by char to a numeric value */
    while (str[i] >= 48 && str[i] <= 57 && str[i] != '\0')
    {
        prev = value;
        value = value * 10 + sign * (str[i] - '0');

        /* managing the overflow */
        if (sign == 1 && prev > value)
            return (-1);
        else if (sign == -1 && prev < value)
            return (0);
        i++;
    }
    return (value);
}

/**
 * test the function implementation
 */
void test_c_atoi()
{
    printf("<<<< TEST FUNCTION >>>>\n");
    assert(c_atoi("123") == atoi("123"));
    assert(c_atoi("-123") == atoi("-123"));
    assert(c_atoi("") == atoi(""));
    assert(c_atoi("-h23") == atoi("-h23"));
    assert(c_atoi("         23") == atoi("         23"));
    assert(c_atoi("999999999") == atoi("999999999"));
    printf("<<<< TEST DONE >>>>\n");
}

/**
 * the main function take one argument of type char*
 * example : ./program 123
 */
int main(int argc, char **argv)
{
    test_c_atoi();

    if (argc == 2)
    {
        printf("Your number + 5 is %d\n", c_atoi(argv[1]) + 5);
        return (0);
    }
    printf("wrong number of parmeters\n");
    return (1);
}
#include <math.h>
#include <stdio.h>

// Converts octal number to decimal
int convertValue(int num, int i) { return num * pow(8, i); }

long long toDecimal(int octal_value)
{
    int decimal_value = 0, i = 0;

    while (octal_value)
    {
        // Extracts right-most digit and then multiplies by 8^i
        decimal_value += convertValue(octal_value % 10, i++);

        // Shift right in base 10
        octal_value /= 10;
    }

    return decimal_value;
}

int main()
{
    printf("Enter octal value: ");

    int octal_value;

    scanf("%d", &octal_value);

    long long result = toDecimal(octal_value);

    printf("%d in decimal is %lld\n", octal_value, result);

    return 0;
}
/* C program to convert Hexadecimal to Octal number system */

#include <stdio.h>

int main()
{
#define MAX_STR_LEN 17
    char hex[MAX_STR_LEN];
    long long octal, bin, place;
    int i = 0, rem, val;

    /* Input hexadecimal number from user */
    printf("Enter any hexadecimal number: ");
    fgets(hex, MAX_STR_LEN, stdin);

    octal = 0ll;
    bin = 0ll;
    place = 0ll;

    /* Hexadecimal to binary conversion */
    for (i = 0; hex[i] != '\0'; i++)
    {
        bin = bin * place;

        switch (hex[i])
        {
        case '0':
            bin += 0;
            break;
        case '1':
            bin += 1;
            break;
        case '2':
            bin += 10;
            break;
        case '3':
            bin += 11;
            break;
        case '4':
            bin += 100;
            break;
        case '5':
            bin += 101;
            break;
        case '6':
            bin += 110;
            break;
        case '7':
            bin += 111;
            break;
        case '8':
            bin += 1000;
            break;
        case '9':
            bin += 1001;
            break;
        case 'a':
        case 'A':
            bin += 1010;
            break;
        case 'b':
        case 'B':
            bin += 1011;
            break;
        case 'c':
        case 'C':
            bin += 1100;
            break;
        case 'd':
        case 'D':
            bin += 1101;
            break;
        case 'e':
        case 'E':
            bin += 1110;
            break;
        case 'f':
        case 'F':
            bin += 1111;
            break;
        default:
            printf("Invalid hexadecimal input.");
        }

        place = 10000;
    }

    place = 1;

    /* Binary to octal conversion */
    while (bin > 0)
    {
        rem = bin % 1000;

        switch (rem)
        {
        case 0:
            val = 0;
            break;
        case 1:
            val = 1;
            break;
        case 10:
            val = 2;
            break;
        case 11:
            val = 3;
            break;
        case 100:
            val = 4;
            break;
        case 101:
            val = 5;
            break;
        case 110:
            val = 6;
            break;
        case 111:
            val = 7;
            break;
        }

        octal = (val * place) + octal;
        bin /= 1000;

        place *= 10;
    }

    printf("Hexadecimal number = %s\n", hex);
    printf("Octal number = %lld", octal);

    return 0;
}
/*****Decimal to Hexadecimal conversion*******************/
#include <stdio.h>
void decimal2Hexadecimal(long num);

int main()
{
    long decimalnum;

    printf("Enter decimal number: ");
    scanf("%ld", &decimalnum);

    decimal2Hexadecimal(decimalnum);

    return 0;
}

/********function for convert decimal number to hexadecimal
 * number****************/
void decimal2Hexadecimal(long num)
{
    long decimalnum = num;
    long quotient, remainder;
    int i, j = 0;
    char hexadecimalnum[100];

    quotient = decimalnum;

    while (quotient != 0)
    {
        remainder = quotient % 16;
        if (remainder < 10)
            hexadecimalnum[j++] = 48 + remainder;

        else
            hexadecimalnum[j++] = 55 + remainder;

        quotient = quotient / 16;
    }

    // print the hexadecimal number

    for (i = j; i >= 0; i--)
    {
        printf("%c", hexadecimalnum[i]);
    }

    printf("\n");
}
#include <stdio.h>
#include <stdlib.h>

#define MAXBITS 100

int main()
{
    // input of the user
    int inputNumber;

    // for the remainder
    int re;

    // contains the bits 0/1
    int bits[MAXBITS];

    // for the loops
    int j;
    int i = 0;

    printf("\t\tConverter decimal --> binary\n\n");

    // reads a decimal number from the user.
    printf("\nenter a positive integer number: ");
    scanf("%d", &inputNumber);

    // make sure the input number is a positive integer.
    if (inputNumber < 0)
    {
        printf("only positive integers >= 0\n");
        return 1;
    }

    // actual processing
    while (inputNumber > 0)
    {
        // computes the remainder by modulo 2
        re = inputNumber % 2;

        // computes the quotient of division by 2
        inputNumber = inputNumber / 2;

        bits[i] = re;
        i++;
    }

    printf("\n the number in binary is: ");

    // iterates backwards over all bits
    for (j = i - 1; j >= 0; j--)
    {
        printf("%d", bits[j]);
    }

    // for the case the input number is 0
    if (i == 0)
    {
        printf("0");
    }

    return 0;
}
/**
 * @file
 * @brief Convert decimal to binary using recursion algorithm
 */
#include <assert.h>

/**
 * Decimal to binary using recursion algorithm.
 * For example, if number = 5, the function returns the decimal integer 101.
 * @param number positive integer number to convert
 * @returns integer with digits representing binary value representation of
 * number.
 */
int decimal_to_binary(unsigned int number)
{
    return number == 0 ? 0 : number % 2 + 10 * decimal_to_binary(number / 2);
}

/** Test function */
void test()
{
    const int sets[][2] = {
        {0, 0}, {1, 1}, {2, 10}, {3, 11}, {4, 100}, {6, 110}, {7, 111},
        /* add more data sets to test */
    };

    for (int i = 0, size = sizeof(sets) / sizeof(sets[0]); i < size; ++i)
    {
        assert(decimal_to_binary(sets[i][0]) == sets[i][1]);
    }
}

/** Driver Code */
int main()
{
    test();
    return 0;
}
/**
 * @brief Octal to binay conversion by scanning user input
 * @details
 * The octalTobinary function take the octal number as long
 * return a long binary nuber after conversion
 * @author [Vishnu P](https://github.com/vishnu0pothan)
 */
#include <math.h>
#include <stdio.h>

/**
 * @brief Converet  octal number to binary
 * @param octalnum octal value that need to convert
 * @returns A binary number after conversion
 */
long octalToBinary(int octalnum)
{
    int decimalnum = 0, i = 0;
    long binarynum = 0;

    /* This loop converts octal number "octalnum" to the
     * decimal number "decimalnum"
     */
    while (octalnum != 0)
    {
        decimalnum = decimalnum + (octalnum % 10) * pow(8, i);
        i++;
        octalnum = octalnum / 10;
    }

    // i is re-initialized
    i = 1;

    /* This loop converts the decimal number "decimalnum" to the binary
     * number "binarynum"
     */
    while (decimalnum != 0)
    {
        binarynum = binarynum + (long)(decimalnum % 2) * i;
        decimalnum = decimalnum / 2;
        i = i * 10;
    }

    // Returning the binary number that we got from octal number
    return binarynum;
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    int octalnum;

    printf("Enter an octal number: ");
    scanf("%d", &octalnum);

    // Calling the function octaltoBinary
    printf("Equivalent binary number is: %ld", octalToBinary(octalnum));
    return 0;
}
/**
 * @file
 * @brief Octal to hexadecimal conversion by scanning user input
 * @details
 * The octalToHexadecimal function take the octal number as long
 * return a string hexadecimal value after conversion
 * @author [Rachit Bhalla](https://github.com/rachitbhalla)
 */
#include <assert.h> // for assert
#include <math.h> // for pow function
#include <stdio.h> // for scanf and printf functions
#include <stdlib.h> // for malloc and free functions
#include <string.h> // for strcmp function

/**
 * @brief Convert octal number to decimal number
 * @param octalValue is the octal number that needs to be converted
 * @returns a decimal number after conversion
 */
long octalToDecimal(long octalValue){
    long decimalValue = 0;
    int i = 0;
    while (octalValue) {
        // Extracts right-most digit, multiplies it with 8^i, and increment i by 1
        decimalValue += (long)(octalValue % 10) * pow(8, i++);
        // Shift right in base 10
        octalValue /= 10;
    }
    return decimalValue;
}

/**
 * @brief Convert octal number to hexadecimal number
 * dynamically allocated memory needs to be freed by the calling the function free
 * @param octalValue is the octal number that needs to be converted
 * @returns a hexadecimal value as a string after conversion
 */
char *octalToHexadecimal(long octalValue){
    char *hexadecimalValue = malloc(256 * sizeof(char));
    sprintf(hexadecimalValue, "%lX", octalToDecimal(octalValue));
    return hexadecimalValue;
}

/**
 * @brief Test function
 * @returns void
 */
static void test() {
    /* test that hexadecimal value of octal number 213 is 8B */
    assert(strcmp(octalToHexadecimal(213), "8B") == 0);

    /* test that hexadecimal value of octal number 174 is 7C */
    assert(strcmp(octalToHexadecimal(174), "7C") == 0);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    // execute the tests
    test();

    // get the value of octal number as input
    int octalValue;
    printf("Enter an octal number: ");
    scanf("%d", &octalValue);

    // call the function octalToHexadecimal and print the hexadecimal value
    char *hexadecimalValue = octalToHexadecimal(octalValue);
    printf("Equivalent hexadecimal number is: %s", hexadecimalValue);

    // free the memory allocated dynamically in function octalToHexadecimal
    free(hexadecimalValue);

    // return 0 and exit
    return 0;
}
// Program to convert decimal number to octal (Using Reccursion)
// This program only works for integer decimals
// Created by Aromal Anil

#include <stdio.h>
int decimal_to_octal(int decimal)
{
    if ((decimal < 8) && (decimal > 0))
    {
        return decimal;
    }
    else if (decimal == 0)
    {
        return 0;
    }
    else
    {
        return ((decimal_to_octal(decimal / 8) * 10) + decimal % 8);
    }
}
int main()
{
    int octalNumber, decimalNumber;
    printf("\nEnter your decimal number : ");
    scanf("%d", &decimalNumber);
    octalNumber = decimal_to_octal(decimalNumber);
    printf("\nThe octal of %d is : %d", decimalNumber, octalNumber);
    return 0;
}
bool isleaf(struct TreeNode *root)
{
    return root->left == NULL && root->right == NULL;
}

int sumOfLeftLeaves(struct TreeNode *root)
{
    if (root == NULL)
        return 0;
    if (root->left)
    {
        if (isleaf(root->left))
            return root->left->val + sumOfLeftLeaves(root->right);
    }
    return sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
}
int removeElement(int *nums, int numsSize, int val)
{
    int i, start = 0;
    for (i = 0; i < numsSize; i++)
    {
        if (nums[i] != val)
            nums[start++] = nums[i];
    }
    return start;
}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

struct TreeNode *searchBST(struct TreeNode *root, int val)
{
    if (!root)
        return NULL;

    if (root->val == val)
    {
        return root;
    }
    else if (root->val > val)
    {
        return searchBST(root->left, val);
    }
    else
    {
        return searchBST(root->right, val);
    }
}
int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }
int arrayPairSum(int *nums, int numsSize)
{
    int sum = 0, i;
    qsort(nums, numsSize, sizeof(int), cmpval);
    for (i = 0; i < numsSize; i = i + 2) sum = sum + nums[i];
    return sum;
}
int search(int *nums, int numsSize, int target)
{
    int low = 0, high = numsSize - 1;
    while (low <= high)
    {
        int mid = low + (high - low) / 2;
        if (target > nums[mid])
        {
            low = mid + 1;
        }
        else if (target < nums[mid])
        {
            high = mid - 1;
        }
        else
        {
            return mid;
        }
    }
    return -1;
}

/* Another solution: Using bsearch() */
int cmpint(const void *a, const void *b) { return *(int *)a - *(int *)b; }

int search(int *nums, int numsSize, int target)
{
    int *ret = bsearch(&target, nums, numsSize, sizeof(int), cmpint);
    if (ret)
        return (ret - nums);
    else
        return -1;
}
int max(int a, int b) { return a >= b ? a : b; }

int height(struct TreeNode *root)
{
    if (root == NULL)
        return 0;
    else
        return 1 + max(height(root->left), height(root->right));
}

bool isBalanced(struct TreeNode *root)
{
    if (root == NULL)
        return 1;
    int left = height(root->left);
    int right = height(root->right);
    return abs(left - right) <= 1 && isBalanced(root->left) &&
           isBalanced(root->right);
}
bool isPowerOfTwo(int n)
{
    if (!n)
        return false;
    while (n % 2 == 0) n /= 2;
    return n == 1;
}int hammingDistance(int x, int y)
{
    int difference =
        x ^ y;  // The XOR operator generates the bitwise difference in the
                // binary representation of two numbers If bit in ith position
                // of both numbers is same, bit in difference is 0, otherwise 1
    int TotalBits = sizeof(difference) * 8;  // total number of bits
    int i, distance = 0;
    for (i = 0; i < TotalBits; i++)
    {
        if (difference &
            (UINT32_C(1)
             << i))  // if the bit on the ith position of 32 bit input is 1,
                     // then proceed Further note the use of UINT32_C to convert
                     // 1 to unsigned 32 bit int, as just 1 is treated as int
                     // which cannot be shifted left more than 30 times
            distance += 1;
    }
    return distance;
}int divide(int dividend, int divisor)
{
    int sign = 1;
    long int output = 0;
    if (dividend < 0)
    {
        sign *= -1;
    }
    else
    {
        dividend *= -1;
    }
    if (divisor < 0)
    {
        sign *= -1;
    }
    else
    {
        divisor *= -1;
    }
    while (dividend <= divisor)
    {
        long int tmp = 0;
        long int div = divisor;
        while (dividend <= div)
        {
            tmp += (tmp + 1);
            dividend -= div;
            div += div;
        }
        if (output >= INT_MAX)
        {
            if (sign == -1)
            {
                return INT_MIN;
            }
            else
            {
                return INT_MAX;
            }
        }
        output += tmp;
    }

    return output * sign;
}
bool isPalindrome(char *s)
{
    int start = 0, end = strlen(s) - 1;
    while (start < end)
    {
        if (!isalpha(s[start]) && !isalnum(s[start]))
        {
            start++;
        }
        else if (!isalpha(s[end]) && !isalnum(s[end]))
        {
            end--;
        }
        else
        {
            char c1 = tolower(s[start]);
            char c2 = tolower(s[end]);
            if (c1 != c2)
                return 0;
            start++;
            end--;
        }
    }
    return 1;
}
int lengthOfLongestSubstring(char *str)
{
    int n = strlen(str);

    if (!n)
        return 0;

    int L_len = 1;  // length of longest substring
    int C_len = 1;  // length of current substring

    int P_ind, i;      //  P_ind for previous index
    int visited[256];  //  visited will keep track of visiting char for the last
                       //  instance. since there are 256 ASCII char, its size is
                       //  limited to that value.
    memset(visited, -1, sizeof(int) * 256);
    visited[str[0]] =
        0;  //  the index of that char will tell us that when it was visited.
    for (i = 1; i < n; i++)
    {
        P_ind = visited[str[i]];
        if (P_ind == -1 || i - C_len > P_ind)
            C_len++;  //  if the current char was not visited earlier, or it is
                      //  not the part of current substring
        else
        {  //  otherwise, we need to change the current/longest substring length
            if (C_len > L_len)
                L_len = C_len;
            C_len = i - P_ind;
        }
        visited[str[i]] = i;
    }
    if (C_len > L_len)
        L_len = C_len;
    return L_len;
}
/* Brute force */
int lengthOfLongestSubstring(char *s)
{
    int cur_max = 0, max = 0;
    int counter[255];
    int end = 0;

    memset(counter, 0, sizeof(int) * 255);
    while (end < strlen(s))
    {
        if (counter[s[end]] == 0)
        {
            counter[s[end]]++;
            end++;
            cur_max++;
        }
        else
        {
            char c = s[end];
            memset(counter, 0, 255 * sizeof(int));
            if (cur_max >= max)
                max = cur_max;
            cur_max = 0;
            while (s[end - 1] != c) end--;
        }
    }
    if (cur_max >= max)
        max = cur_max;
    return max;
}
int distanceBetweenBusStops(int *distance, int distanceSize, int start,
                            int destination)
{
    int sum1 = 0, sum2 = 0;
    if (start > destination)
    {
        int tmp = start;
        start = destination;
        destination = tmp;
    }
    for (auto i = 0; i < distanceSize; ++i)
    {
        if (i >= start && i < destination)
            sum1 += distance[i];
        else
            sum2 += distance[i];
    }
    return sum1 < sum2 ? sum1 : sum2;
}
bool isPalindrome(int x)
{
    if (x < 0 || (x % 10 == 0 && x != 0))
    {
        return false;
    }

    int revertedNumber = 0;
    while (x > revertedNumber)
    {
        revertedNumber = revertedNumber * 10 + x % 10;
        x /= 10;
    }

    return x == revertedNumber || x == revertedNumber / 10;
}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

int maxval(int a, int b)
{
    if (a > b)
        return a;
    else
        return b;
}
int maxDepth(struct TreeNode *root)
{
    if (root == NULL)
        return 0;
    else
        return 1 + maxval(maxDepth(root->left), maxDepth(root->right));
}
void reverseString(char *s, int sSize)
{
    int last = sSize - 1, i;
    for (i = 0; i < last; i++)
    {
        char tmp = s[i];
        s[i] = s[last];
        s[last] = tmp;
        last--;
    }
}
void processTraversal(struct TreeNode *root, int *res, int *size)
{
    if (!root)
        return;
    processTraversal(root->left, res, size);
    res[*size] = root->val;
    *size = *size + 1;
    processTraversal(root->right, res, size);
}

int *inorderTraversal(struct TreeNode *root, int *returnSize)
{
    int *res = malloc(256 * sizeof(int));
    *returnSize = 0;
    processTraversal(root, res, returnSize);
    return res;
}
char *getOne(char c)
{
    switch (c)
    {
    case '9':
        return "IX";

    case '8':
        return "VIII";

    case '7':
        return "VII";

    case '6':
        return "VI";

    case '5':
        return "V";

    case '4':
        return "IV";

    case '3':
        return "III";

    case '2':
        return "II";

    case '1':
        return "I";

    case '0':
        return "";

    default:
        return NULL;
    }
}

char *getTen(char c)
{
    switch (c)
    {
    case '9':
        return "XC";

    case '8':
        return "LXXX";

    case '7':
        return "LXX";

    case '6':
        return "LX";

    case '5':
        return "L";

    case '4':
        return "XL";

    case '3':
        return "XXX";

    case '2':
        return "XX";

    case '1':
        return "X";

    case '0':
        return "";

    default:
        return NULL;
    }
}

char *getHundred(char c)
{
    switch (c)
    {
    case '9':
        return "CM";

    case '8':
        return "DCCC";

    case '7':
        return "DCC";

    case '6':
        return "DC";

    case '5':
        return "D";

    case '4':
        return "CD";

    case '3':
        return "CCC";

    case '2':
        return "CC";

    case '1':
        return "C";

    case '0':
        return "";

    default:
        return NULL;
    }
}

char *getThousand(char c)
{
    switch (c)
    {
    case '3':
        return "MMM";

    case '2':
        return "MM";

    case '1':
        return "M";

    default:
        return NULL;
    }
}

char *intToRoman(int num)
{
    int length;
    char number[5];
    char *s = malloc(16 * sizeof(char));

    sprintf(number, "%i", num);

    length = strlen(number);

    switch (length)
    {
    case 4:
        sprintf(s, "%s%s%s%s", getThousand(number[0]), getHundred(number[1]),
                getTen(number[2]), getOne(number[3]));
        break;

    case 3:
        sprintf(s, "%s%s%s", getHundred(number[0]), getTen(number[1]),
                getOne(number[2]));

        break;

    case 2:
        sprintf(s, "%s%s", getTen(number[0]), getOne(number[1]));

        break;

    case 1:
        s = getOne(number[0]);
        break;

    default:
        break;
    }
    return s;
}
int maxcmp(int a, int b) { return (a >= b) ? a : b; }

/* max subarray problem by using Kadane's Algorithm
 */
int maxProfit(int *prices, int pricesSize)
{
    /* maxCur: current maximum
     * maxSoFar: found maximum for subarray so far
     */
    int maxCur = 0, maxSoFar = 0;
    for (int i = 1; i < pricesSize; i++)
    {
        maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]);
        maxSoFar = maxcmp(maxSoFar, maxCur);
    }
    return maxSoFar;
}
// for strlen()
#include <string.h>

int numJewelsInStones(char *j, char *s)
{
    // as strlen is O(n), store it once rather than using it in for loop
    int cnt[500], lens = strlen(s), lenj = strlen(j), sol = 0;
    memset(cnt, 0, sizeof(cnt));

    // lookup to know which character occurs in j
    for (int i = 0; i < lenj; i++) cnt[j[i]]++;

    // count the characters in s
    for (int i = 0; i < lens; i++) sol += cnt[s[i]];

    return sol;
}
#include <limits.h>

int reverse(int x)
{
    int rev = 0;
    while (x != 0)
    {
        int pop = x % 10;
        x /= 10;
        if (rev > INT_MAX / 10 || (rev == INT_MAX / 10 && pop > 7))
            return 0;
        if (rev < INT_MIN / 10 || (rev == INT_MIN / 10 && pop < -8))
            return 0;
        rev = rev * 10 + pop;
    }
    return rev;
}
/**
 * 905. Sort Array By Parity
 * Given an array A of non-negative integers, return an array consisting of
 * all the even elements of A, followed by all the odd elements of A.
 * You may return any answer array that satisfies this condition.
 * Example 1:
 * Input: [3,1,2,4]
 * Output: [2,4,3,1]
 * The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
 *
 * Note: The returned array must be malloced, assume caller calls free().
 */
int *sortArrayByParity(int *A, int ASize, int *returnSize)
{
    int *retArr = malloc(ASize * sizeof(int));
    int oddIndex = ASize - 1;
    int evenIndex = 0;
    *returnSize = ASize;
    for (int i = 0; i < ASize; i++)
    {
        if (A[i] % 2 == 0)
        {
            retArr[evenIndex] = A[i];
            evenIndex++;
        }
        else
        {
            retArr[oddIndex] = A[i];
            oddIndex--;
        }
    }

    return retArr;
}
int findMin(int *nums, int numsSize)
{
    int low = 0, high = numsSize - 1;
    while (low < high)
    {
        int mid = low + (high - low) / 2;
        /* minimum is on left side */
        if (nums[mid] < nums[high])
            high = mid;
        /* minimum is on right side */
        else
            low = mid + 1;
    }
    return nums[low];
}
/* 1st way: Using 2 pointers */
int *sortedSquares(int *A, int ASize, int *returnSize)
{
    int i, start = 0, end = ASize - 1;
    int *res = malloc(ASize * sizeof(int));
    *returnSize = ASize;
    for (i = ASize - 1; i >= 0; i--)
    {
        if (abs(A[start]) > A[end])
        {
            res[i] = A[start] * A[start];
            start++;
        }
        else
        {
            res[i] = A[end] * A[end];
            end--;
        }
    }
    return res;
}

/* 2nd way: Using qsort */
int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }

int *sortedSquares(int *A, int ASize, int *returnSize)
{
    int *res = malloc(ASize * sizeof(int));
    for (int i = 0; i < ASize; i++) res[i] = A[i] * A[i];
    *returnSize = ASize;
    qsort(res, ASize, sizeof(int), cmpval);
    return res;
}
// Forward declaration of isBadVersion API.
bool isBadVersion(int version);

int firstBadVersion(int n)
{
    int low = 1, high = n;
    while (low <= high)
    {
        int mid = low + (high - low) / 2;
        if (isBadVersion(mid))
        {
            high = mid - 1;
        }
        else
        {
            low = mid + 1;
        }
    }
    return low;
}

/* Author : Saurav Dubey */

int countSubstrings(char *s)
{
    int len = strlen(s);
    int i;
    int count = 0;
    for (i = 0; i < len; i++)
    {
        // cases handled for both odd and even lenghted Palindrome

        count += countPalin(s, i, i, len);
        if (i != len - 1)
            count += countPalin(s, i, i + 1, len);
    }
    return count;
}
int countPalin(char *s, int head, int tail, int len)
{
    int ret = (s[head] == s[tail]) ? 1 : 0;
    if (ret && head - 1 >= 0 && tail + 1 < len)
        ret += countPalin(s, head - 1, tail + 1, len);
    return ret;
}
int peakIndexInMountainArray(int *A, int ASize)
{
    int low = 1, high = ASize;
    while (low <= high)
    {
        int mid = low + (high - low) / 2;
        if (A[mid - 1] < A[mid] && A[mid] > A[mid + 1])
            return mid;
        else if (A[mid - 1] < A[mid] && A[mid] < A[mid + 1])
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}
char *toLowerCase(char *str)
{
    for (int i = 0; i < strlen(str); i++) str[i] = tolower(str[i]);
    return str;
}
int hammingWeight(uint32_t n)
{
    int TotalBits = 32;
    int i, weight = 0;
    for (i = 0; i < TotalBits; i++)
    {
        if (n &
            (UINT32_C(1)
             << i))  // if the bit on the ith position of 32 bit input is 1,
                     // then proceed Further note the use of UINT32_C to
                     // convert 1 to unsigned 32 bit int, as just 1 is treated
                     // as int which cannot be shifted left more than 30 times
            weight += 1;
    }
    return weight;
}struct ListNode *swapPairs(struct ListNode *head)
{
    if (!head || !head->next)
        return head;
    struct ListNode *tmp = head->next;
    head->next = swapPairs(head->next->next);
    tmp->next = head;
    return tmp;
}
bool isValid(char *s)
{
    int i, k = 0, len = strlen(s);
    char *store = calloc(len, sizeof(char));

    for (i = 0; s[i] != '\0'; i++)
    {
        switch (s[i])
        {
        case '(':
        case '{':
        case '[':
            store[k++] = s[i];
            break;
        case ')':
            if (k < 1 || store[--k] != '(')
                goto out;
            break;
        case '}':
            if (k < 1 || store[--k] != '{')
                goto out;
            break;
        case ']':
            if (k < 1 || store[--k] != '[')
                goto out;
            break;
        }
    }
out:
    free(store);
    return s[i] == '\0' && k == 0;
}
int singleNumber(int *nums, int numsSize)
{
    int i, result = 0;
    for (i = 0; i < numsSize; i++) result = result ^ nums[i];
    return result;
}
int fib(int N)
{
    if (N == 0)
        return 0;
    if (N == 1)
        return 1;
    return fib(N - 1) + fib(N - 2);
}
int numcmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }

bool containsDuplicate(int *nums, int numsSize)
{
    int i;
    qsort(nums, numsSize, sizeof(int), numcmp);
    for (i = 0; i < numsSize - 1; i++)
    {
        if (nums[i] == nums[i + 1])
            return 1;
    }
    return 0;
}

struct ListNode *deleteDuplicates(struct ListNode *head)
{
    struct ListNode *cur = head;
    while (cur && cur->next)
    {
        if (cur->val == cur->next->val)
            cur->next = cur->next->next;
        else
            cur = cur->next;
    }
    return head;
}
struct TreeNode *newNode(int item)
{
    struct TreeNode *node = (struct TreeNode *)malloc(sizeof(struct TreeNode));
    node->val = item;
    node->left = node->right = NULL;
    return node;
}

struct TreeNode *mergeTrees(struct TreeNode *t1, struct TreeNode *t2)
{
    if (t1 == NULL && t2 == NULL)
        return NULL;
    int item = (t1 == NULL ? 0 : t1->val) + (t2 == NULL ? 0 : t2->val);
    struct TreeNode *node = newNode(item);
    node->left =
        mergeTrees(t1 == NULL ? NULL : t1->left, t2 == NULL ? NULL : t2->left);
    node->right = mergeTrees(t1 == NULL ? NULL : t1->right,
                             t2 == NULL ? NULL : t2->right);
    return node;
}
struct TreeNode *buildBST(struct ListNode *head, struct ListNode *tail)
{
    if (head == tail)
        return NULL;
    struct ListNode *slow = head, *fast = head;
    while (fast != tail && fast->next != tail)
    {
        fast = fast->next->next;
        slow = slow->next;
    }
    struct TreeNode *node = malloc(sizeof(struct TreeNode));
    node->val = slow->val;
    node->left = buildBST(head, slow);
    node->right = buildBST(slow->next, tail);
    return node;
}
struct TreeNode *sortedListToBST(struct ListNode *head)
{
    if (!head)
        return NULL;
    else
        return buildBST(head, NULL);
}
int maxNumberOfBalloons(char *text)
{
    /*
        0 -> b,
        1 -> a,
        2 -> l,
        3 -> o,
        4 -> n
    */
    int count_letters[5] = {0};
    int i, min_counter_ballons;

    for (char *ptr = text; *ptr; ptr++)
    {
        if (*ptr == 'b')
        {
            count_letters[0]++;
        }
        else if (*ptr == 'a')
        {
            count_letters[1]++;
        }
        else if (*ptr == 'l')
        {
            count_letters[2]++;
        }
        else if (*ptr == 'o')
        {
            count_letters[3]++;
        }
        else if (*ptr == 'n')
        {
            count_letters[4]++;
        }
    }

    /* Divide by 2 the repeted letters */
    count_letters[2] /= 2;
    count_letters[3] /= 2;

    /* Max number of times which we can write ballon is equal to min value of
     * letters on count_letter */
    min_counter_ballons = count_letters[0];
    for (i = 1; i < 5; i++)
    {
        if (count_letters[i] < min_counter_ballons)
            min_counter_ballons = count_letters[i];
    }

    return min_counter_ballons;
}
int missingNumber(int *nums, int numsSize)
{
    int i, actual_sum = 0, sum = 0;
    for (i = 0; i < numsSize; i++)
    {
        sum = sum + nums[i];
        actual_sum = actual_sum + i;
    }
    return actual_sum + numsSize - sum;
}
struct ListNode *removeElements(struct ListNode *head, int val)
{
    if (head == NULL)
        return NULL;
    if (head->val == val)
    {
        return removeElements(head->next, val);
    }
    else
    {
        head->next = removeElements(head->next, val);
    }
    return head;
}
// Fucntion to calculate min of values a and b
int min(int a, int b) { return ((a < b) ? a : b); }

// Two pointer approach to find maximum container area
int maxArea(int *height, int heightSize)
{
    // Start with maximum container width
    int start = 0;
    int end = heightSize - 1;
    int res = 0;

    while (start < end)
    {
        // Calculate current area by taking minimum of two heights
        int currArea = (end - start) * min(height[start], height[end]);

        if (currArea > res)
            res = currArea;

        if (height[start] < height[end])
            start = start + 1;
        else
            end = end - 1;
    }

    return res;
}


double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2,
                              int nums2Size)
{
    int index1 = 0;
    int index2 = 0;
    int v[nums1Size + nums2Size];
    int v_index = 0;

    while (index1 < nums1Size && index2 < nums2Size)
    {
        if (nums1[index1] <= nums2[index2])
        {
            v[v_index++] = nums1[index1++];
        }
        else
        {
            v[v_index++] = nums2[index2++];
        }
    }
    if (index1 < nums1Size)
    {
        while (index1 < nums1Size)
        {
            v[v_index++] = nums1[index1++];
        }
    }
    if (index2 < nums2Size)
    {
        while (index2 < nums2Size)
        {
            v[v_index++] = nums2[index2++];
        }
    }
    if (v_index == 1)
    {
        return v[0];
    }
    if (v_index % 2 == 0)
    {
        double n1, n2;
        n1 = v[v_index / 2];
        n2 = v[(v_index / 2) - 1];
        return (n1 + n2) / 2;
    }
    int new_index = (int)v_index / 2;
    int i = 0;
    return v[new_index];
}
struct TreeNode *invertTree(struct TreeNode *root)
{
    struct TreeNode *tmp;
    if (root == NULL)
        return NULL;
    tmp = root->left;
    root->left = root->right;
    root->right = tmp;

    invertTree(root->left);
    invertTree(root->right);
    return root;
}
int findComplement(int num)
{
    int TotalBits = 0;
    int temp = num;
    while (temp)
    {  // To find position of MSB in given num. Since num is represented as a
       // standard size in memory, we cannot rely on size for that information.
        TotalBits++;  // increment TotalBits till temp becomes 0
        temp >>= 1;   // shift temp right by 1 bit every iteration; temp loses 1
                      // bit to underflow every iteration till it becomes 0
    }
    int i,
        flipNumber = 1;  // Eg: 1's complement of 101(binary) can be found as
                         // 101^111 (XOR with 111 flips all bits that are 1 to 0
                         // and flips 0 to 1)
    for (i = 1; i < TotalBits; i++)
    {
        flipNumber += UINT32_C(1)
                      << i;  // Note the use of unsigned int to facilitate left
                             // shift more than 31 times, if needed
    }
    num = num ^ flipNumber;
    return num;
}void duplicateZeros(int *arr, int arrSize)
{
    int i, start = 0;
    int *tmp = malloc(arrSize * sizeof(int));
    /* Copy arr into tmp arr */
    for (i = 0; i < arrSize; i++)
    {
        tmp[i] = arr[i];
    }
    i = 0;
    for (start = 0; start < arrSize; start++)
    {
        arr[start] = tmp[i];
        if (tmp[i] == 0)
        {
            start++;
            if (start < arrSize)
                arr[start] = 0;
        }
        i++;
    }
}
char *reverseOnlyLetters(char *S)
{
    int last = strlen(S) - 1, i;
    for (i = 0; i < last;)
    {
        if (!isalpha(S[i]))
        {
            i++;
            continue;
        }
        if (!isalpha(S[last]))
        {
            last--;
            continue;
        }
        char tmp = S[i];
        S[i] = S[last];
        S[last] = tmp;
        i++;
        last--;
    }
    return S;
}
int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }

int *findDuplicates(int *nums, int numsSize, int *returnSize)
{
    int i;
    qsort(nums, numsSize, sizeof(int), cmpval);
    int *retArr = malloc(numsSize * sizeof(int));
    *returnSize = 0;
    for (i = 0; i < numsSize - 1;)
    {
        if (nums[i] == nums[i + 1])
        {
            retArr[*returnSize] = nums[i];
            *returnSize = *returnSize + 1;
            i = i + 2;
        }
        else
        {
            i = i + 1;
        }
    }
    return retArr;
}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

struct ListNode *middleNode(struct ListNode *head)
{
    struct ListNode *fast, *slow;
    fast = slow = head;
    while (fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}
uint32_t reverseBits(uint32_t n)
{
    uint TotalBits = 32;
    uint32_t reverse_int = 0;  // stored in memory as 32 bits, each bit valued 0
    uint i;
    for (i = 0; i < TotalBits; i++)
    {
        if ((n & (UINT32_C(1)
                  << i)))  // if the bit on the ith position of 32 bit input is
                           // 1, then proceed Further note the use of UINT32_C
                           // to convert 1 to unsigned 32 bit int, since just 1
                           // is treated as int which cannot be shifted left
                           // more than 30 times
            reverse_int =
                reverse_int |
                (UINT32_C(1)
                 << (TotalBits - 1 -
                     i));  // Convert the ith bit from the end in reverse_int
                           // from 0 to 1, if ith bit from beginning in n is 1
                           // This is achieved by using bitwise OR on
                           // reverse_int (where ith bit from end is currently
                           // 0) and 1 shifted left 31 - i bits (to ith bit from
                           // the end)
    }
    return reverse_int;
}int rangeSumBST(struct TreeNode *root, int L, int R)
{
    if (root == NULL)
    {
        return 0;
    }
    else if (root->val >= L && root->val <= R)
    {
        return root->val + rangeSumBST(root->left, L, R) +
               rangeSumBST(root->right, L, R);
    }
    else
    {
        return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);
    }
}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

#include <limits.h>

typedef struct
{
    int *values;
    int CurrentIndex;
    int NumberOfNodes;
} BSTIterator;

void TraverseAndAssign(struct TreeNode *root, BSTIterator *obj)
{
    if (!root)
        return;
    if (root->left)
        TraverseAndAssign(root->left, obj);
    obj->values[obj->CurrentIndex] = root->val;
    obj->CurrentIndex++;
    if (root->right)
        TraverseAndAssign(root->right, obj);
}

int TotalNodes(struct TreeNode *root)
{
    if (!root)
        return 0;
    int nodes_left = TotalNodes(root->left);
    int nodes_right = TotalNodes(root->right);
    return nodes_left + nodes_right + 1;
}

BSTIterator *bSTIteratorCreate(struct TreeNode *root)
{
    int n = TotalNodes(root);
    int size = n + 1;
    printf("%d", size);
    BSTIterator *obj = (BSTIterator *)malloc(sizeof(BSTIterator));
    obj->values = (int *)calloc(size, sizeof(int));
    obj->CurrentIndex = 0;
    obj->NumberOfNodes = n;
    obj->values[size - 1] = INT_MAX;
    TraverseAndAssign(root, obj);
    obj->CurrentIndex = 0;
    return obj;
}

/** @return the next smallest number */
int bSTIteratorNext(BSTIterator *obj)
{
    int NextValue = obj->values[obj->CurrentIndex];
    obj->CurrentIndex++;
    return NextValue;
}

/** @return whether we have a next smallest number */
bool bSTIteratorHasNext(BSTIterator *obj)
{
    if (!obj->NumberOfNodes)
    {
        return false;
    }
    printf(" Here ");
    return (obj->values[obj->CurrentIndex] == INT_MAX) ? false : true;
}

void bSTIteratorFree(BSTIterator *obj)
{
    free(obj->values);
    free(obj);
}
bool hasPathSum(struct TreeNode *root, int sum)
{
    if (root == NULL)
        return 0;
    if (!root->left && !root->right && sum - root->val == 0)
        return 1;
    return hasPathSum(root->left, sum - root->val) ||
           hasPathSum(root->right, sum - root->val);
}
/*
 * Iterative approach
 */
struct ListNode *mergeTwoLists(struct ListNode *l1, struct ListNode *l2)
{
    struct ListNode *list = NULL;
    struct ListNode *tmp = NULL;

    if (!l1)
        return l2;
    if (!l2)
        return l1;

    if (l1 && l2)
    {
        if (l1->val < l2->val)
        {
            list = tmp = l1;
            l1 = l1->next;
        }
        else
        {
            list = tmp = l2;
            l2 = l2->next;
        }

        while (l1 && l2)
        {
            if (l1->val < l2->val)
            {
                tmp->next = l1;
                l1 = l1->next;
            }
            else
            {
                tmp->next = l2;
                l2 = l2->next;
            }
            tmp = tmp->next;
        }

        if (l1)
            tmp->next = l1;
        if (l2)
            tmp->next = l2;

        return list;
    }

    return NULL;
}

/*
 * Recursive approach
 */
struct ListNode *mergeTwoLists(struct ListNode *l1, struct ListNode *l2)
{
    if (!l1)
        return l2;
    if (!l2)
        return l1;
    if (l1->val < l2->val)
    {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    }
    else
    {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
}
struct ListNode *deleteDuplicates(struct ListNode *head)
{
    if (head == NULL)
        return NULL;

    if (head->next && head->val == head->next->val)
    {
        /* Remove all duplicate numbers */
        while (head->next && head->val == head->next->val)
        {
            head = head->next;
        }
        return deleteDuplicates(head->next);
    }
    else
    {
        head->next = deleteDuplicates(head->next);
    }
    return head;
}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

struct TreeNode *convertBST(int *nums, int left, int right)
{
    if (left > right)
        return NULL;
    else
    {
        int mid = (right + left) / 2;
        struct TreeNode *new_val = malloc(sizeof(struct TreeNode));
        new_val->val = nums[mid];
        new_val->left = convertBST(nums, left, mid - 1);
        new_val->right = convertBST(nums, mid + 1, right);
        return new_val;
    }
}

struct TreeNode *sortedArrayToBST(int *nums, int numsSize)
{
    if (numsSize == 0)
        return NULL;
    else
        return convertBST(nums, 0, numsSize - 1);
}
bool isPerfectSquare(int num)
{
    for (long i = 1; i * i <= num; i++)
        if (i * i == num)
            return true;
    return false;
}
/* Boyer-Moore Majority Vote Algorithm
 * http://www.cs.utexas.edu/~moore/best-ideas/mjrty/ */
int majorityElement(int *nums, int numsSize)
{
    int count = 1;
    int majorNum = nums[0];
    for (int i = 1; i < numsSize; i++)
    {
        if (count == 0)
        {
            majorNum = nums[i];
            count++;
        }
        else if (majorNum == nums[i])
            count++;
        else
            count--;
    }
    return majorNum;
}
bool isAnagram(char *s, char *t)
{
    int n = strlen(s);
    int m = strlen(t);

    int cnt_s[1000], cnt_t[1000];
    for (int c = 97; c < 97 + 26; c++) cnt_s[c] = cnt_t[c] = 0;

    for (int i = 0; i < n; i++) cnt_s[s[i]]++;

    for (int i = 0; i < m; i++) cnt_t[t[i]]++;

    for (int c = 97; c < 97 + 26; c++)
        if (cnt_s[c] != cnt_t[c])
            return false;

    return true;
}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

struct ListNode *reverseList(struct ListNode *head)
{
    struct ListNode *res = NULL;
    while (head)
    {
        struct ListNode *pre_node = head;
        head = head->next;
        pre_node->next = res;
        res = pre_node;
    }
    return res;
}
int *twoSum(int *nums, int numsSize, int target, int *returnSize)
{
    int i, j;
    int *ret = calloc(2, sizeof(int));
    for (i = 0; i < numsSize; i++)
    {
        int key = target - nums[i];
        for (j = i + 1; j < numsSize; j++)
            if (nums[j] == key)
            {
                ret[0] = i;
                ret[1] = j;
            }
    }
    *returnSize = 2;
    return ret;
}
struct ListNode *detectCycle(struct ListNode *head)
{
    if (head == NULL || head->next == NULL)
        return NULL;
    struct ListNode *slow, *fast;
    slow = fast = head;
    while (fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
        {
            struct ListNode *entry = head;
            while (slow != entry)
            {
                slow = slow->next;
                entry = entry->next;
            }
            return entry;
        }
    }
    return NULL;
}
int searchInsert(int *nums, int numsSize, int target)
{
    int low = 0, high = numsSize - 1, mid;
    while (low <= high)
    {
        mid = low + (high - low) / 2;
        if (target > nums[mid])
            low = mid + 1;
        else if (target < nums[mid])
            high = mid - 1;
        else
            return mid;
    }
    return low;
}

/* Recursive version */
int searchInsert(int *nums, int numsSize, int target)
{
    int idx = numsSize - 1;
    if (numsSize > 0)
    {
        if (target > nums[idx])
        {
            return numsSize;
        }
        return searchInsert(nums, numsSize - 1, target);
    }
    return 0;
}
int removeDuplicates(int *nums, int numsSize)
{
    int count = 0, i;
    for (i = 1; i < numsSize; i++)
    {
        if (nums[i] == nums[i - 1])
            count++;
        else
            nums[i - count] = nums[i];
    }
    return numsSize - count;
}
bool detectCapitalUse(char *word)
{
    int len = strlen(word);
    if (len == 1)
        return 1;
    int countUpper = 0, i;
    for (i = 0; i < len; i++)
    {
        if (isupper(word[i]))
            countUpper++;
    }
    /* All lower case */
    if (countUpper == 0)
        return 1;
    /* 1st character is upper, and the rest is lower case */
    if (countUpper == 1 && isupper(word[0]))
        return 1;
    /* Check all character is upper case? */
    else
        return countUpper == len;
}

/* Another way */
bool isAllUpper(char *word)
{
    int len = strlen(word);
    for (int i = 0; i < len; i++)
    {
        if (islower(word[i]))
            return 0;
    }
    return 1;
}
bool detectCapitalUse(char *word)
{
    int len = strlen(word);
    for (int i = 1; i < len; i++)
    {
        if (isupper(word[i]) && !isAllUpper(word))
            return 0;
    }
    return 1;
}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

struct ListNode *reverse(struct ListNode *head)
{
    struct ListNode *res = NULL;
    while (head)
    {
        struct ListNode *pre_node = head;
        head = head->next;
        pre_node->next = res;
        res = pre_node;
    }
    return res;
}
bool isPalindrome(struct ListNode *head)
{
    struct ListNode *slow = head;
    struct ListNode *fast = head;
    struct ListNode *last;
    while (fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
    }
    if (fast != NULL)
        slow = slow->next;
    last = reverse(slow);
    while (last)
    {
        if (head->val != last->val)
            return 0;
        head = head->next;
        last = last->next;
    }
    return 1;
}
struct TreeNode *insertIntoBST(struct TreeNode *root, int val)
{
    if (root == NULL)
    {
        struct TreeNode *new_val = malloc(sizeof(struct TreeNode));
        new_val->val = val;
        new_val->left = new_val->right = NULL;
        return new_val;
    }
    else
    {
        if (root->val >= val)
            root->left = insertIntoBST(root->left, val);
        else
            root->right = insertIntoBST(root->right, val);
    }
    return root;
}
int *cmpval(const void *a, const void *b) { return *(int *)b - *(int *)a; }

int findKthLargest(int *nums, int numsSize, int k)
{
    qsort(nums, numsSize, sizeof(int), cmpval);
    return nums[k - 1];
}
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int *plusOne(int *digits, int digitsSize, int *returnSize)
{
    for (int i = digitsSize - 1; i >= 0; i--)
    {
        if (digits[i] < 9)
        {
            digits[i]++;
            *returnSize = digitsSize;
            return digits;
        }
        else
        {
            digits[i] = 0;
        }
    }

    int *newdigit = (int *)malloc((digitsSize + 1) * sizeof(int));
    newdigit[0] = 1;
    for (int i = 1; i < (digitsSize + 1); i++)
    {
        newdigit[i] = digits[i - 1];
    }
    *returnSize = digitsSize + 1;
    return newdigit;
}/*
 * brute force approach
 * time complexity: O(mn)
 */
int strStr(char *haystack, char *needle)
{
    int i = 0;
    int j = 0;
    int k = 0;
    int hlen = 0;
    int nlen = 0;

    if (needle == NULL || *needle == 0)
        return 0;

    if (haystack == NULL || *haystack == 0)
        return -1;

    hlen = strlen(haystack);
    nlen = strlen(needle);

    if (hlen < nlen)
        return -1;

    for (i = 0; i <= hlen - nlen; i++)
    {
        j = 0;
        if (haystack[i] != needle[j++])
            continue;

        k = i + 1;
        for (; j < nlen; j++)
        {
            if (haystack[k] != needle[j])
            {
                break;
            }
            else
                k++;
        }
        if (j == nlen)
            return i;
    }
    return -1;
}

/* ----------------------------------------------------------------------------------------
 */

/*
 * KMP algorithm
 * time complexity: O(m + n)
 */

/* fills overlap with longest proper prefix which is also suffix for each index
 * in needle */
void fill_overlap(char *needle, int len_needle, int *overlap)
{
    int len = 0;
    int i = 0;

    overlap[0] = 0;

    for (i = 1; i < len_needle;)
    {
        if (needle[i] == needle[len])
        {
            len++;
            overlap[i++] = len;
        }
        else
        {
            if (len)
                len = overlap[len - 1];
            else
                overlap[i++] = 0;
        }
    }
}

int strStr(char *haystack, char *needle)
{
    int i = 0; /* index for haystack */
    int j = 0; /* index for needle */

    int len_needle = strlen(needle);
    int len_haystack = strlen(haystack);

    if (!len_needle)
        return 0;

    int overlap[len_needle];

    fill_overlap(needle, len_needle, overlap);

    while (i < len_haystack)
    {
        if (needle[j] == haystack[i])
        {
            i++;
            j++;
        }

        if (j == len_needle)
        {
            return (i - j);
        }
        else if (i < len_haystack && needle[j] != haystack[i])
        {
            if (j != 0)
                j = overlap[j - 1];
            else
                i = i + 1;
        }
    }
    return -1;
}

/* ----------------------------------------------------------------------------------------
 */
int myAtoi(char *str)
{
    int minusFlag = 0;
    int length = strlen(str);
    long int result = 0;
    char numberBuffer[11];
    int counter = 0;
    while (str[counter] == ' ')
    {
        counter++;
    }
    str = &str[counter];
    counter = 0;

    for (int i = 0; i < length; i++)
    {
        if (i == 0)
        {
            if (str[0] == '-')
            {
                minusFlag = 1;
                i++;
            }
            else if (str[0] == '+')
            {
                i++;
            }
        }
        if (counter > 10)
        {
            if (minusFlag)
            {
                return __INT_MAX__ * -1 - 1;
            }
            else
            {
                return __INT_MAX__;
            }
        }

        if (str[i] < '0' || str[i] > '9')
        {
            break;
        }
        if (counter == 0 && str[i] == '0')
        {
            continue;
        }

        numberBuffer[counter] = str[i];
        counter++;
    }

    int i = 0;
    while (counter > 0)
    {
        if (minusFlag)
        {
            result -= (numberBuffer[i] - '0') * pow(10.0, counter - 1);
        }
        else
        {
            result += (numberBuffer[i] - '0') * pow(10.0, counter - 1);
        }
        i++;
        counter--;
    }

    if (result > __INT_MAX__)
    {
        return __INT_MAX__;
    }
    else if (result < __INT_MAX__ * -1 - 1)
    {
        return __INT_MAX__ * -1 - 1;
    }
    return result;
}
/*
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

struct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2)
{
    struct ListNode *head = NULL;
    struct ListNode *walk = NULL;
    struct ListNode *tmp = NULL;

    int carry = 0;
    int val1 = 0;
    int val2 = 0;
    int val = 0;

    while (l1 != NULL || l2 != NULL || carry)
    {
        val1 = 0;
        val2 = 0;
        val = 0;

        if (l1)
        {
            val1 = l1->val;
            l1 = l1->next;
        }

        if (l2)
        {
            val2 = l2->val;
            l2 = l2->next;
        }

        val = carry + val1 + val2;
        carry = val / 10;

        tmp = malloc(sizeof(struct ListNode));
        tmp->val = val % 10;
        tmp->next = NULL;

        if (!head)
        {
            head = walk = tmp;
        }
        else
        {
            walk->next = tmp;
            walk = walk->next;
        }
    }

    return head;
}
void moveZeroes(int *nums, int numsSize)
{
    int i = 0, start = 0;

    for (i = 0; i < numsSize; i++)
    {
        if (nums[i])
            nums[start++] = nums[i];
    }

    for (start; start < numsSize; start++)
    {
        nums[start] = 0;
    }
}
char *countAndSay(int n)
{
    // Calculating the length of array
    double result = 1.0;
    for (int i = 0; i < n - 1; i++)
    {
        result *= 1.4;
    }

    int k, j, count, convert = (int)result;

    // Creating array with the length calculated above
    char *arr = malloc(convert + 4);
    arr[0] = '1';
    arr[1] = '\0';

    for (int i = 2, length; i <= n; i++)
    {
        length = strlen(arr);
        char newArr[length * 2];
        strcpy(newArr, arr);

        k = 0;
        j = 0;
        count = 1;

        while (newArr[j] != '\0')
        {
            if (newArr[j] == newArr[j + 1])
            {
                count++;
                j++;
            }
            else
            {
                arr[k] = (48 + count);
                arr[k + 1] = newArr[j];
                arr[k + 2] = '\0';
                j++;
                k += 2;
                count = 1;
            }
        }
    }

    return arr;
}

int maxcmp(int a, int b) { return a >= b ? a : b; }

int maxSubArray(int *nums, int numsSize)
{
    int maxSoFar = nums[0], maxEndingHere = nums[0];
    for (int i = 1; i < numsSize; i++)
    {
        maxEndingHere = maxcmp(maxEndingHere + nums[i], nums[i]);
        maxSoFar = maxcmp(maxSoFar, maxEndingHere);
    }
    return maxSoFar;
}
struct ListNode *getIntersectionNode(struct ListNode *headA,
                                     struct ListNode *headB)
{
    struct ListNode *cur1 = headA, *cur2 = headB;
    if (cur1 == NULL || cur2 == NULL)
        return NULL;
    while (cur1 && cur2 && cur1 != cur2)
    {
        cur1 = cur1->next;
        cur2 = cur2->next;
        if (cur1 == cur2)
            return cur1;
        if (!cur1)
            cur1 = headB;
        if (!cur2)
            cur2 = headA;
    }
    return cur1;
}
int findLengthOfLCIS(int *nums, int numsSize)
{
    int maxval = 1, i, count = 1;
    if (numsSize == 0)
        return 0;
    for (i = 1; i < numsSize; i++)
    {
        if (nums[i] > nums[i - 1])
        {
            count++;
            if (count >= maxval)
                maxval = count;
        }
        else
        {
            count = 1;
        }
    }
    return maxval;
}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

bool checkSymmetric(struct TreeNode *left, struct TreeNode *right)
{
    if (!left || !right)
        return left == right;
    if (left->val != right->val)
        return 0;
    return checkSymmetric(left->left, right->right) &&
           checkSymmetric(left->right, right->left);
}

bool isSymmetric(struct TreeNode *root)
{
    return root == NULL || checkSymmetric(root->left, root->right);
}
char findTheDifference(char *s, char *t)
{
    int sum1 = 0, sum2 = 0;
    int i;
    for (i = 0; i < strlen(s); i++) sum1 += s[i];
    for (i = 0; i < strlen(t); i++) sum2 += t[i];
    return (char)(sum2 - sum1);
}
#define MAP_SIZE 2048

int cmpvalue(const void *a, const void *b) { return *(int *)b - *(int *)a; }
bool uniqueOccurrences(int *arr, int arrSize)
{
    int *map = calloc(MAP_SIZE, sizeof(int));
    int i;
    for (i = 0; i < arrSize; i++)
    {
        if (arr[i] < 0)
            map[arr[i] + MAP_SIZE / 2] += 1;
        else
            map[arr[i]] += 1;
    }
    /* number of occurrences is sorted by decreasing order
       Ex: 3 2 1 0 0 0 0 */
    qsort(map, MAP_SIZE, sizeof(int), cmpvalue);
    i = 0;
    while (map[i])
    {
        if (map[i] == map[i + 1])
            return 0;
        i++;
    }
    return 1;
}
void rotate(int *nums, int numsSize, int k)
{
    for (int i = 1; i <= k; i++)
    {
        int j;
        int lastElement;
        lastElement = nums[numsSize - 1];
        for (j = numsSize - 1; j > 0; j--)
        {
            nums[j] = nums[j - 1];
        }
        nums[0] = lastElement;
    }
}int firstUniqChar(char *s)
{
    int *arr = calloc(256, sizeof(int));
    int i;
    for (i = 0; i < strlen(s); i++) arr[s[i]] = arr[s[i]] + 1;
    for (i = 0; i < strlen(s); i++)
    {
        if (arr[s[i]] == 1)
            return i;
    }
    return -1;
}
/**
 * @file
 * @brief Implementation of the [ZigZag
 * Conversion](https://leetcode.com/problems/zigzag-conversion/) Leetcode
 * problem
 * @details
 * A decent solution to the ZigZag conversion problem.
 * Take advantage of the fact that the maximum gap between the chars is 2 times
 * the depth(the number of rows).
 * The actual gap between the two first chars of a rows depends on the depth of
 * the row. The gaps between successives chars on the same row is the complement
 * of the first gap to the maximum gap.
 * @author [straight_into_the_wall](https://github.com/straight-into-the-wall)
 */

#include <assert.h>  /// for assert
#include <stdint.h>  /// for unsigned int with fixed size
#include <stdio.h>   /// for IO operations
#include <stdlib.h>  /// for malloc
#include <string.h>  /// for string tools

/**
 * @brief Convert a string to the it's zigzag equivalent on a given number of
 * rows.
 * @param in the string in input.
 * @param numRows the desired number of rows.
 * @returns the converted new (malloced) string.
 */
char* convert(char* in, uint16_t numRows)
{
    uint16_t len = strlen(in);

    if (len < numRows)
    {
        numRows = len;
    }
    char* out = calloc(len + 1, sizeof(char));

    if (numRows < 2)
    {
        memcpy(out, in, len + 1);
        return out;
    }

    uint16_t max = numRows - 1;
    uint16_t rr = 2 * max;
    uint16_t i = 0;
    uint16_t o = 0;
    uint16_t delta = 0;

    // first row
    while (i < len)
    {
        out[o++] = in[i];
        i += rr;
    }

    // middle rows
    for (uint16_t l = 1; l < max; l++)
    {
        i = l;
        delta = 2 * l;
        while (i < len)
        {
            out[o++] = in[i];
            delta = rr - delta;
            i += delta;
        }
    }

    // last row
    i = max;
    while (i < len)
    {
        out[o++] = in[i];
        i += rr;
    }

    return out;
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void testZigZag(char* s, int numRows, char* expected)
{
    char* ret = convert(s, numRows);
    int len = strlen(s);
    int cmp = strncmp(ret, expected, len);
    assert(!cmp);

    free(ret);
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
    char* s01 = "PAYPALISHIRING";

    char* r01 = "PINALSIGYAHRPI";
    testZigZag(s01, 4, r01);

    char* r02 = "PAHNAPLSIIGYIR";
    testZigZag(s01, 3, r02);

    char* s03 = "A";
    testZigZag(s03, 1, s03);
    testZigZag(s03, 3, s03);

    char* s04 =
        "cbxdwjccgtdoqiscyspqzvuqivzptlpvooynyapgvswoaosaghrffnxnjyeeltzaiznicc"
        "ozwknwyhzgpqlwfkjqipuu"
        "jvwtxlbznryjdohbvghmyuiggtyqjtmuqinntqmihntkddnalwnmsxsatqqeldacnnpjfe"
        "rmrnyuqnwbjjpdjhdeavkn"
        "ykpoxhxclqqedqavdwzoiorrwwxyrhlsrdgqkduvtmzzczufvtvfioygkvedervvudnegh"
        "bctcbxdxezrzgbpfhzanff"
        "eccbgqfmzjqtlrsppxqiywjobspefujlxnmddurddiyobqfspvcoulcvdrzkmkwlyiqdch"
        "ghrgytzdnobqcvdeqjystm"
        "epxcaniewqmoxkjwpymqorluxedvywhcoghotpusfgiestckrpaigocfufbubiyrrffmwa"
        "eeimidfnnzcphkflpbqsvt"
        "dwludsgaungfzoihbxifoprwcjzsdxngtacw";

    char* r04 =
        "cbxdwjccgtdoqiscyspqzvuqivzptlpvooynyapgvswoaosaghrffnxnjyeeltzaiznicc"
        "ozwknwyhzgpqlwfkjqipuu"
        "jvwtxlbznryjdohbvghmyuiggtyqjtmuqinntqmihntkddnalwnmsxsatqqeldacnnpjfe"
        "rmrnyuqnwbjjpdjhdeavkn"
        "ykpoxhxclqqedqavdwzoiorrwwxyrhlsrdgqkduvtmzzczufvtvfioygkvedervvudnegh"
        "bctcbxdxezrzgbpfhzanff"
        "eccbgqfmzjqtlrsppxqiywjobspefujlxnmddurddiyobqfspvcoulcvdrzkmkwlyiqdch"
        "ghrgytzdnobqcvdeqjystm"
        "epxcaniewqmoxkjwpymqorluxedvywhcoghotpusfgiestckrpaigocfufbubiyrrffmwa"
        "eeimidfnnzwccpahtkgfnl"
        "xpdbsqzsjvctwdrwploufdisxgbahuinogzf";

    testZigZag(s04, 472, r04);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main(void)
{
    test();  // run self-test implementations
    return 0;
}
int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }
int findDuplicate(int *nums, int numsSize)
{
    int i;
    qsort(nums, numsSize, sizeof(int), cmpval);
    for (i = 0; i < numsSize - 1; i++)
    {
        if (nums[i] == nums[i + 1])
            return nums[i];
    }
    return nums[i];
}
int romanToInt(char *s)
{
    int romanToInt = 0;
    for (int i = 0; i < strlen(s); i++)
    {
        switch (s[i])
        {
        case 'I':
            if (i + 1 < strlen(s))
            {
                if (s[i + 1] == 'V' || s[i + 1] == 'X')
                {
                    romanToInt -= 1;
                    break;
                }
            }
            romanToInt += 1;
            break;
        case 'V':
            romanToInt += 5;
            break;
        case 'X':
            if (i + 1 < strlen(s))
            {
                if (s[i + 1] == 'L' || s[i + 1] == 'C')
                {
                    romanToInt -= 10;
                    break;
                }
            }
            romanToInt += 10;
            break;
        case 'L':
            romanToInt += 50;
            break;
        case 'C':
            if (i + 1 < strlen(s))
            {
                if (s[i + 1] == 'D' || s[i + 1] == 'M')
                {
                    romanToInt -= 100;
                    break;
                }
            }
            romanToInt += 100;
            break;
        case 'D':
            romanToInt += 500;
            break;
        case 'M':
            romanToInt += 1000;
            break;
        default:
            break;
        }
    }
    return romanToInt;
}bool isUnivalTree(struct TreeNode *root)
{
    if (root == NULL)
        return 1;
    if (root->left)
    {
        if (root->left->val != root->val)
            return 0;
    }
    if (root->right)
    {
        if (root->right->val != root->val)
            return 0;
    }
    return isUnivalTree(root->left) && isUnivalTree(root->right);
}
int rangeBitwiseAnd(int m, int n)
{
    while (m < n)
    {
        n &= n - 1;
    }
    return n;
}/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
bool hasCycle(struct ListNode *head)
{
    struct ListNode *fast = head, *slow = head;
    while (slow && fast && fast->next)
    {
        fast = fast->next->next;
        slow = slow->next;
        if (fast == slow)
            return true;
    }
    return false;
}
#include <stdio.h>
#include <stdlib.h>
#define len 5

int binarySearch(int array[], int leng, int searchX)
{
    int pos = -1, right, left, i = 0;

    left = 0;
    right = leng - 1;

    while (left <= right)
    {
        pos = left + (right - left) / 2;
        if (array[pos] == searchX)
        {
            return pos;
        }
        else if (array[pos] > searchX)
        {
            right = pos - 1;
        }
        else
        {
            left = pos + 1;
        }
    }
    return -1; /* not found */
}

int main(int argc, char *argv[])
{
    int array[len] = {5, 8, 10, 14, 16};

    int position;
    position = binarySearch(array, len, 5);

    if (position < 0)
        printf("The number %d doesnt exist in array\n", 5);
    else
    {
        printf("The number %d exist in array at position : %d \n", 5, position);
    }

    return 0;
}

#include <stdio.h>

// Function to perform Ternary Search
int ternarySearch(int l, int r, int key, int ar[])
{
    if (r >= l)
    {
        // Find the mid1 and mid2
        int mid1 = l + (r - l) / 3;
        int mid2 = r - (r - l) / 3;

        // Check if key is present at any mid
        if (ar[mid1] == key)
        {
            return mid1;
        }
        if (ar[mid2] == key)
        {
            return mid2;
        }

        // Since key is not present at mid,
        // check in which region it is present
        // then repeat the Search operation
        // in that region

        if (key < ar[mid1])
        {
            // The key lies in between l and mid1
            return ternarySearch(l, mid1 - 1, key, ar);
        }
        else if (key > ar[mid2])
        {
            // The key lies in between mid2 and r
            return ternarySearch(mid2 + 1, r, key, ar);
        }
        else
        {
            // The key lies in between mid1 and mid2
            return ternarySearch(mid1 + 1, mid2 - 1, key, ar);
        }
    }

    // Key not found
    return -1;
}

// Driver code
int main()
{
    int l, r, p, key;

    // Get the array
    // Sort the array if not sorted
    int ar[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // Starting index
    l = 0;

    // length of array
    r = 9;

    // Checking for 5

    // Key to be searched in the array
    key = 5;

    // Search the key using ternarySearch
    p = ternarySearch(l, r, key, ar);

    // Print the result
    printf("Index of %d is %d\n", key, p);

    // Checking for 50

    // Key to be searched in the array
    key = 50;

    // Search the key using ternarySearch
    p = ternarySearch(l, r, key, ar);

    // Print the result
    printf("Index of %d is %d", key, p);
}#include <stdio.h>
#include <stdlib.h>

int fibMonaccianSearch(int arr[], int x, int n)
{
    /* Initialize fibonacci numbers */
    int fibMMm2 = 0;               // (m-2)'th Fibonacci No.
    int fibMMm1 = 1;               // (m-1)'th Fibonacci No.
    int fibM = fibMMm2 + fibMMm1;  // m'th Fibonacci

    /* fibM is going to store the smallest Fibonacci
       Number greater than or equal to n */
    while (fibM < n)
    {
        fibMMm2 = fibMMm1;
        fibMMm1 = fibM;
        fibM = fibMMm2 + fibMMm1;
    }

    // Marks the eliminated range from front
    int offset = -1;

    /* while there are elements to be inspected. Note that
       we compare arr[fibMm2] with x. When fibM becomes 1,
       fibMm2 becomes 0 */
    while (fibM > 1)
    {
        // Check if fibMm2 is a valid location

        // sets i to the min. of (offset+fibMMm2) and (n-1)
        int i = ((offset + fibMMm2) < (n - 1)) ? (offset + fibMMm2) : (n - 1);

        /* If x is greater than the value at index fibMm2,
           cut the subarray array from offset to i */
        if (arr[i] < x)
        {
            fibM = fibMMm1;
            fibMMm1 = fibMMm2;
            fibMMm2 = fibM - fibMMm1;
            offset = i;
        }

        /* If x is greater than the value at index fibMm2,
           cut the subarray after i+1  */
        else if (arr[i] > x)
        {
            fibM = fibMMm2;
            fibMMm1 = fibMMm1 - fibMMm2;
            fibMMm2 = fibM - fibMMm1;
        }

        /* element found. return index */
        else
            return i;
    }

    /* comparing the last element with x */
    if (fibMMm1 && arr[offset + 1] == x)
        return offset + 1;

    /*element not found. return -1 */
    return -1;
}

int main(void)
{
    int arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 85;
    printf("Found at index: %d", fibMonaccianSearch(arr, x, n));
    return 0;
}
#include <stdio.h>

/* By comparison, binary search always chooses the middle of the remaining
 * search space, discarding one half or the other, depending on the comparison
 * between the key found at the estimated position and the key sought. The
 * remaining search space is reduced to the part before or after the estimated
 * position. The linear search uses equality only as it compares elements
 * one-by-one from the start, ignoring any sorting. On average the interpolation
 * search makes about log(log(n)) comparisons (if the elements are uniformly
 * distributed), where n is the number of elements to be searched. In the worst
 * case (for instance where the numerical values of the keys increase
 * exponentially) it can make up to O(n) comparisons. In
 * interpolation-sequential search, interpolation is used to find an item near
 * the one being searched for, then linear search is used to find the exact
 * item. */

int interpolationSearch(int arr[], int n, int key)
{
    int low = 0, high = n - 1;
    while (low <= high && key >= arr[low] && key <= arr[high])
    {
        /* Calculate the nearest posible position of key */
        int pos =
            low + ((key - arr[low]) * (high - low)) / (arr[high] - arr[low]);
        if (key > arr[pos])
            low = pos + 1;
        else if (key < arr[pos])
            high = pos - 1;
        else /* Found */
            return pos;
    }
    /* Not found */
    return -1;
}

int main()
{
    int x;
    int arr[] = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\nEnter the number to be searched: ");
    scanf("%d", &x); /* Element to be searched */

    int index = interpolationSearch(arr, n, x);

    /* If element was found */
    if (index != -1)
        printf("Element found at position: %d\n", index);
    else
        printf("Element not found.\n");
    return 0;
}
/**
 * @file jump_search.c
 * @brief Implementation of [jump
 * search](https://en.wikipedia.org/wiki/Jump_search) algorithm.
 */
#include <assert.h>
#include <math.h>
#include <stdio.h>

/**
 * @brief Macro to return the minimum of two values
 */
#define min(X, Y) ((X) < (Y) ? (X) : (Y))

/**
 * @brief Implement Jump-search algorithm
 *
 * @param [in] arr Array to search within
 * @param x value to search for
 * @param n length of array
 * @return index where the value was found
 * @return -1 if value not found
 */
int jump_search(const int *arr, int x, size_t n)
{
    int step = floor(sqrt(n));
    int prev = 0;

    while (arr[min(step, n) - 1] < x)
    {
        prev = step;
        step += floor(sqrt(n));
        if (prev >= n)
        {
            return -1;
        }
    }

    while (arr[prev] < x)
    {
        prev = prev + 1;
        if (prev == min(step, n))
        {
            return -1;
        }
    }
    if (arr[prev] == x)
    {
        return prev;
    }
    return -1;
}

/**
 * @brief Test implementation of the function
 *
 */
void test()
{
    int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610};
    size_t n = sizeof(arr) / sizeof(int);

    int x = 55;
    printf("Test 1.... ");
    int index = jump_search(arr, x, n);
    assert(index == 10);
    printf("passed\nTest 2.... ");
    x = 56;
    index = jump_search(arr, x, n);
    assert(index == -1);
    printf("passed\nTest 3.... ");
    x = 13;
    index = jump_search(arr, x, n);
    assert(index == 7);
    printf("passed\n");
}

/**
 * @brief Main function
 */
int main()
{
    test();
    return 0;
}
/**
 * @file
 * @brief Program to perform [binary
 * search](https://en.wikipedia.org/wiki/Binary_search_algorithm) of a target
 * value in a given *sorted* array.
 * @authors [James McDermott](https://github.com/theycallmemac) - recursive
 * algorithm
 * @authors [Krishna Vedala](https://github.com/kvedala) - iterative algorithm
 */
#include <assert.h>
#include <stdio.h>

/** Recursive implementation
 * \param[in] arr array to search
 * \param l left index of search range
 * \param r right index of search range
 * \param x target value to search for
 * \returns location of x assuming array arr[l..r] is present
 * \returns -1 otherwise
 */
int binarysearch1(const int *arr, int l, int r, int x)
{
    if (r >= l)
    {
        int mid = l + (r - l) / 2;

        // If element is present at middle
        if (arr[mid] == x)
            return mid;

        // If element is smaller than middle
        if (arr[mid] > x)
            return binarysearch1(arr, l, mid - 1, x);

        // Else element is in right subarray
        return binarysearch1(arr, mid + 1, r, x);
    }

    // When element is not present in array
    return -1;
}

/** Iterative implementation
 * \param[in] arr array to search
 * \param l left index of search range
 * \param r right index of search range
 * \param x target value to search for
 * \returns location of x assuming array arr[l..r] is present
 * \returns -1 otherwise
 */
int binarysearch2(const int *arr, int l, int r, int x)
{
    int mid = l + (r - l) / 2;

    while (arr[mid] != x)
    {
        if (r <= l || r < 0)
            return -1;

        if (arr[mid] > x)
            // If element is smaller than middle
            r = mid - 1;
        else
            // Else element is in right subarray
            l = mid + 1;

        mid = l + (r - l) / 2;
    }

    // When element is not present in array
    return mid;
}

/** Test implementations */
void test()
{
    // give function an array to work with
    int arr[] = {2, 3, 4, 10, 40};
    // get size of array
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Test 1.... ");
    // set value to look for
    int x = 10;
    // set result to what is returned from binarysearch
    int result = binarysearch1(arr, 0, n - 1, x);
    assert(result == 3);
    printf("passed recursive... ");
    result = binarysearch2(arr, 0, n - 1, x);
    assert(result == 3);
    printf("passed iterative...\n");

    printf("Test 2.... ");
    x = 5;
    // set result to what is returned from binarysearch
    result = binarysearch1(arr, 0, n - 1, x);
    assert(result == -1);
    printf("passed recursive... ");
    result = binarysearch2(arr, 0, n - 1, x);
    assert(result == -1);
    printf("passed iterative...\n");
}

/** Main function */
int main(void)
{
    test();
    return 0;
}
/**
 * @file
 * @brief [Linear Search with Sentinel](https://en.wikipedia.org/wiki/Linear_search#With_a_sentinel) algorithm implementation
 * @details
 * This algorithm saves the last element of the array, 
 * then replaces it with the value to be found and sets it as the sentinel. 
 * When searching, compares each element with the sentinel. 
 * If the same, returns the index. If the index is the index of the sentinel, it means it was not found. 
 * Of course, if the value to be found is the last element, we return the index of the last element.
 * @author [Regan Yue](https://github.com/ReganYue)
 * Time Complexity: O(N)
 */

#include <stdio.h>   /// for IO operations
#include <assert.h>  /// for assert

/**
 * @brief Utility function to search for an element in the array and return the index of the element
 * @details 
 * The so-called "sentinel" is to use a special value as the boundary key of the array. 
 * One less judgment statement can be used. 
 * The purpose is to avoid checking whether the entire array is searched at each step in the search 
 * process, so as to improve the efficiency of the program.
 * We can use the last value of the array as the "sentinel", the data storage index i 
 * starts from 0 and ends at len-1, then the position where the index of arr is n-1 indicates 
 * that there is no data temporarily, which is the "sentinel" key.
 * If the last element of the array is equal to the key, directly return the index of the last element. 
 * Before setting the last element of the array as the key, we hand over the last element of the array to temp for temporary storage. 
 * Then go to the array to find the key. If the key is found, stop the search, and then compare the found element index with len-1. 
 * If it is equal, it means it was not found. If it is not equal, it is found.
 * @param arr this is an array containing elements
 * @param len this is the number of elements in the array
 * @param key the value we want to search
 * @return i if found, otherwise -1 is returned.
 */
int sentinel_linear_search( int arr[], int len, int key ){
	if(key == arr[len-1]){
		return len-1;
	}
	
	int temp = arr[len-1]; 
	arr[len-1] = key;
	
	int i = 0;
	while (arr[len-1] != arr[i]) {
		i++;
	}
	
	arr[len-1] = temp;
	
	return i != len-1 ? i : -1;
	 
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test(){
	int n,i;
	n = 5;
	/* init array */
	int arr[] = { 1, 2, 2, 6, 99, 100, 999 };

	assert(sentinel_linear_search( arr, n, 1 )==0);
	assert(sentinel_linear_search( arr, n, 2 )==1);
	assert(sentinel_linear_search( arr, n, 6 )==3);
	assert(sentinel_linear_search( arr, n, 101 )==-1);
	printf("All test cases have successfully passed!\n");
} 

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main(){
	test();  // run self-test implementations
	return 0;
}
#include <stdio.h>
#include <string.h>

/* Kabin-Karp algorithm for pattern searching
   d: radix-d notation. Ex. number from 0->9, d = 10
   q: prime number for hashing */
void rabin_karp_search(char *str, char *pattern, int d, int q)
{
    int len_str = strlen(str);
    int len_pat = strlen(pattern);
    int i, h = 1;
    int hash_s = 0; /* hash value for string text */
    int hash_p = 0; /* hash value for pattern */

    /* h = pow(d, len_pat - 1) % q */
    for (i = 0; i < len_pat - 1; i++) h = d * h % q;
    /* Calculating hashing of pattern and the 1st window of text */
    for (i = 0; i < len_pat; i++)
    {
        hash_p = (d * hash_p + pattern[i]) % q;
        hash_s = (d * hash_s + str[i]) % q;
    }

    for (i = 0; i <= len_str - len_pat; i++)
    {
        /* Check hash value of current window of text, and pattern
           If it is match, check each character to make sure pattern
           is match with current window of text */
        if (hash_p == hash_s)
        {
            int j;
            for (j = 0; j < len_pat; j++)
            {
                if (pattern[j] != str[i + j])
                    break;
            }
            if (len_pat == j)
                printf("--Pattern is found at: %d\n", i);
        }
        /* Calculate hash value for next window by removing the leading
           element of current window text, and adding its trailing */
        hash_s = (d * (hash_s - str[i] * h) + str[i + len_pat]) % q;
        /* Converting hash value to positive when it is negative */
        if (hash_s < 0)
            hash_s = hash_s + q;
    }
}

int main()
{
    char str[] = "AABCAB12AFAABCABFFEGABCAB";
    char pat1[] = "ABCAB";
    char pat2[] = "FFF"; /* not found */
    char pat3[] = "CAB";

    printf("String test: %s\n", str);
    printf("Test1: search pattern %s\n", pat1);
    rabin_karp_search(str, pat1, 256, 29);
    printf("Test2: search pattern %s\n", pat2);
    rabin_karp_search(str, pat2, 256, 29);
    printf("Test3: search pattern %s\n", pat3);
    rabin_karp_search(str, pat3, 256, 29);
    return 0;
}
#include <stdio.h>
#include <string.h>

#define NUM_OF_CHARS 256

int max(int a, int b) { return (a > b) ? a : b; }

void computeArray(char *pattern, int size, int arr[NUM_OF_CHARS])
{
    int i;

    for (i = 0; i < NUM_OF_CHARS; i++) arr[i] = -1;
    /* Fill the actual value of last occurrence of a character */
    for (i = 0; i < size; i++) arr[(int)pattern[i]] = i;
}
/* Boyer Moore Search algorithm  */
void boyer_moore_search(char *str, char *pattern)
{
    int n = strlen(str);
    int m = strlen(pattern);
    int shift = 0;
    int arr[NUM_OF_CHARS];

    computeArray(pattern, m, arr);
    while (shift <= (n - m))
    {
        int j = m - 1;
        while (j >= 0 && pattern[j] == str[shift + j]) j--;
        if (j < 0)
        {
            printf("--Pattern is found at: %d\n", shift);
            shift += (shift + m < n) ? m - arr[str[shift + m]] : 1;
        }
        else
        {
            shift += max(1, j - arr[str[shift + j]]);
        }
    }
}

int main()
{
    char str[] = "AABCAB12AFAABCABFFEGABCAB";
    char pat1[] = "ABCAB";
    char pat2[] = "FFF"; /* not found */
    char pat3[] = "CAB";

    printf("String test: %s\n", str);
    printf("Test1: search pattern %s\n", pat1);
    boyer_moore_search(str, pat1);
    printf("Test2: search pattern %s\n", pat2);
    boyer_moore_search(str, pat2);
    printf("Test3: search pattern %s\n", pat3);
    boyer_moore_search(str, pat3);
    return 0;
}
#include <stdio.h>
#include <string.h>

/* Naive Pattern Search algorithm (brute force way) */
void naive_search(char *str, char *pattern)
{
    int len_str = strlen(str);
    int len_pat = strlen(pattern);

    for (int i = 0; i <= len_str - len_pat; i++)
    {
        int j;
        for (j = 0; j < len_pat; j++)
        {
            if (str[i + j] != pattern[j])
                break;
        }
        if (j == len_pat)
            printf("--Pattern is found at: %d\n", i);
    }
}

int main()
{
    char str[] = "AABCAB12AFAABCABFFEGABCAB";
    char pat1[] = "ABCAB";
    char pat2[] = "FFF"; /* not found */
    char pat3[] = "CAB";

    printf("String test: %s\n", str);
    printf("Test1: search pattern %s\n", pat1);
    naive_search(str, pat1);
    printf("Test2: search pattern %s\n", pat2);
    naive_search(str, pat2);
    printf("Test3: search pattern %s\n", pat3);
    naive_search(str, pat3);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

int linearsearch(int *arr, int size, int val)
{
    int i;
    for (i = 0; i < size; i++)
    {
        if (arr[i] == val)
            return 1;
    }
    return 0;
}

int main()
{
    int n, i, v;
    printf("Enter the size of the array:\n");
    scanf("%d", &n);  // Taking input for the size of Array

    int *a = (int *)malloc(n * sizeof(int));
    printf("Enter the contents for an array of size %d:\n", n);
    for (i = 0; i < n; i++)
        scanf("%d", &a[i]);  // accepts the values of array elements until the
                             // loop terminates//

    printf("Enter the value to be searched:\n");
    scanf("%d", &v);  // Taking input the value to be searched
    if (linearsearch(a, n, v))
        printf("Value %d is in the array.\n", v);
    else
        printf("Value %d is not in the array.\n", v);

    free(a);
    return 0;
}
/**
 *  \file
 *  \brief [Exponential Search](https://github.com/TheAlgorithms/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Exponential%20Search.md)
 *  \author [Alessio Farinelli](https://github.com/faridevnz)
 */
#include <assert.h>  /// for assert
#include <inttypes.h>  /// for int64_t, uint16_t

#define ELEMENT -10

int64_t binary_search(const int64_t* arr, const uint16_t l_index, const uint16_t r_index, const int64_t n); ///< used to perform the binary search over the given array
int64_t exponential_search(const int64_t* arr, const uint16_t length, const int64_t n); ///< used to perform the exponential search over the given array
static void test(); ///< used to run the self-test implementations

/**
 * Function: exponential_search
 * \brief algorithm that search the index of the given item
 * \details recursive function that take an array and quickly find the range 
 * where to apply the binary search algorithm to find the given element
 * ----------------------------
 * \param arr array where search the element
 * \param length the total length of the given array (arr)
 * \param n element to find in the array (arr)
 * 
 * \returns the index of the element (n) in the array (arr)
 * \returns -1 if the element wasn't found
 */
int64_t exponential_search(const int64_t* arr, const uint16_t length, const int64_t n) 
{
    if ( length == 0 ) { return -1; }
    // find the upperbound
    uint32_t upper_bound = 1;
    while ( upper_bound <= length && arr[upper_bound] < n ) { upper_bound = upper_bound * 2; }
    // calculate the range ( between lower_boud and upper_bound )
    uint16_t lower_bound = upper_bound/2;
    if ( upper_bound > length ) { upper_bound = length; }
    // apply the binary search in the range
    return binary_search(arr, lower_bound, upper_bound, n);
}

/**
 * Function: binary_search
 * \brief algorithm that search the index of the given item
 * \details recursive function that search the given element in
 * the array using the [Binary Search](https://github.com/TheAlgorithms/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Binary%20Search.md)
 * ----------------------------
 * \param arr array where search the element
 * \param l_index start index of the array (arr) to apply the algorithm
 * \param r_index end index of the array (arr) to apply the algorithm
 * \param n element to find in the array (arr)
 *
 * \returns the index of the element (n) in the array (arr)
 * \returns -1 if the n element wasn't found
 */
int64_t binary_search(const int64_t* arr, const uint16_t l_index, const uint16_t r_index, const int64_t n) 
{
    // calculate the middle index of the array
    uint16_t middle_index = l_index + ( r_index - l_index ) / 2;
    // base cases
    if ( l_index > r_index ) { return -1; }
    if ( arr[middle_index] == n ) { return middle_index; }
    // recursion
    if ( arr[middle_index] > n ) { return binary_search(arr, l_index, middle_index-1, n); } // left
    return binary_search(arr, middle_index+1, r_index, n); // right
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main() 
{
    test();  // run self-test implementations
    return 0;
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
    // empty array
    int64_t arr_empty[] = {};
    assert(exponential_search(arr_empty, 0, 10) == -1);
    // elent not found
    int64_t arr_found[] = {1, 2, 3};
    assert(exponential_search(arr_found, 3, 10) == -1);
    // element found in an array of length 1
    int64_t arr_one[] = {1};
    assert(exponential_search(arr_found, 1, 1) == 0);
    // find the first element in an array of length 2
    int64_t arr_first_2[] = {1, 2};
    assert(exponential_search(arr_first_2, 2, 1) == 0);
    // find the last element in an array of length 2
    int64_t arr_last_2[] = {1, 2};
    assert(exponential_search(arr_last_2, 2, 2) == 1);
    // find the first element in an array of length n
    int64_t arr_first_n[] = {-1, 2, 4, 6, 8};
    assert(exponential_search(arr_first_n, 5, -1) == 0);
    // find the last element in an array of length n
    int64_t arr_last_n[] = {-1, 2, 4, 6, 8};
    assert(exponential_search(arr_last_n, 5, 8) == 4);
    // find an element in an array of length n
    int64_t arr_middle[] = {-1, 2, 4, 6, 8};
    assert(exponential_search(arr_middle, 5, 6) == 3);
}
/**
 * @file
 * @brief Implementation of [Floyd's Cycle
 * Detection](https://en.wikipedia.org/wiki/Cycle_detection) algorithm
 * @details
 * Given an array of integers containing `n + 1` integers, where each
 * integer is in the range [1, n] inclusive. If there is only one duplicate
 * number in the input array, this algorithm returns the duplicate number in
 * O(1) space and the time complexity is less than O(n^2) without modifying the
 * original array, otherwise, it returns -1.
 * @author [Swastika Gupta](https://github.com/Swastyy)
 */
 
#include <assert.h>   /// for assert
#include <inttypes.h> /// for uint32_t
#include <stdio.h>    /// for IO operations

/**
 * @brief The main function implements the search algorithm
 * @tparam T type of array
 * @param in_arr the input array
 * @param n size of the array
 * @returns the duplicate number
 */
uint32_t duplicateNumber(const uint32_t *in_arr, size_t n)
{
    if (n <= 1) {  // to find duplicate in an array its size should be atleast 2
        return -1;
    }
    uint32_t tortoise = in_arr[0];  ///< variable tortoise is used for the longer
                                    ///< jumps in the array
    uint32_t hare = in_arr[0];  ///< variable hare is used for shorter jumps in the array
    do {                                   // loop to enter the cycle
        tortoise = in_arr[tortoise];       // tortoise is moving by one step
        hare = in_arr[in_arr[hare]];       // hare is moving by two steps
    } while (tortoise != hare);
    tortoise = in_arr[0];
    while (tortoise != hare) {             // loop to find the entry point of cycle
        tortoise = in_arr[tortoise];
        hare = in_arr[hare];
    }
    return tortoise;
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
    uint32_t arr[] = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}; // input array
    size_t n = sizeof(arr) / sizeof(int);

    printf("1st test... ");
    uint32_t index = duplicateNumber(arr, n); // calling the duplicateNumber function to check which number occurs twice in the array
    assert(index == 1); // the number which occurs twice is 1 or not
    printf("passed\n");
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    test();  // run self-test implementations
    return 0;
}
/**
 * @file
 * @brief [Modified binary search algorithm](https://arxiv.org/abs/1406.1677)
 */
#include <stdio.h>
#include <stdlib.h>

/** This function does Binary search for `x` in `i`-th row from `j_low` to
 * `j_high`.
 * @param mat 2D matrix to search within
 * @param i row to search in
 * @param j_low start column index
 * @param j_high end column index
 * @param x value to search for
 * @return column where `x` was found
 * @return -1 if value not found
 */
int binarySearch(const int **mat, int i, int j_low, int j_high, int x)
{
    while (j_low <= j_high)
    {
        int j_mid = (j_low + j_high) / 2;

        // Element found
        if (mat[i][j_mid] == x)
        {
            printf("Found at (%d,%d)\n", i, j_mid);
            return j_mid;
        }
        else if (mat[i][j_mid] > x)
            j_high = j_mid - 1;
        else
            j_low = j_mid + 1;
    }

    // element not found
    printf("element not found\n");
    return -1;
}

/** Function to perform binary search on the mid values of row to get the
 * desired pair of rows where the element can be found
 * @param [in] mat matrix to search for the value in
 * @param n number of rows in the matrix
 * @param m number of columns in the matrix
 * @param x value to search for
 */
void modifiedBinarySearch(const int **mat, int n, int m, int x)
{  // If Single row matrix
    if (n == 1)
    {
        binarySearch(mat, 0, 0, m - 1, x);
        return;
    }

    // Do binary search in middle column.
    // Condition to terminate the loop when the 2 desired rows are found.
    int i_low = 0, i_high = n - 1, j_mid = m / 2;
    while ((i_low + 1) < i_high)
    {
        int i_mid = (i_low + i_high) / 2;
        // element found
        if (mat[i_mid][j_mid] == x)
        {
            printf("Found at (%d,%d)\n", i_mid, j_mid);
            return;
        }
        else if (mat[i_mid][j_mid] > x)
            i_high = i_mid;
        else
            i_low = i_mid;
    }
    // If element is present on the mid of the two rows
    if (mat[i_low][j_mid] == x)
        printf("Found at (%d,%d)\n", i_low, j_mid);
    else if (mat[i_low + 1][j_mid] == x)
        printf("Found at (%d,%d)\n", i_low + 1, j_mid);

    // Search element on 1st half of 1st row
    else if (x <= mat[i_low][j_mid - 1])
        binarySearch(mat, i_low, 0, j_mid - 1, x);

    // Search element on 2nd half of 1st row
    else if (x >= mat[i_low][j_mid + 1] && x <= mat[i_low][m - 1])
        binarySearch(mat, i_low, j_mid + 1, m - 1, x);

    // Search element on 1st half of 2nd row
    else if (x <= mat[i_low + 1][j_mid - 1])
        binarySearch(mat, i_low + 1, 0, j_mid - 1, x);

    // search element on 2nd half of 2nd row
    else
        binarySearch(mat, i_low + 1, j_mid + 1, m - 1, x);
}

/** Main function */
int main()
{
    int x;     // element to be searched
    int m, n;  // m = columns, n = rows

    scanf("%d %d %d\n", &n, &m, &x);

    int **mat = (int **)malloc(n * sizeof(int *));
    for (int i = 0; i < m; i++) mat[i] = (int *)malloc(m * sizeof(int));

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            scanf("%d", &mat[i][j]);
        }
    }

    modifiedBinarySearch(mat, n, m, x);

    for (int i = 0; i < n; i++) free(mat[i]);
    free(mat);
    return 0;
}
/**
 * @file k_means_clustering.c
 * @brief K Means Clustering Algorithm implemented
 * @details
 * This file has K Means algorithm implemmented
 * It prints test output in eps format
 *
 * Note:
 * Though the code for clustering works for all the
 * 2D data points and can be extended for any size vector
 * by making the required changes, but note that
 * the output method i.e. printEPS is only good for
 * polar data points i.e. in a circle and both test
 * use the same.
 * @author [Lakhan Nad](https://github.com/Lakhan-Nad)
 */

#define _USE_MATH_DEFINES /* required for MS Visual C */
#include <float.h>        /* DBL_MAX, DBL_MIN */
#include <math.h>         /* PI, sin, cos */
#include <stdio.h>        /* printf */
#include <stdlib.h>       /* rand */
#include <string.h>       /* memset */
#include <time.h>         /* time */

/*!
 * @addtogroup machine_learning Machine Learning Algorithms
 * @{
 * @addtogroup k_means K-Means Clustering Algorithm
 * @{
 */

/*! @struct observation
 *  a class to store points in 2d plane
 *  the name observation is used to denote
 *  a random point in plane
 */
typedef struct observation
{
    double x;  /**< abscissa of 2D data point */
    double y;  /**< ordinate of 2D data point */
    int group; /**< the group no in which this observation would go */
} observation;

/*! @struct cluster
 *  this class stores the coordinates
 *  of centroid of all the points
 *  in that cluster it also
 *  stores the count of observations
 *  belonging to this cluster
 */
typedef struct cluster
{
    double x;     /**< abscissa centroid of this cluster */
    double y;     /**< ordinate of centroid of this cluster */
    size_t count; /**< count of observations present in this cluster */
} cluster;

/*!
 * Returns the index of centroid nearest to
 * given observation
 *
 * @param o  observation
 * @param clusters  array of cluster having centroids coordinates
 * @param k  size of clusters array
 *
 * @returns the index of nearest centroid for given observation
 */
int calculateNearst(observation* o, cluster clusters[], int k)
{
    double minD = DBL_MAX;
    double dist = 0;
    int index = -1;
    int i = 0;
    for (; i < k; i++)
    {
        /* Calculate Squared Distance*/
        dist = (clusters[i].x - o->x) * (clusters[i].x - o->x) +
               (clusters[i].y - o->y) * (clusters[i].y - o->y);
        if (dist < minD)
        {
            minD = dist;
            index = i;
        }
    }
    return index;
}

/*!
 * Calculate centoid and assign it to the cluster variable
 *
 * @param observations  an array of observations whose centroid is calculated
 * @param size  size of the observations array
 * @param centroid  a reference to cluster object to store information of
 * centroid
 */
void calculateCentroid(observation observations[], size_t size,
                       cluster* centroid)
{
    size_t i = 0;
    centroid->x = 0;
    centroid->y = 0;
    centroid->count = size;
    for (; i < size; i++)
    {
        centroid->x += observations[i].x;
        centroid->y += observations[i].y;
        observations[i].group = 0;
    }
    centroid->x /= centroid->count;
    centroid->y /= centroid->count;
}

/*!
 *    --K Means Algorithm--
 * 1. Assign each observation to one of k groups
 *    creating a random initial clustering
 * 2. Find the centroid of observations for each
 *    cluster to form new centroids
 * 3. Find the centroid which is nearest for each
 *    observation among the calculated centroids
 * 4. Assign the observation to its nearest centroid
 *    to create a new clustering.
 * 5. Repeat step 2,3,4 until there is no change
 *    the current clustering and is same as last
 *    clustering.
 *
 * @param observations  an array of observations to cluster
 * @param size  size of observations array
 * @param k  no of clusters to be made
 *
 * @returns pointer to cluster object
 */
cluster* kMeans(observation observations[], size_t size, int k)
{
    cluster* clusters = NULL;
    if (k <= 1)
    {
        /*
        If we have to cluster them only in one group
        then calculate centroid of observations and
        that will be a ingle cluster
        */
        clusters = (cluster*)malloc(sizeof(cluster));
        memset(clusters, 0, sizeof(cluster));
        calculateCentroid(observations, size, clusters);
    }
    else if (k < size)
    {
        clusters = malloc(sizeof(cluster) * k);
        memset(clusters, 0, k * sizeof(cluster));
        /* STEP 1 */
        for (size_t j = 0; j < size; j++)
        {
            observations[j].group = rand() % k;
        }
        size_t changed = 0;
        size_t minAcceptedError =
            size /
            10000;  // Do until 99.99 percent points are in correct cluster
        int t = 0;
        do
        {
            /* Initialize clusters */
            for (int i = 0; i < k; i++)
            {
                clusters[i].x = 0;
                clusters[i].y = 0;
                clusters[i].count = 0;
            }
            /* STEP 2*/
            for (size_t j = 0; j < size; j++)
            {
                t = observations[j].group;
                clusters[t].x += observations[j].x;
                clusters[t].y += observations[j].y;
                clusters[t].count++;
            }
            for (int i = 0; i < k; i++)
            {
                clusters[i].x /= clusters[i].count;
                clusters[i].y /= clusters[i].count;
            }
            /* STEP 3 and 4 */
            changed = 0;  // this variable stores change in clustering
            for (size_t j = 0; j < size; j++)
            {
                t = calculateNearst(observations + j, clusters, k);
                if (t != observations[j].group)
                {
                    changed++;
                    observations[j].group = t;
                }
            }
        } while (changed > minAcceptedError);  // Keep on grouping until we have
                                               // got almost best clustering
    }
    else
    {
        /* If no of clusters is more than observations
           each observation can be its own cluster
        */
        clusters = (cluster*)malloc(sizeof(cluster) * k);
        memset(clusters, 0, k * sizeof(cluster));
        for (int j = 0; j < size; j++)
        {
            clusters[j].x = observations[j].x;
            clusters[j].y = observations[j].y;
            clusters[j].count = 1;
            observations[j].group = j;
        }
    }
    return clusters;
}

/**
 * @}
 * @}
 */

/*!
 * A function to print observations and clusters
 * The code is taken from
 * http://rosettacode.org/wiki/K-means%2B%2B_clustering.
 * Even the K Means code is also inspired from it
 *
 * @note To print in a file use pipeline operator
 * ```sh
 * ./k_means_clustering > image.eps
 * ```
 *
 * @param observations  observations array
 * @param len  size of observation array
 * @param cent  clusters centroid's array
 * @param k  size of cent array
 */
void printEPS(observation pts[], size_t len, cluster cent[], int k)
{
    int W = 400, H = 400;
    double min_x = DBL_MAX, max_x = DBL_MIN, min_y = DBL_MAX, max_y = DBL_MIN;
    double scale = 0, cx = 0, cy = 0;
    double* colors = (double*)malloc(sizeof(double) * (k * 3));
    int i;
    size_t j;
    double kd = k * 1.0;
    for (i = 0; i < k; i++)
    {
        *(colors + 3 * i) = (3 * (i + 1) % k) / kd;
        *(colors + 3 * i + 1) = (7 * i % k) / kd;
        *(colors + 3 * i + 2) = (9 * i % k) / kd;
    }

    for (j = 0; j < len; j++)
    {
        if (max_x < pts[j].x)
        {
            max_x = pts[j].x;
        }
        if (min_x > pts[j].x)
        {
            min_x = pts[j].x;
        }
        if (max_y < pts[j].y)
        {
            max_y = pts[j].y;
        }
        if (min_y > pts[j].y)
        {
            min_y = pts[j].y;
        }
    }
    scale = W / (max_x - min_x);
    if (scale > (H / (max_y - min_y)))
    {
        scale = H / (max_y - min_y);
    };
    cx = (max_x + min_x) / 2;
    cy = (max_y + min_y) / 2;

    printf("%%!PS-Adobe-3.0 EPSF-3.0\n%%%%BoundingBox: -5 -5 %d %d\n", W + 10,
           H + 10);
    printf(
        "/l {rlineto} def /m {rmoveto} def\n"
        "/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\n"
        "/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath "
        "	gsave 1 setgray fill grestore gsave 3 setlinewidth"
        " 1 setgray stroke grestore 0 setgray stroke }def\n");
    for (int i = 0; i < k; i++)
    {
        printf("%g %g %g setrgbcolor\n", *(colors + 3 * i),
               *(colors + 3 * i + 1), *(colors + 3 * i + 2));
        for (j = 0; j < len; j++)
        {
            if (pts[j].group != i)
            {
                continue;
            }
            printf("%.3f %.3f c\n", (pts[j].x - cx) * scale + W / 2,
                   (pts[j].y - cy) * scale + H / 2);
        }
        printf("\n0 setgray %g %g s\n", (cent[i].x - cx) * scale + W / 2,
               (cent[i].y - cy) * scale + H / 2);
    }
    printf("\n%%%%EOF");

    // free accquired memory
    free(colors);
}

/*!
 * A function to test the kMeans function
 * Generates 100000 points in a circle of
 * radius 20.0 with center at (0,0)
 * and cluster them into 5 clusters
 *
 * <img alt="Output for 100000 points divided in 5 clusters" src=
 * "https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest1.png"
 * width="400px" heiggt="400px">
 * @returns None
 */
static void test()
{
    size_t size = 100000L;
    observation* observations =
        (observation*)malloc(sizeof(observation) * size);
    double maxRadius = 20.00;
    double radius = 0;
    double ang = 0;
    size_t i = 0;
    for (; i < size; i++)
    {
        radius = maxRadius * ((double)rand() / RAND_MAX);
        ang = 2 * M_PI * ((double)rand() / RAND_MAX);
        observations[i].x = radius * cos(ang);
        observations[i].y = radius * sin(ang);
    }
    int k = 5;  // No of clusters
    cluster* clusters = kMeans(observations, size, k);
    printEPS(observations, size, clusters, k);
    // Free the accquired memory
    free(observations);
    free(clusters);
}

/*!
 * A function to test the kMeans function
 * Generates 1000000 points in a circle of
 * radius 20.0 with center at (0,0)
 * and cluster them into 11 clusters
 *
 * <img alt="Output for 1000000 points divided in 11 clusters" src=
 * "https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest2.png"
 * width="400px" heiggt="400px">
 * @returns None
 */
void test2()
{
    size_t size = 1000000L;
    observation* observations =
        (observation*)malloc(sizeof(observation) * size);
    double maxRadius = 20.00;
    double radius = 0;
    double ang = 0;
    size_t i = 0;
    for (; i < size; i++)
    {
        radius = maxRadius * ((double)rand() / RAND_MAX);
        ang = 2 * M_PI * ((double)rand() / RAND_MAX);
        observations[i].x = radius * cos(ang);
        observations[i].y = radius * sin(ang);
    }
    int k = 11;  // No of clusters
    cluster* clusters = kMeans(observations, size, k);
    printEPS(observations, size, clusters, k);
    // Free the accquired memory
    free(observations);
    free(clusters);
}

/*!
 * This function calls the test
 * function
 */
int main()
{
    srand(time(NULL));
    test();
    /* test2(); */
    return 0;
}
/**
 * \file
 * \brief [Kohonen self organizing
 * map](https://en.wikipedia.org/wiki/Self-organizing_map) (data tracing)
 *
 * \details
 * This example implements a powerful self organizing map algorithm.
 * The algorithm creates a connected network of weights that closely
 * follows the given data points. This this creates a chain of nodes that
 * resembles the given input shape.
 * \author [Krishna Vedala](https://github.com/kvedala)
 * \see kohonen_som_topology.c
 */
#define _USE_MATH_DEFINES /**< required for MS Visual C */
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP  // check if OpenMP based parallelization is available
#include <omp.h>
#endif

/**
 * @addtogroup machine_learning Machine learning algorithms
 * @{
 * @addtogroup kohonen_1d Kohonen SOM trace/chain algorithm
 * @{
 */

#ifndef max
/** shorthand for maximum value */
#define max(a, b) (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
/** shorthand for minimum value */
#define min(a, b) (((a) < (b)) ? (a) : (b))
#endif

/**
 * \brief Helper function to generate a random number in a given interval.
 * \details
 * \n Steps:
 * 1. `r1 = rand() % 100` gets a random number between 0 and 99
 * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99
 * 3. scale and offset the random number to given range of \f$[a,b)\f$
 * \f[
 * y = (b - a) \times \frac{\text{(random number between 0 and RAND_MAX)} \;
 * \text{mod}\; 100}{100} + a \f]
 *
 * \param a lower limit
 * \param b upper limit
 * \returns random number in the range \f$[a,b)\f$
 */
double _random(double a, double b)
{
    int r = rand() % 100;
    return ((b - a) * r / 100.f) + a;
}

/**
 * Save a given n-dimensional data martix to file.
 *
 * \param [in] fname filename to save in (gets overwriten without confirmation)
 * \param [in] X matrix to save
 * \param [in] num_points rows in the matrix = number of points
 * \param [in] num_features columns in the matrix = dimensions of points
 * \returns 0 if all ok
 * \returns -1 if file creation failed
 */
int save_nd_data(const char *fname, double **X, int num_points,
                 int num_features)
{
    FILE *fp = fopen(fname, "wt");
    if (!fp)  // error with fopen
    {
        char msg[120];
        sprintf(msg, "File error (%s): ", fname);
        perror(msg);
        return -1;
    }

    for (int i = 0; i < num_points; i++)  // for each point in the array
    {
        for (int j = 0; j < num_features; j++)  // for each feature in the array
        {
            fprintf(fp, "%.4g", X[i][j]);  // print the feature value
            if (j < num_features - 1)      // if not the last feature
                fprintf(fp, ",");          // suffix comma
        }
        if (i < num_points - 1)  // if not the last row
            fprintf(fp, "\n");   // start a new line
    }
    fclose(fp);
    return 0;
}

/**
 * Get minimum value and index of the value in a vector
 * \param[in] X vector to search
 * \param[in] N number of points in the vector
 * \param[out] val minimum value found
 * \param[out] idx index where minimum value was found
 */
void kohonen_get_min_1d(double const *X, int N, double *val, int *idx)
{
    val[0] = INFINITY;  // initial min value

    for (int i = 0; i < N; i++)  // check each value
    {
        if (X[i] < val[0])  // if a lower value is found
        {                   // save the value and its index
            idx[0] = i;
            val[0] = X[i];
        }
    }
}

/**
 * Update weights of the SOM using Kohonen algorithm
 *
 * \param[in] x data point
 * \param[in,out] W weights matrix
 * \param[in,out] D temporary vector to store distances
 * \param[in] num_out number of output points
 * \param[in] num_features number of features per input sample
 * \param[in] alpha learning rate \f$0<\alpha\le1\f$
 * \param[in] R neighborhood range
 */
void kohonen_update_weights(double const *x, double *const *W, double *D,
                            int num_out, int num_features, double alpha, int R)
{
    int j, k;

#ifdef _OPENMP
#pragma omp for
#endif
    // step 1: for each output point
    for (j = 0; j < num_out; j++)
    {
        D[j] = 0.f;
        // compute Euclidian distance of each output
        // point from the current sample
        for (k = 0; k < num_features; k++)
            D[j] += (W[j][k] - x[k]) * (W[j][k] - x[k]);
    }

    // step 2:  get closest node i.e., node with smallest Euclidian distance to
    // the current pattern
    int d_min_idx;
    double d_min;
    kohonen_get_min_1d(D, num_out, &d_min, &d_min_idx);

    // step 3a: get the neighborhood range
    int from_node = max(0, d_min_idx - R);
    int to_node = min(num_out, d_min_idx + R + 1);

    // step 3b: update the weights of nodes in the
    // neighborhood
#ifdef _OPENMP
#pragma omp for
#endif
    for (j = from_node; j < to_node; j++)
        for (k = 0; k < num_features; k++)
            // update weights of nodes in the neighborhood
            W[j][k] += alpha * (x[k] - W[j][k]);
}

/**
 * Apply incremental algorithm with updating neighborhood and learning rates
 * on all samples in the given datset.
 *
 * \param[in] X data set
 * \param[in,out] W weights matrix
 * \param[in] num_samples number of output points
 * \param[in] num_features number of features per input sample
 * \param[in] num_out number of output points
 * \param[in] alpha_min terminal value of alpha
 */
void kohonen_som_tracer(double **X, double *const *W, int num_samples,
                        int num_features, int num_out, double alpha_min)
{
    int R = num_out >> 2, iter = 0;
    double alpha = 1.f;
    double *D = (double *)malloc(num_out * sizeof(double));

    // Loop alpha from 1 to alpha_min
    for (; alpha > alpha_min; alpha -= 0.01, iter++)
    {
        // Loop for each sample pattern in the data set
        for (int sample = 0; sample < num_samples; sample++)
        {
            const double *x = X[sample];
            // update weights for the current input pattern sample
            kohonen_update_weights(x, W, D, num_out, num_features, alpha, R);
        }

        // every 10th iteration, reduce the neighborhood range
        if (iter % 10 == 0 && R > 1)
            R--;
    }

    free(D);
}

/**
 * @}
 * @}
 */

/** Creates a random set of points distributed *near* the circumference
 * of a circle and trains an SOM that finds that circular pattern. The
 * generating function is
 * \f{eqnarray*}{
 * r &\in& [1-\delta r, 1+\delta r)\\
 * \theta &\in& [0, 2\pi)\\
 * x &=& r\cos\theta\\
 * y &=& r\sin\theta
 * \f}
 *
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_circle(double *const *data, int N)
{
    const double R = 0.75, dr = 0.3;
    double a_t = 0., b_t = 2.f * M_PI;  // theta random between 0 and 2*pi
    double a_r = R - dr, b_r = R + dr;  // radius random between R-dr and R+dr
    int i;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        double r = _random(a_r, b_r);      // random radius
        double theta = _random(a_t, b_t);  // random theta
        data[i][0] = r * cos(theta);       // convert from polar to cartesian
        data[i][1] = r * sin(theta);
    }
}

/** Test that creates a random set of points distributed *near* the
 * circumference of a circle and trains an SOM that finds that circular pattern.
 * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)
 * files are created to validate the execution:
 * * `test1.csv`: random test samples points with a circular pattern
 * * `w11.csv`: initial random map
 * * `w12.csv`: trained SOM map
 *
 * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using
 * the following snippet
 * ```gnuplot
 * set datafile separator ','
 * plot "test1.csv" title "original", \
 *      "w11.csv" title "w1", \
 *      "w12.csv" title "w2"
 * ```
 * ![Sample execution
 * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test1.svg)
 */
void test1()
{
    int j, N = 500;
    int features = 2;
    int num_out = 50;

    // 2D space, hence size = number of rows * 2
    double **X = (double **)malloc(N * sizeof(double *));

    // number of clusters nodes * 2
    double **W = (double **)malloc(num_out * sizeof(double *));

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            W[i] = (double *)malloc(features * sizeof(double));
#ifdef _OPENMP
#pragma omp for
#endif
            // preallocate with random initial weights
            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_circle(X, N);  // create test data around circumference of a circle
    save_nd_data("test1.csv", X, N, features);  // save test data points
    save_nd_data("w11.csv", W, num_out,
                 features);  // save initial random weights
    kohonen_som_tracer(X, W, N, features, num_out, 0.1);  // train the SOM
    save_nd_data("w12.csv", W, num_out,
                 features);  // save the resultant weights

    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
}

/** Creates a random set of points distributed *near* the locus
 * of the [Lamniscate of
 * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono).
 * \f{eqnarray*}{
 * \delta r &=& 0.2\\
 * \delta x &\in& [-\delta r, \delta r)\\
 * \delta y &\in& [-\delta r, \delta r)\\
 * \theta &\in& [0, \pi)\\
 * x &=& \delta x + \cos\theta\\
 * y &=& \delta y + \frac{\sin(2\theta)}{2}
 * \f}
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_lamniscate(double *const *data, int N)
{
    const double dr = 0.2;
    int i;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        double dx = _random(-dr, dr);     // random change in x
        double dy = _random(-dr, dr);     // random change in y
        double theta = _random(0, M_PI);  // random theta
        data[i][0] = dx + cos(theta);     // convert from polar to cartesian
        data[i][1] = dy + sin(2. * theta) / 2.f;
    }
}

/** Test that creates a random set of points distributed *near* the locus
 * of the [Lamniscate of
 * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono) and trains an SOM
 * that finds that circular pattern. The following
 * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created
 * to validate the execution:
 * * `test2.csv`: random test samples points with a lamniscate pattern
 * * `w21.csv`: initial random map
 * * `w22.csv`: trained SOM map
 *
 * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using
 * the following snippet
 * ```gnuplot
 * set datafile separator ','
 * plot "test2.csv" title "original", \
 *      "w21.csv" title "w1", \
 *      "w22.csv" title "w2"
 * ```
 * ![Sample execution
 * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test2.svg)
 */
void test2()
{
    int j, N = 500;
    int features = 2;
    int num_out = 20;
    double **X = (double **)malloc(N * sizeof(double *));
    double **W = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            W[i] = (double *)malloc(features * sizeof(double));

#ifdef _OPENMP
#pragma omp for
#endif
            // preallocate with random initial weights
            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_lamniscate(X, N);  // create test data around the lamniscate
    save_nd_data("test2.csv", X, N, features);  // save test data points
    save_nd_data("w21.csv", W, num_out,
                 features);  // save initial random weights
    kohonen_som_tracer(X, W, N, features, num_out, 0.01);  // train the SOM
    save_nd_data("w22.csv", W, num_out,
                 features);  // save the resultant weights

    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
    free(X);
    free(W);
}

/** Creates a random set of points distributed in four clusters in
 * 3D space with centroids at the points
 * * \f$(0,5, 0.5, 0.5)\f$
 * * \f$(0,5,-0.5, -0.5)\f$
 * * \f$(-0,5, 0.5, 0.5)\f$
 * * \f$(-0,5,-0.5, -0.5)\f$
 *
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_3d_classes(double *const *data, int N)
{
    const double R = 0.1;  // radius of cluster
    int i;
    const int num_classes = 4;
    const double centres[][3] = {
        // centres of each class cluster
        {.5, .5, .5},    // centre of class 1
        {.5, -.5, -.5},  // centre of class 2
        {-.5, .5, .5},   // centre of class 3
        {-.5, -.5 - .5}  // centre of class 4
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        /* The follosing can also be used
        for (int j = 0; j < 3; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}

/** Test that creates a random set of points distributed in six clusters in
 * 3D space. The following
 * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created
 * to validate the execution:
 * * `test3.csv`: random test samples points with a circular pattern
 * * `w31.csv`: initial random map
 * * `w32.csv`: trained SOM map
 *
 * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using
 * the following snippet
 * ```gnuplot
 * set datafile separator ','
 * plot "test3.csv" title "original", \
 *      "w31.csv" title "w1", \
 *      "w32.csv" title "w2"
 * ```
 * ![Sample execution
 * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test3.svg)
 */
void test3()
{
    int j, N = 200;
    int features = 3;
    int num_out = 20;
    double **X = (double **)malloc(N * sizeof(double *));
    double **W = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            W[i] = (double *)malloc(features * sizeof(double));

#ifdef _OPENMP
#pragma omp for
#endif
            // preallocate with random initial weights
            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_3d_classes(X, N);  // create test data around the lamniscate
    save_nd_data("test3.csv", X, N, features);  // save test data points
    save_nd_data("w31.csv", W, num_out,
                 features);  // save initial random weights
    kohonen_som_tracer(X, W, N, features, num_out, 0.01);  // train the SOM
    save_nd_data("w32.csv", W, num_out,
                 features);  // save the resultant weights

    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
    free(X);
    free(W);
}

/**
 * Convert clock cycle difference to time in seconds
 *
 * \param[in] start_t start clock
 * \param[in] end_t end clock
 * \returns time difference in seconds
 */
double get_clock_diff(clock_t start_t, clock_t end_t)
{
    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;
}

/** Main function */
int main(int argc, char **argv)
{
#ifdef _OPENMP
    printf("Using OpenMP based parallelization\n");
#else
    printf("NOT using OpenMP based parallelization\n");
#endif
    clock_t start_clk = clock();
    test1();
    clock_t end_clk = clock();
    printf("Test 1 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));
    start_clk = clock();
    test2();
    end_clk = clock();
    printf("Test 2 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));
    start_clk = clock();
    test3();
    end_clk = clock();
    printf("Test 3 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));
    printf(
        "(Note: Calculated times include: creating test sets, training "
        "model and writing files to disk.)\n\n");
    return 0;
}
/**
 * \file
 * \brief [Kohonen self organizing
 * map](https://en.wikipedia.org/wiki/Self-organizing_map) (topological map)
 *
 * This example implements a powerful unsupervised learning algorithm called as
 * a self organizing map. The algorithm creates a connected network of weights
 * that closely follows the given data points. This thus creates a topological
 * map of the given data i.e., it maintains the relationship between various
 * data points in a much higher dimensional space by creating an equivalent in a
 * 2-dimensional space.
 * <img alt="Trained topological maps for the test cases in the program"
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/2D_Kohonen_SOM.svg"
 * />
 * \author [Krishna Vedala](https://github.com/kvedala)
 * \warning MSVC 2019 compiler generates code that does not execute as expected.
 * However, MinGW, Clang for GCC and Clang for MSVC compilers on windows perform
 * as expected. Any insights and suggestions should be directed to the author.
 * \see kohonen_som_trace.c
 */
#define _USE_MATH_DEFINES /**< required for MS Visual C */
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP  // check if OpenMP based parallellization is available
#include <omp.h>
#endif

/**
 * @addtogroup machine_learning Machine learning algorithms
 * @{
 * @addtogroup kohonen_2d Kohonen SOM topology algorithm
 * @{
 */

#ifndef max
/** shorthand for maximum value */
#define max(a, b) (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
/** shorthand for minimum value */
#define min(a, b) (((a) < (b)) ? (a) : (b))
#endif

/** to store info regarding 3D arrays */
struct kohonen_array_3d
{
    int dim1;     /**< lengths of first dimension */
    int dim2;     /**< lengths of second dimension */
    int dim3;     /**< lengths of thirddimension */
    double *data; /**< pointer to data */
};

/** Function that returns the pointer to (x, y, z) ^th location in the
 * linear 3D array given by:
 * \f[
 * X_{i,j,k} = i\times M\times N + j\times N + k
 * \f]
 * where \f$L\f$, \f$M\f$ and \f$N\f$ are the 3D matrix dimensions.
 * \param[in] arr pointer to ::kohonen_array_3d structure
 * \param[in] x     first index
 * \param[in] y     second index
 * \param[in] z     third index
 * \returns pointer to (x,y,z)^th location of data
 */
double *kohonen_data_3d(const struct kohonen_array_3d *arr, int x, int y, int z)
{
    int offset = (x * arr->dim2 * arr->dim3) + (y * arr->dim3) + z;
    return arr->data + offset;
}

/**
 * Helper function to generate a random number in a given interval.
 * \n Steps:
 * 1. `r1 = rand() % 100` gets a random number between 0 and 99
 * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99
 * 3. scale and offset the random number to given range of \f$[a,b)\f$
 * \f[
 * y = (b - a) \times \frac{\text{(random number between 0 and RAND_MAX)} \;
 * \text{mod}\; 100}{100} + a \f]
 *
 * \param[in] a lower limit
 * \param[in] b upper limit
 * \returns random number in the range \f$[a,b)\f$
 */
double _random(double a, double b)
{
    return ((b - a) * (rand() % 100) / 100.f) + a;
}

/**
 * Save a given n-dimensional data martix to file.
 *
 * \param[in] fname filename to save in (gets overwritten without confirmation)
 * \param[in] X matrix to save
 * \param[in] num_points rows in the matrix = number of points
 * \param[in] num_features columns in the matrix = dimensions of points
 * \returns 0 if all ok
 * \returns -1 if file creation failed
 */
int save_2d_data(const char *fname, double **X, int num_points,
                 int num_features)
{
    FILE *fp = fopen(fname, "wt");
    if (!fp)  // error with fopen
    {
        char msg[120];
        sprintf(msg, "File error (%s): ", fname);
        perror(msg);
        return -1;
    }

    for (int i = 0; i < num_points; i++)  // for each point in the array
    {
        for (int j = 0; j < num_features; j++)  // for each feature in the array
        {
            fprintf(fp, "%.4g", X[i][j]);  // print the feature value
            if (j < num_features - 1)      // if not the last feature
                fputc(',', fp);            // suffix comma
        }
        if (i < num_points - 1)  // if not the last row
            fputc('\n', fp);     // start a new line
    }
    fclose(fp);
    return 0;
}

/**
 * Create the distance matrix or
 * [U-matrix](https://en.wikipedia.org/wiki/U-matrix) from the trained weights
 * and save to disk.
 *
 * \param [in] fname filename to save in (gets overwriten without confirmation)
 * \param [in] W model matrix to save
 * \returns 0 if all ok
 * \returns -1 if file creation failed
 */
int save_u_matrix(const char *fname, struct kohonen_array_3d *W)
{
    FILE *fp = fopen(fname, "wt");
    if (!fp)  // error with fopen
    {
        char msg[120];
        sprintf(msg, "File error (%s): ", fname);
        perror(msg);
        return -1;
    }

    int R = max(W->dim1 >> 3, 2); /* neighborhood range */

    for (int i = 0; i < W->dim1; i++)  // for each x
    {
        for (int j = 0; j < W->dim2; j++)  // for each y
        {
            double distance = 0.f;
            int k;

            int from_x = max(0, i - R);
            int to_x = min(W->dim1, i + R + 1);
            int from_y = max(0, j - R);
            int to_y = min(W->dim2, j + R + 1);
            int l;
#ifdef _OPENMP
#pragma omp parallel for reduction(+ : distance)
#endif
            for (l = from_x; l < to_x; l++)  // scan neighborhoor in x
            {
                for (int m = from_y; m < to_y; m++)  // scan neighborhood in y
                {
                    double d = 0.f;
                    for (k = 0; k < W->dim3; k++)  // for each feature
                    {
                        double *w1 = kohonen_data_3d(W, i, j, k);
                        double *w2 = kohonen_data_3d(W, l, m, k);
                        d += (w1[0] - w2[0]) * (w1[0] - w2[0]);
                        // distance += w1[0] * w1[0];
                    }
                    distance += sqrt(d);
                    // distance += d;
                }
            }

            distance /= R * R;              // mean distance from neighbors
            fprintf(fp, "%.4g", distance);  // print the mean separation
            if (j < W->dim2 - 1)            // if not the last column
                fputc(',', fp);             // suffix comma
        }
        if (i < W->dim1 - 1)  // if not the last row
            fputc('\n', fp);  // start a new line
    }
    fclose(fp);
    return 0;
}

/**
 * Get minimum value and index of the value in a matrix
 * \param[in] X matrix to search
 * \param[in] N number of points in the vector
 * \param[out] val minimum value found
 * \param[out] x_idx x-index where minimum value was found
 * \param[out] y_idx y-index where minimum value was found
 */
void get_min_2d(double **X, int N, double *val, int *x_idx, int *y_idx)
{
    val[0] = INFINITY;  // initial min value

    for (int i = 0; i < N; i++)  // traverse each x-index
    {
        for (int j = 0; j < N; j++)  // traverse each y-index
        {
            if (X[i][j] < val[0])  // if a lower value is found
            {                      // save the value and its index
                x_idx[0] = i;
                y_idx[0] = j;
                val[0] = X[i][j];
            }
        }
    }
}

/**
 * Update weights of the SOM using Kohonen algorithm
 *
 * \param[in] X data point
 * \param[in,out] W weights matrix
 * \param[in,out] D temporary vector to store distances
 * \param[in] num_out number of output points
 * \param[in] num_features number of features per input sample
 * \param[in] alpha learning rate \f$0<\alpha\le1\f$
 * \param[in] R neighborhood range
 * \returns minimum distance of sample and trained weights
 */
double kohonen_update_weights(const double *X, struct kohonen_array_3d *W,
                              double **D, int num_out, int num_features,
                              double alpha, int R)
{
    int x, y, k;
    double d_min = 0.f;

#ifdef _OPENMP
#pragma omp for
#endif
    // step 1: for each 2D output point
    for (x = 0; x < num_out; x++)
    {
        for (y = 0; y < num_out; y++)
        {
            D[x][y] = 0.f;
            // compute Euclidian distance of each output
            // point from the current sample
            for (k = 0; k < num_features; k++)
            {
                double *w = kohonen_data_3d(W, x, y, k);
                D[x][y] += (w[0] - X[k]) * (w[0] - X[k]);
            }
            D[x][y] = sqrt(D[x][y]);
        }
    }

    // step 2:  get closest node i.e., node with smallest Euclidian distance to
    // the current pattern
    int d_min_x, d_min_y;
    get_min_2d(D, num_out, &d_min, &d_min_x, &d_min_y);

    // step 3a: get the neighborhood range
    int from_x = max(0, d_min_x - R);
    int to_x = min(num_out, d_min_x + R + 1);
    int from_y = max(0, d_min_y - R);
    int to_y = min(num_out, d_min_y + R + 1);

    // step 3b: update the weights of nodes in the
    // neighborhood
#ifdef _OPENMP
#pragma omp for
#endif
    for (x = from_x; x < to_x; x++)
    {
        for (y = from_y; y < to_y; y++)
        {
            /* you can enable the following normalization if needed.
               personally, I found it detrimental to convergence */
            // const double s2pi = sqrt(2.f * M_PI);
            // double normalize = 1.f / (alpha * s2pi);

            /* apply scaling inversely proportional to distance from the
               current node */
            double d2 =
                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);
            double scale_factor = exp(-d2 / (2.f * alpha * alpha));

            for (k = 0; k < num_features; k++)
            {
                double *w = kohonen_data_3d(W, x, y, k);
                // update weights of nodes in the neighborhood
                w[0] += alpha * scale_factor * (X[k] - w[0]);
            }
        }
    }
    return d_min;
}

/**
 * Apply incremental algorithm with updating neighborhood and learning rates
 * on all samples in the given datset.
 *
 * \param[in] X data set
 * \param[in,out] W weights matrix
 * \param[in] num_samples number of output points
 * \param[in] num_features number of features per input sample
 * \param[in] num_out number of output points
 * \param[in] alpha_min terminal value of alpha
 */
void kohonen_som(double **X, struct kohonen_array_3d *W, int num_samples,
                 int num_features, int num_out, double alpha_min)
{
    int R = num_out >> 2, iter = 0;
    double **D = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < num_out; i++)
        D[i] = (double *)malloc(num_out * sizeof(double));

    double dmin = 1.f;  // average minimum distance of all samples

    // Loop alpha from 1 to slpha_min
    for (double alpha = 1.f; alpha > alpha_min && dmin > 1e-3;
         alpha -= 0.001, iter++)
    {
        dmin = 0.f;
        // Loop for each sample pattern in the data set
        for (int sample = 0; sample < num_samples; sample++)
        {
            // update weights for the current input pattern sample
            dmin += kohonen_update_weights(X[sample], W, D, num_out,
                                           num_features, alpha, R);
        }

        // every 20th iteration, reduce the neighborhood range
        if (iter % 100 == 0 && R > 1)
            R--;

        dmin /= num_samples;
        printf("iter: %5d\t alpha: %.4g\t R: %d\td_min: %.4g\r", iter, alpha, R,
               dmin);
    }
    putchar('\n');

    for (int i = 0; i < num_out; i++) free(D[i]);
    free(D);
}

/**
 * @}
 * @}
 */

/** Creates a random set of points distributed in four clusters in
 * 3D space with centroids at the points
 * * \f$(0,5, 0.5, 0.5)\f$
 * * \f$(0,5,-0.5, -0.5)\f$
 * * \f$(-0,5, 0.5, 0.5)\f$
 * * \f$(-0,5,-0.5, -0.5)\f$
 *
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_2d_classes(double *const *data, int N)
{
    const double R = 0.3;  // radius of cluster
    int i;
    const int num_classes = 4;
    const double centres[][2] = {
        // centres of each class cluster
        {.5, .5},   // centre of class 1
        {.5, -.5},  // centre of class 2
        {-.5, .5},  // centre of class 3
        {-.5, -.5}  // centre of class 4
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);

        /* The follosing can also be used
        for (int j = 0; j < 2; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}

/** Test that creates a random set of points distributed in four clusters in
 * 2D space and trains an SOM that finds the topological pattern.
 * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)
 * files are created to validate the execution:
 * * `test1.csv`: random test samples points with a circular pattern
 * * `w11.csv`: initial random U-matrix
 * * `w12.csv`: trained SOM U-matrix
 */
void test1()
{
    int j, N = 300;
    int features = 2;
    int num_out = 30;  // image size - N x N

    // 2D space, hence size = number of rows * 2
    double **X = (double **)malloc(N * sizeof(double *));

    // cluster nodex in 'x' * cluster nodes in 'y' * 2
    struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  // assign rows

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                // preallocate with random initial weights
                for (j = 0; j < features; j++)
                {
                    double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_2d_classes(X, N);  // create test data around circumference of a circle
    save_2d_data("test1.csv", X, N, features);  // save test data points
    save_u_matrix("w11.csv", &W);               // save initial random weights
    kohonen_som(X, &W, N, features, num_out, 1e-4);  // train the SOM
    save_u_matrix("w12.csv", &W);  // save the resultant weights

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}

/** Creates a random set of points distributed in four clusters in
 * 3D space with centroids at the points
 * * \f$(0,5, 0.5, 0.5)\f$
 * * \f$(0,5,-0.5, -0.5)\f$
 * * \f$(-0,5, 0.5, 0.5)\f$
 * * \f$(-0,5,-0.5, -0.5)\f$
 *
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_3d_classes1(double *const *data, int N)
{
    const double R = 0.2;  // radius of cluster
    int i;
    const int num_classes = 4;
    const double centres[][3] = {
        // centres of each class cluster
        {.5, .5, .5},    // centre of class 1
        {.5, -.5, -.5},  // centre of class 2
        {-.5, .5, .5},   // centre of class 3
        {-.5, -.5 - .5}  // centre of class 4
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        /* The follosing can also be used
        for (int j = 0; j < 3; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}

/** Test that creates a random set of points distributed in 4 clusters in
 * 3D space and trains an SOM that finds the topological pattern. The following
 * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created
 * to validate the execution:
 * * `test2.csv`: random test samples points
 * * `w21.csv`: initial random U-matrix
 * * `w22.csv`: trained SOM U-matrix
 */
void test2()
{
    int j, N = 500;
    int features = 3;
    int num_out = 30;  // image size - N x N

    // 3D space, hence size = number of rows * 3
    double **X = (double **)malloc(N * sizeof(double *));

    // cluster nodex in 'x' * cluster nodes in 'y' * 2
    struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  // assign rows

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                for (j = 0; j < features; j++)
                {  // preallocate with random initial weights
                    double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_3d_classes1(X, N);                     // create test data
    save_2d_data("test2.csv", X, N, features);  // save test data points
    save_u_matrix("w21.csv", &W);               // save initial random weights
    kohonen_som(X, &W, N, features, num_out, 1e-4);  // train the SOM
    save_u_matrix("w22.csv", &W);  // save the resultant weights

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}

/** Creates a random set of points distributed in four clusters in
 * 3D space with centroids at the points
 * * \f$(0,5, 0.5, 0.5)\f$
 * * \f$(0,5,-0.5, -0.5)\f$
 * * \f$(-0,5, 0.5, 0.5)\f$
 * * \f$(-0,5,-0.5, -0.5)\f$
 *
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_3d_classes2(double *const *data, int N)
{
    const double R = 0.2;  // radius of cluster
    int i;
    const int num_classes = 8;
    const double centres[][3] = {
        // centres of each class cluster
        {.5, .5, .5},    // centre of class 1
        {.5, .5, -.5},   // centre of class 2
        {.5, -.5, .5},   // centre of class 3
        {.5, -.5, -.5},  // centre of class 4
        {-.5, .5, .5},   // centre of class 5
        {-.5, .5, -.5},  // centre of class 6
        {-.5, -.5, .5},  // centre of class 7
        {-.5, -.5, -.5}  // centre of class 8
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        /* The follosing can also be used
        for (int j = 0; j < 3; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}

/** Test that creates a random set of points distributed in eight clusters in
 * 3D space and trains an SOM that finds the topological pattern. The following
 * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created
 * to validate the execution:
 * * `test3.csv`: random test samples points
 * * `w31.csv`: initial random U-matrix
 * * `w32.csv`: trained SOM U-matrix
 */
void test3()
{
    int j, N = 500;
    int features = 3;
    int num_out = 30;
    double **X = (double **)malloc(N * sizeof(double *));

    // cluster nodex in 'x' * cluster nodes in 'y' * 2
    struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  // assign rows

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                // preallocate with random initial weights
                for (j = 0; j < features; j++)
                {
                    double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_3d_classes2(X, N);  // create test data around the lamniscate
    save_2d_data("test3.csv", X, N, features);  // save test data points
    save_u_matrix("w31.csv", &W);               // save initial random weights
    kohonen_som(X, &W, N, features, num_out, 0.01);  // train the SOM
    save_u_matrix("w32.csv", &W);  // save the resultant weights

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}

/**
 * Convert clock cycle difference to time in seconds
 *
 * \param[in] start_t start clock
 * \param[in] end_t end clock
 * \returns time difference in seconds
 */
double get_clock_diff(clock_t start_t, clock_t end_t)
{
    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;
}

/** Main function */
int main(int argc, char **argv)
{
#ifdef _OPENMP
    printf("Using OpenMP based parallelization\n");
#else
    printf("NOT using OpenMP based parallelization\n");
#endif
    clock_t start_clk, end_clk;

    start_clk = clock();
    test1();
    end_clk = clock();
    printf("Test 1 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));

    start_clk = clock();
    test2();
    end_clk = clock();
    printf("Test 2 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));

    start_clk = clock();
    test3();
    end_clk = clock();
    printf("Test 3 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));

    printf("(Note: Calculated times include: writing files to disk.)\n\n");
    return 0;
}
/**
 * \file
 * \brief [Adaptive Linear Neuron
 * (ADALINE)](https://en.wikipedia.org/wiki/ADALINE) implementation
 * \details
 * <img
 * src="https://upload.wikimedia.org/wikipedia/commons/b/be/Adaline_flow_chart.gif"
 * width="200px">
 * [source](https://commons.wikimedia.org/wiki/File:Adaline_flow_chart.gif)
 * ADALINE is one of the first and simplest single layer artificial neural
 * network. The algorithm essentially implements a linear function
 * \f[ f\left(x_0,x_1,x_2,\ldots\right) =
 * \sum_j x_jw_j+\theta
 * \f]
 * where \f$x_j\f$ are the input features of a sample, \f$w_j\f$ are the
 * coefficients of the linear function and \f$\theta\f$ is a constant. If we
 * know the \f$w_j\f$, then for any given set of features, \f$y\f$ can be
 * computed. Computing the \f$w_j\f$ is a supervised learning algorithm wherein
 * a set of features and their corresponding outputs are given and weights are
 * computed using stochastic gradient descent method.
 * \author [Krishna Vedala](https://github.com/kvedala)
 */

#include <assert.h>
#include <limits.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * @addtogroup machine_learning Machine learning algorithms
 * @{
 * @addtogroup adaline Adaline learning algorithm
 * @{
 */

/** Maximum number of iterations to learn */
#define MAX_ADALINE_ITER 500  // INT_MAX

/** structure to hold adaline model parameters */
struct adaline
{
    double eta;      /**< learning rate of the algorithm */
    double *weights; /**< weights of the neural network */
    int num_weights; /**< number of weights of the neural network */
};

/** convergence accuracy \f$=1\times10^{-5}\f$ */
#define ADALINE_ACCURACY 1e-5

/**
 * Default constructor
 * \param[in] num_features number of features present
 * \param[in] eta learning rate (optional, default=0.1)
 * \returns new adaline model
 */
struct adaline new_adaline(const int num_features, const double eta)
{
    if (eta <= 0.f || eta >= 1.f)
    {
        fprintf(stderr, "learning rate should be > 0 and < 1\n");
        exit(EXIT_FAILURE);
    }

    // additional weight is for the constant bias term
    int num_weights = num_features + 1;
    struct adaline ada;
    ada.eta = eta;
    ada.num_weights = num_weights;
    ada.weights = (double *)malloc(num_weights * sizeof(double));
    if (!ada.weights)
    {
        perror("Unable to allocate error for weights!");
        return ada;
    }

    // initialize with random weights in the range [-50, 49]
    for (int i = 0; i < num_weights; i++) ada.weights[i] = 1.f;
    // ada.weights[i] = (double)(rand() % 100) - 50);

    return ada;
}

/** delete dynamically allocated memory
 * \param[in] ada model from which the memory is to be freed.
 */
void delete_adaline(struct adaline *ada)
{
    if (ada == NULL)
        return;

    free(ada->weights);
};

/** [Heaviside activation
 * function](https://en.wikipedia.org/wiki/Heaviside_step_function) <img
 * src="https://upload.wikimedia.org/wikipedia/commons/d/d9/Dirac_distribution_CDF.svg"
 * width="200px"/>
 * @param x activation function input
 * @returns \f$f(x)= \begin{cases}1 & \forall\; x > 0\\ -1 & \forall\; x \le0
 * \end{cases}\f$
 */
int adaline_activation(double x) { return x > 0 ? 1 : -1; }

/**
 * Operator to print the weights of the model
 * @param ada model for which the values to print
 * @returns pointer to a NULL terminated string of formatted weights
 */
char *adaline_get_weights_str(const struct adaline *ada)
{
    static char out[100];  // static so the value is persistent

    sprintf(out, "<");
    for (int i = 0; i < ada->num_weights; i++)
    {
        sprintf(out, "%s%.4g", out, ada->weights[i]);
        if (i < ada->num_weights - 1)
            sprintf(out, "%s, ", out);
    }
    sprintf(out, "%s>", out);
    return out;
}

/**
 * predict the output of the model for given set of features
 *
 * \param[in] ada adaline model to predict
 * \param[in] x input vector
 * \param[out] out optional argument to return neuron output before applying
 * activation function (`NULL` to ignore)
 * \returns model prediction output
 */
int adaline_predict(struct adaline *ada, const double *x, double *out)
{
    double y = ada->weights[ada->num_weights - 1];  // assign bias value

    for (int i = 0; i < ada->num_weights - 1; i++) y += x[i] * ada->weights[i];

    if (out)  // if out variable is not NULL
        *out = y;

    // quantizer: apply ADALINE threshold function
    return adaline_activation(y);
}

/**
 * Update the weights of the model using supervised learning for one feature
 * vector
 *
 * \param[in] ada adaline model to fit
 * \param[in] x feature vector
 * \param[in] y known output  value
 * \returns correction factor
 */
double adaline_fit_sample(struct adaline *ada, const double *x, const int y)
{
    /* output of the model with current weights */
    int p = adaline_predict(ada, x, NULL);
    int prediction_error = y - p;  // error in estimation
    double correction_factor = ada->eta * prediction_error;

    /* update each weight, the last weight is the bias term */
    for (int i = 0; i < ada->num_weights - 1; i++)
    {
        ada->weights[i] += correction_factor * x[i];
    }
    ada->weights[ada->num_weights - 1] += correction_factor;  // update bias

    return correction_factor;
}

/**
 * Update the weights of the model using supervised learning for an array of
 * vectors.
 *
 * \param[in] ada adaline model to train
 * \param[in] X array of feature vector
 * \param[in] y known output value for each feature vector
 * \param[in] N number of training samples
 */
void adaline_fit(struct adaline *ada, double **X, const int *y, const int N)
{
    double avg_pred_error = 1.f;

    int iter;
    for (iter = 0;
         (iter < MAX_ADALINE_ITER) && (avg_pred_error > ADALINE_ACCURACY);
         iter++)
    {
        avg_pred_error = 0.f;

        // perform fit for each sample
        for (int i = 0; i < N; i++)
        {
            double err = adaline_fit_sample(ada, X[i], y[i]);
            avg_pred_error += fabs(err);
        }
        avg_pred_error /= N;

        // Print updates every 200th iteration
        // if (iter % 100 == 0)
        printf("\tIter %3d: Training weights: %s\tAvg error: %.4f\n", iter,
               adaline_get_weights_str(ada), avg_pred_error);
    }

    if (iter < MAX_ADALINE_ITER)
        printf("Converged after %d iterations.\n", iter);
    else
        printf("Did not converged after %d iterations.\n", iter);
}

/** @}
 *  @}
 */

/**
 * test function to predict points in a 2D coordinate system above the line
 * \f$x=y\f$ as +1 and others as -1.
 * Note that each point is defined by 2 values or 2 features.
 * \param[in] eta learning rate (optional, default=0.01)
 */
void test1(double eta)
{
    struct adaline ada = new_adaline(2, eta);  // 2 features

    const int N = 10;  // number of sample points
    const double saved_X[10][2] = {{0, 1},  {1, -2},   {2, 3},   {3, -1},
                                   {4, 1},  {6, -5},   {-7, -3}, {-8, 5},
                                   {-9, 2}, {-10, -15}};

    double **X = (double **)malloc(N * sizeof(double *));
    const int Y[10] = {1,  -1, 1, -1, -1,
                       -1, 1,  1, 1,  -1};  // corresponding y-values
    for (int i = 0; i < N; i++)
    {
        X[i] = (double *)saved_X[i];
    }

    printf("------- Test 1 -------\n");
    printf("Model before fit: %s\n", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf("Model after fit: %s\n", adaline_get_weights_str(&ada));

    double test_x[] = {5, -3};
    int pred = adaline_predict(&ada, test_x, NULL);
    printf("Predict for x=(5,-3): % d\n", pred);
    assert(pred == -1);
    printf(" ...passed\n");

    double test_x2[] = {5, 8};
    pred = adaline_predict(&ada, test_x2, NULL);
    printf("Predict for x=(5, 8): % d\n", pred);
    assert(pred == 1);
    printf(" ...passed\n");

    // for (int i = 0; i < N; i++)
    //     free(X[i]);
    free(X);
    delete_adaline(&ada);
}

/**
 * test function to predict points in a 2D coordinate system above the line
 * \f$x+3y=-1\f$ as +1 and others as -1.
 * Note that each point is defined by 2 values or 2 features.
 * The function will create random sample points for training and test purposes.
 * \param[in] eta learning rate (optional, default=0.01)
 */
void test2(double eta)
{
    struct adaline ada = new_adaline(2, eta);  // 2 features

    const int N = 50;  // number of sample points

    double **X = (double **)malloc(N * sizeof(double *));
    int *Y = (int *)malloc(N * sizeof(int));  // corresponding y-values
    for (int i = 0; i < N; i++) X[i] = (double *)malloc(2 * sizeof(double));

    // generate sample points in the interval
    // [-range2/100 , (range2-1)/100]
    int range = 500;          // sample points full-range
    int range2 = range >> 1;  // sample points half-range
    for (int i = 0; i < N; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        X[i][0] = x0;
        X[i][1] = x1;
        Y[i] = (x0 + 3. * x1) > -1 ? 1 : -1;
    }

    printf("------- Test 2 -------\n");
    printf("Model before fit: %s\n", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf("Model after fit: %s\n", adaline_get_weights_str(&ada));

    int N_test_cases = 5;
    double test_x[2];
    for (int i = 0; i < N_test_cases; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;

        test_x[0] = x0;
        test_x[1] = x1;
        int pred = adaline_predict(&ada, test_x, NULL);
        printf("Predict for x=(% 3.2f,% 3.2f): % d\n", x0, x1, pred);

        int expected_val = (x0 + 3. * x1) > -1 ? 1 : -1;
        assert(pred == expected_val);
        printf(" ...passed\n");
    }

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(Y);
    delete_adaline(&ada);
}

/**
 * test function to predict points in a 3D coordinate system lying within the
 * sphere of radius 1 and centre at origin as +1 and others as -1. Note that
 * each point is defined by 3 values but we use 6 features. The function will
 * create random sample points for training and test purposes.
 * The sphere centred at origin and radius 1 is defined as:
 * \f$x^2+y^2+z^2=r^2=1\f$ and if the \f$r^2<1\f$, point lies within the sphere
 * else, outside.
 *
 * \param[in] eta learning rate (optional, default=0.01)
 */
void test3(double eta)
{
    struct adaline ada = new_adaline(6, eta);  // 2 features

    const int N = 50;  // number of sample points

    double **X = (double **)malloc(N * sizeof(double *));
    int *Y = (int *)malloc(N * sizeof(int));  // corresponding y-values
    for (int i = 0; i < N; i++) X[i] = (double *)malloc(6 * sizeof(double));

    // generate sample points in the interval
    // [-range2/100 , (range2-1)/100]
    int range = 200;          // sample points full-range
    int range2 = range >> 1;  // sample points half-range
    for (int i = 0; i < N; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        double x2 = ((rand() % range) - range2) / 100.f;
        X[i][0] = x0;
        X[i][1] = x1;
        X[i][2] = x2;
        X[i][3] = x0 * x0;
        X[i][4] = x1 * x1;
        X[i][5] = x2 * x2;
        Y[i] = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;
    }

    printf("------- Test 3 -------\n");
    printf("Model before fit: %s\n", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf("Model after fit: %s\n", adaline_get_weights_str(&ada));

    int N_test_cases = 5;
    double test_x[6];
    for (int i = 0; i < N_test_cases; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        double x2 = ((rand() % range) - range2) / 100.f;
        test_x[0] = x0;
        test_x[1] = x1;
        test_x[2] = x2;
        test_x[3] = x0 * x0;
        test_x[4] = x1 * x1;
        test_x[5] = x2 * x2;
        int pred = adaline_predict(&ada, test_x, NULL);
        printf("Predict for x=(% 3.2f,% 3.2f): % d\n", x0, x1, pred);

        int expected_val = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;
        assert(pred == expected_val);
        printf(" ...passed\n");
    }

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(Y);
    delete_adaline(&ada);
}

/** Main function */
int main(int argc, char **argv)
{
    srand(time(NULL));  // initialize random number generator

    double eta = 0.1;  // default value of eta
    if (argc == 2)     // read eta value from commandline argument if present
        eta = strtof(argv[1], NULL);

    test1(eta);

    printf("Press ENTER to continue...\n");
    getchar();

    test2(eta);

    printf("Press ENTER to continue...\n");
    getchar();

    test3(eta);

    return 0;
}
/**
 * @file
 * \brief Program to compute the [QR
 * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given
 * matrix.
 * \author [Krishna Vedala](https://github.com/kvedala)
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "qr_decompose.h"

/**
 * main function
 */
int main(void)
{
    double **A;
    unsigned int ROWS, COLUMNS;

    printf("Enter the number of rows and columns: ");
    scanf("%u %u", &ROWS, &COLUMNS);
    if (ROWS < COLUMNS)
    {
        fprintf(stderr,
                "Number of rows must be greater than or equal to "
                "number of columns.\n");
        return -1;
    }

    printf("Enter matrix elements row-wise:\n");

    A = (double **)malloc(ROWS * sizeof(double *));
    for (int i = 0; i < ROWS; i++)
        A[i] = (double *)malloc(COLUMNS * sizeof(double));

    for (int i = 0; i < ROWS; i++)
        for (int j = 0; j < COLUMNS; j++) scanf("%lf", &A[i][j]);

    print_matrix(A, ROWS, COLUMNS);

    double **R = (double **)malloc(sizeof(double *) * ROWS);
    double **Q = (double **)malloc(sizeof(double *) * ROWS);
    if (!Q || !R)
    {
        perror("Unable to allocate memory for Q & R!");
        return -1;
    }
    for (int i = 0; i < ROWS; i++)
    {
        R[i] = (double *)malloc(sizeof(double) * COLUMNS);
        Q[i] = (double *)malloc(sizeof(double) * ROWS);
        if (!Q[i] || !R[i])
        {
            perror("Unable to allocate memory for Q & R.");
            return -1;
        }
    }

    clock_t t1 = clock();
    qr_decompose(A, Q, R, ROWS, COLUMNS);
    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;

    print_matrix(R, ROWS, COLUMNS);
    print_matrix(Q, ROWS, COLUMNS);
    printf("Time taken to compute: %.4g sec\n", dtime);

    for (int i = 0; i < ROWS; i++)
    {
        free(A[i]);
        free(R[i]);
        free(Q[i]);
    }
    free(A);
    free(R);
    free(Q);
    return 0;
}
/**
 * \file
 * \authors [Krishna Vedala](https://github.com/kvedala)
 * \brief Solve a multivariable first order [ordinary differential equation
 * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using
 * [midpoint Euler
 * method](https://en.wikipedia.org/wiki/Midpoint_method)
 *
 * \details
 * The ODE being solved is:
 * \f{eqnarray*}{
 * \dot{u} &=& v\\
 * \dot{v} &=& -\omega^2 u\\
 * \omega &=& 1\\
 * [x_0, u_0, v_0] &=& [0,1,0]\qquad\ldots\text{(initial values)}
 * \f}
 * The exact solution for the above problem is:
 * \f{eqnarray*}{
 * u(x) &=& \cos(x)\\
 * v(x) &=& -\sin(x)\\
 * \f}
 * The computation results are stored to a text file `midpoint_euler.csv` and
 * the exact soltuion results in `exact.csv` for comparison. <img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_midpoint_euler.svg"
 * alt="Implementation solution"/>
 *
 * To implement [Van der Pol
 * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the
 * ::problem function to:
 * ```cpp
 * const double mu = 2.0;
 * dy[0] = y[1];
 * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];
 * ```
 * \see ode_forward_euler.c, ode_semi_implicit_euler.c
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define order 2 /**< number of dependent variables in ::problem */

/**
 * @brief Problem statement for a system with first-order differential
 * equations. Updates the system differential variables.
 * \note This function can be updated to and ode of any order.
 *
 * @param[in] 		x 		independent variable(s)
 * @param[in,out]	y		dependent variable(s)
 * @param[in,out]	dy	    first-derivative of dependent variable(s)
 */
void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;       // some const for the problem
    dy[0] = y[1];                   // x dot
    dy[1] = -omega * omega * y[0];  // y dot
}

/**
 * @brief Exact solution of the problem. Used for solution comparison.
 *
 * @param[in] 		x 		independent variable
 * @param[in,out]	y		dependent variable
 */
void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}

/**
 * @brief Compute next step approximation using the midpoint-Euler
 * method.
 * @f[y_{n+1} = y_n + dx\, f\left(x_n+\frac{1}{2}dx,
 * y_n + \frac{1}{2}dx\,f\left(x_n,y_n\right)\right)@f]
 * @param[in] 		dx	step size
 * @param[in,out] 	x	take @f$x_n@f$ and compute @f$x_{n+1}@f$
 * @param[in,out] 	y	take @f$y_n@f$ and compute @f$y_{n+1}@f$
 * @param[in,out]	dy	compute @f$y_n+\frac{1}{2}dx\,f\left(x_n,y_n\right)@f$
 */
void midpoint_euler_step(double dx, double *x, double *y, double *dy)
{
    problem(x, y, dy);
    double tmp_x = (*x) + 0.5 * dx;
    double tmp_y[order];
    int o;
    for (o = 0; o < order; o++) tmp_y[o] = y[o] + 0.5 * dx * dy[o];

    problem(&tmp_x, tmp_y, dy);

    for (o = 0; o < order; o++) y[o] += dx * dy[o];
}

/**
 * @brief Compute approximation using the midpoint-Euler
 * method in the given limits.
 * @param[in] 		dx  	step size
 * @param[in]   	x0  	initial value of independent variable
 * @param[in] 	    x_max	final value of independent variable
 * @param[in,out] 	y	    take \f$y_n\f$ and compute \f$y_{n+1}\f$
 * @param[in] save_to_file	flag to save results to a CSV file (1) or not (0)
 * @returns time taken for computation in seconds
 */
double midpoint_euler(double dx, double x0, double x_max, double *y,
                      char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen("midpoint_euler.csv", "w+");
        if (fp == NULL)
        {
            perror("Error! ");
            return -1;
        }
    }

    /* start integration */
    clock_t t1 = clock();
    double x = x0;
    do  // iterate for each step of independent variable
    {
        if (save_to_file && fp)
            fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        midpoint_euler_step(dx, &x, y, dy);  // perform integration
        x += dx;                             // update step
    } while (x <= x_max);  // till upper limit of independent variable
    /* end of integration */
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}

/**
    Main Function
*/
int main(int argc, char *argv[])
{
    double X0 = 0.f;          /* initial value of x0 */
    double X_MAX = 10.F;      /* upper limit of integration */
    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */
    double step_size;

    if (argc == 1)
    {
        printf("\nEnter the step size: ");
        scanf("%lg", &step_size);
    }
    else
        // use commandline argument as independent variable step size
        step_size = atof(argv[1]);

    // get approximate solution
    double total_time = midpoint_euler(step_size, X0, X_MAX, Y0, 1);
    printf("\tTime = %.6g ms\n", total_time);

    /* compute exact solution for comparion */
    FILE *fp = fopen("exact.csv", "w+");
    if (fp == NULL)
    {
        perror("Error! ");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf("Finding exact solution\n");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf("\tTime = %.6g ms\n", total_time);
    fclose(fp);

    return 0;
}
#include <math.h>
#include <stdio.h>

#define ARRAY_SIZE 20

void display(float a[ARRAY_SIZE][ARRAY_SIZE], int n)
{
    int i, j;
    for (i = 0; i < n; i++)
    {
        for (j = 0; j <= n; j++)
        {
            printf("%.2f \t", a[i][j]);
        }
        printf("\n");
    }
}

float interchange(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)
{
    float tmp[ARRAY_SIZE][ARRAY_SIZE];
    float max = fabs(m[i][i]);
    int j, k = i;

    for (j = i; j < n; j++)
    {
        if (max < fabs(m[j][i]))
        {
            max = fabs(m[j][i]);
            k = j;
        }
    }
    for (j = 0; j <= n; j++)
    {
        tmp[i][j] = m[i][j];
        m[i][j] = m[k][j];
        m[k][j] = tmp[i][j];
    }
    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];
}
float eliminate(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)
{
    float tmp;
    int k = 1, l, j;
    for (j = i; j < n - 1; j++)
    {
        tmp = -((m[i + k][i]) / (m[i][i]));
        for (l = 0; l <= n; l++)
        {
            m[i + k][l] = (m[i + k][l]) + (m[i][l] * tmp);
        }
        k++;
    }
    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];
}
int main(void)
{
    int i, j, n, k = 0, l;
    float m[ARRAY_SIZE][ARRAY_SIZE], mul, tmp[ARRAY_SIZE][ARRAY_SIZE], val,
        ans[ARRAY_SIZE];

    printf("Total No.of Equations : ");
    scanf("%d", &n);

    printf("\n");
    for (i = 0; i < n; i++)
    {
        printf("Enter Co-efficient Of Equations %d & Total --->>>\n", i + 1);
        for (j = 0; j <= n; j++)
        {
            printf("r%d%d : ", i, j);
            scanf("%f", &m[i][j]);
        }
        printf("\n");
    }
    printf(":::::::::::: Current Matrix ::::::::::::\n\n");
    display(m, n);

    for (i = 0; i < n - 1; i++)
    {
        printf("\n------->>>>>>>>>>>>>>>>>>>>>>>>-------- %d\n", i + 1);
        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = interchange(m, i, n);
        display(m, n);
        printf("\n_______________________________________\n");
        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = eliminate(m, i, n);
        display(m, n);
    }
    printf("\n\n Values are : \n");
    for (i = n - 1; i >= 0; i--)
    {
        l = n - 1;
        mul = 0;
        for (j = 0; j < k; j++)
        {
            mul = mul + m[i][l] * ans[l];
            l--;
        }
        k++;
        ans[i] = (m[i][n] - mul) / m[i][i];
        printf("X%d = %.2f\n", i + 1, ans[i]);
    }

    return 0;
}
/**
 * \file
 * \brief Compute statistics for data entered in rreal-time
 * \author [Krishna Vedala](https://github.com/kvedala)
 *
 * This algorithm is really beneficial to compute statistics on data read in
 * realtime. For example, devices reading biometrics data. The algorithm is
 * simple enough to be easily implemented in an embedded system.
 */
#include <assert.h>
#include <math.h>
#include <stdio.h>

/**
 * continuous mean and variance computance using
 * first value as an approximation for the mean.
 * If the first number is much far form the mean, the algorithm becomes very
 * inaccurate to compute variance and standard deviation.
 * \param[in] x new value added to data set
 * \param[out] mean if not NULL, mean returns mean of data set
 * \param[out] variance if not NULL, mean returns variance of data set
 * \param[out] std if not NULL, mean returns standard deviation of data set
 */
void stats_computer1(float x, float *mean, float *variance, float *std)
{
    /* following variables declared static becuase they need to be remembered
     * when updating for next sample, when received.
     */
    static unsigned int n = 0;
    static float Ex = 0.f, Ex2 = 0.f;
    static float K = 0.f;

    if (n == 0)
        K = x;
    n++;
    float tmp = x - K;
    Ex += tmp;
    Ex2 += tmp * tmp;

    /* return sample mean computed till last sample */
    if (mean != NULL)
        *mean = K + Ex / n;

    /* return data variance computed till last sample */
    if (variance != NULL)
        *variance = (Ex2 - (Ex * Ex) / n) / (n - 1);

    /* return sample standard deviation computed till last sample */
    if (std != NULL)
        *std = sqrtf(*variance);
}

/**
 * continuous mean and variance computance using
 * Welford's algorithm  (very accurate)
 * \param[in] x new value added to data set
 * \param[out] mean if not NULL, mean returns mean of data set
 * \param[out] variance if not NULL, mean returns variance of data set
 * \param[out] std if not NULL, mean returns standard deviation of data set
 */
void stats_computer2(float x, float *mean, float *variance, float *std)
{
    /* following variables declared static becuase they need to be remembered
     * when updating for next sample, when received.
     */
    static unsigned int n = 0;
    static float mu = 0, M = 0;

    n++;
    float delta = x - mu;
    mu += delta / n;
    float delta2 = x - mu;
    M += delta * delta2;

    /* return sample mean computed till last sample */
    if (mean != NULL)
        *mean = mu;

    /* return data variance computed till last sample */
    if (variance != NULL)
        *variance = M / n;

    /* return sample standard deviation computed till last sample */
    if (std != NULL)
        *std = sqrtf(*variance);
}

/** Test the algorithm implementation
 * \param[in] test_data array of data to test the algorithms
 * \param[in] number_of_samples number of samples of data
 */
void test_function(const float *test_data, const int number_of_samples)
{
    float ref_mean = 0.f, ref_variance = 0.f;
    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;
    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;

    for (int i = 0; i < number_of_samples; i++)
    {
        stats_computer1(test_data[i], &s1_mean, &s1_variance, &s1_std);
        stats_computer2(test_data[i], &s2_mean, &s2_variance, &s2_std);
        ref_mean += test_data[i];
    }
    ref_mean /= number_of_samples;

    for (int i = 0; i < number_of_samples; i++)
    {
        float temp = test_data[i] - ref_mean;
        ref_variance += temp * temp;
    }
    ref_variance /= number_of_samples;

    printf("<<<<<<<< Test Function >>>>>>>>\n");
    printf("Expected: Mean: %.4f\t Variance: %.4f\n", ref_mean, ref_variance);
    printf("\tMethod 1:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n", s1_mean,
           s1_variance, s1_std);
    printf("\tMethod 2:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n", s2_mean,
           s2_variance, s2_std);

    assert(fabs(s1_mean - ref_mean) < 0.01);
    assert(fabs(s2_mean - ref_mean) < 0.01);
    assert(fabs(s2_variance - ref_variance) < 0.01);

    printf("(Tests passed)\n\n");
}

/** Main function */
int main(int argc, char **argv)
{
    const float test_data1[] = {3, 4, 5, -1.4, -3.6, 1.9, 1.};
    test_function(test_data1, sizeof(test_data1) / sizeof(test_data1[0]));

    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;
    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;

    printf("Enter data. Any non-numeric data will terminate the data input.\n");

    while (1)
    {
        float val;
        printf("Enter number: ");

        // check for failure to read input. Happens for
        // non-numeric data
        if (!scanf("%f", &val))
            break;

        stats_computer1(val, &s1_mean, &s1_variance, &s1_std);
        stats_computer2(val, &s2_mean, &s2_variance, &s2_std);

        printf("\tMethod 1:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n",
               s1_mean, s1_variance, s1_std);
        printf("\tMethod 2:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n",
               s2_mean, s2_variance, s2_std);
    }

    return 0;
}
/**
 * @file
 * \brief Library functions to compute [QR
 * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given
 * matrix.
 * \author [Krishna Vedala](https://github.com/kvedala)
 */

#ifndef QR_DECOMPOSE_H
#define QR_DECOMPOSE_H

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#ifdef _OPENMP
#include <omp.h>
#endif

/**
 * function to display matrix on stdout
 */
void print_matrix(double **A, /**< matrix to print */
                  int M,      /**< number of rows of matrix */
                  int N)      /**< number of columns of matrix */
{
    for (int row = 0; row < M; row++)
    {
        for (int col = 0; col < N; col++) printf("% 9.3g\t", A[row][col]);
        putchar('\n');
    }
    putchar('\n');
}

/**
 * Compute dot product of two vectors of equal lengths
 *
 * If \f$\vec{a}=\left[a_0,a_1,a_2,...,a_L\right]\f$ and
 * \f$\vec{b}=\left[b_0,b_1,b_1,...,b_L\right]\f$ then
 * \f$\vec{a}\cdot\vec{b}=\displaystyle\sum_{i=0}^L a_i\times b_i\f$
 *
 * \returns \f$\vec{a}\cdot\vec{b}\f$
 */
double vector_dot(double *a, double *b, int L)
{
    double mag = 0.f;
    int i;
#ifdef _OPENMP
// parallelize on threads
#pragma omp parallel for reduction(+ : mag)
#endif
    for (i = 0; i < L; i++) mag += a[i] * b[i];

    return mag;
}

/**
 * Compute magnitude of vector.
 *
 * If \f$\vec{a}=\left[a_0,a_1,a_2,...,a_L\right]\f$ then
 * \f$\left|\vec{a}\right|=\sqrt{\displaystyle\sum_{i=0}^L a_i^2}\f$
 *
 * \returns \f$\left|\vec{a}\right|\f$
 */
double vector_mag(double *vector, int L)
{
    double dot = vector_dot(vector, vector, L);
    return sqrt(dot);
}

/**
 * Compute projection of vector \f$\vec{a}\f$ on \f$\vec{b}\f$ defined as
 * \f[\text{proj}_\vec{b}\vec{a}=\frac{\vec{a}\cdot\vec{b}}{\left|\vec{b}\right|^2}\vec{b}\f]
 *
 * \returns NULL if error, otherwise pointer to output
 */
double *vector_proj(double *a, double *b, double *out, int L)
{
    const double num = vector_dot(a, b, L);
    const double deno = vector_dot(b, b, L);
    if (deno == 0) /*! check for division by zero */
        return NULL;

    const double scalar = num / deno;
    int i;
#ifdef _OPENMP
// parallelize on threads
#pragma omp for
#endif
    for (i = 0; i < L; i++) out[i] = scalar * b[i];

    return out;
}

/**
 * Compute vector subtraction
 *
 * \f$\vec{c}=\vec{a}-\vec{b}\f$
 *
 * \returns pointer to output vector
 */
double *vector_sub(double *a,   /**< minuend */
                   double *b,   /**< subtrahend */
                   double *out, /**< resultant vector */
                   int L        /**< length of vectors */
)
{
    int i;
#ifdef _OPENMP
// parallelize on threads
#pragma omp for
#endif
    for (i = 0; i < L; i++) out[i] = a[i] - b[i];

    return out;
}

/**
 * Decompose matrix \f$A\f$ using [Gram-Schmidt
 *process](https://en.wikipedia.org/wiki/QR_decomposition).
 *
 * \f{eqnarray*}{
 * \text{given that}\quad A &=&
 *\left[\mathbf{a}_1,\mathbf{a}_2,\ldots,\mathbf{a}_{N-1},\right]\\
 * \text{where}\quad\mathbf{a}_i &=&
 *\left[a_{0i},a_{1i},a_{2i},\ldots,a_{(M-1)i}\right]^T\quad\ldots\mbox{(column
 *vectors)}\\
 * \text{then}\quad\mathbf{u}_i &=& \mathbf{a}_i
 *-\sum_{j=0}^{i-1}\text{proj}_{\mathbf{u}_j}\mathbf{a}_i\\
 * \mathbf{e}_i &=&\frac{\mathbf{u}_i}{\left|\mathbf{u}_i\right|}\\
 * Q &=& \begin{bmatrix}\mathbf{e}_0 & \mathbf{e}_1 & \mathbf{e}_2 & \dots &
 *\mathbf{e}_{N-1}\end{bmatrix}\\
 * R &=& \begin{bmatrix}\langle\mathbf{e}_0\,,\mathbf{a}_0\rangle &
 *\langle\mathbf{e}_1\,,\mathbf{a}_1\rangle &
 *\langle\mathbf{e}_2\,,\mathbf{a}_2\rangle & \dots \\
 *                  0 & \langle\mathbf{e}_1\,,\mathbf{a}_1\rangle &
 *\langle\mathbf{e}_2\,,\mathbf{a}_2\rangle & \dots\\
 *                  0 & 0 & \langle\mathbf{e}_2\,,\mathbf{a}_2\rangle & \dots\\
 *                  \vdots & \vdots & \vdots & \ddots
 *      \end{bmatrix}\\
 * \f}
 */
void qr_decompose(double **A, /**< input matrix to decompose */
                  double **Q, /**< output decomposed matrix */
                  double **R, /**< output decomposed matrix */
                  int M,      /**< number of rows of matrix A */
                  int N       /**< number of columns of matrix A */
)
{
    double *col_vector = (double *)malloc(M * sizeof(double));
    double *col_vector2 = (double *)malloc(M * sizeof(double));
    double *tmp_vector = (double *)malloc(M * sizeof(double));
    for (int i = 0; i < N;
         i++) /* for each column => R is a square matrix of NxN */
    {
        int j;
#ifdef _OPENMP
// parallelize on threads
#pragma omp for
#endif
        for (j = 0; j < i; j++) /* second dimension of column */
            R[i][j] = 0.;       /* make R upper triangular */

            /* get corresponding Q vector */
#ifdef _OPENMP
// parallelize on threads
#pragma omp for
#endif
        for (j = 0; j < M; j++)
        {
            tmp_vector[j] = A[j][i]; /* accumulator for uk */
            col_vector[j] = A[j][i];
        }
        for (j = 0; j < i; j++)
        {
            for (int k = 0; k < M; k++) col_vector2[k] = Q[k][j];
            vector_proj(col_vector, col_vector2, col_vector2, M);
            vector_sub(tmp_vector, col_vector2, tmp_vector, M);
        }
        double mag = vector_mag(tmp_vector, M);

#ifdef _OPENMP
// parallelize on threads
#pragma omp for
#endif
        for (j = 0; j < M; j++) Q[j][i] = tmp_vector[j] / mag;

        /* compute upper triangular values of R */
        for (int kk = 0; kk < M; kk++) col_vector[kk] = Q[kk][i];
        for (int k = i; k < N; k++)
        {
            for (int kk = 0; kk < M; kk++) col_vector2[kk] = A[kk][k];
            R[i][k] = vector_dot(col_vector, col_vector2, M);
        }
    }

    free(col_vector);
    free(col_vector2);
    free(tmp_vector);
}

#endif  // QR_DECOMPOSE_H
/**
 * \file
 * \authors [Krishna Vedala](https://github.com/kvedala)
 * \brief Solve a multivariable first order [ordinary differential equation
 * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using
 * [forward Euler
 * method](https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations#Euler_method)
 *
 * \details
 * The ODE being solved is:
 * \f{eqnarray*}{
 * \dot{u} &=& v\\
 * \dot{v} &=& -\omega^2 u\\
 * \omega &=& 1\\
 * [x_0, u_0, v_0] &=& [0,1,0]\qquad\ldots\text{(initial values)}
 * \f}
 * The exact solution for the above problem is:
 * \f{eqnarray*}{
 * u(x) &=& \cos(x)\\
 * v(x) &=& -\sin(x)\\
 * \f}
 * The computation results are stored to a text file `forward_euler.csv` and the
 * exact soltuion results in `exact.csv` for comparison.
 * <img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_forward_euler.svg"
 * alt="Implementation solution"/>
 *
 * To implement [Van der Pol
 * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the
 * ::problem function to:
 * ```cpp
 * const double mu = 2.0;
 * dy[0] = y[1];
 * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];
 * ```
 * \see ode_midpoint_euler.c, ode_semi_implicit_euler.c
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define order 2 /**< number of dependent variables in ::problem */

/**
 * @brief Problem statement for a system with first-order differential
 * equations. Updates the system differential variables.
 * \note This function can be updated to and ode of any order.
 *
 * @param[in] 		x 		independent variable(s)
 * @param[in,out]	y		dependent variable(s)
 * @param[in,out]	dy	    first-derivative of dependent variable(s)
 */
void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;       // some const for the problem
    dy[0] = y[1];                   // x dot
    dy[1] = -omega * omega * y[0];  // y dot
}

/**
 * @brief Exact solution of the problem. Used for solution comparison.
 *
 * @param[in] 		x 		independent variable
 * @param[in,out]	y		dependent variable
 */
void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}

/**
 * @brief Compute next step approximation using the forward-Euler
 * method. @f[y_{n+1}=y_n + dx\cdot f\left(x_n,y_n\right)@f]
 * @param[in] 		dx	step size
 * @param[in,out] 	x	take \f$x_n\f$ and compute \f$x_{n+1}\f$
 * @param[in,out] 	y	take \f$y_n\f$ and compute \f$y_{n+1}\f$
 * @param[in,out]	dy	compute \f$f\left(x_n,y_n\right)\f$
 */
void forward_euler_step(const double dx, const double *x, double *y, double *dy)
{
    int o;
    problem(x, y, dy);
    for (o = 0; o < order; o++) y[o] += dx * dy[o];
}

/**
 * @brief Compute approximation using the forward-Euler
 * method in the given limits.
 * @param[in] 		dx  	step size
 * @param[in]   	x0  	initial value of independent variable
 * @param[in] 	    x_max	final value of independent variable
 * @param[in,out] 	y	    take \f$y_n\f$ and compute \f$y_{n+1}\f$
 * @param[in] save_to_file	flag to save results to a CSV file (1) or not (0)
 * @returns time taken for computation in seconds
 */
double forward_euler(double dx, double x0, double x_max, double *y,
                     char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen("forward_euler.csv", "w+");
        if (fp == NULL)
        {
            perror("Error! ");
            return -1;
        }
    }

    /* start integration */
    clock_t t1 = clock();
    double x = x0;
    do  // iterate for each step of independent variable
    {
        if (save_to_file && fp)
            fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        forward_euler_step(dx, &x, y, dy);  // perform integration
        x += dx;                            // update step
    } while (x <= x_max);  // till upper limit of independent variable
    /* end of integration */
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}

/**
    Main Function
*/
int main(int argc, char *argv[])
{
    double X0 = 0.f;          /* initial value of x0 */
    double X_MAX = 10.F;      /* upper limit of integration */
    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */
    double step_size;

    if (argc == 1)
    {
        printf("\nEnter the step size: ");
        scanf("%lg", &step_size);
    }
    else
        // use commandline argument as independent variable step size
        step_size = atof(argv[1]);

    // get approximate solution
    double total_time = forward_euler(step_size, X0, X_MAX, Y0, 1);
    printf("\tTime = %.6g ms\n", total_time);

    /* compute exact solution for comparion */
    FILE *fp = fopen("exact.csv", "w+");
    if (fp == NULL)
    {
        perror("Error! ");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf("Finding exact solution\n");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf("\tTime = %.6g ms\n", total_time);
    fclose(fp);

    return 0;
}
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define MAX_LEN INT_MAX

int main(int argc, char **argv)
{
    int *a, n = 10, i, j, temp, sum = 0;
    float mean;

    if (argc == 2)
    {
        n = atoi(argv[1]);
        if (n >= MAX_LEN)
        {
            fprintf(stderr, "Maximum %d!\n", MAX_LEN);
            return 1;
        }
    }
    
    a = (int *)malloc(n * sizeof(int));

    printf("Random Numbers Generated are: ");
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
        printf("%2d, ", a[i]);
    }
    putchar('\n');

    for (i = 0; i < n; i++) sum = sum + a[i];

    mean = sum / (float)n;
    printf("\nMean: ");
    printf("%f\n", mean);

    free(a);
    return 0;
}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int a[10], n, i, j, temp;
    float mean, median;

    printf("Enter no. for Random Numbers :");
    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
    }
    printf("Random Numbers Generated are :\n");
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }
    printf("\n");
    printf("\nSorted Data:");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            if (a[i] < a[j])
            {
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }

    if (n % 2 == 0)
    {
        median = (a[n / 2] + a[(n / 2) - 1]) / 2;
    }
    else
    {
        median = a[n / 2];
    }
    printf("\nMedian is : %f", median);

    return 0;
}
/**
 * @file
 * \brief Find approximate solution for \f$f(x) = 0\f$ using
 * Newton-Raphson interpolation algorithm.
 *
 * \author [Krishna Vedala](https://github.com/kvedala)
 */

#include <complex.h> /* requires minimum of C99 */
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ACCURACY 1e-10 /**< solution accuracy */

/**
 * Return value of the function to find the root for.
 * \f$f(x)\f$
 */
double complex func(double complex x)
{
    return x * x - 3.; /* x^2 = 3 - solution is sqrt(3) */
    // return x * x - 2.; /* x^2 = 2 - solution is sqrt(2) */
}

/**
 * Return first order derivative of the function.
 * \f$f'(x)\f$
 */
double complex d_func(double complex x) { return 2. * x; }

/**
 * main function
 */
int main(int argc, char **argv)
{
    double delta = 1;
    double complex cdelta = 1;

    /* initialize random seed: */
    srand(time(NULL));

    /* random initial approximation */
    double complex root = (rand() % 100 - 50) + (rand() % 100 - 50) * I;

    unsigned long counter = 0;
    /* iterate till a convergence is reached */
    while (delta > ACCURACY && counter < ULONG_MAX)
    {
        cdelta = func(root) / d_func(root);
        root += -cdelta;
        counter++;
        delta = fabs(cabs(cdelta));

#if defined(DEBUG) || !defined(NDEBUG)
        if (counter % 50 == 0)
        {
            double r = creal(root);
            double c = cimag(root);

            printf("Iter %5lu: Root: %4.4g%c%4.4gi\t\tdelta: %.4g\n", counter,
                   r, c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);
        }
#endif
    }

    double r = creal(root);
    double c = fabs(cimag(root)) < ACCURACY ? 0 : cimag(root);

    printf("Iter %5lu: Root: %4.4g%c%4.4gi\t\tdelta: %.4g\n", counter, r,
           c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);

    return 0;
}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int *ARRAY = NULL, ARRAY_LENGTH, i, TEMPORARY_ELEMENT, isSorted = 0;
    float MEAN = 0, VARIANCE = 0, STAND;

    printf("Enter no. for Random Numbers :");
    scanf("%d", &ARRAY_LENGTH);
    ARRAY = (int *)realloc(
        ARRAY,
        ARRAY_LENGTH * (sizeof(int)));  // We allocate the dedicated memory
    for (i = 0; i < ARRAY_LENGTH; i++)  // We generate the random numbers
        ARRAY[i] = rand() % 100;

    printf("Random Numbers Generated are :\n");  // We display them
    for (i = 0; i < ARRAY_LENGTH; i++) printf("%d ", ARRAY[i]);

    printf("\nSorted Data: ");  // Then we sort it using Bubble Sort..

    while (!isSorted)
    {                  // While our array's not sorted
        isSorted = 1;  // we suppose that it's sorted
        for (i = 0; i < ARRAY_LENGTH - 1; i++)
        {  // then for each element of the array
            if (ARRAY[i] > ARRAY[i + 1])
            {                  // if the two elements aren't sorted
                isSorted = 0;  // it means that the array is not sorted
                TEMPORARY_ELEMENT = ARRAY[i];  // and we switch these elements
                                               // using TEMPORARY_ELEMENT
                ARRAY[i] = ARRAY[i + 1];
                ARRAY[i + 1] = TEMPORARY_ELEMENT;
            }
        }
    }
    for (i = 0; i < ARRAY_LENGTH; i++)
    {
        printf("%d ", ARRAY[i]);
        MEAN = MEAN + ARRAY[i];
    }
    MEAN = MEAN / (float)ARRAY_LENGTH;

    for (i = 0; i < ARRAY_LENGTH; i++)
        VARIANCE = VARIANCE + (pow((ARRAY[i] - MEAN), 2));

    VARIANCE = VARIANCE / (float)ARRAY_LENGTH;
    STAND = sqrt(VARIANCE);

    printf("\n\n- Mean is: %f\n", MEAN);
    printf("- Variance is: %f\n", VARIANCE);
    printf("- Standard Deviation is: %f\n", STAND);
}
/**
 * @file
 * \brief Compute real eigen values and eigen vectors of a symmetric matrix
 * using [QR decomposition](https://en.wikipedia.org/wiki/QR_decomposition)
 * method.
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "qr_decompose.h"
#ifdef _OPENMP
#include <omp.h>
#endif

#define LIMS 9        /**< limit of range of matrix values */
#define EPSILON 1e-10 /**< accuracy tolerance limit */

/**
 * create a square matrix of given size with random elements
 * \param[out] A matrix to create (must be pre-allocated in memory)
 * \param[in] N matrix size
 */
void create_matrix(double **A, int N)
{
    int i, j, tmp, lim2 = LIMS >> 1;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        A[i][i] = (rand() % LIMS) - lim2;
        for (j = i + 1; j < N; j++)
        {
            tmp = (rand() % LIMS) - lim2;
            A[i][j] = tmp;
            A[j][i] = tmp;
        }
    }
}

/**
 * Perform multiplication of two matrices.
 * * R2 must be equal to C1
 * * Resultant matrix size should be R1xC2
 * \param[in] A first matrix to multiply
 * \param[in] B second matrix to multiply
 * \param[out] OUT output matrix (must be pre-allocated)
 * \param[in] R1 number of rows of first matrix
 * \param[in] C1 number of columns of first matrix
 * \param[in] R2 number of rows of second matrix
 * \param[in] C2 number of columns of second matrix
 * \returns pointer to resultant matrix
 */
double **mat_mul(double **A, double **B, double **OUT, int R1, int C1, int R2,
                 int C2)
{
    if (C1 != R2)
    {
        perror("Matrix dimensions mismatch!");
        return OUT;
    }

    int i;
#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < R1; i++)
    {
        for (int j = 0; j < C2; j++)
        {
            OUT[i][j] = 0.f;
            for (int k = 0; k < C1; k++) OUT[i][j] += A[i][k] * B[k][j];
        }
    }
    return OUT;
}

/** Compute eigen values using iterative shifted QR decomposition algorithm as
 * follows:
 * 1. Use last diagonal element of A as eigen value approximation \f$c\f$
 * 2. Shift diagonals of matrix \f$A' = A - cI\f$
 * 3. Decompose matrix \f$A'=QR\f$
 * 4. Compute next approximation \f$A'_1 = RQ \f$
 * 5. Shift diagonals back \f$A_1 = A'_1 + cI\f$
 * 6. Termination condition check: last element below diagonal is almost 0
 *   1. If not 0, go back to step 1 with the new approximation \f$A_1\f$
 *   2. If 0, continue to step 7
 * 7. Save last known \f$c\f$ as the eigen value.
 * 8. Are all eigen values found?
 *   1. If not, remove last row and column of \f$A_1\f$ and go back to step 1.
 *   2. If yes, stop.
 *
 * \note The matrix \f$A\f$ gets modified
 *
 * \param[in,out] A matrix to compute eigen values for
 * \param[out] eigen_vals resultant vector containing computed eigen values
 * \param[in] mat_size matrix size
 * \param[in] debug_print 1 to print intermediate Q & R matrices, 0 for not to
 * \returns time for computation in seconds
 */
double eigen_values(double **A, double *eigen_vals, int mat_size,
                    char debug_print)
{
    if (!eigen_vals)
    {
        perror("Output eigen value vector cannot be NULL!");
        return -1;
    }
    double **R = (double **)malloc(sizeof(double *) * mat_size);
    double **Q = (double **)malloc(sizeof(double *) * mat_size);
    if (!Q || !R)
    {
        perror("Unable to allocate memory for Q & R!");
        if (Q)
        {
            free(Q);
        }
        if (R)
        {
            free(R);
        }
        return -1;
    }

    /* allocate dynamic memory for matrices */
    for (int i = 0; i < mat_size; i++)
    {
        R[i] = (double *)malloc(sizeof(double) * mat_size);
        Q[i] = (double *)malloc(sizeof(double) * mat_size);
        if (!Q[i] || !R[i])
        {
            perror("Unable to allocate memory for Q & R.");
            for (; i >= 0; i--)
            {
                free(R[i]);
                free(Q[i]);
            }
            free(Q);
            free(R);
            return -1;
        }
    }

    if (debug_print)
    {
        print_matrix(A, mat_size, mat_size);
    }

    int rows = mat_size, columns = mat_size;
    int counter = 0, num_eigs = rows - 1;
    double last_eig = 0;

    clock_t t1 = clock();
    while (num_eigs > 0) /* continue till all eigen values are found */
    {
        /* iterate with QR decomposition */
        while (fabs(A[num_eigs][num_eigs - 1]) > EPSILON)
        {
            last_eig = A[num_eigs][num_eigs];
            for (int i = 0; i < rows; i++) A[i][i] -= last_eig; /* A - cI */
            qr_decompose(A, Q, R, rows, columns);

            if (debug_print)
            {
                print_matrix(A, rows, columns);
                print_matrix(Q, rows, columns);
                print_matrix(R, columns, columns);
                printf("-------------------- %d ---------------------\n",
                       ++counter);
            }

            mat_mul(R, Q, A, columns, columns, rows, columns);
            for (int i = 0; i < rows; i++) A[i][i] += last_eig; /* A + cI */
        }

        /* store the converged eigen value */
        eigen_vals[num_eigs] = last_eig;

        if (debug_print)
        {
            printf("========================\n");
            printf("Eigen value: % g,\n", last_eig);
            printf("========================\n");
        }

        num_eigs--;
        rows--;
        columns--;
    }
    eigen_vals[0] = A[0][0];
    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;

    if (debug_print)
    {
        print_matrix(R, mat_size, mat_size);
        print_matrix(Q, mat_size, mat_size);
    }

    /* cleanup dynamic memory */
    for (int i = 0; i < mat_size; i++)
    {
        free(R[i]);
        free(Q[i]);
    }
    free(R);
    free(Q);

    return dtime;
}

/**
 * test function to compute eigen values of a 2x2 matrix
 * \f[\begin{bmatrix}
 * 5 & 7\\
 * 7 & 11
 * \end{bmatrix}\f]
 * which are approximately, {15.56158, 0.384227}
 */
void test1()
{
    int mat_size = 2;
    double X[][2] = {{5, 7}, {7, 11}};
    double y[] = {15.56158, 0.384227};  // corresponding y-values
    double eig_vals[2] = {0, 0};

    // The following steps are to convert a "double[][]" to "double **"
    double **A = (double **)malloc(mat_size * sizeof(double *));
    for (int i = 0; i < mat_size; i++) A[i] = X[i];

    printf("------- Test 1 -------\n");

    double dtime = eigen_values(A, eig_vals, mat_size, 0);

    for (int i = 0; i < mat_size; i++)
    {
        printf("%d/5 Checking for %.3g --> ", i + 1, y[i]);
        char result = 0;
        for (int j = 0; j < mat_size && !result; j++)
        {
            if (fabs(y[i] - eig_vals[j]) < 0.1)
            {
                result = 1;
                printf("(%.3g) ", eig_vals[j]);
            }
        }

        // ensure that i^th expected eigen value was computed
        assert(result != 0);
        printf("found\n");
    }
    printf("Test 1 Passed in %.3g sec\n\n", dtime);
    free(A);
}

/**
 * test function to compute eigen values of a 2x2 matrix
 * \f[\begin{bmatrix}
 * -4& 4& 2& 0& -3\\
 * 4& -4& 4& -3& -1\\
 * 2& 4& 4& 3& -3\\
 * 0& -3& 3& -1&-1\\
 * -3& -1& -3& -3& 0
 * \end{bmatrix}\f]
 * which are approximately, {9.27648, -9.26948, 2.0181, -1.03516, -5.98994}
 */
void test2()
{
    int mat_size = 5;
    double X[][5] = {{-4, 4, 2, 0, -3},
                     {4, -4, 4, -3, -1},
                     {2, 4, 4, 3, -3},
                     {0, -3, 3, -1, -3},
                     {-3, -1, -3, -3, 0}};
    double y[] = {9.27648, -9.26948, 2.0181, -1.03516,
                  -5.98994};  // corresponding y-values
    double eig_vals[5];

    // The following steps are to convert a "double[][]" to "double **"
    double **A = (double **)malloc(mat_size * sizeof(double *));
    for (int i = 0; i < mat_size; i++) A[i] = X[i];

    printf("------- Test 2 -------\n");

    double dtime = eigen_values(A, eig_vals, mat_size, 0);

    for (int i = 0; i < mat_size; i++)
    {
        printf("%d/5 Checking for %.3g --> ", i + 1, y[i]);
        char result = 0;
        for (int j = 0; j < mat_size && !result; j++)
        {
            if (fabs(y[i] - eig_vals[j]) < 0.1)
            {
                result = 1;
                printf("(%.3g) ", eig_vals[j]);
            }
        }

        // ensure that i^th expected eigen value was computed
        assert(result != 0);
        printf("found\n");
    }
    printf("Test 2 Passed in %.3g sec\n\n", dtime);
    free(A);
}

/**
 * main function
 */
int main(int argc, char **argv)
{
    srand(time(NULL));

    int mat_size = 5;
    if (argc == 2)
    {
        mat_size = atoi(argv[1]);
    }
    else
    {  // if invalid input argument is given run tests
        test1();
        test2();
        printf("Usage: ./qr_eigen_values [mat_size]\n");
        return 0;
    }

    if (mat_size < 2)
    {
        fprintf(stderr, "Matrix size should be > 2\n");
        return -1;
    }

    int i;

    double **A = (double **)malloc(sizeof(double *) * mat_size);
    /* number of eigen values = matrix size */
    double *eigen_vals = (double *)malloc(sizeof(double) * mat_size);
    if (!eigen_vals)
    {
        perror("Unable to allocate memory for eigen values!");
        free(A);
        return -1;
    }
    for (i = 0; i < mat_size; i++)
    {
        A[i] = (double *)malloc(sizeof(double) * mat_size);
        eigen_vals[i] = 0.f;
    }

    /* create a random matrix */
    create_matrix(A, mat_size);

    print_matrix(A, mat_size, mat_size);

    double dtime = eigen_values(A, eigen_vals, mat_size, 0);
    printf("Eigen vals: ");
    for (i = 0; i < mat_size; i++) printf("% 9.4g\t", eigen_vals[i]);
    printf("\nTime taken to compute: % .4g sec\n", dtime);

    for (int i = 0; i < mat_size; i++) free(A[i]);
    free(A);
    free(eigen_vals);
    return 0;
}
#include <math.h>
#include <stdio.h>

int main()
{
    float a, b, c, a1, a2, a3, b1, b2, b3, c1, c2, c3, d1, d2, d3, x1, x2, x3;

    printf("Enter values of eq1:");
    scanf("%f%f%f%f", &a1, &a2, &a3, &d1);
    printf("Enter values of eq2:");
    scanf("%f%f%f%f", &b1, &b2, &b3, &d2);
    printf("Enter values of eq3:");
    scanf("%f%f%f%f", &c1, &c2, &c3, &d3);
    x1 = x2 = x3 = 0.0;
    do
    {
        a = x1;
        b = x2;
        c = x3;
        x1 = (1 / a1) * (d1 - (a2 * x2) - (a3 * x3));
        x2 = (1 / b2) * (d2 - (b1 * x1) - (b3 * x3));
        x3 = (1 / c3) * (d3 - (c1 * x1) - (c2 * x2));
    } while (fabs(x1 - a) > 0.0001 && fabs(x2 - b) > 0.0001 &&
             fabs(x3 - c) > 0.0001);
    printf("x1=%f\nx2=%f\nx3=%f", x1, x2, x3);

    return 0;
}#include <math.h>
#include <stdio.h>

float f(float x)
{
    return 1.0 +
           x * x * x;  // This is the expresion of the function to integrate?
}

int main()
{
    int i, n;
    float a, b, h, x, s2, s3, sum, integral;

    printf("enter the lower limit of the integration:");
    scanf("%f", &a);
    printf("enter the upper limit of the integration:");
    scanf("%f", &b);
    printf("enter the number of intervals:");
    scanf("%d", &n);

    h = (b - a) / n;
    sum = f(a) + f(b);
    s2 = s3 = 0.0;

    for (i = 1; i < n; i += 3)
    {
        x = a + i * h;
        s3 = s3 + f(x) + f(x + h);
    }

    for (i = 3; i < n; i += 3)
    {
        x = a + i * h;
        s2 = s2 + f(x);
    }

    integral = (h / 3.0) * (sum + 2 * s2 + 4 * s3);
    printf("\nValue of the integral = %9.4f\n", integral);

    return 0;
}/**
 * \file
 * \brief [LU decomposition](https://en.wikipedia.org/wiki/LU_decompositon) of a
 * square matrix
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP
#include <omp.h>
#endif

/** Perform LU decomposition on matrix
 * \param[in] A matrix to decompose
 * \param[out] L output L matrix
 * \param[out] U output U matrix
 * \param[in] mat_size input square matrix size
 */
int lu_decomposition(double **A, double **L, double **U, int mat_size)
{
    int row, col, j;

    // regularize each row
    for (row = 0; row < mat_size; row++)
    {
        // Upper triangular matrix
#ifdef _OPENMP
#pragma omp for
#endif
        for (col = row; col < mat_size; col++)
        {
            // Summation of L[i,j] * U[j,k]
            double lu_sum = 0.;
            for (j = 0; j < row; j++) lu_sum += L[row][j] * U[j][col];

            // Evaluate U[i,k]
            U[row][col] = A[row][col] - lu_sum;
        }

        // Lower triangular matrix
#ifdef _OPENMP
#pragma omp for
#endif
        for (col = row; col < mat_size; col++)
        {
            if (row == col)
            {
                L[row][col] = 1.;
                continue;
            }

            // Summation of L[i,j] * U[j,k]
            double lu_sum = 0.;
            for (j = 0; j < row; j++) lu_sum += L[col][j] * U[j][row];

            // Evaluate U[i,k]
            L[col][row] = (A[col][row] - lu_sum) / U[row][row];
        }
    }

    return 0;
}

/** Function to display square matrix */
void display(double **A, int N)
{
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            printf("% 3.3g \t", A[i][j]);
        }
        putchar('\n');
    }
}

/** Main function */
int main(int argc, char **argv)
{
    int mat_size = 3;  // default matrix size
    const int range = 10;
    const int range2 = range >> 1;

    if (argc == 2)
        mat_size = atoi(argv[1]);

    srand(time(NULL));  // random number initializer

    /* Create a square matrix with random values */
    double **A = (double **)malloc(mat_size * sizeof(double *));
    double **L = (double **)malloc(mat_size * sizeof(double *));  // output
    double **U = (double **)malloc(mat_size * sizeof(double *));  // output
    for (int i = 0; i < mat_size; i++)
    {
        // calloc so that all valeus are '0' by default
        A[i] = (double *)calloc(mat_size, sizeof(double));
        L[i] = (double *)calloc(mat_size, sizeof(double));
        U[i] = (double *)calloc(mat_size, sizeof(double));
        for (int j = 0; j < mat_size; j++)
            /* create random values in the limits [-range2, range-1] */
            A[i][j] = (double)(rand() % range - range2);
    }

    lu_decomposition(A, L, U, mat_size);

    printf("A = \n");
    display(A, mat_size);
    printf("\nL = \n");
    display(L, mat_size);
    printf("\nU = \n");
    display(U, mat_size);

    /* Free dynamically allocated memory */
    for (int i = 0; i < mat_size; i++)
    {
        free(A[i]);
        free(L[i]);
        free(U[i]);
    }
    free(A);
    free(L);
    free(U);

    return 0;
}/**
 * @file
 * \brief Compute all possible approximate roots of any given polynomial using
 * [Durand Kerner
 * algorithm](https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method)
 *
 * \author [Krishna Vedala](https://github.com/kvedala)
 *
 * Test the algorithm online:
 * https://gist.github.com/kvedala/27f1b0b6502af935f6917673ec43bcd7
 *
 * Try the highly unstable Wilkinson's polynomial:
 * ```
 * ./numerical_methods/durand_kerner_roots.c 1 -210 20615 -1256850 53327946
 * -1672280820 40171771630 -756111184500 11310276995381 -135585182899530
 * 1307535010540395 -10142299865511450 63030812099294896 -311333643161390640
 * 1206647803780373360 -3599979517947607200 8037811822645051776
 * -12870931245150988800 13803759753640704000 -8752948036761600000
 * 2432902008176640000
 * ```
 * Sample implementation results to compute approximate roots of the equation
 * \f$x^4-1=0\f$:\n
 * <img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/durand_kerner_error.svg"
 * width="400" alt="Error evolution during root approximations computed every
 * iteration."/> <img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/durand_kerner_roots.svg"
 * width="400" alt="Roots evolution - shows the initial approximation of the
 * roots and their convergence to a final approximation along with the iterative
 * approximations" />
 */

#include <complex.h>
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define ACCURACY 1e-10 /**< maximum accuracy limit */

/**
 * Evaluate the value of a polynomial with given coefficients
 * \param[in] coeffs coefficients of the polynomial
 * \param[in] degree degree of polynomial
 * \param[in] x point at which to evaluate the polynomial
 * \returns \f$f(x)\f$
 */
long double complex poly_function(long double *coeffs, unsigned int degree,
                                  long double complex x)
{
    long double complex out = 0.;
    unsigned int n;

    for (n = 0; n < degree; n++) out += coeffs[n] * cpow(x, degree - n - 1);

    return out;
}

/**
 * create a textual form of complex number
 * \param[in] x point at which to evaluate the polynomial
 * \returns pointer to converted string
 */
const char *complex_str(long double complex x)
{
    static char msg[50];
    double r = creal(x);
    double c = cimag(x);

    sprintf(msg, "% 7.04g%+7.04gj", r, c);

    return msg;
}

/**
 * check for termination condition
 * \param[in] delta point at which to evaluate the polynomial
 * \returns 0 if termination not reached
 * \returns 1 if termination reached
 */
char check_termination(long double delta)
{
    static long double past_delta = INFINITY;
    if (fabsl(past_delta - delta) <= ACCURACY || delta < ACCURACY)
        return 1;
    past_delta = delta;
    return 0;
}

/***
 * the comandline inputs are taken as coeffiecients of a polynomial
 */
int main(int argc, char **argv)
{
    long double *coeffs = NULL;
    long double complex *s0 = NULL;
    unsigned int degree = 0;
    unsigned int n, i;

    if (argc < 2)
    {
        printf(
            "Please pass the coefficients of the polynomial as commandline "
            "arguments.\n");
        return 0;
    }

    degree = argc - 1; /* detected polynomial degree */
    coeffs = (long double *)malloc(
        degree * sizeof(long double)); /* store all input coefficients */
    s0 = (long double complex *)malloc(
        (degree - 1) *
        sizeof(long double complex)); /* number of roots = degree-1 */

    /* initialize random seed: */
    srand(time(NULL));

    if (!coeffs || !s0)
    {
        perror("Unable to allocate memory!");
        if (coeffs)
            free(coeffs);
        if (s0)
            free(s0);
        return EXIT_FAILURE;
    }

#if defined(DEBUG) || !defined(NDEBUG)
    /**
     * store intermediate values to a CSV file
     */
    FILE *log_file = fopen("durand_kerner.log.csv", "wt");
    if (!log_file)
    {
        perror("Unable to create a storage log file!");
        free(coeffs);
        free(s0);
        return EXIT_FAILURE;
    }
    fprintf(log_file, "iter#,");
#endif

    printf("Computing the roots for:\n\t");
    for (n = 0; n < degree; n++)
    {
        coeffs[n] = strtod(argv[n + 1], NULL);
        if (n < degree - 1 && coeffs[n] != 0)
            printf("(%Lg) x^%d + ", coeffs[n], degree - n - 1);
        else if (coeffs[n] != 0)
            printf("(%Lg) x^%d = 0\n", coeffs[n], degree - n - 1);

        double tmp;
        if (n > 0)
            coeffs[n] /= tmp; /* numerical errors less when the first
                                 coefficient is "1" */
        else
        {
            tmp = coeffs[0];
            coeffs[0] = 1;
        }

        /* initialize root approximations with random values */
        if (n < degree - 1)
        {
            s0[n] = (long double)rand() + (long double)rand() * I;
#if defined(DEBUG) || !defined(NDEBUG)
            fprintf(log_file, "root_%d,", n);
#endif
        }
    }

#if defined(DEBUG) || !defined(NDEBUG)
    fprintf(log_file, "avg. correction");
    fprintf(log_file, "\n0,");
    for (n = 0; n < degree - 1; n++)
        fprintf(log_file, "%s,", complex_str(s0[n]));
#endif

    double tol_condition = 1;
    unsigned long iter = 0;

    clock_t end_time, start_time = clock();
    while (!check_termination(tol_condition) && iter < INT_MAX)
    {
        long double complex delta = 0;
        tol_condition = 0;
        iter++;

#if defined(DEBUG) || !defined(NDEBUG)
        fprintf(log_file, "\n%ld,", iter);
#endif

        for (n = 0; n < degree - 1; n++)
        {
            long double complex numerator =
                poly_function(coeffs, degree, s0[n]);
            long double complex denominator = 1.0;
            for (i = 0; i < degree - 1; i++)
                if (i != n)
                    denominator *= s0[n] - s0[i];

            delta = numerator / denominator;

            if (isnan(cabsl(delta)) || isinf(cabsl(delta)))
            {
                printf("\n\nOverflow/underrun error - got value = %Lg",
                       cabsl(delta));
                goto end;
            }

            s0[n] -= delta;

            tol_condition = fmaxl(tol_condition, fabsl(cabsl(delta)));

#if defined(DEBUG) || !defined(NDEBUG)
            fprintf(log_file, "%s,", complex_str(s0[n]));
#endif
        }
        // tol_condition /= (degree - 1);

#if defined(DEBUG) || !defined(NDEBUG)
        if (iter % 500 == 0)
        {
            printf("Iter: %lu\t", iter);
            for (n = 0; n < degree - 1; n++) printf("\t%s", complex_str(s0[n]));
            printf("\t\tabsolute average change: %.4g\n", tol_condition);
        }

        fprintf(log_file, "%.4g", tol_condition);
#endif
    }
end:

    end_time = clock();

#if defined(DEBUG) || !defined(NDEBUG)
    fclose(log_file);
#endif

    printf("\nIterations: %lu\n", iter);
    for (n = 0; n < degree - 1; n++) printf("\t%s\n", complex_str(s0[n]));
    printf("absolute average change: %.4g\n", tol_condition);
    printf("Time taken: %.4g sec\n",
           (end_time - start_time) / (double)CLOCKS_PER_SEC);

    free(coeffs);
    free(s0);

    return 0;
}
/**
 * \file
 * \authors [Krishna Vedala](https://github.com/kvedala)
 * \brief Solve a multivariable first order [ordinary differential equation
 * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using
 * [semi implicit Euler
 * method](https://en.wikipedia.org/wiki/Semi-implicit_Euler_method)
 *
 * \details
 * The ODE being solved is:
 * \f{eqnarray*}{
 * \dot{u} &=& v\\
 * \dot{v} &=& -\omega^2 u\\
 * \omega &=& 1\\
 * [x_0, u_0, v_0] &=& [0,1,0]\qquad\ldots\text{(initial values)}
 * \f}
 * The exact solution for the above problem is:
 * \f{eqnarray*}{
 * u(x) &=& \cos(x)\\
 * v(x) &=& -\sin(x)\\
 * \f}
 * The computation results are stored to a text file `semi_implicit_euler.csv`
 * and the exact soltuion results in `exact.csv` for comparison. <img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_semi_implicit_euler.svg"
 * alt="Implementation solution"/>
 *
 * To implement [Van der Pol
 * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the
 * ::problem function to:
 * ```cpp
 * const double mu = 2.0;
 * dy[0] = y[1];
 * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];
 * ```
 * <a href="https://en.wikipedia.org/wiki/Van_der_Pol_oscillator"><img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/van_der_pol_implicit_euler.svg"
 * alt="Van der Pol Oscillator solution"/></a>
 *
 * \see ode_forward_euler.c, ode_midpoint_euler.c
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define order 2 /**< number of dependent variables in ::problem */

/**
 * @brief Problem statement for a system with first-order differential
 * equations. Updates the system differential variables.
 * \note This function can be updated to and ode of any order.
 *
 * @param[in] 		x 		independent variable(s)
 * @param[in,out]	y		dependent variable(s)
 * @param[in,out]	dy	    first-derivative of dependent variable(s)
 */
void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;       // some const for the problem
    dy[0] = y[1];                   // x dot
    dy[1] = -omega * omega * y[0];  // y dot
}

/**
 * @brief Exact solution of the problem. Used for solution comparison.
 *
 * @param[in] 		x 		independent variable
 * @param[in,out]	y		dependent variable
 */
void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}

/**
 * @brief Compute next step approximation using the semi-implicit-Euler
 * method.
 * @param[in] 		dx	step size
 * @param[in,out] 	x	take @f$x_n@f$ and compute @f$x_{n+1}@f$
 * @param[in,out] 	y	take @f$y_n@f$ and compute @f$y_{n+1}@f$
 * @param[in,out]	dy	compute @f$y_n+\frac{1}{2}dx\,f\left(x_n,y_n\right)@f$
 */
void semi_implicit_euler_step(double dx, double *x, double *y, double *dy)
{
    int o;

    problem(x, y, dy);   // update dy once
    y[0] += dx * dy[0];  // update y0

    problem(x, y, dy);  // update dy once more

    for (o = 1; o < order; o++)
        y[o] += dx * dy[o];  // update remaining using new dy
    *x += dx;
}

/**
 * @brief Compute approximation using the semi-implicit-Euler
 * method in the given limits.
 * @param[in] 		dx  	step size
 * @param[in]   	x0  	initial value of independent variable
 * @param[in] 	    x_max	final value of independent variable
 * @param[in,out] 	y	    take \f$y_n\f$ and compute \f$y_{n+1}\f$
 * @param[in] save_to_file	flag to save results to a CSV file (1) or not (0)
 * @returns time taken for computation in seconds
 */
double semi_implicit_euler(double dx, double x0, double x_max, double *y,
                           char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen("semi_implicit_euler.csv", "w+");
        if (fp == NULL)
        {
            perror("Error! ");
            return -1;
        }
    }

    /* start integration */
    clock_t t1 = clock();
    double x = x0;
    do  // iterate for each step of independent variable
    {
        if (save_to_file && fp)
            fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        semi_implicit_euler_step(dx, &x, y, dy);  // perform integration
        x += dx;                                  // update step
    } while (x <= x_max);  // till upper limit of independent variable
    /* end of integration */
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}

/**
    Main Function
*/
int main(int argc, char *argv[])
{
    double X0 = 0.f;          /* initial value of x0 */
    double X_MAX = 10.F;      /* upper limit of integration */
    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */
    double step_size;

    if (argc == 1)
    {
        printf("\nEnter the step size: ");
        scanf("%lg", &step_size);
    }
    else
        // use commandline argument as independent variable step size
        step_size = atof(argv[1]);

    // get approximate solution
    double total_time = semi_implicit_euler(step_size, X0, X_MAX, Y0, 1);
    printf("\tTime = %.6g ms\n", total_time);

    /* compute exact solution for comparion */
    FILE *fp = fopen("exact.csv", "w+");
    if (fp == NULL)
    {
        perror("Error! ");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf("Finding exact solution\n");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf("\tTime = %.6g ms\n", total_time);
    fclose(fp);

    return 0;
}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    float x[20], y[20], a, sum, p;
    int n, i, j;

    printf("Enter the no of entry to insert->");
    scanf("%d", &n);

    for (i = 0; i < n; i++)
    {
        printf("enter the value of x%d->", i);
        scanf("%f", &x[i]);
        printf("enter the value of y%d->", i);
        scanf("%f", &y[i]);
    }
    printf("\n X \t\t Y \n");
    printf("----------------------------\n");
    for (i = 0; i < n; i++)
    {
        printf("%f\t", x[i]);
        printf("%f\n", y[i]);
    }
    printf("\nenter the value of x for interpolation:");
    scanf("%f", &a);
    sum = 0;
    for (i = 0; i < n; i++)
    {
        p = 1.0;
        for (j = 0; j < n; j++)
        {
            if (i != j)
            {
                p = p * (a - x[j]) / (x[i] - x[j]);
            }
            sum = sum + y[i] * p;
        }
        printf("ans is->%f", sum);

        return 0;
    }
}/**
 * @file
 * @brief File used to test the malloc_dbg, calloc_dbg and free_dbg functions.
 * @details
 * This file only have a main function that calls malloc, calloc and free.
 * When the program exits, memory leaks must be printed.
 * @author [tinouduart33](https://github.com/tinouduart33)
 * @see malloc_dbg.c, malloc_dbg.h
 */

#include <stdio.h> /// For IO operations if needed.
#include <stdlib.h> /// For the EXIT_SUCCESS macro and the "real" malloc, calloc and free functions.
#include "malloc_dbg.h" /// For the macros malloc, calloc and free and the malloc_dbg, calloc_dbg and free_dbg functions.


/**
 * @brief Main function
 * @param argc number of arguments (not used)
 * @param argv list of arguments (not used)
 * @returns 0 on exit
 */
int main(int argc, char* argv[])
{
	int* iptr = malloc(10 * sizeof(int));
	char* cptr = calloc(256, sizeof(char));

	free(iptr);
	// free(cptr);

	return 0;
}
/**
 * @file
 * @brief Header file that contains macros used to replace malloc/calloc and free.
 * @details
 * Macros malloc, calloc and free respectively calls malloc_dbg, calloc_dbg and free_dbg.
 * malloc_dbg and calloc_dbg allocates memory using the "real" malloc and calloc and store
 * the pointer returned (with additional informations) in a linked list.
 * Thanks to this linked list, it is possible to check memory leaks.
 * @author [tinouduart33](https://github.com/tinouduart33)
 * @see malloc_dbg.c
 */

#ifndef MALLOC_DBG_H
#define MALLOC_DBG_H

 /** This macro replace the standard malloc function with malloc_dbg.
  * */
#define malloc(bytes) malloc_dbg(bytes, __LINE__, __FILE__, __FUNCTION__)

  /** This macro replace the standard calloc function with calloc_dbg.
   * */
#define calloc(elemCount, elemSize) calloc_dbg(elemCount, elemSize, __LINE__, __FILE__, __FUNCTION__)

   /** This macro replace the standard free function with free_dbg.
	* */
#define free(ptr) free_dbg(ptr)

void* malloc_dbg(size_t bytes, int line, const char* filename, const char* functionName);

void* calloc_dbg(size_t elementCount, size_t elementSize, int line, const char* filename, const char* functionName);

void free_dbg(void* ptrToFree);

void printLeaks(void);

#endif /* MALLOC_DBG_H */
/**
 * @file
 * @brief File used to test min_printf function.
 * @details
 * The test will be executed by comparing the result of both `min_printf` and `printf` functions
 * @author [Jaskarn7](https://github.com/Jaskarn7)
 * @see min_printf.h
*/

#include "min_printf.h" /// for `min_printf` function
#include <stdio.h> /// for `printf` function

/**
 * @brief Main function
 * @details
 * This function is used to test `min_printf` function.
 * The numbers and string used for the test is generated randomly (The user can also specify their own value for tests)
 * First integers were tested then floats and at last strings
 * After running the program the user will see three pair of lines with each pair followed by an empty line
 * In each pair of lines, the first line will be printed by `min_printf` function and next line by the actual `printf` function
 * In each line user will see number or string covered with two colons, they are used to check from where the printing was started and where it ends
 * @returns 0 on exit
*/
int main()
{
    // print strings using `printf` and `min_printf`
    min_printf(":%d: :%1.6d:\n", 12, 56);
    printf(":%d: :%1.6d:\n", 12, 56);

    printf("\n"); /// Printing an empty new line

    // print floats or doubles using `printf` and `min_printf`
    min_printf(":%f: :%3.6f:\n", 104.5654, 43.766443332);
    printf(":%f: :%3.6f:\n", 104.5654, 43.766443332);

    printf("\n");

    // print integers `printf` and `min_printf`
    min_printf(":%s: :%4.3s:\n", "Hello, World!", "Hello, World!");
    printf(":%s: :%4.3s:\n", "Hello, World!", "Hello, World!");

}
/**
 * @file
 * @brief Implementation of a [function](https://www.geeksforgeeks.org/variable-length-argument-c) similar to `printf`
 * @details
 * `printf` statement rewritten (as `min_printf`) in C without using the `stdio.h` library 
 * Syntax of `min_printf` is same as `printf`
 * Currently min_printf handles:
 * 	Integers, Doubles, floats, characters and strings
 * The format specifiers and escape sequence is the same as for `printf`
 * User can also specify the width and precision if required, just like in the case of `printf`
 * How to use it:
 * 	- First include min_printf.h in your code
 * 	- Then type `min_printf()`, and pass required parameters to it
 * 	- As already specified, it's syntax is same as printf 
 * @author [Jaskarn Singh](https://github.com/Jaskarn7)
*/

#ifndef MIN_PRINTF_H
#define MIN_PRINTF_H

#include <stdlib.h> /// for `malloc` and `free` functions
#include <unistd.h> /// for `write` function
#include <stdarg.h> /// for `va_start` and `va_arg` functions

#define INT_MAX_LENGTH 10       /// used as standard length of string to store integers
#define PRECISION_FOR_FLOAT 8   /// default precision for float or double if not specified

/**
 * @brief struct used to store character in certain times
*/
typedef struct buffer {
	char buffr_char; // Character will be stored in this variable
	int buf_size; // Checks if character is present in buffr_char or not, 0 if no and 1 if yes
} Buffer;

/**
 * @details 
 * This function return ten to the power a(The parameter specified to it) like:
 * 		if the parameter specified is 4 i.e. -> power_of_ten(4) is called then
 * 		this function will return ten to the power four (10000);
 * @param a The power of ten which is to be returned
 * @return Ten to the power a
 */
int power_of_ten(int a)
{
	int n = 1; ///< This number will be returned as ten to power of a
	for (int i = 1; i <= a; ++i)
		n *= 10 ;
	return n;
}

/**
 * @brief Checks if a character is a number
 * @param c character to be checked if it's a number or not
 * @return `true`(1) if the character is a number 
 * @return `false`(0) if the character is NOT a number
*/
int is_number(char *c)
{
	return (*c >= '0' && *c <= '9') ? 1 : 0;
}

/**
 * @brief Returns specific required next character
 * @param p pointer to a format string of `min_printf()`
 * @param buffer struct for checking if buffr_char character is present or not
 * @return character inside `buffer->buffr_char`, if `buffer->buf_size` is one
 * @return character at which p is pointing, if `buffer->buf_size` is zero
 */
char get_ch(char *p, Buffer *buffer)
{
	if (buffer->buf_size) {
		buffer->buf_size = 0; ///< Since character is used, this sets `buffer->buf_size` to zero
		return buffer->buffr_char; // Returns character inside buffer->buffr_char
	}
	return *p++;
}

/**
 * @brief Stores character to the `buffer->buffr_char`
 * @param c character to be stored in the `buffer->buffr_char`
 * @param buffer struct where character will be stored
*/
void unget_ch(char *c, Buffer *buffer)
{
	buffer->buffr_char = *c;	// Character initializes inside buffer->buffr_char
	buffer->buf_size = 1; // Sets bufsize to one as new character is stored in buffr_char
}


/**
 * @brief Calculates the number of digits in a number
 * @param n number whose digits are to be counted
 * @return number of digits in n
*/
int get_number_of_digits(int n)
{
	int digits = 0; // Stores encountered number of digits
	while (n > 0) {
		++digits; // Since number still contains a digit, so increment digit variable
		n /= 10; // Removes last digit from number
	}
	return digits;
}

/**
 * @brief Prints one character on screen
 * @param s character to be printed on the screen
*/
void put_char(char s)
{
	/* buf used for storing character to be printed in an array (+1 for '\0')*/
	char *buf = (char *) malloc(sizeof(char) + 1); 
	*buf = s;
	*(buf + 1) = '\0';
	write(1, buf, 1);
	free(buf);
}

/**
 * @brief Reverses a string using [two pointer algorithm](https://www.geeksforgeeks.org/program-reverse-array-using-pointers/?ref=rp)
 * @param p pointer to the string which is to be reversed
*/
void reverse_str(char *p)
{
	char *l = p; // Points to first character of p
	char *h = p; // Will be used to point to last character of p
	char temp; // Temporarily stores a character, Used in swapping

	while (*h != '\0') 
		++h;
	--h; // Now h point to last valid character of string 

	/* Swap character which lower and higher are pointing until lower < higher. At that point string will be reversed.*/
	while (l < h) {
		temp = *l;
		*l = *h;
		*h = temp;
		++l; // Increment lower to next character
		--h; // Decrement higher to previous character from current character
	}
}

/**
 * @details
 * The algorithm here is to first convert the number into 
 * string and then reverse it be passing it to reverse_str function
 * and then printing on the screen
 * @param n Number to be printed
 * @param width Total characters to be printed (Prints ' ' if (size < width)
 * @param precision Total character of number to be printed (prints 0 before number if size of number < precision)
 * 
*/
void print_int_value(int n, int width, int precision)
{
	char *p = (char *) malloc(INT_MAX_LENGTH * sizeof(char) + 1); /* +1 for '\0' */
	char *s = p; // Temporary pointer
	int size = 0; //!< Used to store number of digits in number

	while (n > 0) {
		*s++ = n % 10 + '0'; // Converts last digit of number to character and store it in p
		++size; // Increment size variable as one more digit is occured
		n /= 10; // Removes the last digit from the number n as we have successfully stored it in p
	}
	*s = '\0';

	s = p; // Again point back s to starting of p

	reverse_str(p);

	/*!
	 * The next two conditions check weather it is required to 
	 * add blanks before printing the number (ie: width)and is it specified how many
	 * zeros to be printed before the number is printed (ie: precision)
	*/
	if (width > 0 && size < width)
		for (int i = 0; i < (width - precision); ++i) 
			put_char(' ');

	if (precision > 0 && precision > size)
		for (int i = 0; i < (precision - size); ++i)
			put_char('0');

	/* Prints the number.*/
	while (*s != '\0')
		put_char(*s++);

	free(p);
}

/**
* @brief The algorithm here is also the same as the `print_int_value` function
 *
 * @details
 * First, the digits before decimal is printed by converting the double 
 * to int. Then after printed a `.`, the double number is subtracted with
 * the integer value of the number, leaving us with 0 before the decimal.
 * Then, we multiply the number with 10 raised to the power precision (
 * precision means how many digits to be printed after the decimal.)
 * By default, the precision is 8 if it is not specified.
 * Then, the remaining number is printed on the screen.
 * @param dval double number to be printed
 * @param width similar to width parameter of print_int_value()
 * @param precision tells the number of digits to be printed after the decimal (By default it is 8)
 */
void print_double_value(double dval, int width, int precision)
{
	int ndigits = get_number_of_digits((int) dval); // Store number of digits before decimal in dval
	int reqd_blanks = width - (precision + 1) - ndigits; // Blanks to be printed before printing dval, just to cover the width
	
	print_int_value((int) dval, reqd_blanks, 0); // Prints the part before decimal

	put_char('.'); // Print decimal

	/*Deletes digits before decimal and makes them zero. For example:
		if dval = 1923.79022, them this will make dval = 0.79022
	*/
	dval = dval - (int) dval;

	dval *= power_of_ten(precision); // Brings precision number of digits after decimal to before decimal
	
	print_int_value((int) dval, 0, precision); // Prints the remaining number
}

/**
 * @details
* First size of the string is calculated to check whether
* width and precision are to be taken into account or not.
* Then, the string is printed in accordingly.
* @param p pointer to string to be printed
* @param width if (width > sizeof string) then, blanks will be printed before sting to cover up the width
* @param precision total characters of the string to be printed (prints the whole string if 0 or greater than size of string)
*/
void print_string(char *p, int width, int precision)
{
	int size = 0; // Stores number of character in string
	char *s = p; // Temporary pointer

	/* Calculates size of string p*/
	while (*s != '\0') { 
		++size;
		++s;
	}

	s = p; // Point s to starting of p

	/* Checks how many characters to be printed.
		if precision is defined then size variable is changed to precision so that only precision
		number of characters were printed.
	*/
	if (precision != 0 && precision < size)
		size = precision;

	/* Prints blanks to cover the width if required*/
	for (int i = 0; i < (width - size); ++i)
		put_char(' ');

	/* Print the string.*/
	for (int i = 0; i < size; ++i)
		put_char(*s++);

}

/**
* @brief Takes width and precision specified from the format of the string
* @param p pointer of the format string
* @param width variable in which width will be stored
* @param precision variable in which precision will be stored
* @return character pointer to the current pointer of string p (used to update value of p)
*/
char *get_width_and_precision(char *p, Buffer *buffer, int *width, int *precision)
{
	/* Skip % if p is pointing to it.*/
	if (*p == '%')
		++p;
	
	/* Calculates the width specified. */
	while (*p != '.' && is_number(p)) 
		*width = *width * 10 + (*p++ - '0');

	/* Calculates the precision specified.*/
	if (*p == '.' /* Since a precision is always specified after a '.'. */) { 
		while (is_number(++p))
			*precision = *precision * 10 + (*p - '0'); 
		unget_ch(p, buffer); // The non number will be stored in `buffer->buffr`
	}
	return p;
}

/**
 * min_printf is the function same as printf
 * @param fmt format of string
 * @param ... arguments passed according to the format
*/
void min_printf(char *fmt, ...)
{
	va_list ap; // Points to each unnamed arg in turn
	char *p, *sval; // p will be used to point to fmt and sval will store string value
	char cval; // Stores character value
	int ival; // For integer values
	double dval; // For double or float values
	va_start(ap, fmt); // Makes ap points to first unnames argument

	/* Initializing the buffer for storing character. */
	Buffer *buffer = (Buffer *) malloc(sizeof(Buffer));
	buffer->buf_size = 0; // Initially set buffer size to zero as no character is inserted

	for (p = fmt; *p != '\0'; ++p) {
		
		/* If p != '%' then the character is printed to screen. */
		if (*p != '%') {
			put_char(*p);
			continue;
		}
		
		int width = 0; // Stores width specified
		int precision = 0; // Stores precision specified

		/* Updates values of width, precision and p. */
		p = get_width_and_precision(p, buffer, &width, &precision); 
		
		/* Checks format of next argument.*/
		switch (get_ch(p, buffer)) {
			case 'd': // Integer
				ival = va_arg(ap, int);
				print_int_value(ival, width, precision);
				break;
			case 'c': // Character
				cval = va_arg(ap, int);
				put_char(cval);
				break;
			case 'f': // Float or Double
				dval = va_arg(ap, double);

				// If precision is not specified then default value is applied
				if (precision == 0)
					precision = PRECISION_FOR_FLOAT;
				print_double_value(dval, width, precision);
				break;
			case 's': // String pointer
				sval = va_arg(ap, char *);
				print_string(sval, width, precision);
				break;
			default:
				put_char(*p);
				break;
		}
	}
	va_end(ap);
}

#endif /* MIN_PRINTF_H */
/**
 * @file
 * @brief This file contains malloc_dbg, calloc_dbg, free_dbg and printLeaks implementations.
 * @author [tinouduart33](https://github.com/tinouduart33)
 */

#include <stdlib.h> /// For the malloc, calloc and free functions.
#include <stdio.h> /// For IO operations (printf).
#include <string.h> /// For the memcmp function.
#include "malloc_dbg.h" /// Header file which contains the prototypes of malloc_dbg, calloc_dbg and fre_dbg.

/* We must undef these macros in order to use the real malloc / calloc and free functions */
#undef malloc
#undef calloc
#undef free

/**
 * @brief Structure used to save an allocated pointer
 */
typedef struct MEMORY_INFORMATION
{
	void* ptr; ///< Pointer returned by malloc / calloc
	const char* fileName; ///< File in which malloc or calloc has been called
	const char* functionName; ///< Function in which malloc or calloc has been called
	size_t bytes; ///< Number of bytes allocated
	int line; ///< Line number (in file) corresponding to the malloc / calloc call
	struct MEMORY_INFORMATION* next; ///< Next element in the list
	struct MEMORY_INFORMATION* previous; ///< Previous element in the list
} mem_info;

/** We use a global variable for the list so we can use it at any time.
 * */
mem_info* memoryInformation = NULL;

/** Another global variable. This one is used to know if we already call the atexit function.
 * */
int atexitCalled = 0;


/**
 * @brief addMemInfo function add a memory allocation in the memoryInfo list.
 * @details This function creates a new element and add it on top of the list
 * @param memoryInfo Pointer to the doubly linked list used to store all of the allocations
 * @param ptrToreturn Pointer returned by malloc or calloc
 * @param bytes Size in bytes of the allocation
 * @param line Line where the allocation has been called
 * @param filename File where the allocation has been called
 * @param functionName Name of the function where the allocation has been called
 * @returns mem_info pointer if it succeeds, NULL otherwise
 */
mem_info* addMemInfo(mem_info* memoryInfo, void* ptrToReturn, size_t bytes, int line, const char* filename, const char* functionName)
{
	mem_info* newMemInfo = (mem_info*)malloc(sizeof(mem_info));
	if (!newMemInfo)
	{
		return NULL;
	}

	newMemInfo->ptr = ptrToReturn;
	newMemInfo->bytes = bytes;
	newMemInfo->line = line;
	newMemInfo->fileName = filename;
	newMemInfo->functionName = functionName;
	newMemInfo->next = memoryInfo;
	newMemInfo->previous = NULL;
	if (memoryInformation)
		memoryInformation->previous = newMemInfo;

	return newMemInfo;
}

/**
 * @brief inList function is used to know if an element is already in the memoryInfo list.
 * @details This function is used to know if an allocation in a specific file at a specific line already exists in the list.
 * @param filename File in which malloc or calloc has been called
 * @param line Line number in the file in which malloc or calloc has been called
 * @returns Position of the element in the list if the element is found, -1 otherwise.
 */
int inList(const char* filename, int line)
{
	mem_info* tmp = memoryInformation;
	int counter = 0;
	int len = strlen(filename);

	while (tmp)
	{
		if (len == strlen(tmp->fileName))
		{
			if (!memcmp(filename, tmp->fileName, len) && tmp->line == line)
			{
				return counter;
			}
		}
		tmp = tmp->next;
		counter++;
	}
	return -1;
}

/**
 * @brief editInfo function is used to edit an element in the memoryInfo list.
 * @details This function is used to edit the number of bytes allocated at a specific line.
 * @param elemPos Position of an element in the doubly linked list memoryInfo
 * @param bytes Size of the allocation in bytes
 * @returns Nothing.
 */
void editInfo(int elemPos, size_t bytes)
{
	int counter = 0;
	mem_info* tmp = memoryInformation;

	while (counter != elemPos)
	{
		tmp = tmp->next;
		counter++;
	}
	tmp->bytes += bytes;
}

/**
 * @brief malloc_dbg function is a wrapper around the malloc function.
 * @details This function calls malloc and allocates the number of bytes passed in the parameters.
 * If the allocation succeeds then it add the pointer returned by malloc in the mem_info list.
 * @param bytes Size of the allocation in bytes
 * @param filename Caller file
 * @param functionName Caller function
 * @returns Pointer returned by malloc if it's valid, NULL otherwhise.
 */
void* malloc_dbg(size_t bytes, int line, const char* filename, const char* functionName)
{
	void* ptrToReturn = malloc(bytes);
	int pos = 0;
	if (!ptrToReturn)
	{
		return NULL;
	}

	// We must check atexitCalled value to know if we already called the function
	if (!atexitCalled)
	{
		atexit(printLeaks); // Used to call printLeaks when the program exit
		atexitCalled = 1;
	}

	pos = inList(filename, line);
	if (pos == -1)
	{
		// Add a new element in the mem_info list
		memoryInformation = addMemInfo(memoryInformation, ptrToReturn, bytes, line, filename, functionName);
		if (!memoryInformation)
		{
			free(ptrToReturn);
			return NULL;
		}
	}
	else
	{
		editInfo(pos, bytes);
	}
	return ptrToReturn;
}

/**
 * @brief calloc_dbg function is a wrapper around the calloc function.
 * @details This function calls calloc and allocates the number of bytes passed in the parameters.
 * If the allocation succeeds then it add the pointer returned by malloc in the mem_info list.
 * @param elementCount number of element to allocate
 * @param elementSize Size of each element
 * @param line Line number in the caller file
 * @param filename Caller file
 * @param functionName Caller function
 * @returns Pointer returned by calloc if it's valid, NULL otherwhise.
 */
void* calloc_dbg(size_t elementCount, size_t elementSize, int line, const char* filename, const char* functionName)
{
	void* ptrToReturn = calloc(elementCount, elementSize);
	if (!ptrToReturn)
	{
		return NULL;
	}

	// We must check atexitCalled value to know if we already called the function
	if (!atexitCalled)
	{
		atexit(printLeaks); // Used to call printLeaks when the program exit
		atexitCalled = 1;
	}

	// Add a new element in the mem_info list
	memoryInformation = addMemInfo(memoryInformation, ptrToReturn, elementCount * elementSize, line, filename, functionName);
	if (!memoryInformation)
	{
		free(ptrToReturn);
		return NULL;
	}

	return ptrToReturn;
}

/**
 * @brief free_dbg function is used to free the memory allocated to a pointer.
 * @details This function free the memory pointed by the pointer passed in parameter.
 * To free this pointer, we loop through the mem_info list and check if we find the pointer.
 * Once it's found, the pointer is freed and the element is deleted from the list.
 * @param ptrToFree Pointer that must be freed
 * @returns Nothing.
 */
void free_dbg(void* ptrToFree)
{
	mem_info* tmp = memoryInformation;
	mem_info* toFree = NULL;
	mem_info* previous = NULL;

	// Check if the head contains the pointer to free
	if (tmp->ptr == ptrToFree)
	{
		toFree = tmp;
		memoryInformation = tmp->next;
		free(toFree->ptr);
		free(toFree);
		if (memoryInformation)
		{
			memoryInformation->previous = NULL;
		}
		return;
	}

	// We can loop through the list without any problems, the head is not the pointer
	while (tmp)
	{
		if (tmp->ptr == ptrToFree) // If we found the pointer that must be freed
		{
			toFree = tmp;
			tmp = tmp->next;
			previous = toFree->previous;

			if (previous)
			{
				previous->next = tmp;
			}
			if (tmp)
			{
				tmp->previous = previous;
			}

			free(toFree->ptr);
			if (toFree == memoryInformation)
			{
				memoryInformation = NULL;
			}
			free(toFree);
			return;
		}
		tmp = tmp->next;
	}
}

/**
 * @brief printLeaks function is used to print all the memory leaks.
 * @details This function is called when the program exits. It loop through the mem_info list and if it's not empty,
 * it prints the memory leaks.
 * @returns Nothing.
 */
void printLeaks()
{
	mem_info* tmp = memoryInformation;
	mem_info* previous = NULL;
	size_t sum = 0;
	int nbBlocks = 0;

	if (tmp)
	{
		printf("Memory Leaks detected.\n");
	}

	while (tmp)
	{
		previous = tmp;
		printf("\n%ld bytes lost\n", tmp->bytes);
		printf("address : 0x%p in %s\t%s:%d\n", tmp->ptr, tmp->functionName, tmp->fileName, tmp->line);
		printf("\n====================================\n");
		sum += tmp->bytes;
		tmp = tmp->next;
		free(previous);
		nbBlocks++;
	}

	printf("SUMMARY :\n%ld bytes lost in %d blocks\n", sum, nbBlocks);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *to_rna(const char s[])
{
    /* determines the length of the given string */
    int len = strlen(s);

    /* creates a return string */
    char *ans = malloc(sizeof(char) * len);

    /* for the loop */
    int i = 0;

    /* actual compile process */
    for (i = 0; i < len; i++)
    {
        switch (s[i])
        {
        case 'G':
            ans[i] = 'C';
            break;
        case 'C':
            ans[i] = 'G';
            break;
        case 'T':
            ans[i] = 'A';
            break;
        case 'A':
            ans[i] = 'U';
            break;
        }
    }

    return ans;
}#ifndef __RNA_TRANSCRIPTION__H
#define __RNA_TRANSCRIPTION__H

/* to_rna: compiles a DNA strand in its RNA complement */
char *to_rna(const char s[]);

#endif#include "hello_world.h"
#include <stdlib.h>
#include <string.h>

const char *hello(void)
{
    char *ans = strdup("Hello, World!");
    /* string is pointer of the first character */
    return ans;
}
#ifndef HELLO_WORLD_H
#define HELLO_WORLD_H

const char *hello(void);

#endif
#include <stdbool.h>
#include <string.h>

/*
    is_isogram: returns true if the given string a isogram, otherwise false.
*/
bool is_isogram(const char phrase[])
{
    /* use 'unsigned' because of the function strlen(...) */
    unsigned int i = 0;
    unsigned int j = 0;

    /* the current read character in the first for-loop */
    char current_char = ' ';

    /* return status */
    bool status = true;

    /* contains the length of the given string */
    unsigned int len_phrase = strlen(phrase);

    for (i = 0; i < len_phrase; i++)
    {
        current_char = phrase[i];

        /* makes sure the current character has no repetition */
        for (j = i + 1; j < len_phrase; j++)
        {
            if (current_char == phrase[j])
            {
                status = false;

                /*
                    because the given string is none isogram.
                    that means we can exit the nested for-loop.
                */
                goto end;
            }
        }
    }

/* exit label */
end:
    return status;
}#ifndef ISOGRAM_H
#define ISOGRAM_H

#include <stdbool.h>

bool is_isogram(const char phrase[]);

#endif
#ifndef WORD_COUNT_H
#define WORD_COUNT_H

#define MAX_WORDS 20  // at most MAX_WORDS can be found in the test input string
#define MAX_WORD_LENGTH 50  // no individual word can exceed this length

// results structure
typedef struct word_count_word
{
    char text[MAX_WORD_LENGTH];
    int count;
} word_count_word_t;

#define EXCESSIVE_LENGTH_WORD -1
#define EXCESSIVE_NUMBER_OF_WORDS -2

// word_count - routine to classify the unique words and their frequency in a
// test input string inputs:
//    input_text =  a null-terminated string containing that is analyzed
//
// outputs:
//    words = allocated structure to record the words found and their frequency
//    uniqueWords - number of words in the words structure
//           returns a negative number if an error.
//           words will contain the results up to that point.
int word_count(const char *input_text, word_count_word_t *words);

#endif
#include "word_count.h"
#include <string.h>

/*
    word_count: returns the full number of words in the input_text,
                otherwise an error code: (see below)

    error codes: EXCESSIVE_LENGTH_WORD     -1
                 EXCESSIVE_NUMBER_OF_WORDS -2

    The function manipulates the given structure of type word_count_word_t
    After that process the member count contains the number of occures.
*/
int word_count(const char *input_text, word_count_word_t *words)
{
    char word_list[MAX_WORDS][MAX_WORD_LENGTH];
    char input[1000];
    strcpy(input, input_text);
    char *p_str = input;

    /* index for iteration over input string */
    int index = 0;

    /* index for word_list */
    int index_list = 0;

    /* counts all words */
    int count_all = 0;

    /* for controlling the while loop */
    int loop = 1;

    /* for the for-loop */
    int i = 0;

    /* collects all words in the word_list */
    while (input[index] && loop)
    {
        if (input[index] == ' ')
        {
            input[index] = '\0';
            if (strlen(p_str) <= MAX_WORD_LENGTH)
            {
                if (index_list <= MAX_WORDS)
                {
                    strcpy(word_list[index_list], p_str);

                    /* sets pointer to the next position */
                    p_str = input + index + 1;
                    index_list++;

                    /* counts the word */
                    count_all++;
                }
                else /* error case too many words */
                {
                    count_all = EXCESSIVE_NUMBER_OF_WORDS;
                    loop = 0;
                }
            }
            else /* error case: word is too long */
            {
                count_all = EXCESSIVE_LENGTH_WORD;
                loop = 0;
            }
        }

        index++;
    }

    words->count = 0;

    /* make sure none error is occured */
    if (loop)
    {
        /* collects the last word up to the \0-character. and counts it.*/
        strcpy(word_list[index_list], p_str);
        count_all++;

        for (i = 0; i <= index_list; i++)
        {
            if (strcmp(word_list[i], words->text) == 0)
            {
                words->count++;
            }
        }
    }

    /* returns the number of words or an error code */
    return count_all;
}#include <ctype.h>
#include <stdio.h>
#include <string.h>

char *abbreviate(const char *phrase)
{
    char str[80];
    strcpy(str, phrase);
    char *p_str = str;
    static char acr[80];
    strcpy(acr, "");

    /* for counting the words */
    int counter = 0;

    /* for position the words */
    int index = 0;

    /* for -loop variable */
    int i = 0;

    /*
        counts the empty-characters.
        for determine the number of words
    */
    while (p_str && (i < 80))
    {
        if (*p_str == ' ')
        {
            counter++;
        }
        if (i < 80)
        {
            p_str++;
            i++;
        }
    }

    i = 0;
    counter++;
    char **words = (char **)malloc(counter * sizeof(char *));

    /* initalizes words-array with empty strings */
    for (i = 0; i < counter; i++)
    {
        words[i] = (char *)malloc(80 * sizeof(char));
        strcpy(words[i], "");
    }

    /* rewind string */
    p_str = str;

    char *p_start = p_str;

    /* collects each word in array 'words' */
    while (p_str && (i <= 80))
    {
        if (*p_str == ' ')
        {
            *p_str = '\0';
            strncat(words[index], p_start, 80);
            index++;
            p_start = p_str + 1;
        }

        if (i <= 80)
        {
            p_str++;
            i++;
        }
    }

    /* adds the last word */
    *p_str = '\0';
    strncat(words[index], p_start, 80);
    index++;

    /* builds the actual acronym */
    for (i = 0; i < index; i++)
    {
        /* capitalize the first character */
        words[i][0] = toupper(words[i][0]);
        words[i][1] = '\0';
        strcat(acr, words[i]);
    }

    for (i = 0; i < counter; i++) free(words[i]);
    free(words);

    return acr;
}
#ifndef ACRONYM_H
#define ACRONYM_H

char *abbreviate(const char *phrase);

#endif
/**
 * @file
 * @author [sunzhenliang](https://github.com/HiSunzhenliang)
 * @brief A-law algorithm for encoding and decoding (16bit pcm <=> a-law).
 * This is the implementation of [G.711](https://en.wikipedia.org/wiki/G.711)
 * in C.
 **/

/**
 * Linear input code | Compressed code | Linear output code
 * ------------------+-----------------+-------------------
 * s0000000abcdx     | s000abcd        | s0000000abcd1
 * s0000001abcdx     | s001abcd        | s0000001abcd1
 * s000001abcdxx     | s010abcd        | s000001abcd10
 * s00001abcdxxx     | s011abcd        | s00001abcd100
 * s0001abcdxxxx     | s100abcd        | s0001abcd1000
 * s001abcdxxxxx     | s101abcd        | s001abcd10000
 * s01abcdxxxxxx     | s110abcd        | s01abcd100000
 * s1abcdxxxxxxx     | s111abcd        | s1abcd1000000
 *
 * Compressed code: (s | eee | abcd)
 **/
#include <assert.h>    /// for assert
#include <inttypes.h>  /// for appropriate size int types
#include <stdio.h>     /// for IO operations

/* length of test inputs */
#define LEN ((size_t)8)

/* input pcm for test */
int16_t pcm[LEN] = {1000, -1000, 1234, 3200, -1314, 0, 32767, -32768};

/* result coded alaw for test */
uint8_t r_coded[LEN] = {250, 122, 230, 156, 97, 213, 170, 42};

/* result decoded for test */
int16_t r_decoded[LEN] = {1008, -1008, 1248, 3264, -1312, 8, 32256, -32256};

/**
 * @brief 16bit pcm to 8bit alaw
 * @param out unsigned 8bit alaw array
 * @param in  signed 16bit pcm array
 * @param len length of pcm array
 * @returns void
 */
void encode(uint8_t *out, int16_t *in, size_t len)
{
    uint8_t alaw = 0;
    int16_t pcm = 0;
    int32_t sign = 0;
    int32_t abcd = 0;
    int32_t eee = 0;
    int32_t mask = 0;
    for (size_t i = 0; i < len; i++)
    {
        pcm = *in++;
        /* 0-7 kinds of quantization level from the table above */
        eee = 7;
        mask = 0x4000; /* 0x4000: '0b0100 0000 0000 0000' */

        /* Get sign bit */
        sign = (pcm & 0x8000) >> 8;

        /* Turn negative pcm to positive */
        /* The absolute value of a negative number may be larger than the size
         * of the corresponding positive number, so here needs `-pcm -1` after
         * taking the opposite number. */
        pcm = sign ? (-pcm - 1) : pcm;

        /* Get eee and abcd bit */
        /* Use mask to locate the first `1` bit and quantization level at the
         * same time */
        while ((pcm & mask) == 0 && eee > 0)
        {
            eee--;
            mask >>= 1;
        }

        /* The location of abcd bits is related with quantization level. Check
         * the table above to determine how many bits to `>>` to get abcd */
        abcd = (pcm >> (eee ? (eee + 3) : 4)) & 0x0f;

        /* Put the quantization level number at right bit location to get eee
         * bits */
        eee <<= 4;

        /* Splice results */
        alaw = (sign | eee | abcd);

        /* The standard specifies that all resulting even bits (LSB
         * is even) are inverted before the octet is transmitted. This is to
         * provide plenty of 0/1 transitions to facilitate the clock recovery
         * process in the PCM receivers. Thus, a silent A-law encoded PCM
         * channel has the 8 bit samples coded 0xD5 instead of 0x80 in the
         * octets. (Reference from wiki above) */
        *out++ = alaw ^ 0xD5;
    }
}

/**
 * @brief 8bit alaw to 16bit pcm
 * @param out signed 16bit pcm array
 * @param in  unsigned 8bit alaw array
 * @param len length of alaw array
 * @returns void
 */
void decode(int16_t *out, uint8_t *in, size_t len)
{
    uint8_t alaw = 0;
    int32_t pcm = 0;
    int32_t sign = 0;
    int32_t eee = 0;
    for (size_t i = 0; i < len; i++)
    {
        alaw = *in++;

        /* Re-toggle toggled bits */
        alaw ^= 0xD5;

        /* Get sign bit */
        sign = alaw & 0x80;

        /* Get eee bits */
        eee = (alaw & 0x70) >> 4;

        /* Get abcd bits and add 1/2 quantization step */
        pcm = (alaw & 0x0f) << 4 | 8;

        /* If quantization level > 0, there need `1` bit before abcd bits */
        pcm += eee ? 0x100 : 0x0;

        /* Left shift according quantization level */
        pcm <<= eee > 1 ? (eee - 1) : 0;

        /* Use the right sign */
        *out++ = sign ? -pcm : pcm;
    }
}

/**
 * @brief Self-test implementations
 * @param pcm signed 16bit pcm array
 * @param coded unsigned 8bit alaw array
 * @param decoded signed 16bit pcm array
 * @param len length of test array
 * @returns void
 */
static void test(int16_t *pcm, uint8_t *coded, int16_t *decoded, size_t len)
{
    /* run encode */
    encode(coded, pcm, len);

    /* check encode result */
    for (size_t i = 0; i < len; i++)
    {
        assert(coded[i] == r_coded[i]);
    }

    /* run decode */
    decode(decoded, coded, len);

    /* check decode result */
    for (size_t i = 0; i < len; i++)
    {
        assert(decoded[i] == r_decoded[i]);
    }
}

/**
 * @brief Main function
 * @param argc commandline argument count (ignored)
 * @param argv commandline array of arguments (ignored)
 * @returns 0 on exit
 */
int main(int argc, char *argv[])
{
    /* output alaw encoded by encode() */
    uint8_t coded[LEN];

    /* output pcm decoded by decode() from coded[LEN] */
    int16_t decoded[LEN];

    test(pcm, coded, decoded, LEN);  // run self-test implementations

    /* print test pcm inputs */
    printf("inputs: ");
    for (size_t i = 0; i < LEN; i++)
    {
        printf("%d ", pcm[i]);
    }
    printf("\n");

    /* print encoded alaw */
    printf("encode: ");
    for (size_t i = 0; i < LEN; i++)
    {
        printf("%u ", coded[i]);
    }
    printf("\n");

    /* print decoded pcm */
    printf("decode: ");
    for (size_t i = 0; i < LEN; i++)
    {
        printf("%d ", decoded[i]);
    }
    printf("\n");

    /* It can be seen that the encoded alaw is smaller than the input PCM, so
     * the purpose of compression is achieved. And the decoded PCM is almost the
     * same as the original input PCM, which verifies the correctness of the
     * decoding. The reason why it is not exactly the same is that there is
     * precision loss during encode / decode.  */

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int partition(int arr[], int low, int high)
{
    int pivot = arr[low];
    int i = low - 1, j = high + 1;

    while (1)
    {
        /* Find leftmost element >= pivot */
        do
        {
            i++;
        } while (arr[i] < pivot);

        /* Find rightmost element <= pivot */
        do
        {
            j--;
        } while (arr[j] > pivot);

        /* if two pointers met */
        if (i >= j)
            return j;

        swap(&arr[i], &arr[j]);
    }
}

void partitionSort(int arr[], int low, int high)
{
    if (low < high)
    {
        int value = partition(arr, low, high);
        partitionSort(arr, low, value);
        partitionSort(arr, value + 1, high);
    }
}

void printArray(int arr[], int n)
{
    int i;
    for (i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
}

int main()
{
    int arr[20];
    int i, range = 100;
    for (i = 0; i < 20; i++)
    {
        arr[i] = rand() % range + 1;
    }
    int size = sizeof arr / sizeof arr[0];
    printf("Array: \n");
    printArray(arr, size);
    partitionSort(arr, 0, size - 1);
    printf("Sorted Array: \n");
    printArray(arr, size);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

void cocktailSort(int arr[], int size)
{
    int i, changed = TRUE, temp, start = 0, end = size - 1;

    while (changed)
    {
        changed = FALSE;
        for (i = start; i < end; i++)
        {
            if (arr[i] > arr[i + 1])
            {
                temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                changed = TRUE;
            }
        }
        end--;

        if (changed == FALSE)
        {
            break;
        }
        changed = FALSE;

        for (i = end - 1; i >= start; i--)
        {
            if (arr[i + 1] < arr[i])
            {
                temp = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = temp;
                changed = TRUE;
            }
        }
        start++;
    }
}

int main()
{
    int i, n;

    printf("Enter the size of the array: ");
    scanf("%d", &n);
    int *arr = (int *)malloc(sizeof(int) * n);

    for (i = 0; i < n; i++)
    {
        printf("Number #%d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("You entered:  ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    cocktailSort(arr, n);
    printf("\nSorted array: ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr);
    return 0;
}/**
 * @file
 * @brief [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm
 * implementation
 */
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * Display elements of array
 * @param arr array to be display
 * @param n length of array
 */
void display(const int *arr, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

/**
 * Swap two values by using pointer
 * @param first first pointer of first number
 * @param second second pointer of second number
 */
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * Bubble sort algorithm implementation
 * @param arr array to be sorted
 * @param size size of array
 */
void bubbleSort(int *arr, int size)
{
    for (int i = 0; i < size - 1; i++)
    {                         /* for each array index */
        bool swapped = false; /* flag to check if any changes had to be made */
        /* perform iterations until no more changes were made or outer loop
            executed for all array indices */
        for (int j = 0; j < size - 1 - i; j++)
        { /* for each element in the array */
            if (arr[j] > arr[j + 1])
            { /* if the order of successive elements needs update */
                swap(&arr[j], &arr[j + 1]);
                swapped = true; /* set flag */
            }
        }
        if (!swapped)
        {
            /* since no more updates we made, the array is already sorted
                this is an optimization for early termination */
            break;
        }
    }
}

/**
 * Test function
 */
void test()
{
    const int size = 10;
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from 0 to 100 */
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    bubbleSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/** Driver Code */
int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
/**
 * @file
 * @brief Implementation of [merge
 * sort](https://en.wikipedia.org/wiki/Merge_sort) algorithm
 */
#include <stdio.h>
#include <stdlib.h>

/**
 * @addtogroup sorting Sorting algorithms
 * @{
 */
/** Swap two integer variables
 * @param [in,out] a pointer to first variable
 * @param [in,out] b pointer to second variable
 */
void swap(int *a, int *b)
{
    int t;
    t = *a;
    *a = *b;
    *b = t;
}

/**
 * @brief Perform merge of segments.
 *
 * @param a array to sort
 * @param l left index for merge
 * @param r right index for merge
 * @param n total number of elements in the array
 */
void merge(int *a, int l, int r, int n)
{
    int *b = (int *)malloc(n * sizeof(int)); /* dynamic memory must be freed */
    int c = l;
    int p1, p2;
    p1 = l;
    p2 = ((l + r) / 2) + 1;
    while ((p1 < ((l + r) / 2) + 1) && (p2 < r + 1))
    {
        if (a[p1] <= a[p2])
        {
            b[c++] = a[p1];
            p1++;
        }
        else
        {
            b[c++] = a[p2];
            p2++;
        }
    }

    if (p2 == r + 1)
    {
        while ((p1 < ((l + r) / 2) + 1))
        {
            b[c++] = a[p1];
            p1++;
        }
    }
    else
    {
        while ((p2 < r + 1))
        {
            b[c++] = a[p2];
            p2++;
        }
    }

    for (c = l; c < r + 1; c++) a[c] = b[c];

    free(b);
}

/** Merge sort algorithm implementation
 * @param a array to sort
 * @param n number of elements in the array
 * @param l index to sort from
 * @param r index to sort till
 */
void merge_sort(int *a, int n, int l, int r)
{
    if (r - l == 1)
    {
        if (a[l] > a[r])
            swap(&a[l], &a[r]);
    }
    else if (l != r)
    {
        merge_sort(a, n, l, (l + r) / 2);
        merge_sort(a, n, ((l + r) / 2) + 1, r);
        merge(a, l, r, n);
    }

    /* no change if l == r */
}
/** @} */

/** Main function */
int main(void)
{
    int *a, n, i;
    scanf("%d", &n);
    a = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
    }

    merge_sort(a, n, 0, n - 1);
    for (i = 0; i < n; i++)
    {
        printf(" %d", a[i]);
    }

    free(a);

    return 0;
}
/*
 * Algorithm : Bucket Sort
 * Time-Complexity : O(n)
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#define NARRAY 8    /* array size */
#define NBUCKET 5   /* bucket size */
#define INTERVAL 10 /* bucket range */

struct Node
{
    int data;
    struct Node *next;
};

void BucketSort(int arr[]);
struct Node *InsertionSort(struct Node *list);
void print(int arr[]);
void printBuckets(struct Node *list);
int getBucketIndex(int value);

void BucketSort(int arr[])
{
    int i, j;
    struct Node **buckets;

    /* allocate memory for array of pointers to the buckets */
    buckets = (struct Node **)malloc(sizeof(struct Node *) * NBUCKET);

    /* initialize pointers to the buckets */
    for (i = 0; i < NBUCKET; ++i)
    {
        buckets[i] = NULL;
    }

    /* put items into the buckets */
    /* creates a link list in each bucket slot */
    for (i = 0; i < NARRAY; ++i)
    {
        struct Node *current;
        int pos = getBucketIndex(arr[i]);
        current = (struct Node *)malloc(sizeof(struct Node));
        current->data = arr[i];
        current->next = buckets[pos];
        buckets[pos] = current;
    }

    /* check what's in each bucket */
    for (i = 0; i < NBUCKET; i++)
    {
        printf("Bucket[\"%d\"] : ", i);
        printBuckets(buckets[i]);
        printf("\n");
    }

    /* sorting bucket using Insertion Sort */
    for (i = 0; i < NBUCKET; ++i)
    {
        buckets[i] = InsertionSort(buckets[i]);
    }

    /* check what's in each bucket */
    printf("--------------\n");
    printf("Buckets after sorted\n");
    for (i = 0; i < NBUCKET; i++)
    {
        printf("Bucket[\"%d\"] : ", i);
        printBuckets(buckets[i]);
        printf("\n");
    }

    /* put items back to original array */
    for (j = 0, i = 0; i < NBUCKET; ++i)
    {
        struct Node *node;
        node = buckets[i];
        while (node)
        {
            // precondition for avoiding out of bounds by the array
            assert(j < NARRAY);
            arr[j++] = node->data;
            node = node->next;
        }
    }

    /* free memory */
    for (i = 0; i < NBUCKET; ++i)
    {
        struct Node *node;
        node = buckets[i];
        while (node)
        {
            struct Node *tmp;
            tmp = node;
            node = node->next;
            free(tmp);
        }
    }
    free(buckets);
    return;
}

/* Insertion Sort */
struct Node *InsertionSort(struct Node *list)
{
    struct Node *k, *nodeList;
    /* need at least two items to sort */
    if (list == NULL || list->next == NULL)
    {
        return list;
    }

    nodeList = list;
    k = list->next;
    nodeList->next = NULL; /* 1st node is new list */
    while (k != NULL)
    {
        struct Node *ptr;
        /* check if insert before first */
        if (nodeList->data > k->data)
        {
            struct Node *tmp;
            tmp = k;
            k = k->next;  // important for the while
            tmp->next = nodeList;
            nodeList = tmp;
            continue;
        }

        // from begin up to end
        // finds [i] > [i+1]
        for (ptr = nodeList; ptr->next != NULL; ptr = ptr->next)
        {
            if (ptr->next->data > k->data)
                break;
        }

        // if found (above)
        if (ptr->next != NULL)
        {
            struct Node *tmp;
            tmp = k;
            k = k->next;  // important for the while
            tmp->next = ptr->next;
            ptr->next = tmp;
            continue;
        }
        else
        {
            ptr->next = k;
            k = k->next;  // important for the while
            ptr->next->next = NULL;
            continue;
        }
    }
    return nodeList;
}

int getBucketIndex(int value) { return value / INTERVAL; }

void print(int ar[])
{
    int i;
    for (i = 0; i < NARRAY; ++i)
    {
        printf("%d ", ar[i]);
    }
    printf("\n");
}

void printBuckets(struct Node *list)
{
    struct Node *cur = list;
    while (cur)
    {
        printf("%d ", cur->data);
        cur = cur->next;
    }
}

int main(void)
{
    int array[NARRAY] = {29, 25, -1, 49, 9, 37, 21, 43};

    printf("Initial array\n");
    print(array);
    printf("------------\n");

    BucketSort(array);
    printf("------------\n");
    printf("Sorted array\n");
    print(array);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ELEMENT_NR 20000
#define ARRAY_LEN(x) (sizeof(x) / sizeof((x)[0]))
const char *notation =
    "Shell Sort Big O Notation:\
						\n--> Best Case: O(n log(n)) \
						\n--> Average Case: depends on gap sequence \
						\n--> Worst Case: O(n)";

void show_data(int arr[], int len)
{
    int i;

    for (i = 0; i < len; i++) printf("%3d ", arr[i]);
    printf("\n");
}

void swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}

void shellSort(int array[], int len)
{
    int i, j, gap;

    for (gap = len / 2; gap > 0; gap = gap / 2)
        for (i = gap; i < len; i++)
            for (j = i - gap; j >= 0 && array[j] > array[j + gap]; j = j - gap)
                swap(&array[j], &array[j + gap]);
}

int main(int argc, char *argv[])
{
    int i;
    int array[ELEMENT_NR];
    int range = 500;
    int size;
    clock_t start, end;
    double time_spent;

    srand(time(NULL));
    for (i = 0; i < ELEMENT_NR; i++) array[i] = rand() % range + 1;

    size = ARRAY_LEN(array);

    show_data(array, size);
    start = clock();
    shellSort(array, size);
    end = clock();
    time_spent = (double)(end - start) / CLOCKS_PER_SEC;

    printf("Data Sorted\n");
    show_data(array, size);

    printf("%s\n", notation);
    printf("Time spent sorting: %.4g ms\n", time_spent * 1e3);

    return 0;
}
/**
 * @file
 * @brief Sorting of array list using [bead
 * sort](https://en.wikipedia.org/wiki/Bead_sort)
 */
#include <stdio.h>
#include <stdlib.h>

/**
 * @addtogroup sorting Sorting algorithms
 * @{
 */
/** Create easy access of elements from a 2D matrix stored in memory as a 1D
 * array
 */
#define BEAD(i, j) beads[i * max + j]

/**
 * Displays the array, passed to this method
 * @param [in] arr array to display
 * @param [in] n number of elements in the array
 */
void display(const int *arr, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

/** This is where the sorting of the array takes place
 * @param [in,out] a array to be sorted
 * @param [in] len Array Size
 */
void bead_sort(int *a, size_t len)
{
    int i, j, max, sum;
    unsigned char *beads;

    for (i = 1, max = a[0]; i < len; i++)
        if (a[i] > max)
            max = a[i];

    beads = calloc(1, max * len);

    /* mark the beads */
    for (i = 0; i < len; i++)
        for (j = 0; j < a[i]; j++) BEAD(i, j) = 1;

    for (j = 0; j < max; j++)
    {
        /* count how many beads are on each post */
        for (sum = i = 0; i < len; i++)
        {
            sum += BEAD(i, j);
            BEAD(i, j) = 0;
        }
        /* mark bottom sum beads */
        for (i = len - sum; i < len; i++) BEAD(i, j) = 1;
    }

    for (i = 0; i < len; i++)
    {
        for (j = 0; j < max && BEAD(i, j); j++)
            ;
        a[i] = j;
    }
    free(beads);
}
/** @} */

/** Main function */
int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  // E.g. 8 1 2 3

    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);

    bead_sort(arr, n);

    printf("Sorted array: ");
    display(arr, n);

    free(arr);
    return 0;
}
#include <stdio.h>

void max_heapify(int *a, int i, int n);
void heapsort(int *a, int n);
void build_maxheap(int *a, int n);

void max_heapify(int *a, int i, int n)
{
    int j, temp;
    temp = a[i];
    j = 2 * i;
    while (j <= n)
    {
        if (j < n && a[j + 1] > a[j])
            j = j + 1;
        if (temp > a[j])
        {
            break;
        }
        else if (temp <= a[j])
        {
            a[j / 2] = a[j];
            j = 2 * j;
        }
    }
    a[j / 2] = temp;
    return;
}

void heapsort(int *a, int n)
{
    int i, temp;
    for (i = n; i >= 2; i--)
    {
        temp = a[i];
        a[i] = a[1];
        a[1] = temp;
        max_heapify(a, 1, i - 1);
    }
}

void build_maxheap(int *a, int n)
{
    int i;
    for (i = n / 2; i >= 1; i--)
    {
        max_heapify(a, i, n);
    }
}

int main()
{
    int n, i;
    printf("Enter number of elements of array\n");
    scanf("%d", &n);
    int a[20];
    for (i = 1; i <= n; i++)
    {
        printf("Enter Element %d\n", i);
        scanf("%d", a + i);
    }

    build_maxheap(a, n);
    heapsort(a, n);
    printf("Sorted Output\n");
    for (i = 1; i <= n; i++)
    {
        printf("%d\n", a[i]);
    }

    getchar();
}
/**
 * @file
 * @brief implementation of [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm
 * @details
 * worst-case: O(n^2)
 * best-case: O(n)
 * average-complexity: O(n^2)

 * @author Unknown author
 * @author [Gabriel Fioravante](https://github.com/northernSage)
 */

#include <stdlib.h>   /// for rand() calls
#include <assert.h>   /// for assert(<expr>)
#include <stdbool.h>  /// for boolean values: true, false  

#define MAX 20

/**
 * @brief Bubble sort implementation
 * @param array_sort the array to be sorted
 * @returns void
 */
void bubble_sort(int* array_sort)
{
	bool is_sorted = false;

    /* keep iterating over entire array
     * and swaping elements out of order
     * until it is sorted */
    while (!is_sorted)
    {
		is_sorted = true;

        /* iterate over all elements */
        for (int i = 0; i < MAX - 1; i++)
        {
            /* check if adjacent elements are out of order */
            if (array_sort[i] > array_sort[i + 1])
            {
                /* swap elements */
                int change_place = array_sort[i];
                array_sort[i] = array_sort[i + 1];
                array_sort[i + 1] = change_place;
                /* elements out of order were found
                 * so we reset the flag to keep ordering
                 * until no swap operations are executed */
                is_sorted = false;
            }
        }
    }
}

/**
 * @brief Test implementations
 * @returns void
 */
static void test() {
    /* simple int array for testing */
	int array_sort[MAX] = {0};

    /* populate our test array with 
     * random integer numbers */
    for (int i = 0; i < MAX; i++)
    {
        array_sort[i] = rand() % 101;
    }

    /* sort array */
    bubble_sort(array_sort);

    /* check if array ir correctly ordered */	
    for (int i = 0; i < MAX - 1; i++)
    {
        assert(array_sort[i] <= array_sort[i+1]);
    }
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    test();  // run self-test implementations
    return 0;
}
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

bool check_sorted(int *a, int n)
{
    while (--n >= 1)
    {
        if (a[n] < a[n - 1])
            return false;
    }
    return true;
}

void shuffle(int *a, int n)
{
    int i, t, r;
    for (i = 0; i < n; i++)
    {
        t = a[i];
        r = rand() % n;
        a[i] = a[r];
        a[r] = t;
    }
}

void sort(int *a, int n)
{
    while (!check_sorted(a, n)) shuffle(a, n);
}

int main()
{
    int numbers[6];
    int i;
    printf("Enter 6 numbers unsorted \n\n");
    for (i = 0; i < 6; i++)
    {
        scanf("%d", &numbers[i]);
    }
    sort(numbers, 6);
    for (i = 0; i < 6; i++) printf("%d ", numbers[i]);
    printf("\n");
}
// Sorting of array list using pancake sort
#include <stdio.h>
#include <stdlib.h>

/* Reverses the array */
void flip(int arr[], int i)
{
    int temp, start = 0;

    while (start < i)
    {
        temp = arr[start];
        arr[start] = arr[i];
        arr[i] = temp;
        start++;
        i--;
    }
}

// Returns index of the maximum element in arr[0..n-1]
int findMax(int arr[], int n)
{
    int maxElementIdx, i;

    for (maxElementIdx = 0, i = 0; i < n; ++i)
        if (arr[i] > arr[maxElementIdx])
            maxElementIdx = i;

    return maxElementIdx;
}

// Sorts the array using flip operations
void pancakeSort(int *arr, int n)
{
    // Start from the complete array and one by one reduce current size by one
    for (int curr_size = n; curr_size > 1; --curr_size)
    {
        // Find index of the maximum element in arr[0..curr_size-1]
        int maxElementIdx = findMax(arr, curr_size);

        // Move the maximum element to end of current array if it's not already
        // at the end
        if (maxElementIdx != curr_size - 1)
        {
            // To move at the end, first move maximum number to beginning
            flip(arr, maxElementIdx);

            // Now move the maximum number to end by reversing current array
            flip(arr, curr_size - 1);
        }
    }
}

// Displays the array, passed to this method
void display(int arr[], int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

#define N 50

// Driver program to test above function
int main()
{
    int arr[N];
    for (int i = 0; i < N; i++)
        arr[i] = rand() % (N << 1); /* random numbers from 0 to 2N */

    printf("Original array: ");
    display(arr, N);

    pancakeSort(arr, N);
    printf("Sorted array: ");
    display(arr, N);

    return 0;
}/* Sorting of array list using binary insertion sort
 * Using binary search to find the proper location for
 * inserting the selected item at each iteration. */
#include <stdio.h>
#include <stdlib.h>

/*Displays the array, passed to this method*/
void display(int *arr, int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int binarySearch(int *arr, int key, int low, int high)
{
    if (low >= high)
        return (key > arr[low]) ? (low + 1) : low;
    int mid = low + (high - 1) / 2;
    if (arr[mid] == key)
        return mid + 1;
    else if (arr[mid] > key)
        return binarySearch(arr, key, low, mid - 1);
    else
        return binarySearch(arr, key, mid + 1, high);
}
/*This is where the sorting of the array takes place
 arr[] --- Array to be sorted
 size --- Array Size
 */
void insertionSort(int *arr, int size)
{
    int i, j, key, index;
    for (i = 0; i < size; i++)
    {
        j = i - 1;
        key = arr[i];
        /* Use binrary search to find exact key's index */
        index = binarySearch(arr, key, 0, j);
        /* Move all elements greater than key from [index...j]
         * to one position */
        while (j >= index)
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        /* Insert key value in right place */
        arr[j + 1] = key;
    }
}

int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  // E.g. 8

    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);

    insertionSort(arr, n);

    printf("Sorted array: ");
    display(arr, n);

    free(arr);
    return 0;
}
/* demo.c -- Implementations of multikey quicksort and ternary search trees
   Usage
    demo                  Run basic timings on /usr/dict/words
    demo <file>           Run basic timings on <file>
    demo <file> trysearch Interactive pm and nn search on <file>
    demo <file> nncost    Run near neigbhor expers on <file>
    demo <file> pmcost    Interactive partial match expers on <file>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// MULTIKEY QUICKSORT

#ifndef min
#define min(a, b) ((a) <= (b) ? (a) : (b))
#endif

#define swap(a, b)      \
    {                   \
        char *t = x[a]; \
        x[a] = x[b];    \
        x[b] = t;       \
    }
#define i2c(i) x[i][depth]

void vecswap(int i, int j, int n, char *x[])
{
    while (n-- > 0)
    {
        swap(i, j);
        i++;
        j++;
    }
}

void ssort1(char *x[], int n, int depth)
{
    int a, b, c, d, r, v;
    if (n <= 1)
        return;
    a = rand() % n;
    swap(0, a);
    v = i2c(0);
    a = b = 1;
    c = d = n - 1;
    for (;;)
    {
        while (b <= c && (r = i2c(b) - v) <= 0)
        {
            if (r == 0)
            {
                swap(a, b);
                a++;
            }
            b++;
        }
        while (b <= c && (r = i2c(c) - v) >= 0)
        {
            if (r == 0)
            {
                swap(c, d);
                d--;
            }
            c--;
        }
        if (b > c)
            break;
        swap(b, c);
        b++;
        c--;
    }
    r = min(a, b - a);
    vecswap(0, b - r, r, x);
    r = min(d - c, n - d - 1);
    vecswap(b, n - r, r, x);
    r = b - a;
    ssort1(x, r, depth);
    if (i2c(r) != 0)
        ssort1(x + r, a + n - d - 1, depth + 1);
    r = d - c;
    ssort1(x + n - r, r, depth);
}

void ssort1main(char *x[], int n) { ssort1(x, n, 0); }

// ssort2 -- Faster Version of Multikey Quicksort

void vecswap2(char **a, char **b, int n)
{
    while (n-- > 0)
    {
        char *t = *a;
        *a++ = *b;
        *b++ = t;
    }
}

#define swap2(a, b)  \
    {                \
        t = *(a);    \
        *(a) = *(b); \
        *(b) = t;    \
    }
#define ptr2char(i) (*(*(i) + depth))

char **med3func(char **a, char **b, char **c, int depth)
{
    int va, vb, vc;
    if ((va = ptr2char(a)) == (vb = ptr2char(b)))
        return a;
    if ((vc = ptr2char(c)) == va || vc == vb)
        return c;
    return va < vb ? (vb < vc ? b : (va < vc ? c : a))
                   : (vb > vc ? b : (va < vc ? a : c));
}
#define med3(a, b, c) med3func(a, b, c, depth)

void inssort(char **a, int n, int d)
{
    char **pi, **pj, *s, *t;
    for (pi = a + 1; --n > 0; pi++)
        for (pj = pi; pj > a; pj--)
        {
            // Inline strcmp: break if *(pj-1) <= *pj
            for (s = *(pj - 1) + d, t = *pj + d; *s == *t && *s != 0; s++, t++)
                ;
            if (*s <= *t)
                break;
            swap2(pj, pj - 1);
        }
}

void ssort2(char **a, int n, int depth)
{
    int d, r, partval;
    char **pa, **pb, **pc, **pd, **pl, **pm, **pn, *t;
    if (n < 10)
    {
        inssort(a, n, depth);
        return;
    }
    pl = a;
    pm = a + (n / 2);
    pn = a + (n - 1);
    if (n > 30)
    {  // On big arrays, pseudomedian of 9
        d = (n / 8);
        pl = med3(pl, pl + d, pl + 2 * d);
        pm = med3(pm - d, pm, pm + d);
        pn = med3(pn - 2 * d, pn - d, pn);
    }
    pm = med3(pl, pm, pn);
    swap2(a, pm);
    partval = ptr2char(a);
    pa = pb = a + 1;
    pc = pd = a + n - 1;
    for (;;)
    {
        while (pb <= pc && (r = ptr2char(pb) - partval) <= 0)
        {
            if (r == 0)
            {
                swap2(pa, pb);
                pa++;
            }
            pb++;
        }
        while (pb <= pc && (r = ptr2char(pc) - partval) >= 0)
        {
            if (r == 0)
            {
                swap2(pc, pd);
                pd--;
            }
            pc--;
        }
        if (pb > pc)
            break;
        swap2(pb, pc);
        pb++;
        pc--;
    }
    pn = a + n;
    r = min(pa - a, pb - pa);
    vecswap2(a, pb - r, r);
    r = min(pd - pc, pn - pd - 1);
    vecswap2(pb, pn - r, r);
    if ((r = pb - pa) > 1)
        ssort2(a, r, depth);
    if (ptr2char(a + r) != 0)
        ssort2(a + r, pa - a + pn - pd - 1, depth + 1);
    if ((r = pd - pc) > 1)
        ssort2(a + n - r, r, depth);
}

void ssort2main(char **a, int n) { ssort2(a, n, 0); }

// TERNARY SEARCH TREE ALGS

typedef struct tnode *Tptr;
typedef struct tnode
{
    char splitchar;
    Tptr lokid, eqkid, hikid;
} Tnode;
Tptr root;

// Insert 1 -- Simple Insertion Algorithm

Tptr insert1(Tptr p, char *s)
{
    if (p == 0)
    {
        p = (Tptr)malloc(sizeof(Tnode));
        p->splitchar = *s;
        p->lokid = p->eqkid = p->hikid = 0;
    }
    if (*s < p->splitchar)
        p->lokid = insert1(p->lokid, s);
    else if (*s == p->splitchar)
    {
        if (*s != 0)
            p->eqkid = insert1(p->eqkid, ++s);
    }
    else
        p->hikid = insert1(p->hikid, s);
    return p;
}

void cleanup1(Tptr p)
{
    if (p)
    {
        cleanup1(p->lokid);
        cleanup1(p->eqkid);
        cleanup1(p->hikid);
        free(p);
    }
}

// Insert 2 -- Faster version of Insert

#define BUFSIZE 1000
Tptr buffer;
int bufn, freen;
void *freearr[10000];
int storestring = 0;

void insert2(char *s)
{
    int d;
    char *instr = s;

    Tptr pp, *p;
    p = &root;
    pp = *p;
    while (pp == *p)
    {
        if ((d = *s - pp->splitchar) == 0)
        {
            if (*s++ == 0)
                return;
            p = &(pp->eqkid);
        }
        else if (d < 0)
            p = &(pp->lokid);
        else
            p = &(pp->hikid);
    }
    for (;;)
    {
        // *p = (Tptr) malloc(sizeof(Tnode));
        if (bufn-- == 0)
        {
            buffer = (Tptr)malloc(BUFSIZE * sizeof(Tnode));
            freearr[freen++] = (void *)buffer;
            bufn = BUFSIZE - 1;
        }
        *p = buffer++;
        pp = *p;
        pp->splitchar = *s;
        pp->lokid = pp->eqkid = pp->hikid = 0;
        if (*s++ == 0)
        {
            if (storestring)
                pp->eqkid = (Tptr)instr;
            return;
        }
        p = &(pp->eqkid);
    }
}
void cleanup2()
{
    int i;
    for (i = 0; i < freen; i++) free(freearr[i]);
}

// Search Algorithms

int search1(char *s)
{
    Tptr p;
    p = root;
    while (p)
    {
        if (*s < p->splitchar)
            p = p->lokid;
        else if (*s == p->splitchar)
        {
            if (*s++ == 0)
                return 1;
            p = p->eqkid;
        }
        else
            p = p->hikid;
    }
    return 0;
}

int search2(char *s)
{
    int d, sc;
    Tptr p;
    sc = *s;
    p = root;
    while (p)
    {
        if ((d = sc - p->splitchar) == 0)
        {
            if (sc == 0)
                return 1;
            sc = *++s;
            p = p->eqkid;
        }
        else if (d < 0)
            p = p->lokid;
        else
            p = p->hikid;
    }
    return 0;
}

// Advanced searching: Partial match, near words

int nodecnt;
char *srcharr[100000];
int srchtop;

void pmsearch(Tptr p, char *s)
{
    if (!p)
        return;
    nodecnt++;
    if (*s == '.' || *s < p->splitchar)
        pmsearch(p->lokid, s);
    if (*s == '.' || *s == p->splitchar)
        if (p->splitchar && *s)
            pmsearch(p->eqkid, s + 1);
    if (*s == 0 && p->splitchar == 0)
        srcharr[srchtop++] = (char *)p->eqkid;
    if (*s == '.' || *s > p->splitchar)
        pmsearch(p->hikid, s);
}

void nearsearch(Tptr p, char *s, int d)
{
    if (!p || d < 0)
        return;
    nodecnt++;
    if (d > 0 || *s < p->splitchar)
        nearsearch(p->lokid, s, d);
    if (p->splitchar == 0)
    {
        if ((int)strlen(s) <= d)
            srcharr[srchtop++] = (char *)p->eqkid;
    }
    else
        nearsearch(p->eqkid, *s ? s + 1 : s, (*s == p->splitchar) ? d : d - 1);
    if (d > 0 || *s > p->splitchar)
        nearsearch(p->hikid, s, d);
}

#define NUMBER_OF_STRING 3

int main(int argc, char *argv[])
{
    char *arr[NUMBER_OF_STRING] = {"apple", "cat", "boy"};

    ssort1main(arr, NUMBER_OF_STRING);

    for (int i = 0; i < NUMBER_OF_STRING; i++)
    {
        printf("%s ", arr[i]);
    }
}
#include <stdio.h>
void stoogesort(int[], int, int);

int main()
{
    int arr[100], i, n;

    printf("How many elements do you want to sort: ");
    scanf("%d", &n);
    for (i = 0; i < n; i++) scanf(" %d", &arr[i]);
    stoogesort(arr, 0, n - 1);
    printf("Sorted array : \n");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}

void stoogesort(int arr[], int i, int j)
{
    int temp, k;
    if (arr[i] > arr[j])
    {
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    if ((i + 1) >= j)
        return;
    k = (int)((j - i + 1) / 3);
    stoogesort(arr, i, j - k);
    stoogesort(arr, i + k, j);
    stoogesort(arr, i, j - k);
}
/**
 * \file
 * \brief [Shell sort algorithm](https://en.wikipedia.org/wiki/Shell_sort)
 * implementation.
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * @addtogroup sorting Sorting algorithms
 * @{
 */
/** Helper function to print array values */
void show_data(int *arr, long len)
{
    for (long i = 0; i < len; i++) printf("%3d ", arr[i]);
    printf("\n");
}

/** Function to swap values of two integers
 * @param [in,out] a reference to first variable
 * @param [in,out] b reference to second variable
 */
inline void swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}

/**
 * Shell sort algorithm.\n
 * Optimized algorithm - takes half the time as other
 * @param [in,out] array array to sort
 * @param [in] LEN length of the array
 */
void shell_sort(int *array, long LEN)
{
    const int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};
    const int gap_len = 8;
    long i, j, g;

    for (g = 0; g < gap_len; g++)
    {  // for each gap
        int gap = gaps[g];
        for (i = gap; i < LEN; i++)
        {  // from gap position to the end
            int tmp = array[i];

            for (j = i; j >= gap && (array[j - gap] - tmp) > 0; j -= gap)
                array[j] = array[j - gap];
            array[j] = tmp;
        }
    }
#ifdef DEBUG
    for (i = 0; i < LEN; i++) printf("%s\t", data[i]);
#endif
}
/** @} */

/** Main function */
int main(int argc, char *argv[])
{
    int i;
    long size = 500;
    if (argc == 2)
        size = atol(argv[1]);
    else if (argc > 2)
        fprintf(stderr, "Usage: ./shell_sort [number of values]\n");

    int *array = (int *)malloc(size * sizeof(int));
    int range = 500;  // range of array values
    double time_spent;

    srand(time(NULL));  // initialize random number generator
    for (i = 0; i < size; i++)
        // fill array with random integers
        array[i] = rand() % range + 1;

    show_data(array, size);   // show array before sorting
    clock_t t1 = clock();     // start timer
    shell_sort(array, size);  // sort the array
    clock_t t2 = clock();     // end timer

    printf("Data Sorted\n");
    show_data(array, size);  // display array after sorting

    printf("Time spent sorting: %.4g s\n", (t2 - t1) / CLOCKS_PER_SEC);

    free(array);
    return 0;
}
/**
 * @file
 * @author [Dhruv Pasricha](https://github.com/DhruvPasricha)
 * @brief [Heap Sort](https://en.wikipedia.org/wiki/Heapsort) implementation
 * @details
 * Heap-sort is a comparison-based sorting algorithm.
 * Heap-sort can be thought of as an improved selection sort:
 * like selection sort, heap sort divides its input into a sorted
 * and an unsorted region, and it iteratively shrinks the unsorted
 * region by extracting the largest element from it and inserting
 * it into the sorted region.
 *
 * Unlike selection sort,
 * heap sort does not waste time with a linear-time scan of the
 * unsorted region; rather, heap sort maintains the unsorted region
 * in a heap data structure to more quickly find the largest element
 * in each step.
 * Time Complexity : O(Nlog(N))
 */

#include <assert.h>   /// for assert
#include <stdio.h>    /// for IO operations
#include <stdlib.h>   /// for dynamic memory allocation
#include <time.h>     /// for random numbers generation
#include <inttypes.h> /// for uint8_t, int8_t

/**
 * @brief Swapped two numbers using pointer
 * @param first pointer of first number
 * @param second pointer of second number
 */
void swap(int8_t *first, int8_t *second)
{
    int8_t temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * @brief heapifyDown Adjusts new root to the correct position in the heap
 * This heapify procedure can be thought of as building a heap from
 * the top down by successively shifting downward to establish the
 * heap property.
 * @param arr array to be sorted
 * @param size size of array
 * @return void
*/
void heapifyDown(int8_t *arr, const uint8_t size)
{
    uint8_t i = 0;

    while (2 * i + 1 < size)
    {
        uint8_t maxChild = 2 * i + 1;

        if (2 * i + 2 < size && arr[2 * i + 2] > arr[maxChild])
        {
            maxChild = 2 * i + 2;
        }

        if (arr[maxChild] > arr[i])
        {
            swap(&arr[i], &arr[maxChild]);
            i = maxChild;
        }
        else
        {
            break;
        }
    }
}

/**
 * @brief heapifyUp Adjusts arr[i] to the correct position in the heap
 * This heapify procedure can be thought of as building a heap from
 * the bottom up by successively shifting upward to establish the
 * heap property.
 * @param arr array to be sorted
 * @param i index of the pushed element
 * @return void
*/
void heapifyUp(int8_t *arr, uint8_t i)
{
    while (i > 0 && arr[(i - 1) / 2] < arr[i])
    {
        swap(&arr[(i - 1) / 2], &arr[i]);
        i = (i - 1) / 2;
    }
}

/**
 * @brief Heap Sort algorithm
 * @param arr array to be sorted
 * @param size size of the array
 * @returns void
 */
void heapSort(int8_t *arr, const uint8_t size)
{
    if (size <= 1)
    {
        return;
    }

    for (uint8_t i = 0; i < size; i++)
    {
        // Pushing `arr[i]` to the heap

        /*heapifyUp Adjusts arr[i] to the correct position in the heap*/
        heapifyUp(arr, i);
    }

    for (uint8_t i = size - 1; i >= 1; i--)
    {
        // Moving current root to the end
        swap(&arr[0], &arr[i]);

        // `heapifyDown` adjusts new root to the correct position in the heap
        heapifyDown(arr, i);

    }
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
    const uint8_t size = 10;
    int8_t *arr = (int8_t *)calloc(size, sizeof(int8_t));

    /* generate size random numbers from 0 to 100 */
    for (uint8_t i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    heapSort(arr, size);
    for (uint8_t i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    // Intializes random number generator
    srand(time(NULL));

    test(); // run self-test implementations
    return 0;
}
/**
 * @file
 * @author [Dhruv Pasricha](https://github.com/DhruvPasricha)
 * @brief [Selection Sort](https://en.wikipedia.org/wiki/Selection_sort)
 * implementation using recursion.
 */

#include <assert.h>     /// for assert
#include <stdio.h>      /// for IO operations
#include <stdlib.h>     /// for dynamic memory allocation
#include <time.h>       /// for random numbers generation
#include <inttypes.h>   /// for uint8_t, int8_t

/**
 * @brief Swapped two numbers using pointer
 * @param first pointer of first number
 * @param second pointer of second number
 */
void swap(int8_t *first, int8_t *second)
{
    int8_t temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * @brief Returns the index having minimum value using recursion
 * @param arr array to be sorted
 * @param size size of array
 * @return min_index index of an element having a minimum value
*/
uint8_t findIndex(const int8_t *arr, const uint8_t size)
{
    if (size == 1)
    {
        return 0;
    }

    // marking recursive call to reach starting element
    uint8_t min_index = findIndex(arr, size - 1);

    if (arr[size - 1] < arr[min_index])
    {
        min_index = size - 1;
    }

    return min_index;
}

/**
 * @brief Selection Sort algorithm implemented using recursion
 * @param arr array to be sorted
 * @param size size of the array
 * @returns void
 */
void selectionSort(int8_t *arr, const uint8_t size)
{
    if (size <= 1)
    {
        return;
    }

    /* findIndex(arr, size) returned the index having min value*/
    uint8_t min_index = findIndex(arr, size);
    /* arr[min_index] is the minimum value in the array*/

    if (min_index != 0)
    {
        swap(&arr[0], &arr[min_index]);
    }

    /*sorted the remaining array recursively*/
    selectionSort(arr + 1, size - 1);
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
    const uint8_t size = 10;
    int8_t *arr = (int8_t *)calloc(size, sizeof(int8_t));

    /* generate size random numbers from 0 to 100 */
    for (uint8_t i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    selectionSort(arr, size);
    for (uint8_t i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /* Intializes random number generator */
    srand(time(NULL));

    test();  // run self-test implementations
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

/*Displays the array, passed to this method*/
void display(int arr[], int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

/*Swap function to swap two values*/
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

/*Partition method which selects a pivot
  and places each element which is less than the pivot value to its left
  and the elements greater than the pivot value to its right
  arr[] --- array to be partitioned
  lower --- lower index
  upper --- upper index
*/
int partition(int arr[], int lower, int upper)
{
    int i = (lower - 1);

    int pivot = arr[upper];  // Selects last element as the pivot value

    int j;
    for (j = lower; j < upper; j++)
    {
        if (arr[j] <= pivot)
        {  // if current element is smaller than the pivot

            i++;  // increment the index of smaller element
            swap(&arr[i], &arr[j]);
        }
    }

    swap(&arr[i + 1], &arr[upper]);  // places the last element i.e, the pivot
                                     // to its correct position

    return (i + 1);
}

/*This is where the sorting of the array takes place
    arr[] --- Array to be sorted
    lower --- Starting index
    upper --- Ending index
*/
void quickSort(int arr[], int lower, int upper)
{
    if (upper > lower)
    {
        // partitioning index is returned by the partition method , partition
        // element is at its correct poition

        int partitionIndex = partition(arr, lower, upper);

        // Sorting elements before and after the partition index
        quickSort(arr, lower, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, upper);
    }
}

int main()
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  // E.g. 8

    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(sizeof(int) * n);
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);  // Original array : 10 11 9 8 4 7 3 8

    quickSort(arr, 0, n - 1);

    printf("Sorted array: ");
    display(arr, n);  // Sorted array : 3 4 7 8 8 9 10 11
    getchar();
    free(arr);
    return 0;
}
/* Program to demonstrate non recursive merge sort */

/* Merge sort is an effective sorting algorithm which falls under divide and
conquer paradigm and produces a stable sort. Merge sort repeatedly breaks down a
list into several sublists until each sublist consists of a single element and
merging those sublists in a manner that results into a sorted list.

Bottom-Up Merge Sort Implementation:
The Bottom-Up merge sort approach uses iterative methodology. It starts with the
“single-element” array, and combines two adjacent elements and also sorting the
two at the same time. The combined-sorted arrays are again combined and sorted
with each other until one single unit of sorted array is achieved. */

#include <stdio.h>

void mergesort(int x[], int n);
void show(int x[], int n);

void mergesort(int x[], int n)
{
    int temp[50], i, j, k, lb1, lb2, ub1, ub2, size;

    size = 1;
    while (size < n)
    {
        lb1 = 0;
        k = 0;

        while (lb1 + size < n)
        {
            lb2 = lb1 + size;
            ub1 = lb2 - 1;
            if (ub1 + size < n)
                ub2 = ub1 + size;
            else
                ub2 = n - 1;

            i = lb1;
            j = lb2;

            while (i <= ub1 && j <= ub2)
                if (x[i] < x[j])
                    temp[k++] = x[i++];
                else
                    temp[k++] = x[j++];

            while (i <= ub1) temp[k++] = x[i++];

            while (j <= ub2) temp[k++] = x[j++];

            lb1 = ub2 + 1;
        }

        for (i = 0; i <= ub2; i++) x[i] = temp[i];

        size = size * 2;

        show(x, n);
    }
}

// function to show each pass
void show(int x[], int n)
{
    int i;
    for (i = 0; i < n; i++) printf("%d ", x[i]);
    printf("\n\n");
}

int main()  // main function
{
    int i, n, x[20];

    printf("Enter the number of elements: ");
    scanf("%d", &n);
    printf("Enter the elements:\n");
    for (i = 0; i < n; i++) scanf("%d", &x[i]);

    mergesort(x, n);

    printf("Sorted array is as shown:\n");
    for (i = 0; i < n; i++) printf("%d ", x[i]);
    return 0;
}

/* Output of the Program*/
/*
Enter the number of elements: 5
Enter the elements:
15
14
13
12
11
14 15 12 13 11

12 13 14 15 11

11 12 13 14 15

Sorted array is as shown:
11 12 13 14 15
*/
/**
 * @file
 * @brief [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort)
 * algorithm implementation.
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * @addtogroup sorting Sorting algorithms
 * @{
 */
/**
 * Insertion sort algorithm implements using Recursion 
 * @param arr array to be sorted
 * @param size size of array
 */
void RecursionInsertionSort(int *arr, int size)
{
    if(size <= 0)
    {
        return;
    }
    
    // marking recursive call to reach starting element
    RecursionInsertionSort(arr,size-1);
    
    int key = arr[size-1];
    int j = size-2;
    // swapping logic for insertion sort
    while(j >= 0 && arr[j] > key)
    {
        arr[j+1] = arr[j];
        j--;
    }
    arr[j+1] = key;
}
/** @} */
/** Test function
  * @returns None
  */
static void test()
{
    const int size = rand() % 500; /* random array size */
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from -50 to 49 */  
    for (int i = 0; i < size; i++)
    {
        arr[i] = (rand() % 100) - 50;/* signed random numbers */
    }
    RecursionInsertionSort(arr, size);
    for (int i = 0; i < size  ; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/** Main function
 *  @returns integer 0
 */
int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void sort(int *numbers, int size)
{
    int pos = 0;
    while (pos < size)
    {
        if (numbers[pos] >= numbers[pos - 1])
            pos++;
        else
        {
            int tmp = numbers[pos - 1];
            numbers[pos - 1] = numbers[pos];
            numbers[pos] = tmp;
            pos--;

            if (pos == 0)
                pos = 1;
        }
    }
}

void display(int *array, int n)
{
    int i;
    for (i = 0; i < n; ++i) printf("%d ", array[i]);
    printf("\n");
}

int main()
{
    int size = 6;
    int i;
    int *numbers = malloc(size * sizeof(int));
    printf("Insert %d unsorted numbers: \n", size);
    for (i = 0; i < size; ++i) scanf("%d", &numbers[i]);
    printf("Initial array: ");
    display(numbers, size);
    sort(numbers, size);
    printf("Sorted array: ");
    display(numbers, size);
    free(numbers);
    return 0;
}
/**
 * @file
 * @author [Edwin Ajong](https://github.com/eddybruv)
 * @brief [Odd Even Sort](https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort) implementation
 * @details
 * This algorithm is divided into two phases- Odd and Even Phase.
 * The algorithm runs until the array elements are sorted and in each iteration two phases occurs- Odd and Even Phases.
 * In the odd phase, we perform a bubble sort on odd indexed elements and in the even phase,
 * we perform a bubble sort on even indexed elements.
 * Time Complexity: O(N ^ 2)
 */

#include <assert.h>     /// for assert
#include <stdbool.h>    /// for bool
#include <stdio.h>      /// for IO operations
#include <stdlib.h>     /// for dynammic memory allocation
#include <time.h>       /// for random number generation
#include <inttypes.h>   /// for int32_t types

/**
 * @brief Swap numbers by reference(using pointers)
 * @param first pointer to first number
 * @param second pointer to second number
 * @returns void
 */
void swap(int32_t *first, int32_t *second)
{
    int32_t temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * @brief oddEvenSort sorts the array using the algorithm described above.
 * @details 
 * A boolean varaible(isSorted) is declared and initialised to "false".
 * In the while loop, the variable(isSorted) is then set to "true".
 * During even phase the for loop loops through the array, touching just the even indexes.
 * i.e arr[0], arr[2], arr[4] and so on.
 * While during the odd phase, the for loop loops through the array, touching just the odd indexes.
 * i.e arr[1], arr[3], arr[5] and so on.
 * During these phases, if the if statement check if the interger at the current position in the array
 * is greater than the interger at the next array index (i.e arr[index + 2], to make sure the index is odd
 * during the odd phase and even during the even phase).
 * If the condition is true, the function "swap" is called and address of the intergers in question are passed as
 * parameters. After the swap is completed, "isSorted" is set to "false".
 * The while loop will keep running till the array is propertly sorted.
 * @param arr array to be sorted
 * @param size the size of the array
 * @returns void
 */
void oddEvenSort(int *arr, int size)
{
    bool isSorted = false;
    while(!isSorted)
    {
        isSorted = true;
        int32_t i;

        // Even phase
        for(i = 0; i <= size - 2; i += 2)
        {
            if(arr[i] > arr[i + 1])
            {
                swap(&arr[i], &arr[i + 1]);
                isSorted = false;
            }
        }

        // Odd phase
        for(i = 1; i <= size - 2; i += 2)
        {
            if(arr[i] > arr[i + 1])
            {
                swap(&arr[i], &arr[i + 1]);
                isSorted = false;
            }
        }
    }
}

/**
 * @brief Self-test implementations
 * @details Two tests (unsorted) arrays were created and their corresponding solution(sorted) arrays were also created.
 * The test arrays and their respective sizes are then passed in to the oddEvenSort function.
 * To test if the algorithm works, a for loop is assigned to loop through the both arrays(test and solution) and check if the array elements 
 * of the test array correspond to the elements of the solution array.
 * @returns void
 */
static void test()
{
    int32_t arr1[] = {-9, 2, 3, 1};
    int32_t arr1Soln[] = {-9, 1, 2, 3};
    int32_t arr2[] = {9, 7, 5, 3, 8, 2, 1, 4, 0, 6};
    int32_t arr2Soln[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    oddEvenSort(arr1, 4);
    oddEvenSort(arr2, 10);

     for (int32_t i = 0; i < 4; i++)
     {
         assert(arr1[i] == arr1Soln[i]);    
     }

    for (int32_t i = 0; i < 10; i++)
    {
        assert(arr2[i] == arr2Soln[i]);    
    }
    printf("All tests have passed!\n");
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    test();  // run self-test implementations
    return 0;
}
#include <stdio.h>

int largest(int a[], int n)
{
    int large = a[0], i;
    for (i = 1; i < n; i++)
    {
        if (large < a[i])
            large = a[i];
    }
    return large;
}

void RadixSort(int a[], int n)
{
    int bucket[10][10], bucket_count[10];
    int i, j, k, remainder, NOP = 0, divisor = 1, large, pass;

    large = largest(a, n);
    printf("The large element %d\n", large);
    while (large > 0)
    {
        NOP++;
        large /= 10;
    }

    for (pass = 0; pass < NOP; pass++)
    {
        for (i = 0; i < 10; i++)
        {
            bucket_count[i] = 0;
        }
        for (i = 0; i < n; i++)
        {
            remainder = (a[i] / divisor) % 10;
            bucket[remainder][bucket_count[remainder]] = a[i];
            bucket_count[remainder] += 1;
        }

        i = 0;
        for (k = 0; k < 10; k++)
        {
            for (j = 0; j < bucket_count[k]; j++)
            {
                a[i] = bucket[k][j];
                i++;
            }
        }
        divisor *= 10;

        for (i = 0; i < n; i++) printf("%d  ", a[i]);
        printf("\n");
    }
}

int main()
{
    int i, n, a[10];
    printf("Enter the number of elements :: ");
    scanf("%d", &n);
    printf("Enter the elements :: ");
    for (i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
    }
    RadixSort(a, n);
    printf("The sorted elements are ::  ");
    for (i = 0; i < n; i++) printf("%d  ", a[i]);
    printf("\n");
    return 0;
}
/*
  > Counting sort is a sorting technique based on keys between a specific range.
  > integer sorting algorithm
  > Worst-case performance O(n+k)
  > Stabilized by prefix sum array
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    int i, n, l = 0;

    printf("Enter size of array = ");
    scanf("%d", &n);

    int *a = (int *)malloc(n * sizeof(int));
    printf("Enter %d elements in array :\n", n);
    for (i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
        if (a[i] > l)
            l = a[i];
    }

    int *b = (int *)malloc((l + 1) * sizeof(int));
    memset(b, 0, (l + 1) * sizeof(b[0]));

    for (i = 0; i < n; i++) b[a[i]]++;  // hashing number to array index

    for (i = 0; i < (l + 1); i++)  // unstable , stabilized by prefix sum array
    {
        if (b[i] > 0)
        {
            while (b[i] != 0)  // for case when number exists more than once
            {
                printf("%d ", i);
                b[i]--;
            }
        }
    }

    free(a);
    free(b);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#define SHRINK 1.3  // suggested shrink factor value

void sort(int *numbers, int size)
{
    int gap = size;
    while (gap > 1)  // gap = 1 means that the array is sorted
    {
        gap = gap / SHRINK;
        int i = 0;
        while ((i + gap) < size)
        {  // similiar to the Shell Sort
            if (numbers[i] > numbers[i + gap])
            {
                int tmp = numbers[i];
                numbers[i] = numbers[i + gap];
                numbers[i + gap] = tmp;
            }
            i++;
        }
    }
}

void display(int *array, int n)
{
    int i;
    for (i = 0; i < n; ++i) printf("%d ", array[i]);
    printf("\n");
}

int main()
{
    int size = 6;
    int *numbers = malloc(size * sizeof(int));
    printf("Insert %d unsorted numbers: \n", size);
    int i;
    for (i = 0; i < size; ++i) scanf("%d", &numbers[i]);
    printf("Initial array: ");
    display(numbers, size);
    sort(numbers, size);
    printf("Sorted array: ");
    display(numbers, size);
    free(numbers);
    return 0;
}
// sorting of array list using Radix sort
#include <stdio.h>
#include <stdlib.h>

#define range 10  // Range for integers is 10 as digits range from 0-9

// Utility function to get the maximum value in ar[]
int MAX(int *ar, int size)
{
    int i, max = ar[0];
    for (i = 0; i < size; i++)
    {
        if (ar[i] > max)
            max = ar[i];
    }
    return max;
}

// Counting sort according to the digit represented by place
void countSort(int *arr, int n, int place)
{
    int i, freq[range] = {0};
    int *output = (int *)malloc(n * sizeof(int));

    // Store count of occurences in freq[]
    for (i = 0; i < n; i++) freq[(arr[i] / place) % range]++;

    // Change freq[i] so that it contains the actual position of the digit in
    // output[]
    for (i = 1; i < range; i++) freq[i] += freq[i - 1];

    // Build the output array
    for (i = n - 1; i >= 0; i--)
    {
        output[freq[(arr[i] / place) % range] - 1] = arr[i];
        freq[(arr[i] / place) % range]--;
    }

    // Copy the output array to arr[], so it contains numbers according to the
    // current digit
    for (i = 0; i < n; i++) arr[i] = output[i];
    free(output);
}

/*This is where the sorting of the array takes place
 arr[] --- Array to be sorted
 n --- Array Size
 max --- Maximum element in Array
 */
void radixsort2(int *arr, int n,
                int max)  // max is the maximum element in the array
{
    int mul = 1;
    while (max)
    {
        countSort(arr, n, mul);
        mul *= 10;
        max /= 10;
    }
}

void display(int *arr, int N)
{
    for (int i = 0; i < N; i++) printf("%d, ", arr[i]);
    putchar('\n');
}

int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  // E.g. 8

    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);  // Original array : 10 11 9 8 4 7 3 8

    int max;
    max = MAX(arr, n);

    radixsort2(arr, n, max);

    printf("Sorted array: ");
    display(arr, n);  // Sorted array : 3 4 7 8 8 9 10 11

    free(arr);
    return 0;
}
// Sorting of array list using cycle sort
#include <stdio.h>
#include <stdlib.h>

// Displays the array, passed to this method
void display(int *arr, int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

// Swap function to swap two values
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

// Function sort the array using Cycle sort
void cycleSort(int *arr, int n)
{
    // count number of memory writes
    int writes = 0;

    // traverse array elements and put it to on
    // the right place
    for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++)
    {
        // initialize item as starting point
        int item = arr[cycle_start];

        // Find position where we put the item. We basically
        // count all smaller elements on right side of item.
        int pos = cycle_start;
        for (int i = cycle_start + 1; i < n; i++)
            if (arr[i] < item)
                pos++;

        // If item is already in correct position
        if (pos == cycle_start)
            continue;

        // ignore all duplicate elements
        while (item == arr[pos]) pos += 1;

        // put the item to it's right position
        if (pos != cycle_start)
        {
            swap(&item, &arr[pos]);
            writes++;
        }

        // Rotate rest of the cycle
        while (pos != cycle_start)
        {
            pos = cycle_start;

            // Find position where we put the element
            for (int i = cycle_start + 1; i < n; i++)
                if (arr[i] < item)
                    pos += 1;

            // ignore all duplicate elements
            while (item == arr[pos]) pos += 1;

            // put the item to it's right position
            if (item != arr[pos])
            {
                swap(&item, &arr[pos]);
                writes++;
            }
        }
    }
}

// Driver program to test above function
int main()
{
    int n;  // Size of array elements

    printf("Enter size of array:\n");
    scanf("%d", &n);  // E.g. 8

    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);

    cycleSort(arr, n);
    printf("Sorted array: ");
    display(arr, n);

    free(arr);
    return 0;
}
/*
Randomised quick sort implementation in C language.
In normal quick sort, pivot chosen to partition is either the first or the last
element of the array. This can take time O(n*n) to sort in the worst case. Now
in randomised quick sort, pivot is randomly chosen and then recursively sort the
left and right sub-arrays. The expected running time of the algorithm is
O(nlog(n)).
*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int getBig(int *a, int i, int right, int pivot)
{
    for (int k = i; k <= right; k++)
    {
        if (a[k] > pivot)
            return k;
    }
    return right + 1;
}

int getSmall(int *a, int j, int left, int pivot)
{
    for (int k = j; k >= left; k--)
    {
        if (a[k] < pivot)
            return k;
    }
    return -1;
}

void swap(int *a, int *b)
{
    int t = *a;
    *a = *b;
    *b = t;
}

void random_quick(int *a, int left, int right)
{
    if (left >= right)
        return;
    int index = left + (rand() % (right - left)), i = left, j = right;
    int pivot_index = index;
    int pivot = a[index];
    // storing index of element greater than pivot
    i = getBig(a, i, right, pivot);
    // storing index of element smaller than pivot
    j = getSmall(a, j, left, pivot);
    while (i <= j)
    {
        swap(&a[i], &a[j]);
        i = getBig(a, i, right, pivot);
        j = getSmall(a, j, left, pivot);
    }
    // after separating the smaller and greater elements, there are 3 cases
    // possible
    if (pivot_index > j && pivot_index > i)
    {
        // case 1. When the pivot element index is greater than both i and j
        swap(&a[i], &a[pivot_index]);
        random_quick(a, left, i - 1);
        random_quick(a, i + 1, right);
    }
    else if (pivot_index < j && pivot_index < i)
    {
        // case 2. When the pivot element index is smaller than both i and j
        swap(&a[j], &a[pivot_index]);
        random_quick(a, left, j - 1);
        random_quick(a, j + 1, right);
    }
    else
    {
        // the pivot element is at its origin position.
        random_quick(a, left, pivot_index - 1);
        random_quick(a, pivot_index + 1, right);
    }
}

int main()
{
    srand(time(0));
    int num;
    scanf("%d", &num);
    int *arr = (int *)malloc(num * sizeof(int));
    for (int i = 0; i < num; i++)
    {
        scanf("%d", &arr[i]);
    }
    random_quick(arr, 0, num - 1);
    for (int i = 0; i < num; i++)
    {
        printf("%d ", arr[i]);
    }

    free(arr);
    printf("\n");
}
/**
 * @file
 * @brief [Selection sort](https://en.wikipedia.org/wiki/Selection_sort)
 * algorithm implementation.
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * Swapped two numbers using pointer
 * @param first first pointer of first number
 * @param second second pointer of second number
 */
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * Selection sort algorithm implements
 * @param arr array to be sorted
 * @param size size of array
 */
void selectionSort(int *arr, int size)
{
    for (int i = 0; i < size - 1; i++)
    {
        int min_index = i;
        for (int j = i + 1; j < size; j++)
        {
            if (arr[min_index] > arr[j])
            {
                min_index = j;
            }
        }
        if (min_index != i)
        {
            swap(arr + i, arr + min_index);
        }
    }
}

/** Test function
  * @returns None
  */
static void test()
{
    const int size = rand() % 500; /* random array size */
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from -50 to 49 */
    for (int i = 0; i < size; i++)
    {
        arr[i] = (rand() % 100) - 50; /* signed random numbers */
    }
    selectionSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/** Driver Code */
int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
/**
 * @file
 * @brief [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort)
 * algorithm implementation.
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * Insertion sort algorithm implements
 * @param arr array to be sorted
 * @param size size of array
 */
void insertionSort(int *arr, int size)
{
    for (int i = 1; i < size; i++)
    {
        int j = i - 1;
        int key = arr[i];
        /* Move all elements greater than key to one position */
        while (j >= 0 && key < arr[j])
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        /* Find a correct position for key */
        arr[j + 1] = key;
    }
}

/** Test function
  * @returns None
  */
static void test()
{
    const int size = rand() % 500; /* random array size */
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from -50 to 49 */  
    for (int i = 0; i < size; i++)
    {
        arr[i] = (rand() % 100) - 50; /* signed random numbers */
    }
    insertionSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}
int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
/**
 * @file
 * @brief [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm
 * implementation using recursion.
 */
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * Swapped two numbers using pointer
 * @param first first pointer of first number
 * @param second second pointer of second number
 */
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * Bubble sort algorithm implements using recursion
 * @param arr array to be sorted
 * @param size size of array
 */
void bubbleSort(int *arr, int size)
{
    if (size == 1)
    {
        return;
    }
    bool swapped = false;
    for (int i = 0; i < size - 1; ++i)
    {
        if (arr[i] > arr[i + 1])
        {
            swap(arr + i, arr + i + 1);
            swapped = true;
        }
    }
    if (swapped)
    {
        bubbleSort(arr, size - 1);
    }
}

/**
 * Test function
 */
void test()
{
    const int size = 10;
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from 0 to 100 */
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    bubbleSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/** Driver Code */
int main()
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
void shakersort(int *a, int n)
{
    int p, i;
    for (p = 1; p <= n / 2; p++)
    {
        for (i = p - 1; i < n - p; i++)
            if (a[i] > a[i + 1])
            {
                swap(&a[i], &a[i + 1]);
            }
        for (i = n - p - 1; i >= p; i--)
            if (a[i] < a[i - 1])
            {
                swap(&a[i], &a[i - 1]);
            }
    }
}
int main()
{
    int n;
    scanf("%d", &n);
    int *arr = (int *)malloc(n * sizeof(int));
    int i;
    for (i = 0; i < n; i++) scanf("%d ", &arr[i]);
    shakersort(arr, n);
    for (i = 0; i < n; i++) printf("%d ", arr[i]);
    free(arr);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void pigeonholeSort(int arr[], int size)
{
    int i, j, min = arr[0], max = arr[0], range;

    // Getting range of the array using max and min
    for (i = 1; i < size; i++)
    {
        if (arr[i] < min)
            min = arr[i];
        if (arr[i] > max)
            max = arr[i];
    }
    range = max - min + 1;

    // Make 'holes' and put array's numbers in holes
    int *holes = (int *)malloc(sizeof(int) * range);
    for (i = 0; i < range; i++)
    {
        holes[i] = 0;
    }
    for (i = 0; i < size; i++)
    {
        holes[arr[i] - min]++;
    }

    // Copy the numbers back to the original array
    j = 0;
    for (i = 0; i < range; i++)
    {
        while (holes[i] > 0)
        {
            arr[j] = i + min;
            holes[i]--;
            j++;
        }
    }

    free(holes);
}

int main()
{
    int i, n;

    printf("Enter the size of the array: ");
    scanf("%d", &n);
    int *arr = (int *)malloc(sizeof(int) * n);

    for (i = 0; i < n; i++)
    {
        printf("Number #%d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("You entered:  ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    pigeonholeSort(arr, n);
    printf("\nSorted array: ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr);
    return 0;
}/**
 * @file
 * @brief Functions related to 3D vector operations.
 * @author Krishna Vedala
 */

#include <stdio.h>
#ifdef __arm__  // if compiling for ARM-Cortex processors
#define LIBQUAT_ARM
#include <arm_math.h>
#else
#include <math.h>
#endif
#include <assert.h>

#include "geometry_datatypes.h"

/**
 * @addtogroup vec_3d 3D Vector operations
 * @{
 */

/**
 * Subtract one vector from another. @f[
 * \vec{c}=\vec{a}-\vec{b}=\left(a_x-b_x\right)\hat{i}+
 * \left(a_y-b_y\right)\hat{j}+\left(a_z-b_z\right)\hat{k}@f]
 * @param[in] a vector to subtract from
 * @param[in] b vector to subtract
 * @returns resultant vector
 */
vec_3d vector_sub(const vec_3d *a, const vec_3d *b)
{
    vec_3d out;
#ifdef LIBQUAT_ARM
    arm_sub_f32((float *)a, (float *)b, (float *)&out);
#else
    out.x = a->x - b->x;
    out.y = a->y - b->y;
    out.z = a->z - b->z;
#endif

    return out;
}

/**
 * Add one vector to another. @f[
 * \vec{c}=\vec{a}+\vec{b}=\left(a_x+b_x\right)\hat{i}+
 * \left(a_y+b_y\right)\hat{j}+\left(a_z+b_z\right)\hat{k}@f]
 * @param[in] a vector to add to
 * @param[in] b vector to add
 * @returns resultant vector
 */
vec_3d vector_add(const vec_3d *a, const vec_3d *b)
{
    vec_3d out;
#ifdef LIBQUAT_ARM
    arm_add_f32((float *)a, (float *)b, (float *)&out);
#else
    out.x = a->x + b->x;
    out.y = a->y + b->y;
    out.z = a->z + b->z;
#endif

    return out;
}

/**
 * Obtain the dot product of two 3D vectors.
 * @f[
 * \vec{a}\cdot\vec{b}=a_xb_x + a_yb_y + a_zb_z
 * @f]
 * @param[in] a first vector
 * @param[in] b second vector
 * @returns resulting dot product
 */
float dot_prod(const vec_3d *a, const vec_3d *b)
{
    float dot;
#ifdef LIBQUAT_ARM
    arm_dot_prod_f32((float *)a, (float *)b, &dot);
#else
    dot = a->x * b->x;
    dot += a->y * b->y;
    dot += a->z * b->z;
#endif

    return dot;
}

/**
 * Compute the vector product of two 3d vectors.
 * @f[\begin{align*}
 * \vec{a}\times\vec{b} &= \begin{vmatrix}
 *  \hat{i} & \hat{j} & \hat{k}\\
 *  a_x & a_y & a_z\\
 *  b_x & b_y & b_z
 *  \end{vmatrix}\\
 *  &= \left(a_yb_z-b_ya_z\right)\hat{i} - \left(a_xb_z-b_xa_z\right)\hat{j}
 * + \left(a_xb_y-b_xa_y\right)\hat{k} \end{align*}
 * @f]
 * @param[in] a first vector @f$\vec{a}@f$
 * @param[in] b second vector @f$\vec{b}@f$
 * @returns resultant vector @f$\vec{o}=\vec{a}\times\vec{b}@f$
 */
vec_3d vector_prod(const vec_3d *a, const vec_3d *b)
{
    vec_3d out;  // better this way to avoid copying results to input
                 // vectors themselves
    out.x = a->y * b->z - a->z * b->y;
    out.y = -a->x * b->z + a->z * b->x;
    out.z = a->x * b->y - a->y * b->x;

    return out;
}

/**
 * Print formatted vector on stdout.
 * @param[in] a vector to print
 * @param[in] name  name of the vector
 * @returns string representation of vector
 */
const char *print_vector(const vec_3d *a, const char *name)
{
    static char vec_str[100];  // static to ensure the string life extends the
                               // life of function

    snprintf(vec_str, 99, "vec(%s) = (%.3g)i + (%.3g)j + (%.3g)k\n", name, a->x,
             a->y, a->z);
    return vec_str;
}

/**
 * Compute the norm a vector.
 * @f[\lVert\vec{a}\rVert = \sqrt{\vec{a}\cdot\vec{a}} @f]
 * @param[in] a input vector
 * @returns norm of the given vector
 */
float vector_norm(const vec_3d *a)
{
    float n = dot_prod(a, a);
#ifdef LIBQUAT_ARM
    arm_sqrt_f32(*n, n);
#else
    n = sqrtf(n);
#endif

    return n;
}

/**
 * Obtain unit vector in the same direction as given vector.
 * @f[\hat{a}=\frac{\vec{a}}{\lVert\vec{a}\rVert}@f]
 * @param[in] a input vector
 * @returns n unit vector in the direction of @f$\vec{a}@f$
 */
vec_3d unit_vec(const vec_3d *a)
{
    vec_3d n = {0};

    float norm = vector_norm(a);
    if (fabsf(norm) < EPSILON)
    {  // detect possible divide by 0
        return n;
    }

    if (norm != 1.F)  // perform division only if needed
    {
        n.x = a->x / norm;
        n.y = a->y / norm;
        n.z = a->z / norm;
    }
    return n;
}

/**
 * The cross product of vectors can be represented as a matrix
 * multiplication operation. This function obtains the `3x3` matrix
 * of the cross-product operator from the first vector.
 * @f[\begin{align*}
 * \left(\vec{a}\times\right)\vec{b} &= \tilde{A}_a\vec{b}\\
 * \tilde{A}_a &=
 * \begin{bmatrix}0&-a_z&a_y\\a_z&0&-a_x\\-a_y&a_x&0\end{bmatrix}
 * \end{align*}@f]
 * @param[in] a input vector
 * @returns the `3x3` matrix for the cross product operator
 * @f$\left(\vec{a}\times\right)@f$
 */
mat_3x3 get_cross_matrix(const vec_3d *a)
{
    mat_3x3 A = {0., -a->z, a->y, a->z, 0., -a->x, -a->y, a->x, 0.};
    return A;
}

/**
 * Obtain the angle between two given vectors.
 * @f[\alpha=acos\left(\frac{\vec{a} \cdot \vec{b}}{\lVert\vec{a}\rVert \cdot \lVert\vec{b}\rVert}\right)@f]
 * @param[in] a first input vector
 * @param[in] b second input vector
 * @returns angle between @f$\vec{a}@f$ and @f$\vec{b}@f$ in radians
 */

double get_angle(const vec_3d *a, const vec_3d *b)
{
    double alpha, cos_alpha;
    float norm_a = vector_norm(a); ///< The norm of vector a
    float norm_b = vector_norm(b); ///< The norm of vector b
    if (fabsf(norm_a) < EPSILON || fabsf(norm_b) < EPSILON) /// detect possible division by 0 - the angle is not defined in this case
    {  
        return NAN; 
    }

    cos_alpha = dot_prod(a, b) / (norm_a * norm_b);
    alpha = acos(cos_alpha); // delivers the radian
    return alpha; // in range from -1 to 1
}

/** @} */

/**
 * @brief Testing function
 * @returns `void`
 */
static void test()
{
    vec_3d a = {1., 2., 3.};
    vec_3d b = {1., 1., 1.};
    float d;

    // printf("%s", print_vector(&a, "a"));
    // printf("%s", print_vector(&b, "b"));

    d = vector_norm(&a);
    // printf("|a| = %.4g\n", d);
    assert(fabsf(d - 3.742f) < 0.01);
    d = vector_norm(&b);
    // printf("|b| = %.4g\n", d);
    assert(fabsf(d - 1.732f) < 0.01);

    d = dot_prod(&a, &b);
    // printf("Dot product: %f\n", d);
    assert(fabsf(d - 6.f) < 0.01);

    vec_3d c = vector_prod(&a, &b);
    // printf("Vector product ");
    // printf("%s", print_vector(&c, "c"));
    assert(fabsf(c.x - (-1.f)) < 0.01);
    assert(fabsf(c.y - (2.f)) < 0.01);
    assert(fabsf(c.z - (-1.f)) < 0.01);

    double alpha = get_angle(&a, &b);
    // printf("The angle is %f\n", alpha);
    assert(fabsf(alpha - 0.387597) < 0.01);
}

/**
 * @brief Main function
 *
 * @return 0 on exit
 */
int main(void)
{
    test();

    return 0;
}
/**
 * @addtogroup quaternions Library for 3D Vectors & Quaternions
 * @{
 * @file
 * @brief Generic header that provides data types for 3D vectors and quaternions
 * @author Krishna Vedala
 */

#ifndef __LIBQUAT_H_
#define __LIBQUAT_H_

/** Minimum recognizable value. Any value less than this is considered to be
 * @f$=0@f$ */
#define EPSILON 1e-9

/**
 * @addtogroup vec_3d 3D Vector operations
 * @{
 */
/** 3D vector type */
typedef struct vec_3d_
{
    float x; /**< X co-ordinate */
    float y; /**< Y co-ordinate */
    float z; /**< Z co-ordinate */
} vec_3d;
/** @} */

/**
 * @addtogroup matrix Matrix operations
 * @{
 */
/** A 3x3 Matrix type definition */
typedef struct mat_3x3_
{
    union
    { /**< 3 element row 1 */
        float row1[3];
        vec_3d vec1;
    };
    union
    { /**< 3 element row 2 */
        float row2[3];
        vec_3d vec2;
    };
    union
    { /**< 3 element row 3 */
        float row3[3];
        vec_3d vec3;
    };
} mat_3x3;
/** @} */

/** @addtogroup quats 3D Quaternion operations
 * @{
 */
/** a Quaternion type represented using a scalar \f$w\f$ or \f$q_0\f$ and a
 * 3D vector \f$\left(q_1,q_2,q_3\right)\f$
 */
typedef struct quaternion_
{
    union
    {
        float w;  /**< real part of quaternion */
        float q0; /**< real part of quaternion */
    };
    /**< dual part of quaternion */
    union
    {
        vec_3d dual; /**< can be a 3D vector */
        /** or individual values */
        struct
        {
            float q1, q2, q3;
        };
    };
} quaternion;

/** 3D Euler or Tait-Bryan angles (in radian) */
typedef struct euler_
{
    union
    {
        float roll; /**< or bank \f$\phi\f$ = rotation about X axis */
        float bank; /**< or roll \f$\phi\f$ = rotation about X axis */
    };
    union
    {
        float pitch; /**< or elevation \f$\theta\f$ = rotation about Y axis */
        float elevation; /**< or pitch \f$\theta\f$ = rotation about Y axis */
    };
    union
    {
        float yaw;     /**< or heading \f$\psi\f$ = rotation about Z axis */
        float heading; /**< or yaw \f$\psi\f$ = rotation about Z axis */
    };
} euler;

/** @} */

/** @addtogroup dual_quats 3D Dual-Quaternion operations
 * @{
 */
/** a dual quaternion type */
typedef struct dual_quat_
{
    quaternion real; /**< real part of dual quaternion */
    quaternion dual; /**< dual part of dual quaternion */
} dual_quat;

/** @} */

#endif  // __LIBQUAT_H_

/** @} */
/**
 * @file
 * @brief Functions related to 3D quaternions and Euler angles.
 * @author Krishna Vedala
 */

#include <stdio.h>
#ifdef __arm__  // if compiling for ARM-Cortex processors
#define LIBQUAT_ARM
#include <arm_math.h>
#else
#include <math.h>
#endif
#include <assert.h>

#include "geometry_datatypes.h"

/**
 * @addtogroup quats 3D Quaternion operations
 * @{
 */

/**
 * Function to convert given Euler angles to a quaternion.
 * \f{eqnarray*}{
 * q_{0} & =
 * &\cos\left(\frac{\phi}{2}\right)\cos\left(\frac{\theta}{2}\right)\cos\left(\frac{\psi}{2}\right)
 * +
 * \sin\left(\frac{\phi}{2}\right)\sin\left(\frac{\theta}{2}\right)\sin\left(\frac{\psi}{2}\right)\\
 * q_{1} & =
 * &\sin\left(\frac{\phi}{2}\right)\cos\left(\frac{\theta}{2}\right)\cos\left(\frac{\psi}{2}\right)
 * -
 * \cos\left(\frac{\phi}{2}\right)\sin\left(\frac{\theta}{2}\right)\sin\left(\frac{\psi}{2}\right)\\
 * q_{2} & =
 * &\cos\left(\frac{\phi}{2}\right)\sin\left(\frac{\theta}{2}\right)\cos\left(\frac{\psi}{2}\right)
 * +
 * \sin\left(\frac{\phi}{2}\right)\cos\left(\frac{\theta}{2}\right)\sin\left(\frac{\psi}{2}\right)\\
 * q_{3} & =
 * &\cos\left(\frac{\phi}{2}\right)\cos\left(\frac{\theta}{2}\right)\sin\left(\frac{\psi}{2}\right)
 * -
 * \sin\left(\frac{\phi}{2}\right)\sin\left(\frac{\theta}{2}\right)\cos\left(\frac{\psi}{2}\right)\\
 * \f}
 *
 * @param [in] in_euler input Euler angles instance
 * @returns converted quaternion
 */
quaternion quat_from_euler(const euler *in_euler)
{
    quaternion out_quat;

    if (!in_euler)  // if null
    {
        fprintf(stderr, "%s: Invalid input.", __func__);
        return out_quat;
    }

    quaternion temp;

    float cy = cosf(in_euler->yaw * 0.5f);
    float sy = sinf(in_euler->yaw * 0.5f);
    float cp = cosf(in_euler->pitch * 0.5f);
    float sp = sinf(in_euler->pitch * 0.5f);
    float cr = cosf(in_euler->roll * 0.5f);
    float sr = sinf(in_euler->roll * 0.5f);

    temp.w = cr * cp * cy + sr * sp * sy;
    temp.q1 = sr * cp * cy - cr * sp * sy;
    temp.q2 = cr * sp * cy + sr * cp * sy;
    temp.q3 = cr * cp * sy - sr * sp * cy;

    return temp;
}

/**
 * Function to convert given quaternion to Euler angles.
 * \f{eqnarray*}{
 * \phi & = &
 * \tan^{-1}\left[\frac{2\left(q_0q_1+q_2q_3\right)}{1-2\left(q_1^2+q_2^2\right)}\right]\\
 * \theta & =
 * &-\sin^{-1}\left[2\left(q_0q_2-q_3q_1\right)\right]\\
 * \psi & = &
 * \tan^{-1}\left[\frac{2\left(q_0q_3+q_1q_2\right)}{1-2\left(q_2^2+q_3^2\right)}\right]\\
 * \f}
 *
 * @param [in] in_quat input quaternion instance
 * @returns converted euler angles
 */
euler euler_from_quat(const quaternion *in_quat)
{
    euler out_euler;
    if (!in_quat)  // if null
    {
        fprintf(stderr, "%s: Invalid input.", __func__);
        return out_euler;
    }

    out_euler.roll = atan2f(
        2.f * (in_quat->w * in_quat->q1 + in_quat->q2 * in_quat->q3),
        1.f - 2.f * (in_quat->q1 * in_quat->q1 + in_quat->q2 * in_quat->q2));
    out_euler.pitch =
        asinf(2.f * (in_quat->w * in_quat->q2 + in_quat->q1 * in_quat->q3));
    out_euler.yaw = atan2f(
        2.f * (in_quat->w * in_quat->q3 + in_quat->q1 * in_quat->q2),
        1.f - 2.f * (in_quat->q2 * in_quat->q2 + in_quat->q3 * in_quat->q3));

    return out_euler;
}

/**
 * Function to multiply two quaternions.
 * \f{eqnarray*}{
 * \mathbf{c} & = & \mathbf{a}\otimes\mathbf{b}\\
 * & = & \begin{bmatrix}a_{0} & a_{1} & a_{2} &
 *  a_{3}\end{bmatrix}\otimes\begin{bmatrix}b_{0} & b_{1} & b_{2} &
 *  b_{3}\end{bmatrix}\\
 * & = &
 * \begin{bmatrix}
 *  a_{0}b_{0}-a_{1}b_{1}-a_{2}b_{2}-a_{3}b_{3}\\
 *  a_{0}b_{1}+a_{1}b_{0}+a_{2}b_{3}-a_{3}b_{2}\\
 *  a_{0}b_{2}-a_{1}b_{3}+a_{2}b_{0}+a_{3}b_{1}\\
 *  a_{0}b_{3}+a_{1}b_{2}-a_{2}b_{1}+a_{3}b_{0}
 * \end{bmatrix}^{T}
 * \f}
 *
 * @param [in] in_quat1 first input quaternion instance
 * @param [in] in_quat2 second input quaternion instance
 * @returns resultant quaternion
 */
quaternion quaternion_multiply(const quaternion *in_quat1,
                               const quaternion *in_quat2)
{
    quaternion out_quat;
    if (!in_quat1 || !in_quat2)  // if null
    {
        fprintf(stderr, "%s: Invalid input.", __func__);
        return out_quat;
    }

    out_quat.w = in_quat1->w * in_quat2->w - in_quat1->q1 * in_quat2->q1 -
                 in_quat1->q2 * in_quat2->q2 - in_quat1->q3 * in_quat2->q3;
    out_quat.q1 = in_quat1->w * in_quat2->q1 + in_quat1->q1 * in_quat2->w +
                  in_quat1->q2 * in_quat2->q3 - in_quat1->q3 * in_quat2->q2;
    out_quat.q2 = in_quat1->w * in_quat2->q2 - in_quat1->q1 * in_quat2->q3 +
                  in_quat1->q2 * in_quat2->w + in_quat1->q3 * in_quat2->q1;
    out_quat.q3 = in_quat1->w * in_quat2->q3 + in_quat1->q1 * in_quat2->q2 -
                  in_quat1->q2 * in_quat2->q1 + in_quat1->q3 * in_quat2->w;

    return out_quat;
}

/** @} */

static void test()
{
    quaternion quat = {0.7071f, 0.7071f, 0.f, 0.f};
    euler eul = euler_from_quat(&quat);
    printf("Euler: %.4g, %.4g, %.4g\n", eul.pitch, eul.roll, eul.yaw);

    quaternion test_quat = quat_from_euler(&eul);
    printf("Quaternion: %.4g %+.4g %+.4g %+.4g\n", test_quat.w,
           test_quat.dual.x, test_quat.dual.y, test_quat.dual.z);

    assert(fabsf(test_quat.w - quat.w) < .01);
    assert(fabsf(test_quat.q1 - quat.q1) < .01);
    assert(fabsf(test_quat.q2 - quat.q2) < .01);
    assert(fabsf(test_quat.q3 - quat.q3) < .01);
}

int main()
{
    test();
    return 0;
}
/**
 * @file
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief Implementation of
 * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)
 *
 * @details
 * Implementation of the program is based on the geometry shown in the figure
 * below:
 *
 * <a
 * href="https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg"><img
 * src="https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg"
 * alt="Spirograph geometry from Wikipedia" style="width: 250px"/></a>
 */
#define _USE_MATH_DEFINES /**< required for MSVC compiler */
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/** Generate spirograph curve into arrays `x` and `y` such that the i^th point
 * in 2D is represented by `(x[i],y[i])`. The generating function is given by:
 * \f{eqnarray*}{
 * x &=& R\left[ (1-k) \cos (t) + l\cdot k\cdot\cos \left(\frac{1-k}{k}t\right)
 * \right]\\
 * y &=& R\left[ (1-k) \sin (t) - l\cdot k\cdot\sin \left(\frac{1-k}{k}t\right)
 * \right] \f}
 * where
 * * \f$R\f$ is the scaling parameter that we will consider \f$=1\f$
 * * \f$l=\frac{\rho}{r}\f$ is the relative distance of marker from the centre
 * of inner circle and \f$0\le l\le1\f$
 * * \f$\rho\f$ is physical distance of marker from centre of inner circle
 * * \f$r\f$ is the radius of inner circle
 * * \f$k=\frac{r}{R}\f$ is the ratio of radius of inner circle to outer circle
 * and \f$0<k<1\f$
 * * \f$R\f$ is the radius of outer circle
 * * \f$t\f$ is the angle of rotation of the point i.e., represents the time
 * parameter
 *
 * Since we are considering ratios, the actual values of \f$r\f$ and
 * \f$R\f$ are immaterial.
 *
 * @param [out] x output array containing absicca of points (must be
 * pre-allocated)
 * @param [out] y output array containing ordinates of points (must be
 * pre-allocated)
 * @param l the relative distance of marker from the centre of
 * inner circle and \f$0\le l\le1\f$
 * @param k the ratio of radius of inner circle to outer circle and
 * \f$0<k<1\f$
 * @param N number of sample points along the trajectory (higher = better
 * resolution but consumes more time and memory)
 * @param num_rot the number of rotations to perform (can be fractional value)
 */
void spirograph(double *x, double *y, double l, double k, size_t N, double rot)
{
    double dt = rot * 2.f * M_PI / N;
    double t = 0.f, R = 1.f;
    const double k1 = 1.f - k;

    for (size_t dk = 0; dk < N; dk++, t += dt)
    {
        x[dk] = R * (k1 * cos(t) + l * k * cos(k1 * t / k));
        y[dk] = R * (k1 * sin(t) - l * k * sin(k1 * t / k));
    }
}

/**
 * @brief Test function to save resulting points to a CSV file.
 *
 */
void test(void)
{
    size_t N = 500;
    double l = 0.3, k = 0.75, rot = 10.;
    char fname[50];
    snprintf(fname, 50, "spirograph_%.2f_%.2f_%.2f.csv", l, k, rot);
    FILE *fp = fopen(fname, "wt");
    if (!fp)
    {
        perror(fname);
        exit(EXIT_FAILURE);
    }

    double *x = (double *)malloc(N * sizeof(double));
    double *y = (double *)malloc(N * sizeof(double));

    spirograph(x, y, l, k, N, rot);

    for (size_t i = 0; i < N; i++)
    {
        fprintf(fp, "%.5g, %.5g", x[i], y[i]);
        if (i < N - 1)
        {
            fputc('\n', fp);
        }
    }

    fclose(fp);

    free(x);
    free(y);
}

#ifdef USE_GLUT  // this is set by CMAKE automatically, if available
#ifdef __APPLE__
#include <GLUT/glut.h>  // include path on Macs is different
#else
#include <GL/glut.h>
#endif

static bool paused = 0; /**< flag to set pause/unpause animation */
static const int animation_speed = 25; /**< animation delate in ms */

static const double step = 0.01;   /**< animation step size */
static double l_ratio = 0.1;       /**< the l-ratio defined in docs */
static double k_ratio = 0.1;       /**< the k-ratio defined in docs */
static const double num_rot = 20.; /**< number of rotations to simulate */

/** A wrapper that is not available in all GLUT implementations.
 */
static inline void glutBitmapString(void *font, char *string)
{
    for (char *ch = string; *ch != '\0'; ch++) glutBitmapCharacter(font, *ch);
}

/**
 * @brief Function to graph (x,y) points on the OpenGL graphics window.
 *
 * @param x array containing absicca of points (must be pre-allocated)
 * @param y array containing ordinates of points (must be pre-allocated)
 * @param N number of points in the the arrays
 */
void display_graph(const double *x, const double *y, size_t N, double l,
                   double k)
{
    glClearColor(1.0f, 1.0f, 1.0f,
                 0.0f);            // Set background color to white and opaque
    glClear(GL_COLOR_BUFFER_BIT);  // Clear the color buffer (background)

    if (x && y)
    {
        glBegin(GL_LINES);         // draw line segments
        glColor3f(0.f, 0.f, 1.f);  // blue
        glPointSize(2.f);          // point size in pixels

        for (size_t i = 1; i < N; i++)
        {
            glVertex2f(x[i - 1], y[i - 1]);  // line from
            glVertex2f(x[i], y[i]);          // line to
        }
        glEnd();
    }
    glColor3f(0.f, 0.f, 0.f);
    char buffer[20];
    snprintf(buffer, 20, "l = %.3f", l);
    glRasterPos2f(-.85, .85);
    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);
    snprintf(buffer, 20, "k = %.3f", k);
    glRasterPos2f(-.85, .75);
    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);

    glutSwapBuffers();
}

/**
 * @brief Test function with animation
 *
 */
void test2(void)
{
    const size_t N = 1000;  // number of samples

    static bool direction1 = true;  // increment if true, otherwise decrement
    static bool direction2 = true;  // increment if true, otherwise decrement

    double *x = (double *)malloc(N * sizeof(double));
    double *y = (double *)malloc(N * sizeof(double));

    spirograph(x, y, l_ratio, k_ratio, N, num_rot);
    display_graph(x, y, N, l_ratio, k_ratio);

    free(x);  // free dynamic memories
    free(y);

    if (paused)
        // if paused, do not update l_ratio and k_ratio
        return;

    if (direction1)  // increment k_ratio
    {
        if (k_ratio >= (1.f - step))  // maximum limit
            direction1 = false;       // reverse direction of k_ratio
        else
            k_ratio += step;
    }
    else  // decrement k_ratio
    {
        if (k_ratio <= step)  // minimum limit
        {
            direction1 = true;  // reverse direction of k_ratio

            if (direction2)  // increment l_ratio
            {
                if (l_ratio >= (1.f - step))  // max limit of l_ratio
                    direction2 = false;       // reverse direction of l_ratio
                else
                    l_ratio += step;
            }
            else  // decrement l_ratio
            {
                if (l_ratio <= step)    // minimum limit of l_ratio
                    direction2 = true;  // reverse direction of l_ratio
                else
                    l_ratio -= step;
            }
        }
        else  // no min limit of k_ratio
            k_ratio -= step;
    }
}

/**
 * @brief GLUT timer callback function to add animation delay.
 */
void timer_cb(int id)
{
    glutPostRedisplay();
    glutTimerFunc(animation_speed, timer_cb, 0);
}

/**
 * @brief Keypress event call back function.
 *
 * @param key ID of the key pressed
 * @param x mouse pointer position at event
 * @param y mouse pointer position at event
 */
void keyboard_cb(unsigned char key, int x, int y)
{
    switch (key)
    {
    case ' ':              // spacebar toggles pause
        paused = !paused;  // toggle
        break;
    case '+':  // up arrow key
        k_ratio += step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '_':  // down arrow key
        k_ratio -= step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '=':  // left arrow key
        l_ratio += step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '-':  // right arrow key
        l_ratio -= step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case 0x1B:  // escape key exits
        exit(EXIT_SUCCESS);
    }
}
#endif

/** Main function */
int main(int argc, char **argv)
{
    test();

#ifdef USE_GLUT
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
    glutCreateWindow("Spirograph");
    glutInitWindowSize(400, 400);
    // glutIdleFunc(glutPostRedisplay);
    glutTimerFunc(animation_speed, timer_cb, 0);
    glutKeyboardFunc(keyboard_cb);
    glutDisplayFunc(test2);
    glutMainLoop();
#endif

    return 0;
}
/**
 * @file
 * @author [Carlos Rafael](https://github.com/CarlosZoft)
 * @author [Herick Lima](https://github.com/hericklima22)
 * @brief [naval_battle](https://en.wikipedia.org/wiki/Battleship_(game))
 * implementation in C using only the stdio.h for Standard Input and Output.
 * @details  Naval battle is a game, to be played by two people. It consists of
 * knocking down the enemy ship, through shots , when hit the ship is
 * revealed with the respective number of its size. Example: size 3 = 3 3 3 on
 * the board.
 * To play - boats over size 1, need direction; V -> vertical and H ->
 * horizontal. Example Input 1 A H -> line 1, column A, direction H
 * (Horizontal).
 */

#include <stdio.h>  /// for Standard Input Output

/**
 * @brief Function validEntryLineColumn
 * Responsible for validating entries, for positioning boats
 * @param line matrix row
 * @param column matrix column
 * @returns if the row and column are valid
 */
int validEntryLineColumn(int line, char column)
{
    if ((line >= 1 && line <= 10) && (column >= 65 && column <= 74))
    {
        return 1;
    }

    return 0;
}
/**
 * @brief Function validatePosition
 * Responsible for checking if the position can receive the boat.
 * @param mat board
 * @param boat boat
 * @param line matrix row
 * @param column matrix column
 * @returns if the position is valid
 */
int validatePosition(int mat[10][10], int boat, int line, int column,
                     char guide)
{
    int cont = 0;
    int i, j;

    if (line < 0 || line > 9 || column < 0 || column > 9 ||
        (guide != 'H' && guide != 'V') || boat < 1 || boat > 3)
    {
        return 0;
    }

    if (guide == 'H')
    {
        if ((10 - column) < boat)
        {
            return 0;
        }
        else
        {
            for (j = column; j < (column + boat); j++)
            {
                if (mat[line][j] == 0)
                {
                    cont++;
                }
            }
        }
    }

    if (guide == 'V')
    {
        if ((10 - line) < boat)
        {
            return 0;
        }

        else
        {
            for (i = line; i < (line + boat); i++)
            {
                if (mat[i][column] == 0)
                {
                    cont++;
                }
            }
        }
    }

    if (cont == boat)
    {
        return 1;
    }
    return 0;
}
/**
 * @brief Function canShoot
 * Responsible to verify that it is a valid position to shoot
 * @param mat board
 * @param line matrix row
 * @param column matrix column
 * @returns if the position is valid for shooting
 */

int canShoot(int mat[10][10], int line, int column)
{
    if (mat[line][column] == -2 || mat[line][column] == 10 ||
        mat[line][column] == 20 || mat[line][column] == 30 ||
        mat[line][column] == 50)
    {
        return 0;
    }

    return 1;
}
/**
 * @brief Function positionBoat
 * Responsible for placing the boats on the board, according to the size.
 * @param mat board
 * @param boat boat
 */
void positionBoat(int mat[10][10], int boat)
{
    int line, j;
    char column, guide;

    if (boat == 1)
    {
        scanf("%d %c", &line, &column);

        while (validEntryLineColumn(line, column) != 1 ||
               validatePosition(mat, boat, (line - 1), (column - 65), 'H') != 1)
        {
            printf("Position unavailable!\n");
            scanf("%d %c", &line, &column);
        }
    }

    else
    {
        scanf("%d %c %c", &line, &column, &guide);

        while (validEntryLineColumn(line, column) == 0 ||
               validatePosition(mat, boat, (line - 1), (column - 65), guide) ==
                   0)
        {
            printf("Position unavailable!\n");
            scanf("%d %c %c", &line, &column, &guide);
        }
    }

    int aux = column - 'A';
    line -= 1;

    if (boat == 1)
    {
        for (j = aux; j < (aux + boat); j++)
        {
            mat[line][j] = boat;
        }

        for (int a = line - 1; a < (line + boat + 1); a++)
        {
            for (int b = aux - 1; b < (aux + boat + 1); b++)
            {
                if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                {
                    if (mat[a][b] != boat)
                    {
                        mat[a][b] = -1;
                    }
                }
            }
        }
    }

    if (guide == 'H')
    {
        for (j = aux; j < (aux + boat); j++)
        {
            mat[line][j] = boat;
        }
        if (boat == 3)
        {
            for (int a = line - 1; a < (line + boat - 1); a++)
            {
                for (int b = aux - 1; b < (aux + boat + 1); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }

        else
        {
            for (int a = line - 1; a < (line + boat); a++)
            {
                for (int b = aux - 1; b < (aux + boat + 1); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }
    }

    if (guide == 'V')
    {
        for (j = line; j < (line + boat); j++)
        {
            mat[j][aux] = boat;
        }
        if (boat == 3)
        {
            for (int a = line - 1; a < (line + boat + 1); a++)
            {
                for (int b = aux - 1; b < (aux + boat - 1); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }

        else
        {
            for (int a = line - 1; a < (line + boat + 1); a++)
            {
                for (int b = aux - 1; b < (aux + boat); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }
    }
}
/**
 * @brief Function printMessage
 * Responsible for printing the auxiliary message
 * @param msg msg with board
 */
void printMessage(char *msg)
{
    printf("************************\n");
    printf("*\n");
    printf("* %s\n", msg);
    printf("*\n");
    printf("************************\n");
}
/**
 * @brief Function printMessageScore
 * Responsible for printing the score messages
 * @param pts1 player 1 score
 * @param pts2 player 2 score
 */
void printMessageScore(int pts1, int pts2)
{
    printf("************************\n");
    printf("*\n");
    printf("* Player'S SCORE 1: %02d\n", pts1);
    printf("* Player'S SCORE 2: %02d\n", pts2);
    printf("*\n");
    printf("************************\n");
}
/**
 * @brief Function printTable
 * Responsible for printing the board
 * @param logic return of the logical matrix
 * @param stage game step
 * @returns char for visual matrix
 */
char printTable(int logic, int stage)
{
    if (stage == 0)
    {
        if (logic == 0)
        {
            return '.';
        }

        else if (logic == -1)
        {
            return '*';
        }

        else if (logic == 1)
        {
            return '1';
        }

        else if (logic == 2)
        {
            return '2';
        }

        else
        {
            return '3';
        }
    }

    else
    {
        if (logic == 0 || logic == -1 || logic == 1 || logic == 2 || logic == 3)
        {
            return '.';
        }

        else if (logic == -2)
        {
            return 'x';
        }

        else if (logic == 10 || logic == 20 || logic == 30)
        {
            return 'N';
        }

        else
        {
            return 'A';
        }
    }
}
/**
 * @brief Function printsTray
 * Responsible for printing the visual board for the user
 * @param mat Matrix
 * @param stage game step
 */
void printsTray(int mat[10][10], int stage)
{
    int logic;
    char imp;

    printf("     ");
    for (int i = 65; i < 75; i++)
    {
        printf("%c", i);
        if (i < 74)
        {
            printf(" ");
        }
    }
    printf("\n");

    for (int i = 0; i < 12; i++)
    {
        if (i > 0 && i < 11)
        {
            printf("%02d ", i);
        }

        else
        {
            printf("   ");
        }

        for (int j = 0; j < 12; j++)
        {
            if ((i > 0 && i < 11) && (j > 0 && j < 11))
            {
                logic = mat[i - 1][j - 1];
                imp = printTable(logic, stage);
                printf("%c", imp);
            }
            else
            {
                printf("#");
            }

            if (j < 11)
            {
                printf(" ");
            }
        }
        printf("\n");
    }
}
/**
 * @brief Function shoot
 * Responsible for saying if he hit a boat
 * @param mat board
 * @param line matrix row
 * @param column matrix column
 */
void shoot(int mat[10][10], int line, int column)
{
    if (mat[line][column] == 0 || mat[line][column] == -1)
    {
        mat[line][column] = -2;
    }

    else if (mat[line][column] == 1)
    {
        mat[line][column] = 10;
    }

    else if (mat[line][column] == 2)
    {
        mat[line][column] = 20;
    }

    else if (mat[line][column] == 3)
    {
        mat[line][column] = 30;
    }
}
/**
 * @brief Function calculateScore
 * Responsible for calculating the score obtained during the game
 * @param mat board
 * @param line matrix row
 * @param column matrix column
 * @returns resulting score
 */

int calculateScore(int mat[10][10], int line, int column)
{
    int c = 0, b = 0, e = 0, d = 0;

    if (mat[line][column] == 10)
    {
        mat[line][column] = 50;
        return 2;
    }

    else if (mat[line][column] == 20)
    {
        if (mat[line + 1][column] == 20)
        {
            b = 1;
        }

        if (mat[line - 1][column] == 20)
        {
            c = 1;
        }

        if (mat[line][column + 1] == 20)
        {
            d = 1;
        }

        if (mat[line][column - 1] == 20)
        {
            e = 1;
        }

        if (b == 1)
        {
            if (mat[line + 1][column] == 20)
            {
                mat[line][column] = 50;
                mat[line + 1][column] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }

        if (c == 1)
        {
            if (mat[line - 1][column] == 20)
            {
                mat[line][column] = 50;
                mat[line - 1][column] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }

        if (d == 1)
        {
            if (mat[line][column + 1] == 20)
            {
                mat[line][column] = 50;
                mat[line][column + 1] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }

        if (e == 1)
        {
            if (mat[line][column - 1] == 20)
            {
                mat[line][column] = 50;
                mat[line][column - 1] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }
    }

    else if (mat[line][column] == 30)
    {
        if (mat[line + 1][column] == 30)
        {
            b = 1;
        }

        if (mat[line - 1][column] == 30)
        {
            c = 1;
        }
        if (mat[line][column + 1] == 30)
        {
            d = 1;
        }

        if (mat[line][column - 1] == 30)
        {
            e = 1;
        }

        if (b == 1 && c == 1)
        {
            if (mat[line + 1][column] == 30 && mat[line - 1][column] == 30)
            {
                mat[line][column] = 50;
                mat[line + 1][column] = 50;
                mat[line - 1][column] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (d == 1 && e == 1)
        {
            if (mat[line][column + 1] == 30 && mat[line][column - 1] == 30)
            {
                mat[line][column] = 50;
                mat[line][column - 1] = 50;
                mat[line][column + 1] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (d == 1)
        {
            if (mat[line][column + 1] == 30 && mat[line][column + 2] == 30)
            {
                mat[line][column] = 50;
                mat[line][column + 1] = 50;
                mat[line][column + 2] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (e == 1)
        {
            if (mat[line][column - 1] == 30 && mat[line][column - 2] == 30)
            {
                mat[line][column] = 50;
                mat[line][column - 1] = 50;
                mat[line][column - 2] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (c == 1)
        {
            if (mat[line - 1][column] == 30 && mat[line - 2][column] == 30)
            {
                mat[line][column] = 50;
                mat[line - 1][column] = 50;
                mat[line - 2][column] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (b == 1)
        {
            if (mat[line + 1][column] == 30 && mat[line + 2][column] == 30)
            {
                mat[line][column] = 50;
                mat[line + 1][column] = 50;
                mat[line + 2][column] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }
    }
    return 0;
}
/**
 * @brief Function printPositioning
 * Responsible for printing messages for positioning boats on the board; of
 * player 1 and 2
 * @param Player number representing the Player
 * @param boat number that represents the boat
 * @param nm which message to print
 */
void printPositioning(int Player, int boat, int nm)
{
    if (Player == 1)
    {
        char msg1[60] = "Player 1 - Position the size boat 1 (1/6)";
        char msg2[60] = "Player 1 - Position the size boat 1 (2/6)";
        char msg3[60] = "Player 1 - Position the size boat 1 (3/6)";
        char msg4[60] = "Player 1 - Position the size boat 1 (4/6)";
        char msg5[60] = "Player 1 - Position the size boat 1 (5/6)";
        char msg6[60] = "Player 1 - Position the size boat 1 (6/6)";

        char msg7[60] = "Player 1 - Position the size boat 2 (1/4)";
        char msg8[60] = "Player 1 - Position the size boat 2 (2/4)";
        char msg9[60] = "Player 1 - Position the size boat 2 (3/4)";
        char msg10[60] = "Player 1 - Position the size boat 2 (4/4)";

        char msg11[60] = "Player 1 - Position the size boat 3 (1/2)";
        char msg12[60] = "Player 1 - Position the size boat 3 (2/2)";

        if (boat == 1)
        {
            if (nm == 1)
            {
                printMessage(msg1);
            }
            else if (nm == 2)
            {
                printMessage(msg2);
            }
            else if (nm == 3)
            {
                printMessage(msg3);
            }

            else if (nm == 4)
            {
                printMessage(msg4);
            }

            else if (nm == 5)
            {
                printMessage(msg5);
            }

            else if (nm == 6)
            {
                printMessage(msg6);
            }
        }
        else if (boat == 2)
        {
            if (nm == 1)
            {
                printMessage(msg7);
            }
            else if (nm == 2)
            {
                printMessage(msg8);
            }
            else if (nm == 3)
            {
                printMessage(msg9);
            }
            else if (nm == 4)
            {
                printMessage(msg10);
            }
        }
        else if (boat == 3)
        {
            if (nm == 1)
            {
                printMessage(msg11);
            }
            if (nm == 2)
            {
                printMessage(msg12);
            }
        }
    }

    if (Player == 2)
    {
        char msg1[60] = "Player 2 - Position the size boat 1 (1/6)";
        char msg2[60] = "Player 2 - Position the size boat 1 (2/6)";
        char msg3[60] = "Player 2 - Position the size boat 1 (3/6)";
        char msg4[60] = "Player 2 - Position the size boat 1 (4/6)";
        char msg5[60] = "Player 2 - Position the size boat 1 (5/6)";
        char msg6[60] = "Player 2 - Position the size boat 1 (6/6)";

        char msg7[60] = "Player 2 - Position the size boat 2 (1/4)";
        char msg8[60] = "Player 2 - Position the size boat 2 (2/4)";
        char msg9[60] = "Player 2 - Position the size boat 2 (3/4)";
        char msg10[60] = "Player 2 - Position the size boat 2 (4/4)";

        char msg11[60] = "Player 2 - Position the size boat 3 (1/2)";
        char msg12[60] = "Player 2 - Position the size boat 3 (2/2)";

        if (boat == 1)
        {
            if (nm == 1)
            {
                printMessage(msg1);
            }
            else if (nm == 2)
            {
                printMessage(msg2);
            }
            else if (nm == 3)
            {
                printMessage(msg3);
            }
            else if (nm == 4)
            {
                printMessage(msg4);
            }
            else if (nm == 5)
            {
                printMessage(msg5);
            }
            else if (nm == 6)
            {
                printMessage(msg6);
            }
        }
        else if (boat == 2)
        {
            if (nm == 1)
            {
                printMessage(msg7);
            }
            else if (nm == 2)
            {
                printMessage(msg8);
            }
            else if (nm == 3)
            {
                printMessage(msg9);
            }
            else if (nm == 4)
            {
                printMessage(msg10);
            }
        }
        else if (boat == 3)
        {
            if (nm == 1)
            {
                printMessage(msg11);
            }
            else if (nm == 2)
            {
                printMessage(msg12);
            }
        }
    }
}
/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    int Player1[10][10];
    int Player2[10][10];
    int plays = 1;
    int pts1 = 0, pts2 = 0, a1 = 0, a2 = 0;
    int line, col = 0, lin = 0;
    char column;

    // filling matrix with 0
    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            Player1[i][j] = 0;
            Player2[i][j] = 0;
        }
    }

    // positioning boats
    for (int i = 1; i <= 2; i++)
    {
        for (int j = 1; j <= 6; j++)
        {
            if (i == 1)
            {
                printPositioning(i, 1, j);
                printsTray(Player1, 0);
                positionBoat(Player1, 1);
            }
            else if (i == 2)
            {
                printPositioning(i, 1, j);
                printsTray(Player2, 0);
                positionBoat(Player2, 1);
            }
        }
        for (int j = 1; j <= 4; j++)
        {
            if (i == 1)
            {
                printPositioning(i, 2, j);
                printsTray(Player1, 0);
                positionBoat(Player1, 2);
            }
            else if (i == 2)
            {
                printPositioning(i, 2, j);
                printsTray(Player2, 0);
                positionBoat(Player2, 2);
            }
        }
        for (int j = 1; j <= 2; j++)
        {
            if (i == 1)
            {
                printPositioning(i, 3, j);
                printsTray(Player1, 0);
                positionBoat(Player1, 3);
            }
            else if (i == 2)
            {
                printPositioning(i, 3, j);
                printsTray(Player2, 0);
                positionBoat(Player2, 3);
            }
        }
    }

    // starting the game
    while (plays <= 40)
    {
        if (plays % 2 != 0)
        {
            printMessageScore(pts1, pts2);
            printMessage("Player's turn 1");
            printsTray(Player2, 1);
            scanf("%d %c", &line, &column);

            while (validEntryLineColumn(line, column) != 1 ||
                   canShoot(Player2, line - 1, column - 65) != 1)
            {
                line = 0;
                column = 'a';
                printf("Position unavailable!\n");
                scanf("%d %c", &line, &column);
            }
            lin = line - 1;
            col = column - 65;
            shoot(Player2, lin, col);
            a1 = pts1;
            pts1 += calculateScore(Player2, lin, col);

            if (a1 != pts1)
            {
                printMessage("Player 1 DROPPED A BOAT!");
            }
        }
        else
        {
            printMessageScore(pts1, pts2);
            printMessage("Player's turn 1");
            printsTray(Player1, 1);
            scanf("%d %c", &line, &column);

            while (validEntryLineColumn(line, column) != 1 ||
                   canShoot(Player1, line - 1, column - 65) != 1)
            {
                printf("Position unavailable!\n");
                scanf("%d %c", &line, &column);
            }
            lin = line - 1;
            col = column - 65;
            shoot(Player1, lin, col);
            a2 = pts2;
            pts2 += calculateScore(Player1, lin, col);

            if (a2 != pts2)
            {
                printMessage("Player 2 DROPPED A BOAT!");
            }
        }

        plays++;
    }
    /**
     * the one with the most points wins, or the one who knocks down all boats
     * first.
     */
    printMessage("END GAME\n");
    printMessageScore(pts1, pts2);

    return 0;
}
/**
 * @file tic-tac-toe.c
 * @author [vivekboss99](github.com/vivekboss99)
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief [Tic-Tac-Toe game](https://en.wikipedia.org/wiki/Tic-tac-toe)
 * implementation in C
 * @details  Tic-Tac-Toe Game, where the user can decide to play with the
 * computer(single player mode) or with other user(double player mode), the
 * code as an array named 'game_table' which is the table and user needs to enter the
 * position inside the array(from 1-9) where he/she wants to place 'X' or 'O' on the
 * table.
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

// Functions Declarations
static void singlemode();
static void doublemode();
static void placex(int);  // used for placing position of X by the 1st player
static void place();      // used by the computer to place O
static void placey(int);  // used in Double Player mode by the 2nd player to
                          // place the position of O
int checkwin();  // checks everytime when a player or computer places 'X' or 'O'

/** Tic-Tac-Toe table, so basically we are using variable 'game_table' as the table(size:3X3) and
 * updating it regularly
 */
static char game_table[9];

/**
 * Main program function.
 * @returns 0 on clean exit. 
 * @note No checks are included for program execution failures!
 */
int main()
{   
    srand( (unsigned int)time(NULL));
    int l = 0;
    do
    {
        int n = 0;

        // filling the table with multiple asterisks
        for (int i = 0; i < 9; i++) game_table[i] = '*';

        // displaying the main menu
        printf("***************************************\n");
        printf("*************TIC TAC TOE***************\n");
        printf("***************************************\n");
        printf("***********1. YOU vs COMPUTER ***********\n");
        printf("***********2. YOU vs PLAYER ***********\n");
        printf("***********3.EXIT *********************\n");
        printf("Enter your choice : ");
        scanf("%d", &n);

        switch (n)  // switch case to select between single player mode or
                    // double player mode
        {
        case 1:
            singlemode();
            break;
        case 2:
            doublemode();
            break;
        default:
            printf("THANK YOU and EXIT!");
        }

        printf("Next game ? : ");
        printf("Enter 1 – YES and 0 - NO ");
        scanf("%d", &l);

    } while (l == 1);

    return 0;
}

/**
 * @brief Implementation of game vs computer
 *
 * @returns None
 */
void singlemode()
{
    int m;
    int k = 0;
    int table_fill_count=0;

    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            printf("%c ", game_table[k]);
            k++;
        }

        printf("\n");
    }

    for (int x = 1; x < 10; x++)
    {
        k = 0;

        printf("Where would you like to place 'x' ");
        scanf("%d", &m);

        placex(m);
        if(table_fill_count<4)
        {
          place();
        }

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                printf("%c ", game_table[k]);
                k++;

            }

            printf("\n");
        }
        table_fill_count++;
        int o = checkwin();

        if (o == -1 || o == -2)
        {
            if (o == -1)
            {
                printf("YOU WIN\n");
            }
            if (o == -2)
            {
                printf("YOU LOSE\n");
            }

            break;
        }

        if (table_fill_count==4)
        {
            printf("\nDRAW ");
            break;
        }
    }
}

/**
 * @brief Implementation of game vs another player.
 *
 * @returns None
 */
void doublemode()
{
    int m;
    int e1;
    int k = 0;
    int doublemode_table_count=0;

    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            printf("%c ", game_table[k]);
            k++;
        }

        printf("\n");
    }
    for (int x = 1; x < 10; x++)
    {
        k = 0;

        printf("PLAYER1 - where would you like to place 'x' : ");
        scanf("%d", &m);

        placex(m);
        if(doublemode_table_count<4)
        {
        printf("PLAYER2 - where would you like to place 'o' : ");
        scanf("%d", &e1);

        placey(e1);
        }

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                printf("%c ", game_table[k]);
                k++;
            }

            printf("\n");
        }
        doublemode_table_count++;
        int o = checkwin();

        if (o == -1 || o == -2)
        {
            if (o == -1)
            {
                printf("Player 1 WIN\n");
            }
            if (o == -2)
            {
                printf("Player 2 WIN\n");
            }

            break;
        }
        if (doublemode_table_count==4)
        {
            printf("\nDRAW ");
            break;
        }
    }
}

int check_placex(){
	char input[50];
	int n1;
	while (1){
		fgets(input,49,stdin);
		if ( strlen(input) > 2 || strlen(input)  == 0){
			fprintf(stderr,"Invalid move, Enter number 1 - 9: ");
			continue;
		}
		if(sscanf(input,"%d",&n1) != 1){
			fprintf(stderr,"Invalid move, Enter number 1 - 9: ");
			continue;
		} 
		if ((game_table[n1-1] == 'x') || (game_table[n1-1]) == 'o' || (n1== 0)){
			fprintf(stderr,"Already allocated, Enter number: ");
			continue;
		}
		return n1;
	}
}	





/**
 * @brief Update table by placing an `X`
 *
 * @param m location to place `X`
 *
 * @returns None
 */
void placex(int m)
{
    int n1 = 0;
    if (m >= 1 && m <= 9)
    {
        if (game_table[m - 1] != 'x' && game_table[m - 1] != 'o')
        {
            game_table[m - 1] = 'x';
        }
        else
        {
			int n = check_placex();
			placex(n);
        }
    }
    else
    {
		int n = check_placex();
		placex(n);
    }
}
/**
 * @brief Update table by placing an `O`
 *
 * @returns None
 */
void place()
{

    int e = rand() % 9;

    if (e >= 0 && e <= 8)
    {
        if (game_table[e] != 'x' && game_table[e] != 'o')
        {
            game_table[e] = 'o';
            printf("\n Computer placed at %d position\n", e + 1);
        }
        else
        {
            place();
        }
    }
}
/**
 * @brief Update table by placing an `O`
 *
 * @param e1 location to place `O`
 *
 * @returns None
 */
void placey(int e1)
{
    int n1 = 0;
    if (e1 >= 1 && e1 <= 9)
    {
        if (game_table[e1 - 1] != 'x' && game_table[e1 - 1] != 'o')
        {
            game_table[e1 - 1] = 'o';
        }
        else
        {
			int n = check_placex();
			placex(n);
        }
    }
    else
    {
		int n = check_placex();
		placex(n);
    }
}
/**
 * @brief Implementation of win conditon checker for 'X' or 'O' whenever the table is updated
 *
 * @returns -1: if 'X' won 
 * @returns -2: if 'O' won
 * @returns 0: if there is no win condition for 'X' or 'O' 
 */
int checkwin()
{
    if (game_table[0] == game_table[1] && game_table[1] == game_table[2])
    {
        if (game_table[0] == 'x' && game_table[1] == 'x' &&
            game_table[2] == 'x')
        {
            return -1;
        }

        if (game_table[0] == 'o' && game_table[1] == 'o' &&
            game_table[2] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[0] == game_table[4] && game_table[4] == game_table[8])
    {
        if (game_table[0] == 'x' && game_table[4] == 'x' &&
            game_table[8] == 'x')
        {
            return -1;
        }

        if (game_table[0] == 'o' && game_table[4] == 'o' &&
            game_table[8] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[0] == game_table[3] && game_table[3] == game_table[6])
    {
        if (game_table[0] == 'x' && game_table[3] == 'x' &&
            game_table[6] == 'x')
        {
            return -1;
        }

        if (game_table[0] == 'o' && game_table[3] == 'o' &&
            game_table[6] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[3] == game_table[4] && game_table[4] == game_table[5])
    {
        if (game_table[3] == 'x' && game_table[4] == 'x' &&
            game_table[5] == 'x')
        {
            return -1;
        }

        if (game_table[3] == 'o' && game_table[4] == 'o' &&
            game_table[5] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[6] == game_table[7] && game_table[7] == game_table[8])
    {
        if (game_table[6] == 'x' && game_table[7] == 'x' &&
            game_table[8] == 'x')
        {
            return -1;
        }

        if (game_table[6] == 'o' && game_table[7] == 'o' &&
            game_table[8] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[1] == game_table[4] && game_table[4] == game_table[7])
    {
        if (game_table[1] == 'x' && game_table[4] == 'x' &&
            game_table[7] == 'x')
        {
            return -1;
        }

        if (game_table[1] == 'o' && game_table[4] == 'o' &&
            game_table[7] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[2] == game_table[5] && game_table[5] == game_table[8])
    {
        if (game_table[2] == 'x' && game_table[5] == 'x' &&
            game_table[8] == 'x')
        {
            return -1;
        }

        if (game_table[2] == 'o' && game_table[5] == 'o' &&
            game_table[8] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[2] == game_table[4] && game_table[4] == game_table[6])
    {
        if (game_table[2] == 'x' && game_table[4] == 'x' &&
            game_table[6] == 'x')
        {
            return -1;
        }

        if (game_table[2] == 'o' && game_table[4] == 'o' &&
            game_table[6] == 'o')
        {
            return -2;
        }
    }
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

#define MAX 20
#define INF 999

int mat[MAX][MAX];
int V;

int dist[MAX];

int q[MAX];
int qp = 0;

void enqueue(int v) { q[qp++] = v; }

int cf(void *a, void *b)
{
    int *x = (int *)a;
    int *y = (int *)b;
    return *y - *x;
}

int dequeue()
{
    qsort(q, qp, sizeof(int), cf);
    return q[--qp];
}

int queue_has_something() { return (qp > 0); }

int visited[MAX];
int vp = 0;

void dijkstra(int s)
{
    dist[s] = 0;
    int i;
    for (i = 0; i < V; ++i)
    {
        if (i != s)
        {
            dist[i] = INF;
        }
        enqueue(i);
    }
    while (queue_has_something())
    {
        int u = dequeue();
        visited[vp++] = u;
        for (i = 0; i < V; ++i)
        {
            if (mat[u][i])
            {
                if (dist[i] > dist[u] + mat[u][i])
                {
                    dist[i] = dist[u] + mat[u][i];
                }
            }
        }
    }
}

int main(int argc, char const *argv[])
{
    printf("Enter the number of vertices: ");
    scanf(" %d", &V);
    printf("Enter the adj matrix: ");
    int i, j;
    for (i = 0; i < V; ++i)
    {
        for (j = 0; j < V; ++j)
        {
            scanf(" %d", &mat[i][j]);
        }
    }

    dijkstra(0);

    printf("\nNode\tDist\n");
    for (i = 0; i < V; ++i)
    {
        printf("%d\t%d\n", i, dist[i]);
    }

    return 0;
}
/**
 * @file
 * @author [Timothy Maloney](https://github.com/sl1mb0)
 * @brief [Prim's algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)
 * implementation in C to find the MST of a weighted, connected graph.
 * @details Prim's algorithm uses a greedy approach to generate the MST of a weighted connected graph.
 * The algorithm begins at an arbitrary vertex v, and selects a next vertex u, 
 * where v and u are connected by a weighted edge whose weight is the minimum of all edges connected to v. 
 * @references Page 319 "Introduction to the Design and Analysis of Algorithms" - Anany Levitin
 *
 * To test - run './prim -test'
 * prim() will find the MST of the following adj. matrix:
 *	  
 *	  0  1  2  3
 *        1  0  4  6
 *        2  4  0  5
 *        3  6  5  0
 * 
 * The minimum spanning tree for the above weighted connected graph is given by the following adj matrix:
 *	   
 *	  0  1  2  3
 *	  1  0  0  0
 *	  2  0  0  0
 *	  3  0  0  0
 *
 *
 * The following [link](https://visualgo.net/en/mst) provides a visual representation of graphs that can be used to test/verify the algorithm for different adj
 * matrices and their weighted, connected graphs.
 */

#include <stdio.h>        /// for IO operations
#include <string.h>      /// for string comparison
#include <assert.h>     /// for assert()
#include <inttypes.h>  /// for uint16_t

#define MAX 20
#define INF 999

/**
 * @brief Finds index of minimum element in edge list for an arbitrary vertex
 * @param arr graph row
 * @param N number of elements in arr
 * @returns index of minimum element in arr
 */
uint16_t minimum(uint16_t arr[], uint16_t N)
{
    uint16_t index = 0;
    uint16_t min = INF;

    for (uint16_t i = 0; i < N; i++)
    {
        if (arr[i] < min)
        {
            min = arr[i];
            index = i;
        }
    }
    return index;
}

/**
 * @brief Used to find MST of user-generated adj matrix G
 * @returns void
 */
void prim(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)
{
    uint16_t u, v;
    uint16_t E_t[MAX], path[MAX];
    uint16_t V_t[MAX], no_of_edges;

    E_t[0] = 0;  // edges for current vertex
    V_t[0] = 1;  // list of visited vertices

    for (uint16_t i = 1; i < V; i++)
    {
        E_t[i] = G[i][0];
        path[i] = 0;
        V_t[i] = 0;
    }

    no_of_edges = V - 1;

    while (no_of_edges > 0)
    {
        u = minimum(E_t, V);
        while (V_t[u] == 1)
        {
            E_t[u] = INF;
            u = minimum(E_t, V);
        }

        v = path[u];
        MST[v][u] = E_t[u];
        MST[u][v] = E_t[u];
        no_of_edges--;
        V_t[u] = 1;

        for (uint16_t i = 1; i < V; i++)
        {
            if (V_t[i] == 0 && G[u][i] < E_t[i])
            {
                E_t[i] = G[u][i];
                path[i] = v;
            }
        }
    }
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)
{
 
  uint16_t test[4][4] = {{0,1,2,3},{1,0,4,6},{2,4,0,5},{3,6,5,0}};
  uint16_t solution[4][4] = {{0,1,2,3},{1,0,0,0},{2,0,0,0},{3,0,0,0}};

  V = 4;

  for(uint16_t i = 0; i < V; ++i)
  {
    for(uint16_t j = 0; j < V; ++j)
    {
      G[i][j] = test[i][j];
    }
  }

  prim(&(*G),&(*MST),V);

  for(uint16_t i = 0; i < V; ++i)
  {
    for(uint16_t j = 0; j < V; ++j)
    {
      assert(MST[i][j] == solution[i][j]);
    }
  }
}

/**
 * @brief Function user_graph();
 * gets user input adj. matrix and finds MST of that graph
 * @returns void
 */
void user_graph(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)
{
      printf("Enter the number of vertices: ");
      scanf(" %hd", &V);

      assert(V <= MAX);

      printf("Enter the adj matrix\n");
      uint16_t i, j;
      for (i = 0; i < V; ++i)
      {
          for (j = 0; j < V; ++j)
          {
              printf("G[%d][%d]: ", i, j);
              scanf(" %hd", &G[i][j]);
              if (G[i][j] == 0)
                  G[i][j] = INF;
          }
      }

      prim(&(*G),&(*MST),V);

      printf("minimum spanning tree:\n");
      for (i = 0; i < V; ++i)
      {
          printf("\n");
          for (j = 0; j < V; ++j)
          {
              printf("%d\t", MST[i][j]);
          }
      }
}


/**
 * @brief Main function
 * @param argc commandline argument count (ignored)
 * @param argv commandline array of arguments (ignored)
 * @returns 0 on exit
 */
int main(int argc, char const *argv[])
{   

    uint16_t G[MAX][MAX];    ///< weighted, connected graph G
    uint16_t MST[MAX][MAX];  ///< adj matrix to hold minimum spanning tree of G
    uint16_t V;              ///< number of vertices in V in G


    if(argc == 2 && strcmp(argv[1],"-test") == 0)
    {
      test(&(*G),&(*MST),V);
    }
    else
    {
      user_graph(&(*G),&(*MST),V);
    }

    return 0;
}
