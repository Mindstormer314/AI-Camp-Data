const CHAR_SIZE = 8


function pad (str, bits) {
  let res = str
  while (res.length % bits !== 0) {
    res = '0' + res
  }
  return res
}


function chunkify (str, size) {
  const chunks = []
  for (let i = 0; i < str.length; i += size) {
    chunks.push(str.slice(i, i + size))
  }
  return chunks
}


function rotateLeft (bits, turns) {
  return bits.substr(turns) + bits.substr(0, turns)
}


function preProcess (message) {
      let m = message.split('')
    .map(e => e.charCodeAt(0))
    .map(e => e.toString(2))
    .map(e => pad(e, 8))
    .join('') + '1'

    while (m.length % 512 !== 448) {
    m += '0'
  }

      let ml = (message.length * CHAR_SIZE).toString(2)
  ml = pad(ml, 8)
  ml = '0'.repeat(64 - ml.length) + ml

  return m + ml
}


function SHA1 (message) {
    let H0 = 0x67452301
  let H1 = 0xEFCDAB89
  let H2 = 0x98BADCFE
  let H3 = 0x10325476
  let H4 = 0xC3D2E1F0

    const bits = preProcess(message)
  const chunks = chunkify(bits, 512)

  chunks.forEach(function (chunk, i) {
        const words = chunkify(chunk, 32)

        for (let i = 16; i < 80; i++) {
      const val = [words[i - 3], words[i - 8], words[i - 14], words[i - 16]]
        .map(e => parseInt(e, 2))
        .reduce((acc, curr) => curr ^ acc, 0)
      const bin = (val >>> 0).toString(2)
      const paddedBin = pad(bin, 32)
      const word = rotateLeft(paddedBin, 1)
      words.push(word)
    }

        let [a, b, c, d, e] = [H0, H1, H2, H3, H4]

    for (let i = 0; i < 80; i++) {
      let f, k
      if (i < 20) {
        f = (b & c) | (~b & d)
        k = 0x5A827999
      } else if (i < 40) {
        f = b ^ c ^ d
        k = 0x6ED9EBA1
      } else if (i < 60) {
        f = (b & c) | (b & d) | (c & d)
        k = 0x8F1BBCDC
      } else {
        f = b ^ c ^ d
        k = 0xCA62C1D6
      }
            f >>>= 0

      const aRot = rotateLeft(pad(a.toString(2), 32), 5)
      const aInt = parseInt(aRot, 2) >>> 0
      const wordInt = parseInt(words[i], 2) >>> 0
      const t = aInt + f + e + k + wordInt
      e = d >>> 0
      d = c >>> 0
      const bRot = rotateLeft(pad(b.toString(2), 32), 30)
      c = parseInt(bRot, 2) >>> 0
      b = a >>> 0
      a = t >>> 0
    }

        H0 = (H0 + a) >>> 0
    H1 = (H1 + b) >>> 0
    H2 = (H2 + c) >>> 0
    H3 = (H3 + d) >>> 0
    H4 = (H4 + e) >>> 0
  })

    const HH = [H0, H1, H2, H3, H4]
    .map(e => e.toString(16))
    .map(e => pad(e, 8))
    .join('')

  return HH
}

export { SHA1 }

const CHAR_SIZE = 8

const K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]


function pad (str, bits) {
  let res = str
  while (res.length % bits !== 0) {
    res = '0' + res
  }
  return res
}


function chunkify (str, size) {
  const chunks = []
  for (let i = 0; i < str.length; i += size) {
    chunks.push(str.slice(i, i + size))
  }
  return chunks
}


function rotateRight (bits, turns) {
  return bits.substr(bits.length - turns) + bits.substr(0, bits.length - turns)
}


function preProcess (message) {
      let m = message.split('')
    .map(e => e.charCodeAt(0))
    .map(e => e.toString(2))
    .map(e => pad(e, 8))
    .join('') + '1'

    while (m.length % 512 !== 448) {
    m += '0'
  }

      let ml = (message.length * CHAR_SIZE).toString(2)
  ml = pad(ml, 8)
  ml = '0'.repeat(64 - ml.length) + ml

  return m + ml
}


function SHA256 (message) {
    let H0 = 0x6a09e667
  let H1 = 0xbb67ae85
  let H2 = 0x3c6ef372
  let H3 = 0xa54ff53a
  let H4 = 0x510e527f
  let H5 = 0x9b05688c
  let H6 = 0x1f83d9ab
  let H7 = 0x5be0cd19

    const bits = preProcess(message)
  const chunks = chunkify(bits, 512)

  chunks.forEach(function (chunk, i) {
        const words = chunkify(chunk, 32)

        for (let i = 16; i < 64; i++) {
      const W1 = words[i - 15]
      const W2 = words[i - 2]
      const R1 = rotateRight(W1, 7)
      const R2 = rotateRight(W1, 18)
      const R3 = rotateRight(W2, 17)
      const R4 = rotateRight(W2, 19)
      const S0 = parseInt(R1, 2) ^ parseInt(R2, 2) ^ (parseInt(W1, 2) >>> 3)
      const S1 = parseInt(R3, 2) ^ parseInt(R4, 2) ^ (parseInt(W2, 2) >>> 10)
      const val = parseInt(words[i - 16], 2) + S0 + parseInt(words[i - 7], 2) + S1
      words[i] = pad((val >>> 0).toString(2), 32)
    }

        let [a, b, c, d, e, f, g, h] = [H0, H1, H2, H3, H4, H5, H6, H7]

    for (let i = 0; i < 64; i++) {
      const S1 = [6, 11, 25]
        .map(turns => rotateRight(pad(e.toString(2), 32), turns))
        .map(bitstring => parseInt(bitstring, 2))
        .reduce((acc, curr) => acc ^ curr, 0) >>> 0
      const CH = ((e & f) ^ (~e & g)) >>> 0
      const temp1 = (h + S1 + CH + K[i] + parseInt(words[i], 2)) >>> 0
      const S0 = [2, 13, 22]
        .map(turns => rotateRight(pad(a.toString(2), 32), turns))
        .map(bitstring => parseInt(bitstring, 2))
        .reduce((acc, curr) => acc ^ curr, 0) >>> 0
      const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0
      const temp2 = (S0 + maj) >>> 0

      h = g
      g = f
      f = e
      e = (d + temp1) >>> 0
      d = c
      c = b
      b = a
      a = (temp1 + temp2) >>> 0
    }

        H0 = (H0 + a) >>> 0
    H1 = (H1 + b) >>> 0
    H2 = (H2 + c) >>> 0
    H3 = (H3 + d) >>> 0
    H4 = (H4 + e) >>> 0
    H5 = (H5 + f) >>> 0
    H6 = (H6 + g) >>> 0
    H7 = (H7 + h) >>> 0
  })

    const HH = [H0, H1, H2, H3, H4, H5, H6, H7]
    .map(e => e.toString(16))
    .map(e => pad(e, 8))
    .join('')

  return HH
}

export { SHA256 }

'use strict'


let utils;
(function (_utils) {
  function comparator () {
    return function (v1, v2) {
      if (v1 < v2) return -1
      if (v2 < v1) return 1
      return 0
    }
  }
  _utils.comparator = comparator
})(utils || (utils = {}))


const AVLTree = (function () {
  function _avl (comp) {
    /
    this._comp = undefined
    this._comp = comp !== undefined ? comp : utils.comparator()

    /
    this.root = null
    /
    this.size = 0
  }

    const Node = function (val) {
    this._val = val
    this._left = null
    this._right = null
    this._height = 1
  }

    const getHeight = function (node) {
    if (node == null) { return 0 }
    return node._height
  }

    const getHeightDifference = function (node) {
    return node == null ? 0 : getHeight(node._left) - getHeight(node._right)
  }

    const updateHeight = function (node) {
    if (node == null) { return }
    node._height = Math.max(getHeight(node._left), getHeight(node._right)) + 1
  }

    const isValidBalanceFactor = (balanceFactor) => [0, 1, -1].includes(balanceFactor)

    const leftRotate = function (node) {
    const temp = node._right
    node._right = temp._left
    temp._left = node
    updateHeight(node)
    updateHeight(temp)
    return temp
  }
  const rightRotate = function (node) {
    const temp = node._left
    node._left = temp._right
    temp._right = node
    updateHeight(node)
    updateHeight(temp)
    return temp
  }

    const insertBalance = function (node, _val, balanceFactor) {
    if (balanceFactor > 1 && _val < node._left._val) {
      return rightRotate(node)     }
    if (balanceFactor < 1 && _val > node._right._val) {
      return leftRotate(node)     }
    if (balanceFactor > 1 && _val > node._left._val) {
      node._left = leftRotate(node._left)       return rightRotate(node)
    }
    node._right = rightRotate(node._right)
    return leftRotate(node)
  }

    const delBalance = function (node) {
    const balanceFactor1 = getHeightDifference(node)
    if (isValidBalanceFactor(balanceFactor1)) {
      return node
    }
    if (balanceFactor1 > 1) {
      if (getHeightDifference(node._left) >= 0) {
        return rightRotate(node)       }
      node._left = leftRotate(node._left)
      return rightRotate(node)     }
    if (getHeightDifference(node._right) > 0) {
      node._right = rightRotate(node._right)
      return leftRotate(node)     }
    return leftRotate(node)   }

    const insert = function (root, val, tree) {
    if (root == null) {
      tree.size++
      return new Node(val)
    }
    if (tree._comp(root._val, val) < 0) {
      root._right = insert(root._right, val, tree)
    } else if (tree._comp(root._val, val) > 0) {
      root._left = insert(root._left, val, tree)
    } else {
      return root
    }
    updateHeight(root)
    const balanceFactor = getHeightDifference(root)
    return isValidBalanceFactor(balanceFactor) ? root : insertBalance(root, val, balanceFactor)
  }

    const deleteElement = function (root, _val, tree) {
    if (root == null) { return root }
    if (tree._comp(root._val, _val) === 0) {       if (root._left === null && root._right === null) {
        root = null
        tree.size--
      } else if (root._left === null) {
        root = root._right
        tree.size--
      } else if (root._right === null) {
        root = root._left
        tree.size--
      } else {
        let temp = root._right
        while (temp._left != null) {
          temp = temp._left
        }
        root._val = temp._val
        root._right = deleteElement(root._right, temp._val, tree)
      }
    } else {
      if (tree._comp(root._val, _val) < 0) {
        root._right = deleteElement(root._right, _val, tree)
      } else {
        root._left = deleteElement(root._left, _val, tree)
      }
    }
    updateHeight(root)
    root = delBalance(root)
    return root
  }
    const searchAVLTree = function (root, val, tree) {
    if (root == null) { return null }
    if (tree._comp(root._val, val) === 0) {
      return root
    }
    if (tree._comp(root._val, val) < 0) {
      return searchAVLTree(root._right, val, tree)
    }
    return searchAVLTree(root._left, val, tree)
  }

  /
  /
  _avl.prototype.add = function (_val) {
    const prevSize = this.size
    this.root = insert(this.root, _val, this)
    return this.size !== prevSize
  }
  /
  _avl.prototype.find = function (_val) {
    const temp = searchAVLTree(this.root, _val, this)
    return temp != null
  }
  /
  _avl.prototype.remove = function (_val) {
    const prevSize = this.size
    this.root = deleteElement(this.root, _val, this)
    return prevSize !== this.size
  }
  return _avl
}())



export { AVLTree }
/

const Node = (function Node () {
    function Node (val) {
    this.value = val
    this.left = null
    this.right = null
  }

    Node.prototype.search = function (val) {
    if (this.value === val) {
      return this
    } else if (val < this.value && this.left !== null) {
      return this.left.search(val)
    } else if (val > this.value && this.right !== null) {
      return this.right.search(val)
    }
    return null
  }

    Node.prototype.visit = function (output = value => console.log(value)) {
        if (this.left !== null) {
      this.left.visit()
    }
        output(this.value)
        if (this.right !== null) {
      this.right.visit()
    }
  }

    Node.prototype.addNode = function (n) {
    if (n.value < this.value) {
      if (this.left === null) {
        this.left = n
      } else {
        this.left.addNode(n)
      }
    } else if (n.value > this.value) {
      if (this.right === null) {
        this.right = n
      } else {
        this.right.addNode(n)
      }
    }
  }

    Node.prototype.removeNode = function (val) {
    if (val === this.value) {
      if (!this.left && !this.right) {
        return null
      } else {
        if (this.left) {
          const leftMax = maxVal(this.left)
          this.value = leftMax
          this.left = this.left.removeNode(leftMax)
        } else {
          const rightMin = minVal(this.right)
          this.value = rightMin
          this.right = this.right.removeNode(rightMin)
        }
      }
    } else if (val < this.value) {
      this.left = this.left && this.left.removeNode(val)
    } else if (val > this.value) {
      this.right = this.right && this.right.removeNode(val)
    }
    return this
  }

    const maxVal = function (node) {
    if (!node.right) {
      return node.value
    }
    return maxVal(node.right)
  }

    const minVal = function (node) {
    if (!node.left) {
      return node.value
    }
    return minVal(node.left)
  }
    return Node
}())

const Tree = (function () {
  function Tree () {
        this.root = null
  };

    Tree.prototype.traverse = function () {
    if (!this.root) {
            return
    }
    this.root.visit()
  }

    Tree.prototype.search = function (val) {
    const found = this.root.search(val)
    if (found !== null) {
      return found.value
    }
        return null
  }

    Tree.prototype.addValue = function (val) {
    const n = new Node(val)
    if (this.root === null) {
      this.root = n
    } else {
      this.root.addNode(n)
    }
  }

    Tree.prototype.removeValue = function (val) {
        this.root = this.root && this.root.removeNode(val)
  }

    return Tree
}())

export { Tree }
import { AVLTree } from '../AVLTree'

describe('AVLTree Implementation: ', () => {
  const avlTree = new AVLTree()
  const dataList = []
  const demoData = [1, 4, 6, 22, 7, 99, 4, 66, 77, 98]

  beforeAll(() => {
    demoData.forEach(item => {
      if (avlTree.add(item)) {
        dataList.push(item)
      }
    })
  })

  it('checks if element is inserted properly', () => {
    expect(dataList.length).toEqual(avlTree.size)
  })

  it('search if inserted element is present', () => {
    demoData.forEach(data => {
      expect(avlTree.find(data)).toBeTruthy()
    })
  })

  it('deletes the inserted element', () => {
    const deleteElement = dataList[3]
    expect(avlTree.remove(deleteElement)).toBeTruthy()
  })
})
const TrieNode = function TrieNode (key, parent) {
  this.key = key
  this.count = 0
  this.children = Object.create(null)
  if (parent === undefined) {
    this.parent = null
  } else {
    this.parent = parent
  }
}

function Trie () {
    this.root = new TrieNode(null, null)
}

Trie.findAllWords = function (root, word, output) {
  if (root === null) return
  if (root.count > 0) {
    if (typeof output === 'object') { output.push({ word, count: root.count }) }
  }
  let key
  for (key in root.children) {
    word += key
    this.findAllWords(root.children[key], word, output)
    word = word.slice(0, -1)
  }
}

Trie.prototype.insert = function (word) {
  if (typeof word !== 'string') return
  if (word === '') {
    this.root.count += 1
    return
  }
  let node = this.root
  const len = word.length
  let i
  for (i = 0; i < len; i++) {
    if (node.children[word.charAt(i)] === undefined) { node.children[word.charAt(i)] = new TrieNode(word.charAt(i), node) }
    node = node.children[word.charAt(i)]
  }
  node.count += 1
}

Trie.prototype.findPrefix = function (word) {
  if (typeof word !== 'string') return null
  let node = this.root
  const len = word.length
  let i
    for (i = 0; i < len; i++) {
    if (node.children[word.charAt(i)] === undefined) return null     node = node.children[word.charAt(i)]
  }
  return node
}

Trie.prototype.remove = function (word, count) {
  if (typeof word !== 'string') return
  if (typeof count !== 'number') count = 1
  else if (count <= 0) return

    if (word === '') {
    if (this.root.count >= count) this.root.count -= count
    else this.root.count = 0
    return
  }

  let child = this.root
  const len = word.length
  let i, key
    for (i = 0; i < len; i++) {
    key = word.charAt(i)
    if (child.children[key] === undefined) return
    child = child.children[key]
  }

    if (child.count >= count) child.count -= count
  else child.count = 0

          if (child.count <= 0 && (Object.keys(child.children).length && child.children.constructor === Object)) {
    child.parent.children[child.key] = undefined
  }
}

Trie.prototype.findAllWords = function (prefix) {
  const output = []
    const node = this.findPrefix(prefix)
    if (node === null) return output
  Trie.findAllWords(node, prefix, output)
  return output
}

Trie.prototype.contains = function (word) {
    const node = this.findPrefix(word)
    if (node === null || node.count === 0) return false
  return true
}

Trie.prototype.findOccurences = function (word) {
    const node = this.findPrefix(word)
    if (node === null) return 0
  return node.count
}

export { Trie }
import { DoubleLinkedList } from '../DoublyLinkedList'

describe('DoubleLinkedList', () => {
  it('Check append', () => {
    const list = new DoubleLinkedList()

    list.append(1)
    expect(list.getHead().element).toEqual(1)

    list.append(2)
    expect(list.getTail().element).toEqual(2)
  })

  it('Check insert', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 1)
    expect(list.getHead().element).toEqual(1)

    list.insert(1, 20)
    expect(list.getTail().element).toEqual(20)
  })

  it('Check removeAt', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 10)
    list.insert(1, 40)
    list.insert(2, 30)

    list.removeAt(0)
    expect(list.getHead().element).toEqual(40)

    list.removeAt(1)
    expect(list.getTail().element).toEqual(40)
  })

  it('Check delete', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 10)
    list.insert(1, 40)

    list.delete(10)
    expect(list.getHead().element).toEqual(40)
  })

  it('Check deleteTail', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 10)
    list.insert(1, 40)

    list.deleteTail()
    expect(list.getTail().element).toEqual(10)
  })

  it('Check toString', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 20)
    expect(list.toString()).toEqual('20')
  })

  it('Check isEmpty', () => {
    const list = new DoubleLinkedList()

    expect(list.isEmpty()).toEqual(true)

    list.insert(0, 'Hello')
    expect(list.isEmpty()).toEqual(false)
  })

  it('Check size', () => {
    const list = new DoubleLinkedList()
    expect(list.size()).toBe(0)

    list.append(10)
    expect(list.size()).toBe(1)

    list.removeAt(1)
    expect(list.size()).toBe(1)
  })

  it('Check toArray', () => {
    const list = new DoubleLinkedList()
    list.append(1)
    list.append(2)

    const listArray = list.toArray()
    expect(listArray).toEqual([1, 2])
  })

  it('Check getHead', () => {
    const list = new DoubleLinkedList()
    expect(list.getHead()).toEqual(null)

    list.append(1)
    list.append(2)
    expect(list.getHead()).toBeInstanceOf(Object)
  })

  it('Check Iterator', () => {
    const list = new DoubleLinkedList()

    let iterate = list.iterator()
    expect(iterate).toBe(-1)

    const arr = [10, 20, 5]
    list.append(arr[0])
    list.append(arr[1])
    list.append(arr[2])
    iterate = list.iterator()

    for (let i = 0; i < arr.length; i++) {
      expect(iterate.next().value).toBe(arr[i])
    }
    expect(iterate.next().value).toBe(undefined)

    iterate = list.iterator()
    let count = 0
    for (const item of iterate) {
      expect(item).toBe(arr[count])
      count++
    }
  })
})
import { SinglyCircularLinkedList } from '../SinglyCircularLinkedList'

describe('SinglyCircularLinkedList', () => {
  let list
  beforeEach(() => {
    list = new SinglyCircularLinkedList()
  })
  it('Check get', () => {
    expect(list.get()).toEqual([])
    expect(list.add(1)).toEqual(1)
    expect(list.get()).toEqual([1])
    expect(list.add(5)).toEqual(2)
    expect(list.get()).toEqual([1, 5])
  })

  it('Check size', () => {
    expect(list.size()).toEqual(0)
    expect(list.add(1)).toEqual(1)
    expect(list.add(1)).toEqual(2)
    expect(list.size()).toEqual(2)
  })

  it('Check head', () => {
    expect(list.head()).toEqual(null)
    expect(list.add(1)).toEqual(1)
    expect(list.head()).toEqual(1)
    expect(list.add(1)).toEqual(2)
    expect(list.head()).toEqual(1)
    expect(list.addAtFirst(100)).toEqual(3)
    expect(list.head()).toEqual(100)
    expect(list.insertAt(0, 500)).toEqual(4)
    expect(list.head()).toEqual(500)
    list.clear()
    expect(list.head()).toEqual(null)
  })

  it('Check isEmpty', () => {
    expect(list.isEmpty()).toEqual(true)
    expect(list.add(1)).toEqual(1)
    expect(list.add(1)).toEqual(2)
    expect(list.isEmpty()).toEqual(false)
  })

  it('Check getElementAt', () => {
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)

    expect(list.getElementAt(1).data).toEqual(200)
    expect(list.getElementAt(3).data).toEqual(500)
  })

  it('Check addAtFirst', () => {
    list.add(1)
    list.add(5)
    list.add(7)
    list.add(9)
    list.add(0)
    expect(list.get()).toEqual([1, 5, 7, 9, 0])
    list.addAtFirst(100)
    expect(list.get()).toEqual([100, 1, 5, 7, 9, 0])
  })

  it('Check add', () => {
    list.add(1)
    list.add(5)
    list.add(7)
    list.add(9)
    list.add(0)
    expect(list.get()).toEqual([1, 5, 7, 9, 0])
    list.add(100)
    expect(list.get()).toEqual([1, 5, 7, 9, 0, 100])
  })

  it('Check insertAt', () => {
    expect(list.insertAt(0, 100)).toEqual(1)
    expect(list.get()).toEqual([100])
    expect(list.insertAt(0, 200)).toEqual(2)
    expect(list.get()).toEqual([200, 100])
    expect(list.insertAt(2, 300)).toEqual(3)
    expect(list.get()).toEqual([200, 100, 300])
  })

  it('Checks indexOf', () => {
    expect(list.indexOf(200)).toEqual(-1)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.indexOf(200)).toEqual(1)
  })

  it('Check remove', () => {
    expect(list.remove()).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.remove()
    expect(removedData).toEqual(900)
    expect(list.get()).toEqual([100, 200, 300, 500])
  })

  it('Check removeFirst', () => {
    expect(list.removeFirst()).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.removeFirst()
    expect(removedData).toEqual(100)
    expect(list.get()).toEqual([200, 300, 500, 900])
  })

  it('Check removeAt', () => {
    expect(list.removeAt(1)).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.removeAt(2)
    expect(removedData).toEqual(300)
    expect(list.get()).toEqual([100, 200, 500, 900])
  })

  it('Check removeData', () => {
    expect(list.removeData(100)).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.removeData(200)
    expect(removedData).toEqual(200)
    expect(list.get()).toEqual([100, 300, 500, 900])
  })
})
import { AddTwoNumbers } from '../AddTwoNumbers.js'
import { LinkedList } from '../SinglyLinkedList'

describe('AddTwoNumbers', () => {
  it('Check Sum Of Two Linked List', () => {
    const list1 = new LinkedList()
    list1.addFirst(2)
    list1.addLast(4)
    list1.addLast(3)

    const list2 = new LinkedList()
    list2.addFirst(5)
    list2.addLast(6)
    list2.addLast(4)

    const expected = new LinkedList()
    expected.addFirst(7)
    expected.addLast(0)
    expected.addLast(8)

    const addTwoLinkedList = new AddTwoNumbers()
    addTwoLinkedList.solution(list1.headNode, list2.headNode)

    expect(addTwoLinkedList.solutionToArray()).toEqual(expected.get())
  })
})
import { LinkedList } from '../SinglyLinkedList'

describe('SinglyLinkedList', () => {
  it('Check addLast', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    expect(list.addLast(1)).toEqual(1)
    expect(list.get()).toEqual([1])

    expect(list.addLast(5)).toEqual(2)
    expect(list.get()).toEqual([1, 5])
  })

  it('Check addFirst', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    expect(list.addFirst(1)).toEqual(1)
    expect(list.get()).toEqual([1])

    expect(list.addFirst(5)).toEqual(2)
    expect(list.get()).toEqual([5, 1])
  })

  it('Check addAt', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    expect(list.addAt(0, 10)).toEqual(1)
    expect(list.get()).toEqual([10])

    expect(list.addAt(1, 20)).toEqual(2)
    expect(list.get()).toEqual([10, 20])

    expect(list.addAt(1, 30)).toEqual(3)
    expect(list.get()).toEqual([10, 30, 20])

    expect(list.addAt(3, 40)).toEqual(4)
    expect(list.get()).toEqual([10, 30, 20, 40])
  })

  it('Check removeLast', () => {
    const list = new LinkedList()
    list.addLast(1)
    list.addLast(2)
    expect(list.get()).toEqual([1, 2])

    expect(list.removeLast()).toEqual(2)
    expect(list.get()).toEqual([1])

    expect(list.removeLast()).toEqual(1)
    expect(list.get()).toEqual([])
  })

  it('Check removeFirst', () => {
    const list = new LinkedList()
    list.addLast(1)
    list.addLast(2)
    expect(list.get()).toEqual([1, 2])

    expect(list.removeFirst()).toEqual(1)
    expect(list.get()).toEqual([2])

    expect(list.removeFirst()).toEqual(2)
    expect(list.get()).toEqual([])
  })

  it('Check removeAt', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.get()).toEqual([10, 20, 30, 40, 50])

    expect(list.removeAt(0)).toEqual(10)
    expect(list.get()).toEqual([20, 30, 40, 50])

    expect(list.removeAt(3)).toEqual(50)
    expect(list.get()).toEqual([20, 30, 40])

    expect(list.removeAt(1)).toEqual(30)
    expect(list.get()).toEqual([20, 40])
  })

  it('Check remove', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    expect(list.get()).toEqual([10, 20, 30])

    expect(list.remove(10)).toEqual(10)
    expect(list.get()).toEqual([20, 30])

    expect(list.remove(100)).toEqual(null)
    expect(list.get()).toEqual([20, 30])
  })

  it('Check indexOf', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.indexOf(10)).toBe(0)
    expect(list.indexOf(30)).toBe(2)
    expect(list.indexOf(50)).toBe(4)
    expect(list.indexOf(70)).toBe(-1)
  })

  it('Check elementAt', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.elementAt(0)).toBe(10)
    expect(list.elementAt(1)).toBe(20)
    expect(list.elementAt(3)).toBe(40)
    expect(list.elementAt(4)).toBe(50)
  })

  it('Check isEmpty', () => {
    const list = new LinkedList()
    expect(list.isEmpty()).toBe(true)
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.isEmpty()).toBe(false)
  })

  it('Check head', () => {
    const list = new LinkedList()
    expect(list.head()).toBe(null)

    list.addLast(10)
    expect(list.head()).toBe(10)

    list.addLast(20)
    expect(list.head()).toBe(10)

    list.addFirst(30)
    expect(list.head()).toBe(30)
  })

  it('Check size', () => {
    const list = new LinkedList()
    expect(list.size()).toBe(0)

    list.addLast(10)
    expect(list.size()).toBe(1)

    list.addLast(20)
    expect(list.size()).toBe(2)

    list.removeFirst()
    expect(list.size()).toBe(1)
  })

  it('Check Iterator', () => {
    const list = new LinkedList()

    let iterate = list.iterator()
    expect(iterate).toBe(-1)

    const arr = [10, 20, 5]
    list.addLast(arr[0])
    list.addLast(arr[1])
    list.addLast(arr[2])
    iterate = list.iterator()

    for (let i = 0; i < arr.length; i++) {
      expect(iterate.next().value).toBe(arr[i])
    }
    expect(iterate.next().value).toBe(undefined)

    iterate = list.iterator()
    let count = 0
    for (const item of iterate) {
      expect(item).toBe(arr[count])
      count++
    }
  })
  it('Cleans the linkedList', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.size()).toEqual(5)
    list.clean()
    expect(list.isEmpty()).toBe(true)
  })
})
import { Node } from './SinglyLinkedList.js'

class SinglyCircularLinkedList {
  constructor () {
    this.headNode = null
    this.length = 0
  }

    size = () => this.length
    head = () => this.headNode?.data || null
    isEmpty = () => this.length === 0

    initiateNodeAndIndex () {
    return { currentNode: this.headNode, currentIndex: 0 }
  }

    getElementAt (index) {
    if (this.length !== 0 && index >= 0 && index <= this.length) {
      let { currentNode } = this.initiateNodeAndIndex()
      for (let i = 0; i < index && currentNode !== null; i++) {
        currentNode = currentNode.next
      }
      return currentNode
    }
    return undefined
  }

    addAtFirst (data) {
    const node = new Node(data)
    node.next = this.headNode
    this.headNode = node
    this.length++
    return this.length
  }

    add (data) {
    if (!this.headNode) { return this.addAtFirst(data) }
    const node = new Node(data)
        const currentNode = this.getElementAt(this.length - 1)
    currentNode.next = node
    node.next = this.headNode
    this.length++
    return this.length
  }

    insertAt (index, data) {
    if (index === 0) return this.addAtFirst(data)
    if (index === this.length) return this.add(data)
    if (index < 0 || index > this.length) throw new RangeError(`Index is out of range max ${this.length}`)
    const node = new Node(data)
    const previousNode = this.getElementAt(index - 1)
    node.next = previousNode.next
    previousNode.next = node
    this.length++
    return this.length
  }

    indexOf (data) {
    let { currentNode } = this.initiateNodeAndIndex()
        let currentIndex = -1
    while (currentNode) {
      if (currentNode.data === data) {
        return currentIndex + 1
      }
      currentIndex++
      currentNode = currentNode.next
    }
    return -1
  }

    remove () {
    if (this.isEmpty()) return null
    const secondLastNode = this.getElementAt(this.length - 2)
    const removedNode = secondLastNode.next
    secondLastNode.next = this.headNode
    this.length--
    return removedNode.data || null
  }

    removeFirst () {
    if (this.isEmpty()) return null
    const removedNode = this.headNode
    if (this.length === 1) {
      this.clear()
      return removedNode.data
    }
    const lastNode = this.getElementAt(this.length - 1)
    this.headNode = this.headNode.next
    lastNode.next = this.headNode
    this.length--
    return removedNode.data || null
  }

    removeAt (index) {
    if (this.isEmpty()) return null
    if (index === 0) return this.removeFirst()
    if (index === this.length) return this.remove()
    if (index < 0 && index > this.length) return null
    const previousNode = this.getElementAt(index - 1)
    const currentNode = previousNode.next
    previousNode.next = currentNode.next
    this.length--
    return currentNode.data || null
  }

    removeData (data) {
    if (this.isEmpty()) return null
    const index = this.indexOf(data)
    return this.removeAt(index)
  }

    printData (output = value => console.log(value)) {
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()

    while (currentNode !== null && currentIndex < this.length) {
      output(currentNode.data)
      currentNode = currentNode.next
      currentIndex++
    }
  }

    get () {
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    const list = []
    while (currentNode !== null && currentIndex < this.length) {
      list.push(currentNode.data)
      currentNode = currentNode.next
      currentIndex++
    }
    return list
  }

  clear () {
    this.headNode = null
    this.length = 0
  }
}

export { SinglyCircularLinkedList }

import { Node } from './SinglyLinkedList.js'

/

class AddTwoNumbers {
  constructor () {
    this.dummyNode = new Node(0)
  }

  solution (firstList, secondList) {
    let firstRunner = firstList
    let secondRunner = secondList
    let tail = this.dummyNode
    let carry = 0
    while (firstRunner != null || secondRunner != null) {
      const firstNumber = firstRunner ? firstRunner.data : 0
      const secondNumber = secondRunner ? secondRunner.data : 0
      const sum = carry + firstNumber + secondNumber
      carry = parseInt(sum / 10)
      tail.next = new Node(sum % 10)
      tail = tail.next
      if (firstRunner) {
        firstRunner = firstRunner.next
      }
      if (secondRunner) {
        secondRunner = secondRunner.next
      }
    }
    if (carry > 0) {
      tail.next = new Node(carry % 10)
    }

    return this.dummyNode.next
  }

  solutionToArray () {
    const list = []
    let currentNode = this.dummyNode.next
    while (currentNode) {
      list.push(currentNode.data)
      currentNode = currentNode.next
    }

    return list
  }
}

export { AddTwoNumbers }


function main () {
  /
  const head = ''   let fast = head
  let slow = head

  while (fast != null && fast.next != null && slow != null) {
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) {
      return true
    }
  }
  return false
}

main()
class Node {
  constructor (element) {
    this.element = element
    this.next = null
    this.prev = null
  }
}

class DoubleLinkedList {
  constructor () {
    this.length = 0
    this.head = null
    this.tail = null
  }

    append (element) {
    const node = new Node(element)

    if (!this.head) {
      this.head = node
      this.tail = node
    } else {
      node.prev = this.tail
      this.tail.next = node
      this.tail = node
    }

    this.length++
  }

    insert (position, element) {
        if (position >= 0 && position <= this.length) {
      const node = new Node(element)
      let current = this.head
      let previous = 0
      let index = 0

      if (position === 0) {
        if (!this.head) {
          this.head = node
          this.tail = node
        } else {
          node.next = current
          current.prev = node
          this.head = node
        }
      } else if (position === this.length) {
        current = this.tail
        current.next = node
        node.prev = current
        this.tail = node
      } else {
        while (index++ < position) {
          previous = current
          current = current.next
        }

        node.next = current
        previous.next = node

                current.prev = node
        node.prev = previous
      }

      this.length++
      return true
    } else {
      return false
    }
  }

    removeAt (position) {
        if (position > -1 && position < this.length) {
      let current = this.head
      let previous = 0
      let index = 0

            if (position === 0) {
        this.head = current.next

                if (this.length === 1) {
          this.tail = null
        } else {
          this.head.prev = null
        }
      } else if (position === this.length - 1) {
        current = this.tail
        this.tail = current.prev
        this.tail.next = null
      } else {
        while (index++ < position) {
          previous = current
          current = current.next
        }

                previous.next = current.next
        current.next.prev = previous
      }

      this.length--
      return current.element
    } else {
      return null
    }
  }

    indexOf (elm) {
    let current = this.head
    let index = -1

        while (current) {
      if (elm === current.element) {
        return ++index
      }

      index++
      current = current.next
    }

        return -1
  }

    isPresent (elm) {
    return this.indexOf(elm) !== -1
  }

    delete (elm) {
    return this.removeAt(this.indexOf(elm))
  }

    deleteHead () {
    this.removeAt(0)
  }

    deleteTail () {
    this.removeAt(this.length - 1)
  }

    toString () {
    let current = this.head
    let string = ''

    while (current) {
      string += current.element + (current.next ? '\n' : '')
      current = current.next
    }

    return string
  }

    toArray () {
    const arr = []
    let current = this.head

    while (current) {
      arr.push(current.element)
      current = current.next
    }

    return arr
  }

    isEmpty () {
    return this.length === 0
  }

    size () {
    return this.length
  }

    getHead () {
    return this.head
  }

    getTail () {
    return this.tail
  }

    iterator () {
    let currentNode = this.getHead()
    if (currentNode === null) return -1

    const iterate = function * () {
      while (currentNode) {
        yield currentNode.element
        currentNode = currentNode.next
      }
    }
    return iterate()
  }

      log () {
    let currentNode = this.getHead()
    while (currentNode) {
      console.log(currentNode.element)
      currentNode = currentNode.next
    }
  }
}



export { DoubleLinkedList }


function main () {
  /
    let head = ''
  let k = ''
  let i = 0
  let current = head
  while (current) {
    i++
    current = current.next
  }
  k %= i
  current = head
  let prev = null
  while (k--) {
    if (!current || !current.next) {
      return current
    } else {
      while (current.next) {
        prev = current
        current = current.next
      }
      prev.next = current.next
      current.next = head
      head = current
    }
  }
  return head
}

main()
/


class Node {
  constructor (data) {
    this.data = data
    this.next = null
  }
}

class LinkedList {
  constructor () {
    this.headNode = null
    this.length = 0
  }

    initiateNodeAndIndex () {
    return { currentNode: this.headNode, currentIndex: 0 }
  }

    size () {
    return this.length
  }

    head () {
    return this.headNode?.data || null
  }

    isEmpty () {
    return this.length === 0
  }

    addLast (element) {
        if (this.headNode === null) {
      return this.addFirst(element)
    }
    let { currentNode } = this.initiateNodeAndIndex()

        while (currentNode.next) {
      currentNode = currentNode.next
    }

    const node = new Node(element)
        currentNode.next = node
    this.length++
    return this.size()
  }

    addFirst (element) {
    const node = new Node(element)
    node.next = this.headNode
    this.headNode = node
    this.length++
    return this.size()
  }

    removeFirst () {
    const removedNode = this.headNode
    if (this.length > 0) {
      this.headNode = this.headNode.next
      this.length--
    }
    console.log(removedNode.data)
    return removedNode?.data
  }

    removeLast () {
    if (this.isEmpty()) return null
    if (this.length === 1) {
      return this.removeFirst()
    }
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    while (currentIndex !== this.length - 2) {
      currentIndex++
      currentNode = currentNode.next
    }
    const removedNode = currentNode.next
    currentNode.next = null
    this.length--
    return removedNode.data
  }

    remove (element) {
    if (this.isEmpty()) return null
    let { currentNode } = this.initiateNodeAndIndex()
    let removedNode = null
        if (currentNode.data === element) {
      return this.removeFirst()
    }
        while (currentNode?.next) {
      if (currentNode.next.data === element) {
        removedNode = currentNode.next
        currentNode.next = currentNode.next.next
        this.length--
        break
      }
      currentNode = currentNode.next
    }
    return removedNode?.data || null
  }

    indexOf (element) {
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()

    while (currentNode) {
            if (currentNode.data === element) {
        return currentIndex
      }
      currentNode = currentNode.next
      currentIndex++
    }
    return -1
  }

    elementAt (index) {
    if (index >= this.length || index < 0) {
      throw new RangeError('Out of Range index')
    }
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    while (currentIndex < index) {
      currentIndex++
      currentNode = currentNode.next
    }
    return currentNode.data
  }

    addAt (index, element) {
        if (index > this.length || index < 0) {
      throw new RangeError('Out of Range index')
    }
    if (index === 0) return this.addFirst(element)
    if (index === this.length) return this.addLast(element)
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    const node = new Node(element)

    while (currentIndex !== index - 1) {
      currentIndex++
      currentNode = currentNode.next
    }

        const tempNode = currentNode.next
    currentNode.next = node
    node.next = tempNode
        this.length++
    return this.size()
  }

    removeAt (index) {
        if (index < 0 || index >= this.length) {
      throw new RangeError('Out of Range index')
    }
    if (index === 0) return this.removeFirst()
    if (index === this.length) return this.removeLast()

    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    while (currentIndex !== index - 1) {
      currentIndex++
      currentNode = currentNode.next
    }
    const removedNode = currentNode.next
    currentNode.next = currentNode.next.next
        this.length--
    return removedNode.data
  }

    clean () {
    this.headNode = null
    this.length = 0
  }

    get () {
    const list = []
    let { currentNode } = this.initiateNodeAndIndex()
    while (currentNode) {
      list.push(currentNode.data)
      currentNode = currentNode.next
    }

    return list
  }

    iterator () {
    let { currentNode } = this.initiateNodeAndIndex()
    if (currentNode === null) return -1

    const iterate = function * () {
      while (currentNode) {
        yield currentNode.data
        currentNode = currentNode.next
      }
    }
    return iterate()
  }

    log () {
    console.log(JSON.stringify(this.headNode, null, 2))
  }
}

export { Node, LinkedList }
import { QuickSelect } from '../QuickSelect'

describe('QuickSelect tests', () => {
  it('should return the only element of a list of length 1', () => {
        expect(QuickSelect([100], 1)).toEqual(100)
    expect(QuickSelect([-23], 1)).toEqual(-23)
    expect(QuickSelect([2007.102], 1)).toEqual(2007.102)
    expect(QuickSelect([0.9], 1)).toEqual(0.9)
    expect(QuickSelect([-0.075], 1)).toEqual(-0.075)
    expect(QuickSelect([0], 1)).toEqual(0)
    expect(QuickSelect([1], 1)).toEqual(1)
  })

  it('should throw an Error when k is greater than the length of the list', () => {
    expect(() => QuickSelect([100, 2], 5)).toThrow('Index Out of Bound')
  })

  it('should throw an Error when k is less than 1', () => {
    expect(() => QuickSelect([100, 2], 0)).toThrow('Index Out of Bound')
    expect(() => QuickSelect([100, 2], -1)).toThrow('Index Out of Bound')
  })

  describe('varieties of list composition', () => {
    it('should return the kth smallest element of a list that is in increasing order', () => {
      expect(QuickSelect([10, 22, 33, 44, 55], 1)).toEqual(10)
      expect(QuickSelect([10, 22, 33, 44, 55], 2)).toEqual(22)
      expect(QuickSelect([10, 22, 33, 44, 55], 3)).toEqual(33)
      expect(QuickSelect([10, 22, 33, 44, 55], 4)).toEqual(44)
      expect(QuickSelect([10, 22, 33, 44, 55], 5)).toEqual(55)
    })

    it('should return the kth smallest element of an input list that is in decreasing order', () => {
      expect(QuickSelect([82, 33.12, 4.0, 1], 1)).toEqual(1)
      expect(QuickSelect([82, 33.12, 4.0, 1], 2)).toEqual(4.0)
      expect(QuickSelect([82, 33.12, 4.0, 1], 2)).toEqual(4)
      expect(QuickSelect([82, 33.12, 4.0, 1], 3)).toEqual(33.12)
      expect(QuickSelect([82, 33.12, 4.0, 1], 4)).toEqual(82)
    })

    it('should return the kth smallest element of an input list that is no particular order', () => {
      expect(QuickSelect([123, 14231, -10, 0, 15], 3)).toEqual(15)
      expect(QuickSelect([0, 15, 123, 14231, -10], 3)).toEqual(15)
      expect(QuickSelect([-10, 15, 123, 14231, 0], 3)).toEqual(15)
      expect(QuickSelect([14231, 0, 15, 123, -10], 3)).toEqual(15)
      expect(QuickSelect([14231, 0, 15, -10, 123], 3)).toEqual(15)
    })
  })
})
import { LocalMaximomPoint } from '../LocalMaximomPoint'

describe('LocalMaximumPoint tests', () => {
  it('test boundary maximum points - last element', () => {
    const Array = [1, 2, 3, 4, 5, 6, 12]
    expect(LocalMaximomPoint(Array)).toEqual(6)
  })

  it('test boundary maximum points - first element', () => {
    const Array2 = [13, 6, 5, 4, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(0)
  })

  it('test boundary maximum points - should find first maximom point from the top', () => {
        const Array = [13, 2, 3, 4, 5, 6, 12]
    expect(LocalMaximomPoint(Array)).toEqual(6)
  })

  it('test inner points - second element', () => {
    const Array2 = [13, 16, 5, 4, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(1)
  })

  it('test inner points - element some where in the middle', () => {
    const Array2 = [13, 16, 5, 41, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(3)
  })
})
import { NumberOfLocalMaximumPoints } from '../NumberOfLocalMaximumPoints'

describe('LocalMaximomPoint tests', () => {
  it('test boundary maximum points - last element', () => {
    const Array = [1, 2, 3, 4, 5, 6, 12]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(1)
  })

  it('test boundary maximum points - first element', () => {
    const Array = [13, 6, 5, 4, 3, 2, 1]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(1)
  })

  it('test boundary maximum points - both boundaries have maximum points', () => {
        const Array = [13, 2, 3, 4, 5, 6, 12]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(2)
  })

  it('multiple maximum points in the middle', () => {
        const Array = [1, 3, 2, 5, 6, 9, 2, 7, 12, 1, 0]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(3)
  })

  it('multiple maximum points in the middle with one at end', () => {
        const Array = [1, 3, 2, 5, 6, 9, 2, 7, 12, 1, 10]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(4)
  })

  it('multiple maximum points in the middle with one at start', () => {
        const Array = [10, 3, 2, 5, 6, 9, 2, 7, 12, 1, 0]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(3)
  })

  it('multiple maximum points in the middle with two more at both ends', () => {
        const Array = [10, 3, 11, 5, 6, 9, 2, 7, 12, 1, 10]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(5)
  })
})

const findMaxPointIndex = (array, rangeStartIndex, rangeEndIndex, originalLength) => {
    const middleIndex = rangeStartIndex + parseInt((rangeEndIndex - rangeStartIndex) / 2)

    if ((middleIndex === 0 || array[middleIndex - 1] <= array[middleIndex]) &&
        (middleIndex === originalLength - 1 || array[middleIndex + 1] <= array[middleIndex])) {
    return middleIndex
  } else if (middleIndex > 0 && array[middleIndex - 1] > array[middleIndex]) {
    return findMaxPointIndex(array, rangeStartIndex, (middleIndex - 1), originalLength)
  } else {
        return findMaxPointIndex(array, (middleIndex + 1), rangeEndIndex, originalLength)
  }
}

const LocalMaximomPoint = (A) => findMaxPointIndex(A, 0, A.length - 1, A.length)

export { LocalMaximomPoint }


const IsMaximumPoint = (array, index) => {
      if (index === 0) {
    return array[index] > array[index + 1]
      } else if (index === array.length - 1) {
    return array[index] > array[index - 1]
      } else {
    return array[index] > array[index + 1] && array[index] > array[index - 1]
  }
}

const CountLocalMaximumPoints = (array, startIndex, endIndex) => {
    if (startIndex === endIndex) {
    return IsMaximumPoint(array, startIndex) ? 1 : 0
  }

    const middleIndex = parseInt((startIndex + endIndex) / 2)
  return CountLocalMaximumPoints(array, startIndex, middleIndex) +
    CountLocalMaximumPoints(array, middleIndex + 1, endIndex)
}

const NumberOfLocalMaximumPoints = (A) => CountLocalMaximumPoints(A, 0, A.length - 1)

export { NumberOfLocalMaximumPoints }


function QuickSelect (items, kth) {   if (kth < 1 || kth > items.length) {
    throw new RangeError('Index Out of Bound')
  }

  return RandomizedSelect(items, 0, items.length - 1, kth)
}

function RandomizedSelect (items, left, right, i) {
  if (left === right) return items[left]

  const pivotIndex = RandomizedPartition(items, left, right)
  const k = pivotIndex - left + 1

  if (i === k) return items[pivotIndex]
  if (i < k) return RandomizedSelect(items, left, pivotIndex - 1, i)

  return RandomizedSelect(items, pivotIndex + 1, right, i - k)
}

function RandomizedPartition (items, left, right) {
  const rand = getRandomInt(left, right)
  Swap(items, rand, right)
  return Partition(items, left, right)
}

function Partition (items, left, right) {
  const x = items[right]
  let pivotIndex = left - 1

  for (let j = left; j < right; j++) {
    if (items[j] <= x) {
      pivotIndex++
      Swap(items, pivotIndex, j)
    }
  }

  Swap(items, pivotIndex + 1, right)

  return pivotIndex + 1
}

function getRandomInt (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

function Swap (arr, x, y) {
  [arr[x], arr[y]] = [arr[y], arr[x]]
}

export { QuickSelect }
class Graph {
  constructor () {
    this.adjacencyMap = {}
  }

  addVertex (vertex) {
    this.adjacencyMap[vertex] = []
  }

  containsVertex (vertex) {
    return typeof (this.adjacencyMap[vertex]) !== 'undefined'
  }

  addEdge (vertex1, vertex2) {
    if (this.containsVertex(vertex1) && this.containsVertex(vertex2)) {
      this.adjacencyMap[vertex1].push(vertex2)
      this.adjacencyMap[vertex2].push(vertex1)
    }
  }

  printGraph (output = value => console.log(value)) {
    const keys = Object.keys(this.adjacencyMap)
    for (const i of keys) {
      const values = this.adjacencyMap[i]
      let vertex = ''
      for (const j of values) {
        vertex += j + ' '
      }
      output(i + ' -> ' + vertex)
    }
  }

  /
  bfs (source, output = value => console.log(value)) {
    const queue = [[source, 0]]     const visited = new Set()

    while (queue.length) {
      const [node, level] = queue.shift()       if (visited.has(node)) {         continue
      }

      visited.add(node)
      output(`Visited node ${node} at level ${level}.`)
      for (const next of this.adjacencyMap[node]) {
        queue.push([next, level + 1])       }
    }
  }

  /
  dfs (source, visited = new Set(), output = value => console.log(value)) {
    if (visited.has(source)) {       return
    }

    output(`Visited node ${source}`)
    visited.add(source)
    for (const neighbour of this.adjacencyMap[source]) {
      this.dfs(neighbour, visited, output)
    }
  }
}

const example = () => {
  const g = new Graph()
  g.addVertex(1)
  g.addVertex(2)
  g.addVertex(3)
  g.addVertex(4)
  g.addVertex(5)
  g.addEdge(1, 2)
  g.addEdge(1, 3)
  g.addEdge(2, 4)
  g.addEdge(2, 5)

            
    
    g.bfs(1)

    g.dfs(1)
}

export { Graph, example }
import { Graph } from '../Graph2'

describe('Test Graph2', () => {
  const vertices = ['A', 'B', 'C', 'D', 'E', 'F']
  const graph = new Graph(vertices.length)

    for (let i = 0; i < vertices.length; i++) {
    graph.addVertex(vertices[i])
  }

    graph.addEdge('A', 'B')
  graph.addEdge('A', 'D')
  graph.addEdge('A', 'E')
  graph.addEdge('B', 'C')
  graph.addEdge('D', 'E')
  graph.addEdge('E', 'F')
  graph.addEdge('E', 'C')
  graph.addEdge('C', 'F')

  it('Check adjacency lists', () => {
    const mockFn = jest.fn()
    graph.printGraph(mockFn)

        expect(mockFn.mock.calls.length).toBe(vertices.length)

        const adjListArr = mockFn.mock.calls.map(v => v[0])

    expect(adjListArr).toEqual([
      'A -> B D E ',
      'B -> A C ',
      'C -> B E F ',
      'D -> A E ',
      'E -> A D F C ',
      'F -> E C '
    ])
  })
})
import { Graph } from '../Graph3'

describe('Test Graph3', () => {
  const g = new Graph()

    g.addVertex('A')
  g.addVertex('B')
  g.addVertex('C')
  g.addVertex('D')
  g.addVertex('E')
  g.addVertex('F')

    g.addEdge('A', 'B')
  g.addEdge('A', 'C')
  g.addEdge('B', 'D')
  g.addEdge('C', 'E')
  g.addEdge('D', 'E')
  g.addEdge('D', 'F')
  g.addEdge('E', 'F')

  /
  it('Check iterative DFS List', () => {
    const iterativeDFSList = g.DFSIterative('A')
    expect(iterativeDFSList).toEqual(['A', 'C', 'E', 'F', 'D', 'B'])
  })

  it('Check recursive DFS List', () => {
    const recursiveDFSList = g.DFS('A')
    expect(recursiveDFSList).toEqual(['A', 'B', 'D', 'E', 'C', 'F'])
  })

  it('Check BFS List', () => {
    const BFSList = g.BFS('A')
    expect(BFSList).toEqual(['A', 'B', 'C', 'D', 'E', 'F'])
  })

  /

  it('Check iterative DFS List After Removing Vertex B', () => {
    g.removeVertex('B')
    const iterativeDFSList = g.DFSIterative('A')
    expect(iterativeDFSList).toEqual(['A', 'C', 'E', 'F', 'D'])
  })

  it('Check recursive DFS List After Removing Vertex B', () => {
    g.removeVertex('B')
    const recursiveDFSList = g.DFS('A')
    expect(recursiveDFSList).toEqual(['A', 'C', 'E', 'D', 'F'])
  })

  it('Check BFS List After Removing Vertex B', () => {
    g.removeVertex('B')
    const BFSList = g.BFS('A')
    expect(BFSList).toEqual(['A', 'C', 'E', 'D', 'F'])
  })
})
class Graph {
      constructor (noOfVertices) {
    this.noOfVertices = noOfVertices
    this.AdjList = new Map()
  }

  
      
    
    addVertex (v) {
        
    this.AdjList.set(v, [])
  }

    addEdge (v, w) {
            this.AdjList.get(v).push(w)

            this.AdjList.get(w).push(v)
  }

    printGraph (output = value => console.log(value)) {
        const getKeys = this.AdjList.keys()

        for (const i of getKeys) {
                  const getValues = this.AdjList.get(i)
      let conc = ''

                  for (const j of getValues) {
        conc += j + ' '
      }

            output(i + ' -> ' + conc)
    }
  }
}

export { Graph }
class Graph {
  constructor () {
    this.adjacencyObject = {}
  }

  addVertex (vertex) {
    if (!this.adjacencyObject[vertex]) this.adjacencyObject[vertex] = []
  }

  addEdge (vertex1, vertex2) {
    this.adjacencyObject[vertex1].push(vertex2)
    this.adjacencyObject[vertex2].push(vertex1)
  }

  removeEdge (vertex1, vertex2) {
    this.adjacencyObject[vertex1] = this.adjacencyObject[vertex1].filter(
      (v) => v !== vertex2
    )
    this.adjacencyObject[vertex2] = this.adjacencyObject[vertex2].filter(
      (v) => v !== vertex1
    )
  }

  removeVertex (vertex) {
    while (this.adjacencyObject[vertex].length) {
      const adjacentVertex = this.adjacencyObject[vertex].pop()
      this.removeEdge(vertex, adjacentVertex)
    }
  }

  /
  DFS (start) {
    if (!start) return null

    const result = []
    const visited = {}
    const adjacencyObject = this.adjacencyObject

    function dfs (vertex) {
      if (!vertex) return null
      visited[vertex] = true
      result.push(vertex)
      adjacencyObject[vertex].forEach((neighbor) => {
        if (!visited[neighbor]) {
          dfs(neighbor)
        }
      })
    }

    dfs(start)
    return result
  }

  /
  DFSIterative (start) {
    if (!start) return null

    const stack = [start]
    const visited = {}
    visited[start] = true

    const result = []
    let currentVertex

    while (stack.length) {
      currentVertex = stack.pop()
      result.push(currentVertex)

      this.adjacencyObject[currentVertex].forEach((neighbor) => {
        if (!visited[neighbor]) {
          visited[neighbor] = true
          stack.push(neighbor)
        }
      })
    }
    return result
  }

  BFS (start) {
    if (!start) return null

    const queue = [start]
    const visited = {}
    visited[start] = true

    let currentVertex
    const result = []

    while (queue.length) {
      currentVertex = queue.shift()
      result.push(currentVertex)

      this.adjacencyObject[currentVertex].forEach((neighbor) => {
        if (!visited[neighbor]) {
          visited[neighbor] = true
          queue.push(neighbor)
        }
      })
    }
    return result
  }
}

export { Graph }


class Vector2 {
  constructor (x, y) {
    this.x = x
    this.y = y
  }

  /
  equalsExactly (vector) {
    return this.x === vector.x && this.y === vector.y
  }

  /
  equalsApproximately (vector, epsilon) {
    return (Math.abs(this.x - vector.x) < epsilon && Math.abs(this.y - vector.y) < epsilon)
  }

  /
  length () {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }

  /
  normalize () {
    const length = this.length()
    if (length === 0) {
      throw new Error('Cannot normalize vectors of length 0')
    }
    return new Vector2(this.x / length, this.y / length)
  }

  /
  add (vector) {
    const x = this.x + vector.x
    const y = this.y + vector.y
    return new Vector2(x, y)
  }

  /
  subtract (vector) {
    const x = this.x - vector.x
    const y = this.y - vector.y
    return new Vector2(x, y)
  }

  /
  multiply (scalar) {
    const x = this.x * scalar
    const y = this.y * scalar
    return new Vector2(x, y)
  }

  /
  distance (vector) {
    const difference = vector.subtract(this)
    return difference.length()
  }

  /
  dotProduct (vector) {
    return this.x * vector.x + this.y * vector.y
  }

  /
  rotate (angleInRadians) {
    const ca = Math.cos(angleInRadians)
    const sa = Math.sin(angleInRadians)
    const x = ca * this.x - sa * this.y
    const y = sa * this.x + ca * this.y
    return new Vector2(x, y)
  }

  /
  angleBetween (vector) {
    return Math.atan2(vector.y, vector.x) - Math.atan2(this.y, this.x)
  }
}

export { Vector2 }
import { Vector2 } from '../Vector2.js'

describe('Vector2', () => {
  describe('#equalsExactly', () => {
    it('should compare equality correctly', () => {
      expect(new Vector2(1, 0).equalsExactly(new Vector2(1, 0))).toBe(true)

      expect(new Vector2(1.23, 4.56).equalsExactly(new Vector2(0, 0))).toBe(false)
    })
  })

  describe('#equalsApproximately', () => {
    it('should compare equality (approximately) correctly', () => {
      expect(new Vector2(1, 0).equalsApproximately(new Vector2(1, 0.0000001), 0.000001))
        .toBe(true)

      expect(new Vector2(1.23, 4.56).equalsApproximately(new Vector2(1.24, 4.56), 0.000001))
        .toBe(false)
    })
  })

  describe('#add', () => {
    it('should add two vectors correctly', () => {
      expect(new Vector2(1, 0).add(new Vector2(0, 1)).equalsApproximately(new Vector2(1, 1), 0.000001))
        .toBe(true)

      expect(new Vector2(-3.3, -9).add(new Vector2(-2.2, 3)).equalsApproximately(new Vector2(-5.5, -6), 0.000001))
        .toBe(true)
    })
  })

  describe('#subtract', () => {
    it('should subtract two vectors correctly', () => {
      expect(new Vector2(1, 0).subtract(new Vector2(0, 1)).equalsApproximately(new Vector2(1, -1), 0.000001))
        .toBe(true)

      expect(new Vector2(234.5, 1.7).subtract(new Vector2(3.3, 2.7)).equalsApproximately(new Vector2(231.2, -1), 0.000001))
        .toBe(true)
    })
  })

  describe('#multiply', () => {
    it('should multiply two vectors correctly', () => {
      expect(new Vector2(1, 0).multiply(5).equalsApproximately(new Vector2(5, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(3.41, -7.12).multiply(-3.1).equalsApproximately(new Vector2(-10.571, 22.072), 0.000001))
        .toBe(true)
    })
  })

  describe('#length', () => {
    it('should calculate it\'s length correctly', () => {
      expect(new Vector2(1, 0).length()).toBe(1)

      expect(new Vector2(-1, 1).length()).toBe(Math.sqrt(2))
    })
  })

  describe('#normalize', () => {
    it('should normalize vectors correctly', () => {
      expect(new Vector2(1, 0).normalize().equalsApproximately(new Vector2(1, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(1, -1).normalize().equalsApproximately(new Vector2(Math.sqrt(2) / 2, -Math.sqrt(2) / 2), 0.000001))
        .toBe(true)
    })
  })

  describe('#distance', () => {
    it('should calculate the distance between two vectors correctly', () => {
      expect(new Vector2(0, 0).distance(new Vector2(0, -1))).toBe(1)

      expect(new Vector2(1, 0).distance(new Vector2(0, 1))).toBe(Math.sqrt(2))
    })
  })

  describe('#dotProduct', () => {
    it('should calculate the dot product correctly', () => {
      expect(new Vector2(1, 0).dotProduct(new Vector2(0, 1))).toBe(0)

      expect(new Vector2(1, 2).dotProduct(new Vector2(3, 4))).toBe(11)     })
  })

  describe('#rotate', () => {
    it('should rotate a vector correctly', () => {
      expect(new Vector2(0, -1).rotate(Math.PI / 2).equalsApproximately(new Vector2(1, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(1.23, -4.56).rotate(Math.PI).equalsApproximately(new Vector2(-1.23, 4.56), 0.000001))
        .toBe(true)
    })
  })

  describe('#angleBetween', () => {
    it('should calculate the angle between two vectors correctly', () => {
      expect(new Vector2(1, 0).angleBetween(new Vector2(0, 1))).toBe(Math.PI / 2)

      expect(new Vector2(1, 0).angleBetween(new Vector2(1, -1))).toBe(-Math.PI / 4)
    })
  })
})


class MinHeap {
  constructor (array) {
    this.heap = this.initializeHeap(array)
  }

  /
  initializeHeap (array) {
    const startingParent = Math.floor((array.length - 2) / 2)

    for (let currIdx = startingParent; currIdx >= 0; currIdx--) {
      this.sinkDown(currIdx, array.length - 1, array)
    }
    return array
  }

  /
  sinkDown (currIdx, endIdx, heap) {
    let childOneIdx = currIdx * 2 + 1

    while (childOneIdx <= endIdx) {
      const childTwoIdx = childOneIdx + 1 <= endIdx ? childOneIdx + 1 : -1
      const swapIdx = childTwoIdx !== -1 && heap[childTwoIdx] < heap[childOneIdx]
        ? childTwoIdx
        : childOneIdx

      if (heap[swapIdx] < heap[currIdx]) {
        this.swap(currIdx, swapIdx, heap)
        currIdx = swapIdx
        childOneIdx = currIdx * 2 + 1
      } else {
        return
      }
    }
  }

  /
  bubbleUp (currIdx) {
    let parentIdx = Math.floor((currIdx - 1) / 2)

    while (currIdx > 0 && this.heap[currIdx] < this.heap[parentIdx]) {
      this.swap(currIdx, parentIdx, this.heap)
      currIdx = parentIdx
      parentIdx = Math.floor((currIdx - 1) / 2)
    }
  }

  peek () {
    return this.heap[0]
  }

  /
  extractMin () {
    this.swap(0, this.heap.length - 1, this.heap)
    const min = this.heap.pop()
    this.sinkDown(0, this.heap.length - 1, this.heap)
    return min
  }

    insert (value) {
    this.heap.push(value)
    this.bubbleUp(this.heap.length - 1)
  }

    swap (idx1, idx2, heap) {
    const temp = heap[idx1]
    heap[idx1] = heap[idx2]
    heap[idx2] = temp
  }
}

export { MinHeap }
import { MinHeap } from '../MinHeap'

describe('MinHeap', () => {
  const array = [2, 4, 10, 23, 43, 42, 39, 7, 9, 16, 85, 1, 51]
  let heap

  beforeEach(() => {
    heap = new MinHeap(array)
  })

  it('should initialize a heap from an input array', () => {
    expect(heap).toEqual({ 'heap': [1, 4, 2, 7, 16, 10, 39, 23, 9, 43, 85, 42, 51] })     })

  it('should show the top value in the heap', () => {
    const minValue = heap.peek()

    expect(minValue).toEqual(1)
  })

  it('should remove and return the top value in the heap', () => {
    const minValue = heap.extractMin()

    expect(minValue).toEqual(1)
    expect(heap).toEqual({ 'heap': [2, 4, 10, 7, 16, 42, 39, 23, 9, 43, 85, 51] })        })

  it('should insert a new value and sort until it meets heap conditions', () => {
    heap.insert(15)

    expect(heap).toEqual({ 'heap': [2, 4, 10, 7, 16, 15, 39, 23, 9, 43, 85, 51, 42] })    })
})
import { MinPriorityQueue } from '../MinPriorityQueue'

describe('MinPriorityQueue', () => {
  const values = [5, 2, 4, 1, 7, 6, 3, 8]
  const capacity = values.length
  let queue

  beforeEach(() => {
    queue = new MinPriorityQueue(capacity)
    values.forEach(v => queue.insert(v))
  })

  it('Check heap ordering', () => {
    const mockFn = jest.fn()
    queue.print(mockFn)

    expect(mockFn.mock.calls.length).toBe(1)     expect(mockFn.mock.calls[0].length).toBe(1) 
    const heap = mockFn.mock.calls[0][0]
    expect(heap.length).toBe(capacity)
    expect(heap).toStrictEqual([1, 2, 3, 5, 7, 6, 4, 8])
  })

  it('heapSort() expected to reverse the heap ordering', () => {
    queue.heapReverse()
    const mockFn = jest.fn()
    queue.print(mockFn)

    expect(mockFn.mock.calls.length).toBe(1)
    expect(mockFn.mock.calls[0].length).toBe(1)

    const heap = mockFn.mock.calls[0][0]
    expect(heap.length).toBe(capacity)
    expect(heap).toStrictEqual([8, 7, 6, 5, 4, 3, 2, 1])
  })

  describe('delete() function work properly', () => {
    it('return undefined if heap is empty', () => {
      const minqueue = new MinPriorityQueue(capacity)
      const min = minqueue.delete()
      expect(min).toBe(undefined)
    })
    it('return min value and remove it', () => {
      const sortedValues = values.sort()
      let initialSize = queue.size
      sortedValues.forEach((minValue, index) => {
        const min = queue.delete()
        expect(min).toBe(minValue)
        expect(queue.size).toBe(--initialSize)
      })
      expect(queue.size).toBe(0)
    })
  })
})


class BinaryHeap {
  constructor () {
    this.heap = []
  }

  insert (value) {
    this.heap.push(value)
    this.heapify()
  }

  size () {
    return this.heap.length
  }

  empty () {
    return this.size() === 0
  }

    heapify () {
    let index = this.size() - 1

    while (index > 0) {
      const element = this.heap[index]
      const parentIndex = Math.floor((index - 1) / 2)
      const parent = this.heap[parentIndex]

      if (parent[0] >= element[0]) break
      this.heap[index] = parent
      this.heap[parentIndex] = element
      index = parentIndex
    }
  }

    extractMax () {
    const max = this.heap[0]
    const tmp = this.heap.pop()
    if (!this.empty()) {
      this.heap[0] = tmp
      this.sinkDown(0)
    }
    return max
  }

    sinkDown (index) {
    const left = 2 * index + 1
    const right = 2 * index + 2
    let largest = index
    const length = this.size()

    if (left < length && this.heap[left][0] > this.heap[largest][0]) {
      largest = left
    }
    if (right < length && this.heap[right][0] > this.heap[largest][0]) {
      largest = right
    }
        if (largest !== index) {
      const tmp = this.heap[largest]
      this.heap[largest] = this.heap[index]
      this.heap[index] = tmp
      this.sinkDown(largest)
    }
  }
}



export { BinaryHeap }

/


class MinPriorityQueue {
    constructor (c) {
    this.heap = []
    this.capacity = c
    this.size = 0
  }

      insert (key) {
    if (this.isFull()) return
    this.heap[this.size + 1] = key
    let k = this.size + 1
    while (k > 1) {
      if (this.heap[k] < this.heap[Math.floor(k / 2)]) {
        const temp = this.heap[k]
        this.heap[k] = this.heap[Math.floor(k / 2)]
        this.heap[Math.floor(k / 2)] = temp
      }
      k = Math.floor(k / 2)
    }
    this.size++
  }

    peek () {
    return this.heap[1]
  }

    isEmpty () {
    return this.size === 0
  }

    isFull () {
    if (this.size === this.capacity) return true
    return false
  }

    print (output = value => console.log(value)) {
    output(this.heap.slice(1))
  }

        heapReverse () {
    const heapSort = []
    while (this.size > 0) {
            [this.heap[1], this.heap[this.size]] = [this.heap[this.size], this.heap[1]]
      heapSort.push(this.heap.pop())
      this.size--
      this.sink()
    }
            this.heap = [undefined, ...heapSort.reverse()]
    this.size = heapSort.length
  }

    sink () {
    let k = 1
    while (2 * k <= this.size || 2 * k + 1 <= this.size) {
      let minIndex
      if (this.heap[2 * k] >= this.heap[k]) {
        if (2 * k + 1 <= this.size && this.heap[2 * k + 1] >= this.heap[k]) {
          break
        } else if (2 * k + 1 > this.size) {
          break
        }
      }
      if (2 * k + 1 > this.size) {
        minIndex = this.heap[2 * k] < this.heap[k] ? 2 * k : k
      } else {
        if (
          this.heap[k] > this.heap[2 * k] ||
          this.heap[k] > this.heap[2 * k + 1]
        ) {
          minIndex =
            this.heap[2 * k] < this.heap[2 * k + 1] ? 2 * k : 2 * k + 1
        } else {
          minIndex = k
        }
      }
      const temp = this.heap[k]
      this.heap[k] = this.heap[minIndex]
      this.heap[minIndex] = temp
      k = minIndex
    }
  }

      delete () {
        if (this.isEmpty()) return
    if (this.size === 1) {
      this.size--
      return this.heap.pop()
    }
    const min = this.heap[1]
    this.heap[1] = this.heap.pop()
    this.size--
    this.sink()
    return min
  }
}

export { MinPriorityQueue }

class Queue {
  constructor () {
    this.inputStack = []
    this.outputStack = []
  }

    enqueue (item) {
    this.inputStack.push(item)
  }

  dequeue () {
        this.outputStack = []
    while (this.inputStack.length > 0) {
      this.outputStack.push(this.inputStack.pop())
    }
        if (this.outputStack.length > 0) {
      const top = this.outputStack.pop()
            this.inputStack = []
      while (this.outputStack.length > 0) {
        this.inputStack.push(this.outputStack.pop())
      }
      return top
    }
  }

    listIn (output = value => console.log(value)) {
    let i = 0
    while (i < this.inputStack.length) {
      output(this.inputStack[i])
      i++
    }
  }

    listOut (output = value => console.log(value)) {
    let i = 0
    while (i < this.outputStack.length) {
      output(this.outputStack[i])
      i++
    }
  }
}

export { Queue }
import { Queue } from '../QueueUsing2Stacks'

describe('QueueUsing2Stacks', () => {
  const queue = new Queue()

  it('Check enqueue/dequeue', () => {
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(8)
    queue.enqueue(9)

    expect(queue.dequeue()).toBe(1)
    expect(queue.dequeue()).toBe(2)
  })
})
import Queue from '../Queue'

describe('Testing the Queue DS', () => {
  const queue = new Queue()

  it('Testing enqueue method', () => {
    expect(queue.enqueue(1)).toBe(1)
    expect(queue.enqueue(2)).toBe(2)
    expect(queue.enqueue(8)).toBe(3)
    expect(queue.enqueue(9)).toBe(4)
  })

  it('Testing length after enqueue', () => {
    expect(queue.length).toBe(4)
  })

  it('Testing peekFirst & peekLast methods', () => {
    expect(queue.peekFirst()).toBe(1)
    expect(queue.peekLast()).toBe(9)
  })

  it('Testing toArray method', () => {
    expect(queue.toArray()).toEqual([1, 2, 8, 9])
  })

  it('Testing dequeue method', () => {
    expect(queue.dequeue()).toBe(1)
    expect(queue.dequeue()).toBe(2)
  })

  it('Testing length after dequeue', () => {
    expect(queue.length).toBe(2)
  })

  it('Testing isEmpty method', () => {
    const queue = new Queue()
    expect(queue.isEmpty()).toBeTruthy()

    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(8)
    queue.enqueue(9)

    expect(queue.isEmpty()).toBeFalsy()
  })
})
/

class Queue {
  #size

  constructor () {
    this.head = null
    this.tail = null
    this.#size = 0

    return Object.seal(this)
  }

  get length () {
    return this.#size
  }

  /
  enqueue (data) {
    const node = { data, next: null }

    if (!this.head && !this.tail) {
      this.head = node
      this.tail = node
    } else {
      this.tail.next = node
      this.tail = node
    }

    return ++this.#size
  }

  /
  dequeue () {
    if (this.isEmpty()) {
      throw new Error('Queue is Empty')
    }

    const firstData = this.peekFirst()

    this.head = this.head.next

    if (!this.head) {
      this.tail = null
    }

    this.#size--

    return firstData
  }

  /
  peekFirst () {
    if (this.isEmpty()) {
      throw new Error('Queue is Empty')
    }

    return this.head.data
  }

  /
  peekLast () {
    if (this.isEmpty()) {
      throw new Error('Queue is Empty')
    }

    return this.tail.data
  }

  /
  toArray () {
    const array = []
    let node = this.head

    while (node) {
      array.push(node.data)
      node = node.next
    }

    return array
  }

  /
  isEmpty () {
    return this.length === 0
  }
}

export default Queue

class CircularQueue {
  constructor (maxLength) {
    this.queue = []
    this.front = 0
    this.rear = 0
    this.maxLength = maxLength
  }

    enqueue (value) {
    if (this.checkOverflow()) return
    if (this.checkEmpty()) {
      this.front += 1
      this.rear += 1
    } else {
      if (this.rear === this.maxLength) {
        this.rear = 1
      } else this.rear += 1
    }
    this.queue[this.rear] = value
  }

    dequeue () {
    if (this.checkEmpty()) {
            return
    }
    const y = this.queue[this.front]
    this.queue[this.front] = '*'
    if (!this.checkSingleelement()) {
      if (this.front === this.maxLength) this.front = 1
      else {
        this.front += 1
      }
    }

    return y   }

    checkEmpty () {
    if (this.front === 0 && this.rear === 0) {
      return true
    }
  }

  checkSingleelement () {
    if (this.front === this.rear && this.rear !== 0) {
      this.front = this.rear = 0
      return true
    }
  }

    checkOverflow () {
    if ((this.front === 1 && this.rear === this.maxLength) || (this.front === this.rear + 1)) {
            return true
    }
  }

    display (output = value => console.log(value)) {
    for (let index = 1; index < this.queue.length; index++) {
      output(this.queue[index])
    }
  }

    length () {
    return this.queue.length - 1
  }

    peek () {
    return this.queue[this.front]
  }
}

export { CircularQueue }
/

class Stack {
  constructor () {
    this.stack = []
    this.top = 0
  }

    push (newValue) {
    this.stack.push(newValue)
    this.top += 1
  }

    pop () {
    if (this.top !== 0) {
      this.top -= 1
      return this.stack.pop()
    }
    throw new Error('Stack Underflow')
  }

    get length () {
    return this.top
  }

    get isEmpty () {
    return this.top === 0
  }

    get last () {
    if (this.top !== 0) {
      return this.stack[this.stack.length - 1]
    }
    return null
  }

    static isStack (el) {
    return el instanceof Stack
  }
}

export { Stack }
/


const Stack = (function () {
  function Stack () {
        this.top = 0
        this.stack = []
  }

    Stack.prototype.push = function (value) {
    this.stack[this.top] = value
    this.top++
  }

    Stack.prototype.pop = function () {
    if (this.top === 0) {
      return 'Stack is Empty'
    }

    this.top--
    const result = this.stack[this.top]
    this.stack = this.stack.splice(0, this.top)
    return result
  }

    Stack.prototype.size = function () {
    return this.top
  }

    Stack.prototype.peek = function () {
    return this.stack[this.top - 1]
  }

    Stack.prototype.view = function (output = value => console.log(value)) {
    for (let i = 0; i < this.top; i++) {
      output(this.stack[i])
    }
  }

  return Stack
}())

export { Stack }
import { FenwickTree } from '../FenwickTree'

describe('Fenwick Tree Implementation', () => {
  const fenwickArray = new Array(1000)
  const array = [3, 2, 0, 6, 5, -1, 2]
  const length = array.length

  const fenwickTree = new FenwickTree(fenwickArray, array, length)

  it('Fenwick Tree - Prefix sum of array', () => {
    const prefixSum = fenwickTree.getPrefixSum(fenwickArray, 6)
    expect(prefixSum).toBe(23)
  })

  array[2] += 6
  fenwickTree.update(fenwickArray, length, 2, 6)

  it('Fenwick Tree - Prefix sum of Updated array', () => {
    const prefixSum = fenwickTree.getPrefixSum(fenwickArray, 6)
    expect(prefixSum).toBe(23)
  })
})
import { BinaryTree, Node } from '../BreadthFirstTreeTraversal'

describe('Breadth First Tree Traversal', () => {
  const binaryTree = new BinaryTree()

  const root = new Node(7)
  root.left = new Node(5)
  root.right = new Node(8)
  root.left.left = new Node(3)
  root.left.right = new Node(6)
  root.right.right = new Node(9)
  binaryTree.root = root

              
  it('Binary tree - Level order traversal', () => {
    expect(binaryTree.traversal).toStrictEqual([])
    const traversal = binaryTree.breadthFirst()
    expect(traversal).toStrictEqual([7, 5, 8, 3, 6, 9])
  })
})
/

class Node {
  constructor (data) {
    this.data = data
    this.left = null
    this.right = null
  }
}

class BinaryTree {
  constructor () {
    this.root = null
    this.traversal = []
  }

  breadthFirst () {
    const h = this.getHeight(this.root)
    for (let i = 0; i !== h; i++) {
      this.traverseLevel(this.root, i)
    }
    return this.traversal
  }

    getHeight (node) {
    if (node === null) {
      return 0
    }
    const lheight = this.getHeight(node.left)
    const rheight = this.getHeight(node.right)
    return lheight > rheight ? lheight + 1 : rheight + 1
  }

  traverseLevel (node, levelRemaining) {
    if (node === null) {
      return
    }
    if (levelRemaining === 0) {
      this.traversal.push(node.data)
    } else {
      this.traverseLevel(node.left, levelRemaining - 1)
      this.traverseLevel(node.right, levelRemaining - 1)
    }
  }
}

export { BinaryTree, Node }
/

class FenwickTree {
  constructor (feneickArray, array, n) {
    for (let i = 1; i <= n; i++) {
      feneickArray[i] = 0
    }
    for (let i = 0; i < n; i++) {
      this.update(feneickArray, n, i, array[i])
    }
  }

  update (feneickArray, n, index, value) {
    index = index + 1
    while (index <= n) {
      feneickArray[index] += value
      index += index & (-index)
    }
  }

  getPrefixSum (feneickArray, index) {
    let currSum = 0
    index = index + 1
    while (index > 0) {
      currSum += feneickArray[index]
      index -= index & (-index)
    }

    return currSum
  }
}
export { FenwickTree }
/

function traverseDFS (root) {
  const stack = [root]
  const res = []

  while (stack.length) {
    const curr = stack.pop()
    res.push(curr.key)

    if (curr.right) {
      stack.push(curr.right)
    }

    if (curr.left) {
      stack.push(curr.left)
    }
  }

  return res.reverse()
}

function searchDFS (tree, value) {
  const stack = []

  stack.push(tree[0])

  while (stack.length !== 0) {
    for (let i = 0; i < stack.length; i++) {
      const node = stack.pop()

      if (node.value === value) {
        return node
      }
      if (node.right) {
        stack.push(tree[node.right])
      }
      if (node.left) {
        stack.push(tree[node.left])
      }
    }
  }
  return null
}

const tree = [
  { value: 6, left: 1, right: 2 },
  { value: 5, left: 3, right: 4 },
  { value: 7, left: null, right: 5 },
  { value: 3, left: 6, right: null },
  { value: 4, left: null, right: null },
  { value: 9, left: 7, right: 8 },
  { value: 2, left: 9, right: null },
  { value: 8, left: null, right: null },
  { value: 10, left: null, right: null },
  { value: 1, left: null, right: null }
]

searchDFS(tree, 9)
searchDFS(tree, 10)

traverseDFS(6)

import { memoize } from '../Memoize'
import { union } from './cacheTest'
import { fibonacci } from '../../Dynamic-Programming/FibonacciNumber'
import { factorial } from '../../Recursive/Factorial'
import LFUCache from '../LFUCache'

const multipleFactorials = (arr) => arr.map(factorial)

describe('Testing Memoize', () => {
  it('expects the fibonacci function to use the cache on the second call', () => {
    const memoFibonacci = memoize(fibonacci)

    expect(memoFibonacci(5)).toEqual(fibonacci(5))
    expect(memoFibonacci(5)).toEqual(5)
    expect(memoFibonacci(10)).toEqual(fibonacci(10))
    expect(memoFibonacci(10)).toEqual(55)
  })

  it('expects the factorial function to use the cache on the second call', () => {
    const memoFactorial = memoize(factorial)

    expect(memoFactorial(5)).toEqual(factorial(5))
    expect(memoFactorial(5)).toEqual(120)
    expect(memoFactorial(10)).toEqual(factorial(10))
    expect(memoFactorial(10)).toEqual(3628800)
  })

  it('expects the multipleFactorials function to use the cache on the second call', () => {
    const memoMultipleFactorials = memoize(multipleFactorials)
    const input = [2, 3, 4, 5]

    expect(memoMultipleFactorials(input)).toEqual([2, 6, 24, 120])
    expect(memoMultipleFactorials(input)).toEqual(multipleFactorials(input))
  })

  it('expects the multipleFactorials function to use the cache on the second call', () => {
    const memoMultipleFactorials = memoize(multipleFactorials)
    const input = [2, 3, 4, 5]

    expect(memoMultipleFactorials(input)).toEqual([2, 6, 24, 120])
    expect(memoMultipleFactorials(input)).toEqual(multipleFactorials(input))
  })

  it('expects the union function to use the cache on the second call', () => {
    const memoUnion = memoize(union)
    const inputs = [
      new Set([1, 2, 3]),
      new Set([4, 3, 2]),
      new Set([5, 3, 6])
    ]

    expect(memoUnion(...inputs)).toEqual(new Set([1, 2, 3, 4, 5, 6]))
    expect(memoUnion(...inputs)).toEqual(union(...inputs))
  })

  it('Testing with explicit cache -> LFUCache', () => {
    const LFU = new LFUCache(2)

    const memoizeFibonacci = memoize(fibonacci, LFU)     const fibOfFiveHundred = memoizeFibonacci(500)
    const fibOfOneHundred = memoizeFibonacci(100)

    expect(memoizeFibonacci(500)).toBe(fibOfFiveHundred)
    expect(memoizeFibonacci(100)).toBe(fibOfOneHundred)

    expect(LFU.leastFrequency).toBe(2)
  })
})
import LFUCache from '../LFUCache'
import { fibonacciCache } from './cacheTest'

describe('Testing LFUCache class', () => {
  it('Example 1 (Small Cache, size = 2)', () => {
    const cache = new LFUCache(1) 
    cache.capacity = 2 
    expect(cache.capacity).toBe(2)

    cache.set(1, 1)     cache.set(2, 2) 
    expect(cache.get(1)).toBe(1)     expect(cache.get(2)).toBe(2) 
        cache.set(3, 3) 
    expect(cache.get(1)).toBe(null)     expect(cache.get(2)).toBe(2)     expect(cache.get(3)).toBe(3) 
    cache.set(4, 4)     expect(cache.get(1)).toBe(null)     expect(cache.get(2)).toBe(2)     expect(cache.get(3)).toBe(null)     expect(cache.get(4)).toBe(4) 
    expect(cache.info).toEqual({
      misses: 3,
      hits: 6,
      capacity: 2,
      currentSize: 2,
      leastFrequency: 2
    })

    const json = '{"misses":3,"hits":6,"cache":{"2":{"key":"2","value":2,"frequency":4},"4":{"key":"4","value":4,"frequency":2}}}'
    expect(cache.toString()).toBe(json)

    const cacheInstance = cache.parse(json) 
    expect(cacheInstance).toBe(cache) 
    cache.capacity = 1 
    expect(cache.info).toEqual({       misses: 6,
      hits: 12,
      capacity: 1,
      currentSize: 1,
      leastFrequency: 5
    })

    const clearedCache = cache.clear()     expect(clearedCache.size).toBe(0)
  })

  it('Example 2 (Computing Fibonacci Series, size = 100)', () => {
    const cache = new LFUCache(100)

    for (let i = 1; i <= 100; i++) {
      fibonacciCache(i, cache)
    }

    expect(cache.info).toEqual({
      misses: 103,
      hits: 193,
      capacity: 100,
      currentSize: 98,
      leastFrequency: 1
    })
  })
})
import LRUCache from '../LRUCache'
import { fibonacciCache } from './cacheTest'

describe('Testing LRUCache', () => {
  it('Testing with invalid capacity', () => {
    expect(() => new LRUCache()).toThrow()
    expect(() => new LRUCache('Invalid')).toThrow()
    expect(() => new LRUCache(-1)).toThrow()
    expect(() => new LRUCache(Infinity)).toThrow()
  })

  it('Example 1 (Small Cache, size = 2)', () => {
    const cache = new LRUCache(1) 
    cache.capacity++ 
    cache.set(1, 1)
    cache.set(2, 2)

    expect(cache.get(1)).toBe(1)
    expect(cache.get(2)).toBe(2)

        cache.set(3, 3)

        expect(cache.get(1)).toBe(null)
    expect(cache.get(2)).toBe(2)
    expect(cache.get(3)).toBe(3)

    cache.set(4, 4)
    expect(cache.get(1)).toBe(null)     expect(cache.get(2)).toBe(null)     expect(cache.get(3)).toBe(3)
    expect(cache.get(4)).toBe(4)

    expect(cache.info).toEqual({
      misses: 3,
      hits: 6,
      capacity: 2,
      size: 2
    })

    const json = '{"misses":3,"hits":6,"cache":{"3":3,"4":4}}'
    expect(cache.toString()).toBe(json)

        cache.parse(json)

    cache.capacity-- 
    expect(cache.info).toEqual({
      misses: 6,
      hits: 12,
      capacity: 1,
      size: 1
    })
  })

  it('Example 2 (Computing Fibonacci Series, size = 100)', () => {
    const cache = new LRUCache(100)

    for (let i = 1; i <= 100; i++) {
      fibonacciCache(i, cache)
    }

    expect(cache.info).toEqual({
      misses: 103,
      hits: 193,
      capacity: 100,
      size: 98
    })
  })
})

export const fibonacciCache = (n, cache = null) => {
  if (cache) {
    const value = cache.get(n)

    if (value !== null) {
      return value
    }
  }

  if (n === 1 || n === 2) {
    return 1
  }

  const result = fibonacciCache(n - 1, cache) + fibonacciCache(n - 2, cache)

  cache && cache.set(n, result)

  return result
}


export const union = (...sets) => {
  return new Set(
    sets.reduce((flatArray, set) => [...flatArray, ...set], [])
  )
}

const memoize = (func, cache = new Map()) => {
  const jsonReplacer = (_, value) => {
    if (value instanceof Set) {       return [...value]
    }

    if (value instanceof Map) {       return Object.fromEntries(value)
    }

    return value
  }

  return (...args) => {
    /
    const argsKey = JSON.stringify(args, jsonReplacer)

    /
    if (cache.has(argsKey)) {
      return cache.get(argsKey)
    }

    /
    const result = func(...args)     cache.set(argsKey, result)

    return result
  }
}

export { memoize }
class LRUCache {
    #capacity

  /
  constructor (capacity) {
    if (!Number.isInteger(capacity) || capacity < 0) {
      throw new TypeError('Invalid capacity')
    }

    this.#capacity = ~~capacity
    this.misses = 0
    this.hits = 0
    this.cache = new Map()

    return Object.seal(this)
  }

  get info () {
    return Object.freeze({
      misses: this.misses,
      hits: this.hits,
      capacity: this.capacity,
      size: this.size
    })
  }

  get size () {
    return this.cache.size
  }

  get capacity () {
    return this.#capacity
  }

  set capacity (newCapacity) {
    if (newCapacity < 0) {
      throw new RangeError('Capacity should be greater than 0')
    }

    if (newCapacity < this.capacity) {
      let diff = this.capacity - newCapacity

      while (diff--) {
        this.#removeLeastRecentlyUsed()
      }
    }

    this.#capacity = newCapacity
  }

  /
  #removeLeastRecentlyUsed () {
    this.cache.delete(this.cache.keys().next().value)
  }

  /
  has (key) {
    key = String(key)

    return this.cache.has(key)
  }

  /
  set (key, value) {
    key = String(key)
        if (this.size === this.capacity) {
      this.#removeLeastRecentlyUsed()
    }

    this.cache.set(key, value)
  }

  /
  get (key) {
    key = String(key)
        if (this.cache.has(key)) {
      const value = this.cache.get(key)

            this.cache.delete(key)
      this.cache.set(key, value)

      this.hits++
      return value
    }

    this.misses++
    return null
  }

  /
  parse (json) {
    const { misses, hits, cache } = JSON.parse(json)

    this.misses += misses ?? 0
    this.hits += hits ?? 0

    for (const key in cache) {
      this.set(key, cache[key])
    }

    return this
  }

  /
  toString (indent) {
    const replacer = (_, value) => {
      if (value instanceof Set) {
        return [...value]
      }

      if (value instanceof Map) {
        return Object.fromEntries(value)
      }

      return value
    }

    return JSON.stringify(this, replacer, indent)
  }
}

export default LRUCache
class CacheNode {
  constructor (key, value, frequency) {
    this.key = key
    this.value = value
    this.frequency = frequency

    return Object.seal(this)
  }
}

class FrequencyMap extends Map {
  static get [Symbol.species] () { return Map }   get [Symbol.toStringTag] () { return '' }

  /
  refresh (node) {
    const { frequency } = node
    const freqSet = this.get(frequency)
    freqSet.delete(node)

    node.frequency++

    this.insert(node)
  }

  /
  insert (node) {
    const { frequency } = node

    if (!this.has(frequency)) {
      this.set(frequency, new Set())
    }

    this.get(frequency).add(node)
  }
}

class LFUCache {
    #capacity
    #frequencyMap

    /
    constructor (capacity) {
      this.#capacity = capacity
      this.#frequencyMap = new FrequencyMap()
      this.misses = 0
      this.hits = 0
      this.cache = new Map()

      return Object.seal(this)
    }

    /
    get capacity () {
      return this.#capacity
    }

    /
    get size () {
      return this.cache.size
    }

    /
    set capacity (newCapacity) {
      if (this.#capacity > newCapacity) {
        let diff = this.#capacity - newCapacity 
        while (diff--) {
          this.#removeCacheNode()
        }

        this.cache.size === 0 && this.#frequencyMap.clear()
      }

      this.#capacity = newCapacity
    }

    get info () {
      return Object.freeze({
        misses: this.misses,
        hits: this.hits,
        capacity: this.capacity,
        currentSize: this.size,
        leastFrequency: this.leastFrequency
      })
    }

    get leastFrequency () {
      const freqCacheIterator = this.#frequencyMap.keys()
      let leastFrequency = freqCacheIterator.next().value || null

            while (this.#frequencyMap.get(leastFrequency)?.size === 0) {
        leastFrequency = freqCacheIterator.next().value
      }

      return leastFrequency
    }

    #removeCacheNode () {
      const leastFreqSet = this.#frequencyMap.get(this.leastFrequency)
            const LFUNode = leastFreqSet.values().next().value

      leastFreqSet.delete(LFUNode)
      this.cache.delete(LFUNode.key)
    }

    /
    has (key) {
      key = String(key) 
      return this.cache.has(key)
    }

    /
    get (key) {
      key = String(key) 
      if (this.cache.has(key)) {
        const oldNode = this.cache.get(key)
        this.#frequencyMap.refresh(oldNode)

        this.hits++

        return oldNode.value
      }

      this.misses++
      return null
    }

    /
    set (key, value, frequency = 1) {
      key = String(key) 
      if (this.#capacity === 0) {
        throw new RangeError('LFUCache ERROR: The Capacity is 0')
      }

      if (this.cache.has(key)) {
        const node = this.cache.get(key)
        node.value = value

        this.#frequencyMap.refresh(node)

        return this
      }

            if (this.#capacity === this.cache.size) {
        this.#removeCacheNode()
      }

      const newNode = new CacheNode(key, value, frequency)

      this.cache.set(key, newNode)
      this.#frequencyMap.insert(newNode)

      return this
    }

    /
    parse (json) {
      const { misses, hits, cache } = JSON.parse(json)

      this.misses += misses ?? 0
      this.hits += hits ?? 0

      for (const key in cache) {
        const { value, frequency } = cache[key]
        this.set(key, value, frequency)
      }

      return this
    }

    /
    clear () {
      this.cache.clear()
      this.#frequencyMap.clear()

      return this
    }

    /
    toString (indent) {
      const replacer = (_, value) => {
        if (value instanceof Set) {
          return [...value]
        }

        if (value instanceof Map) {
          return Object.fromEntries(value)
        }

        return value
      }

      return JSON.stringify(this, replacer, indent)
    }
}

export default LFUCache
const feetToMeter = (feet) => {
  return feet * 0.3048
}

const meterToFeet = (meter) => {
  return meter / 0.3048
}

export { feetToMeter, meterToFeet }
/


const RailwayTimeConversion = (timeString) => {
    if (typeof timeString !== 'string') {
    return new TypeError('Argument is not a string.')
  }
    const [hour, minute, scondWithShift] = timeString.split(':')
    const [second, shift] = [scondWithShift.substr(0, 2), scondWithShift.substr(2)]
    if (shift === 'PM') {
    if (parseInt(hour) === 12) { return `${hour}:${minute}:${second}` } else { return `${parseInt(hour) + 12}:${minute}:${second}` }
  } else {
    if (parseInt(hour) === 12) { return `00:${minute}:${second}` } else { return `${hour}:${minute}:${second}` }
  }
}

export { RailwayTimeConversion }
/


const titleCaseConversion = (inputString) => {
  if (inputString === '') return ''
    const stringCollections = inputString.split(' ').map(word => {
    let firstChar = ''
        const firstCharCode = word[0].charCodeAt()
        if (firstCharCode >= 97 && firstCharCode <= 122) {
            firstChar += String.fromCharCode(firstCharCode - 32)
    } else {
            firstChar += word[0]
    }
    const newWordChar = word.slice(1).split('').map(char => {
            const presentCharCode = char.charCodeAt()
            if (presentCharCode >= 65 && presentCharCode <= 90) {
                return String.fromCharCode(presentCharCode + 32)
      }
            return char
    })
        return firstChar + newWordChar.join('')
  })
    return stringCollections.join(' ')
}

export { titleCaseConversion }
import { base64ToBuffer } from '../Base64ToArrayBuffer'
import { TextDecoder } from 'util'

describe('Base64ToArrayBuffer', () => {
  it('should decode "SGVsbG8sIHdvcmxkIQ==" as "Hello, world!"', () => {
    const testBase64String = 'SGVsbG8sIHdvcmxkIQ=='
    const buffer = base64ToBuffer(testBase64String)
    const decoder = new TextDecoder()
    const helloWorldString = decoder.decode(buffer)
    expect(helloWorldString).toBe('Hello, world!')
  })

  it('should decode base64 "Nxex6kQaWg==" as binary buffer [55,23,177,234,68,26,90]', () => {
    const testBase64String = 'Nxex6kQaWg=='
    const buffer = base64ToBuffer(testBase64String)
    const array = [...new Uint8Array(buffer)]
    expect(array).toEqual([55, 23, 177, 234, 68, 26, 90])
  })

  it('should decode base64 "AAECAwQFBgcICQ==" as binary buffer [0,1,2,3,4,5,6,7,8,9]', () => {
    const testBase64String = 'AAECAwQFBgcICQ=='
    const buffer = base64ToBuffer(testBase64String)
    const array = [...new Uint8Array(buffer)]
    expect(array).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  })
})
import { octalToDecimal } from '../OctToDecimal'

test('The Decimal representation of Octal number 56 is 46', () => {
  const res = octalToDecimal(56)
  expect(res).toBe(46)
})

test('The Decimal representation of Octal number 99 is 81', () => {
  const res = octalToDecimal(99)
  expect(res).toBe(81)
})

test('The Decimal representation of Octal number 17 is 15', () => {
  const res = octalToDecimal(17)
  expect(res).toBe(15)
})

test('The Decimal representation of Octal number 100 is 64', () => {
  const res = octalToDecimal(100)
  expect(res).toBe(64)
})

test('The Decimal representation of Octal number 0 is 0', () => {
  const res = octalToDecimal(0)
  expect(res).toBe(0)
})
import binaryToDecimal from '../BinaryToDecimal'

describe('BinaryToDecimal', () => {
  it('expects to return correct decimal value', () => {
    expect(binaryToDecimal('1000')).toBe(8)
  })

  it('expects to return correct hexadecimal value for more than one hex digit', () => {
    expect(binaryToDecimal('01101000')).toBe(104)
  })

  it('expects to return correct hexadecimal value for padding-required binary', () => {
    expect(binaryToDecimal('1000101')).toBe(69)
  })
})
import * as tc from '../TemperatureConversion.js'

describe('Testing Conversion of Celsius to fahrenheit', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToFahrenheit(10)
    expect(test1).toBe(50)
  })
})

describe('Testing Conversion of Celsius to kelvin', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToKelvin(15)
    expect(test1).toBe(288)
  })
})

describe('Testing Conversion of Celsius to Rankine', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToRankine(28)
    expect(test1).toBe(542)
  })
})

describe('Testing Conversion of Fahrenheit to Celsius', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToCelsius(134)
    expect(test1).toBe(57)
  })
})

describe('Testing Conversion of Fahrenheit to Kelvin', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToKelvin(125)
    expect(test1).toBe(325)
  })
})

describe('Testing Conversion of Fahrenheit to Rankine', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToRankine(10)
    expect(test1).toBe(470)
  })
})

describe('Testing Conversion of Kelvin to Celsius', () => {
  it('with Kelvin value', () => {
    const test1 = tc.kelvinToCelsius(100)
    expect(test1).toBe(-173)
  })
})

describe('Testing Conversion of Kelvin to Fahrenheit', () => {
  it('with Kelvin value', () => {
    const test1 = tc.kelvinToFahrenheit(20)
    expect(test1).toBe(-424)
  })
})

describe('Testing Conversion of Kelvin to Rankine', () => {
  it('with kelvin value', () => {
    const test1 = tc.kelvinToRankine(69)
    expect(test1).toBe(124)
  })
})
describe('Testing Conversion of Rankine to Celsius', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToCelsius(234)
    expect(test1).toBe(-143)
  })
})
describe('Testing Conversion of Rankine to Fahrenheit', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToFahrenheit(98)
    expect(test1).toBe(-362)
  })
})
describe('Testing Conversion of Rankine to Kelvin', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToKelvin(10)
    expect(test1).toBe(6)
  })
})
describe('Testing Conversion of Reamur to Celsius', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToCelsius(100)
    expect(test1).toBe(125)
  })
})
describe('Testing Conversion of Reamur to Fahrenheit', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToFahrenheit(100)
    expect(test1).toBe(257)
  })
})
describe('Testing Conversion of Reamur to Kelvin', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToKelvin(100)
    expect(test1).toBe(398)
  })
})
describe('Testing Conversion of Reamur to Rankine', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToRankine(100)
    expect(test1).toBe(717)
  })
})
import hexToBinary from '../HexToBinary'

describe('Testing hexToBinary', () => {
  it('expects throw error in invalid types', () => {
    expect(() => hexToBinary(false)).toThrowError()
    expect(() => hexToBinary(null)).toThrowError()
    expect(() => hexToBinary(23464)).toThrowError()
  })

  it('expects throw error in invalid hex', () => {
    expect(() => hexToBinary('Hello i am not a valid Hex')).toThrowError()
    expect(() => hexToBinary('Gf46f')).toThrowError()
    expect(() => hexToBinary('M')).toThrowError()
  })

  it('expects to return correct hexadecimal value', () => {
    expect(hexToBinary('8')).toBe('1000')
  })

  it('expects to return correct binary value for more than one hex digit', () => {
    expect(hexToBinary('EA')).toBe('11101010')
  })

  it('expects to test its robustness as it should be case-insensitive', () => {
    expect(hexToBinary('4d')).toBe('01001101')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(2)', () => {
    expect(hexToBinary('F')).toBe(parseInt('F', 16).toString(2))
  })
})
import { upperCaseConversion } from '../UpperCaseConversion'

describe(('Test the upperCaseConversion function'), () => {
  it('should return an empty string when the input is an empty string', () => {
    expect(upperCaseConversion('')).toEqual('')
  })

  it('should return an all-uppercase string when input is an all-uppercase string', () => {
    expect(upperCaseConversion('ALLUPPERCASE')).toEqual('ALLUPPERCASE')
  })

  it('should return an all-uppercase string when input is an all-uppercase string with spaces', () => {
    expect(upperCaseConversion('ALL UPPERCASE')).toEqual('ALL UPPERCASE')
  })

  it('should return an all-uppercase string when input is an all-uppercase string with punctuation', () => {
    expect(upperCaseConversion('ALL UPPER-CASE!')).toEqual('ALL UPPER-CASE!')
  })

  it('should return an all-uppercase string when input is an all-lowercase string', () => {
    expect(upperCaseConversion('lowercaseinput')).toEqual('LOWERCASEINPUT')
  })

  it('should return an all-uppercase string when input is an all-lowercase string with spaces', () => {
    expect(upperCaseConversion('lowercase input')).toEqual('LOWERCASE INPUT')
  })

  it('should return an all-uppercase string when input is an all-lowercase string with punctuation', () => {
    expect(upperCaseConversion('lower-case, input.')).toEqual('LOWER-CASE, INPUT.')
  })

  it('should return an all-uppercase string when input is an mixed-case string', () => {
    expect(upperCaseConversion('mixeDCaSeINPuT')).toEqual('MIXEDCASEINPUT')
  })

  it('should return an all-uppercase string when input is an mixed-case string with spaces', () => {
    expect(upperCaseConversion('mixeD CaSe INPuT')).toEqual('MIXED CASE INPUT')
  })

  it('should return an all-uppercase string when input is an mixed-case string with punctuation', () => {
    expect(upperCaseConversion('mixeD-CaSe INPuT!')).toEqual('MIXED-CASE INPUT!')
  })
})
import binaryToHex from '../BinaryToHex'

describe('BinaryToHex', () => {
  it('expects to return correct hexadecimal value', () => {
    expect(binaryToHex('1000')).toBe('8')
  })

  it('expects to return correct hexadecimal value for more than one hex digit', () => {
    expect(binaryToHex('11101010')).toBe('EA')
  })

  it('expects to return correct hexadecimal value for padding-required binary', () => {
    expect(binaryToHex('1001101')).toBe('4D')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(16)', () => {
    expect(binaryToHex('1111')).toBe(parseInt('1111', 2).toString(16).toUpperCase())
  })
})
import { DateDayDifference } from '../DateDayDifference'

test('The difference between 17/08/2002 & 10/10/2020 is 6630', () => {
  const res = DateDayDifference('17/08/2002', '10/10/2020')
  expect(res).toBe(6630)
})

test('The difference between 18/02/2001 & 16/03/2022 is 7696', () => {
  const res = DateDayDifference('18/02/2001', '16/03/2022')
  expect(res).toBe(7696)
})

test('The difference between 11/11/2011 & 12/12/2012 is 398', () => {
  const res = DateDayDifference('11/11/2011', '12/12/2012')
  expect(res).toBe(398)
})

test('The difference between 01/01/2001 & 16/03/2011 is 3727', () => {
  const res = DateDayDifference('01/01/2001', '16/03/2011')
  expect(res).toBe(3727)
})
import { LowerCaseConversion } from '../LowerCaseConversion'

test('The LowerCaseConversion of ApoLO is apolo', () => {
  const res = LowerCaseConversion('ApoLO')
  expect(res).toBe('apolo')
})

test('The LowerCaseConversion of WEB is web', () => {
  const res = LowerCaseConversion('WEB')
  expect(res).toBe('web')
})

test('The LowerCaseConversion of EaRTh is earth', () => {
  const res = LowerCaseConversion('EaRTh')
  expect(res).toBe('earth')
})

test('The LowerCaseConversion of TiGER is tiger', () => {
  const res = LowerCaseConversion('TiGER')
  expect(res).toBe('tiger')
})

test('The LowerCaseConversion of Cricket is cricket', () => {
  const res = LowerCaseConversion('Cricket')
  expect(res).toBe('cricket')
})
import { decimalToRoman } from '../DecimalToRoman'

describe('decimalToRoman', () => {
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(34)).toBe('XXXIV')
  })
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(28)).toBe('XXVIII')
  })
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(2021)).toBe('MMXXI')
  })
})
import { decimalToBinary } from '../DecimalToBinary'

test('The Binary representation of 35 is 100011', () => {
  const res = decimalToBinary(35)
  expect(res).toBe('100011')
})

test('The Binary representation of 1 is 1', () => {
  const res = decimalToBinary(1)
  expect(res).toBe('1')
})

test('The Binary representation of 1000 is 1111101000', () => {
  const res = decimalToBinary(1000)
  expect(res).toBe('1111101000')
})

test('The Binary representation of 2 is 10', () => {
  const res = decimalToBinary(2)
  expect(res).toBe('10')
})

test('The Binary representation of 17 is 10001', () => {
  const res = decimalToBinary(17)
  expect(res).toBe('10001')
})
import { decimalToHex } from '../DecimalToHex'

describe('DecimalToHex', () => {
  it('expects to return correct hexadecimal value', () => {
    expect(decimalToHex(255)).toBe('FF')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(16)', () => {
    expect(decimalToHex(32768)).toBe((32768).toString(16).toUpperCase())
  })

  it('expects to not handle negative numbers', () => {
    expect(decimalToHex(-32768)).not.toBe((-32768).toString(16).toUpperCase())
  })
})
import { convertArbitraryBase } from '../ArbitraryBase'

test('Check the answer of convertArbitraryBase(98, 0123456789, 01234567) is 142', () => {
  const res = convertArbitraryBase('98', '0123456789', '01234567')
  expect(res).toBe('142')
})

test('Check the answer of convertArbitraryBase(98, 0123456789, abcdefgh) is bec', () => {
  const res = convertArbitraryBase('98', '0123456789', 'abcdefgh')
  expect(res).toBe('bec')
})

test('Check the answer of convertArbitraryBase(98, 0123456789, 98765432) is 857', () => {
  const res = convertArbitraryBase('98', '0123456789', '98765432')
  expect(res).toBe('857')
})

test('Check the answer of convertArbitraryBase(129, 0123456789, 01234567) is 201', () => {
  const res = convertArbitraryBase('129', '0123456789', '01234567')
  expect(res).toBe('201')
})

test('Check the answer of convertArbitraryBase(112, 0123456789, 12345678) is 271', () => {
  const res = convertArbitraryBase('112', '0123456789', '12345678')
  expect(res).toBe('271')
})

test('Check the answer of convertArbitraryBase(112, 0123456789, 123456789) is 245', () => {
  const res = convertArbitraryBase('112', '0123456789', '123456789')
  expect(res).toBe('245')
})

test('Check the answer of convertArbitraryBase(111, 0123456789, abcdefgh) is bfh', () => {
  const res = convertArbitraryBase('111', '0123456789', 'abcdefgh')
  expect(res).toBe('bfh')
})
import { meterToFeet, feetToMeter } from '../MeterToFeetConversion'

describe('Testing conversion of Meter to Feet', () => {
  it('with feet value', () => {
    expect(meterToFeet(30.48)).toBe(100)
  })
})

describe('Testing conversion of Feet to Meter', () => {
  it('with feet value', () => {
    expect(feetToMeter(10)).toBe(3.048)
  })
})
import { RGBToHex } from '../RGBToHex'

test('The Hex format of RGB (225, 225, 225) is #ffffff', () => {
  const res = RGBToHex(255, 255, 255)
  expect(res).toBe('#ffffff')
})

test('The Hex format of RGB (190, 108, 217) is #be6cd9', () => {
  const res = RGBToHex(190, 108, 217)
  expect(res).toBe('#be6cd9')
})

test('The Hex format of RGB (255, 99, 71) is #ff6347', () => {
  const res = RGBToHex(255, 99, 71)
  expect(res).toBe('#ff6347')
})

test('The Hex format of RGB (100, 108, 217) is #646cd9', () => {
  const res = RGBToHex(100, 108, 217)
  expect(res).toBe('#646cd9')
})
import { approximatelyEqualHsv, hsvToRgb, rgbToHsv } from '../RgbHsvConversion'

describe('hsvToRgb', () => {
    it('should calculate the correct RGB values', () => {
    expect(hsvToRgb(0, 0, 0)).toEqual([0, 0, 0])
    expect(hsvToRgb(0, 0, 1)).toEqual([255, 255, 255])
    expect(hsvToRgb(0, 1, 1)).toEqual([255, 0, 0])
    expect(hsvToRgb(60, 1, 1)).toEqual([255, 255, 0])
    expect(hsvToRgb(120, 1, 1)).toEqual([0, 255, 0])
    expect(hsvToRgb(240, 1, 1)).toEqual([0, 0, 255])
    expect(hsvToRgb(300, 1, 1)).toEqual([255, 0, 255])
    expect(hsvToRgb(180, 0.5, 0.5)).toEqual([64, 128, 128])
    expect(hsvToRgb(234, 0.14, 0.88)).toEqual([193, 196, 224])
    expect(hsvToRgb(330, 0.75, 0.5)).toEqual([128, 32, 80])
  })
})

describe('rgbToHsv', () => {
    it('should calculate the correct HSV values', () => {
    expect(approximatelyEqualHsv(rgbToHsv(0, 0, 0), [0, 0, 0])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 255, 255), [0, 0, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 0, 0), [0, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 255, 0), [60, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(0, 255, 0), [120, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(0, 0, 255), [240, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 0, 255), [300, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(64, 128, 128), [180, 0.5, 0.5])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(193, 196, 224), [234, 0.14, 0.88])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(128, 32, 80), [330, 0.75, 0.5])).toEqual(true)
  })
})
import { DateToDay } from '../DateToDay'

test('The date 18/02/2001 is Monday', () => {
  const res = DateToDay('18/02/2001')
  expect(res).toBe('Monday')
})

test('The date 18/12/2020 is Friday', () => {
  const res = DateToDay('18/12/2020')
  expect(res).toBe('Friday')
})

test('The date 12/12/2012 is Wednesday', () => {
  const res = DateToDay('12/12/2012')
  expect(res).toBe('Wednesday')
})
test('The date 01/01/2001 is Friday', () => {
  const res = DateToDay('01/01/2001')
  expect(res).toBe('Friday')
})
import { decimalToOctal } from '../DecimalToOctal'

test('The Octal representation of 8 is 10', () => {
  const res = decimalToOctal(8)
  expect(res).toBe(10)
})

test('The Octal representation of 1 is 1', () => {
  const res = decimalToOctal(1)
  expect(res).toBe(1)
})

test('The Octal representation of 0 is 0', () => {
  const res = decimalToOctal(0)
  expect(res).toBe(0)
})

test('The Octal representation of 100 is 144', () => {
  const res = decimalToOctal(100)
  expect(res).toBe(144)
})

test('The Octal representation of 111 is 157', () => {
  const res = decimalToOctal(111)
  expect(res).toBe(157)
})
import { hexStringToRGB } from '../HexToRGB'

test('The RGB form of Hex String E1E1E1 is {r: 225, g: 225, b: 225}', () => {
  const res = hexStringToRGB('E1E1E1')
  expect(res).toEqual({ r: 225, g: 225, b: 225 })
})

test('The RGB form of Hex String 000000 is {r: 0, g: 0, b: 0}', () => {
  const res = hexStringToRGB('000000')
  expect(res).toEqual({ r: 0, g: 0, b: 0 })
})

test('The RGB form of Hex String 6CE1CD is {r: 108, g: 225, b: 205}', () => {
  const res = hexStringToRGB('6CE1CD')
  expect(res).toEqual({ r: 108, g: 225, b: 205 })
})
import { titleCaseConversion } from '../TitleCaseConversion'

describe(('Tests for the titleCaseConversion function'), () => {
  it('should return an empty string when the input is an empty string', () => {
    expect(titleCaseConversion('')).toEqual('')
  })

  it('should return the input string when the input string is a title case string', () => {
    expect(titleCaseConversion('A Proper Title Case String')).toEqual('A Proper Title Case String')
  })

  it('should return a title case string when input is an all-uppercase string', () => {
    expect(titleCaseConversion('ALL UPPER CASE')).toEqual('All Upper Case')
  })

  it('should return a title case string when input is a title case string of with spaces', () => {
    expect(titleCaseConversion('ALL UPPERCASE')).toEqual('All Uppercase')
  })

  it('should return a title case string when input is a title case string of with no spaces', () => {
    expect(titleCaseConversion('ALLUPPERCASE')).toEqual('Alluppercase')
  })

  it('should return a title case string when input is a title case string with punctuation', () => {
    expect(titleCaseConversion('All Title Case!')).toEqual('All Title Case!')
  })

  it('should return a title case string when input is an all-lowercase string with no spaces', () => {
    expect(titleCaseConversion('lowercaseinput')).toEqual('Lowercaseinput')
  })

  it('should return a title case string when input is an all-lowercase string with spaces', () => {
    expect(titleCaseConversion('lowercase input')).toEqual('Lowercase Input')
  })

  it('should return a title case string when input is an all-lowercase string with punctuation', () => {
    expect(titleCaseConversion('lower, case, input.')).toEqual('Lower, Case, Input.')
  })

  it('should return a title case string when input is an mixed-case string', () => {
    expect(titleCaseConversion('mixeD CaSe INPuT')).toEqual('Mixed Case Input')
  })

  it('should return a title case string when input is an mixed-case string with no spaces', () => {
    expect(titleCaseConversion('mixeDCaSeINPuT')).toEqual('Mixedcaseinput')
  })

  it('should return a title case string when input is an mixed-case string with punctuation', () => {
    expect(titleCaseConversion('mixeD, CaSe, INPuT!')).toEqual('Mixed, Case, Input!')
  })
})
import { bufferToBase64 } from '../ArrayBufferToBase64'
import { TextEncoder } from 'util'

describe('ArrayBufferToBase64', () => {
  it('should encode "Hello, world!" as "SGVsbG8sIHdvcmxkIQ=="', () => {
    const testString = 'Hello, world!'
    const encoder = new TextEncoder()
    const helloWorldBuffer = encoder.encode(testString)
    const result = bufferToBase64(helloWorldBuffer)
    expect(result).toBe('SGVsbG8sIHdvcmxkIQ==')
  })

  it('should encode binary buffer [55,23,177,234,68,26,90] as "Nxex6kQaWg=="', () => {
    const testBuffer = new Uint8Array([55, 23, 177, 234, 68, 26, 90])
    const result = bufferToBase64(testBuffer)
    expect(result).toBe('Nxex6kQaWg==')
  })

  it('should encode binary buffer [0,1,2,3,4,5,6,7,8,9] as "AAECAwQFBgcICQ=="', () => {
    const testBuffer = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    const result = bufferToBase64(testBuffer)
    expect(result).toBe('AAECAwQFBgcICQ==')
  })
})
import { RailwayTimeConversion } from '../RailwayTimeConversion'

test('The RailwayTimeConversion of 07:05:45AM is 07:05:45', () => {
  const res = RailwayTimeConversion('07:05:45AM')
  expect(res).toEqual('07:05:45')
})

test('The RailwayTimeConversion of 07:05:45PM is 19:05:45', () => {
  const res = RailwayTimeConversion('07:05:45PM')
  expect(res).toEqual('19:05:45')
})

test('The RailwayTimeConversion of 10:20:00AM is 10:20:00', () => {
  const res = RailwayTimeConversion('10:20:00AM')
  expect(res).toEqual('10:20:00')
})

test('The RailwayTimeConversion of 11:20:00PM is 23:20:00', () => {
  const res = RailwayTimeConversion('11:20:00PM')
  expect(res).toEqual('23:20:00')
})
import { romanToDecimal } from '../RomanToDecimal'

describe('romanToDecimal', () => {
  it('XXIIVV', () => {
    expect(romanToDecimal('XXIIVV')).toBe(28)
  })

  it('MDCCCIV', () => {
    expect(romanToDecimal('MDCCCIV')).toBe(1804)
  })

  it('XXIVI', () => {
    expect(romanToDecimal('XXIVI')).toBe(25)
  })
})
const pad = (num, padlen) => {
  const pad = new Array(1 + padlen).join(0)
  return (pad + num).slice(-pad.length)
}

const hexLookup = (bin) => {
  let binary = bin
  if (binary.length < 4) {
    binary = pad(binary, 4)
  }
  switch (binary) {
    case '0000': return '0'
    case '0001': return '1'
    case '0010': return '2'
    case '0011': return '3'
    case '0100': return '4'
    case '0101': return '5'
    case '0110': return '6'
    case '0111': return '7'
    case '1000': return '8'
    case '1001': return '9'
    case '1010': return 'A'
    case '1011': return 'B'
    case '1100': return 'C'
    case '1101': return 'D'
    case '1110': return 'E'
    case '1111': return 'F'
  }
}
const binaryToHex = (binaryString) => {
  /

  let result = ''
  binaryString = binaryString.split('')
  for (let i = binaryString.length - 1; i >= 0; i = i - 4) {
    if (i >= 3) {
      result += hexLookup(binaryString.slice(i - 3, i + 1).join(''))
    } else {
      result += hexLookup(binaryString.slice(0, i + 1).join(''))
    }
  }
  return result.split('').reverse().join('')
}

export default binaryToHex


function bufferToBase64 (binaryData) {
    const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    const padding = 3 - (binaryData.byteLength % 3)
    const byteView = new Uint8Array(binaryData)
  let result = ''

    for (let i = 0; i < byteView.byteLength; i += 3) {
        const char1 = (byteView[i] & 252) >> 2
    const char2 = ((byteView[i] & 3) << 4) + ((byteView[i + 1] & 240) >> 4)
    const char3 = ((byteView[i + 1] & 15) << 2) + ((byteView[i + 2] & 192) >> 6)
    const char4 = byteView[i + 2] & 63

    result +=
        base64Table[char1] +
        base64Table[char2] +
        base64Table[char3] +
        base64Table[char4]
  }

    if (padding !== 3) {
    const paddedResult = result.slice(0, result.length - padding) + '='.repeat(padding)
    return paddedResult
  }

  return result
}

export { bufferToBase64 }
function RGBToHex (r, g, b) {
  if (
    typeof r !== 'number' ||
    typeof g !== 'number' ||
    typeof b !== 'number'
  ) {
    throw new TypeError('argument is not a Number')
  }

  const toHex = n => (n || '0').toString(16).padStart(2, '0')

  return `#${toHex(r)}${toHex(g)}${toHex(b)}`
}

export { RGBToHex }


/

const isLeap = (year) => {
  if (year % 400 === 0) return true
  else if (year % 100 === 0) return false
  else if (year % 4 === 0) return true
  else return false
}
const DateToDay = (dd, mm, yyyy) => {
  return Math.floor((365 * (yyyy - 1)) + ((yyyy - 1) / 4) - ((yyyy - 1) / 100) + ((yyyy - 1) / 400) + dd + (((367 * mm) - 362) / 12) + (mm <= 2 ? 0 : isLeap(yyyy) ? -1 : -2))
}

const DateDayDifference = (date1, date2) => {
    if (typeof date1 !== 'string' && typeof date2 !== 'string') {
    return new TypeError('Argument is not a string.')
  }
    const [firstDateDay, firstDateMonth, firstDateYear] = date1.split('/').map((ele) => Number(ele))
    const [secondDateDay, secondDateMonth, secondDateYear] = date2.split('/').map((ele) => Number(ele))
    if (firstDateDay < 0 || firstDateDay > 31 ||
        firstDateMonth > 12 || firstDateMonth < 0 ||
        secondDateDay < 0 || secondDateDay > 31 ||
        secondDateMonth > 12 || secondDateMonth < 0) {
    return new TypeError('Date is not valid.')
  }
  return Math.abs(DateToDay(secondDateDay, secondDateMonth, secondDateYear) - DateToDay(firstDateDay, firstDateMonth, firstDateYear))
}


export { DateDayDifference }
const binLookup = (key) => ({
  0: '0000',
  1: '0001',
  2: '0010',
  3: '0011',
  4: '0100',
  5: '0101',
  6: '0110',
  7: '0111',
  8: '1000',
  9: '1001',
  a: '1010',
  b: '1011',
  c: '1100',
  d: '1101',
  e: '1110',
  f: '1111'
}[key.toLowerCase()]) 
const hexToBinary = (hexString) => {
  if (typeof hexString !== 'string') {
    throw new TypeError('Argument is not a string type')
  }

  if (/[^\da-f]/gi.test(hexString)) {
    throw new Error('Argument is not a valid HEX code!')
  }
  /

  return hexString.replace(
    /[0-9a-f]/gi,
    lexeme => binLookup(lexeme)
  )
}

export default hexToBinary
/

const values = {
  M: 1000,
  CM: 900,
  D: 500,
  CD: 400,
  C: 100,
  XC: 90,
  L: 50,
  XL: 40,
  X: 10,
  IX: 9,
  V: 5,
  IV: 4,
  I: 1
}

const orders = [
  'M',
  'CM',
  'D',
  'CD',
  'C',
  'XC',
  'L',
  'XL',
  'X',
  'IX',
  'V',
  'IV',
  'I'
]

function decimalToRoman (num) {
  let roman = ''
  for (const symbol of orders) {
    while (num >= values[symbol]) {
      roman += symbol
      num -= values[symbol]
    }
  }
  return roman
}

export { decimalToRoman }
const values = {
  I: 1,
  V: 5,
  X: 10,
  L: 50,
  C: 100,
  D: 500,
  M: 1000
}

export function romanToDecimal (romanNumber) {
  let prev = ' '

  let sum = 0

  let newPrev = 0
  for (let i = romanNumber.length - 1; i >= 0; i--) {
    const c = romanNumber.charAt(i)

    if (prev !== ' ') {
      newPrev = values[prev] > newPrev ? values[prev] : newPrev
    }

    const currentNum = values[c]
    if (currentNum >= newPrev) {
      sum += currentNum
    } else {
      sum -= currentNum
    }

    prev = c
  }
  return sum
}


function base64ToBuffer (b64) {
    const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    const paddingIdx = b64.indexOf('=')
    const b64NoPadding = paddingIdx !== -1 ? b64.slice(0, paddingIdx) : b64
    const bufferLength = Math.floor((b64NoPadding.length * 6) / 8)
    const result = new ArrayBuffer(bufferLength)
    const byteView = new Uint8Array(result)

    for (let i = 0, j = 0; i < b64NoPadding.length; i += 4, j += 3) {
        const b64Char1 = base64Table.indexOf(b64NoPadding[i])
    const b64Char2 = base64Table.indexOf(b64NoPadding[i + 1])
    let b64Char3 = base64Table.indexOf(b64NoPadding[i + 2])
    let b64Char4 = base64Table.indexOf(b64NoPadding[i + 3])

        if (b64Char3 === -1) b64Char3 = 0
    if (b64Char4 === -1) b64Char4 = 0

        const byte1 = (b64Char1 << 2) + ((b64Char2 & 48) >> 4)
    const byte2 = ((b64Char2 & 15) << 4) + ((b64Char3 & 60) >> 2)
    const byte3 = ((b64Char3 & 3) << 6) + b64Char4

    byteView[j] = byte1
    byteView[j + 1] = byte2
    byteView[j + 2] = byte3
  }

  return result
}

export { base64ToBuffer }
function octalToDecimal (num) {
  let dec = 0
  let base = 1
  while (num > 0) {
    const r = num % 10
    num = Math.floor(num / 10)
    dec = dec + (r * base)
    base = base * 8
  }
  return dec
}

export { octalToDecimal }


function hexToInt (hexNum) {
  const numArr = hexNum.split('')   return numArr.map((item, index) => {
    switch (item) {
      case 'A': return 10
      case 'B': return 11
      case 'C': return 12
      case 'D': return 13
      case 'E': return 14
      case 'F': return 15
      default: return parseInt(item)
    }
  })
}

function hexToDecimal (hexNum) {
  const intItemsArr = hexToInt(hexNum)
  return intItemsArr.reduce((accumulator, current, index) => {
    return accumulator + (current * Math.pow(16, (intItemsArr.length - (1 + index))))
  }, 0)
}

export { hexToInt, hexToDecimal }
function intToHex (num) {
  switch (num) {
    case 10: return 'A'
    case 11: return 'B'
    case 12: return 'C'
    case 13: return 'D'
    case 14: return 'E'
    case 15: return 'F'
  }
  return num
}

function decimalToHex (num) {
  const hexOut = []
  while (num > 15) {
    hexOut.unshift(intToHex(num % 16))
    num = Math.floor(num / 16)
  }
  return intToHex(num) + hexOut.join('')
}

export { decimalToHex }
/


const upperCaseConversion = (inputString) => {
    const newString = inputString.split('').map(char => {
        const presentCharCode = char.charCodeAt()
        if (presentCharCode >= 97 && presentCharCode <= 122) {
            return String.fromCharCode(presentCharCode - 32)
    }
        return char
  })
    return newString.join('')
}

export { upperCaseConversion }
function decimalToOctal (num) {
  let oct = 0
  let c = 0
  while (num > 0) {
    const r = num % 8
    oct = oct + (r * Math.pow(10, c++))
    num = Math.floor(num / 8)   }
  return oct
}

export { decimalToOctal }






const convertArbitraryBase = (stringInBaseOne, baseOneCharacters, baseTwoCharacters) => {
  if ([stringInBaseOne, baseOneCharacters, baseTwoCharacters].map(arg => typeof arg).some(type => type !== 'string')) {
    throw new TypeError('Only string arguments are allowed')
  }
  [baseOneCharacters, baseTwoCharacters].forEach(baseString => {
    const charactersInBase = [...baseString]
    if (charactersInBase.length !== new Set(charactersInBase).size) {
      throw new TypeError('Duplicate characters in character set are not allowed')
    }
  })
  const reversedStringOneChars = [...stringInBaseOne].reverse()
  const stringOneBase = baseOneCharacters.length
  let value = 0
  let placeValue = 1
  for (const digit of reversedStringOneChars) {
    const digitNumber = baseOneCharacters.indexOf(digit)
    if (digitNumber === -1) {
      throw new TypeError(`Not a valid character: ${digit}`)
    }
    value += (digitNumber * placeValue)
    placeValue *= stringOneBase
  }
  let stringInBaseTwo = ''
  const stringTwoBase = baseTwoCharacters.length
  while (value > 0) {
    const remainder = value % stringTwoBase
    stringInBaseTwo = baseTwoCharacters.charAt(remainder) + stringInBaseTwo
    value /= stringTwoBase
  }
  const baseTwoZero = baseTwoCharacters.charAt(0)
  return stringInBaseTwo.replace(new RegExp(`^${baseTwoZero}+`), '')
}

export { convertArbitraryBase }



/


const LowerCaseConversion = (inputString) => {
    const newString = inputString.split('').map(char => {
        const presentCharCode = char.charCodeAt()
        if (presentCharCode >= 65 && presentCharCode <= 90) {
            return String.fromCharCode(presentCharCode + 32)
    }
        return char
  })
    return newString.join('')
}

export { LowerCaseConversion }

const celsiusToFahrenheit = (celsius) => {
      return Math.round(((celsius) * 9 / 5) + 32)
}

const celsiusToKelvin = (celsius) => {
      return Math.round((celsius) + 273.15)
}

const celsiusToRankine = (celsius) => {
      return Math.round(((celsius) * 9 / 5) + 491.67)
}

const fahrenheitToCelsius = (fahrenheit) => {
      return Math.round(((fahrenheit) - 32) * 5 / 9)
}

const fahrenheitToKelvin = (fahrenheit) => {
      return Math.round((((fahrenheit) - 32) * 5 / 9) + 273.15)
}

const fahrenheitToRankine = (fahrenheit) => {
      return Math.round((fahrenheit) + 459.67)
}

const kelvinToCelsius = (kelvin) => {
      return Math.round((kelvin) - 273.15)
}

const kelvinToFahrenheit = (kelvin) => {
      return Math.round((((kelvin) - 273.15) * 9 / 5) + 32)
}

const kelvinToRankine = (kelvin) => {
      return Math.round(((kelvin) * 9 / 5))
}

const rankineToCelsius = (rankine) => {
      return Math.round(((rankine) - 491.67) * 5 / 9)
}

const rankineToFahrenheit = (rankine) => {
      return Math.round((rankine) - 459.67)
}

const rankineToKelvin = (rankine) => {
      return Math.round(((rankine) * 5 / 9))
}

const reaumurToKelvin = (reaumur) => {
    return Math.round(((reaumur) * 1.25 + 273.15))
}

const reaumurToFahrenheit = (reaumur) => {
    return Math.round(((reaumur) * 2.25 + 32))
}

const reaumurToCelsius = (reaumur) => {
    return Math.round(((reaumur) * 1.25))
}

const reaumurToRankine = (reaumur) => {
    return Math.round(((reaumur) * 2.25 + 32 + 459.67))
}

export {
  celsiusToFahrenheit, celsiusToKelvin, celsiusToRankine,
  fahrenheitToCelsius, fahrenheitToKelvin, fahrenheitToRankine,
  kelvinToCelsius, kelvinToFahrenheit, kelvinToRankine,
  rankineToCelsius, rankineToFahrenheit, rankineToKelvin,
  reaumurToCelsius, reaumurToFahrenheit, reaumurToKelvin, reaumurToRankine
}
/

const calcMonthList = {
  1: 11,
  2: 12,
  3: 1,
  4: 2,
  5: 3,
  6: 4,
  7: 5,
  8: 6,
  9: 7,
  10: 8,
  11: 9,
  12: 10
}

const daysNameList = {   0: 'Sunday',
  1: 'Monday',
  2: 'Tuesday',
  3: 'Wednesday',
  4: 'Thursday',
  5: 'Friday',
  6: 'Saturday'
}

const DateToDay = (date) => {
    if (typeof date !== 'string') {
    return new TypeError('Argument is not a string.')
  }
    const [day, month, year] = date.split('/').map((x) => Number(x))
    if (day < 0 || day > 31 || month > 12 || month < 0) {
    return new TypeError('Date is not valid.')
  }
    const yearDigit = (year % 100)
  const century = Math.floor(year / 100)
    const weekDay = Math.abs((day + Math.floor((2.6 * calcMonthList[month]) - 0.2) - (2 * century) + yearDigit + Math.floor(yearDigit / 4) + Math.floor(century / 4)) % 7)
    return daysNameList[weekDay]
}


export { DateToDay }
function hexStringToRGB (hexString) {
  let r = hexString.substring(0, 2)
  let g = hexString.substring(2, 4)
  let b = hexString.substring(4, 6)

  r = parseInt(r, 16)
  g = parseInt(g, 16)
  b = parseInt(b, 16)
  const obj = { r, g, b }

  return obj
}

export { hexStringToRGB }

/


export function hsvToRgb (hue, saturation, value) {
  if (hue < 0 || hue > 360) {
    throw new Error('hue should be between 0 and 360')
  }

  if (saturation < 0 || saturation > 1) {
    throw new Error('saturation should be between 0 and 1')
  }

  if (value < 0 || value > 1) {
    throw new Error('value should be between 0 and 1')
  }

  const chroma = value * saturation
  const hueSection = hue / 60
  const secondLargestComponent = chroma * (1 - Math.abs(hueSection % 2 - 1))
  const matchValue = value - chroma

  return getRgbBySection(hueSection, chroma, matchValue, secondLargestComponent)
}


export function rgbToHsv (red, green, blue) {
  if (red < 0 || red > 255) {
    throw new Error('red should be between 0 and 255')
  }

  if (green < 0 || green > 255) {
    throw new Error('green should be between 0 and 255')
  }

  if (blue < 0 || blue > 255) {
    throw new Error('blue should be between 0 and 255')
  }

  const dRed = red / 255
  const dGreen = green / 255
  const dBlue = blue / 255
  const value = Math.max(Math.max(dRed, dGreen), dBlue)
  const chroma = value - Math.min(Math.min(dRed, dGreen), dBlue)
  const saturation = value === 0 ? 0 : chroma / value
  let hue

  if (chroma === 0) {
    hue = 0
  } else if (value === dRed) {
    hue = 60 * ((dGreen - dBlue) / chroma)
  } else if (value === dGreen) {
    hue = 60 * (2 + (dBlue - dRed) / chroma)
  } else {
    hue = 60 * (4 + (dRed - dGreen) / chroma)
  }

  hue = (hue + 360) % 360

  return [hue, saturation, value]
}

export function approximatelyEqualHsv (hsv1, hsv2) {
  const bHue = Math.abs(hsv1[0] - hsv2[0]) < 0.2
  const bSaturation = Math.abs(hsv1[1] - hsv2[1]) < 0.002
  const bValue = Math.abs(hsv1[2] - hsv2[2]) < 0.002

  return bHue && bSaturation && bValue
}

function getRgbBySection (hueSection, chroma, matchValue, secondLargestComponent) {
  function convertToInt (input) {
    return Math.round(255 * input)
  }

  let red
  let green
  let blue

  if (hueSection >= 0 && hueSection <= 1) {
    red = convertToInt(chroma + matchValue)
    green = convertToInt(secondLargestComponent + matchValue)
    blue = convertToInt(matchValue)
  } else if (hueSection > 1 && hueSection <= 2) {
    red = convertToInt(secondLargestComponent + matchValue)
    green = convertToInt(chroma + matchValue)
    blue = convertToInt(matchValue)
  } else if (hueSection > 2 && hueSection <= 3) {
    red = convertToInt(matchValue)
    green = convertToInt(chroma + matchValue)
    blue = convertToInt(secondLargestComponent + matchValue)
  } else if (hueSection > 3 && hueSection <= 4) {
    red = convertToInt(matchValue)
    green = convertToInt(secondLargestComponent + matchValue)
    blue = convertToInt(chroma + matchValue)
  } else if (hueSection > 4 && hueSection <= 5) {
    red = convertToInt(secondLargestComponent + matchValue)
    green = convertToInt(matchValue)
    blue = convertToInt(chroma + matchValue)
  } else {
    red = convertToInt(chroma + matchValue)
    green = convertToInt(matchValue)
    blue = convertToInt(secondLargestComponent + matchValue)
  }

  return [red, green, blue]
}
function decimalToBinary (num) {
  const bin = []
  while (num > 0) {
    bin.unshift(num % 2)
    num >>= 1   }
  return bin.join('')
}

export { decimalToBinary }



export default function binaryToDecimal (binaryString) {
  let decimalNumber = 0
  const binaryDigits = binaryString.split('').reverse()   binaryDigits.forEach((binaryDigit, index) => {
    decimalNumber += binaryDigit * (Math.pow(2, index))   })
  return decimalNumber
}
/

const swap = (arr, i, j) => {
  const newArray = [...arr];

  [newArray[i], newArray[j]] = [newArray[j], newArray[i]] 
  return newArray
}

const permutations = arr => {
  const P = []
  const permute = (arr, low, high) => {
    if (low === high) {
      P.push([...arr])
      return P
    }
    for (let i = low; i <= high; i++) {
      arr = swap(arr, low, i)
      permute(arr, low + 1, high)
    }
    return P
  }
  return permute(arr, 0, arr.length - 1)
}

export { permutations }
class NQueen {
  constructor (size) {
    this.board = new Array(size).fill('.').map(() => new Array(size).fill('.'))
    this.size = size
    this.solutionCount = 0
  }

  isValid ([row, col]) {
    
        for (let i = 0; i < col; i++) {
      if (this.board[row][i] === 'Q') return false
    }

        for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {
      if (this.board[i][j] === 'Q') return false
    }

        for (let i = row, j = col; j >= 0 && i < this.size; i++, j--) {
      if (this.board[i][j] === 'Q') return false
    }

    return true
  }

  placeQueen (row, col) {
    this.board[row][col] = 'Q'
  }

  removeQueen (row, col) {
    this.board[row][col] = '.'
  }

  solve (col = 0) {
    if (col >= this.size) {
      this.solutionCount++
      return true
    }

    for (let i = 0; i < this.size; i++) {
      if (this.isValid([i, col])) {
        this.placeQueen(i, col)
        this.solve(col + 1)
        this.removeQueen(i, col)
      }
    }

    return false
  }

  printBoard (output = value => console.log(value)) {
    if (!output._isMockFunction) {
      output('\n')
    }
    for (const row of this.board) {
      output(row)
    }
  }
}

export { NQueen }
import { Combinations } from '../AllCombinationsOfSizeK'

describe('AllCombinationsOfSizeK', () => {
  it('should return 3x2 matrix solution for n = 3 and k = 2', () => {
    const test1 = new Combinations(3, 2)
    expect(test1.findCombinations()).toEqual([[1, 2], [1, 3], [2, 3]])
  })

  it('should return 6x2 matrix solution for n = 4 and k = 2', () => {
    const test2 = new Combinations(4, 2)
    expect(test2.findCombinations()).toEqual([[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]])
  })
})
import { NQueen } from '../NQueen'

describe('NQueen', () => {
  it('should return 2 solutions for 4x4 size board', () => {
    const _4Queen = new NQueen(4)
    _4Queen.solve()
    expect(_4Queen.solutionCount).toEqual(2)
  })

  it('should return 92 solutions for 8x8 size board', () => {
    const _8Queen = new NQueen(8)
    _8Queen.solve()
    expect(_8Queen.solutionCount).toEqual(92)
  })
})
import { OpenKnightTour } from '../KnightTour'

describe('OpenKnightTour', () => {
  it('OpenKnightTour(5)', () => {
    const KT = new OpenKnightTour(5)
    expect(KT.board).toEqual([
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0]
    ])

    KT.solve()
    expect(KT.board).toEqual([
      [19, 4, 15, 10, 25],
      [14, 9, 18, 5, 16],
      [1, 20, 3, 24, 11],
      [8, 13, 22, 17, 6],
      [21, 2, 7, 12, 23]
    ])
  })
})
import { Sudoku } from '../Sudoku'

const data = [
  [3, 0, 6, 5, 0, 8, 4, 0, 0],
  [5, 2, 0, 0, 0, 0, 0, 0, 0],
  [0, 8, 7, 0, 0, 0, 0, 3, 1],
  [0, 0, 3, 0, 1, 0, 0, 8, 0],
  [9, 0, 0, 8, 6, 3, 0, 0, 5],
  [0, 5, 0, 0, 9, 0, 6, 0, 0],
  [1, 3, 0, 0, 0, 0, 2, 5, 0],
  [0, 0, 0, 0, 0, 0, 0, 7, 4],
  [0, 0, 5, 2, 0, 6, 3, 0, 0]
]

const solved = [
  [3, 1, 6, 5, 7, 8, 4, 9, 2],
  [5, 2, 9, 1, 3, 4, 7, 6, 8],
  [4, 8, 7, 6, 2, 9, 5, 3, 1],
  [2, 6, 3, 4, 1, 5, 9, 8, 7],
  [9, 7, 4, 8, 6, 3, 1, 2, 5],
  [8, 5, 1, 7, 9, 2, 6, 4, 3],
  [1, 3, 8, 9, 4, 7, 2, 5, 6],
  [6, 9, 2, 3, 5, 1, 8, 7, 4],
  [7, 4, 5, 2, 8, 6, 3, 1, 9]
]

describe('Sudoku', () => {
  it('should create a valid board successfully', () => {
            expect(() => { new Sudoku(data) }).not.toThrow()
  })

  it('should find an empty cell', () => {
    const board = new Sudoku(data)
    const emptyCell = board.findEmptyCell()
    expect(emptyCell).not.toEqual([-1, -1])
  })

  it('should solve the board successfully', () => {
    const board = new Sudoku(data)
    board.solve()

        const emptyCell = board.findEmptyCell()
    expect(emptyCell).toEqual([-1, -1])

        for (let i = 0; i < 9; i++) {
      const section = board.getSection(i, [0, 9])
      expect(section).toEqual(solved[i])
    }
  })
})
import { permutations } from '../GeneratePermutations'

describe('Permutations', () => {
  it('Permutations of [1, 2, 3]', () => {
    expect(permutations([1, 2, 3])).toEqual([
      [1, 2, 3],
      [1, 3, 2],
      [2, 1, 3],
      [2, 3, 1],
      [3, 1, 2],
      [3, 2, 1]
    ])
  })
})
import { RatInAMaze } from '../RatInAMaze'

describe('RatInAMaze', () => {
  it('should fail for non-arrays', () => {
    const values = [undefined, null, {}, 42, 'hello, world']

    for (const value of values) {
                  expect(() => { new RatInAMaze(value) }).toThrow()
    }
  })

  it('should fail for an empty array', () => {
            expect(() => { new RatInAMaze([]) }).toThrow()
  })

  it('should fail for a non-square array', () => {
    const array = [
      [0, 0, 0],
      [0, 0]
    ]

            expect(() => { new RatInAMaze(array) }).toThrow()
  })

  it('should fail for arrays containing invalid values', () => {
    const values = [[[2]], [['a']]]

    for (const value of values) {
                  expect(() => { new RatInAMaze(value) }).toThrow()
    }
  })

  it('should work for a single-cell maze', () => {
    const maze = new RatInAMaze([[1]])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('')
  })

  it('should work for a single-cell maze that can not be solved', () => {
    const maze = new RatInAMaze([[0]])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })

  it('should work for a simple 3x3 maze', () => {
    const maze = new RatInAMaze([[1, 1, 0], [0, 1, 0], [0, 1, 1]])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('RDDR')
  })

  it('should work for a simple 2x2 that can not be solved', () => {
    const maze = new RatInAMaze([[1, 0], [0, 1]])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })

  it('should work for a more complex maze', () => {
    const maze = new RatInAMaze([
      [1, 1, 1, 1, 1, 0, 0],
      [0, 0, 0, 0, 1, 0, 0],
      [1, 1, 1, 0, 1, 0, 0],
      [1, 0, 1, 0, 1, 0, 0],
      [1, 0, 1, 1, 1, 0, 0],
      [1, 0, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 1, 1, 1]
    ])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('RRRRDDDDLLUULLDDDDRRRRRR')
  })

  it('should work for a more complex maze that can not be solved', () => {
    const maze = new RatInAMaze([
      [1, 1, 1, 1, 1, 0, 1],
      [0, 0, 0, 0, 1, 0, 1],
      [1, 1, 1, 0, 1, 0, 1],
      [1, 0, 1, 0, 1, 0, 1],
      [1, 0, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 1, 1, 1]
    ])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })
})
import { sumOfSubset } from '../SumOfSubset'

describe('SumOfSubset', () => {
  it('should return the subsets that add up to the given number', () => {
        
    const nums = [2, 5, 7, 8, 12, 16, 23, 40]

    const subsets = sumOfSubset(nums, [], 0, 0, 25)

    expect(subsets).toEqual([
      [2, 7, 16],
      [2, 23],
      [5, 8, 12]
    ])
  })
})
class Sudoku {
    constructor (board) {
    this.board = board
  }

  findEmptyCell () {
        for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        if (this.board[i][j] === 0) return [i, j]
      }
    }
    return [-1, -1]
  }

  check ([y, x], value) {
    
        for (let i = 0; i < 9; i++) {
      if (this.board[i][x] === value) return false
    }
        for (let i = 0; i < 9; i++) {
      if (this.board[y][i] === value) return false
    }

        const secRow = Math.floor(y / 3)
    const secCol = Math.floor(x / 3)
    for (let i = (secRow * 3); i < ((secRow * 3) + 3); i++) {
      for (let j = (secCol * 3); j < ((secCol * 3) + 3); j++) {
        if (y !== i && x !== j && this.board[i][j] === value) return false
      }
    }

    return true
  }

  solve () {
    const [y, x] = this.findEmptyCell()

        if (y === -1 && x === -1) return true

    for (let val = 1; val < 10; val++) {
      if (this.check([y, x], val)) {
        this.board[y][x] = val
        if (this.solve()) return true
                this.board[y][x] = 0
      }
    }
        return false
  }

  getSection (row, [start, end]) {
    return this.board[row].slice(start, end)
  }

  printBoard (output = (...v) => console.log(...v)) {
        for (let i = 0; i < 9; i++) {
      if (i % 3 === 0 && i !== 0) {
        output('- - - - - - - - - - - -')
      }
      output(
        ...this.getSection(i, [0, 3]), ' | ',
        ...this.getSection(i, [3, 6]), ' | ',
        ...this.getSection(i, [6, 9]))
    }
  }
}

export { Sudoku }
/


function validateGrid (grid) {
  if (!Array.isArray(grid) || grid.length === 0) throw new TypeError('Grid must be a non-empty array')

  const allRowsHaveCorrectLength = grid.every(row => row.length === grid.length)
  if (!allRowsHaveCorrectLength) throw new TypeError('Grid must be a square')

  const allCellsHaveValidValues = grid.every(row => {
    return row.every(cell => cell === 0 || cell === 1)
  })
  if (!allCellsHaveValidValues) throw new TypeError('Grid must only contain 0s and 1s')
}

function isSafe (grid, x, y) {
  const n = grid.length
  return x >= 0 && x < n && y >= 0 && y < n && grid[y][x] === 1
}


function getPathPart (grid, x, y, solution, path) {
  const n = grid.length

    if (x === n - 1 && y === n - 1 && grid[y][x] === 1) {
    solution[y][x] = 1
    return path
  }

    if (!isSafe(grid, x, y)) return false

    if (solution[y][x] === 1) return false

  
    solution[y][x] = 1

    const right = getPathPart(grid, x + 1, y, solution, path + 'R')
  if (right) return right

    const down = getPathPart(grid, x, y + 1, solution, path + 'D')
  if (down) return down

    const up = getPathPart(grid, x, y - 1, solution, path + 'U')
  if (up) return up

    const left = getPathPart(grid, x - 1, y, solution, path + 'L')
  if (left) return left

    solution[y][x] = 0
  return false
}

function getPath (grid) {
    const n = grid.length

    const solution = []
  for (let i = 0; i < n; i++) {
    const row = Array(n)
    row.fill(0)
    solution[i] = row
  }

  return getPathPart(grid, 0, 0, solution, '')
}


export class RatInAMaze {
  constructor (grid) {
        validateGrid(grid)

        const solution = getPath(grid)

    if (solution !== false) {
      this.path = solution
      this.solved = true
    } else {
      this.path = ''
      this.solved = false
    }
  }
}
/

class Combinations {
  constructor (n, k) {
    this.n = n
    this.k = k
    this.current = []     this.combinations = []
  }

  findCombinations (high = this.n, total = this.k, low = 1) {
    if (total === 0) {
      this.combinations.push([...this.current])
      return this.combinations
    }
    for (let i = low; i <= high; i++) {
      this.current.push(i)
      this.findCombinations(high, total - 1, i + 1)
      this.current.pop()
    }
    return this.combinations
  }
}

export { Combinations }
/

/
const sumOfSubset = (set, subset, setindex, sum, targetSum) => {
        if (sum === targetSum) return [subset]

      if (sum > targetSum) return []

    let results = []

        set.slice(setindex).forEach((num, index) => {
        const nextSubset = [...subset, num]

            const nextSetIndex = setindex + index + 1

        const nextSum = sum + num

        const subsetResult = sumOfSubset(
      set,
      nextSubset,
      nextSetIndex,
      nextSum,
      targetSum
    )

        results = [...results, ...subsetResult]
  })

    return results
}

export { sumOfSubset }

class OpenKnightTour {
  constructor (size) {
    this.board = new Array(size).fill(0).map(() => new Array(size).fill(0))
    this.size = size
  }

  getMoves ([i, j]) {
        const moves = [
      [i + 2, j - 1],
      [i + 2, j + 1],
      [i - 2, j - 1],
      [i - 2, j + 1],
      [i + 1, j - 2],
      [i + 1, j + 2],
      [i - 1, j - 2],
      [i - 1, j + 2]
    ]

    return moves.filter(([y, x]) => y >= 0 && y < this.size && x >= 0 && x < this.size)
  }

  isComplete () {
        return !this.board.map(row => row.includes(0)).includes(true)
  }

  solve () {
        for (let i = 0; i < this.size; i++) {
      for (let j = 0; j < this.size; j++) {
        if (this.solveHelper([i, j], 0)) return true
      }
    }
    return false
  }

  solveHelper ([i, j], curr) {
        if (this.isComplete()) return true

    for (const [y, x] of this.getMoves([i, j])) {
      if (this.board[y][x] === 0) {
        this.board[y][x] = curr + 1
        if (this.solveHelper([y, x], curr + 1)) return true
                this.board[y][x] = 0
      }
    }
    return false
  }

  printBoard (output = value => console.log(value)) {
        for (const row of this.board) {
      let string = ''
      for (const elem of row) {
        string += elem + '\t'
      }
      output(string)
    }
  }
}

export { OpenKnightTour }
/


export function newGeneration (cells) {
  const nextGeneration = []
  for (let i = 0; i < cells.length; i++) {
    const nextGenerationRow = []
    for (let j = 0; j < cells[i].length; j++) {
            let neighbourCount = 0
      if (i > 0 && j > 0) neighbourCount += cells[i - 1][j - 1]
      if (i > 0) neighbourCount += cells[i - 1][j]
      if (i > 0 && j < cells[i].length - 1) neighbourCount += cells[i - 1][j + 1]
      if (j > 0) neighbourCount += cells[i][j - 1]
      if (j < cells[i].length - 1) neighbourCount += cells[i][j + 1]
      if (i < cells.length - 1 && j > 0) neighbourCount += cells[i + 1][j - 1]
      if (i < cells.length - 1) neighbourCount += cells[i + 1][j]
      if (i < cells.length - 1 && j < cells[i].length - 1) neighbourCount += cells[i + 1][j + 1]

            const alive = cells[i][j] === 1
      if ((alive && neighbourCount >= 2 && neighbourCount <= 3) || (!alive && neighbourCount === 3)) {
        nextGenerationRow.push(1)
      } else {
        nextGenerationRow.push(0)
      }
    }
    nextGeneration.push(nextGenerationRow)
  }
  return nextGeneration
}
import { newGeneration } from '../ConwaysGameOfLife'

describe('newGeneration', () => {
  it('should produce the next generation according to the rules', () => {
    expect(newGeneration([[0, 1, 0], [0, 1, 0], [0, 1, 0]]))
      .toEqual([[0, 0, 0], [1, 1, 1], [0, 0, 0]])
  })
})

export function TowerOfHanoi (n, from, to, aux, output = []) {
  if (n === 1) {
    output.push(`Move disk 1 from rod ${from} to rod ${to}`)
    return output
  }
  TowerOfHanoi(n - 1, from, aux, to, output)
  output.push(`Move disk ${n} from rod ${from} to rod ${to}`)
  TowerOfHanoi(n - 1, aux, to, from, output)
  return output
}


function euclideanGCDRecursive (first, second) {
  /
  if (second === 0) {
    return first
  } else {
    return euclideanGCDRecursive(second, (first % second))
  }
}

function euclideanGCDIterative (first, second) {
  /
  while (second !== 0) {
    const temp = second
    second = first % second
    first = temp
  }
  return first
}

export { euclideanGCDIterative, euclideanGCDRecursive }
import { Vector2, iterate } from './KochSnowflake'


function getKochSnowflake (canvasWidth = 600, steps = 5) {
  if (canvasWidth <= 0) {
    throw new Error('canvasWidth should be greater than zero')
  }

  const offsetX = canvasWidth / 10.0
  const offsetY = canvasWidth / 3.7
  const vector1 = new Vector2(offsetX, offsetY)
  const vector2 = new Vector2(canvasWidth / 2, Math.sin(Math.PI / 3) * canvasWidth * 0.8 + offsetY)
  const vector3 = new Vector2(canvasWidth - offsetX, offsetY)
  const initialVectors = []
  initialVectors.push(vector1)
  initialVectors.push(vector2)
  initialVectors.push(vector3)
  initialVectors.push(vector1)
  const vectors = iterate(initialVectors, steps)
  return drawToCanvas(vectors, canvasWidth, canvasWidth)
}


function drawToCanvas (vectors, canvasWidth, canvasHeight) {
  const canvas = document.createElement('canvas')
  canvas.width = canvasWidth
  canvas.height = canvasHeight

    const ctx = canvas.getContext('2d')
  ctx.beginPath()
  ctx.moveTo(vectors[0].x, vectors[0].y)
  for (let i = 1; i < vectors.length; i++) {
    ctx.lineTo(vectors[i].x, vectors[i].y)
  }
  ctx.stroke()

  return canvas
}

if (typeof window !== 'undefined') {
  const canvas = getKochSnowflake()
  document.body.append(canvas)
}
import { factorial } from '../Factorial'

describe('Factorial', () => {
  it('should return factorial 1 for value "0"', () => {
    expect(factorial(0)).toBe(1)
  })

  it('should return factorial 120 for value "5"', () => {
    expect(factorial(5)).toBe(120)
  })
})
import { fibonacci } from '../FibonacciNumberRecursive'

describe('FibonacciNumberRecursive', () => {
  it('should return 0', () => {
    expect(fibonacci(0)).toBe(0)
  })

  it('should return 1', () => {
    expect(fibonacci(1)).toBe(1)
  })

  it('should return 5', () => {
    expect(fibonacci(5)).toBe(5)
  })

  it('should return 9', () => {
    expect(fibonacci(9)).toBe(34)
  })
})
import { binarySearch } from '../BinarySearch'

describe('BinarySearch', () => {
  const arr = [2, 3, 4, 10, 25, 40, 45, 60, 100, 501, 700, 755, 800, 999]
  const low = 0
  const high = arr.length - 1

  it('should return index 3 for searchValue 10', () => {
    const searchValue = 10
    expect(binarySearch(arr, searchValue, low, high)).toBe(3)
  })

  it('should return index 0 for searchValue 2', () => {
    const searchValue = 2
    expect(binarySearch(arr, searchValue, low, high)).toBe(0)
  })

  it('should return index 13 for searchValue 999', () => {
    const searchValue = 999
    expect(binarySearch(arr, searchValue, low, high)).toBe(13)
  })

  it('should return -1 for searchValue 1', () => {
    const searchValue = 1
    expect(binarySearch(arr, searchValue, low, high)).toBe(-1)
  })

  it('should return -1 for searchValue 1000', () => {
    const searchValue = 1000
    expect(binarySearch(arr, searchValue, low, high)).toBe(-1)
  })
})
import { palindrome } from '../Palindrome'

describe('Palindrome', () => {
  it('expects to return true for palindrome string', () => {
    const isPalindrome = palindrome('madam')
    expect(isPalindrome).toBe(true)
  })

  it('expects to return true for Empty String', () => {
    const isPalindrome = palindrome('')
    expect(isPalindrome).toBe(true)
  })

  it('expects to return false for non-palindrome string', () => {
    const isPalindrome = palindrome('foobar')
    expect(isPalindrome).toBe(false)
  })

  it('Throw Error for Invalid Input', () => {
    expect(() => palindrome(123)).toThrow('Invalid Input')
    expect(() => palindrome(null)).toThrow('Invalid Input')
    expect(() => palindrome(undefined)).toThrow('Invalid Input')
  })
})
import { breadthFirstSearch, depthFirstSearch } from '../FloodFill'

const black = [0, 0, 0]
const green = [0, 255, 0]
const violet = [255, 0, 255]
const white = [255, 255, 255]
const orange = [255, 128, 0]

describe('FloodFill', () => {
  it('should calculate the correct colors using breadth-first approach', () => {
    expect(testBreadthFirst([1, 1], green, orange, [1, 1])).toEqual(orange)
    expect(testBreadthFirst([1, 1], green, orange, [0, 1])).toEqual(violet)
    expect(testBreadthFirst([1, 1], green, orange, [6, 4])).toEqual(white)
  })

  it('should calculate the correct colors using depth-first approach', () => {
    expect(testDepthFirst([1, 1], green, orange, [1, 1])).toEqual(orange)
    expect(testDepthFirst([1, 1], green, orange, [0, 1])).toEqual(violet)
    expect(testDepthFirst([1, 1], green, orange, [6, 4])).toEqual(white)
  })
})


function testBreadthFirst (fillLocation, targetColor, replacementColor, testLocation) {
  const rgbData = generateTestRgbData()
  breadthFirstSearch(rgbData, fillLocation, targetColor, replacementColor)
  return rgbData[testLocation[0]][testLocation[1]]
}


function testDepthFirst (fillLocation, targetColor, replacementColor, testLocation) {  const rgbData = generateTestRgbData()
  depthFirstSearch(rgbData, fillLocation, targetColor, replacementColor)
  return rgbData[testLocation[0]][testLocation[1]]
}


function generateTestRgbData () {
  const layout = [
    [violet, violet, green, green, black, green, green],
    [violet, green, green, black, green, green, green],
    [green, green, green, black, green, green, green],
    [black, black, green, black, white, white, green],
    [violet, violet, black, violet, violet, white, white],
    [green, green, green, violet, violet, violet, violet],
    [violet, violet, violet, violet, violet, violet, violet]
  ]

    const transposed = []
  for (let x = 0; x < layout[0].length; x++) {
    transposed[x] = []
    for (let y = 0; y < layout.length; y++) {
      transposed[x][y] = layout[y][x]
    }
  }

  return transposed
}
import { iterate, Vector2 } from '../KochSnowflake'

describe('KochSnowflake', () => {
  it('should produce the correctly-transformed vectors', () => {
    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[0])
      .toEqual({ x: 0, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[1])
      .toEqual({ x: 1 / 3, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[2])
      .toEqual({ x: 1 / 2, y: Math.sin(Math.PI / 3) / 3 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[3])
      .toEqual({ x: 2 / 3, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[4])
      .toEqual({ x: 1, y: 0 })
  })
})


const palindrome = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Invalid Input')
  }

  if (str.length <= 1) {
    return true
  }

  if (str[0] !== str[str.length - 1]) {
    return false
  } else {
    return palindrome(str.slice(1, str.length - 1))
  }
}

export { palindrome }
/

export const subsequence = (str, seq, low, output = []) => {
  if (low <= str.length && str.length !== 0) {
    output.push(seq)
  }
  for (let i = low; i < str.length; i++) {
    subsequence(str, seq + str[i], i + 1, output)
  }
  return output
}


const neighbors = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]


export function breadthFirstSearch (rgbData, location, targetColor, replacementColor) {
  if (location[0] < 0 ||
    location[0] >= rgbData.length ||
    location[1] < 0 ||
    location[1] >= rgbData[0].length) {
    throw new Error('location should point to a pixel within the rgbData')
  }

  const queue = []
  queue.push(location)

  while (queue.length > 0) {
    breadthFirstFill(rgbData, location, targetColor, replacementColor, queue)
  }
}


export function depthFirstSearch (rgbData, location, targetColor, replacementColor) {
  if (location[0] < 0 ||
    location[0] >= rgbData.length ||
    location[1] < 0 ||
    location[1] >= rgbData[0].length) {
    throw new Error('location should point to a pixel within the rgbData')
  }

  depthFirstFill(rgbData, location, targetColor, replacementColor)
}


function breadthFirstFill (rgbData, location, targetColor, replacementColor, queue) {
  const currentLocation = queue[0]
  queue.shift()

  if (rgbData[currentLocation[0]][currentLocation[1]] === targetColor) {
    rgbData[currentLocation[0]][currentLocation[1]] = replacementColor

    for (let i = 0; i < neighbors.length; i++) {
      const x = currentLocation[0] + neighbors[i][0]
      const y = currentLocation[1] + neighbors[i][1]
      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {
        queue.push([x, y])
      }
    }
  }
}


function depthFirstFill (rgbData, location, targetColor, replacementColor) {
  if (rgbData[location[0]][location[1]] === targetColor) {
    rgbData[location[0]][location[1]] = replacementColor

    for (let i = 0; i < neighbors.length; i++) {
      const x = location[0] + neighbors[i][0]
      const y = location[1] + neighbors[i][1]
      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {
        depthFirstFill(rgbData, [x, y], targetColor, replacementColor)
      }
    }
  }
}



const binarySearch = (arr, searchValue, low = 0, high = arr.length - 1) => {
    if (high < low || arr.length === 0) return -1

  const mid = low + Math.floor((high - low) / 2)

    if (arr[mid] === searchValue) {
    return mid
  }

      if (arr[mid] > searchValue) {
    return binarySearch(arr, searchValue, low, mid - 1)
  }

    return binarySearch(arr, searchValue, mid + 1, high)
}

export { binarySearch }



export class Vector2 {
  constructor (x, y) {
    this.x = x
    this.y = y
  }

  /
  add (vector) {
    const x = this.x + vector.x
    const y = this.y + vector.y
    return new Vector2(x, y)
  }

  /
  subtract (vector) {
    const x = this.x - vector.x
    const y = this.y - vector.y
    return new Vector2(x, y)
  }

  /
  multiply (scalar) {
    const x = this.x * scalar
    const y = this.y * scalar
    return new Vector2(x, y)
  }

  /
  rotate (angleInDegrees) {
    const radians = angleInDegrees * Math.PI / 180
    const ca = Math.cos(radians)
    const sa = Math.sin(radians)
    const x = ca * this.x - sa * this.y
    const y = sa * this.x + ca * this.y
    return new Vector2(x, y)
  }
}


export function iterate (initialVectors, steps) {
  let vectors = initialVectors
  for (let i = 0; i < steps; i++) {
    vectors = iterationStep(vectors)
  }

  return vectors
}


function iterationStep (vectors) {
  const newVectors = []
  for (let i = 0; i < vectors.length - 1; i++) {
    const startVector = vectors[i]
    const endVector = vectors[i + 1]
    newVectors.push(startVector)
    const differenceVector = endVector.subtract(startVector).multiply(1 / 3)
    newVectors.push(startVector.add(differenceVector))
    newVectors.push(startVector.add(differenceVector).add(differenceVector.rotate(60)))
    newVectors.push(startVector.add(differenceVector.multiply(2)))
  }

  newVectors.push(vectors[vectors.length - 1])
  return newVectors
}
/

export const binaryEquivalent = (num) => {
  if (num === 0 || num === 1) {
    return String(num)
  }
  return binaryEquivalent(Math.floor(num / 2)) + String(num % 2)
}


const factorial = (n) => {
  if (n === 0) {
    return 1
  }
  return n * factorial(n - 1)
}

export { factorial }



const fibonacci = (n) => {
  if (n < 2) {
    return n
  }
  return fibonacci(n - 2) + fibonacci(n - 1)
}

export { fibonacci }

const haversineDistance = (latitude1 = 0, longitude1 = 0, latitude2 = 0, longitude2 = 0) => {
  validateLatOrLong(latitude1)
  validateLatOrLong(latitude2)
  validateLatOrLong(longitude1)
  validateLatOrLong(longitude2)
  const earthRadius = 6371e3   const pi = Math.PI
  const cos1 = latitude1 * pi / 180.0
  const cos2 = latitude2 * pi / 180.0
  const deltaLatitude = (latitude2 - latitude1) * pi / 180.0
  const deltaLongitude = (longitude2 - longitude1) * pi / 180.0

  const alpha = Math.sin(deltaLatitude / 2) * Math.sin(deltaLatitude / 2) + Math.cos(cos1) * Math.cos(cos2) * Math.sin(deltaLongitude / 2) * Math.sin(deltaLongitude / 2)
  const constant = 2 * Math.atan2(Math.sqrt(alpha), Math.sqrt(1 - alpha))
  return earthRadius * constant
}

const validateLatOrLong = value => {
  if (typeof value !== 'number') {
    throw new TypeError('The value of latitude or longitude should be a number')
  }
}

export { haversineDistance }
import { haversineDistance } from '../Haversine'

describe('Testing the haversine distance calculator', () => {
  it('Calculate distance', () => {
    const distance = haversineDistance(64.1265, -21.8174, 40.7128, -74.0060)
    expect(distance).toBe(4208198.758424171)
  })
  it('Test validation, expect throw', () => {
    expect(() => haversineDistance(64.1265, -21.8174, 40.7128, '74.0060')).toThrow()
  })
})



const getNumOfDivisors = (num) => {
    let numberOfDivisors = 0

      const sqrtNum = Math.sqrt(num)
  for (let i = 0; i <= sqrtNum; i++) {
        if (num % i === 0) {
      if (i === sqrtNum) {
                numberOfDivisors++
      } else {
                numberOfDivisors += 2
      }
    }
  }
  return numberOfDivisors
}


const firstTriangularWith500Divisors = () => {
  let triangularNum
    for (let n = 1; ; n++) {
        triangularNum = (1 / 2) * n * (n + 1)
    if (getNumOfDivisors(triangularNum) >= 500) return triangularNum
  }
}

export { firstTriangularWith500Divisors }
const SQ5 = 5 ** 0.5 const PHI = (1 + SQ5) / 2 
export const EvenFibonacci = (limit) => {
  const highestIndex = Math.floor(Math.log(limit * SQ5) / Math.log(PHI))
  const n = Math.floor(highestIndex / 3)
  return ((PHI ** (3 * n + 3) - 1) / (PHI ** 3 - 1) -
    ((1 - PHI) ** (3 * n + 3) - 1) / ((1 - PHI) ** 3 - 1)) / SQ5
}



const powerDigitSum = function (n = 2, pow = 1000) {
    
  const digits = [n]
  let p = 1

  while (++p <= pow) {
    let carry = 0
    for (let exp = 0; exp < digits.length; exp++) {
      const prod = digits[exp] * n + carry
      carry = Math.floor(prod / 10)
      digits[exp] = prod % 10
    }
    while (carry > 0) {
      digits.push(carry % 10)
      carry = Math.floor(carry / 10)
    }
  }

  
  return digits.reduce((prev, current) => prev + current, 0)
}

export { powerDigitSum }

export const squareDifference = (num = 100) => {
  let sumOfSquares = 0
  let sums = 0
  for (let i = 1; i <= num; i++) {
    sumOfSquares += i ** 2     sums += i   }
  return (sums ** 2) - sumOfSquares }




function sumOfNonAbundantNumbers (n = 28123) {
  const abundantNumbers = []   const sumOfAbundantNumbers = {}   let sum = 0

  for (let i = 1; i <= n; i++) {
    if (isAbundant(i)) {
      abundantNumbers.push(i)       abundantNumbers.forEach(num => {         const sum = num + i
        sumOfAbundantNumbers[sum] = true
      })
    }
  }

  for (let i = 1; i <= n; i++) {
    if (!sumOfAbundantNumbers[i]) {       sum += i
    }
  }

  return sum
}



function isAbundant (number) {
  let sum = 0
  for (let i = 1; i <= number / 2; i++) {
    if (number % i === 0) {       sum += i     }
  }
  return sum > number
}

export { sumOfNonAbundantNumbers }
import { firstTriangularWith500Divisors } from '../Problem012'

describe('checkFirstTriangularWith500Divisors()', () => {
  it('Problem Statement Answer', () => {
    const firstTriangular = firstTriangularWith500Divisors()
    expect(firstTriangular).toBe(76576500)
  })
})
import { fibonacciIndex } from '../Problem025'

describe('Check Problem 25 - 1000 digit Fibonnaci number', () => {
  it('First term of the Fibonnaci sequence containing 3 digits', () => {
    expect(fibonacciIndex(3)).toBe(12)
  })

  it('First term of the Fibonnaci sequence containing 10 digits', () => {
    expect(fibonacciIndex(10)).toBe(45)
  })

  it('First term of the Fibonnaci sequence containing 50 digits', () => {
    expect(fibonacciIndex(50)).toBe(237)
  })

  it('First term of the Fibonnaci sequence containing 100 digits', () => {
    expect(fibonacciIndex(100)).toBe(476)
  })

  it('First term of the Fibonnaci sequence containing 1000 digits', () => {
    expect(fibonacciIndex(1000)).toBe(4782)
  })

  it('First term of the Fibonnaci sequence containing 10000 digits', () => {
    expect(fibonacciIndex(10000)).toBe(47847)
  })
})
import { largestAdjacentNumber } from '../Problem008'

const grid1 = `73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
38991007832084782777189757278819047278899274961949
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
82834772897718748193457134085784719857638187485919
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
83247832478757285710958372981577583275832789327921
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
84327878357761783787589375857378271083787811983779
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
82347875831098357801578571807585817518287829189189`

const grid2 = `73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450`

const grid3 = `89125732138957892357892768971807934878999818278898
48327483578957875827583295789187588875238579887789
74358275778171870973857835738758275210873583758279
81347834738473878758758373857893758787772897580719
81232847857895758758987587501087575387538183787098
17047878395783578750837100983787587582797837508298
42894789325732857893759187987487489748377578791989
82147328972387832578327581919827382758932789798289
83243289473847328974832947832748932472387895738978
84738294738973289578753287582375238957573297892398
29383748329748397483274832748327477575018978975289
48327483758375846372864736476478364783647463278787
73281473847832974328758975890189373857875875895898
74328978748329789357389578329758329758937893758979
81738957389579287598217589127589375893275987359889
71890743894732897510875895783297591085738975837897
10783974839479879857895789758975981735870175835789
01494787857897583758975849758475107589754897589789
09939858758919788017587897587387585775289757982898
74718478978758758975897589789789798789178957789789`

const grid4 = `99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999`

describe('checkLargestAdjacentNumberProduct', () => {
  it('Random Example', () => {
    const RESULT = largestAdjacentNumber(grid1, 13)
    expect(RESULT).toBe(23514624000)
  })
  it('Problem statement Example', () => {
    const RESULT = largestAdjacentNumber(grid2, 13)
    expect(RESULT).toBe(23514624000)
  })
  it('Random Example 2', () => {
    const RESULT = largestAdjacentNumber(grid3, 13)
    expect(RESULT).toBe(580717154304)
  })
  it('Example with all 9', () => {
    const RESULT = largestAdjacentNumber(grid4, 13)
    expect(RESULT).toBe(2541865828329)
  })
})
import { maxPathSum } from '../Problem018'

const example = `
3
7 4
2 4 6
8 5 9 3
`

describe('Check Problem 18 - Maximum path sum I', () => {
  it('Check example', () => {
    expect(maxPathSum(example)).toBe(23)
  })

  it('Check solution', () => {
    expect(maxPathSum()).toBe(1074)
  })
})
import { calculateSumOfPrimeNumbers } from '../Problem010'

describe('checkAnagram', () => {
  it('Return the sum of prime numbers up to but less than 14', () => {
    const SUT = calculateSumOfPrimeNumbers(14)
    expect(SUT).toBe(41)
  })
  it('Return the sum of prime numbers up to but less than 10', () => {
    const SUT = calculateSumOfPrimeNumbers(10)
    expect(SUT).toBe(17)
  })
  it('Return the sum of prime numbers up to but less than 100', () => {
    const SUT = calculateSumOfPrimeNumbers(100)
    expect(SUT).toBe(1060)
  })
})
import { sumOfNonAbundantNumbers } from '../Problem023'

describe('Check Problem 23 - Non-Abundant Sums', () => {
  it('Sum of all positive integers <= 10000 which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(10000)).toBe(3731004)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(15000)).toBe(4039939)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(20000)).toBe(4159710)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(28123)).toBe(4179871)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(30000)).toBe(4179871)
  })
})
import { powerDigitSum } from '../Problem016'

describe('Check Problem 16 - Power digit sum', () => {
  it('Power digit sum of 2^15', () => {
    expect(powerDigitSum(2, 15)).toBe(26)
  })

  it('Power digit sum of 2^1000', () => {
    expect(powerDigitSum()).toBe(1366)
    expect(powerDigitSum(2, 1000)).toBe(1366)
  })

  it('Power digit sum of 3^5000', () => {
    expect(powerDigitSum(3, 5000)).toBe(11097)
  })
})
import { factorialDigitSum } from '../Problem020'

describe('Check Problem 20 - Factorial digit sum', () => {
  it('Factorial digit sum of 10!', () => {
    expect(factorialDigitSum(10)).toBe(27)
  })

  it('Factorial digit sum of 100!', () => {
    expect(factorialDigitSum()).toBe(648)
    expect(factorialDigitSum(100)).toBe(648)
  })

  it('Factorial digit sum of 1000!', () => {
    expect(factorialDigitSum(1000)).toBe(10539)
  })
})

export const largestPrime = (num = 600851475143) => {
  let newnumm = num
  let largestFact = 0
  let counter = 2
  while (counter * counter <= newnumm) {
    if (newnumm % counter === 0) {
      newnumm = newnumm / counter
    } else {
      counter++
    }
  }
  if (newnumm > largestFact) {
    largestFact = newnumm
  }
  return largestFact
}




const triangle = `
75
95 64
17 47 82
18 35 87 10
20 04 82 47 65
19 01 23 75 03 34
88 02 77 73 07 63 67
99 65 04 28 06 16 70 92
41 41 26 56 83 40 80 70 33
41 48 72 33 47 32 37 16 94 29
53 71 44 65 25 43 91 52 97 51 14
70 11 33 28 77 73 17 78 39 68 17 57
91 71 52 38 17 14 91 43 58 50 27 29 48
63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
`

export const maxPathSum = function (grid = triangle) {
  /

  grid = grid.split(/\r\n|\n/).filter(l => l).map(r => r.split(' ').map(n => +n))

  for (let i = grid.length - 2; i >= 0; i--) {
    for (let j = 0; j < grid[i].length; j++) {
      grid[i][j] += Math.max(grid[i + 1][j], grid[i + 1][j + 1])
    }
  }

  return grid[0][0]
}

const largestAdjacentNumber = (grid, consecutive) => {
  grid = grid.split('\n').join('')
  const splitedGrid = grid.split('\n')
  let largestProd = 0

  for (const row in splitedGrid) {
    const currentRow = splitedGrid[row].split('').map(x => Number(x))

    for (let i = 0; i < currentRow.length - consecutive; i++) {
      const combine = currentRow.slice(i, i + consecutive)

      if (!combine.includes(0)) {
        const product = combine.reduce(function (a, b) {
          return a * b
        })

        if (largestProd < product) largestProd = product
      }
    }
  }
  return largestProd
}

export { largestAdjacentNumber }
/

const isPythagoreanTriplet = (a, b, c) => Math.pow(a, 2) + Math.pow(b, 2) === Math.pow(c, 2)

export const findSpecialPythagoreanTriplet = () => {
  for (let a = 0; a < 1000; a++) {
    for (let b = a + 1; b < 1000; b++) {
      for (let c = b + 1; c < 1000; c++) {
        if (isPythagoreanTriplet(a, b, c) && a + b + c === 1000) {
          return a * b * c
        }
      }
    }
  }
}
/

const getCollatzSequenceLength = (num, seqLength) => {
  if (num === 1) {
    return seqLength
  } else {
    let newElement
    if (num % 2 === 0) {
      newElement = num / 2
    } else {
      newElement = (3 * num) + 1
    }
    seqLength++
    return getCollatzSequenceLength(newElement, seqLength)
  }
}

export const findLongestCollatzSequence = (limit = 1000000) => {
  let startingPointForLargestSequence = 1
  let largestSequenceLength = 1
  for (let i = 2; i < limit; i++) {
    const currentSequenceLength = getCollatzSequenceLength(i, 1)
    if (currentSequenceLength > largestSequenceLength) {
      startingPointForLargestSequence = i
      largestSequenceLength = currentSequenceLength
    }
  }
  return startingPointForLargestSequence
}


const factorialDigitSum = (n = 100) => {
    const digits = [1]

  for (let x = 2; x <= n; x++) {
    let carry = 0
    for (let exp = 0; exp < digits.length; exp++) {
      const prod = digits[exp] * x + carry
      carry = Math.floor(prod / 10)
      digits[exp] = prod % 10
    }
    while (carry > 0) {
      digits.push(carry % 10)
      carry = Math.floor(carry / 10)
    }
  }

  
  return digits.reduce((prev, current) => prev + current, 0)
}

export { factorialDigitSum }
/
export const largestPalindromic = (digits) => {
  let i
  let n
  let m
  let d
  let limit
  let number = 0

  for (i = 1; i < digits; i++) {
    number = 10 * number + 9
  }
  const inf = number   const sup = 10 * number + 9 
  const isPalindromic = (n) => {
    let p = 0
    const q = n
    let r
    while (n > 0) {
      r = n % 10
      p = 10 * p + r
      n = Math.floor(n / 10)
    }
    return p === q   }

  for (n = sup * sup, m = inf * inf; n > m; n--) {
    if (isPalindromic(n)) {
      limit = Math.ceil(Math.sqrt(n))
      d = sup
      while (d >= limit) {
        if (n % d === 0 && n / d > inf) {
          return n
        }
        d -= 1
      }
    }
  }
  return NaN }

const isPrime = (number) => {
  if (number === 2) return true
  if (number % 2 === 0) return false

  for (let j = 3; j * j <= number; j += 2) {
    if (number % j === 0) {
      return false
    }
  }
  return true
}

const calculateSumOfPrimeNumbers = (maxNumber) => {
  let sum = 0
  for (let i = maxNumber - 1; i >= 2; i--) {
    if (isPrime(parseInt(i)) === true) {
      sum += i
    }
  }
  return sum
}
export { calculateSumOfPrimeNumbers }



function fibonacciIndex (t = 1000) {
  const digits = 10n ** BigInt(t - 1)
  let fib0 = BigInt(0)
  let fib1 = BigInt(1)
  let index = 1
  while (fib1 < digits) {     const tempfib = fib1
    fib1 = fib1 + fib0
    fib0 = tempfib
    index += 1
  }
  return (index)
}

export { fibonacciIndex }
/

const multiplesThreeAndFive = (num) => {
  let total = 0
    for (let i = 0; i < num; i++) {
    if (i % 3 === 0 || i % 5 === 0) {
      total += i
    }
  }
  return total
}

export { multiplesThreeAndFive }
/


export const latticePath = (gridSize) => {
  let paths
  for (let i = 1, paths = 1; i <= gridSize; i++) {
    paths = paths * (gridSize + i) / i
  }
    return paths
}

/

export const findSmallestMultiple = () => {
  const divisors = [20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]
  let num = 21
  let result

  while (!result) {
    const isDivisibleByAll = divisors.every((divisor) => num % divisor === 0)
    if (isDivisibleByAll) result = num
    else num++
  }

  return result
}


function slidingWindow (arr, num) {
      if (arr.length < num) return null
    let maxSum = 0
    let tempSum = 0
    for (let i = 0; i < num; i++) {
    maxSum += arr[i]
  }
    tempSum = maxSum
    for (let i = num; i < arr.length; i++) {
        tempSum = tempSum - arr[i - num] + arr[i]
        maxSum = Math.max(maxSum, tempSum)
  }
  return maxSum
}

export { slidingWindow }


function binarySearch (arr, value, floor, ceiling) {
    const mid = Math.floor((floor + ceiling) / 2)

    if (arr[mid] === value) {
    return mid
  }

  if (floor > ceiling) return -1

      if (arr[mid] > value) {
    return binarySearch(arr, value, floor, mid - 1)
          } else {
    return binarySearch(arr, value, mid + 1, ceiling)
  }
}

function exponentialSearch (arr, length, value) {
    if (arr[0] === value) {
    return 0
  }

    let i = 1
  while (i < length && arr[i] <= value) {
    i = i * 2
  }

    return binarySearch(arr, value, i / 2, Math.min(i, length))
}

export { binarySearch, exponentialSearch }

import { exponentialSearch } from '../ExponentialSearch'

test('The Exponential Search of the Array [2, 3, 4, 10, 40, 65, 78, 100] is 6 where the value = 78', () => {
  const arr = [2, 3, 4, 10, 40, 65, 78, 100]
  const value = 78
  const result = exponentialSearch(arr, arr.length, value)
  expect(result).toEqual(6)
})

test('The Exponential Search of the Array [2, 3, 4, 10, 40, 65, 78, 100] is -1 where the value = 178', () => {
  const arr = [2, 3, 4, 10, 40, 65, 78, 100]
  const value = 178
  const result = exponentialSearch(arr, arr.length, value)
  expect(result).toEqual(-1)
})
import { ternarySearchRecursive, ternarySearchIterative } from '../TernarySearch'

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)
  expect(indexNumber).toBe(2)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 8)
  expect(indexNumber).toBe(7)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0)
  expect(indexNumber).toBe(-1)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 12)
  expect(indexNumber).toBe(-1)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Cathrynli')
  expect(indexNumber).toBe(1)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Josuke')
  expect(indexNumber).toBe(2)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Angela')
  expect(indexNumber).toBe(-1)
})
import { binarySearchIterative, binarySearchRecursive } from '../BinarySearch'

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const stringArr = [
  'Alpha',
  'Bravo',
  'Charlie',
  'Delta',
  'Echo',
  'Foxtrot',
  'Golf',
  'Hotel',
  'India',
  'Juliet',
  'Kilo',
  'Lima',
  'Mike',
  'November',
  'Oscar',
  'Papa',
  'Quebec',
  'Romeo',
  'Sierra',
  'Tango',
  'Uniform',
  'Victor',
  'Whiskey',
  'X-Ray',
  'Yankee',
  'Zulu'
]

describe('Binary Search', () => {
  const funcs = [binarySearchIterative, binarySearchRecursive]
  for (const func of funcs) {
    test('expect to return the index of the item in the array', () => {
      expect(func(arr, 3)).toBe(2)
    })
    test('expect to return -1 if not in array', () => {
      expect(func(arr, 11)).toBe(-1)
    })
    test('expect to return the index of the item in the array', () => {
      expect(func(stringArr, 'Charlie')).toBe(2)
    })
    test('expect to return -1 if not in array', () => {
      expect(func(stringArr, 'Zoft')).toBe(-1)
    })
  }
})
import { UnionFind } from '../UnionFind'

const uf = new UnionFind(5)

test('should expose .size():', () => {
  const size = uf.size()
  expect(size).toBe(5)
})

test('should do .union(num1, num2):', () => {
  uf.union(1, 2)
  uf.union(3, 4)
  uf.union(0, 4)
  expect(uf.connected(1, 2)).toBe(true)
  expect(uf.connected(1, 2)).toBe(true)

  expect(uf.connected(3, 4)).toBe(true)
  expect(uf.connected(3, 0)).toBe(true)
  expect(uf.connected(4, 0)).toBe(true)

  expect(uf.connected(1, 3)).toBe(false)
  expect(uf.connected(1, 4)).toBe(false)
  expect(uf.connected(1, 0)).toBe(false)
  expect(uf.connected(2, 3)).toBe(false)
  expect(uf.connected(2, 4)).toBe(false)
  expect(uf.connected(2, 0)).toBe(false)
})

test('.count(), should return the number of disparate groups:', () => {
  expect(uf.count()).toBe(2)
})

test('should check if two components are connected, .connected(num1, num2):', () => {
  expect(uf.connected(1, 2)).toBe(true)
  expect(uf.connected(1, 3)).toBe(false)
})

test('should find the root of the tree in which the given element lives, .find(num):', () => {
  expect(uf.find(1)).toBe(1)
  expect(uf.find(2)).toBe(1)
  expect(uf.find(3)).toBe(3)
  expect(uf.find(4)).toBe(3)
  expect(uf.find(0)).toBe(3)
})

test('should always change the id of the smaller tree and preserve the id of the larger one', () => {
  uf.union(2, 3)
  expect(uf.count()).toBe(1)
  expect(uf.find(0)).toBe(3)
  expect(uf.find(1)).toBe(3)
  expect(uf.find(2)).toBe(3)
  expect(uf.find(3)).toBe(3)
  expect(uf.find(4)).toBe(3)
})
import { slidingWindow } from '../SlidingWindow'

test('expect to return the largest sum of sequence in the array', () => {
  const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 2)
  expect(sum).toBe(10)
})

test('expect to return the largest sum of sequence in the array', () => {
  const sum = slidingWindow([5, 2, 6, 9], 3)
  expect(sum).toBe(17)
})

test('expect to return null when the sequence size is larger then the array length', () => {
  const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 15)
  expect(sum).toBe(null)
})
/
export function quickSelectSearch (array, k) {
  if (!array || array.length <= k) {
    throw new Error('Invalid arguments')
  }

  let from = 0
  let to = array.length - 1
  while (from < to) {
    let left = from
    let right = to
    const pivot = array[Math.ceil((left + right) * 0.5)]

    while (left < right) {
      if (array[left] >= pivot) {
        const tmp = array[left]
        array[left] = array[right]
        array[right] = tmp
        --right
      } else {
        ++left
      }
    }

    if (array[left] > pivot) {
      --left
    }

    if (k <= left) {
      to = left
    } else {
      from = left + 1
    }
  }
  return array
}

/

/
function SearchArray (searchNum, ar, output = v => console.log(v)) {
  const position = Search(ar, searchNum)
  if (position !== -1) {
    output('The element was found at ' + (position + 1))
  } else {
    output('The element not found')
  }
}

function Search (theArray, key) {
  for (let n = 0; n < theArray.length; n++) {
    if (theArray[n] === key) { return n }
  }
  return -1
}

export { SearchArray, Search }

/

function makeTable (str) {
      const table = new Array(str.length)
  let maxPrefix = 0
    table[0] = 0

    for (let i = 1; i < str.length; i++) {
        while (maxPrefix > 0 && str.charAt(i) !== str.charAt(maxPrefix)) {
                  maxPrefix = table[maxPrefix - 1]
    }
        if (str.charAt(maxPrefix) === str.charAt(i)) {
                                          maxPrefix++
          }
    table[i] = maxPrefix
  }
  return table
}

export function stringSearch (str, word) {
    const prefixes = makeTable(word)
  const matches = []

    let j = 0
    let i = 0
  while (i < str.length) {
        if (str.charAt(i) === word.charAt(j)) {
      i++
      j++
    }
                                                if (j === word.length) {
      matches.push(i - j)
      j = prefixes[j - 1]
                } else if (str.charAt(i) !== word.charAt(j)) {
            if (j !== 0) {
        j = prefixes[j - 1]
      } else {
                i++
      }
    }
  }

  return matches
}

/

const jumpSearch = (arr, value) => {
  const length = arr.length
  let step = Math.floor(Math.sqrt(length))
  let lowerBound = 0
  while (arr[Math.min(step, length) - 1] < value) {
    lowerBound = step
    step += step
    if (lowerBound >= length) {
      return -1
    }
  }

  const upperBound = Math.min(step, length)
  while (arr[lowerBound] < value) {
    lowerBound++
    if (lowerBound === upperBound) {
      return -1
    }
  }
  if (arr[lowerBound] === value) {
    return lowerBound
  }
  return -1
}
const arr = [0, 0, 4, 7, 10, 23, 34, 40, 55, 68, 77, 90]
jumpSearch(arr, 4)
jumpSearch(arr, 34)
jumpSearch(arr, 77)

function UnionFind (n, key) {
  if (!(this instanceof UnionFind)) return new UnionFind(n)
  if (key && typeof key !== 'function') {
    throw new Error('key has to be a function or else left undefined')
  }
  let cnt, length
      key = key || function (a) { return a }
  cnt = length = n
  const id = new Array(n)
  const sz = new Array(n)
  for (let i = 0; i < n; i++) {
    id[i] = i
    sz[i] = 1
  }
    this.size = function () {
    return length
  }
    this.count = function () {
    return cnt
  }
    this.find = function (p) {
    p = key(p)
    while (p !== id[p]) {
      id[p] = id[id[p]]
      p = id[p]
    }
    return p
  }
    this.connected = function (p, q) {
    p = key(p)
    q = key(q)
    ensureIndexWithinBounds(p, q)
    return this.find(p) === this.find(q)
  }
    this.union = function (p, q) {
    p = key(p)
    q = key(q)
    ensureIndexWithinBounds(p, q)
    const i = this.find(p)
    const j = this.find(q)
    if (i === j) return
    if (sz[i] < sz[j]) {
      id[i] = j; sz[j] += sz[i]
    } else {
      id[j] = i; sz[i] += sz[j]
    }
    cnt--
  }
  function ensureIndexWithinBounds (args) {
    for (let i = arguments.length - 1; i >= 0; i--) {
      const p = arguments[i]
      if (p >= length) throw new Error('Index out of bounds. The maximum index can be length-1')
    }
  }
}

export { UnionFind }
/

function binarySearchRecursive (arr, x, low = 0, high = arr.length - 1) {
  const mid = Math.floor(low + (high - low) / 2)

  if (high >= low) {
    if (arr[mid] === x) {
            return mid
    }

    if (x < arr[mid]) {
            return binarySearchRecursive(arr, x, low, mid - 1)
    } else {
            return binarySearchRecursive(arr, x, mid + 1, high)
    }
  } else {
        return -1
  }
}
function binarySearchIterative (arr, x, low = 0, high = arr.length - 1) {
  while (high >= low) {
    const mid = Math.floor(low + (high - low) / 2)

    if (arr[mid] === x) {
            return mid
    }

    if (x < arr[mid]) {
            high = mid - 1
    } else {
            low = mid + 1
    }
  }
    return -1
}

export { binarySearchIterative, binarySearchRecursive }


export function interpolationSearch (arr, key) {
  const length = arr.length - 1
  let low = 0
  let high = length
  let position = -1
  let delta = -1

    while (low <= high && key >= arr[low] && key <= arr[high]) {
    delta = (key - arr[low]) / (arr[high] - arr[low])
    position = low + Math.floor((high - low) * delta)

        if (arr[position] === key) {
      return position
    }

        if (arr[position] < key) {
      low = position + 1
          } else {
      high = position - 1
    }
  }

  return -1
}


/

function ternarySearchRecursive (arr, key, low = 0, high = arr.length - 1) {
  if (high >= low) {
        const mid1 = Math.floor(low + (high - low) / 3)
    const mid2 = Math.floor(high - (high - low) / 3)

        if (arr[mid1] === key) {
            return mid1
    }
    if (arr[mid2] === key) {
            return mid2
    }

                    if (key < arr[mid1]) {
            return ternarySearchRecursive(arr, key, low, mid1 - 1)
    } else if (key > arr[mid2]) {
            return ternarySearchRecursive(arr, key, mid2 + 1, high)
    } else {
            return ternarySearchRecursive(arr, key, mid1 + 1, mid2 - 1)
    }
  } else {
        return -1
  }
}

function ternarySearchIterative (arr, key, low = 0, high = arr.length - 1) {
  while (high >= low) {
        const mid1 = Math.floor(low + (high - low) / 3)
    const mid2 = Math.floor(high - (high - low) / 3)

        if (arr[mid1] === key) {
            return mid1
    }
    if (arr[mid2] === key) {
            return mid2
    }

                    if (key < arr[mid1]) {
            high = mid1 - 1
    } else if (key > arr[mid2]) {
            low = mid2 + 1
    } else {
            low = mid1 + 1
      high = mid2 - 1
    }
  }
    return -1
}

export { ternarySearchRecursive, ternarySearchIterative }


export const fibonacciSearch = (arr, x, n) => {
  let fib2 = 0   let fib1 = 1   let fibK = fib2 + fib1 
  /
  while (fibK < n) {
    fib2 = fib1
    fib1 = fibK
    fibK = fib2 + fib1
  }
    let offset = -1

  /

  while (fibK > 1) {
        const i = Math.min(offset + fib2, n - 1)

    /
    if (arr[i] < x) {
      fibK = fib1
      fib1 = fib2
      fib2 = fibK - fib1
      offset = i
      /
    } else if (arr[i] > x) {
      fibK = fib2
      fib1 = fib1 - fib2
      fib2 = fibK - fib1
    } else {
          return i
    }
  }

    if (fib1 && arr[offset + 1] === x) {
    return offset + 1
  }
    return -1
}


const fibonacci = (N) => {
  if (!Number.isInteger(N)) {
    throw new TypeError('Input should be integer')
  }

    let firstNumber = 0
  let secondNumber = 1

  for (let i = 1; i < N; i++) {
    const sumOfNumbers = firstNumber + secondNumber
        firstNumber = secondNumber
    secondNumber = sumOfNumbers
  }

  return N ? secondNumber : firstNumber
}

export { fibonacci }
/
/
function NumberOfSubsetSum (array, sum) {
  const dp = []   for (let i = 1; i <= sum; i++) {
    dp[i] = 0
  }
  dp[0] = 1 
  for (let i = 0; i < array.length; i++) {
    for (let j = sum; j >= array[i]; j--) {
      if (j - array[i] >= 0) {
        dp[j] += dp[j - array[i]]
      }
    }
  }
  return dp[sum]
}



export { NumberOfSubsetSum }
/

const minimumEditDistance = (word1, word2) => {
  const n = word1.length
  const m = word2.length
  const dp = new Array(m + 1).fill(0).map(item => [])

  /

  for (let i = 0; i < n + 1; i++) {
    dp[0][i] = i
  }

  for (let i = 0; i < m + 1; i++) {
    dp[i][0] = i
  }

  /

  for (let i = 1; i < m + 1; i++) {
    for (let j = 1; j < n + 1; j++) {
      const letter1 = word1[j - 1]
      const letter2 = word2[i - 1]

      if (letter1 === letter2) {
        dp[i][j] = dp[i - 1][j - 1]
      } else {
        dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1
      }
    }
  }

  return dp[m][n]
}

export { minimumEditDistance }
/
function shuf (datasetSource, sampleSize) {
  const output = fillBaseSample(datasetSource, sampleSize)

  return randomizeOutputFromDataset(datasetSource, output)
}


function fillBaseSample (datasetSource, sampleSize) {
  let filledIndexes = []
  let output = new Array(sampleSize)

    while (true) {
    const iterator = datasetSource.next()
    if (iterator.done) break

    let insertTo = Math.floor(Math.random() * output.length)
    while (filledIndexes.includes(insertTo)) {
      insertTo++
      if (insertTo === output.length) {
        insertTo = 0
      }
    }
    output[insertTo] = {
      value: iterator.value
    }

    filledIndexes = [...filledIndexes, insertTo]

    if (filledIndexes.length === sampleSize) {
      break
    }
  }

  if (filledIndexes.length < output.length) {
        output = output.filter((_, i) => filledIndexes.includes(i))
  }

  return output.map((o) => o.value)
}


function randomizeOutputFromDataset (datasetSource, output) {
  const newOutput = [...output]
  let readSoFar = output.length

  while (true) {
    const iterator = datasetSource.next()
    if (iterator.done) break
    readSoFar++

    const insertTo = Math.floor(Math.random() * readSoFar)
    if (insertTo < newOutput.length) {
      newOutput[insertTo] = iterator.value
    }
  }

  return newOutput
}



function * generateRandomData (length) {
  const maxValue = Math.pow(2, 31) - 1
  for (let i = 0; i < length; i++) {
    yield Math.floor(Math.random() * maxValue)
  }
}


export { shuf, generateRandomData }
import { PermutationinString } from '../PermutationinString.js'

describe('PermutationinString', () => {
  it("should  return true if one of s1's permutations is the substring of s2", () => {
    expect(PermutationinString('ab', 'eidbaooo')).toEqual(true)
    expect(PermutationinString('abc', 'bcab')).toEqual(true)
    expect(PermutationinString('ab', 'eidboaoo')).toEqual(false)
    expect(PermutationinString('abc', '')).toEqual(false)
  })
})
import { LongestSubstringWithoutRepeatingCharacters } from '../LongestSubstringWithoutRepeatingCharacters.js'

describe('LongestSubstringWithoutRepeatingCharacters', () => {
  it('should return longest substring without repeating characters', () => {
    expect(LongestSubstringWithoutRepeatingCharacters('abcabcbb')).toEqual(3)
    expect(LongestSubstringWithoutRepeatingCharacters('bbbbb')).toEqual(1)
    expect(LongestSubstringWithoutRepeatingCharacters('pwwkew')).toEqual(3)
    expect(LongestSubstringWithoutRepeatingCharacters('a')).toEqual(1)
    expect(LongestSubstringWithoutRepeatingCharacters('')).toEqual(0)
  })
})



export function PermutationinString (s1, s2) {
  if (s1.length > s2.length) return false
  let start = 0
  let end = s1.length - 1
  const s1Set = SetHash()
  const s2Set = SetHash()
  for (let i = 0; i < s1.length; i++) {
    s1Set[s1[i]]++
    s2Set[s2[i]]++
  }
  if (equals(s1Set, s2Set)) return true
  while (end < s2.length - 1) {
    if (equals(s1Set, s2Set)) return true
    end++
    const c1 = s2[start]
    const c2 = s2[end]
    if (s2Set[c1] > 0) s2Set[c1]--
    s2Set[c2]++
    start++
    if (equals(s1Set, s2Set)) return true
  }
  return false
}
function equals (a, b) {
  return JSON.stringify(a) === JSON.stringify(b)
}

function SetHash () {
  const set = new Set()
  const alphabets = 'abcdefghijklmnopqrstuvwxyz'
  for (let i = 0; i < alphabets.length; i++) {
    set[alphabets[i]] = 0
  }
  return set
}





export function LongestSubstringWithoutRepeatingCharacters (s) {
  let maxLength = 0
  let start = 0
  let end = 0
  const map = {}
  while (end < s.length) {
    if (map[s[end]] === undefined) {
      map[s[end]] = 1
      maxLength = Math.max(maxLength, end - start + 1)
      end++
    } else {
      while (s[start] !== s[end]) {
        delete map[s[start]]
        start++
      }
      delete map[s[start]]
      start++
    }
  }
  return maxLength
}





const zeroOneKnapsack = (arr, n, cap, cache) => {
  if (cap === 0 || n === 0) {
    cache[n][cap] = 0
    return cache[n][cap]
  }
  if (cache[n][cap] !== -1) {
    return cache[n][cap]
  }
  if (arr[n - 1][0] <= cap) {
    cache[n][cap] = Math.max(arr[n - 1][1] + zeroOneKnapsack(arr, n - 1, cap - arr[n - 1][0], cache), zeroOneKnapsack(arr, n - 1, cap, cache))
    return cache[n][cap]
  } else {
    cache[n][cap] = zeroOneKnapsack(arr, n - 1, cap, cache)
    return cache[n][cap]
  }
}

const example = () => {
  /
  let input = `1
    4 5
    1 8
    2 4
    3 0
    2 5
    2 3`

  input = input.trim().split('\n')
  input.shift()
  const length = input.length

  const output = []

  let i = 0
  while (i < length) {
    const cap = Number(input[i].trim().split(' ')[0])
    const currlen = Number(input[i].trim().split(' ')[1])
    let j = i + 1
    const arr = []
    while (j <= i + currlen) {
      arr.push(input[j])
      j++
    }
    const newArr = arr.map(e =>
      e.trim().split(' ').map(Number)
    )
    const cache = []
    for (let i = 0; i <= currlen; i++) {
      const temp = []
      for (let j = 0; j <= cap; j++) {
        temp.push(-1)
      }
      cache.push(temp)
    }
    const result = zeroOneKnapsack(newArr, currlen, cap, cache)
    output.push(result)
    i += currlen + 1
  }

  return output
}

export { zeroOneKnapsack, example }

const isValid = (board, row, col, k) => {
  for (let i = 0; i < 9; i++) {
    const m = 3 * Math.floor(row / 3) + Math.floor(i / 3)
    const n = 3 * Math.floor(col / 3) + i % 3
    if (board[row][i] === k || board[i][col] === k || board[m][n] === k) {
      return false
    }
  }
  return true
}

const sudokuSolver = (data) => {
  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 9; j++) {
      if (data[i][j] === '.') {
        for (let k = 1; k <= 9; k++) {
          if (isValid(data, i, j, `${k}`)) {
            data[i][j] = `${k}`
            if (sudokuSolver(data)) {
              return true
            } else {
              data[i][j] = '.'
            }
          }
        }
        return false
      }
    }
  }
  return true
}



export { sudokuSolver }

const tribonacci = (n) => {
    const dp = new Array(n + 1)
  dp[0] = 0
  dp[1] = 1
  dp[2] = 1
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
  }
  return dp[n]
}

export { tribonacci }


const climbStairs = (n) => {
  let prev = 0
  let cur = 1
  let temp

  for (let i = 0; i < n; i++) {
    temp = prev
    prev = cur
    cur += temp
  }
  return cur
}

export { climbStairs }
import { tribonacci } from '../TribonacciNumber'

describe('TribonacciNumber', () => {
  it('tribonacci of 0', () => {
    expect(tribonacci(0)).toBe(0)
  })

  it('tribonacci of 1', () => {
    expect(tribonacci(1)).toBe(1)
  })

  it('tribonacci of 2', () => {
    expect(tribonacci(2)).toBe(1)
  })

  it('tribonacci of 10', () => {
    expect(tribonacci(10)).toBe(149)
  })

  it('tribonacci of 25', () => {
    expect(tribonacci(25)).toBe(1389537)
  })
})
import { kadaneAlgo } from '../KadaneAlgo'
test('it is being checked that 15 is the answer to the corresponding array input', () => {
  expect(kadaneAlgo([1, 2, 3, 4, 5])).toBe(15)
})

test('it is being checked that 5 is the answer to the corresponding array input', () => {
  expect(kadaneAlgo([-1, -2, -3, -4, 5])).toBe(5)
})
import { trap } from '../TrappingRainWater'

describe('TrappingRainWater', () => {
  it('expects 6 units of rain water are being trapped', () => {
    expect(trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6)
  })

  it('expects 9 units of rain water are being trapped', () => {
    expect(trap([4, 2, 0, 3, 2, 5])).toBe(9)
  })
})
import { maxProductOfThree } from '../MaxProductOfThree'

describe('MaxProductOfThree', () => {
  it('expects to throw error for array with only 2 numbers', () => {
    expect(() => {
      maxProductOfThree([1, 3])
    }).toThrow('Triplet cannot exist with the given array')
  })

  it('expects to return 300 as the maximum product', () => {
    expect(maxProductOfThree([10, 6, 5, 3, 1, -10])).toBe(300)
  })

  it('expects to return 300 as the maximum product', () => {
    expect(maxProductOfThree([10, -6, 5, 3, 1, -10])).toBe(600)
  })
})
import { change, coinChangeMin } from '../CoinChange'

test('Base Case 1', () => {
  const coins = [2, 3, 5]
  const amount = 0
  expect(change(coins, amount)).toBe(1)
  expect(coinChangeMin(coins, amount)).toBe(0)
})
test('Base Case 2', () => {
  const coins = []
  const amount = 100
  expect(change(coins, amount)).toBe(0)
  expect(coinChangeMin(coins, amount)).toBe(-1)
})
test('Test Case 1', () => {
  const coins = [2, 4, 5]
  const amount = 12
  expect(change(coins, amount)).toBe(5)
  expect(coinChangeMin(coins, amount)).toBe(3)
})
test('Test Case 2', () => {
  const coins = [5, 2, 3, 7, 6, 1, 12, 11, 9, 15]
  const amount = 45
  expect(change(coins, amount)).toBe(12372)
  expect(coinChangeMin(coins, amount)).toBe(3)
})
test('Test Case 3', () => {
  const coins = [2]
  const amount = 3
  expect(change(coins, amount)).toBe(0)
  expect(coinChangeMin(coins, amount)).toBe(-1)
})
test('Test Case 4', () => {
  const coins = [3, 5, 7, 8, 9, 10, 11]
  const amount = 500
  expect(change(coins, amount)).toBe(35502874)
  expect(coinChangeMin(coins, amount)).toBe(46)
})
test('Test Case 5', () => {
  const coins = [10]
  const amount = 10
  expect(change(coins, amount)).toBe(1)
  expect(coinChangeMin(coins, amount)).toBe(1)
})
import { sieveOfEratosthenes } from '../SieveOfEratosthenes'

describe('SieveOfEratosthenes', () => {
  it('Primes till 0', () => {
    expect(sieveOfEratosthenes(0)).toEqual([])
  })

  it('Primes till 1', () => {
    expect(sieveOfEratosthenes(1)).toEqual([])
  })

  it('Primes till 10', () => {
    expect(sieveOfEratosthenes(10)).toEqual([2, 3, 5, 7])
  })

  it('Primes till 23', () => {
    expect(sieveOfEratosthenes(23)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23])
  })

  it('Primes till 70', () => {
    expect(sieveOfEratosthenes(70)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67])
  })
})
import { longestPalindromeSubsequence } from '../LongestPalindromicSubsequence'

describe('LongestPalindromicSubsequence', () => {
  it('expects to return 1 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('abcdefgh')).toBe(1)
  })

  it('expects to return 4 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('bbbab')).toBe(4)
  })

  it('expects to return 2 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('cbbd')).toBe(2)
  })

  it('expects to return 7 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('racexyzcxar')).toBe(7)
  })
})
import { longestValidParentheses } from '../LongestValidParentheses'

describe('longestValidParentheses', () => {
  it('expects to return 0 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('')).toBe(0)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('(()')).toBe(2)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses(')()())')).toBe(4)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('(((')).toBe(0)
  })
})
import { longestCommonSubsequence } from '../LongestCommonSubsequence'

describe('LongestCommonSubsequence', () => {
  it('expects to return an empty string for empty inputs', () => {
    expect(longestCommonSubsequence('', '')).toEqual(''.length)
    expect(longestCommonSubsequence('aaa', '')).toEqual(''.length)
    expect(longestCommonSubsequence('', 'bbb')).toEqual(''.length)
  })

  it('expects to return an empty string for inputs without a common subsequence', () => {
    expect(longestCommonSubsequence('abc', 'deffgf')).toEqual(''.length)
    expect(longestCommonSubsequence('de', 'ghm')).toEqual(''.length)
    expect(longestCommonSubsequence('aupj', 'xyz')).toEqual(''.length)
  })

  it('expects to return the longest common subsequence, short inputs', () => {
    expect(longestCommonSubsequence('abc', 'abc')).toEqual('abc'.length)
    expect(longestCommonSubsequence('abc', 'abcd')).toEqual('abc'.length)
    expect(longestCommonSubsequence('abc', 'ab')).toEqual('ab'.length)
    expect(longestCommonSubsequence('abc', 'a')).toEqual('a'.length)
    expect(longestCommonSubsequence('abc', 'b')).toEqual('b'.length)
    expect(longestCommonSubsequence('abc', 'c')).toEqual('c'.length)
    expect(longestCommonSubsequence('abd', 'abcd')).toEqual('abd'.length)
    expect(longestCommonSubsequence('abd', 'ab')).toEqual('ab'.length)
    expect(longestCommonSubsequence('abc', 'abd')).toEqual('ab'.length)
  })

  it('expects to return the longest common subsequence, medium-length inputs', () => {
    expect(longestCommonSubsequence('bsbininm', 'jmjkbkjkv')).toEqual('b'.length)
    expect(longestCommonSubsequence('oxcpqrsvwf', 'shmtulqrypy')).toEqual('qr'.length)
  })
})
import { rodCut } from '../RodCutting'

test('Test Case 1', () => {
  expect(rodCut([1, 5, 8, 9, 10, 17, 17, 20], 8)).toBe(22)
})

test('Test Case 2', () => {
  expect(rodCut([1, 5, 4, 2, 1, 11, 19, 12], 8)).toBe(20)
})

test('Test Case 3', () => {
  expect(rodCut([1, 2, 1], 3)).toBe(3)
})

test('Test Case 4', () => {
  expect(rodCut([5, 4, 3, 2, 1], 5)).toBe(25)
})

test('Test Case 5', () => {
  expect(rodCut([3, 5, 8, 8, 10, 16, 14, 19], 8)).toBe(24)
})
import { fibonacci } from '../FibonacciNumber'

describe('Testing FibonacciNumber', () => {
  it('Testing for invalid type', () => {
    expect(() => fibonacci('0')).toThrowError()
    expect(() => fibonacci('12')).toThrowError()
    expect(() => fibonacci(true)).toThrowError()
  })

  it('fibonacci of 0', () => {
    expect(fibonacci(0)).toBe(0)
  })

  it('fibonacci of 1', () => {
    expect(fibonacci(1)).toBe(1)
  })

  it('fibonacci of 10', () => {
    expect(fibonacci(10)).toBe(55)
  })

  it('fibonacci of 25', () => {
    expect(fibonacci(25)).toBe(75025)
  })
})
import { climbStairs } from '../ClimbingStairs'

describe('ClimbingStairs', () => {
  it('climbStairs of 0', () => {
    expect(climbStairs(0)).toBe(1)
  })

  it('climbStairs of 1', () => {
    expect(climbStairs(1)).toBe(1)
  })

  it('climbStairs of 10', () => {
    expect(climbStairs(10)).toBe(89)
  })

  it('climbStairs of 15', () => {
    expect(climbStairs(15)).toBe(987)
  })
})


/

export const trap = (heights) => {
  const maxes = new Array(heights.length).fill(0)

  let leftMax = 0
  for (let i = 0; i < heights.length; i++) {
    const height = heights[i]
    maxes[i] = leftMax
    leftMax = Math.max(leftMax, height)
  }

  let rightMax = 0
  for (let i = heights.length - 1; i >= 0; i -= 1) {
    const height = heights[i]
    const minHeight = Math.min(rightMax, maxes[i])

    if (height < minHeight) {
      maxes[i] = minHeight - height
    } else {
      maxes[i] = 0
    }
    rightMax = Math.max(rightMax, height)
  }
  return maxes.reduce((a, b) => a + b, 0)
}
/


function longestCommonSubsequence (str1, str2) {
  const memo = new Array(str1.length + 1).fill(null)
    .map(() => new Array(str2.length + 1).fill(null))

  function recursive (end1, end2) {
    if (end1 === -1 || end2 === -1) {
      return 0
    }

    if (memo[end1][end2] !== null) {
      return memo[end1][end2]
    }

    if (str1[end1] === str2[end2]) {
      memo[end1][end2] = 1 + recursive(end1 - 1, end2 - 1)
      return memo[end1][end2]
    } else {
      memo[end1][end2] = Math.max(
        recursive(end1 - 1, end2),
        recursive(end1, end2 - 1)
      )
      return memo[end1][end2]
    }
  }

  return recursive(str1.length - 1, str2.length - 1)
}

export { longestCommonSubsequence }

export function maxProductOfThree (arrayItems) {
    const n = arrayItems.length
  if (n < 3) throw new Error('Triplet cannot exist with the given array')
  let max1 = arrayItems[0]
  let max2 = -1
  let max3 = -1
  let min1 = arrayItems[0]
  let min2 = -1
  for (let i = 1; i < n; i++) {
    if (arrayItems[i] > max1) {
      max3 = max2
      max2 = max1
      max1 = arrayItems[i]
    } else if (max2 === -1 || arrayItems[i] > max2) {
      max3 = max2
      max2 = arrayItems[i]
    } else if (max3 === -1 || arrayItems[i] > max3) {
      max3 = arrayItems[i]
    }
    if (arrayItems[i] < min1) {
      min2 = min1
      min1 = arrayItems[i]
    } else if (min2 === -1 || arrayItems[i] < min2) {
      min2 = arrayItems[i]
    }
  }
  const prod1 = max1 * max2 * max3
  const prod2 = max1 * min1 * min2
  return Math.max(prod1, prod2)
}

function sieveOfEratosthenes (n) {
  if (n <= 1) return []
  const primes = new Array(n + 1).fill(true)   primes[0] = primes[1] = false   for (let i = 2; i * i <= n; i++) {
    if (primes[i]) {
      for (let j = i * i; j <= n; j += i) {
        primes[j] = false
      }
    }
  }

  return primes.reduce((result, isPrime, index) => {
    if (isPrime) {
      result.push(index)
    }
    return result
  }, [])
}



export { sieveOfEratosthenes }
/

export const longestPalindromeSubsequence = function (s) {
  const n = s.length

  const dp = new Array(n).fill(0).map(item => new Array(n).fill(0).map(item => 0))

    for (let i = 0; i < n; i++) {
    dp[i][i] = 1
  }

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < n - i; j++) {
      const col = j + i
      if (s[j] === s[col]) {
        dp[j][col] = 2 + dp[j + 1][col - 1]
      } else {
        dp[j][col] = Math.max(dp[j][col - 1], dp[j + 1][col])
      }
    }
  }

  return dp[0][n - 1]
}

const minCostPath = (matrix) => {
  /

  const n = matrix.length
  const m = matrix[0].length

    const moves = new Array(n)
  for (let i = 0; i < moves.length; i++) moves[i] = new Array(m)

    moves[0][0] = matrix[0][0]   for (let i = 1; i < m; i++) moves[0][i] = moves[0][i - 1] + matrix[0][i]
  for (let i = 1; i < n; i++) moves[i][0] = moves[i - 1][0] + matrix[i][0]

  for (let i = 1; i < n; i++) {
    for (let j = 1; j < m; j++) { moves[i][j] = Math.min(moves[i - 1][j], moves[i][j - 1]) + matrix[i][j] }
  }

  return moves[n - 1][m - 1]
}

export { minCostPath }



/

export function kadaneAlgo (array) {
  let cummulativeSum = 0
  let maxSum = Number.NEGATIVE_INFINITY   for (let i = 0; i < array.length; i++) {
    cummulativeSum = cummulativeSum + array[i]
    if (maxSum < cummulativeSum) {
      maxSum = cummulativeSum
    } else if (cummulativeSum < 0) {
      cummulativeSum = 0
    }
  }
  return maxSum
  }
function maximumNonAdjacentSum (nums) {
  /

  if (nums.length < 0) return 0

  let maxIncluding = nums[0]
  let maxExcluding = 0

  for (const num of nums.slice(1)) {
    const temp = maxIncluding
    maxIncluding = maxExcluding + num
    maxExcluding = Math.max(temp, maxExcluding)
  }

  return Math.max(maxExcluding, maxIncluding)
}



export { maximumNonAdjacentSum }


function minimum (a, b, c) {
  if (a < b && a < c) {
    return a
  } else if (b < a && b < c) {
    return b
  } else {
    return c
  }
}

function costOfSubstitution (x, y) {
  return x === y ? 0 : 1
}

function calculate (x, y) {
  const dp = new Array(x.length + 1)
  for (let i = 0; i < x.length + 1; i++) {
    dp[i] = new Array(y.length + 1)
  }

  for (let i = 0; i < x.length + 1; i++) {
    for (let j = 0; j < y.length + 1; j++) {
      if (i === 0) {
        dp[i][j] = j
      } else if (j === 0) {
        dp[i][j] = i
      } else {
        dp[i][j] = minimum(dp[i - 1][j - 1] + costOfSubstitution(x.charAt(i - 1), y.charAt(j - 1)), dp[i - 1][j] + 1, dp[i][j - 1] + 1)
      }
    }
  }

  return dp[x.length][y.length]
}

export { calculate }


function longestIncreasingSubsequence (x) {
  const length = x.length
  const dp = Array(length).fill(1)

  let res = 1

  for (let i = 0; i < length; i++) {
    for (let j = 0; j < i; j++) {
      if (x[i] > x[j]) {
        dp[i] = Math.max(dp[i], 1 + dp[j])
        if (dp[i] > res) {
          res = dp[i]
        }
      }
    }
  }

  return res
}

export { longestIncreasingSubsequence }
/

export function rodCut (prices, n) {
  const memo = new Array(n + 1)
  memo[0] = 0

  for (let i = 1; i <= n; i++) {
    let maxVal = Number.MIN_VALUE
    for (let j = 0; j < i; j++) { maxVal = Math.max(maxVal, prices[j] + memo[i - j - 1]) }
    memo[i] = maxVal
  }

  return memo[n]
}
/

export const longestValidParentheses = (s) => {
  const n = s.length
  const stack = []

    const res = new Array(n).fill(-Infinity)

  for (let i = 0; i < n; i++) {
    const bracket = s[i]

    if (bracket === ')' && s[stack[stack.length - 1]] === '(') {
      res[i] = 1
      res[stack[stack.length - 1]] = 1
      stack.pop()
    } else {
      stack.push(i)
    }
  }

    for (let i = 1; i < n; i++) {
    res[i] = Math.max(res[i], res[i] + res[i - 1])
  }

    res.push(0)
  return Math.max(...res)
}

export const change = (coins, amount) => {
    const combinations = new Array(amount + 1).fill(0)
  combinations[0] = 1
    for (let i = 0; i < coins.length; i++) {
        for (let j = coins[i]; j < combinations.length; j++) {
      combinations[j] += combinations[j - coins[i]]
    }
  }
  return combinations[amount]
}

export const coinChangeMin = (coins, amount) => {
  const map = { 0: 1 }
  for (let i = 1; i <= amount; i++) {
    let min = Infinity
    for (const coin of coins) {
      if (i < coin) continue
      min = Math.min(min, 1 + map[i - coin])
    }
    map[i] = min
  }
  return map[amount] === Infinity ? -1 : map[amount] - 1
}
/

class Month {
  constructor () {
    this.Days = ['M', 'T', 'W', 'Th', 'F', 'S', 'Su']
    this.BDays = ['M', 'Su', 'S', 'F', 'Th', 'W', 'T']
    this.epoch = { month: 1, year: 1900 }
    this.monthDays = [31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    this.monthDaysLeap = [31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  }

  printCal (days, startDay, output = value => console.log(value)) {
    output('M   T   W   Th  F   S   Su')
    const dates = []; let i
    for (i = 1; i <= days; i++) {
      dates.push(i)
    }
    for (i = 0; i < this.Days.indexOf(startDay); i++) {
      dates.unshift(' ')
    }
    while (true) {
      let row = ''
      for (i = 0; (i < 7) && (dates.length !== 0); i++) {
        row += dates.shift()
        while ((row.length % 4) !== 0) {
          row += ' '
        }
      }
      output(row)
      if (dates.length === 0) break
    }
  }

  parseDate (date) {
    const dateAr = []; let block = ''; let i
    for (i = 0; i < date.length; i++) {
      if (date[i] === '/') {
        dateAr.push(parseInt(block))
        block = ''
        continue
      }
      block += date[i]
    }
    dateAr.push(parseInt(block))
    if (dateAr.length !== 2) throw new Error('Improper string encoding')
    const dateOb = { month: dateAr[0], year: dateAr[1] }
    return dateOb
  }

  isLeapYear (year) {
    if (((year % 400) === 0) || (((year % 100) !== 0) && ((year % 4) === 0))) return true
    return false
  }

  isGreater (startDate, endDate) {
    if (startDate.year > endDate.year) {
      return true
    } else if (startDate.year < endDate.year) {
      return false
    } else if (startDate.month > endDate.month) {
      return true
    } else if (startDate.month < endDate.month) {
      return false
    }
    return true
  }

  getDayDiff (startDate, endDate) {
    if (this.isGreater(startDate, endDate) === null) {
      return 0
    } else if ((this.isGreater(startDate, endDate) === true)) {
      const midDate = startDate
      startDate = endDate
      endDate = midDate
    }
    let diff = 0
    while (startDate.year !== endDate.year) {
      diff += (this.isLeapYear(startDate.year)) ? 366 : 365
      startDate.year = startDate.year + 1
    }
    while (startDate.month !== endDate.month) {
      if (startDate.month < endDate.month) {
        if (this.isLeapYear(startDate.year)) diff += this.monthDaysLeap[startDate.month]
        else diff += this.monthDays[startDate.month]
        startDate.month = startDate.month + 1
      } else {
        if (this.isLeapYear(startDate.year)) diff -= this.monthDaysLeap[startDate.month - 1]
        else diff -= this.monthDays[startDate.month - 1]
        startDate.month = startDate.month - 1
      }
    }
    return diff
  }

  generateMonthCal (date) {
    const Month = this.parseDate(date); let day = ''
    let difference = this.getDayDiff(this.epoch, Month)
    difference = difference % 7
    let Month2 = this.parseDate(date)
    day = (this.isGreater(Month2, this.epoch)) ? this.Days[difference] : this.BDays[difference]
    Month2 = this.parseDate(date)
    if (this.isLeapYear(Month2.year)) this.printCal(this.monthDaysLeap[Month2.month], day)
    else this.printCal(this.monthDays[Month2.month], day)
  }
}

export { Month }


const XORCipher = (str, key) => {
  if (typeof str !== 'string' || !Number.isInteger(key)) {
    throw new TypeError('Arguments type are invalid')
  }

  return str.replace(
    /./g, (char) => String.fromCharCode(char.charCodeAt() ^ key)
  )
}

export default XORCipher
import caesarsCipher from '../CaesarsCipher'

describe('Testing the caesarsCipher function', () => {
  it('Test - 1, Testing for invalid types', () => {
    expect(() => caesarsCipher(false, 3)).toThrow()
    expect(() => caesarsCipher('false', -1)).toThrow()
    expect(() => caesarsCipher('true', null)).toThrow()
  })

  it('Test - 2, Testing for valid string and rotation', () => {
    expect(caesarsCipher('middle-Outz', 2)).toBe('okffng-Qwvb')
    expect(caesarsCipher('abcdefghijklmnopqrstuvwxyz', 3)).toBe('defghijklmnopqrstuvwxyzabc')
    expect(caesarsCipher('Always-Look-on-the-Bright-Side-of-Life', 5)).toBe('Fqbfdx-Qttp-ts-ymj-Gwnlmy-Xnij-tk-Qnkj')
    expect(caesarsCipher('THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG', 23)).toBe('QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD')
  })
})
import { encrypt, decrypt } from '../KeywordShiftedAlphabet'

test('Hello world! === dcrypt(encrypt(Hello world!))', () => {
  const word = 'Hello world!'
  const result = decrypt('keyword', encrypt('keyword', word))
  expect(result).toMatch(word)
})

test('The Algorithms === dcrypt(encrypt(The Algorithms))', () => {
  const word = 'The Algorithms'
  const result = decrypt('keyword', encrypt('keyword', word))
  expect(result).toMatch(word)
})
import Atbash from '../Atbash'

describe('Testing Atbash function', () => {
  it('Test - 1, passing a non-string as an argument', () => {
    expect(() => Atbash(0x345)).toThrow()
    expect(() => Atbash(123)).toThrow()
    expect(() => Atbash(123n)).toThrow()
    expect(() => Atbash(false)).toThrow()
    expect(() => Atbash({})).toThrow()
    expect(() => Atbash([])).toThrow()
  })

  it('Test - 2, passing a string as an argument', () => {
    const clearText = 'The quick brown fox jumps over the lazy dog'
    const cryptText = Atbash(clearText)
    expect(Atbash(cryptText)).toBe(clearText)
  })
})
import XORCipher from '../XORCipher'

describe('Testing XORCipher function', () => {
  it('Test - 1, passing a non-string as an argument', () => {
    expect(() => XORCipher(false, 0x345)).toThrow()
    expect(() => XORCipher(true, 123)).toThrow()
    expect(() => XORCipher(1n, 123n)).toThrow()
    expect(() => XORCipher(false, 0.34)).toThrow()
    expect(() => XORCipher({})).toThrow()
    expect(() => XORCipher([])).toThrow()
  })

  it('Test - 2, passing a string & number as an argument', () => {
        expect(XORCipher('test string', 32)).toBe('TEST\x00STRING')
    expect(XORCipher('TEST\x00STRING', 32)).toBe('test string')
  })
})
import ROT13 from '../ROT13'

describe('Testing ROT13 function', () => {
  it('Test - 1, passing a non-string as an argument', () => {
    expect(() => ROT13(0x345)).toThrow()
    expect(() => ROT13(123)).toThrow()
    expect(() => ROT13(123n)).toThrow()
    expect(() => ROT13(false)).toThrow()
    expect(() => ROT13({})).toThrow()
    expect(() => ROT13([])).toThrow()
  })

  it('Test - 2, passing a string as an argument', () => {
    expect(ROT13('Uryyb Jbeyq')).toBe('Hello World')
    expect(ROT13('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')).toBe('NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')
    expect(ROT13('The quick brown fox jumps over the lazy dog')).toBe('Gur dhvpx oebja sbk whzcf bire gur ynml qbt')
  })
})
import { encrypt, decrypt } from '../VigenereCipher'

test('Hello world! === dcrypt(encrypt(Hello world!))', () => {
  const word = 'Hello world!'
  const result = decrypt(encrypt(word, 'code'), 'code')
  expect(result).toMatch(word)
})

test('The Algorithms === dcrypt(encrypt(The Algorithms))', () => {
  const word = 'The Algorithms'
  const result = decrypt(encrypt(word, 'code'), 'code')
  expect(result).toMatch(word)
})

const caesarsCipher = (str, rotation) => {
  if (typeof str !== 'string' || !Number.isInteger(rotation) || rotation < 0) {
    throw new TypeError('Arguments are invalid')
  }

  const alphabets = new Array(26)
    .fill()
    .map((_, index) => String.fromCharCode(97 + index)) 
  const cipherMap = alphabets.reduce(
    (map, char, index) => map.set(char, alphabets[(rotation + index) % 26]),
    new Map()
  )

  return str.replace(/[a-z]/gi, (char) => {
    if (/[A-Z]/.test(char)) {
      return cipherMap.get(char.toLowerCase()).toUpperCase()
    }

    return cipherMap.get(char)
  })
}

export default caesarsCipher

function ROT13 (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

  return str.replace(/[a-z]/gi, (char) => {
    const charCode = char.charCodeAt()

    if (/[n-z]/i.test(char)) {
      return String.fromCharCode(charCode - 13)
    }

    return String.fromCharCode(charCode + 13)
  })
}

export default ROT13

function isLetter (str) {
  return str.length === 1 && str.match(/[a-zA-Z]/i)
}


function isUpperCase (character) {
  if (character === character.toUpperCase()) {
    return true
  }
  if (character === character.toLowerCase()) {
    return false
  }
}


function encrypt (message, key) {
  let result = ''

  for (let i = 0, j = 0; i < message.length; i++) {
    const c = message.charAt(i)
    if (isLetter(c)) {
      if (isUpperCase(c)) {
        result += String.fromCharCode((c.charCodeAt(0) + key.toUpperCase().charCodeAt(j) - 2 * 65) % 26 + 65)       } else {
        result += String.fromCharCode((c.charCodeAt(0) + key.toLowerCase().charCodeAt(j) - 2 * 97) % 26 + 97)       }
    } else {
      result += c
    }
    j = ++j % key.length
  }
  return result
}


function decrypt (message, key) {
  let result = ''

  for (let i = 0, j = 0; i < message.length; i++) {
    const c = message.charAt(i)
    if (isLetter(c)) {
      if (isUpperCase(c)) {
        result += String.fromCharCode(90 - (25 - (c.charCodeAt(0) - key.toUpperCase().charCodeAt(j))) % 26)
      } else {
        result += String.fromCharCode(122 - (25 - (c.charCodeAt(0) - key.toLowerCase().charCodeAt(j))) % 26)
      }
    } else {
      result += c
    }
    j = ++j % key.length
  }
  return result
}

export { encrypt, decrypt }




const alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

function checkKeywordValidity (keyword) {
  keyword.split('').forEach((char, index) => {
    const rest = keyword.slice(0, index) + keyword.slice(index + 1)
    if (rest.indexOf(char) !== -1) {
      return false
    }
  })
  return true
}

function getEncryptedAlphabet (keyword) {
  const encryptedAlphabet = keyword.split('')
  alphabet.forEach((char) => {
    if (encryptedAlphabet.indexOf(char) === -1) {
      encryptedAlphabet.push(char)
    }
  })
  return encryptedAlphabet
}

function translate (sourceAlphabet, targetAlphabet, message) {
  return message.split('').reduce((encryptedMessage, char) => {
    const isUpperCase = char === char.toUpperCase()
    const encryptedCharIndex = sourceAlphabet.indexOf(char.toLowerCase())
    const encryptedChar = encryptedCharIndex !== -1 ? targetAlphabet[encryptedCharIndex] : char
    encryptedMessage += isUpperCase ? encryptedChar.toUpperCase() : encryptedChar
    return encryptedMessage
  }, '')
}

function checkInputs (keyword, message) {
  if (!keyword || !message) {
    throw new Error('Both keyword and message must be specified')
  }

  if (!checkKeywordValidity(keyword)) {
    throw new Error('Invalid keyword!')
  }
}

function encrypt (keyword, message) {
  checkInputs(keyword, message)
  return translate(alphabet, getEncryptedAlphabet(keyword.toLowerCase()), message)
}

function decrypt (keyword, message) {
  checkInputs(keyword, message)
  return translate(getEncryptedAlphabet(keyword.toLowerCase()), alphabet, message)
}

export { encrypt, decrypt }


const Atbash = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

  return str.replace(/[a-z]/gi, (char) => {
    const charCode = char.charCodeAt()

    if (/[A-Z]/.test(char)) {
      return String.fromCharCode(90 + 65 - charCode)
    }

    return String.fromCharCode(122 + 97 - charCode)
  })
}

export default Atbash

function keyFinder (str) {   const wordBank = [
    'I ',
    'You ',
    'We ',
    'They ',
    'He ',
    'She ',
    'It ',
    ' the ',
    'The ',
    ' of ',
    ' is ',
    'Is ',
    ' am ',
    'Am ',
    ' are ',
    'Are ',
    ' have ',
    'Have ',
    ' has ',
    'Has ',
    ' may ',
    'May ',
    ' be ',
    'Be ']
      const inStr = str.toString()   let outStr = ''   let outStrElement = ''   for (let k = 0; k < 26; k++) {     outStr = caesarCipherEncodeAndDecodeEngine(inStr, k) 
        for (let s = 0; s < outStr.length; s++) {
      for (let i = 0; i < wordBank.length; i++) {
                        for (let w = 0; w < wordBank[i].length; w++) {
          outStrElement += outStr[s + w]
        }
                        if (wordBank[i] === outStrElement) {
          return k         }
        outStrElement = ''       }     }
  }
  return 0 }

/
function caesarCipherEncodeAndDecodeEngine (inStr, numShifted) {
  const shiftNum = numShifted
  let charCode = 0
  let outStr = ''
  let shiftedCharCode = 0
  let result = 0

  for (let i = 0; i < inStr.length; i++) {
    charCode = inStr[i].charCodeAt()
    shiftedCharCode = charCode + shiftNum
    result = charCode

    if ((charCode >= 48 && charCode <= 57)) {
      if (shiftedCharCode < 48) {
        let diff = Math.abs(48 - 1 - shiftedCharCode) % 10

        while (diff >= 10) {
          diff = diff % 10
        }
        document.getElementById('diffID').innerHTML = diff

        shiftedCharCode = 57 - diff

        result = shiftedCharCode
      } else if (shiftedCharCode >= 48 && shiftedCharCode <= 57) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 57) {
        let diff = Math.abs(57 + 1 - shiftedCharCode) % 10

        while (diff >= 10) {
          diff = diff % 10
        }
        document.getElementById('diffID').innerHTML = diff

        shiftedCharCode = 48 + diff

        result = shiftedCharCode
      }
    } else if ((charCode >= 65 && charCode <= 90)) {
      if (shiftedCharCode <= 64) {
        let diff = Math.abs(65 - 1 - shiftedCharCode) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 90 - diff
        result = shiftedCharCode
      } else if (shiftedCharCode >= 65 && shiftedCharCode <= 90) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 90) {
        let diff = Math.abs(shiftedCharCode - 1 - 90) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 65 + diff
        result = shiftedCharCode
      }
    } else if ((charCode >= 97 && charCode <= 122)) {
      if (shiftedCharCode <= 96) {
        let diff = Math.abs(97 - 1 - shiftedCharCode) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 122 - diff
        result = shiftedCharCode
      } else if (shiftedCharCode >= 97 && shiftedCharCode <= 122) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 122) {
        let diff = Math.abs(shiftedCharCode - 1 - 122) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 97 + diff
        result = shiftedCharCode
      }
    }
    outStr = outStr + String.fromCharCode(parseInt(result))
  }
  return outStr
}

export { keyFinder }

import { getMonthDays } from '../GetMonthDays'

describe('Get the Days of a Month', () => {
  it('expects to return 28', () => {
    expect(getMonthDays(2, 2018)).toEqual(28)
  })

  it('expects to return 30', () => {
    expect(getMonthDays(6, 254)).toEqual(30)
  })

  it('expects to return 29', () => {
    expect(getMonthDays(2, 2024)).toEqual(29)
  })

  it('expects to throw a type error', () => {
    expect(() => { getMonthDays(13, 2020) }).toThrow('Invalid Month Number.')
  })
})

class IntervalTimer {
  /
  constructor (interval = 10,
    callBack = () => {}) {
    this.prevInterval = 0
    if (this.instance == null) {
      this.interval = interval
      this.callBack = callBack
      this.instance = this
    } else {
      return this.instance
    }
  }

  /
  startTimer () {
    this.timer = setInterval(this.callBack, this.interval)
  }

  /
  resetTimer () {
    clearInterval(this.timer)
    this.callBack = () => {}
    return this.getElapsedTime()
  }

  /
  getElapsedTime (offset = 0) {
    this.timeElapsed = this.timer - this.prevInterval
    this.prevInterval = this.timer
    return this.timeElapsed - offset
  }

  /
  getRunTime () {
    return this.timer
  }
}


const ExampleIntervalTimer = function (output = v => console.log(v)) {
  /
  const timer = new IntervalTimer()
  timer.startTimer()

    
  /
  const initOffset = timer.getRunTime()

      output(timer.getElapsedTime(initOffset))

  /
  output(timer.resetTimer())
}

export { IntervalTimer, ExampleIntervalTimer }


const getMonthDays = (monthNumber, year) => {
  const the31DaysMonths = [1, 3, 5, 7, 8, 10, 12]
  const the30DaysMonths = [4, 6, 9, 11]

  if (!the31DaysMonths.includes(monthNumber) && !the30DaysMonths.includes(monthNumber) &&
    (monthNumber !== 2)
  ) {
    throw new TypeError('Invalid Month Number.')
  }

  if (the31DaysMonths.includes(monthNumber)) { return 31 }

  if (the30DaysMonths.includes(monthNumber)) { return 30 }

    if (year % 4 === 0) {
    if ((year % 100 !== 0) || (year % 100 === 0 && year % 400 === 0)) {
      return 29
    }
  }

  return 28
}

export { getMonthDays }


function integralEvaluation (N, a, b, func) {
    if (!Number.isInteger(N) || Number.isNaN(a) || Number.isNaN(b)) { throw new TypeError('Expected integer N and finite a, b') }
  if (N <= 0) { throw Error('N has to be >= 2') }   if (a > b) { throw Error('a must be less or equal than b') }   if (a === b) return 0 
    const h = (b - a) / N

    let xi = a   const pointsArray = []

    let temp
  for (let i = 0; i < N; i++) {
    temp = func(xi + h / 2)
    pointsArray.push(temp)
    xi += h
  }

    let result = h
  temp = 0
  for (let i = 0; i < pointsArray.length; i++) temp += pointsArray[i]

  result *= temp

  if (Number.isNaN(result)) { throw Error('Result is NaN. The input interval does not belong to the functions domain') }

  return result
}

export { integralEvaluation }


const perfectCube = (num) => Math.round(num ** (1 / 3)) ** 3 === num

export { perfectCube }
/

function sqrt (num, precision = 4) {
  if (!Number.isFinite(num)) { throw new TypeError(`Expected a number, received ${typeof num}`) }
  if (!Number.isFinite(precision)) { throw new TypeError(`Expected a number, received ${typeof precision}`) }
  let sqrt = 1
  for (let i = 0; i < precision; i++) {
    sqrt -= (sqrt * sqrt - num) / (2 * sqrt)
  }
  return sqrt
}

export { sqrt }
/

export const binaryExponentiation = (a, n) => {
      if (n === 0) {
    return 1
  } else if (n % 2 === 1) {
    return binaryExponentiation(a, n - 1) * a
  } else {
    const b = binaryExponentiation(a, n / 2)
    return b * b
  }
}
/

function fareyApproximation (decimal, repeat = 20) {
  let a = 0; let b = 1; let c = 1; let d = 1; let numerator; let denominator

  for (let i = 0; i < repeat; i++) {
    numerator = a + c
    denominator = b + d

    if (decimal > numerator / denominator) {
      [a, b] = [numerator, denominator]
    } else {
      [c, d] = [numerator, denominator]
    }
  }

  return { numerator, denominator }
}

export { fareyApproximation }

export const isLeapYear = (year) => {
  if (year % 400 === 0) return true
  if (year % 100 === 0) return false
  if (year % 4 === 0) return true

  return false
}
/

const factorial = (n) => {
  let fact = 1
  while (n !== 0) {
    fact = fact * n
    n--
  }
  return fact
}


const CheckKishnamurthyNumber = (number) => {
    if (typeof number !== 'number') {
    return new TypeError('Argument is not a number.')
  }
    let sumOfAllDigitFactorial = 0
    let newNumber = number
    while (newNumber > 0) {
    const lastDigit = newNumber % 10
        sumOfAllDigitFactorial += factorial(lastDigit)
    newNumber = Math.floor(newNumber / 10)
  }
    return sumOfAllDigitFactorial === number
}

export { CheckKishnamurthyNumber }


const FindMinIterator = (_iterable, _selector = undefined) => {
  let min

  const iterator = _iterable[Symbol.iterator]()
  if (!_selector) {
    let current = iterator.next()
    if (current.done) { return undefined }
    min = current.value

    current = iterator.next()
    while (!current.done) {
      const x = current.value
      if (x < min) { min = x }
      current = iterator.next()
    }
  } else {
    let current = iterator.next()
    if (current.done) { return undefined }
    min = _selector(current.value)

    current = iterator.next()
    while (!current.done) {
      const x = _selector(current.value)
      if (x < min) { min = x }
      current = iterator.next()
    }
  }
  return min
}

export { FindMinIterator }
/

const Identity = (n) => {
        const res = []
  for (let i = 0; i < n; i++) {
    res[i] = []
    for (let j = 0; j < n; j++) {
      res[i][j] = i === j ? 1 : 0
    }
  }
  return res
}

const MatMult = (matrixA, matrixB) => {
          const n = matrixA.length
  const matrixC = []
  for (let i = 0; i < n; i++) {
    matrixC[i] = []
    for (let j = 0; j < n; j++) {
      matrixC[i][j] = 0
    }
  }
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      for (let k = 0; k < n; k++) {
        matrixC[i][j] += matrixA[i][k] * matrixB[k][j]
      }
    }
  }
  return matrixC
}

export const MatrixExponentiationRecursive = (mat, m) => {
        if (m === 0) {
        return Identity(mat.length)
  } else if (m % 2 === 1) {
        const tmp = MatrixExponentiationRecursive(mat, m - 1)
        return MatMult(tmp, mat)
  } else {
        const tmp = MatrixExponentiationRecursive(mat, m >> 1)
        return MatMult(tmp, tmp)
  }
}





/

export const decimalIsolate = (number) => {
  const answer = parseFloat((number + '').replace(/^[-\d]+./, '.'))
  return isNaN(answer) === true ? 0 : answer
}
/



export const isPronic = (number) => {
  if (number === 0) {
    return true
  }
  const sqrt = Math.sqrt(number)
  return sqrt % 1 !== 0 && Math.ceil(sqrt) * Math.floor(sqrt) === number
}
/


const isOdd = (number) => Boolean(number % 2) /
const isOddBitwise = (number) => Boolean(number & 1) 
export { isOdd, isOddBitwise }

const calcRPN = (expression) => {
  const operators = {
    '+': (a, b) => a + b,
    '-': (a, b) => a - b,
    '*': (a, b) => a * b,
    '/': (a, b) => b / a
  }

  const tokens = expression.split(' ')

  const stack = []

  tokens.forEach((token) => {
    const operator = operators[token]

    if (typeof operator === 'function') {
      const a = stack.pop()
      const b = stack.pop()

      const result = operator(a, b)

      stack.push(result)
    } else {
      stack.push(parseFloat(token))
    }
  })

  return stack.pop()
}

export { calcRPN }
/


export const isEven = (number) => number % 2 === 0


export const isEvenBitwise = (number) => (number & 1) === 0
/


export const radianToDegree = (radian) => {
  return radian * (180 / Math.PI)
}
/
const euclideanDistance = (longitude1, latitude1, longitude2, latitude2) => {
  const width = longitude2 - longitude1
  const height = latitude2 - latitude1
  return (Math.sqrt(width * width + height * height))
}

const manhattanDistance = (longitude1, latitude1, longitude2, latitude2) => {
  const width = Math.abs(longitude2 - longitude1)
  const height = Math.abs(latitude2 - latitude1)
  return width + height
}

export { euclideanDistance, manhattanDistance }


const perfectSquare = (num) => Math.sqrt(num) ** 2 === num

export { perfectSquare }
import { aliquotSum } from '../AliquotSum'

describe('Aliquot Sum of a Number', () => {
  it('Aliquot Sum of 6', () => {
    expect(aliquotSum(6)).toBe(6)
  })

  it('Aliquot Sum of 1', () => {
    expect(aliquotSum(1)).toBe(0)
  })

  it('Aliquot Sum of 28', () => {
    expect(aliquotSum(28)).toBe(28)
  })
})
import { generate } from '../PascalTriangle'

describe('Pascals Triangle', () => {
  it('should have the the same length as the number', () => {
    const pascalsTriangle = generate(5)
    expect(pascalsTriangle.length).toEqual(5)
  })
  it('should have same length as its index in the array', () => {
    const pascalsTriangle = generate(5)
    pascalsTriangle.forEach((arr, index) => {
      expect(arr.length).toEqual(index + 1)
    })
  })
  it('should return an array of arrays', () => {
    const pascalsTriangle = generate(3)
    expect(pascalsTriangle).toEqual(
      expect.arrayContaining([[1], [1, 1], [1, 2, 1]])
    )
  })
})
import * as area from '../Area'

describe('Testing surfaceAreaCube calculations', () => {
  it('with natural number', () => {
    const surfaceAreaOfOne = area.surfaceAreaCube(1.2)
    const surfaceAreaOfThree = area.surfaceAreaCube(3)
    expect(surfaceAreaOfOne).toBe(8.64)
    expect(surfaceAreaOfThree).toBe(54)
  })
  it('with negative argument, expect throw', () => {
    expect(() => area.surfaceAreaCube(-1)).toThrow()
  })
  it('with non-numeric argument, expect throw', () => {
    expect(() => area.surfaceAreaCube('199')).toThrow()
  })
})

describe('Testing surfaceAreaSphere calculations', () => {
  it('with correct value', () => {
    const calculateArea = area.surfaceAreaSphere(5)
    const expected = 314.1592653589793
    expect(calculateArea).toBe(expected)
  })
  it('with negative value, expect throw', () => {
    expect(() => area.surfaceAreaSphere(-1)).toThrow()
  })
})

describe('Testing areaRectangle calculations', () => {
  it('with correct args', () => {
    const areaRectangle = area.areaRectangle(2.5, 2)
    expect(areaRectangle).toBe(5.0)
  })
  it('with incorrect args, expect throw', () => {
    expect(() => area.areaRectangle(-1, 20)).toThrow()
    expect(() => area.areaRectangle('1', 0)).toThrow()
    expect(() => area.areaRectangle(23, -1)).toThrow()
    expect(() => area.areaRectangle(23, 'zero')).toThrow()
  })
})

describe('Testing areaSquare calculations', () => {
  it('with correct args', () => {
    const areaSquare = area.areaSquare(2.5)
    expect(areaSquare).toBe(6.25)
  })
  it('with incorrect side length, expect throw', () => {
    expect(() => area.areaSquare(-1)).toThrow()
    expect(() => area.areaSquare('zero')).toThrow()
  })
})

describe('Testing areaTriangle calculations', () => {
  it('with correct args', () => {
    const areaTriangle = area.areaTriangle(1.66, 3.44)
    expect(areaTriangle).toBe(2.8552)
  })
  it('with incorrect base and height, expect throw', () => {
    expect(() => area.areaTriangle(-1, 1)).toThrow()
    expect(() => area.areaTriangle(9, 'zero')).toThrow()
  })
})

describe('Testing areaTriangleWithAllThreeSides calculations', () => {
  it('with correct args', () => {
    const areaTriangle = area.areaTriangleWithAllThreeSides(5, 6, 7)
    expect(areaTriangle).toBe(14.7)
  })
  it('with incorrect sides, expect throw', () => {
    expect(() => area.areaTriangleWithAllThreeSides(-1, 1, 10)).toThrow()
    expect(() => area.areaTriangleWithAllThreeSides(9, 'zero', 2)).toThrow()
    expect(() => area.areaTriangleWithAllThreeSides(1, 10, 12)).toThrow()
  })
})

describe('Testing areaParallelogram calculations', () => {
  it('with correct args', () => {
    const areaParallelogram = area.areaParallelogram(1.66, 3.44)
    expect(areaParallelogram).toBe(5.7104)
  })
  it('with incorrect base and height, expect throw', () => {
    expect(() => area.areaParallelogram(-1, 1)).toThrow()
    expect(() => area.areaParallelogram(9, 'zero')).toThrow()
  })
})

describe('Testing areaTrapezium calculations', () => {
  it('with correct args', () => {
    const areaTrapezium = area.areaTrapezium(1.66, 2.41, 4.1)
    expect(areaTrapezium).toBe(8.3435)
  })
  it('with incorrect bases and height, expect throw', () => {
    expect(() => area.areaTrapezium(-1, 1, 0)).toThrow()
    expect(() => area.areaTrapezium(9, 'zero', 2)).toThrow()
    expect(() => area.areaTrapezium(9, 1, 'seven')).toThrow()
  })
})

describe('Testing areaCircle calculations', () => {
  it('with correct args', () => {
    const areaCircle = area.areaCircle(3.456)
    expect(areaCircle).toBe(37.52298159254666)
  })
  it('with incorrect diagonal, expect throw', () => {
    expect(() => area.areaCircle(-1)).toThrow()
    expect(() => area.areaCircle('zero')).toThrow()
  })
})

describe('Testing areaRhombus calculations', () => {
  it('with correct args', () => {
    const areaRhombus = area.areaRhombus(2.5, 2.0)
    expect(areaRhombus).toBe(2.5)
  })
  it('with incorrect diagonals, expect throw', () => {
    expect(() => area.areaRhombus(7, -1)).toThrow()
    expect(() => area.areaRhombus('zero', 2)).toThrow()
  })
})
import { perfectCube } from '../PerfectCube'

describe('PerfectCube', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectCube(125)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectCube(100)).toBeFalsy()
  })
})
import { degreeToRadian } from '../DegreeToRadian'

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(0)
  expect(radianEqual).toBe(0)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(45)
  expect(radianEqual).toBe(Math.PI / 4)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(90)
  expect(radianEqual).toBe(Math.PI / 2)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(180)
  expect(radianEqual).toBe(Math.PI)
})
import { factorsOfANumber } from '../Factors'

describe('Factors', () => {
  factorsOfANumber(50).forEach((num) => {
    it(`${num} is a factor of 50`, () => {
      const isFactor = 50 % num === 0
      expect(isFactor).toBeTruthy()
    })
  })
})
import { isLeapYear } from '../LeapYear'

describe('Leap Year', () => {
  it('Should return true on the year 2000', () => {
    expect(isLeapYear(2000)).toBe(true)
  })
  it('Should return false on the year 2001', () => {
    expect(isLeapYear(2001)).toBe(false)
  })
  it('Should return false on the year 2002', () => {
    expect(isLeapYear(2002)).toBe(false)
  })
  it('Should return false on the year 2003', () => {
    expect(isLeapYear(2003)).toBe(false)
  })
  it('Should return false on the year 2004', () => {
    expect(isLeapYear(2004)).toBe(true)
  })
  it('Should return false on the year 1900', () => {
    expect(isLeapYear(1900)).toBe(false)
  })
})
import { calcRPN } from '../ReversePolishNotation'

describe('ReversePolishNotation', () => {
  it('should evaluate correctly for two values', () => {
    expect(calcRPN('2 3 +')).toEqual(5)
  })
  it("should evaluate' for multiple values", () => {
    expect(calcRPN('2 2 2 * +')).toEqual(6)
    expect(calcRPN('6 9 7 + 2 / + 3 *')).toEqual(42)
  })
})
import * as coordinate from '../Coordinate'

describe('Testing euclideanDistance calculations', () => {
  it('Should give a numeric output (distance between 2 points) with 4 numeric arguments', () => {
    const euclideanDistance = coordinate.euclideanDistance(2, 2, -10, -7)
    expect(euclideanDistance).toBe(15)
  })
  it('Should not give any output given non-numeric argument', () => {
    const euclideanDistance = coordinate.euclideanDistance('ABC', '123', '', '###')
    expect(euclideanDistance).toBeNaN()
  })
  it('Should not give any output given any number of numeric arguments less than 4', () => {
    const euclideanDistance3arg = coordinate.euclideanDistance(2, 2, -10)
    const euclideanDistance2arg = coordinate.euclideanDistance(2, 2)
    const euclideanDistance1arg = coordinate.euclideanDistance(2)
    const euclideanDistance0arg = coordinate.euclideanDistance()
    expect(euclideanDistance3arg).toBeNaN()
    expect(euclideanDistance2arg).toBeNaN()
    expect(euclideanDistance1arg).toBeNaN()
    expect(euclideanDistance0arg).toBeNaN()
  })
})

describe('Testing manhattanDistance calculations', () => {
  it('Should give a numeric output (distance between 2 points) with 4 numeric arguments', () => {
    const manhattanDistance = coordinate.manhattanDistance(2, 2, -10, -7)
    expect(manhattanDistance).toBe(21)
  })
  it('Should not give any output given non-numeric argument', () => {
    const manhattanDistance = coordinate.manhattanDistance('ABC', '123', '', '###')
    expect(manhattanDistance).toBeNaN()
  })
  it('Should not give any output given any number of numeric arguments less than 4', () => {
    const manhattanDistance3arg = coordinate.manhattanDistance(2, 2, -10)
    const manhattanDistance2arg = coordinate.manhattanDistance(2, 2)
    const manhattanDistance1arg = coordinate.manhattanDistance(2)
    const manhattanDistance0arg = coordinate.manhattanDistance()
    expect(manhattanDistance3arg).toBeNaN()
    expect(manhattanDistance2arg).toBeNaN()
    expect(manhattanDistance1arg).toBeNaN()
    expect(manhattanDistance0arg).toBeNaN()
  })
})
import { isDivisible } from '../IsDivisible'

describe('isDivisible', () => {
  const testCases = [
    [0, 1, true],
    [0, 2, true],
    [1, 1, true],
    [1, 2, false],
    [2, 1, true],
    [4, 4, true],
    [16, 4, true],
    [36978235, 5, true],
    [36978235, 4, false],
    [4.5, 1.5, true],
    [4.5, 1.2, false],
    [5, 0, false],
    [5, -0, false]
  ]

  test.each(testCases)('if parameters are (%i, %i) it returns %p', (dividend, divisor, expected) => {
    expect(isDivisible(dividend, divisor)).toBe(expected)
  })

  const errorCases = [
    [NaN, NaN],
    [NaN, 1],
    [1, NaN],
    ['1', 1],
    [1, '1'],
    [1, true],
    [false, 2]
  ]

  test.each(errorCases)('throws an error if parameters are (%p, %p)', (dividend, divisor) => {
    expect(() => {
      isDivisible(dividend, divisor)
    }).toThrow()
  })
})
import { calcFactorial } from '../Factorial'

describe('calcFactorial', () => {
  it('should return a statement for value "0"', () => {
    expect(calcFactorial(0)).toBe('The factorial of 0 is 1.')
  })

  it('should return a statement for "null" and "undefined"', () => {
    const nullFactorial = calcFactorial(null)
    const undefinedFactorial = calcFactorial(undefined)

    expect(nullFactorial).toBe(
      'Sorry, factorial does not exist for null or undefined numbers.'
    )
    expect(undefinedFactorial).toBe(
      'Sorry, factorial does not exist for null or undefined numbers.'
    )
  })

  it('should not support negative numbers', () => {
    const negativeFactorial = calcFactorial(-5)
    expect(negativeFactorial).toBe(
      'Sorry, factorial does not exist for negative numbers.'
    )
  })

  it('should return the factorial of a positive number', () => {
    const positiveFactorial = calcFactorial(3)
    expect(positiveFactorial).toBe('The factorial of 3 is 6')
  })
})
import { eulerFull } from '../EulerMethod'

function plotLine (label, points, width, height) {
  
    const container = document.createElement('div')
  container.style.width = width + 'px'
  container.style.height = height + 'px'
  document.body.append(container)

    const canvas = document.createElement('canvas')
  container.append(canvas)

    const chart = new Chart(canvas, {     type: 'scatter',
    data: {
      datasets: [{
        label,
        data: points,
        showLine: true,
        fill: false,
        tension: 0,
        borderColor: 'black'
      }]
    },
    options: {
      maintainAspectRatio: false,
      responsive: true
    }
  })
}

function exampleEquation1 (x, y) {
  return x
}

function exampleEquation2 (x, y) {
  return y
}

function exampleEquation3 (x, y) {
  return x + y + x * y
}

if (typeof window !== 'undefined') {
  const points1 = eulerFull(0, 4, 0.1, 0, exampleEquation1)
  const points2 = eulerFull(0, 4, 0.1, 1, exampleEquation2)
  const points3 = eulerFull(0, 0.1, 0.025, 1, exampleEquation3)

  const script = document.createElement('script')

    script.src = 'https:  script.onload = function () {
    plotLine('example 1: dy/dx = x', points1, 600, 400)
    plotLine('example 2: dy/dx = y', points2, 600, 400)
    plotLine('example 3: dy/dx = x + y + x * y', points3, 600, 400)
  }
  document.body.append(script)
}
import { isEven, isEvenBitwise } from '../IsEven'

describe('Testing isEven function', () => {
  it('should return if the number is even or not', () => {
    const isEvenNumber = isEven(4)
    expect(isEvenNumber).toBe(true)
  })

  it('should return if the number is even or not', () => {
    const isEvenNumber = isEven(7)
    expect(isEvenNumber).toBe(false)
  })
})

describe('Testing isEvenBitwise function', () => {
  it('should return if the number is even or not', () => {
    const isEvenNumber = isEvenBitwise(6)
    expect(isEvenNumber).toBe(true)
  })

  it('should return if the number is even or not', () => {
    const isEvenNumber = isEvenBitwise(3)
    expect(isEvenNumber).toBe(false)
  })
})
import { eulersTotientFunction } from '../EulersTotientFunction'

describe('eulersTotientFunction', () => {
  it('is a function', () => {
    expect(typeof eulersTotientFunction).toEqual('function')
  })
  it('should return the phi of a given number', () => {
    const phiOfNumber = eulersTotientFunction(10)
    expect(phiOfNumber).toBe(4)
  })
})
import { Softmax } from '../Softmax'

describe('Softmax', () => {
  it('should return equal distribution of 1 for equal input values', () => {
    expect(Softmax([1, 1])).toEqual([0.5, 0.5])
    expect(Softmax([1, 1, 1, 1])).toEqual([0.25, 0.25, 0.25, 0.25])
  })

  it('should return values which sum to the value of 1', () => {
    expect(Softmax([1, 2, 3, 4]).reduce((a, b) => a + b, 0)).toEqual(1)
  })
})
import { perfectSquare } from '../PerfectSquare'

describe('PerfectSquare', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectSquare(16)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectSquare(10)).toBeFalsy()
  })
})
import { Polynomial } from '../Polynomial'

describe('Polynomial', () => {
  it('should not return a expression for zero', () => {
    const polynomial = new Polynomial([0])
    expect(polynomial.display()).toBe('')
  })
  it('should not return an expression for zero values', () => {
    const polynomial = new Polynomial([0, 0, 0, 0, 0])
    expect(polynomial.display()).toBe('')
  })
  it('should return an expression for single a non zero value', () => {
    const polynomial = new Polynomial([9])
    expect(polynomial.display()).toBe('(9)')
  })
  it('should return an expression for two values', () => {
    const polynomial = new Polynomial([3, 2])
    expect(polynomial.display()).toBe('(2x) + (3)')
  })
  it('should return an expression for values including zero', () => {
    const polynomial = new Polynomial([0, 2])
    expect(polynomial.display()).toBe('(2x)')
  })
  it('should return an expression and evaluate it', () => {
    const polynomial = new Polynomial([1, 2, 3, 4])
    expect(polynomial.display()).toBe('(4x^3) + (3x^2) + (2x) + (1)')
    expect(polynomial.evaluate(2)).toEqual(49)
  })
  it('should evaluate 0 for zero values', () => {
    const polynomial = new Polynomial([0, 0, 0, 0])
    expect(polynomial.evaluate(5)).toEqual(0)
  })
  it('should evaluate for negative values', () => {
    const polynomial = new Polynomial([-1, -3, -4, -7])
    expect(polynomial.evaluate(-5)).toBe(789)
  })
})
import { isPronic } from '../IsPronic'

const pronicNumbers = [0, 2, 6, 12, 20, 30, 42, 56, 72, 90, 110, 132, 156, 182, 210, 240, 272, 306, 342, 380, 420, 462, 506, 552, 600, 650, 702, 756, 812, 870, 930, 992, 1056, 1122, 1190, 1260, 1332, 1406, 1482, 1560, 1640, 1722, 1806, 1892, 1980, 2070, 2162, 2256, 2352, 2450, 2550]

describe('Testing isPronic function', () => {
  for (let i = 0; i <= 2500; i++) {
    it('should return true', () => {
      const isPronicNumber = isPronic(i)
      expect(isPronicNumber).toBe(pronicNumbers.includes(i))
    })
  }
})
import { twinPrime } from '../TwinPrime.js'

describe('Twin Primes', () => {
  it('Should be valid twin primes', () => {
    expect(twinPrime(3)).toBe(5)
    expect(twinPrime(5)).toBe(7)
    expect(twinPrime(4)).toBe(-1)
    expect(twinPrime(17)).toBe(19)
  })
})
import { factorial, permutation, combination } from '../PermutationAndCombination'

describe('Factorial', () => {
  it('factorial(5)', () => {
    expect(factorial(5)).toBe(120)
  })
})

describe('Permutation', () => {
  it('permutation(5, 2)', () => {
    expect(permutation(5, 2)).toBe(20)
  })
})

describe('Combination', () => {
  it('combination(5, 2)', () => {
    expect(combination(5, 2)).toBe(10)
  })
})
import { fermatPrimeCheck, modularExponentiation } from '../FermatPrimalityTest'

describe('modularExponentiation', () => {
  it('should give the correct output for all exponentiations', () => {
    expect(modularExponentiation(38, 220, 221)).toBe(1)
    expect(modularExponentiation(24, 220, 221)).toBe(81)
  })
})

describe('fermatPrimeCheck', () => {
  it('should give the correct output for prime and composite numbers', () => {
    expect(fermatPrimeCheck(2, 35)).toBe(true)
    expect(fermatPrimeCheck(10, 30)).toBe(false)
    expect(fermatPrimeCheck(94286167)).toBe(true)
    expect(fermatPrimeCheck(83165867)).toBe(true)
    expect(fermatPrimeCheck(13268774)).toBe(false)
    expect(fermatPrimeCheck(13233852)).toBe(false)
  })
})
import { LinearSieve } from '../LinearSieve'
import { PrimeCheck } from '../PrimeCheck'

describe('LinearSieve', () => {
  it('should return primes below 100', () => {
    expect(LinearSieve(100)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
  })

  it('should return primes only', () => {
    const n = 100000
    const primes = LinearSieve(n)
    for (const p of primes) {
      expect(PrimeCheck(p)).toBeTruthy()
    }
  })
})
import { GetEuclidGCD } from '../GetEuclidGCD'

function testEuclidGCD (n, m, expected) {
  test('Testing on ' + n + ' and ' + m + '!', () => {
    expect(GetEuclidGCD(n, m)).toBe(expected)
  })
}

testEuclidGCD(5, 20, 5)
testEuclidGCD(109, 902, 1)
testEuclidGCD(290, 780, 10)
testEuclidGCD(104, 156, 52)
import { isOdd, isOddBitwise } from '../IsOdd'

describe('Testing the isOdd function', () => {
  it('should return true, if the number is odd', () => {
    const isOddNumber = isOdd(4)
    expect(isOddNumber).toBe(false)
  })

  it('should return true, if the number is odd', () => {
    const isOddNumber = isOdd(7)
    expect(isOddNumber).toBe(true)
  })
})

describe('Testing the isOddBitwise function', () => {
  it('should return true, if the number is odd', () => {
    const isOddNumber = isOddBitwise(6)
    expect(isOddNumber).toBe(false)
  })

  it('should return true, if the number is odd', () => {
    const isOddNumber = isOddBitwise(3)
    expect(isOddNumber).toBe(true)
  })
})
import { decExp } from '../DecimalExpansion'



describe('Finite Decimal Expansion', () => {
  it('1/2 = 0.5', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 2)
    expect(integer).toBe(0)
    expect(decimals).toEqual([5])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/5 = 0.2', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 5)
    expect(integer).toBe(0)
    expect(decimals).toEqual([2])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/8 = 0.125', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 8)
    expect(integer).toBe(0)
    expect(decimals).toEqual([1, 2, 5])
    expect(cycleIndex).toBeUndefined()
  })

  it('255/40 = 6.375', () => {
    const [integer, decimals, cycleIndex] = decExp(255, 40)
    expect(integer).toBe(6)
    expect(decimals).toEqual([3, 7, 5])
    expect(cycleIndex).toBeUndefined()
  })
})

describe('Repeating Decimal Expansion', () => {
  it('1/3 = 0.(3)', () => {
    expect(decExp(1, 3)).toStrictEqual([0, [3], 0])
  })

  it('1/6 = 0.1(6)', () => {
    expect(decExp(1, 6)).toStrictEqual([0, [1, 6], 1])
  })

  it('1/7 = 0.(142857)', () => {
    expect(decExp(1, 7)).toStrictEqual([0, [1, 4, 2, 8, 5, 7], 0])
  })
})



describe('Finite Binary Expansion', () => {
  it('1/2 = 0.1₂', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 2, 2)
    expect(integer).toBe(0)
    expect(decimals).toEqual([1])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/8 = 0.001₂', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 8, 2)
    expect(integer).toBe(0)
    expect(decimals).toEqual([0, 0, 1])
    expect(cycleIndex).toBeUndefined()
  })

  it('255/40 = 110.011₂', () => {
    const [integer, decimals, cycleIndex] = decExp(255, 40, 2)
    expect(integer).toBe(110)
    expect(decimals).toEqual([0, 1, 1])
    expect(cycleIndex).toBeUndefined()
  })
})

describe('Repeating Binary Expansion', () => {
  it('1/3 = 0.(01)₂', () => {
    expect(decExp(1, 3, 2)).toStrictEqual([0, [0, 1], 0])
  })

  it('1/5 = 0.(0011)₂', () => {
    expect(decExp(1, 5, 2)).toStrictEqual([0, [0, 0, 1, 1], 0])
  })

  it('1/6 = 0.0(01)₂', () => {
    expect(decExp(1, 6, 2)).toStrictEqual([0, [0, 0, 1], 1])
  })

  it('1/7 = 0.(001)₂', () => {
    expect(decExp(1, 7, 2)).toStrictEqual([0, [0, 0, 1], 0])
  })
})



describe('Finite Octal Expansion', () => {
  it('1/2 = 0.4₈', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 2, 8)
    expect(integer).toBe(0)
    expect(decimals).toEqual([4])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/8 = 0.1₈', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 8, 8)
    expect(integer).toBe(0)
    expect(decimals).toEqual([1])
    expect(cycleIndex).toBeUndefined()
  })

  it('255/40 = 6.3₈', () => {
    const [integer, decimals, cycleIndex] = decExp(255, 40, 8)
    expect(integer).toBe(6)
    expect(decimals).toEqual([3])
    expect(cycleIndex).toBeUndefined()
  })
})

describe('Repeating Octal Expansion', () => {
  it('1/3 = 0.(25)₈', () => {
    expect(decExp(1, 3, 8)).toStrictEqual([0, [2, 5], 0])
  })

  it('1/5 = 0.(1463)₈', () => {
    expect(decExp(1, 5, 8)).toStrictEqual([0, [1, 4, 6, 3], 0])
  })

  it('1/6 = 0.1(25)₈', () => {
    expect(decExp(1, 6, 8)).toStrictEqual([0, [1, 2, 5], 1])
  })

  it('1/7 = 0.(1)₈', () => {
    expect(decExp(1, 7, 8)).toStrictEqual([0, [1], 0])
  })
})



describe('Integers', () => {
  it('1/1 = 1', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 1)
    expect(integer).toBe(1)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })

  it('5/5 = 1', () => {
    const [integer, decimals, cycleIndex] = decExp(5, 5)
    expect(integer).toBe(1)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })

  it('2/1 = 2', () => {
    const [integer, decimals, cycleIndex] = decExp(2, 1)
    expect(integer).toBe(2)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })

  it('9/3 = 3', () => {
    const [integer, decimals, cycleIndex] = decExp(9, 3)
    expect(integer).toBe(3)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })
})



describe('Throws on unsupported base', () => {
  it('negative base', () => {
    expect(() => decExp(1, 1, -2)).toThrow(RangeError)
  })
  it('base 0', () => {
    expect(() => decExp(1, 1, 0)).toThrow(RangeError)
  })
  it('base 1', () => {
    expect(() => decExp(1, 1, 1)).toThrow(RangeError)
  })
  it('base 11', () => {
    expect(() => decExp(1, 1, 11)).toThrow(RangeError)
  })
})
import { lucas } from '../LucasSeries'

describe('Nth Lucas Number', () => {
  it('should return the 20th Lucas Number', () => {
    expect(lucas(20)).toBe(15127)
  })

  it('should return the 20th Lucas Number', () => {
    expect(lucas(0)).toBe(2)
  })

  it('should return the 20th Lucas Number', () => {
    expect(lucas(100)).toBe(792070839848372100000)
  })
})
import { factorialize } from '../WhileLoopFactorial'

function testFactorial (n, expected) {
  test('Testing on ' + n + '!', () => {
    expect(factorialize(n)).toBe(expected)
  })
}

testFactorial(3, 6)
testFactorial(7, 5040)
testFactorial(0, 1)
testFactorial(12, 479001600)
import { findMaxRecursion } from '../FindMaxRecursion'

describe('Test findMaxRecursion function', () => {
  const positiveAndNegativeArray = [1, 2, 4, 5, -1, -2, -4, -5]
  const positiveAndNegativeArray1 = [10, 40, 100, 20, -10, -40, -100, -20]

  const positiveArray = [1, 2, 4, 5]
  const positiveArray1 = [10, 40, 100, 20]

  const negativeArray = [-1, -2, -4, -5]
  const negativeArray1 = [-10, -40, -100, -20]

  const zeroArray = [0, 0, 0, 0]
  const emptyArray = []

  it('Testing with positive arrays', () => {
    expect(findMaxRecursion(positiveArray, 0, positiveArray.length - 1)).toBe(5)
    expect(findMaxRecursion(positiveArray1, 0, positiveArray1.length - 1)).toBe(
      100
    )
  })

  it('Testing with negative arrays', () => {
    expect(findMaxRecursion(negativeArray, 0, negativeArray.length - 1)).toBe(
      -1
    )
    expect(findMaxRecursion(negativeArray1, 0, negativeArray1.length - 1)).toBe(
      -10
    )
  })

  it('Testing with positive and negative arrays', () => {
    expect(
      findMaxRecursion(
        positiveAndNegativeArray,
        0,
        positiveAndNegativeArray.length - 1
      )
    ).toBe(5)
    expect(
      findMaxRecursion(
        positiveAndNegativeArray1,
        0,
        positiveAndNegativeArray1.length - 1
      )
    ).toBe(100)
  })

  it('Testing with zero arrays', () => {
    expect(findMaxRecursion(zeroArray, 0, zeroArray.length - 1)).toBe(0)
  })

  it('Testing with empty arrays', () => {
    expect(findMaxRecursion(emptyArray, 0, emptyArray.length - 1)).toBe(
      undefined
    )
  })
})
import { sieveOfEratosthenes } from '../SieveOfEratosthenes'
import { PrimeCheck } from '../PrimeCheck'

describe('should return an array of prime booleans', () => {
  it('should have each element in the array as a prime boolean', () => {
    const n = 30
    const primes = sieveOfEratosthenes(n)
    primes.forEach((primeBool, index) => {
      if (primeBool) {
        expect(PrimeCheck(index)).toBeTruthy()
      }
    })
  })
})
import { sumOfGeometricProgression } from '../SumOfGeometricProgression'

describe('Sum Of Geometric Progression', () => {
  it('should return the sum of a finite GP', () => {
    expect(sumOfGeometricProgression(100, 1.5, 4)).toBe(812.5)
  })

  it('should return the sum of an infinite GP', () => {
    expect(sumOfGeometricProgression(2, 0.5, Infinity)).toBe(4)
  })
})
import { findHCF } from '../FindHcf'

describe('findHCF', () => {
  it('should throw a statement for values less than 1', () => {
    expect(findHCF(0, 0)).toBe('Please enter values greater than zero.')
  })

  it('should throw a statement for one value less than 1', () => {
    expect(findHCF(0, 1)).toBe('Please enter values greater than zero.')
    expect(findHCF(1, 0)).toBe('Please enter values greater than zero.')
  })

  it('should return an error for values non-integer values', () => {
    expect(findHCF(2.24, 4.35)).toBe('Please enter whole numbers.')
  })

  it('should return the HCF of two given integers', () => {
    expect(findHCF(27, 36)).toBe(9)
  })
})
import { armstrongNumber } from '../ArmstrongNumber'

describe('ArmstrongNumber', () => {
  it('should return true for an armstrong number', () => {
    expect(armstrongNumber(371)).toBeTruthy()
  })

  it('should return false for a non-armstrong number', () => {
    expect(armstrongNumber(300)).toBeFalsy()
  })
  it('should return false for negative values', () => {
    expect(armstrongNumber(-2)).toBeFalsy()
  })
})
import { EulersTotient } from '../EulersTotient'

describe('EulersTotient', () => {
  it('should return 6 as 1, 2, 4, 5, 7, and 8 are coprime to 9', () => {
    expect(EulersTotient(9)).toBe(6)
  })

  it('should return 4 as 1, 3, 7, and 9 are coprime to 10', () => {
    expect(EulersTotient(10)).toBe(4)
  })
})
import { sqrt } from '../SquareRoot'

test('Check SquareRoot of 4 is 2', () => {
  const res = sqrt(4, 10)
  expect(res).toBeCloseTo(2)
})

test('Check SquareRoot of 2 is 1.4142135', () => {
  const res = sqrt(2, 10)
  expect(res).toBeCloseTo(1.4142135)
})

test('Check SquareRoot of 3.2 is 1.788854381999832', () => {
  const res = sqrt(3.2, 10)
  expect(res).toBeCloseTo(1.788854381999832)
})

test('Check SquareRoot of 1 is 1', () => {
  const res = sqrt(1, 10)
  expect(res).toBe(1)
})

test('Check SquareRoot of 144 is 12', () => {
  const res = sqrt(144, 10)
  expect(res).toBeCloseTo(12)
})

test('Check SquareRoot of 0 is 0', () => {
  const res = sqrt(0, 10)
  expect(res).toBeCloseTo(0)
})

test('Check SquareRoot of 1000 is 31.62277', () => {
  const res = sqrt(1000, 10)
  expect(res).toBeCloseTo(31.62277)
})
import { PalindromeRecursive, PalindromeIterative } from '../Palindrome'

describe('Palindrome', () => {
  it('should return true for a palindrome for PalindromeRecursive', () => {
    expect(PalindromeRecursive('mom')).toBeTruthy()
  })
  it('should return true  for a palindrome for PalindromeIterative', () => {
    expect(PalindromeIterative('mom')).toBeTruthy()
  })
  it('should return false for a non-palindrome for PalindromeRecursive', () => {
    expect(PalindromeRecursive('Algorithms')).toBeFalsy()
  })
  it('should return true  for a non-palindrome for PalindromeIterative', () => {
    expect(PalindromeIterative('JavaScript')).toBeFalsy()
  })
})
import { getRGBData } from '../Mandelbrot'

if (typeof window !== 'undefined') {
  const rgbData = getRGBData()
  const width = rgbData.length
  const height = rgbData[0].length
  const canvas = document.createElement('canvas')
  canvas.width = width
  canvas.height = height
  const ctx = canvas.getContext('2d')
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const rgb = rgbData[x][y]
      ctx.fillStyle = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')'
      ctx.fillRect(x, y, 1, 1)
    }
  }
  document.body.append(canvas)
}
import { radianToDegree } from '../RadianToDegree'

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(0)
  expect(degreeEqual).toBe(0)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI / 4)
  expect(degreeEqual).toBe(45)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI / 2)
  expect(degreeEqual).toBe(90)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI)
  expect(degreeEqual).toBe(180)
})
import { sumOfDigitsUsingLoop, sumOfDigitsUsingRecursion, sumOfDigitsUsingString } from '../SumOfDigits'

test('Testing on sumOfDigitsUsingLoop', () => {
  const sum = sumOfDigitsUsingLoop(123)
  expect(sum).toBe(6)
})

test('Testing on sumOfDigitsUsingRecursion', () => {
  const sum = sumOfDigitsUsingRecursion(123)
  expect(sum).toBe(6)
})

test('Testing on sumOfDigitsUsingString', () => {
  const sum = sumOfDigitsUsingString(123)
  expect(sum).toBe(6)
})
import { perfectNumber } from '../PerfectNumber'

describe('PerfectNumber', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectNumber(28)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectNumber(10)).toBeFalsy()
  })
})
import { findMin } from '../FindMin'

describe('FindMin', () => {
  test('Should return the minimum number in the array', () => {
    const min = findMin(2, 5, 1, 12, 43, 1, 9)
    expect(min).toBe(1)
  })

  test('Should return the minimum number in the array', () => {
    const min = findMin(21, 513, 6)
    expect(min).toBe(6)
  })

  test('Should throw error', () => {
    const min = () => findMin()
    expect(min).toThrow('Array is empty')
  })
})
import { mean } from '../AverageMean'

describe('Tests for average mean', () => {
  it('should be a function', () => {
    expect(typeof mean).toEqual('function')
  })

  it('should throw error for invalid input', () => {
    expect(() => mean(123)).toThrow()
  })

  it('should return the mean of an array of numbers', () => {
    const meanFunction = mean([1, 2, 4, 5])
    expect(meanFunction).toBe(3)
  })

  it('should return the mean of an array of numbers', () => {
    const meanFunction = mean([10, 40, 100, 20])
    expect(meanFunction).toBe(42.5)
  })
})
import { findLcm } from '../FindLcm'

describe('findLcm', () => {
  it('should throw a statement for values less than 1', () => {
    expect(findLcm(0, 0)).toBe('Please enter values greater than zero.')
  })

  it('should throw a statement for one value less than 1', () => {
    expect(findLcm(1, 0)).toBe('Please enter values greater than zero.')
    expect(findLcm(0, 1)).toBe('Please enter values greater than zero.')
  })

  it('should return an error for values non-integer values', () => {
    expect(findLcm(4.564, 7.39)).toBe('Please enter whole numbers.')
  })

  it('should return the LCM of two given integers', () => {
    expect(findLcm(27, 36)).toBe(108)
  })
})
import { integralEvaluation } from '../SimpsonIntegration'

test('Should return the integral of f(x) = sqrt(x) in [1, 3] to be equal 2.797434', () => {
  const result = integralEvaluation(16, 1, 3, (x) => { return Math.sqrt(x) })
  expect(Number(result.toPrecision(7))).toBe(2.797434)
})

test('Should return the integral of f(x) = sqrt(x) + x^2 in [1, 3] to be equal 11.46410161', () => {
  const result = integralEvaluation(64, 1, 3, (x) => { return Math.sqrt(x) + Math.pow(x, 2) })
  expect(Number(result.toPrecision(10))).toBe(11.46410161)
})

test('Should return the integral of f(x) = log(x) + Pi*x^3 in [5, 12] to be equal 15809.9141543', () => {
  const result = integralEvaluation(128, 5, 12, (x) => { return Math.log(x) + Math.PI * Math.pow(x, 3) })
  expect(Number(result.toPrecision(12))).toBe(15809.9141543)
})
import { agm } from '../ArithmeticGeometricMean.js'

describe('Tests for AGM', () => {
  it('should be a function', () => {
    expect(typeof agm).toEqual('function')
  })

  it('number of parameters should be 2', () => {
    expect(agm.length).toEqual(2)
  })

  const m = 0x100 
  it('should return NaN if any or all params has a negative argument', () => {
        expect(agm(-1 * Math.random() * m, Math.random() * m)).toBe(NaN)
    expect(agm(Math.random() * m, -1 * Math.random() * m)).toBe(NaN)
    expect(agm(-1 * Math.random() * m, -1 * Math.random() * m)).toBe(NaN)
  })

  it('should return Infinity if any arg is Infinity and the other is not 0', () => {
    expect(agm(Math.random() * m + 1, Infinity)).toEqual(Infinity)
    expect(agm(Infinity, Math.random() * m + 1)).toEqual(Infinity)
    expect(agm(Infinity, Infinity)).toEqual(Infinity)
  })

  it('should return NaN if some arg is Infinity and the other is 0', () => {
    expect(agm(0, Infinity)).toBe(NaN)
    expect(agm(Infinity, 0)).toBe(NaN)
  })

  it('should return +0 if any or all args are +0 or -0, and return -0 if all are -0', () => {
    expect(agm(Math.random() * m, 0)).toBe(0)
    expect(agm(0, Math.random() * m)).toBe(0)
    expect(agm(Math.random() * m, -0)).toBe(0)
    expect(agm(-0, Math.random() * m)).toBe(0)
    expect(agm(0, -0)).toBe(0)
    expect(agm(-0, 0)).toBe(0)
    expect(agm(-0, -0)).toBe(-0)
  })

  it('should return NaN if any or all args are NaN', () => {
    expect(agm(Math.random() * m, NaN)).toBe(NaN)
    expect(agm(NaN, Math.random() * m)).toBe(NaN)
    expect(agm(NaN, NaN)).toBe(NaN)
  })

  it('should return an accurate approximation of the AGM between 2 valid input args', () => {
        expect(agm(1, 2)).toBeCloseTo(1.4567910310469068)
    expect(agm(2, 256)).toBeCloseTo(64.45940719438667)
    expect(agm(55555, 34)).toBeCloseTo(9933.4047239552)
        expect(agm(2 ** 48, 3 ** 27)).toBeCloseTo(88506556379265.7)
  })
})
import { powLinear, powFaster } from '../Pow'

describe('Testing powLinear function', () => {
  it('should return 1 for numbers with exponent 0', () => {
    expect(powLinear(2, 0)).toBe(1)
  })

  it('should return 0.5 for numbers with exponent -1', () => {
    expect(powLinear(2, -1)).toBe(0.5)
  })

  it('should return 0 for numbers with base 0', () => {
    expect(powLinear(0, 23)).toBe(0)
  })

  it('should return the base to the exponent power', () => {
    expect(powLinear(24, 4)).toBe(331776)
  })
})

describe('Testing powFaster function', () => {
  it('should return 1 for numbers with exponent 0', () => {
    expect(powFaster(2, 0)).toBe(1)
  })

  it('should return 0.5 for numbers with exponent -1', () => {
    expect(powFaster(2, -1)).toBe(0.5)
  })

  it('should return 0 for numbers with base 0', () => {
    expect(powFaster(0, 23)).toBe(0)
  })

  it('should return the base to the exponent power', () => {
    expect(powFaster(24, 4)).toBe(331776)
  })

  it('should return the result in O(lonN) complexity', () => {
    expect(powFaster(2, 64)).toBe(18446744073709552000)   })
})
import { exponent } from '../BinaryExponentiationIterative'

describe('exponent', () => {
  it('should return 1 when power is 0', () => {
    expect(exponent(5, 0)).toBe(1)
  })

  it('should return 0 when base is 0', () => {
    expect(exponent(0, 7)).toBe(0)
  })

  it('should return the value of a base raised to a power', () => {
    expect(exponent(3, 5)).toBe(243)
  })
})
import { FindMinIterator } from '../FindMinIterator'

describe('FindMinIterator', () => {
  test('given empty array then min is undefined', () => {
    expect(FindMinIterator([])).toBeUndefined()
  })

  test('given single value array then min is found', () => {
    expect(FindMinIterator([1])).toBe(1)
    expect(FindMinIterator([-1])).toBe(-1)
    expect(FindMinIterator([0])).toBe(0)
  })

  test('given array then min is found', () => {
    expect(FindMinIterator([1, 2])).toBe(1)
    expect(FindMinIterator([-1, 10])).toBe(-1)
    expect(FindMinIterator([0, 100])).toBe(0)
    expect(FindMinIterator([100, 0])).toBe(0)
    expect(FindMinIterator([100, 50, 20, 0, -100, 0, 2, 30, 45, 99, 104, 23])).toBe(-100)
  })

  test('given empty generator then min is undefined', () => {
    const src = function* () { }     expect(FindMinIterator(src())).toBeUndefined()
  })

  test('given generator then min is found', () => {
    const src = function* () {       yield 1
      yield -1
      yield 0
    }
    expect(FindMinIterator(src())).toBe(-1)
  })

  test('given string generator then min string length is found', () => {
    const src = function* () {       yield 'abc'
      yield 'de'
      yield 'qwerty'
    }
    expect(FindMinIterator(src(), _x => _x.length)).toBe(2)
  })

  test('given array of objects then min accessor is found', () => {
    const array = [
      { name: 'Item #1', price: 1.0 },
      { name: 'Item #2', price: 0.0 },
      { name: 'Item #3', price: -1.0 }
    ]
    expect(FindMinIterator(array, _x => _x.price)).toBe(-1)
    expect(FindMinIterator(array, _x => _x.name)).toBe('Item #1')
  })
})
import {
  FibonacciDpWithoutRecursion,
  FibonacciRecursiveDP,
  FibonacciIterative,
  FibonacciRecursive,
  FibonacciMatrixExpo
} from '../Fibonacci'

describe('Fibonacci', () => {
  it('should return an array of numbers for FibonacciIterative', () => {
    expect(FibonacciIterative(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return an array of numbers for FibonacciRecursive', () => {
    expect(FibonacciRecursive(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return number for FibonacciRecursiveDP', () => {
    expect(FibonacciRecursiveDP(5)).toBe(5)
  })

  it('should return an array of numbers for FibonacciDpWithoutRecursion', () => {
    expect(FibonacciDpWithoutRecursion(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return number for FibonacciMatrixExpo', () => {
    expect(FibonacciMatrixExpo(0)).toBe(0)
    expect(FibonacciMatrixExpo(1)).toBe(1)
    expect(FibonacciMatrixExpo(2)).toBe(1)
    expect(FibonacciMatrixExpo(3)).toBe(2)
    expect(FibonacciMatrixExpo(4)).toBe(3)
    expect(FibonacciMatrixExpo(5)).toBe(5)
  })
})
import { integralEvaluation } from '../MidpointIntegration'

test('Should return the integral of f(x) = sqrt(x) in [1, 3] to be equal 2.797434', () => {
  const result = integralEvaluation(10000, 1, 3, (x) => { return Math.sqrt(x) })
  expect(Number(result.toPrecision(6))).toBe(2.79743)
})

test('Should return the integral of f(x) = sqrt(x) + x^2 in [1, 3] to be equal 11.46410161', () => {
  const result = integralEvaluation(10000, 1, 3, (x) => { return Math.sqrt(x) + Math.pow(x, 2) })
  expect(Number(result.toPrecision(10))).toBe(11.46410161)
})

test('Should return the integral of f(x) = log(x) + Pi*x^3 in [5, 12] to be equal 15809.9141543', () => {
  const result = integralEvaluation(20000, 5, 12, (x) => { return Math.log(x) + Math.PI * Math.pow(x, 3) })
  expect(Number(result.toPrecision(10))).toBe(15809.91415)
})
import { fareyApproximation } from '../FareyApproximation'

describe('fareyApproximation', () => {
  it('Return Farey Approximation of 0.7538385', () => {
    const approx = fareyApproximation(0.7538385)
    expect(approx).toStrictEqual({ numerator: 52, denominator: 69 })
  })

  it('Return Farey Approximation of 0.23584936', () => {
    const approx = fareyApproximation(0.23584936)
    expect(approx).toStrictEqual({ numerator: 196, denominator: 831 })
  })
})
import { collatz } from '../CollatzSequence'

describe('The Collatz Sequence', () => {
  it('Should be 1', () => {
    expect(collatz(1)).toStrictEqual({ result: 1, steps: [] })
    expect(collatz(5)).toStrictEqual({ result: 1, steps: [16, 8, 4, 2, 1] })
  })
})
import { abs } from '../Abs'

describe('Testing abs function', () => {
  it('Testing for invalid types', () => {
    expect(() => abs('234a')).toThrow()
    expect(() => abs({})).toThrow()
    expect(() => abs([12, -32, -60])).toThrow()
  })

  it('Testing for number of string type', () => {
    expect(abs('-345')).toBe(345)
    expect(abs('-345.455645')).toBe(345.455645)
  })

  it('Testing for a boolean type', () => {
    expect(abs(true)).toBe(1)
    expect(abs(false)).toBe(0)
  })

  it('should return an absolute value of a negative number', () => {
    const absOfNegativeNumber = abs(-34)
    expect(absOfNegativeNumber).toBe(34)
  })

  it('should return an absolute value of a positive number', () => {
    const absOfPositiveNumber = abs(50)
    expect(absOfPositiveNumber).toBe(50)
  })

  it('should return an absolute value of a zero number', () => {
    const absOfPositiveNumber = abs(0)
    expect(absOfPositiveNumber).toBe(0)
  })

  it('should return an absolute value of any floating number', () => {
    const absOfPositiveNumber = abs(-20.2034)
    expect(absOfPositiveNumber).toBe(20.2034)
  })
})
import { numberOfDigit } from '../NumberOfDigits'

describe('NumberOfDigits', () => {
  it('should return the correct number of digits for an integer', () => {
    expect(numberOfDigit(1234000)).toBe(7)
  })

  it('should return the correct number of digits for a negative number', () => {
    expect(numberOfDigit(-2346243)).toBe(7)
  })
})
import { getRGBData } from '../Mandelbrot'

describe('Mandelbrot', () => {
  it('should produce black pixels inside the set', () => {
    const blackAndWhite = getRGBData(800, 600, -0.6, 0, 3.2, 50, false)
    expect(blackAndWhite[400][300]).toEqual([0, 0, 0]) 
    const colorCoded = getRGBData(800, 600, -0.6, 0, 3.2, 50, true)
    expect(colorCoded[400][300]).toEqual([0, 0, 0])   })

  it('should produce white pixels outside of the set', () => {
    const blackAndWhite = getRGBData(800, 600, -0.6, 0, 3.2, 50, false)
    expect(blackAndWhite[0][0]).toEqual([255, 255, 255])   })

  it('should produce colored pixels distant to the set', () => {
    const colorCoded = getRGBData(800, 600, -0.6, 0, 3.2, 50, true)
    expect(colorCoded[0][0]).toEqual([255, 0, 0])   })
})
import { PrimeCheck } from '../PrimeCheck'

describe('PrimeCheck', () => {
  it('should return true for Prime Numbers', () => {
    expect(PrimeCheck(1000003)).toBeTruthy()
  })
  it('should return false for Non Prime Numbers', () => {
    expect(PrimeCheck(1000001)).toBeFalsy()
  })
  it('should return false for 1 and 0', () => {
    expect(PrimeCheck(1)).toBeFalsy()
    expect(PrimeCheck(0)).toBeFalsy()
  })
})
import { PrimeFactors } from '../PrimeFactors'

describe('EulersTotient', () => {
  it('should return the prime factors for 100', () => {
    expect(PrimeFactors(100)).toEqual([2, 2, 5, 5])
  })

  it('should return the prime factors for 2560', () => {
    expect(PrimeFactors(2560)).toEqual([2, 2, 2, 2, 2, 2, 2, 2, 2, 5])
  })
})
import { meanSquaredError } from '../MeanSquareError'

describe('meanSquareError', () => {
  it('should throw an error on non-array arguments', () => {
    expect(() => meanSquaredError(1, 4)).toThrow('Argument must be an Array')
  })

  it('should throw an error on non equal length ', () => {
    const firstArr = [1, 2, 3, 4, 5]
    const secondArr = [1, 2, 3]
    expect(() => meanSquaredError(firstArr, secondArr)).toThrow(
      'The two lists must be of equal length'
    )
  })

  it('should return the mean square error of two equal length arrays', () => {
    const firstArr = [1, 2, 3, 4, 5]
    const secondArr = [1, 3, 5, 6, 7]
    expect(meanSquaredError(firstArr, secondArr)).toBe(2.6)
  })
})
import * as volume from '../Volume'

test('Testing on volCuboid', () => {
  const volCuboid = volume.volCuboid(2.0, 5.0, 3)
  expect(volCuboid).toBe(30.0)
})

test('Testing on volCube', () => {
  const volCube = volume.volCube(2.0)
  expect(volCube).toBe(8.0)
})

test('Testing on volCone', () => {
  const volCone = volume.volCone(3.0, 8.0)
  expect(volCone).toBe(75.39822368615503)
})

test('Testing on volPyramid', () => {
  const volPyramid = volume.volPyramid(2.0, 3.0, 8.0)
  expect(volPyramid).toBe(16.0)
})

test('Testing on volCylinder', () => {
  const volCylinder = volume.volCylinder(3.0, 8.0)
  expect(volCylinder).toBe(226.1946710584651)
})

test('Testing on volTriangularPrism', () => {
  const volTriangularPrism = volume.volTriangularPrism(3.0, 6.0, 8.0)
  expect(volTriangularPrism).toBe(72.0)
})

test('Testing on volPentagonalPrism', () => {
  const volPentagonalPrism = volume.volPentagonalPrism(1.0, 4.0, 8.0)
  expect(volPentagonalPrism).toBe(80.0)
})

test('Testing on volSphere', () => {
  const volSphere = volume.volSphere(4.0)
  expect(volSphere).toBe(268.082573106329)
})

test('Testing on volHemisphere', () => {
  const volHemisphere = volume.volHemisphere(4.0)
  expect(volHemisphere).toBe(134.0412865531645)
})
import { averageMedian } from '../AverageMedian'

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([1, 2, 6, 4, 5])
  expect(medianValue).toBe(4)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([8, 9, 1, 2, 5, 10, 11])
  expect(medianValue).toBe(8)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([15, 18, 3, 9, 13, 5])
  expect(medianValue).toBe(11)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([1, 2, 3, 4, 6, 8])
  expect(medianValue).toBe(3.5)
})
import { binaryExponentiation } from '../BinaryExponentiationRecursive'

describe('BinaryExponentiationRecursive', () => {
  it('should calculate 2 to the power of 10 correctly', () => {
    expect(binaryExponentiation(2, 10)).toBe(1024)
  })

  it('should calculate 3 to the power of 9 correctly', () => {
    expect(binaryExponentiation(3, 9)).toBe(19683)
  })
})
import { gridGetX, gridGetY } from '../GridGet'

describe('GridGet', () => {
  it('should have a value of x for the 27th element if the square array has 400 elements', () => {
    expect(gridGetX(Math.sqrt(400), 27)).toEqual(8)
  })
  it('should have a value of x for the 11th element if the square array has 7 columns and 3 rows', () => {
    expect(gridGetX(7, 11)).toEqual(5)
  })
  it('should have a value of y for the 27th element if the square array has 400 elements', () => {
    expect(gridGetY(Math.sqrt(400), 27)).toEqual(2)
  })
  it('should have a value of y for the 11th element if the square array has 7 columns and 3 rows ', () => {
    expect(gridGetX(7, 11)).toEqual(5)
  })
})
import { powLogarithmic } from '../PowLogarithmic'

describe('PowLogarithmic', () => {
  it('should return 1 for numbers with exponent 0', () => {
    expect(powLogarithmic(2, 0)).toBe(1)
  })

  it('should return 0 for numbers with base 0', () => {
    expect(powLogarithmic(0, 23)).toBe(0)
  })

  it('should return the base to the exponent power', () => {
    expect(powLogarithmic(24, 4)).toBe(331776)
  })
})
import { modularBinaryExponentiation } from '../ModularBinaryExponentiationRecursive'

describe('modularBinaryExponentiation', () => {
  it('should return the binary exponentiation', () => {
    expect(modularBinaryExponentiation(2, 10, 17)).toBe(4)
  })
})
import {
  isTriangular,
  isTetrahedral,
  isPentatope,
  checkAll
} from '../FigurateNumber'

describe('FigurateNumber', () => {
  it('Triangular : should return true', () => {
    expect(isTriangular(1)).toEqual(true)
  })
  it('Triangular : should return true', () => {
    expect(isTriangular(3)).toEqual(true)
  })

  it('Triangular : should return false', () => {
    expect(isTriangular(5)).toEqual(false)
  })

  it('Triangular : should return true', () => {
    expect(isTriangular(171)).toEqual(true)
  })
  /

  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(1)).toEqual(true)
  })
  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(4)).toEqual(true)
  })

  it('Tetrahedral : should return false', () => {
    expect(isTetrahedral(3)).toEqual(false)
  })

  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(165)).toEqual(true)
  })

  /
  it('Pentatope : should return true', () => {
    expect(isPentatope(1)).toEqual(true)
  })
  it('Pentatope : should return true', () => {
    expect(isPentatope(5)).toEqual(true)
  })

  it('Pentatope : should return false', () => {
    expect(isPentatope(3)).toEqual(false)
  })

  it('Pentatope : should return true', () => {
    expect(isPentatope(1001)).toEqual(true)
  })
  /

  it('Check All : should return all true', () => {
    expect(checkAll(1)).toEqual({
      isTriangular: true,
      isTetrahedral: true,
      isPentatope: true
    })
  })

  it('Check All : should return all true,true,false', () => {
    expect(checkAll(15)).toEqual({
      isTriangular: true,
      isTetrahedral: false,
      isPentatope: true
    })
  })
})
import { findRoot } from '../BisectionMethod'

test('Equation f(x) = x^2 - 3*x + 2 = 0, has root x = 1 in [a, b] = [0, 1.5]', () => {
  const root = findRoot(0, 1.5, (x) => { return Math.pow(x, 2) - 3 * x + 2 }, 8)
  expect(root).toBe(0.9990234375)
})

test('Equation f(x) = ln(x) + sqrt(x) + π*x^2 = 0, has root x = 0.36247037 in [a, b] = [0, 10]', () => {
  const root = findRoot(0, 10, (x) => { return Math.log(x) + Math.sqrt(x) + Math.PI * Math.pow(x, 2) }, 32)
  expect(Number(Number(root).toPrecision(8))).toBe(0.36247037)
})

test('Equation f(x) = sqrt(x) + e^(2*x) - 8*x = 0, has root x = 0.93945851 in [a, b] = [0.5, 100]', () => {
  const root = findRoot(0.5, 100, (x) => { return Math.exp(2 * x) + Math.sqrt(x) - 8 * x }, 32)
  expect(Number(Number(root).toPrecision(8))).toBe(0.93945851)
})
import { BinaryConvert } from '../BinaryConvert'

describe('BinaryConvert', () => {
  it('should return the correct value', () => {
    expect(BinaryConvert(4)).toBe(100)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(12)).toBe(1100)
  })
  it('should return the correct value of the sum from two number', () => {
    expect(BinaryConvert(12 + 2)).toBe(1110)
  })
  it('should return the correct value of the subtract from two number', () => {
    expect(BinaryConvert(245 - 56)).toBe(10111101)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(254)).toBe(11111110)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(63483)).toBe(1111011111111011)
  })
})
import { eulerFull, eulerStep } from '../EulerMethod'

describe('eulerStep', () => {
  it('should calculate the next y value correctly', () => {
    expect(eulerStep(0, 0.1, 0, function (x, y) { return x })).toBe(0)
    expect(eulerStep(2, 1, 1, function (x, y) { return x * x })).toBe(5)
  })
})

describe('eulerFull', () => {
  it('should return all the points found', () => {
    expect(eulerFull(0, 3, 1, 0, function (x, y) { return x }))
      .toEqual([{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 1 }, { x: 3, y: 3 }])

    expect(eulerFull(3, 4, 0.5, 1, function (x, y) { return x * x }))
      .toEqual([{ x: 3, y: 1 }, { x: 3.5, y: 5.5 }, { x: 4, y: 11.625 }])
  })
})
import { zellersCongruenceAlgorithm } from '../ZellersCongruenceAlgorithm'

function testZeller (day, month, year, expected) {
  test('Testing on ' + day + '/' + month + '/' + year, () => {
    expect(zellersCongruenceAlgorithm(day, month, year)).toBe(expected)
  })
}

test('Testing on this/should/throw', () => {
  expect(() => {
    zellersCongruenceAlgorithm('this', 'should', 'error')
  }).toThrowError(new TypeError('Arguments are not all numbers.'))
})
testZeller(25, 1, 2013, 'Friday')
testZeller(26, 1, 2013, 'Saturday')
testZeller(16, 4, 2022, 'Saturday')
testZeller(25, 4, 2022, 'Monday')
import { piEstimation } from '../PiApproximationMonteCarlo'

describe('PiApproximationMonteCarlo', () => {
  it('should be between the range of 2 to 4', () => {
    const pi = piEstimation()
    const piRange = pi >= 2 && pi <= 4
    expect(piRange).toBeTruthy()
  })
})
import { extendedEuclideanGCD } from '../ExtendedEuclideanGCD'

describe('extendedEuclideanGCD', () => {
  it('should return valid values in order for positive arguments', () => {
    expect(extendedEuclideanGCD(240, 46)).toMatchObject([2, -9, 47])
    expect(extendedEuclideanGCD(46, 240)).toMatchObject([2, 47, -9])
  })
  it('should give error on non-positive arguments', () => {
    expect(() => extendedEuclideanGCD(0, 240)).toThrowError(new TypeError('Must be positive numbers'))
    expect(() => extendedEuclideanGCD(46, -240)).toThrowError(new TypeError('Must be positive numbers'))
  })
  it('should give error on non-numeric arguments', () => {
    expect(() => extendedEuclideanGCD('240', 46)).toThrowError(new TypeError('Not a Number'))
    expect(() => extendedEuclideanGCD([240, 46])).toThrowError(new TypeError('Not a Number'))
  })
})
/


function lucas (index) {
    if (index < 0) throw new TypeError('Index cannot be Negative')

    if (Math.floor(index) !== index) throw new TypeError('Index cannot be a Decimal')

  let a = 2
  let b = 1
  for (let i = 0; i < index; i++) {
    const temp = a + b
    a = b
    b = temp
  }
  return a
}

export { lucas }
/

const modularBinaryExponentiation = (a, n, m) => {
      if (n === 0) {
    return 1
  } else if (n % 2 === 1) {
    return (modularBinaryExponentiation(a, n - 1, m) * a) % m
  } else {
    const b = modularBinaryExponentiation(a, n / 2, m)
    return (b * b) % m
  }
}

export { modularBinaryExponentiation }


const abs = (num) => {
  const validNumber = +num 
  if (Number.isNaN(validNumber)) {
    throw new TypeError('Argument is NaN - Not a Number')
  }

  return validNumber < 0 ? -validNumber : validNumber }

export { abs }

const powLinear = (base, exponent) => {
  if (exponent < 0) {
    base = 1 / base
    exponent = -exponent
  }

  let result = 1

  while (exponent--) {     result *= base
  }

  return result
}


const powFaster = (base, exponent) => {
  if (exponent < 2) {     return base && ([1, base][exponent] || powFaster(1 / base, -exponent))
  }

  if (exponent & 1) {     return base * powFaster(base * base, exponent >> 1)   }

  return powFaster(base * base, exponent / 2)
}





export { powLinear, powFaster }


const findMin = (...nums) => {
  if (nums.length === 0) {
    throw new TypeError('Array is empty')
  }

  let min = nums[0]
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] < min) {
      min = nums[i]
    }
  }

  return min
}

export { findMin }
/

export const EulersTotient = (n) => {
      let res = n
  for (let i = 2; i * i <= n; i++) {
    if (n % i === 0) {
      while (n % i === 0) {
        n = Math.floor(n / i)
      }
                  res = res - Math.floor(res / i)
    }
  }
  if (n > 1) {
    res = res - Math.floor(res / n)
  }
  return res
}


const PalindromeRecursive = (string) => {
    if (string.length < 2) return true

    if (string[0] !== string[string.length - 1]) {
    return false
  }

  return PalindromeRecursive(string.slice(1, string.length - 1))
}

const PalindromeIterative = (string) => {
  const _string = string
    .toLowerCase()
    .replace(/ /g, '')
    .replace(/,/g, '')
    .replace(/'.'/g, '')
    .replace(/:/g, '')
    .split('')

    while (_string.length > 1) {
    if (_string.shift() !== _string.pop()) {
      return false
    }
  }

  return true
}

export { PalindromeIterative, PalindromeRecursive }
/

function integralEvaluation (N, a, b, func) {
    let isNEven = true
  if (N % 2 !== 0) isNEven = false

  if (!Number.isInteger(N) || Number.isNaN(a) || Number.isNaN(b)) { throw new TypeError('Expected integer N and finite a, b') }
  if (!isNEven) { throw Error('N is not an even number') }
  if (N <= 0) { throw Error('N has to be >= 2') }

    if (a > b) { throw Error('a must be less or equal than b') }
  if (a === b) return 0

    const h = (b - a) / N

    let xi = a   const pointsArray = []

    let temp
  for (let i = 0; i < N + 1; i++) {
    if (i === 0 || i === N) temp = func(xi)
    else if (i % 2 === 0) temp = 2 * func(xi)
    else temp = 4 * func(xi)

    pointsArray.push(temp)
    xi += h
  }

    let result = h / 3
  temp = 0
  for (let i = 0; i < pointsArray.length; i++) temp += pointsArray[i]

  result *= temp

  if (Number.isNaN(result)) { throw Error("Result is NaN. The input interval doesn't belong to the functions domain") }

  return result
}

export { integralEvaluation }
/

'use strict'

const findLcm = (num1, num2) => {
    if (num1 < 1 || num2 < 1) {
    return 'Please enter values greater than zero.'
  }

    if (num1 !== Math.round(num1) || num2 !== Math.round(num2)) {
    return 'Please enter whole numbers.'
  }

    const maxNum = Math.max(num1, num2)
  let lcm = maxNum

  while (true) {
    if (lcm % num1 === 0 && lcm % num2 === 0) return lcm
    lcm += maxNum
  }
}

export { findLcm }


export const agm = (a, g) => {
  if (a === Infinity && g === 0) return NaN
  if (Object.is(a, -0) && !Object.is(g, -0)) return 0
  if (a === g) return a   let x   do {
    [a, g, x] = [(a + g) / 2, Math.sqrt(a * g), a]
  } while (a !== x && !isNaN(a))
  /
  return a
}


const BinaryConvert = (num) => {
  let power = 1
  let binary = 0

  while (num) {
    const rem = num % 2
    num = Math.floor(num / 2)
    binary = rem * power + binary
    power *= 10
  }

  return binary
}

export { BinaryConvert }
/

const gridGetX = (columns, index) => {
  while (index + 1 > columns) {
    index = index - columns
  }
  return index + 1
}

const gridGetY = (columns, index) => {
  return Math.floor(index / columns) + 1
}

export { gridGetX, gridGetY }


const factorsOfANumber = (number = 0) => {
  return Array.from(Array(number + 1).keys()).filter(
    (num) => number % num === 0
  )
}

export { factorsOfANumber }

const piEstimation = (iterations = 100000) => {
  let circleCounter = 0

  for (let i = 0; i < iterations; i++) {
        const x = Math.random()
    const y = Math.random()
    const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))

    if (radius < 1) circleCounter += 1
  }

    const pi = (circleCounter / iterations) * 4
  return pi
}

export { piEstimation }


const armstrongNumber = (num) => {
  if (num < 0 || typeof num !== 'number') return false

  let newSum = 0

  const numArr = num.toString().split('')
  numArr.forEach((num) => {
    newSum += parseInt(num) ** numArr.length
  })

  return newSum === num
}

export { armstrongNumber }


const findRoot = (a, b, func, numberOfIterations) => {
    const belongsToDomain = (x, f) => {
    const res = f(x)
    return !Number.isNaN(res)
  }
  if (!belongsToDomain(a, func) || !belongsToDomain(b, func)) throw Error("Given interval is not a valid subset of function's domain")

    const hasRoot = (a, b, func) => {
    return func(a) * func(b) < 0
  }
  if (hasRoot(a, b, func) === false) { throw Error('Product f(a)*f(b) has to be negative so that Bolzano theorem is applied') }

    const m = (a + b) / 2

    if (numberOfIterations === 0) { return m }

    const fm = func(m)
  const prod1 = fm * func(a)
  const prod2 = fm * func(b)

    if (prod1 > 0 && prod2 < 0) return findRoot(m, b, func, --numberOfIterations)
  else if (prod1 < 0 && prod2 > 0) return findRoot(a, m, func, --numberOfIterations)
  else throw Error('Unexpected behavior')
}

export { findRoot }
const addRow = (triangle) => {
  const previous = triangle[triangle.length - 1]
  const newRow = [1]
  for (let i = 0; i < previous.length - 1; i++) {
    const current = previous[i]
    const next = previous[i + 1]
    newRow.push(current + next)
  }
  newRow.push(1)
  return triangle.push(newRow)
}

const generate = (numRows) => {
  const triangle = [[1], [1, 1]]

  if (numRows === 0) {
    return []
  } else if (numRows === 1) {
    return [[1]]
  } else if (numRows === 2) {
    return [[1], [1, 1]]
  } else {
    for (let i = 2; i < numRows; i++) {
      addRow(triangle)
    }
  }
  return triangle
}

export { generate }
/

const PrimeCheck = (n) => {
      if (n === 1) return false
  if (n === 0) return false
  if (n === 2) return true
  if (n % 2 === 0) return false

  for (let i = 3; i * i <= n; i += 2) {
    if (n % i === 0) {
      return false
    }
  }
  return true
}

export { PrimeCheck }
const sieveOfEratosthenes = (n) => {
  /
  const primes = new Array(n + 1)
  primes.fill(true)   primes[0] = primes[1] = false   const sqrtn = Math.ceil(Math.sqrt(n))
  for (let i = 2; i <= sqrtn; i++) {
    if (primes[i]) {
      for (let j = i * i; j <= n; j += i) {
        /
        primes[j] = false
      }
    }
  }
  return primes
}

export { sieveOfEratosthenes }


const matrixCheck = (matrix) => {
  let columnNumb
  for (let index = 0; index < matrix.length; index++) {
    if (index === 0) {
      columnNumb = matrix[index].length
    } else if (matrix[index].length !== columnNumb) {
          } else {
      return columnNumb
    }
  }
}

const twoMatricesCheck = (first, second) => {
  const [firstRowLength, secondRowLength, firstColLength, secondColLength] = [first.length, second.length, matrixCheck(first), matrixCheck(second)]
  if (firstRowLength !== secondColLength || secondRowLength !== firstColLength) {
        return false
  } else {
    return true
  }
}

const initiateEmptyArray = (first, second) => {
  if (twoMatricesCheck(first, second)) {
    const emptyArray = first.map(() => {
      return ['']
    })
    return emptyArray
  } else {
    return false
  }
}

export const matrixMult = (firstArray, secondArray) => {
  const multMatrix = initiateEmptyArray(firstArray, secondArray)
  for (let rm = 0; rm < firstArray.length; rm++) {
    const rowMult = []
    for (let col = 0; col < firstArray[0].length; col++) {
      rowMult.push(firstArray[rm][col])
    }
    for (let cm = 0; cm < firstArray.length; cm++) {
      const colMult = []
      for (let row = 0; row < secondArray.length; row++) {
        colMult.push(secondArray[row][cm])
      }
      let newNumb = 0
      for (let index = 0; index < rowMult.length; index++) {
        newNumb += rowMult[index] * colMult[index]
      }
      multMatrix[rm][cm] = newNumb
    }
  }
  return multMatrix
}






function findMaxRecursion (arr, left, right) {
  const len = arr.length

  if (len === 0 || !arr) {
    return undefined
  }

  if (left >= len || left < -len || right >= len || right < -len) {
    throw new Error('Index out of range')
  }

  if (left === right) {
    return arr[left]
  }

    const mid = (left + right) >> 1

  const leftMax = findMaxRecursion(arr, left, mid)
  const rightMax = findMaxRecursion(arr, mid + 1, right)

    return Math.max(leftMax, rightMax)
}

export { findMaxRecursion }
/

/
function sumOfDigitsUsingString (number) {
  if (number < 0) number = -number

  return Number.parseInt(number.toString().split('').reduce((a, b) => Number(a) + Number(b)))
}

/
function sumOfDigitsUsingLoop (number) {
  if (number < 0) number = -number
  let res = 0

  while (number > 0) {
    res += number % 10
    number = Math.floor(number / 10)
  }

  return res
}

/
function sumOfDigitsUsingRecursion (number) {
  if (number < 0) number = -number

  if (number < 10) return number

  return (number % 10) + sumOfDigitsUsingRecursion(Math.floor(number / 10))
}

export { sumOfDigitsUsingRecursion, sumOfDigitsUsingLoop, sumOfDigitsUsingString }
/

const gcdOfTwoNumbers = (x, y) => {
            return x === 0 ? y : gcdOfTwoNumbers(y % x, x)
}

const eulersTotientFunction = (n) => {
  let countOfRelativelyPrimeNumbers = 1
  for (let iterator = 2; iterator <= n; iterator++) {
    if (gcdOfTwoNumbers(iterator, n) === 1) countOfRelativelyPrimeNumbers++
  }
  return countOfRelativelyPrimeNumbers
}

export { eulersTotientFunction }
/

const GetEuclidGCD = (arg1, arg2) => {
  let less = arg1 > arg2 ? arg2 : arg1
  for (less; less >= 2; less--) {
    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)
  }
  return (less)
}


const CoPrimeCheck = (firstNumber, secondNumber) => {
    if (typeof firstNumber !== 'number' || typeof secondNumber !== 'number') {
    return new TypeError('Argument is not a number.')
  }
  /
  return GetEuclidGCD(firstNumber, secondNumber) === 1
}

export { CoPrimeCheck }


const mean = (nums) => {
  if (!Array.isArray(nums)) {
    throw new TypeError('Invalid Input')
  }

    const sum = nums.reduce((sum, cur) => sum + cur, 0)

    return sum / nums.length
}

export { mean }
/

const averageMedian = (sourceArrayOfNumbers) => {
  let numbers = [...sourceArrayOfNumbers]
  let median = 0
  const numLength = numbers.length
  numbers = numbers.sort(sortNumbers)

  if (numLength % 2 === 0) {
    median = (numbers[numLength / 2 - 1] + numbers[numLength / 2]) / 2
  } else {
    median = numbers[(numLength - 1) / 2]
  }

  return median
}

const sortNumbers = (num1, num2) => {
  return num1 - num2
}

export { averageMedian }
/


export const degreeToRadian = (degree) => {
  return degree * (Math.PI / 180)
}
/


const GetEuclidGCD = (arg1, arg2) => {
    if (typeof arg1 !== 'number' || typeof arg2 !== 'number') {
    return new TypeError('Argument is not a number.')
  }
    if (arg1 < 1 || arg2 < 1) {
    return new TypeError('Argument is a negative number.')
  }
    let less = arg1 > arg2 ? arg2 : arg1
    for (less; less >= 2; less--) {
    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)
  }
  return (less)
}

export { GetEuclidGCD }



const factorial = (n) => {
  if (n >= 0) {
    if (n === 0) {
      return 1
    } else {
      return n * factorial(n - 1)
    }
  } else {
    return NaN
  }
}


const permutation = (n, r) => {
  return factorial(n) / factorial(n - r)
}


const combination = (n, r) => {
  return factorial(n) / (factorial(r) * factorial(n - r))
}

export { factorial, permutation, combination }


const numberOfDigit = (n) => Math.abs(n).toString().length

export { numberOfDigit }



const extendedEuclideanGCD = (arg1, arg2) => {
  if (typeof arg1 !== 'number' || typeof arg2 !== 'number') throw new TypeError('Not a Number')
  if (arg1 < 1 || arg2 < 1) throw new TypeError('Must be positive numbers')

    if (arg1 < arg2) {
    const res = extendedEuclideanGCD(arg2, arg1)
    const temp = res[1]
    res[1] = res[2]
    res[2] = temp
    return res
  }

  
    let r0 = arg1
  let r1 = arg2

    let s0 = 1
  let s1 = 0

    let t0 = 0
  let t1 = 1

  while (r1 !== 0) {
    const q = Math.floor(r0 / r1)

    const r2 = r0 - r1 * q
    const s2 = s0 - s1 * q
    const t2 = t0 - t1 * q

    r0 = r1
    r1 = r2
    s0 = s1
    s1 = s2
    t0 = t1
    t1 = t2
  }
  return [r0, s0, t0]
}

export { extendedEuclideanGCD }
/


function aliquotSum (input) {
    if (input < 0) throw new TypeError('Input cannot be Negative')

    if (Math.floor(input) !== input) throw new TypeError('Input cannot be a Decimal')

    if (input === 1) return 0

  let sum = 0
  for (let i = 1; i <= (input / 2); i++) {
    if (input % i === 0) sum += i
  }

  return sum
}

export { aliquotSum }
import { PrimeCheck } from './PrimeCheck'


function twinPrime (n) {
  const prime = PrimeCheck(n)

  if (!prime) {
    return -1
  }

  if (!PrimeCheck(n + 2)) {
    return -1
  }

  return n + 2
}

export { twinPrime }

export function eulerStep (xCurrent, stepSize, yCurrent, differentialEquation) {
    return yCurrent + stepSize * differentialEquation(xCurrent, yCurrent)
}

export function eulerFull (xStart, xEnd, stepSize, yStart, differentialEquation) {
    const points = [{ x: xStart, y: yStart }]
  let yCurrent = yStart
  let xCurrent = xStart

  while (xCurrent < xEnd) {
        yCurrent = eulerStep(xCurrent, stepSize, yCurrent, differentialEquation)
    xCurrent += stepSize
    points.push({ x: xCurrent, y: yCurrent })
  }

  return points
}
/

const findHCF = (x, y) => {
    if (x < 1 || y < 1) {
    return 'Please enter values greater than zero.'
  }

    if (x !== Math.round(x) || y !== Math.round(y)) {
    return 'Please enter whole numbers.'
  }

    while (Math.max(x, y) % Math.min(x, y) !== 0) {
    if (x > y) {
      x %= y
    } else {
      y %= x
    }
  }

    return Math.min(x, y)
}

export { findHCF }

export const isDivisible = (num1, num2) => {
  if (!Number.isFinite(num1) || !Number.isFinite(num2)) {
    throw new TypeError('Expected a number')
  }
  if (num2 === 0) {
    return false
  }
  return num1 % num2 === 0
}

/
export const factorialize = (num) => {
    let result = 1
    while (num > 1) {
    result *= num     num--   }
    return result
}


const factorsExcludingNumber = (n) => {
  return [...Array(n).keys()].filter((num) => n % num === 0)
}

const perfectNumber = (n) => {
  const factorSum = factorsExcludingNumber(n).reduce((num, initialValue) => {
    return num + initialValue
  }, 0)

  return factorSum === n
}

export { perfectNumber }
const list = []

const FibonacciIterative = (nth) => {
  const sequence = []

  if (nth >= 1) sequence.push(1)
  if (nth >= 2) sequence.push(1)

  for (let i = 2; i < nth; i++) {
    sequence.push(sequence[i - 1] + sequence[i - 2])
  }

  return sequence
}

const FibonacciRecursive = (number) => {
  return (() => {
    switch (list.length) {
      case 0:
        list.push(1)
        return FibonacciRecursive(number)
      case 1:
        list.push(1)
        return FibonacciRecursive(number)
      case number:
        return list
      default:
        list.push(list[list.length - 1] + list[list.length - 2])
        return FibonacciRecursive(number)
    }
  })()
}

const dict = new Map()

const FibonacciRecursiveDP = (stairs) => {
  if (stairs <= 0) return 0
  if (stairs === 1) return 1

    if (dict.has(stairs)) return dict.get(stairs)

  const res =
    FibonacciRecursiveDP(stairs - 1) + FibonacciRecursiveDP(stairs - 2)

  dict.set(stairs, res)

  return res
}


const FibonacciDpWithoutRecursion = (number) => {
  const table = []
  table.push(1)
  table.push(1)
  for (let i = 2; i < number; ++i) {
    table.push(table[i - 1] + table[i - 2])
  }
  return table
}


const copyMatrix = (A) => {
  return A.map(row => row.map(cell => cell))
}

const Identity = (size) => {
  const I = Array(size).fill(null).map(() => Array(size).fill())
  return I.map((row, rowIdx) => row.map((_col, colIdx) => {
    return rowIdx === colIdx ? 1 : 0
  }))
}

const matrixMultiply = (A, B) => {
  A = copyMatrix(A)
  B = copyMatrix(B)
  const l = A.length
  const m = B.length
  const n = B[0].length   const C = Array(l).fill(null).map(() => Array(n).fill())
  for (let i = 0; i < l; i++) {
    for (let j = 0; j < n; j++) {
      C[i][j] = 0
      for (let k = 0; k < m; k++) {
        C[i][j] += A[i][k] * B[k][j]
      }
    }
  }
  return C
}


const matrixExpo = (A, n) => {
  A = copyMatrix(A)

    let result = Identity(A.length)   while (n > 0) {
    if (n % 2 !== 0) result = matrixMultiply(result, A)
    n = Math.floor(n / 2)
    if (n > 0) A = matrixMultiply(A, A)
  }
  return result
}

const FibonacciMatrixExpo = (n) => {
      
      
      
  if (n === 0) return 0

  const A = [
    [1, 1],
    [1, 0]
  ]
  const poweredA = matrixExpo(A, n - 1)   let F = [
    [1],
    [0]
  ]
  F = matrixMultiply(poweredA, F)
  return F[0][0]
}

export { FibonacciDpWithoutRecursion }
export { FibonacciIterative }
export { FibonacciRecursive }
export { FibonacciRecursiveDP }
export { FibonacciMatrixExpo }

const Softmax = (inputs) => {
  const eulerExpOfAllInputs = inputs.map(input => Math.exp(input))
  const sumOfEulerExpOfAllInputs = eulerExpOfAllInputs.reduce((a, b) => a + b)

  return inputs.map((input) => {
    const eulerExpInputs = Math.exp(input)
    return eulerExpInputs / sumOfEulerExpOfAllInputs
  })
}

export { Softmax }
export const zellersCongruenceAlgorithm = (day, month, year) => {
  if (typeof day !== 'number' || typeof month !== 'number' || typeof year !== 'number') {
    throw new TypeError('Arguments are not all numbers.')
  }
  const q = day
  let m = month
  let y = year
  if (month < 3) {
    m += 12
    y -= 1
  }
  day =
      (q + Math.floor(26 * (m + 1) / 10) + (y % 100) + Math.floor((y % 100) / 4) + Math.floor(Math.floor(y / 100) / 4) + (5 * Math.floor(y / 100))) %
          7
  const days = [
    'Saturday',
    'Sunday',
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday'
  ]
  return days[day]
}

class Polynomial {
  constructor (array) {
    this.coefficientArray = array     this.polynomial = ''     this.construct()
  }

  /
  construct () {
    this.polynomial = this.coefficientArray
      .map((coefficient, exponent) => {
        if (coefficient === 0) {
          return '0'
        }
        if (exponent === 0) {
          return `(${coefficient})`
        } else if (exponent === 1) {
          return `(${coefficient}x)`
        } else {
          return `(${coefficient}x^${exponent})`
        }
      })
      .filter((x) =>
        x !== '0'
      )
      .reverse()
      .join(' + ')
  }

  /
  display () {
    return this.polynomial
  }

  /
  evaluate (value) {
    return this.coefficientArray.reduce((result, coefficient, exponent) => {
      return result + coefficient * Math.pow(value, exponent)
    }, 0)
  }
}

export { Polynomial }
/


const surfaceAreaCube = (side) => {
  validateNumericParam(side, 'side')
  return 6 * side ** 2
}


const surfaceAreaSphere = (radius) => {
  validateNumericParam(radius, 'radius')
  return 4.0 * Math.PI * radius ** 2.0
}


const areaRectangle = (length, width) => {
  validateNumericParam(length, 'Length')
  validateNumericParam(width, 'Width')
  return width * length
}


const areaSquare = (side) => {
  validateNumericParam(side, 'square side')
  return side ** 2
}


const areaTriangle = (base, height) => {
  validateNumericParam(base, 'Base')
  validateNumericParam(height, 'Height')
  return (base * height) / 2.0
}


const areaTriangleWithAllThreeSides = (side1, side2, side3) => {
  validateNumericParam(side1, 'side1')
  validateNumericParam(side2, 'side2')
  validateNumericParam(side3, 'side3')
  if (
    side1 + side2 <= side3 ||
    side1 + side3 <= side2 ||
    side2 + side3 <= side1
  ) {
    throw new TypeError('Invalid Triangle sides.')
  }
    const semi = (side1 + side2 + side3) / 2

    const area = Math.sqrt(
    semi * (semi - side1) * (semi - side2) * (semi - side3)
  )
  return Number(area.toFixed(2))
}


const areaParallelogram = (base, height) => {
  validateNumericParam(base, 'Base')
  validateNumericParam(height, 'Height')
  return base * height
}


const areaTrapezium = (base1, base2, height) => {
  validateNumericParam(base1, 'Base One')
  validateNumericParam(base2, 'Base Two')
  validateNumericParam(height, 'Height')
  return (1 / 2) * (base1 + base2) * height
}


const areaCircle = (radius) => {
  validateNumericParam(radius, 'Radius')
  return Math.PI * radius ** 2
}


const areaRhombus = (diagonal1, diagonal2) => {
  validateNumericParam(diagonal1, 'diagonal one')
  validateNumericParam(diagonal2, 'diagonal two')
  return (1 / 2) * diagonal1 * diagonal2
}

const validateNumericParam = (param, paramName = 'param') => {
  if (typeof param !== 'number') {
    throw new TypeError('The ' + paramName + ' should be type Number')
  } else if (param < 0) {
    throw new Error('The ' + paramName + ' only accepts non-negative values')
  }
}

export {
  surfaceAreaCube,
  surfaceAreaSphere,
  areaRectangle,
  areaSquare,
  areaTriangle,
  areaParallelogram,
  areaTrapezium,
  areaCircle,
  areaRhombus,
  areaTriangleWithAllThreeSides
}

const meanSquaredError = (predicted, expected) => {
  if (!Array.isArray(predicted) || !Array.isArray(expected)) {
    throw new TypeError('Argument must be an Array')
  }

  if (predicted.length !== expected.length) {
    throw new TypeError('The two lists must be of equal length')
  }

  let err = 0

  for (let i = 0; i < expected.length; i++) {
    err += (expected[i] - predicted[i]) ** 2
  }

  return err / expected.length
}

export { meanSquaredError }
/

export const PrimeFactors = (n) => {
      const primeFactors = []
  for (let i = 2; i * i <= n; i++) {
    while (n % i === 0) {
      primeFactors.push(i)
      n = Math.floor(n / i)
    }
  }
  if (n > 1) {
    primeFactors.push(n)
  }
  return primeFactors
}

export function decExp (a, b, base = 10, exp = [], d = {}, dlen = 0) {
  if (base < 2 || base > 10) {
    throw new RangeError('Unsupported base. Must be in range [2, 10]')
  }

  if (a === 0) {
    return [0, [], undefined]
  }

  if (a === b && dlen === 0) {
    return [1, [], undefined]
  }

      d[a] = dlen++

  if (a < b) {
    exp.push(0)
    return decExp(a * base, b, base, exp, d, dlen)
  }

    const r = a % b
  const q = (a - r) / b

    exp.push(+q.toString(base))

  if (r === 0) {
        return [exp[0], exp.slice(1), undefined]
  }

    a = r * base

      if (a in d) {
    return [exp[0], exp.slice(1), d[a] - 1]
  }

  return decExp(a, b, base, exp, d, dlen)
}
const LinearSieve = (n) => {
  /
  const isnPrime = new Array(n + 1)
  isnPrime[0] = isnPrime[1] = true
  const primes = []
  for (let i = 2; i <= n; i++) {
    if (!isnPrime[i]) primes.push(i)
    for (const p of primes) {
      const k = i * p
      if (k > n) break
      isnPrime[k] = true
      if (i % p === 0) break
    }
  }
  return primes
}

export { LinearSieve }

export function getRGBData (
  imageWidth = 800,
  imageHeight = 600,
  figureCenterX = -0.6,
  figureCenterY = 0,
  figureWidth = 3.2,
  maxStep = 50,
  useDistanceColorCoding = true) {
  if (imageWidth <= 0) {
    throw new Error('imageWidth should be greater than zero')
  }

  if (imageHeight <= 0) {
    throw new Error('imageHeight should be greater than zero')
  }

  if (maxStep <= 0) {
    throw new Error('maxStep should be greater than zero')
  }

  const rgbData = []
  const figureHeight = figureWidth / imageWidth * imageHeight

    for (let imageX = 0; imageX < imageWidth; imageX++) {
    rgbData[imageX] = []
    for (let imageY = 0; imageY < imageHeight; imageY++) {
            const figureX = figureCenterX + (imageX / imageWidth - 0.5) * figureWidth
      const figureY = figureCenterY + (imageY / imageHeight - 0.5) * figureHeight

      const distance = getDistance(figureX, figureY, maxStep)

            rgbData[imageX][imageY] =
        useDistanceColorCoding
          ? colorCodedColorMap(distance)
          : blackAndWhiteColorMap(distance)
    }
  }

  return rgbData
}


function blackAndWhiteColorMap (distance) {
  return distance >= 1 ? [0, 0, 0] : [255, 255, 255]
}


function colorCodedColorMap (distance) {
  if (distance >= 1) {
    return [0, 0, 0]
  } else {
            const hue = 360 * distance
    const saturation = 1
    const val = 255
    const hi = (Math.floor(hue / 60)) % 6
    const f = hue / 60 - Math.floor(hue / 60)

    const v = val
    const p = 0
    const q = Math.floor(val * (1 - f * saturation))
    const t = Math.floor(val * (1 - (1 - f) * saturation))

    switch (hi) {
      case 0:
        return [v, t, p]
      case 1:
        return [q, v, p]
      case 2:
        return [p, v, t]
      case 3:
        return [p, q, v]
      case 4:
        return [t, p, v]
      default:
        return [v, p, q]
    }
  }
}


function getDistance (figureX, figureY, maxStep) {
  let a = figureX
  let b = figureY
  let currentStep = 0
  for (let step = 0; step < maxStep; step++) {
    currentStep = step
    const aNew = a * a - b * b + figureX
    b = 2 * a * b + figureY
    a = aNew

            if (a * a + b * b > 4) {
      break
    }
  }
  return currentStep / (maxStep - 1)
}
/


const modularExponentiation = (base, exponent, modulus) => {
  if (modulus === 1) return 0 
  let result = 1
  base %= modulus 
  while (exponent > 0) {
        if (exponent % 2 === 1) {
      result = (result * base) % modulus
      exponent--
    } else {
      exponent = exponent / 2       base = (base * base) % modulus
    }
  }

  return result
}


const fermatPrimeCheck = (n, numberOfIterations = 50) => {
    if (n <= 1 || n === 4) return false
  if (n <= 3) return true 
  for (let i = 0; i < numberOfIterations; i++) {
        const randomNumber = Math.floor(Math.random() * (n - 2) + 2)

        if (modularExponentiation(randomNumber, n - 1, n) !== 1) {
      return false
    }
  }

      return true
}

export { modularExponentiation, fermatPrimeCheck }
/

/
const volCuboid = (width, length, height) => {
  isNumber(width, 'Width')
  isNumber(length, 'Length')
  isNumber(height, 'Height')
  return (width * length * height)
}

/
const volCube = (length) => {
  isNumber(length, 'Length')
  return (length ** 3)
}

/
const volCone = (radius, height) => {
  isNumber(radius, 'Radius')
  isNumber(height, 'Height')
  return (Math.PI * radius ** 2 * height / 3.0)
}

/
const volPyramid = (baseLength, baseWidth, height) => {
  isNumber(baseLength, 'BaseLength')
  isNumber(baseWidth, 'BaseWidth')
  isNumber(height, 'Height')
  return (baseLength * baseWidth * height) / 3.0
}

/
const volCylinder = (radius, height) => {
  isNumber(radius, 'Radius')
  isNumber(height, 'Height')
  return (Math.PI * radius ** 2 * height)
}

/
const volTriangularPrism = (baseLengthTriangle, heightTriangle, height) => {
  isNumber(baseLengthTriangle, 'BaseLengthTriangle')
  isNumber(heightTriangle, 'HeightTriangle')
  isNumber(height, 'Height')
  return (1 / 2 * baseLengthTriangle * heightTriangle * height)
}

/
const volPentagonalPrism = (pentagonalLength, pentagonalBaseLength, height) => {
  isNumber(pentagonalLength, 'PentagonalLength')
  isNumber(pentagonalBaseLength, 'PentagonalBaseLength')
  isNumber(height, 'Height')
  return (5 / 2 * pentagonalLength * pentagonalBaseLength * height)
}

/
const volSphere = (radius) => {
  isNumber(radius, 'Radius')
  return (4 / 3 * Math.PI * radius ** 3)
}

/
const volHemisphere = (radius) => {
  isNumber(radius, 'Radius')
  return (2.0 * Math.PI * radius ** 3) / 3.0
}

const isNumber = (number, noName = 'number') => {
  if (typeof number !== 'number') {
    throw new TypeError('The ' + noName + ' should be Number type')
  } else if (number < 0 || (!Number.isFinite(number))) {
    throw new Error('The ' + noName + ' only accepts positive values')
  }
}

export { volCuboid, volCube, volCone, volPyramid, volCylinder, volTriangularPrism, volPentagonalPrism, volSphere, volHemisphere }



const exponent = (x, n) => {
  let answer = 1
  while (n > 0) {
    if (n % 2 !== 0) answer *= x
    n = Math.floor(n / 2)
    if (n > 0) x *= x
  }
  return answer
}

export { exponent }
import { isEven } from './IsEven'


const powLogarithmic = (x, n) => {
  if (n === 0) return 1
  const result = powLogarithmic(x, Math.floor(n / 2))
  if (isEven(n)) {
    return result * result
  }
  return result * result * x
}

export { powLogarithmic }
/

'use strict'

const calcRange = (num) => {
  return [...Array(num).keys()].map(i => i + 1)
}

const calcFactorial = (num) => {
  if (num === 0) {
    return 'The factorial of 0 is 1.'
  }
  if (num < 0) {
    return 'Sorry, factorial does not exist for negative numbers.'
  }
  if (!num) {
    return 'Sorry, factorial does not exist for null or undefined numbers.'
  }
  if (num > 0) {
    const range = calcRange(num)
    const factorial = range.reduce((a, c) => a * c, 1)
    return `The factorial of ${num} is ${factorial}`
  }
}

export { calcFactorial }
/


const ReverseNumber = (number) => {
    if (typeof number !== 'number') {
    return new TypeError('Argument is not a number.')
  }
    let reverseNumber = 0
    while (number > 0) {
        const lastDigit = number % 10
        reverseNumber = reverseNumber * 10 + lastDigit
        number = Math.floor(number / 10)
  }
  return reverseNumber
}

export { ReverseNumber }

export function collatz (n) {
  const steps = []

  while (n !== 1) {
    if (n % 2 === 0) {
      n = n / 2
    } else {
      n = 3 * n + 1
    }

    steps.push(n)
  }

  return { result: n, steps: steps }
}



const isTriangular = (number) => {
  for (let i = 0; i <= number; i++) {
    if ((i * (i + 1)) / 2 === number) {
      return true
    } else if ((i * (i + 1)) / 2 > number) {
      return false
    }
  }
  return false
}


const isTetrahedral = (number) => {
  for (let i = 1; i <= number; i++) {
    if ((i * (i + 1) * (i + 2)) / 6 === number) {
      return true
    } else if ((i * (i + 1) * (i + 2)) / 6 > number) {
      return false
    }
  }
  return false
}

const isPentatope = (number) => {
  for (let i = 1; i <= number; i++) {
    if ((i * (i + 1) * (i + 2) * (i + 3)) / 24 === number) {
      return true
    } else if ((i * (i + 1) * (i + 2) * (i + 3)) / 24 > number) {
      return false
    }
  }
  return false
}


const checkAll = (number) => {
  return {
    isTriangular: isTriangular(number),
    isTetrahedral: isTetrahedral(number),
    isPentatope: isPentatope(number)
  }
}
export { isTriangular }
export { isTetrahedral }
export { isPentatope }
export { checkAll }
/


function sumOfGeometricProgression (firstTerm, commonRatio, numOfTerms) {
  if (!Number.isFinite(numOfTerms)) {
    /
    if (Math.abs(commonRatio) < 1) return firstTerm / (1 - commonRatio)
    throw new Error('The geometric progression is diverging, and its sum cannot be calculated')
  }

  if (commonRatio === 1) return firstTerm * numOfTerms

  return (firstTerm * (Math.pow(commonRatio, numOfTerms) - 1)) / (commonRatio - 1)
}

export { sumOfGeometricProgression }

const validateEmail = (str) => {
  if (str === '' || str === null) {
    throw new TypeError('Email Address String Null or Empty.')
  }

  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(str)
}

export { validateEmail }

const upper = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

  return str.replace(
    /[a-z]/g, (char) => String.fromCharCode(char.charCodeAt() - 32)
  )
}

export default upper



const checkSnakeCase = (varName) => {
    if (typeof varName !== 'string') {
    throw new TypeError('Argument is not a string.')
  }

  const pat = /(.*?)_([a-zA-Z])*/
  return pat.test(varName)
}

export { checkSnakeCase }



const isScramble = (s1, s2) => {
  return helper({}, s1, s2)
}

const helper = function (dp, s1, s2) {
  const map = {}

  if (dp[s1 + s2] !== undefined) return dp[s1 + s2]
  if (s1 === s2) return true

  for (let j = 0; j < s1.length; j++) {
    if (map[s1[j]] === undefined) map[s1[j]] = 0
    if (map[s2[j]] === undefined) map[s2[j]] = 0
    map[s1[j]]++
    map[s2[j]]--
  }

  for (const key in map) {
    if (map[key] !== 0) {
      dp[s1 + s2] = false
      return false
    }
  }

  for (let i = 1; i < s1.length; i++) {
    if (
      (helper(dp, s1.substr(0, i), s2.substr(0, i)) &&
        helper(dp, s1.substr(i), s2.substr(i))) ||
      (helper(dp, s1.substr(0, i), s2.substr(s2.length - i)) &&
        helper(dp, s1.substr(i), s2.substr(0, s2.length - i)))
    ) {
      dp[s1 + s2] = true
      return true
    }
  }

  dp[s1 + s2] = false
  return false
}

export { isScramble }

const checkExceeding = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument is not a string')
  }

  const upperChars = str
    .toUpperCase()
    .replace(/[^A-Z]/g, '') 
  const adjacentDiffList = []

  for (let i = 0; i < upperChars.length - 1; i++) {
        const { [i]: char, [i + 1]: adjacentChar } = upperChars

    if (char !== adjacentChar) {
      adjacentDiffList.push(
        Math.abs(char.charCodeAt() - adjacentChar.charCodeAt())
      )
    }
  }

  for (let i = 0; i < adjacentDiffList.length - 1; i++) {
    const { [i]: charDiff, [i + 1]: secondCharDiff } = adjacentDiffList

    if (charDiff > secondCharDiff) {
      return false
    }
  }

  return true
}

export { checkExceeding }
import { checkWordOccurrence } from '../CheckWordOccurrence'

describe('Testing checkWordOccurrence', () => {
  it('expects throw on insert wrong string', () => {
    const value = 123

    expect(() => checkWordOccurrence(value)).toThrow()
  })

  it('expect throw on insert wrong param for case sensitive', () => {
    const value = 'hello'

    expect(() => checkWordOccurrence(value, value)).toThrow()
  })

  it('check occurrence with case sensitive', () => {
    const stringToTest = 'The quick brown fox jumps over the lazy dog'
    const expectResult = { The: 1, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, the: 1, lazy: 1, dog: 1 }

    expect(checkWordOccurrence(stringToTest)).toEqual(expectResult)
  })

  it('check occurrence with case insensitive', () => {
    const stringToTest = 'The quick brown fox jumps over the lazy dog'
    const expectResult = { the: 2, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, lazy: 1, dog: 1 }

    expect(checkWordOccurrence(stringToTest, true)).toEqual(expectResult)
  })
})
import { KMPSearch } from '../KMPPatternSearching'

describe('KMP Matcher', () => {
  it('TC1: expects to return matching indices for pattern in text', () => {
    const text = 'ABC ABCDAB ABCDABCDABDE'
    const pattern = 'ABCDABD'
    expect(KMPSearch(text, pattern)).toStrictEqual([15])
  })

  it('TC2: expects to return matching indices for pattern in text', () => {
    const text = 'ABC ABCDABD ABCDABCDABDE'
    const pattern = 'ABCDABD'
    expect(KMPSearch(text, pattern)).toStrictEqual([4, 16])
  })

  it('TC3: expects to return matching indices for pattern in text', () => {
    const text = 'AAAAA'
    const pattern = 'AAA'
    expect(KMPSearch(text, pattern)).toStrictEqual([0, 1, 2])
  })

  it('TC4: expects to return matching indices for pattern in text', () => {
    const text = 'ABCD'
    const pattern = 'BA'
    expect(KMPSearch(text, pattern)).toStrictEqual([])
  })
})
import { checkCamelCase } from '../CheckCamelCase'
describe('checkCamelCase', () => {
  it('expect to throw an error if input is not a string', () => {
    expect(() => checkCamelCase(null)).toThrow()
  })

  it('expects to return true if the input is in camel case format', () => {
    const value = 'dockerBuild'
    const result = checkCamelCase(value)
    expect(result).toBe(true)
  })

  it('expects to return false if the input is not in camel case format', () => {
    const value = 'docker_build'
    const result = checkCamelCase(value)
    expect(result).toBe(false)
  })
})
import { diceCoefficient } from '../DiceCoefficient'

describe('diceCoefficient', () => {
  it('should calculate edit distance between two strings', () => {
        expect(diceCoefficient('abc', 'abc')).toBe(1)
    expect(diceCoefficient('', '')).toBe(1)

        expect(diceCoefficient('a', '')).toBe(0)
    expect(diceCoefficient('', 'a')).toBe(0)

    expect(diceCoefficient('skate', 'ate')).toBe(0.66)

    expect(diceCoefficient('money', 'honey')).toBe(0.75)

    expect(diceCoefficient('love', 'hate')).toBe(0)

    expect(diceCoefficient('skilled', 'killed')).toBe(0.9)
  })
})
import { createPermutations } from '../CreatePermutations'

describe('createPermutations', () => {
  it('expects to generate 6 different combinations', () => {
    const text = 'abc'
    const SUT = createPermutations(text)
    expect(SUT).toStrictEqual(['abc', 'acb', 'bac', 'bca', 'cab', 'cba'])
  })
  it('expects to generate 2 different combinations', () => {
    const text = '12'
    const SUT = createPermutations(text)
    expect(SUT).toStrictEqual(['12', '21'])
  })
})
import reverseWords from '../ReverseWords'

describe('Testing the reverseWords function', () => {
  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => {
        reverseWords(input)
      }).toThrow('The given value is not a string')
    }
  )

  it('expects to reverse words to return a joined word', () => {
    expect(reverseWords('I Love JS')).toBe('JS Love I')
    expect(reverseWords('Hello World')).toBe('World Hello')
    expect(reverseWords('The Algorithms Javascript')).toBe('Javascript Algorithms The')
  })
})
import { AlternativeStringArrange } from '../AlternativeStringArrange'

test('AlternativeStringArrange(Agrtm, loih) -> Algorithm', () => {
  const str1 = 'Agrtm'
  const str2 = 'loih'
  const res = AlternativeStringArrange(str1, str2)
  expect(res).toEqual('Algorithm')
})

test('AlternativeStringArrange(JvSrp, aacit) -> JavaScript', () => {
  const str1 = 'JvSrp'
  const str2 = 'aacit'
  const res = AlternativeStringArrange(str1, str2)
  expect(res).toEqual('JavaScript')
})

test('AlternativeStringArrange(abc, def) -> adbecf', () => {
  const str1 = 'abc'
  const str2 = 'def'
  const res = AlternativeStringArrange(str1, str2)
  expect(res).toEqual('adbecf')
})
import { checkAnagramMap, checkAnagramRegex } from '../CheckAnagram'

describe('Testing checkAnagramRegex', () => {
  it.each`
    inputOne              | inputTwo
    ${123456}             | ${'abcd'}
    ${[1, 2, 3, 4, 5, 6]} | ${'abcd'}
    ${{ test: 'test' }}   | ${'abcd'}
    ${'abcd'}             | ${123456}
    ${'abcd'}             | ${[1, 2, 3, 4, 5, 6]}
    ${'abcd'}             | ${{ test: 'test' }}
  `(
    'expects to throw the type Error given values $inputOne and $inputTwo',
    ({ inputOne, inputTwo }) => {
      expect(
        () => checkAnagramRegex(inputOne, inputTwo)
      ).toThrowError()
    }
  )

  it('expects to return false if the arguments have different lengths', () => {
    const SUT = checkAnagramRegex('abs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return false if the arguments are not anagrams', () => {
    const SUT = checkAnagramRegex('abcs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return true if the arguments are anagrams', () => {
    const SUT = checkAnagramRegex('abcd', 'bcad')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of length 1 and are the same letter', () => {
    const SUT = checkAnagramRegex('a', 'a')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of are both empty strings', () => {
    const SUT = checkAnagramRegex('', '')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an odd length', () => {
    const SUT = checkAnagramRegex('abcde', 'edcab')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an even length', () => {
    const SUT = checkAnagramRegex('abcdef', 'fedcab')
    expect(SUT).toBe(true)
  })

  it('expects to return false if either argument is an empty string while the other is not', () => {
    const SUT = checkAnagramRegex('', 'edcab')
    expect(SUT).toBe(false)
    const SUT2 = checkAnagramRegex('edcab', '')
    expect(SUT2).toBe(false)
  })

  it('expects to return true if the arguments contain the same letters but have unequal case', () => {
    const SUT = checkAnagramRegex('ABDCE', 'abcde')
    expect(SUT).toBe(true)
    const SUT2 = checkAnagramRegex('AbCdE', 'aBCdE')
    expect(SUT2).toBe(true)
    const SUT3 = checkAnagramRegex('Eleven plus two', 'Twelve plus one')
    expect(SUT3).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain number characters', () => {
    const SUT = checkAnagramRegex('a1b2', '12ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain space characters', () => {
    const SUT = checkAnagramRegex('a1 b2', '1 2ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain punctuation characters', () => {
    const SUT = checkAnagramRegex('a!1b@2', '1@2ba!')
    expect(SUT).toBe(true)
  })

  it('expects to return false if the arguments contain the same letters but contain a different amount of space characters', () => {
    const SUT = checkAnagramRegex('ea        cb', 'e cba')
    expect(SUT).toBe(false)
  })
})

describe('Testing checkAnagramMap', () => {
  it.each`
    inputOne              | inputTwo
    ${123456}             | ${'abcd'}
    ${[1, 2, 3, 4, 5, 6]} | ${'abcd'}
    ${{ test: 'test' }}   | ${'abcd'}
    ${'abcd'}             | ${123456}
    ${'abcd'}             | ${[1, 2, 3, 4, 5, 6]}
    ${'abcd'}             | ${{ test: 'test' }}
  `(
    'expects to throw the type Error given values $inputOne and $inputTwo',
    ({ inputOne, inputTwo }) => {
      expect(
        () => checkAnagramMap(inputOne, inputTwo)
      ).toThrowError()
    }
  )

  it('expects to return false if the arguments have different lengths', () => {
    const SUT = checkAnagramMap('abs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return false if the arguments are not anagrams', () => {
    const SUT = checkAnagramMap('abcs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return true if the arguments are anagrams', () => {
    const SUT = checkAnagramMap('abcd', 'bcad')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of length 1 and are the same letter', () => {
    const SUT = checkAnagramMap('a', 'a')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of are both empty strings', () => {
    const SUT = checkAnagramMap('', '')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an odd length', () => {
    const SUT = checkAnagramMap('abcde', 'edcab')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an even length', () => {
    const SUT = checkAnagramMap('abcdef', 'fedcab')
    expect(SUT).toBe(true)
  })

  it('expects to return false if either argument is an empty string while the other is not', () => {
    const SUT = checkAnagramMap('', 'edcab')
    expect(SUT).toBe(false)
    const SUT2 = checkAnagramMap('edcab', '')
    expect(SUT2).toBe(false)
  })

  it('expects to return true if the arguments contain the same letters but have unequal case', () => {
    const SUT = checkAnagramMap('ABDCE', 'abcde')
    expect(SUT).toBe(true)
    const SUT2 = checkAnagramMap('AbCdE', 'aBCdE')
    expect(SUT2).toBe(true)
    const SUT3 = checkAnagramMap('Eleven plus two', 'Twelve plus one')
    expect(SUT3).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain number characters', () => {
    const SUT = checkAnagramMap('a1b2', '12ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain space characters', () => {
    const SUT = checkAnagramMap('a1 b2', '1 2ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain punctuation characters', () => {
    const SUT = checkAnagramMap('a!1b@2', '1@2ba!')
    expect(SUT).toBe(true)
  })

  it('expects to return false if the arguments contain the same letters but contain a different amount of space characters', () => {
    const SUT = checkAnagramMap('ea        cb', 'e cba')
    expect(SUT).toBe(false)
  })
})
import { countVowels } from '../CountVowels'

describe('CountVowels', () => {
  it('expect throws on use wrong param', () => {
    expect(() => countVowels(0)).toThrow()
  })

  it('count the vowels in a string', () => {
    const value = 'Mad World'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return 0 when input is a string with no vowels', () => {
    const value = 'bcdfgh'
    const count = countVowels(value)
    expect(count).toBe(0)
  })

  it('should return 1 when input is a string of length 1 that is a vowel', () => {
    const value = 'a'
    const count = countVowels(value)
    expect(count).toBe(1)
  })

  it('should return the correct result when input is in all uppercase letters', () => {
    const value = 'ABCDE'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return the correct result when input is in all lowercase letters', () => {
    const value = 'abcdefghi'
    const count = countVowels(value)
    expect(count).toBe(3)
  })

  it('should return the correct result when input string contains spaces', () => {
    const value = 'abc def   ghi'
    const count = countVowels(value)
    expect(count).toBe(3)
  })

  it('should return the correct result when input contains number characters', () => {
    const value = 'a1b2c3'
    const count = countVowels(value)
    expect(count).toBe(1)
  })

  it('should return the correct result when input contains punctuation characters', () => {
    const value = 'a!b.ce)'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return 0 when the input is an empty string', () => {
    const value = ''
    const count = countVowels(value)
    expect(count).toBe(0)
  })

  it('should count multiple occurrences of the same vowel in the input', () => {
    const value = 'aaaaa'
    const count = countVowels(value)
    expect(count).toBe(5)
  })
})
import { permutate } from '../PermutateString'

describe('Permutate a string', () => {
  it('expects to throw an Error with an empty string', () => {
    expect(() => { permutate() }).toThrow('The arg must be a valid, non empty string')
  })
  it('expects to permute "no" into [no, on]', () => {
    expect(['no', 'on']).toEqual(permutate('no'))
  })
  it('expects to permute "yes" into [esy, eys, sey, sye, yes, yse]', () => {
    expect(['esy', 'eys', 'sey', 'sye', 'yes', 'yse']).toEqual(permutate('yes'))
  })
  it('expects to permute "good" into [dgoo dogo doog gdoo godo good odgo odog ogdo ogod oodg oogd ]', () => {
    expect(['dgoo', 'dogo', 'doog', 'gdoo', 'godo', 'good', 'odgo', 'odog', 'ogdo', 'ogod', 'oodg', 'oogd'])
      .toEqual(permutate('good'))
  })
})
import lower from '../Lower'

describe('Testing the Lower function', () => {
  it('Test 1: Check by invalid type', () => {
    expect(() => lower(345)).toThrowError()
    expect(() => lower(true)).toThrowError()
    expect(() => lower(null)).toThrowError()
  })

  it('Test 2: Check by uppercase string', () => {
    expect(lower('WORLD')).toBe('world')
    expect(lower('Hello_WORLD')).toBe('hello_world')
  })

  it('Test 3: Check by lowercase string', () => {
    expect(lower('hello')).toBe('hello')
    expect(lower('hello_world')).toBe('hello_world')
  })
})
import { validateCreditCard } from '../ValidateCreditCard'

describe('Validate credit card number', () => {
  it('should throw error if card number is boolean', () => {
    const invalidCC = true
    expect(() => validateCreditCard(invalidCC)).toThrow(
      'The given value is not a string'
    )
  })
  it('returns true if the credit card number is valid', () => {
    const validCreditCard = '4111111111111111'
    const validationResult = validateCreditCard(validCreditCard)
    expect(validationResult).toBe(true)
  })
  it('should throw an error on non-numeric character in given credit card number', () => {
    const nonNumericCCNumbers = ['123ABCDEF', 'ABCDKDKD', 'ADS232']
    nonNumericCCNumbers.forEach(nonNumericCC => expect(() => validateCreditCard(nonNumericCC)).toThrow(
      `${nonNumericCC} is an invalid credit card number because ` + 'it has nonnumerical characters.'
    ))
  })
  it('should throw an error on credit card with invalid length', () => {
    const ccWithInvalidLength = ['41111', '4111111111111111111111']
    ccWithInvalidLength.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'of its length.'
    ))
  })
  it('should throw an error on credit card with invalid start substring', () => {
    const ccWithInvalidStartSubstring = ['12345678912345', '23456789123456', '789123456789123', '891234567891234', '912345678912345', '31345678912345', '32345678912345', '33345678912345', '38345678912345']
    ccWithInvalidStartSubstring.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'of its first two digits.'
    ))
  })
  it('should throw an error on credit card with luhn check fail', () => {
    const invalidCCs = ['411111111111111', '371211111111111', '49999999999999']
    invalidCCs.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'it fails the Luhn check.'
    ))
  })
})
import { palindromeRearranging } from '../CheckRearrangePalindrome'

test('palindromeRearranging(apple) -> false', () => {
  const word = 'apple'
  const res = palindromeRearranging(word)
  expect(res).toBeFalsy()
})

test('palindromeRearranging(aapplle) -> true', () => {
  const word = 'aapplle'
  const res = palindromeRearranging(word)
  expect(res).toBeTruthy()
})

test('palindromeRearranging(value) -> false', () => {
  const word = 'value'
  const res = palindromeRearranging(word)
  expect(res).toBeFalsy()
})

test('palindromeRearranging(aaeccrr) -> true', () => {
  const word = 'aaeccrr'
  const res = palindromeRearranging(word)
  expect(res).toBeTruthy()
})
import { maxWord } from '../MaxWord'

describe('Testing the maxWord function', () => {
  it('Expect throw with non string argument', () => {
    expect(() => maxWord(10)).toThrow()
  })
  it('get the max word', () => {
    const string = 'be be be be a a banana'
    const mostOccurringWord = maxWord(string)
    expect(mostOccurringWord).toBe('be')
  })
})
import { levenshteinDistance } from '../LevenshteinDistance'

describe('levenshteinDistance', () => {
  it('should calculate edit distance between two strings', () => {
    expect(levenshteinDistance('', '')).toBe(0)
    expect(levenshteinDistance('a', '')).toBe(1)
    expect(levenshteinDistance('', 'a')).toBe(1)
    expect(levenshteinDistance('abc', '')).toBe(3)
    expect(levenshteinDistance('', 'abc')).toBe(3)

        expect(levenshteinDistance('igloo', 'gloo')).toBe(1)

        expect(levenshteinDistance('firm', 'forge')).toBe(3)

        expect(levenshteinDistance('fighting', 'sitting')).toBe(3)

        expect(levenshteinDistance('ball', 'baseball')).toBe(4)

        expect(levenshteinDistance('baseball', 'foot')).toBe(8)
  })
})
import { checkPangramRegex, checkPangramSet } from '../CheckPangram'

describe('Testing checkPangramRegex function', () => {
  it('"The quick brown fox jumps over the lazy dog" is a pangram', () => {
    expect(
      checkPangramRegex('The quick brown fox jumps over the lazy dog')
    ).toBe(true)
  })

  it('"Waltz, bad nymph, for quick jigs vex." is a pangram', () => {
    expect(checkPangramRegex('Waltz, bad nymph, for quick jigs vex.')).toBe(true)
  })

  it('"Jived fox nymph grabs quick waltz." is a pangram', () => {
    expect(checkPangramRegex('Jived fox nymph grabs quick waltz.')).toBe(true)
  })

  it('"My name is Unknown" is NOT a pangram', () => {
    expect(checkPangramRegex('My name is Unknown')).toBe(false)
  })

  it('"The quick brown fox jumps over the la_y dog" is NOT a pangram', () => {
    expect(
      checkPangramRegex('The quick brown fox jumps over the la_y dog')
    ).toBe(false)
  })

  it('Throws an error if given param is not a string', () => {
    expect(() => {
      checkPangramRegex(undefined)
    }).toThrow('The given value is not a string')
  })
})

describe('Testing checkPangramSet function', () => {
  it('"The quick brown fox jumps over the lazy dog" is a pangram', () => {
    expect(
      checkPangramSet('The quick brown fox jumps over the lazy dog')
    ).toBe(true)
  })

  it('"Waltz, bad nymph, for quick jigs vex." is a pangram', () => {
    expect(checkPangramSet('Waltz, bad nymph, for quick jigs vex.')).toBe(true)
  })

  it('"Jived fox nymph grabs quick waltz." is a pangram', () => {
    expect(checkPangramSet('Jived fox nymph grabs quick waltz.')).toBe(true)
  })

  it('"My name is Unknown" is NOT a pangram', () => {
    expect(checkPangramSet('My name is Unknown')).toBe(false)
  })

  it('"The quick brown fox jumps over the la_y dog" is NOT a pangram', () => {
    expect(
      checkPangramSet('The quick brown fox jumps over the la_y dog')
    ).toBe(false)
  })

  it('Throws an error if given param is not a string', () => {
    expect(() => {
      checkPangramSet(undefined)
    }).toThrow('The given value is not a string')
  })
})
import { checkFlatCase } from '../CheckFlatCase'

describe('checkFlatCase function', () => {
  it('should return false when the input string is not in flatcase', () => {
    const actual = checkFlatCase('this is not in flatcase')
    expect(actual).toBe(false)
  })

  it('should return true when the input string is a single letter character', () => {
    const actual = checkFlatCase('a')
    expect(actual).toBe(true)
  })

  it('should return true when the input string is a string of lowercase letter characters with no spaces', () => {
    const actual = checkFlatCase('abcdefghijklmnopqrstuvwxyz')
    expect(actual).toBe(true)
  })
})
import formatPhoneNumber from '../FormatPhoneNumber'

describe('Testing the formatPhoneNumber functions', () => {
  it('expects to throw a type error', () => {
    expect(() => formatPhoneNumber('1234567')).toThrow('Invalid phone number!')
    expect(() => formatPhoneNumber('123456text')).toThrow('Invalid phone number!')
    expect(() => formatPhoneNumber(12345)).toThrow('Invalid phone number!')
  })

  it('expects to return the formatted phone number', () => {
    expect(formatPhoneNumber('1234567890')).toEqual('(123) 456-7890')
    expect(formatPhoneNumber('2124323322')).toEqual('(212) 432-3322')
    expect(formatPhoneNumber('1721543455')).toEqual('(172) 154-3455')
  })
})
import { checkPalindrome } from '../CheckPalindrome'

describe('checkPalindrome', () => {
  it('expects to return "Palindrome" if the given string is a palindrome', () => {
    const SUT = checkPalindrome('madam')
    expect(SUT).toBe('Palindrome')
  })
  it('expects to return "Empty string" if the given string is empty', () => {
    const SUT = checkPalindrome('')
    expect(SUT).toBe('Empty string')
  })
  it('expects to return "Not a string" if the given string is not a string', () => {
    const SUT = checkPalindrome(123)
    expect(SUT).toBe('Not a string')
  })
})
import { checkIfPatternExists } from '../PatternMatching'
describe('checkIfPatternExists', () => {
  it('expects to find a pattern with correct input', () => {
    const text = 'AABAACAADAABAAAABAA'
    const pattern = 'AABA'
    const SUT = checkIfPatternExists(text.toLowerCase(), pattern.toLowerCase())
    expect(SUT).toBe('Given pattern is found at index 0')
  })
  it('expects to return a message when there is no pattern', () => {
    const text = 'ABCDEFG'
    const pattern = 'AEG'
    const SUT = checkIfPatternExists(text.toLowerCase(), pattern.toLowerCase())
    expect(SUT).toBe(undefined)
  })
  it('expects to find a pattern independent of casing', () => {
    const text = 'AbCAAAAAAB'
    const pattern = 'abc'
    const SUT = checkIfPatternExists(text, pattern)
    expect(SUT).toBe(undefined)
  })
  it('expects to throw an error message when given input is not a string', () => {
    const text = 123444456
    const pattern = 123
    expect(() => checkIfPatternExists(text, pattern)).toThrow(
      'Given input is not a string'
    )
  })
})
import maxCharacter from '../MaxCharacter'

describe('Testing the maxCharacter function', () => {
  it('Expect throw with wrong arg', () => {
    expect(() => maxCharacter(123)).toThrow()
    expect(() => maxCharacter('')).toThrow()
  })

  it('Check the max character in string', () => {
    const theString = 'I can\'t do that'
    const maxCharInAllCount = maxCharacter(theString)
    const maxChar = maxCharacter(theString, /\s/)

    expect(maxCharInAllCount).toBe(' ')
    expect(maxChar).toBe('t')

    expect(maxCharacter('!!!Hello, World!!!', /[a-z]/)).toBe('!')

    expect(maxCharacter('!!!Hello, World!!!', /[^a-z]/i)).toBe('l')
  })
})
import { validateEmail } from '../ValidateEmail'

describe('Validation of an Email Address', () => {
  it('expects to return false', () => {
    expect(validateEmail('mahfoudh.arous.com')).toEqual(false)
  })

  it('expects to return false', () => {
    expect(validateEmail('mahfoudh.arous@com')).toEqual(false)
  })

  it('expects to return true', () => {
    expect(validateEmail('mahfoudh.arous@gmail.com')).toEqual(true)
  })

  it('expects to return true', () => {
    expect(validateEmail('icristianbaciu@.helsinki.edu')).toEqual(true)
  })

  it('expects to throw a type error', () => {
    expect(() => { validateEmail('') }).toThrow('Email Address String Null or Empty.')
    expect(() => { validateEmail(null) }).toThrow('Email Address String Null or Empty.')
  })
})
import { CheckKebabCase } from '../CheckKebabCase'

test('CheckKebabCase(The-Algorithms) -> true', () => {
  const word = 'The-Algorithms'
  const res = CheckKebabCase(word)
  expect(res).toBeTruthy()
})

test('CheckKebabCase(The Algorithms) -> false', () => {
  const word = 'The Algorithms'
  const res = CheckKebabCase(word)
  expect(res).toBeFalsy()
})
import { checkExceeding } from '../CheckExceeding'

describe('Testing CheckExceeding function', () => {
  it('Testing the invalid types', () => {
    expect(() => checkExceeding(Math.random())).toThrow('Argument is not a string')
    expect(() => checkExceeding(null)).toThrow('Argument is not a string')
    expect(() => checkExceeding(false)).toThrow('Argument is not a string')
    expect(() => checkExceeding(false)).toThrow('Argument is not a string')
  })

  it('Testing with empty string', () => {
    expect(checkExceeding('')).toBe(true)
  })

  it('Testing with linear alphabets', () => {
    expect(checkExceeding('a b c d e ')).toBe(true)
    expect(checkExceeding('f g h i j ')).toBe(true)
    expect(checkExceeding('k l m n o ')).toBe(true)
    expect(checkExceeding('p q r s t ')).toBe(true)
    expect(checkExceeding('u v w x y z')).toBe(true)
  })

  it('Testing not exceeding words', () => {
    expect(checkExceeding('Hello')).toBe(false)
    expect(checkExceeding('world')).toBe(false)
    expect(checkExceeding('update')).toBe(false)
    expect(checkExceeding('university')).toBe(false)
    expect(checkExceeding('dog')).toBe(false)
    expect(checkExceeding('exceeding')).toBe(false)
    expect(checkExceeding('resolved')).toBe(false)
    expect(checkExceeding('future')).toBe(false)
    expect(checkExceeding('fixed')).toBe(false)
    expect(checkExceeding('codes')).toBe(false)
    expect(checkExceeding('facebook')).toBe(false)
    expect(checkExceeding('vscode')).toBe(false)
  })

  it('Testing exceeding words', () => {
    expect(checkExceeding('bee')).toBe(true)     expect(checkExceeding('can')).toBe(true)     expect(checkExceeding('good')).toBe(true)     expect(checkExceeding('bad')).toBe(true)     expect(checkExceeding('play')).toBe(true)     expect(checkExceeding('delete')).toBe(true)   })
})
import { CheckPascalCase } from '../CheckPascalCase'

test('CheckPascalCase(TheAlgorithms) -> true', () => {
  const word = 'TheAlgorithms'
  const res = CheckPascalCase(word)
  expect(res).toBeTruthy()
})

test('CheckPascalCase(theAlgorithms) -> false', () => {
  const word = 'theAlgorithms'
  const res = CheckPascalCase(word)
  expect(res).toBeFalsy()
})

test('CheckPascalCase(The Algorithms) -> false', () => {
  const word = 'The Algorithms'
  const res = CheckPascalCase(word)
  expect(res).toBeFalsy()
})
import { validateURL } from '../ValidateUrl'

describe('ValidateUrl', () => {
  it('expects to return false', () => {
    expect(validateURL('google')).toEqual(false)
    expect(validateURL('link: https:  })

  it('expects to return true', () => {
    expect(validateURL('http:    expect(validateURL('https:    expect(validateURL('www.google.com')).toEqual(true)
  })
})
import { ReverseStringIterative, ReverseStringIterativeInplace } from '../ReverseString'

describe('ReverseStringIterative', () => {
  it('expects to reverse a simple string', () => {
    expect(ReverseStringIterative('reverse')).toEqual('esrever')
    expect(ReverseStringIterative('some')).toEqual('emos')
    expect(ReverseStringIterative('string')).toEqual('gnirts')
    expect(ReverseStringIterative('The Algorithms Javascript')).toEqual('tpircsavaJ smhtiroglA ehT')
  })

  it('expects to reverse a string with spaces in between', () => {
    expect(ReverseStringIterative('reverse me')).toEqual('em esrever')
  })

  it('expects to reverse a simple string without capitalizing the first letter', () => {
    expect(ReverseStringIterative('Javascript')).toEqual('tpircsavaJ')
  })

  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => ReverseStringIterative(input)).toThrow('The given value is not a string')
    }
  )

  it('expects to return a empty string with an empty string is given', () => {
    expect(ReverseStringIterative('')).toEqual('')
  })
})

describe('ReverseStringIterativeInplace', () => {
  it('expects to reverse a simple string', () => {
    expect(ReverseStringIterativeInplace('reverse')).toEqual('esrever')
    expect(ReverseStringIterativeInplace('some')).toEqual('emos')
    expect(ReverseStringIterativeInplace('string')).toEqual('gnirts')
    expect(ReverseStringIterativeInplace('The Algorithms Javascript')).toEqual('tpircsavaJ smhtiroglA ehT')
  })

  it('expects to reverse a simple string without capitalizing the first letter', () => {
    expect(ReverseStringIterativeInplace('Javascript')).toEqual('tpircsavaJ')
  })

  it('expects to return an empty string given an empty string', () => {
    expect(ReverseStringIterativeInplace('Javascript')).toEqual('tpircsavaJ')
  })

  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => ReverseStringIterativeInplace(input)).toThrow('The given value is not a string')
    }
  )
})
import upper from '../Upper'

describe('Testing the Upper function', () => {
  it('return uppercase strings', () => {
    expect(upper('hello')).toBe('HELLO')
    expect(upper('WORLD')).toBe('WORLD')
    expect(upper('hello_WORLD')).toBe('HELLO_WORLD')
  })
})
import { isScramble } from '../ScrambleStrings'

describe('ScrambleStrings', () => {
  it('expects to return true for same string', () => {
    expect(isScramble('a', 'a')).toBe(true)
  })

  it('expects to return false for non-scrambled strings', () => {
    expect(isScramble('abcde', 'caebd')).toBe(false)
  })

  it('expects to return true for scrambled strings', () => {
    expect(isScramble('great', 'rgeat')).toBe(true)
  })
})
import alphaNumericPalindrome from '../AlphaNumericPalindrome'

describe('Testing the alpha numeric palindrome', () => {
    it('Testing with valid alphabetic palindrome', () => {
    expect(alphaNumericPalindrome('eye')).toBe(true)
    expect(alphaNumericPalindrome('Madam')).toBe(true)
    expect(alphaNumericPalindrome('race CAR')).toBe(true)
    expect(alphaNumericPalindrome('A man, a plan, a canal. Panama')).toBe(true)
  })

  it('Testing with number and symbol', () => {
    expect(alphaNumericPalindrome('0_0 (: /-:) 0-0')).toBe(true)
    expect(alphaNumericPalindrome('03_|53411435|_30')).toBe(true)
  })

  it('Testing with alphabets and symbols', () => {
    expect(alphaNumericPalindrome('five|_/|evif')).toBe(true)
    expect(alphaNumericPalindrome('five|_/|four')).toBe(false)
  })
})
import { checkSnakeCase } from '../CheckSnakeCase'
describe('checkSnakeCase', () => {
  it('expect to throw an error if input is not a string', () => {
    expect(() => checkSnakeCase(0)).toThrow()
  })

  it('expects to return true if the input is in snake case format', () => {
    const value = 'docker_build'
    const result = checkSnakeCase(value)
    expect(result).toBe(true)
  })

  it('expects to return false if the input is not in snake case format', () => {
    const value = 'dockerBuild'
    const result = checkSnakeCase(value)
    expect(result).toBe(false)
  })
})
import { hammingDistance } from '../HammingDistance'

test('should throw an error when trying to compare the strings of different length', () => {
  const compareStringsOfDifferentLength = () => {
    hammingDistance('abc', 'abcd')
  }

  expect(compareStringsOfDifferentLength).toThrowError()
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('a', 'a')).toBe(0)
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('abc', 'add')).toBe(2)
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('1011101', '1001001')).toBe(2)
})
const checkPalindrome = (str) => {
    if (typeof str !== 'string') {
    return 'Not a string'
  }
  if (str.length === 0) {
    return 'Empty string'
  }
      const reversed = [...str].reverse().join('')
  return str === reversed ? 'Palindrome' : 'Not a Palindrome'
}

export { checkPalindrome }




export const hammingDistance = (a, b) => {
  if (a.length !== b.length) {
    throw new Error('Strings must be of the same length')
  }

  let distance = 0

  for (let i = 0; i < a.length; i += 1) {
    if (a[i] !== b[i]) {
      distance += 1
    }
  }

  return distance
}


const computeLPS = (pattern) => {
  const lps = Array(pattern.length)
  lps[0] = 0
  for (let i = 1; i < pattern.length; i++) {
    let matched = lps[i - 1]
    while (matched > 0 && pattern[i] !== pattern[matched]) {
      matched = lps[matched - 1]
    }
    if (pattern[i] === pattern[matched]) {
      matched++
    }
    lps[i] = matched
  }
  return lps
}


const KMPSearch = (text, pattern) => {
  if (!pattern || !text) {
    return []   }

      const lps = computeLPS(pattern)
  const result = []

  let matched = 0
  for (let i = 0; i < text.length; i++) {
    while (matched > 0 && text[i] !== pattern[matched]) {
      matched = lps[matched - 1]
    }
    if (text[i] === pattern[matched]) {
      matched++
    }
    if (matched === pattern.length) {
      result.push(i - pattern.length + 1)
      matched = lps[matched - 1]
    }
  }

  return result
}

export { KMPSearch }



const CheckPascalCase = (VarName) => {
    if (typeof VarName !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /^[A-Z][A-Za-z]*$/
  return pat.test(VarName)
}

export { CheckPascalCase }



const checkPangramRegex = (string) => {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  /
  return string.match(/([a-z])(?!.*\1)/gi).length === 26
}


const checkPangramSet = (string) => {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const lettersSet = new Set()

  for (const letter of string.toUpperCase()) {
    if (/[A-Z]/.test(letter)) {
            lettersSet.add(letter)
    }
  }

  return lettersSet.size === 26
}

export { checkPangramRegex, checkPangramSet }
/

const createPermutations = (str) => {
  const arr = str.split('')

    const strLen = arr.length
    const perms = []
  let rest
  let picked
  let restPerms
  let next

    if (strLen === 0) { return [str] }
    for (let i = 0; i < strLen; i++) {
    rest = Object.create(arr)
    picked = rest.splice(i, 1)

    restPerms = createPermutations(rest.join(''))

    for (let j = 0, jLen = restPerms.length; j < jLen; j++) {
      next = picked.concat(restPerms[j])
      perms.push(next.join(''))
    }
  }
  return perms
}
export { createPermutations }
/


function mapBigrams (string) {
  const bigrams = new Map()
  for (let i = 0; i < string.length - 1; i++) {
    const bigram = string.substring(i, i + 2)
    const count = bigrams.get(bigram)
    bigrams.set(bigram, (count || 0) + 1)
  }
  return bigrams
}


function countCommonBigrams (bigrams, string) {
  let count = 0
  for (let i = 0; i < string.length - 1; i++) {
    const bigram = string.substring(i, i + 2)
    if (bigrams.has(bigram)) count++
  }
  return count
}

function diceCoefficient (stringA, stringB) {
  if (stringA === stringB) return 1
  else if (stringA.length < 2 || stringB.length < 2) return 0

  const bigramsA = mapBigrams(stringA)

  const lengthA = stringA.length - 1
  const lengthB = stringB.length - 1

  let dice = (2 * countCommonBigrams(bigramsA, stringB)) / (lengthA + lengthB)

    dice = Math.floor(dice * 100) / 100

  return dice
}

export { diceCoefficient }
/

export const Guid = () => {
  const pattern = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
  let currentDateMilliseconds = new Date().getTime()
  return pattern.replace(/[xy]/g, currentChar => {
    const randomChar = (currentDateMilliseconds + Math.random() * 16) % 16 | 0
    currentDateMilliseconds = Math.floor(currentDateMilliseconds / 16)
    return (currentChar === 'x' ? randomChar : (randomChar & 0x7 | 0x8)).toString(16)
  })
}



const countVowels = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Input should be a string')
  }

  const vowelRegex = /[aeiou]/gi
  const vowelsArray = str.match(vowelRegex) || []

  return vowelsArray.length
}

export { countVowels }

const reverseWords = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  return str
    .split(/\s+/)     .reduceRight((reverseStr, word) => `${reverseStr} ${word}`, '')     .trim() }

export default reverseWords


export const palindromeRearranging = (str) => {
    if (typeof str !== 'string') {
    return 'Not a string'
  }
    if (str.length === 0) {
    return 'Empty string'
  }

      const charCounts = [...str].reduce((counts, char) => {
    counts[char] = counts[char] ? counts[char] + 1 : 1
    return counts
  }, {})
    return Object.values(charCounts).filter(count => count % 2 !== 0).length <= 1
}



/
const buildBadMatchTable = (str) => {
  const tableObj = {}
  const strLength = str.length
  for (let i = 0; i < strLength - 1; i++) {
    tableObj[str[i]] = strLength - 1 - i
  }
  if (tableObj[str[strLength - 1]] === undefined) {
    tableObj[str[strLength - 1]] = strLength
  }
  return tableObj
}

const boyerMoore = (str, pattern) => {
  const badMatchTable = buildBadMatchTable(pattern)
  let offset = 0
  const patternLastIndex = pattern.length - 1
  const maxOffset = str.length - pattern.length
    while (offset <= maxOffset) {
    let scanIndex = 0
    while (pattern[scanIndex] === str[scanIndex + offset]) {
      if (scanIndex === patternLastIndex) {
                return offset
      }
      scanIndex++
    }
    const badMatchString = str[offset + patternLastIndex]
    if (badMatchTable[badMatchString]) {
            offset += badMatchTable[badMatchString]
    } else {
      offset++
    }
  }
  return -1
}
export { boyerMoore }

const alphaNumericPalindrome = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

    const newStr = str.replace(/[^a-z0-9]+/ig, '').toLowerCase()
  const midIndex = newStr.length >> 1 
  for (let i = 0; i < midIndex; i++) {
    if (newStr.at(i) !== newStr.at(~i)) {       return false
    }
  }

  return true
}

export default alphaNumericPalindrome

function ReverseStringIterative (string) {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }
  let reversedString = ''
  let index

  for (index = string.length - 1; index >= 0; index--) {
    reversedString += string[index]
  }

  return reversedString
}


function ReverseStringIterativeInplace (string) {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const _string = string.split('')

  for (let i = 0; i < Math.floor(_string.length / 2); i++) {
    const first = _string[i]
    _string[i] = _string[_string.length - 1 - i]
    _string[_string.length - 1 - i] = first
  }

  return _string.join('')
}

export { ReverseStringIterative, ReverseStringIterativeInplace }



const checkCamelCase = (varName) => {
    if (typeof varName !== 'string') {
    throw new TypeError('Argument is not a string.')
  }

  const pat = /^[a-z][A-Za-z]*$/
  return pat.test(varName)
}

export { checkCamelCase }


const luhnValidation = (creditCardNumber) => {
  let validationSum = 0
  creditCardNumber.split('').forEach((digit, index) => {
    let currentDigit = parseInt(digit)
    if (index % 2 === 0) {
            currentDigit *= 2
            if (currentDigit > 9) {
        currentDigit %= 10
        currentDigit += 1
      }
    }
    validationSum += currentDigit
  })

  return validationSum % 10 === 0
}

const validateCreditCard = (creditCardString) => {
  const validStartSubString = ['4', '5', '6', '37', '34', '35'] 
  if (typeof creditCardString !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const errorMessage = `${creditCardString} is an invalid credit card number because `
  if (isNaN(creditCardString)) {
    throw new TypeError(errorMessage + 'it has nonnumerical characters.')
  }
  const creditCardStringLength = creditCardString.length
  if (!((creditCardStringLength >= 13) && (creditCardStringLength <= 16))) {
    throw new Error(errorMessage + 'of its length.')
  }
  if (!validStartSubString.some(subString => creditCardString.startsWith(subString))) {
    throw new Error(errorMessage + 'of its first two digits.')
  }
  if (!luhnValidation(creditCardString)) {
    throw new Error(errorMessage + 'it fails the Luhn check.')
  }

  return true
}

export { validateCreditCard }

const checkAnagramRegex = (str1, str2) => {
    if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    throw new TypeError('Both arguments should be strings.')
  }

    if (str1.length !== str2.length) {
    return false
  }

  /
  return ![...str1].reduce(
    (str2Acc, cur) => str2Acc.replace(new RegExp(cur, 'i'), ''),     str2
  )
}


const checkAnagramMap = (str1, str2) => {
    if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    throw new TypeError('Both arguments should be strings.')
  }

    if (str1.length !== str2.length) {
    return false
  }

  const str1List = Array.from(str1.toUpperCase()) 
    const str1Occurs = str1List.reduce(
    (map, char) => map.set(char, map.get(char) + 1 || 1),
    new Map()
  )

  for (const char of str2.toUpperCase()) {
        if (!str1Occurs.has(char)) {
      return false
    }

    let getCharCount = str1Occurs.get(char)
    str1Occurs.set(char, --getCharCount)

    getCharCount === 0 && str1Occurs.delete(char)
  }

  return true
}

export { checkAnagramRegex, checkAnagramMap }



const AlternativeStringArrange = (str1, str2) => {
    if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    return 'Not string(s)'
  }

    let outStr = ''

    const firstStringLength = str1.length
    const secondStringLength = str2.length
    const absLength = firstStringLength > secondStringLength ? firstStringLength : secondStringLength

    for (let charCount = 0; charCount < absLength; charCount++) {
        if (charCount < firstStringLength) {
      outStr += str1[charCount]
    }

        if (charCount < secondStringLength) {
      outStr += str2[charCount]
    }
  }

    return outStr
}

export { AlternativeStringArrange }
/
const checkIfPatternExists = (text, pattern) => {
  if (typeof text !== 'string' || typeof pattern !== 'string') {
    throw new TypeError('Given input is not a string')
  }
  const textLength = text.length   const patternLength = pattern.length 
    for (let i = 0; i <= textLength - patternLength; i++) {
            for (let j = 0; j < textLength; j++) {
      if (text[i + j] !== pattern[j]) break

                  if (j + 1 === patternLength) {
        return `Given pattern is found at index ${i}`
      }
    }
  }
}

export { checkIfPatternExists }
/

const levenshteinDistance = (a, b) => {
    const distanceMatrix = Array(b.length + 1)
    .fill(null)
    .map(() => Array(a.length + 1).fill(null))

    for (let i = 0; i <= a.length; i += 1) {
    distanceMatrix[0][i] = i
  }

    for (let j = 0; j <= b.length; j += 1) {
    distanceMatrix[j][0] = j
  }

  for (let j = 1; j <= b.length; j += 1) {
    for (let i = 1; i <= a.length; i += 1) {
      const indicator = a[i - 1] === b[j - 1] ? 0 : 1
            distanceMatrix[j][i] = Math.min(
        distanceMatrix[j][i - 1] + 1,         distanceMatrix[j - 1][i] + 1,         distanceMatrix[j - 1][i - 1] + indicator       )
    }
  }

  return distanceMatrix[b.length][a.length]
}

export { levenshteinDistance }



const checkFlatCase = (varname) => {
    if (typeof varname !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /^[a-z]*$/
  return pat.test(varname)
}

export { checkFlatCase }



const CheckKebabCase = (varName) => {
    if (typeof varName !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /(\w+)-(\w)([\w-]*)/
  return pat.test(varName) && !varName.includes('_')
}

export { CheckKebabCase }
'use strict'

const permutate = (aString) => {
  if (typeof aString !== 'string' || !aString) {
    throw new Error('The arg must be a valid, non empty string')
  }
  const characters = aString.split('')
  let permutations = [[characters.shift()]]
  while (characters.length) {
    const currentCharacter = characters.shift()
    permutations = calculateCurrentCharacterPermutation(permutations, currentCharacter)
  }
  return permutations
    .map(character => character.join(''))
    .filter((item, index, self) => (self.indexOf(item) === index))
    .sort()
}

const calculateCurrentCharacterPermutation = (allPermutations, currentCharacter) => {
  const currentPermutations = []
  allPermutations.forEach(permutation => {
    let index = 0
    while (index <= permutation.length) {
      const tmp = [...permutation]
      tmp.splice(index, 0, currentCharacter)
      currentPermutations.push(tmp)
      index++
    }
  })
  return currentPermutations
}

export { permutate }


const lower = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Invalid Input Type')
  }

  return str.replace(
    /[A-Z]/g, (char) => String.fromCharCode(char.charCodeAt() + 32)
  )
}

export default lower

const maxCharacter = (str, ignorePattern) => {   if (typeof str !== 'string') {
    throw new TypeError('Argument should be a string')
  } else if (!str) {
    throw new Error('The param should be a nonempty string')
  }

    const occurrenceMap = new Map()

  for (const char of str) {
    if (!ignorePattern?.test(char)) {
      occurrenceMap.set(char, occurrenceMap.get(char) + 1 || 1)
    }
  }

    let max = { char: '', occur: -Infinity }

  for (const [char, occur] of occurrenceMap) {
    if (occur > max.occur) {
      max = { char, occur }
    }
  }

  return max.char
}

export default maxCharacter

const checkWordOccurrence = (str, isCaseSensitive = false) => {
  if (typeof str !== 'string') {
    throw new TypeError('The first param should be a string')
  }

  if (typeof isCaseSensitive !== 'boolean') {
    throw new TypeError('The second param should be a boolean')
  }

  const modifiedStr = isCaseSensitive ? str.toLowerCase() : str

  return modifiedStr
    .split(/\s+/)     .reduce(
      (occurrence, word) => {
        occurrence[word] = occurrence[word] + 1 || 1
        return occurrence
      },
      {}
    )
}

export { checkWordOccurrence }


const maxWord = (sentence = '') => {
  if (typeof sentence !== 'string') {
    throw new TypeError('the param should be string')
  }

  if (!sentence) {
    return null
  }

  const words = sentence.split(' ')
  if (words.length < 2) {
    return words[0]
  }

  const occurrences = {}
  words.forEach(word => {
    occurrences[word.toLocaleLowerCase()] = occurrences[word.toLocaleLowerCase()] + 1 || 1
  })

  const max = Object.keys(occurrences).reduce((n, word) => {
    if (occurrences[word] > n.count) { return { word, count: occurrences[word] } } else { return n }
  }, { word: '', count: 0 })

  return max.word
}

export { maxWord }

const formatPhoneNumber = (phoneNumber) => {
  if ((phoneNumber.length !== 10) || isNaN(phoneNumber)) {
        throw new TypeError('Invalid phone number!')
  }

  let index = 0
  return '(XXX) XXX-XXXX'.replace(/X/g, () => phoneNumber[index++])
}

export default formatPhoneNumber

const validateURL = (url) => {
  const URL_PATTERN = /^(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})$/gi

  return URL_PATTERN.test(url)
}

export { validateURL }
function getParentPosition (position) {
    return Math.floor((position - 1) / 2)
}
function getChildrenPosition (position) {
    return [2 * position + 1, 2 * position + 2]
}

class PriorityQueue {
    constructor () {
    this._heap = []
    this.keys = {}
  }

  isEmpty () {
        return this._heap.length === 0
  }

  push (key, priority) {
        this._heap.push([key, priority])
    this.keys[key] = this._heap.length - 1
    this._shiftUp(this.keys[key])
  }

  pop () {
        this._swap(0, this._heap.length - 1)
    const [key] = this._heap.pop()
    delete this.keys[key]
    this._shiftDown(0)
    return key
  }

  contains (key) {
        return (key in this.keys)
  }

  update (key, priority) {
        const currPos = this.keys[key]
    this._heap[currPos][1] = priority
    const parentPos = getParentPosition(currPos)
    const currPriority = this._heap[currPos][1]
    let parentPriority = Infinity
    if (parentPos >= 0) {
      parentPriority = this._heap[parentPos][1]
    }
    const [child1Pos, child2Pos] = getChildrenPosition(currPos)
    let [child1Priority, child2Priority] = [Infinity, Infinity]
    if (child1Pos < this._heap.length) {
      child1Priority = this._heap[child1Pos][1]
    }
    if (child2Pos < this._heap.length) {
      child2Priority = this._heap[child2Pos][1]
    }

    if (parentPos >= 0 && parentPriority > currPriority) {
      this._shiftUp(currPos)
    } else if (child2Pos < this._heap.length &&
      (child1Priority < currPriority || child2Priority < currPriority)) {
      this._shiftDown(currPos)
    }
  }

  _shiftUp (position) {
        let currPos = position
    let parentPos = getParentPosition(currPos)
    let currPriority = this._heap[currPos][1]
    let parentPriority = Infinity
    if (parentPos >= 0) {
      parentPriority = this._heap[parentPos][1]
    }

    while (parentPos >= 0 && parentPriority > currPriority) {
      this._swap(currPos, parentPos)
      currPos = parentPos
      parentPos = getParentPosition(currPos)
      currPriority = this._heap[currPos][1]
      try {
        parentPriority = this._heap[parentPos][1]
      } catch (error) {
        parentPriority = Infinity
      }
    }
    this.keys[this._heap[currPos][0]] = currPos
  }

  _shiftDown (position) {
        let currPos = position
    let [child1Pos, child2Pos] = getChildrenPosition(currPos)
    let [child1Priority, child2Priority] = [Infinity, Infinity]
    if (child1Pos < this._heap.length) {
      child1Priority = this._heap[child1Pos][1]
    }
    if (child2Pos < this._heap.length) {
      child2Priority = this._heap[child2Pos][1]
    }
    let currPriority
    try {
      currPriority = this._heap[currPos][1]
    } catch {
      return
    }

    while (child2Pos < this._heap.length &&
      (child1Priority < currPriority || child2Priority < currPriority)) {
      if (child1Priority < currPriority && child1Priority < child2Priority) {
        this._swap(child1Pos, currPos)
        currPos = child1Pos
      } else {
        this._swap(child2Pos, currPos)
        currPos = child2Pos
      }
      [child1Pos, child2Pos] = getChildrenPosition(currPos)
      try {
        [child1Priority, child2Priority] = [this._heap[child1Pos][1], this._heap[child2Pos][1]]
      } catch (error) {
        [child1Priority, child2Priority] = [Infinity, Infinity]
      }

      currPriority = this._heap[currPos][1]
    }
    this.keys[this._heap[currPos][0]] = currPos
    if (child1Pos < this._heap.length && child1Priority < currPriority) {
      this._swap(child1Pos, currPos)
      this.keys[this._heap[child1Pos][0]] = child1Pos
    }
  }

  _swap (position1, position2) {
        [this._heap[position1], this._heap[position2]] = [this._heap[position2], this._heap[position1]]
    this.keys[this._heap[position1][0]] = position1
    this.keys[this._heap[position2][0]] = position2
  }
}

class GraphWeightedUndirectedAdjacencyList {
    constructor () {
    this.connections = {}
  }

  addNode (node) {
        this.connections[node] = {}
  }

  addEdge (node1, node2, weight) {
        if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1][node2] = weight
    this.connections[node2][node1] = weight
  }

  PrimMST (start) {
            const distance = {}
    const parent = {}
    const priorityQueue = new PriorityQueue()
        for (const node in this.connections) {
      distance[node] = (node === start.toString() ? 0 : Infinity)
      parent[node] = null
      priorityQueue.push(node, distance[node])
    }
        while (!priorityQueue.isEmpty()) {
      const node = priorityQueue.pop()
      Object.keys(this.connections[node]).forEach(neighbour => {
        if (priorityQueue.contains(neighbour) && distance[node] + this.connections[node][neighbour] < distance[neighbour]) {
          distance[neighbour] = distance[node] + this.connections[node][neighbour]
          parent[neighbour] = node
          priorityQueue.update(neighbour, distance[neighbour])
        }
      })
    }

        const graph = new GraphWeightedUndirectedAdjacencyList()
    Object.keys(parent).forEach(node => {
      if (node && parent[node]) {
        graph.addEdge(node, parent[node], this.connections[node][parent[node]])
      }
    })
    return graph
  }
}

export { GraphWeightedUndirectedAdjacencyList }

import { BellmanFord } from '../BellmanFord.js'

test('Test Case 1', () => {
  const V = 5
  const E = 8
  const destination = 3
  const graph = [[0, 1, -1], [0, 2, 4],
    [1, 2, 3], [1, 3, 2],
    [1, 4, 2], [3, 2, 5],
    [3, 1, 1], [4, 3, -3]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(-2)
})
test('Test Case 2', () => {
  const V = 6
  const E = 9
  const destination = 4
  const graph = [[0, 1, 3], [0, 3, 6],
    [0, 5, -1], [1, 2, -3],
    [1, 4, -2], [5, 2, 5],
    [2, 3, 1], [4, 3, 5], [5, 4, 2]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(1)
})
test('Test Case 3', () => {
  const V = 4
  const E = 5
  const destination = 1
  const graph = [[0, 3, -1], [0, 2, 4],
    [3, 2, 2], [3, 1, 5],
    [2, 1, -1]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(0)
})
import { breadthFirstSearch } from '../BreadthFirstSearch'

describe('BreadthFirstSearch', () => {
  const graph = {
    A: ['B', 'D'],
    B: ['E'],
    C: ['D'],
    D: ['A'],
    E: ['D'],
    F: ['G'],
    G: []
  }
  /

  it('should return the visited nodes', () => {
    expect(Array.from(breadthFirstSearch(graph, 'C'))).toEqual(['C', 'D', 'A', 'B', 'E'])
    expect(Array.from(breadthFirstSearch(graph, 'A'))).toEqual(['A', 'B', 'D', 'E'])
    expect(Array.from(breadthFirstSearch(graph, 'F'))).toEqual(['F', 'G'])
  })
})
import { breadthFirstShortestPath } from '../BreadthFirstShortestPath'

describe('BreadthFirstShortestPath', () => {
  const graph = {
    A: ['B', 'D'],
    B: ['E'],
    C: ['D'],
    D: ['A'],
    E: ['D'],
    F: ['G'],
    G: []
  }
  /

  it('should return the visited nodes', () => {
    expect(breadthFirstShortestPath(graph, 'C', 'E')).toEqual(['C', 'D', 'A', 'B', 'E'])
    expect(breadthFirstShortestPath(graph, 'E', 'B')).toEqual(['E', 'D', 'A', 'B'])
    expect(breadthFirstShortestPath(graph, 'F', 'G')).toEqual(['F', 'G'])
    expect(breadthFirstShortestPath(graph, 'A', 'G')).toEqual([])
  })
})

export function breadthFirstShortestPath (graph, startNode, targetNode) {
    if (startNode === targetNode) {
    return [startNode]
  }

    const visited = new Set()

    const initialPath = [startNode]
  const queue = [initialPath]

  while (queue.length > 0) {
        const path = queue.shift()
    const node = path[path.length - 1]

        if (!visited.has(node)) {
            visited.add(node)

      const neighbors = graph[node]

            for (let i = 0; i < neighbors.length; i++) {
        const newPath = path.concat([neighbors[i]])

                if (neighbors[i] === targetNode) {
          return newPath
        }

                queue.push(newPath)
      }
    }
  }

    return []
}


function createGraph (V, E) {
      const adjList = []   for (let i = 0; i < V; i++) {
    adjList.push([])
  }
  for (let i = 0; i < E.length; i++) {
    adjList[E[i][0]].push([E[i][1], E[i][2]])
    adjList[E[i][1]].push([E[i][0], E[i][2]])
  }
  return adjList
}

function djikstra (graph, V, src) {
  const vis = Array(V).fill(0)
  const dist = []
  for (let i = 0; i < V; i++) dist.push([10000, -1])
  dist[src][0] = 0

  for (let i = 0; i < V - 1; i++) {
    let mn = -1
    for (let j = 0; j < V; j++) {
      if (vis[j] === 0) {
        if (mn === -1 || dist[j][0] < dist[mn][0]) mn = j
      }
    }

    vis[mn] = 1
    for (let j = 0; j < graph[mn].length; j++) {
      const edge = graph[mn][j]
      if (vis[edge[0]] === 0 && dist[edge[0]][0] > dist[mn][0] + edge[1]) {
        dist[edge[0]][0] = dist[mn][0] + edge[1]
        dist[edge[0]][1] = mn
      }
    }
  }

  return dist
}

export { createGraph, djikstra }




class GraphUnweightedUndirected {
    constructor () {
    this.connections = {}
  }

  addNode (node) {
        this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
        if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSIterative (node, value) {
        const stack = [node]
    const visited = new Set()
    while (stack.length > 0) {
      const currNode = stack.pop()
            if (currNode === value) { return true }
            visited.add(currNode)
            for (const neighbour of this.connections[currNode]) {
        if (!visited.has(neighbour)) {
          stack.push(neighbour)
        }
      }
    }
    return false
  }
}

export { GraphUnweightedUndirected }


/


function BellmanFord (graph, V, E, src, dest) {
    const dis = Array(V).fill(Infinity)
    dis[src] = 0

        for (let i = 0; i < V - 1; i++) {
    for (let j = 0; j < E; j++) {
      if ((dis[graph[j][0]] + graph[j][2]) < dis[graph[j][1]]) { dis[graph[j][1]] = dis[graph[j][0]] + graph[j][2] }
    }
  }
    for (let i = 0; i < E; i++) {
    const x = graph[i][0]
    const y = graph[i][1]
    const weight = graph[i][2]
    if ((dis[x] !== Infinity) && (dis[x] + weight < dis[y])) {
      return null
    }
  }
  for (let i = 0; i < V; i++) {
    if (i === dest) return dis[i]
  }
}

export { BellmanFord }

export function breadthFirstSearch (graph, startingNode) {
    const visited = new Set()

    const queue = [startingNode]

  while (queue.length > 0) {
        const node = queue.shift()

    if (!visited.has(node)) {
            visited.add(node)
      const neighbors = graph[node]

            for (let i = 0; i < neighbors.length; i++) {
        queue.push(neighbors[i])
      }
    }
  }

  return visited
}
/

const FloydWarshall = (dist) => {
      const n = dist.length
  for (let k = 0; k < n; k++) {
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j]
        }
      }
    }
  }
  return dist
}

export { FloydWarshall }


/

const islands = (matrixGrid) => {
  const matrix = matrixGrid
  let counter = 0

  const flood = (row, col) => {
    if (row < 0 || col < 0) return     if (row >= matrix.length || col >= matrix[row].length) return 
    const tile = matrix[row][col]
    if (tile !== '1') return

    matrix[row][col] = '0'

    flood(row + 1, col)     flood(row - 1, col)     flood(row, col + 1)     flood(row, col - 1)   }

  for (let row = 0; row < matrix.length; row += 1) {
    for (let col = 0; col < matrix[row].length; col += 1) {
      const current = matrix[row][col]
      if (current === '1') {
        flood(row, col)
        counter += 1
      }
    }
  }
  return counter
}

export { islands }

class DisjointSetTreeNode {
    constructor (key) {
    this.key = key
    this.parent = this
    this.rank = 0
  }
}

class DisjointSetTree {
    constructor () {
        this.map = {}
  }

  makeSet (x) {
        this.map[x] = new DisjointSetTreeNode(x)
  }

  findSet (x) {
        if (this.map[x] !== this.map[x].parent) {
      this.map[x].parent = this.findSet(this.map[x].parent.key)
    }
    return this.map[x].parent
  }

  union (x, y) {
        this.link(this.findSet(x), this.findSet(y))
  }

  link (x, y) {
        if (x.rank > y.rank) {
      y.parent = x
    } else {
      x.parent = y
      if (x.rank === y.rank) {
        y.rank += 1
      }
    }
  }
}

class GraphWeightedUndirectedAdjacencyList {
    constructor () {
    this.connections = {}
    this.nodes = 0
  }

  addNode (node) {
        this.connections[node] = {}
    this.nodes += 1
  }

  addEdge (node1, node2, weight) {
        if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1][node2] = weight
    this.connections[node2][node1] = weight
  }

  KruskalMST () {
                const edges = []
    const seen = new Set()
    for (const start of Object.keys(this.connections)) {
      for (const end of Object.keys(this.connections[start])) {
        if (!seen.has(`${start} ${end}`)) {
          seen.add(`${end} ${start}`)
          edges.push([start, end, this.connections[start][end]])
        }
      }
    }
    edges.sort((a, b) => a[2] - b[2])
        const disjointSet = new DisjointSetTree()
    Object.keys(this.connections).forEach(node => disjointSet.makeSet(node))
        const graph = new GraphWeightedUndirectedAdjacencyList()
    let numEdges = 0
    let index = 0
    while (numEdges < this.nodes - 1) {
      const [u, v, w] = edges[index]
      index += 1
      if (disjointSet.findSet(u) !== disjointSet.findSet(v)) {
        numEdges += 1
        graph.addEdge(u, v, w)
        disjointSet.union(u, v)
      }
    }
    return graph
  }
}

export { GraphWeightedUndirectedAdjacencyList }


class Graph {
    constructor () {
    this.edges = []
  }

  addEdge (node1, node2) {
        this.edges.push({
      node1,
      node2
    })
  }

  nodeNeighbors (node) {
        const neighbors = new Set()
    for (const edge of this.edges) {
                  if (edge.node1 === node && !(neighbors.has(edge.node2))) {
        neighbors.add(edge.node2)
      } else if (edge.node2 === node && !(neighbors.has(edge.node1))) {
        neighbors.add(edge.node1)
      }
    }
    return neighbors
  }
}

export { Graph }

class GraphUnweightedUndirected {
    constructor () {
    this.connections = {}
  }

  addNode (node) {
        this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
        if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSRecursive (node, value, visited = new Set()) {
            if (node === value) { return true }
        visited.add(node)
        for (const neighbour of this.connections[node]) {
      if (!visited.has(neighbour)) {
        if (this.DFSRecursive(neighbour, value, visited)) { return true }
      }
    }
    return false
  }
}

export { GraphUnweightedUndirected }

/
function density (numberOfNodes, numberOfEdges, isDirected = false) {
  const multi = isDirected ? 1 : 2
  return (multi * numberOfEdges) / (numberOfNodes * (numberOfNodes - 1))
}

export { density }
class GraphUnweightedUndirectedAdjacencyList {
    constructor () {
    this.connections = {}
  }

  addNode (node) {
        this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
        if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSComponent (components, node, visited) {
    
        components.push(node)
    const stack = [node]
        while (stack.length > 0) {
      const curr = stack.pop()
      visited.add(curr.toString())
      for (const neighbour of this.connections[curr].keys()) {
        if (!visited.has(neighbour.toString())) { stack.push(neighbour) }
      }
    }
  }

  connectedComponents () {
            const visited = new Set()
    const components = []
    for (const node of Object.keys(this.connections)) {
      if (!visited.has(node.toString())) { this.DFSComponent(components, node, visited) }
    }
    return components
  }
}

export { GraphUnweightedUndirectedAdjacencyList }


function solve (graph, s) {
  const solutions = {}
  solutions[s] = []
  solutions[s].dist = 0

  while (true) {
    let p = null
    let neighbor = null
    let dist = Infinity

    for (const n in solutions) {
      if (!solutions[n]) { continue }
      const ndist = solutions[n].dist
      const adj = graph[n]

      for (const a in adj) {
        if (solutions[a]) { continue }

        const d = adj[a] + ndist
        if (d < dist) {
          p = solutions[n]
          neighbor = a
          dist = d
        }
      }
    }

        if (dist === Infinity) {
      break
    }

        solutions[neighbor] = p.concat(neighbor)
        solutions[neighbor].dist = dist
  }

  return solutions
}

export { solve }







import { convexHull } from '../ConvexHullGraham'

test('The ConvexHull of the following points is [{x: 0, y: 3}, {x: 4, y: 4}, {x: 3, y: 1}, {x: 0, y: 0}]', () => {
  const points = [
    { x: 0, y: 3 },
    { x: 1, y: 1 },
    { x: 2, y: 2 },
    { x: 4, y: 4 },
    { x: 0, y: 0 },
    { x: 1, y: 2 },
    { x: 3, y: 1 },
    { x: 3, y: 3 }]
  const res = convexHull(points)
  expect(res).toEqual([{ x: 0, y: 3 }, { x: 4, y: 4 }, { x: 3, y: 1 }, { x: 0, y: 0 }])
})

test('The ConvexHull of the following points is [{x: 1, y: 4}, {x: 9, y: 6}, {x: 7, y: 0}, {x: 0, y: 0}]', () => {
  const points = [
    { x: 4, y: 3 },
    { x: 1, y: 4 },
    { x: 2, y: 4 },
    { x: 0, y: 0 },
    { x: 9, y: 6 },
    { x: 1, y: 3 },
    { x: 4, y: 1 },
    { x: 7, y: 0 }]
  const res = convexHull(points)
  expect(res).toEqual([{ x: 1, y: 4 }, { x: 9, y: 6 }, { x: 7, y: 0 }, { x: 0, y: 0 }])
})


function compare (a, b) {
    if (a.x < b.x) return -1
  if (a.x === b.x && a.y < b.y) return -1
  return 1
}
function orientation (a, b, c) {
    const alpha = (b.y - a.y) / (b.x - a.x)
  const beta = (c.y - b.y) / (c.x - b.x)

    if (alpha > beta) return 1
    else if (beta > alpha) return -1
    return 0
}

function convexHull (points) {
  const pointsLen = points.length
  if (pointsLen <= 2) {
    throw new Error('Minimum of 3 points is required to form closed polygon!')
  }

  points.sort(compare)
  const p1 = points[0]; const p2 = points[pointsLen - 1]

    const upperPoints = []; const lowerPoints = []

  upperPoints.push(p1)
  lowerPoints.push(p1)

  for (let i = 1; i < pointsLen; i++) {
    if (i === pointsLen - 1 || orientation(p1, points[i], p2) !== -1) {
      let upLen = upperPoints.length

      while (upLen >= 2 && orientation(upperPoints[upLen - 2], upperPoints[upLen - 1], points[i]) === -1) {
        upperPoints.pop()
        upLen = upperPoints.length
      }
      upperPoints.push(points[i])
    }
    if (i === pointsLen - 1 || orientation(p1, points[i], p2) !== 1) {
      let lowLen = lowerPoints.length
      while (lowLen >= 2 && orientation(lowerPoints[lowLen - 2], lowerPoints[lowLen - 1], points[i]) === 1) {
        lowerPoints.pop()
        lowLen = lowerPoints.length
      }
      lowerPoints.push(points[i])
    }
  }
  const hull = []
  for (let i = 1; i < upperPoints.length - 1; i++) {
    hull.push(upperPoints[i])
  }
  for (let i = lowerPoints.length - 1; i >= 0; i--) {
    hull.push(lowerPoints[i])
  }

  return hull
}

export { convexHull }



import { setBit } from '../SetBit'

test('Set bit number 0 in 1:', () => {
  const setBitPos = setBit(1, 0)
  expect(setBitPos).toBe(1)
})

test('Set bit number 0 in 2:', () => {
  const setBitPos = setBit(2, 0)
  expect(setBitPos).toBe(3)
})

test('Set bit number 1 in 10:', () => {
  const setBitPos = setBit(10, 1)
  expect(setBitPos).toBe(10)
})

test('Set bit number 2 in 10:', () => {
  const setBitPos = setBit(10, 2)
  expect(setBitPos).toBe(14)
})
import { nextPowerOfTwo } from '../NextPowerOfTwo'

describe('NextPowerOfTwo', () => {
  it.each`
    input    | result
    ${0}     | ${1}
    ${1}     | ${1}
    ${2}     | ${2}
    ${3}     | ${4}
    ${5}     | ${8}
    ${125}   | ${128}
    ${1024}  | ${1024}
    ${10000} | ${16384}
  `('returns $result when is given $input', ({ input, result }) => {
    const res = nextPowerOfTwo(input)
    expect(res).toBe(result)
  })
})
import { IsPowerOfTwo } from '../IsPowerOfTwo'

test('Check if 0 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(0)
  expect(res).toBe(false)
})

test('Check if 1 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1)
  expect(res).toBe(true)
})

test('Check if 4 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(4)
  expect(res).toBe(true)
})

test('Check if 1024 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1024)
  expect(res).toBe(true)
})

test('Check if 1025 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1025)
  expect(res).toBe(false)
})
import { BinaryCountSetBits } from '../BinaryCountSetBits'

test('check BinaryCountSetBits of 25 is 3', () => {
  const res = BinaryCountSetBits(25)
  expect(res).toBe(3)
})
test('check BinaryCountSetBits of 36 is 2', () => {
  const res = BinaryCountSetBits(36)
  expect(res).toBe(2)
})
test('check BinaryCountSetBits of 16 is 1', () => {
  const res = BinaryCountSetBits(16)
  expect(res).toBe(1)
})
test('check BinaryCountSetBits of 58 is 4', () => {
  const res = BinaryCountSetBits(58)
  expect(res).toBe(4)
})
test('check BinaryCountSetBits of 4294967295 is 32', () => {
  const res = BinaryCountSetBits(4294967295)
  expect(res).toBe(32)
})
test('check BinaryCountSetBits of 0 is 0', () => {
  const res = BinaryCountSetBits(0)
  expect(res).toBe(0)
})
/

export const IsPowerOfTwo = (n) => {
  if (n > 0 && (n & (n - 1)) === 0) {
    return true
  }
  return false
}
/



export const setBit = (number, bitPosition) => {
  return number | (1 << bitPosition)
}


export const nextPowerOfTwo = (n) => {
  if (n > 0 && (n & (n - 1)) === 0) return n
  let result = 1
  while (n > 0) {
    result = result << 1
    n = n >> 1
  }
  return result
}
/

function BinaryCountSetBits (a) {
  'use strict'
    return a.toString(2).split('1').length - 1
}

export { BinaryCountSetBits }

function quickSort (items) {
  const length = items.length

  if (length <= 1) {
    return items
  }
  const PIVOT = items[0]
  const GREATER = []
  const LESSER = []

  for (let i = 1; i < length; i++) {
    if (items[i] > PIVOT) {
      GREATER.push(items[i])
    } else {
      LESSER.push(items[i])
    }
  }

  const sorted = [...quickSort(LESSER), PIVOT, ...quickSort(GREATER)]
  return sorted
}

export { quickSort }
/
export function gnomeSort (items) {
  if (items.length <= 1) {
    return
  }

  let i = 1

  while (i < items.length) {
    if (items[i - 1] <= items[i]) {
      i++
    } else {
      [items[i], items[i - 1]] = [items[i - 1], items[i]]

      i = Math.max(1, i - 1)
    }
  }
  return items
}




export function flashSort (arr) {
  let max = 0; let min = arr[0]
  const n = arr.length
  const m = ~~(0.45 * n)
  const l = new Array(m)

  for (let i = 1; i < n; ++i) {
    if (arr[i] < min) {
      min = arr[i]
    }
    if (arr[i] > arr[max]) {
      max = i
    }
  }

  if (min === arr[max]) {
    return arr
  }

  const c1 = (m - 1) / (arr[max] - min)

  for (let k = 0; k < m; k++) {
    l[k] = 0
  }

  for (let j = 0; j < n; ++j) {
    const k = ~~(c1 * (arr[j] - min))
    ++l[k]
  }

  for (let p = 1; p < m; ++p) {
    l[p] = l[p] + l[p - 1]
  }

  let hold = arr[max]
  arr[max] = arr[0]
  arr[0] = hold

    let move = 0; let t; let flash
  let j = 0
  let k = m - 1

  while (move < (n - 1)) {
    while (j > (l[k] - 1)) {
      ++j
      k = ~~(c1 * (arr[j] - min))
    }
    if (k < 0) break
    flash = arr[j]
    while (j !== l[k]) {
      k = ~~(c1 * (flash - min))
      hold = arr[t = --l[k]]
      arr[t] = flash
      flash = hold
      ++move
    }
  }

    for (j = 1; j < n; j++) {
    hold = arr[j]
    let i = j - 1
    while (i >= 0 && arr[i] > hold) {
      arr[i + 1] = arr[i--]
    }
    arr[i + 1] = hold
  }
  return arr
}



function introsort (array, compare) {
  /
  const defaultComparator = function (x, y) {
    if (x === undefined && y === undefined) return 0
    if (x === undefined) return 1
    if (y === undefined) return -1
    const xString = toString(x)
    const yString = toString(y)
    if (xString < yString) return -1
    if (xString > yString) return 1
    return 0
  }
  /
  const toString = function (obj) {
    if (obj === null) return 'null'
    if (typeof obj === 'boolean' || typeof obj === 'number') {
      return obj.toString()
    }
    if (typeof obj === 'string') return obj
    if (typeof obj === 'symbol') throw new TypeError()
    return obj.toString()
  }
  /
  if (Array.isArray(array) === false) {
    return
  }
  /
  if (typeof compare !== 'function') {
    compare = defaultComparator   }
  /
  return (function (array, comparator) {
    const swap = function (index1, index2) {
      const temp = array[index1]
      array[index1] = array[index2]
      array[index2] = temp
    }
    /
    const THRESHOLD = 16
    /
    const TUNEMAXDEPTH = 1
    const len = array.length
    /
    if (len === 1) {
      return
    }
    /
    const maxDepth = Math.floor(Math.log2(len)) * TUNEMAXDEPTH
    /
    quickSort(0, len, maxDepth)
    /
    insertionSort(0, len)
    /
    /
    function quickSort (start, last, depth) {
      if (last - start <= THRESHOLD) {
        insertionSort(start, last)
        return
      } else if (depth <= 0) {
        heapSort(start, last)
        return
      }
      let pivot = (last + start) >> 1
      pivot = partition(start, last, pivot)
      quickSort(start, pivot, depth - 1)
      quickSort(pivot + 1, last, depth - 1)
    }
    /
    function partition (start, last, pivot) {
      swap(start, pivot)
      pivot = start
      let lo = start
      let hi = last
      while (true) {
        lo++
        while (comparator(array[lo], array[pivot]) <= 0 && lo !== last) {
          lo++
        }
        hi--
        while (comparator(array[hi], array[pivot]) > 0 && hi !== start) {
          hi--
        }
        if (lo >= hi) {
          break
        }
        swap(lo, hi)
      }
      swap(start, hi)
      return hi
    }
    /
    function insertionSort (start, last) {
      let i, j
      for (i = start + 1; i < last; i++) {
        j = i - 1
        while (j >= 0 && comparator(array[j], array[j + 1]) > 0) {
          swap(j, j + 1)
          j--
        }
      }
    }
    /
    function heapSort (start, last) {
      let x = (last + start) >> 1
      while (x - start >= 0) {
        heapify(x, start, last)
        x--
      }
      x = last - 1
      while (x - start > 0) {
        swap(start, x)
        heapify(start, start, x)
        x--
      }
    }
    /
    function heapify (cur, start, last) {
      const size = last - start
      let max, lt, rt
      cur = cur - start
      while (true) {
        max = cur
        lt = 2 * max + 1
        rt = 2 * max + 2
        if (
          lt < size &&
          comparator(array[start + max], array[start + lt]) < 0
        ) {
          max = lt
        }
        if (
          rt < size &&
          comparator(array[start + max], array[start + rt]) < 0
        ) {
          max = rt
        }
        if (max !== cur) {
          swap(start + cur, start + max)
          cur = max
        } else {
          break
        }
      }
    }
  })(array, compare)
}


function demo1 () {
  const data = []
  const size = 1000000
  let i = 0
  let temp
  const c = function (a, b) {
    return a - b
  }
  for (i = 0; i < size; i++) {
    temp = Math.random() * Number.MAX_SAFE_INTEGER
    data.push(temp)
  }
  introsort(data, c)
  let faulty = false
  for (i = 1; i < size; i++) {
    if (data[i] < data[i - 1]) {
      faulty = true
      break
    }
  }
  if (faulty) {
    return 'WRONG!!'
  } else {
    return 'RIGHT:)'
  }
}


function demo2 () {
  const data = []
  const data2 = []
  const size = 1000000
  let i = 0
  let temp
  for (i = 0; i < size; i++) {
    temp = Math.random() * Number.MAX_SAFE_INTEGER
    data.push(temp)
    data2.push(temp)
  }
  introsort(data)
  data2.sort()
  let faulty = false
  for (i = 1; i < size; i++) {
    if (data[i] !== data2[i]) {
      faulty = true
      break
    }
  }
  if (faulty) {
    return 'WRONG Implemented Comparator!!'
  } else {
    return 'Comparator Works Fine:)'
  }
}

export { introsort, demo1, demo2 }
import { radixSort } from '../RadixSort'

test('The RadixSort of the array [4, 3, 2, 1] is [1, 2, 3, 4]', () => {
  const arr = [4, 3, 2, 1]
  const res = radixSort(arr, 10)
  expect(res).toEqual([1, 2, 3, 4])
})

test('The RadixSort of the array [] is []', () => {
  const arr = []
  const res = radixSort(arr, 10)
  expect(res).toEqual([])
})

test('The RadixSort of the array [14, 16, 10, 12] is [10, 12, 14, 16]', () => {
  const arr = [14, 16, 10, 12]
  const res = radixSort(arr, 10)
  expect(res).toEqual([10, 12, 14, 16])
})
import { oddEvenSort } from '../OddEvenSort'

test('The OddEvenSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = oddEvenSort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The OddEvenSort of the array [] is []', () => {
  const arr = []
  const res = oddEvenSort(arr)
  expect(res).toEqual([])
})

test('The OddEvenSort of the array [10, 14, 12, 20] is [10, 12, 14, 20]', () => {
  const arr = [10, 14, 12, 20]
  const res = oddEvenSort(arr)
  expect(res).toEqual([10, 12, 14, 20])
})

test('The OddEvenSort of the array [166, 169, 144] is [144, 166, 169]', () => {
  const arr = [166, 169, 144]
  const res = oddEvenSort(arr)
  expect(res).toEqual([144, 166, 169])
})
import { beadSort } from '../BeadSort'

describe('BeadSort', () => {
  it('should sort arrays correctly', () => {
    expect(beadSort([5, 4, 3, 2, 1])).toEqual([1, 2, 3, 4, 5])
    expect(beadSort([7, 9, 4, 3, 5])).toEqual([3, 4, 5, 7, 9])
  })

  it('should throw a RangeError when the array contains negative integers', () => {
    expect(() => beadSort([-1, 5, 8, 4, 3, 19])).toThrow(RangeError)
  })
})
import { cycleSort } from '../CycleSort'

describe('cycleSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(cycleSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(cycleSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(cycleSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(cycleSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(cycleSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(cycleSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(cycleSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(cycleSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(cycleSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(cycleSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(cycleSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(cycleSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(cycleSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(cycleSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(cycleSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})
import { insertionSortAlternativeImplementation } from '../InsertionSort'

describe('insertionSortAlternativeImplementation', () => {
  it('expects to work with empty array', () => {
    expect(insertionSortAlternativeImplementation([])).toEqual([])
  })

  it('expects to return input array when array.length is less than 2', () => {
    const input = [3]
    expect(insertionSortAlternativeImplementation(input)).toEqual(input)
  })

  it('expects to return array sorted in ascending order', () => {
    expect(insertionSortAlternativeImplementation([14, 11])).toEqual([11, 14])
    expect(insertionSortAlternativeImplementation([21, 22, 23])).toEqual([21, 22, 23])
    expect(insertionSortAlternativeImplementation([1, 3, 2, 3, 7, 2])).toEqual([1, 2, 2, 3, 3, 7])
    expect(insertionSortAlternativeImplementation([1, 6, 4, 5, 9, 2])).toEqual([1, 2, 4, 5, 6, 9])
  })
})
import { flipArray, findMax, pancakeSort } from '../PancakeSort'

describe('flipArray', () => {
  it('should flip any subarray of any array', () => {
    expect(flipArray([1, 2, 3, 4], 0, 3)).toEqual([4, 3, 2, 1])
    expect(flipArray([1, 2, 3, 4, 5], 2, 4)).toEqual([1, 2, 5, 4, 3])
    expect(flipArray([], 0, 0)).toEqual([])
  })
})

describe('findMax', () => {
  it('should find the index of the maximum value in any subarray of any array', () => {
    expect(findMax([1, 3, 2, 5], 0, 3)).toEqual(3)
    expect(findMax([1, 3, 2, 5], 0, 2)).toEqual(1)
  })
})

describe('pancakeSort', () => {
  it('should sort any array', () => {
    expect(pancakeSort([4, 3, 2, 1])).toEqual([1, 2, 3, 4])
    expect(pancakeSort([3, 1, 4, 2])).toEqual([1, 2, 3, 4])
    expect(pancakeSort([100, 1000, 10, 1])).toEqual([1, 10, 100, 1000])
  })
})
import { combSort } from '../CombSort'

describe('combSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(combSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(combSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(combSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(combSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(combSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(combSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(combSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(combSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(combSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(combSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(combSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(combSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(combSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(combSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(combSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})
import { flashSort } from '../FlashSort'

test('The flash sort of the array [3, 0, 2, 5, -1, 4, 1, -2] is [-2, -1, 0, 1, 2, 3, 4, 5]', () => {
  const array = [3, 0, 2, 5, -1, 4, 1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-2, -1, 0, 1, 2, 3, 4, 5])
})

test('The flash sort of the array [-3, 0, 2, -5, -1, 4, 1, -2] is [-5, -3, -2, -1, 0, 1, 2, 4]', () => {
  const array = [-3, 0, 2, -5, -1, 4, 1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-5, -3, -2, -1, 0, 1, 2, 4])
})

test('The flash sort of the array [13, 0, 12, 5, -1, 14, 1, -2] is [-2, -1, 0, 1, 5, 12, 13, 14]', () => {
  const array = [13, 0, 12, 5, -1, 14, 1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-2, -1, 0, 1, 5, 12, 13, 14])
})

test('The flash sort of the array [-3, 0, -2, -5, -1, -4, -1, -2] is [-5, -4, -3, -2, -2, -1, -1, 0]', () => {
  const array = [-3, 0, -2, -5, -1, -4, -1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-5, -4, -3, -2, -2, -1, -1, 0])
})
import { quickSort } from '../QuickSort'

describe('QuickSort', () => {
  it('should work for empty arrays', () => {
    expect(quickSort([])).toEqual([])
  })

  it('should sort arrays correctly', () => {
    expect(quickSort([5, 4, 3, 10, 2, 1])).toEqual([1, 2, 3, 4, 5, 10])
    expect(quickSort([5, 4])).toEqual([4, 5])
    expect(quickSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(quickSort([0, 5, 3, 2, 2])).toEqual([0, 2, 2, 3, 5])
  })
})
import { alphaNumericalSort } from '../AlphaNumericalSort'

describe('alphaNumericalComparer', () => {
  test('given array of eng symbols return correct sorted array', () => {
    const src = ['b', 'a', 'c']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['a', 'b', 'c'])
  })

  test('given array of numbers return correct sorted array', () => {
    const src = ['15', '0', '5']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['0', '5', '15'])
  })

  test('correct sort with numbers and strings', () => {
    const src = ['3', 'a1b15c', 'z', 'a1b14c']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['3', 'a1b14c', 'a1b15c', 'z'])
  })

  test('correct sort with long numbers', () => {
    const src = ['abc999999999999999999999999999999999cba', 'abc999999999999999999999999999999990cba', 'ab']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['ab', 'abc999999999999999999999999999999990cba', 'abc999999999999999999999999999999999cba'])
  })

  test('correct sort with z prefix', () => {
    const src = ['z', 'abc003def', 'abc1def', 'a']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['a', 'abc1def', 'abc003def', 'z'])
  })

  test('correct sort with other language', () => {
    const src = ['а10б', 'а2б', 'в10г', 'в05г']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['а2б', 'а10б', 'в05г', 'в10г'])
  })
})
import { pigeonHoleSort } from '../PigeonHoleSort'

test('The pigeonHoleSort of the array [1, 4, 3, 2] is [1, 2, 3, 4]', () => {
  const arr = [1, 4, 3, 2]
  const res = pigeonHoleSort(arr)
  expect(res).toEqual([1, 2, 3, 4])
})

test('The pigeonHoleSort of the array [5, 4, 1, 2] is [1, 2, 4, 5]', () => {
  const arr = [5, 4, 1, 2]
  const res = pigeonHoleSort(arr)
  expect(res).toEqual([1, 2, 4, 5])
})

test('The pigeonHoleSort of the array [18, 31, 29, 35, 11] is [11, 18, 29, 31, 35]', () => {
  const arr = [18, 31, 29, 35, 11]
  const res = pigeonHoleSort(arr)
  expect(res).toEqual([11, 18, 29, 31, 35])
})
import { gnomeSort } from '../GnomeSort'

test('The gnomeSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = gnomeSort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The gnomeSort of the array [-5, 4, -3, 2, -1] is [-5, -3, -1, 2, 4]', () => {
  const arr = [-5, 4, -3, 2, -1]
  const res = gnomeSort(arr)
  expect(res).toEqual([-5, -3, -1, 2, 4])
})

test('The gnomeSort of the array [15, 4, -13, 2, -11] is [-13, -11, 2, 4, 15]', () => {
  const arr = [15, 4, -13, 2, -11]
  const res = gnomeSort(arr)
  expect(res).toEqual([-13, -11, 2, 4, 15])
})
import { shellSort } from '../ShellSort'

test('The ShellSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = shellSort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The ShellSort of the array [] is []', () => {
  const arr = []
  const res = shellSort(arr)
  expect(res).toEqual([])
})

test('The ShellSort of the array [15, 24, 31, 42, 11] is [11, 15, 24, 31, 42]', () => {
  const arr = [15, 24, 31, 42, 11]
  const res = shellSort(arr)
  expect(res).toEqual([11, 15, 24, 31, 42])
})

test('The ShellSort of the array [121, 190, 169] is [121, 169, 190]', () => {
  const arr = [121, 190, 169]
  const res = shellSort(arr)
  expect(res).toEqual([121, 169, 190])
})
import { secondLargestElement } from '../FindSecondLargestElement'

test('The second largest element of the array [1, 2, 3, 4, 5] is 4', () => {
  const array = [1, 2, 3, 4, 5]
  const res = secondLargestElement(array)
  expect(res).toEqual(4)
})

test('The second largest element of the array [-1, -2, -3, -4, -5] is -2', () => {
  const array = [-1, -2, -3, -4, -5]
  const res = secondLargestElement(array)
  expect(res).toEqual(-2)
})
import { stoogeSort } from '../StoogeSort'

test('The StoogeSort of the array [1, 6, 4, 7, 2] is [1, 2, 4, 6, 7]', () => {
  const arr = [1, 6, 4, 7, 2]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([1, 2, 4, 6, 7])
})

test('The StoogeSort of the array [] is []', () => {
  const arr = []
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([])
})

test('The StoogeSort of the array [46, 15, 49, 65, 23] is [15, 23, 46, 49, 65]', () => {
  const arr = [46, 15, 49, 65, 23]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([15, 23, 46, 49, 65])
})

test('The StoogeSort of the array [136, 459, 132, 566, 465] is [132, 136, 459, 465, 566]', () => {
  const arr = [136, 459, 132, 566, 465]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([132, 136, 459, 465, 566])
})

test('The StoogeSort of the array [45, 3, 156, 1, 56] is [1, 3, 45, 56, 156]', () => {
  const arr = [45, 3, 156, 1, 56]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([1, 3, 45, 56, 156])
})
import { countingSort } from '../CountingSort'

test('The countingSort of the array [3, 0, 2, 5, 4, 1] is [0, 1, 2, 3, 4, 5]', () => {
  const array = [3, 0, 2, 5, 4, 1]
  const res = countingSort(array, 0, 5)
  expect(res).toEqual([0, 1, 2, 3, 4, 5])
})

test('The countingSort of the array [6, 4, 2, 1, 3, 5] is [1, 2, 3, 4, 5, 6]', () => {
  const array = [6, 4, 2, 1, 3, 5]
  const res = countingSort(array, 1, 6)
  expect(res).toEqual([1, 2, 3, 4, 5, 6])
})

test('The countingSort of the array [11, 14, 12, 15, 16, 13] is [11, 12, 13, 14, 15, 16]', () => {
  const array = [11, 14, 12, 15, 16, 13]
  const res = countingSort(array, 11, 16)
  expect(res).toEqual([11, 12, 13, 14, 15, 16])
})

test('The countingSort of the array [13, 18, 2, 15, 43, 11] is [2, 11, 13, 15, 18, 43]', () => {
  const array = [13, 18, 2, 15, 43, 11]
  const res = countingSort(array, 2, 43)
  expect(res).toEqual([2, 11, 13, 15, 18, 43])
})
import { bogoSort, isSorted } from '../BogoSort'

describe('isSorted', () => {
  it('should return true for empty arrays', () => {
    expect(isSorted([])).toBe(true)
  })

  it('should return true for single-element arrays', () => {
    expect(isSorted([1])).toBe(true)
  })

  it('should return true for arrays that are properly sorted', () => {
    expect(isSorted([1, 2, 3])).toBe(true)
  })

  it('should return false for arrays that are not properly sorted', () => {
    expect(isSorted([3, 2, 1])).toBe(false)
  })
})

describe('bogoSort', () => {
  it('should (eventually) sort the array', () => {
    expect(bogoSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })
})
import { Timsort } from '../TimSort'

test('The Timsort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = Timsort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The Timsort of the array [] is []', () => {
  const arr = []
  const res = Timsort(arr)
  expect(res).toEqual([])
})

test('The Timsort of the array [-5, -4, -3, -2, -1] is [-5, -4, -3, -2, -1]', () => {
  const arr = [-5, -4, -3, -2, -1]
  const res = Timsort(arr)
  expect(res).toEqual([-5, -4, -3, -2, -1])
})

test('The Timsort of the array [9, 0, -5, -11, 3] is [-11, -5, 0, 3, 9]', () => {
  const arr = [9, 0, -5, -11, 3]
  const res = Timsort(arr)
  expect(res).toEqual([-11, -5, 0, 3, 9])
})
import { quickSort } from '../QuickSortRecursive'

describe('QuickSortRecursive | Partition In Place Method', () => {
  it('Expectedly, throw some error if we pass a non-array input', () => {
    expect(() => quickSort('xyz', 0, 2)).toThrow('Please input a valid list or array.')
    expect(() => quickSort(null, 0, 4)).toThrow('Please input a valid list or array.')
    expect(() => quickSort(55, 0, 2)).toThrow('Please input a valid list or array.')
  })

  it('Expectedly, the quickSort method will sort the unsorted list in ascending order', () => {
    const unSortArray = [5, 9, 3, 4, 6, 2, 0, 1, 7, 8]
    const sortedExpectedArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    expect(quickSort(unSortArray, 0, unSortArray.length - 1)).toEqual(sortedExpectedArray)
  })

  it('Expectedly, the quickSort method will arrange the list of character values in dictionary order.', () => {
    const unSortList = ['d', 'e', 'c', 'a', 'f', 'b']
    const sortedExpectedList = ['a', 'b', 'c', 'd', 'e', 'f']
    expect(quickSort(unSortList, 0, unSortList.length - 1)).toEqual(sortedExpectedList)
  })
})
import { heapSort } from '../HeapSortV2'

test('The heapSort of the array [4, 3, 2, 1] is [1, 2, 3, 4]', () => {
  const arr = [4, 3, 2, 1]
  const res = heapSort(arr)
  expect(res).toEqual([1, 2, 3, 4])
})

test('The heapSort of the array [] is []', () => {
  const arr = []
  const res = heapSort(arr)
  expect(res).toEqual([])
})

test('The heapSort of the array [41, 31, 32, 31] is [31, 31, 32, 41]', () => {
  const arr = [41, 31, 32, 31]
  const res = heapSort(arr)
  expect(res).toEqual([31, 31, 32, 41])
})
import { selectionSort } from '../SelectionSort'

describe('selectionSort', () => {
  it('expects to return the array sorted in ascending order', () => {
    const toSort = [5, 6, 7, 8, 1, 2, 12, 14]
    const expected = [1, 2, 5, 6, 7, 8, 12, 14]

    expect(selectionSort(toSort)).toEqual(expected)
  })

  it('expects to throw if it is not a valid array', () => {
    expect(() => selectionSort('abc')).toThrow('Given input is not an array')
    expect(() => selectionSort(123)).toThrow('Given input is not an array')
    expect(() => selectionSort({})).toThrow('Given input is not an array')
    expect(() => selectionSort(null)).toThrow('Given input is not an array')
    expect(() => selectionSort()).toThrow('Given input is not an array')
  })

  it('expects to throw if one of the elements in the array is not a number', () => {
    expect(() => selectionSort([1, 'x', 2])).toThrow('One of the items in your array is not a number')
  })
})
import { shuffle } from '../FisherYatesShuffle'

describe('shuffle', () => {
  it('expects to have a new array with same size', () => {
    const fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    const mixedArray = shuffle(fibonacci)

    expect(mixedArray).toHaveLength(fibonacci.length)
  })

  it('expects to have a new array with same values', () => {
    const fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    const mixedArray = shuffle(fibonacci)

    expect(mixedArray).toContain(0)
    expect(mixedArray).toContain(1)
    expect(mixedArray).toContain(2)
    expect(mixedArray).toContain(3)
    expect(mixedArray).toContain(5)
    expect(mixedArray).toContain(8)
    expect(mixedArray).toContain(13)
    expect(mixedArray).toContain(21)
    expect(mixedArray).toContain(34)
    expect(mixedArray).toContain(55)
    expect(mixedArray).toContain(89)
  })
})
import { heapSort } from '../HeapSort'

test('The HeapSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const array = [5, 4, 3, 2, 1]
  const res = heapSort(array)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The HeapSort of the array [-5, -4, -3, -2, -1] is [-5, -4, -3, -2, -1]', () => {
  const array = [-5, -4, -3, -2, -1]
  const res = heapSort(array)
  expect(res).toEqual([-5, -4, -3, -2, -1])
})

test('The HeapSort of the array [50, 43, 31, 52, 91] is [31, 43, 50, 52, 91]', () => {
  const array = [50, 43, 31, 52, 91]
  const res = heapSort(array)
  expect(res).toEqual([31, 43, 50, 52, 91])
})

test('The HeapSort of the array [] is []', () => {
  const array = []
  const res = heapSort(array)
  expect(res).toEqual([])
})
import { secondLargestElement } from '../FindSecondLargestElement'

test('The second largest element of the array [100, 200, 300, 400] is 300', () => {
  const array = [100, 200, 300, 400]
  const res = secondLargestElement(array)
  expect(res).toBe(300)
})

test('The second largest element of the array [1100, 2400, 1300, 4002] is 2400', () => {
  const array = [1100, 2400, 1300, 4002]
  const res = secondLargestElement(array)
  expect(res).toBe(2400)
})

test('The second largest element of the array [10, 20, 39, 34] is 34', () => {
  const array = [10, 20, 39, 34]
  const res = secondLargestElement(array)
  expect(res).toBe(34)
})

test('The second largest element of the array [1, 20, 3, 40] is 20', () => {
  const array = [1, 20, 3, 40]
  const res = secondLargestElement(array)
  expect(res).toBe(20)
})
import { cocktailShakerSort } from '../CocktailShakerSort'

describe('CocktailShakerSort', () => {
  it('should sort arrays correctly', () => {
    expect(cocktailShakerSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(cocktailShakerSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(cocktailShakerSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })

  it('should work for empty arrays, too', () => {
    expect(cocktailShakerSort([])).toEqual([])
  })
})
import { bucketSort } from '../BucketSort'

describe('Tests for bucketSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(bucketSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(bucketSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(bucketSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(bucketSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(bucketSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(bucketSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(bucketSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(bucketSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(bucketSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(bucketSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(bucketSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(bucketSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(bucketSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(bucketSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(bucketSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})
import { merge, mergeSort } from '../MergeSort'

describe('merge', () => {
  it('should merge arrays correctly', () => {
    expect(merge([5, 4], [1, 2, 3])).toEqual([1, 2, 3, 5, 4])
    expect(merge([], [1, 2])).toEqual([1, 2])
    expect(merge([1, 2, 3], [1])).toEqual([1, 1, 2, 3])
    expect(merge([], [])).toEqual([])
  })
})

describe('MergeSort', () => {
  it('should work for empty arrays', () => {
    expect(mergeSort([])).toEqual([])
  })

  it('should sort arrays correctly', () => {
    expect(mergeSort([5, 4])).toEqual([4, 5])
    expect(mergeSort([8, 4, 10, 15, 9])).toEqual([4, 8, 9, 10, 15])
    expect(mergeSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(mergeSort([10, 5, 3, 8, 2, 6, 4, 7, 9, 1])).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
  })
})
import { simplifiedWiggleSort } from '../SimplifiedWiggleSort.js'

describe('simplified wiggle sort', () => {
  test('simplified wiggle sort for chars', () => {
    const src = ['a', 'b', 'c']
    expect(simplifiedWiggleSort(src)).toEqual(['a', 'c', 'b'])
  })

  test('wiggle sort with duplicates, even array', () => {
    const src = [2, 2, 1, 3]
    expect(simplifiedWiggleSort(src)).toEqual([1, 3, 2, 2])
  })

  test('wiggle sort with duplicates, odd array', () => {
    const src = [1, 1, 1, 2, 4]
    expect(simplifiedWiggleSort(src)).toEqual([1, 4, 1, 2, 1])
  })

  test('simplified wiggle sort which leads to equal values next to ' +
    'each other', () => {
    const src = [3, 3, 5, 1]
    expect(simplifiedWiggleSort(src)).toEqual([1, 5, 3, 3])
  })
})
import { alternativeBubbleSort, bubbleSort } from '../BubbleSort'

describe('bubbleSort', () => {
  it('should sort arrays correctly', () => {
    expect(bubbleSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(bubbleSort([])).toEqual([])
    expect(bubbleSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(bubbleSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
    expect(bubbleSort([5, 6, 7, 8, 9, 4])).toEqual([4, 5, 6, 7, 8, 9])
    expect(bubbleSort([20, 30, 40])).toEqual([20, 30, 40])
    expect(bubbleSort([2, 1, 3])).toEqual([1, 2, 3])
    expect(bubbleSort([10, 15, 16, 100])).toEqual([10, 15, 16, 100])
    expect(bubbleSort([10, 9, 11])).toEqual([9, 10, 11])
    expect(bubbleSort([10, 9, 12])).toEqual([9, 10, 12])
    expect(bubbleSort([3, 2, 1])).toEqual([1, 2, 3])
    expect(bubbleSort([10, 9, 8])).toEqual([8, 9, 10])
  })
})

describe('alternativeBubbleSort', () => {
  it('should sort arrays correctly', () => {
    expect(alternativeBubbleSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(alternativeBubbleSort([])).toEqual([])
    expect(alternativeBubbleSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(alternativeBubbleSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })
})



function combSort (list) {
  if (list.length === 0) {
    return list
  }
  const shrink = 1.3
  let gap = list.length
  let isSwapped = true
  let i = 0

  while (gap > 1 || isSwapped) {
        gap = parseInt(parseFloat(gap) / shrink, 10)

    isSwapped = false
    i = 0

    while (gap + i < list.length) {
      if (list[i] > list[i + gap]) {
        [list[i], list[i + gap]] = [list[i + gap], list[i]]
        isSwapped = true
      }
      i += 1
    }
  }
  return list
}

export { combSort }
/

const secondLargestElement = (array) => {
  const largestElement = Math.max(...array)
  let element = -Number.MAX_VALUE

  for (let i = 0; i < array.length; i++) {
    if (element < array[i] && array[i] !== largestElement) {
      element = array[i]
    }
  }

  return element
}

export { secondLargestElement }


export const countingSort = (arr, min, max) => {
    const res = []
    const count = new Array(max - min + 1).fill(0)
    for (let i = 0; i < arr.length; i++) {
    count[arr[i] - min]++
  }
    count[0] -= 1
  for (let i = 1; i < count.length; i++) {
    count[i] += count[i - 1]
  }
    for (let i = arr.length - 1; i >= 0; i--) {
    res[count[arr[i] - min]] = arr[i]
    count[arr[i] - min]--
  }
  return res
}


/
export function radixSort (items, RADIX) {
    if (RADIX === undefined || RADIX < 1) {
    RADIX = 10
  }

  let maxLength = false
  let placement = 1

  while (!maxLength) {
    maxLength = true
    const buckets = []

    for (let i = 0; i < RADIX; i++) {
      buckets.push([])
    }

    for (let j = 0; j < items.length; j++) {
      const tmp = items[j] / placement
      buckets[Math.floor(tmp % RADIX)].push(items[j])
      if (maxLength && tmp > 0) {
        maxLength = false
      }
    }

    let a = 0
    for (let b = 0; b < RADIX; b++) {
      const buck = buckets[b]
      for (let k = 0; k < buck.length; k++) {
        items[a] = buck[k]
        a++
      }
    }
    placement *= RADIX
  }
  return items
}
/


const quickSort = (inputList, low, high) => {
  if (!Array.isArray(inputList)) {
    throw new TypeError('Please input a valid list or array.')
  }
  if (low < high) {
        const pIndex = partition(inputList, low, high)
        quickSort(inputList, low, pIndex - 1)
    quickSort(inputList, pIndex + 1, high)
  }
  return inputList
}


const partition = (partitionList, low, high) => {
  const pivot = partitionList[high]
  let pIndex = low
  for (let index = low; index <= high - 1; index++) {
    if (partitionList[index] < pivot) {
            [partitionList[index], partitionList[pIndex]] = [partitionList[pIndex], partitionList[index]]
      pIndex += 1
    }
  }
  [partitionList[pIndex], partitionList[high]] = [partitionList[high], partitionList[pIndex]]
  return pIndex
}

export { quickSort }
/
export function pigeonHoleSort (arr) {
  let min = arr[0]
  let max = arr[0]

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > max) { max = arr[i] }
    if (arr[i] < min) { min = arr[i] }
  }

  const range = max - min + 1
  const pigeonhole = Array(range).fill(0)

  for (let i = 0; i < arr.length; i++) {
    pigeonhole[arr[i] - min]++
  }

  let index = 0

  for (let j = 0; j < range; j++) {
    while (pigeonhole[j]-- > 0) {
      arr[index++] = j + min
    }
  }
  return arr
}
/

function swap (arr, i, j) {
  const tmp = arr[i]
  arr[i] = arr[j]
  arr[j] = tmp
}

export function oddEvenSort (arr) {
  let sorted = false
  while (!sorted) {
    sorted = true
    for (let i = 1; i < arr.length - 1; i += 2) {
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1)
        sorted = false
      }
    }
    for (let i = 0; i < arr.length - 1; i += 2) {
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1)
        sorted = false
      }
    }
  }
  return arr
}

export function TopologicalSorter () {
  const graph = {}
  let isVisitedNode
  let finishTimeCount
  let finishingTimeList
  let nextNode

  this.addOrder = function (nodeA, nodeB) {
    nodeA = String(nodeA)
    nodeB = String(nodeB)
    graph[nodeA] = graph[nodeA] || []
    graph[nodeA].push(nodeB)
  }

  this.sortAndGetOrderedItems = function () {
    isVisitedNode = Object.create(null)
    finishTimeCount = 0
    finishingTimeList = []

    for (const node in graph) {
      if (Object.prototype.hasOwnProperty.call(graph, node) && !isVisitedNode[node]) {
        dfsTraverse(node)
      }
    }

    finishingTimeList.sort(function (item1, item2) {
      return item1.finishTime > item2.finishTime ? -1 : 1
    })

    return finishingTimeList.map(function (value) { return value.node })
  }

  function dfsTraverse (node) {
    isVisitedNode[node] = true
    if (graph[node]) {
      for (let i = 0; i < graph[node].length; i++) {
        nextNode = graph[node][i]
        if (isVisitedNode[nextNode]) continue
        dfsTraverse(nextNode)
      }
    }

    finishingTimeList.push({
      node,
      finishTime: ++finishTimeCount
    })
  }
}

/



function cycleSort (list) {
  for (let cycleStart = 0; cycleStart < list.length; cycleStart++) {
    let value = list[cycleStart]
    let position = cycleStart

        for (let i = cycleStart + 1; i < list.length; i++) {
      if (list[i] < value) {
        position++
      }
    }
        if (position === cycleStart) {
      continue
    }
    while (value === list[position]) {
      position++
    }

    const oldValue = list[position]
    list[position] = value
    value = oldValue

        while (position !== cycleStart) {
      position = cycleStart
      for (let i = cycleStart + 1; i < list.length; i++) {
        if (list[i] < value) {
          position++
        }
      }
      while (value === list[position]) {
        position++
      }
      const oldValueCycle = list[position]
      list[position] = value
      value = oldValueCycle
    }
  }
  return list
}

export { cycleSort }
/

export function insertionSort (unsortedList) {
  const len = unsortedList.length
  for (let i = 1; i < len; i++) {
    let j
    const tmp = unsortedList[i]     /
    for (j = i - 1; j >= 0 && (unsortedList[j] > tmp); j--) {
            unsortedList[j + 1] = unsortedList[j]
    }
            unsortedList[j + 1] = tmp
  }
}



/

export function insertionSortAlternativeImplementation (array) {
  const length = array.length
  if (length < 2) return array

  for (let i = 1; i < length; i++) {
        const currentItem = array[i]
        let j = i - 1

        while (j >= 0 && array[j] > currentItem) {
            array[j + 1] = array[j]
      j--
    }
        array[j + 1] = currentItem
  }
    return array
}
/

export const selectionSort = (list) => {
  if (!Array.isArray(list)) {
    throw new TypeError('Given input is not an array')
  }
  const items = [...list]   const length = items.length
  for (let i = 0; i < length - 1; i++) {
    if (typeof items[i] !== 'number') {
      throw new TypeError('One of the items in your array is not a number')
    }
        let min = i     for (let j = i + 1; j < length; j++) {       if (items[j] < items[min]) {         min = j       }
    }
    if (min !== i) {
                  [items[i], items[min]] = [items[min], items[i]]
    }
  }
  return items
}
export const shuffle = (array) => {
  let maxLength = array.length
  let temp
  let idx

    while (maxLength) {
        idx = Math.floor(Math.random() * maxLength--)

        temp = array[maxLength]
    array[maxLength] = array[idx]
    array[idx] = temp
  }

  return array
}
/
import { quickSelectSearch } from '../Search/QuickSelectSearch.js'

export const simplifiedWiggleSort = function (arr) {
    let median = quickSelectSearch(arr, Math.floor(arr.length / 2.0))
  median = median[Math.floor(arr.length / 2.0)]

  const sorted = new Array(arr.length)

  let smallerThanMedianIndx = 0
  let greaterThanMedianIndx = arr.length - 1 - (arr.length % 2)

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > median) {
      sorted[greaterThanMedianIndx] = arr[i]
      greaterThanMedianIndx -= 2
    } else {
      if (smallerThanMedianIndx < arr.length) {
        sorted[smallerThanMedianIndx] = arr[i]
        smallerThanMedianIndx += 2
      } else {
        sorted[greaterThanMedianIndx] = arr[i]
        greaterThanMedianIndx -= 2
      }
    }
  }

  return sorted
}

export function beadSort (sequence) {
  /
  if (sequence.some((integer) => integer < 0)) {
    throw RangeError('Sequence must be a list of Positive integers Only!')
  }

  const sequenceLength = sequence.length
  const max = Math.max(...sequence)

    const grid = sequence.map(number => {
    const maxArr = new Array(max)

    for (let i = 0; i < number; i++) {
      maxArr[i] = '*'
    }

    return maxArr
  })

    for (let col = 0; col < max; col++) {
    let beadsCount = 0

    for (let row = 0; row < sequenceLength; row++) {
      if (grid[row][col] === '*') {
        beadsCount++
      }
    }

    for (let row = sequenceLength - 1; row > -1; row--) {
      if (beadsCount) {
        grid[row][col] = '*'
        beadsCount--
      } else {
        grid[row][col] = undefined
      }
    }
  }

  /
  return grid.map((beadArray) => {
    const beadsArray = beadArray.filter(bead => bead === '*')
    return beadsArray.length
  })
}
let arrayLength = 0

/

function heapRoot (input, i) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let max = i

  if (left < arrayLength && input[left] > input[max]) {
    max = left
  }

  if (right < arrayLength && input[right] > input[max]) {
    max = right
  }

  if (max !== i) {
    swap(input, i, max)
    heapRoot(input, max)
  }
}

function swap (input, indexA, indexB) {
  [input[indexA], input[indexB]] = [input[indexB], input[indexA]]
}

export function heapSort (input) {
  arrayLength = input.length

  for (let i = Math.floor(arrayLength / 2); i >= 0; i -= 1) {
    heapRoot(input, i)
  }

  for (let i = input.length - 1; i > 0; i--) {
    swap(input, 0, i)
    arrayLength--

    heapRoot(input, 0)
  }
  return input
}

export function cocktailShakerSort (items) {
  for (let i = items.length - 1; i > 0; i--) {
    let j

        for (j = items.length - 1; j > i; j--) {
      if (items[j] < items[j - 1]) {
        [items[j], items[j - 1]] = [items[j - 1], items[j]]
      }
    }

        for (j = 0; j < i; j++) {
      if (items[j] > items[j + 1]) {
        [items[j], items[j + 1]] = [items[j + 1], items[j]]
      }
    }
  }

  return items
}
/


export function bubbleSort (items) {
  const length = items.length
  let noSwaps

  for (let i = length; i > 0; i--) {
        noSwaps = true
        for (let j = 0; j < (i - 1); j++) {
            if (items[j] > items[j + 1]) {
                [items[j], items[j + 1]] = [items[j + 1], items[j]]
        noSwaps = false
      }
    }
    if (noSwaps) {
      break
    }
  }

  return items
}


export function alternativeBubbleSort (arr) {
  let swapped = true

  while (swapped) {
    swapped = false
    for (let i = 0; i < arr.length - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]
        swapped = true
      }
    }
  }

  return arr
}
/


export function merge (list1, list2) {
  const results = []
  let i = 0
  let j = 0

  while (i < list1.length && j < list2.length) {
    if (list1[i] < list2[j]) {
      results.push(list1[i++])
    } else {
      results.push(list2[j++])
    }
  }

  return results.concat(list1.slice(i), list2.slice(j))
}


export function mergeSort (list) {
  if (list.length < 2) return list

  const listHalf = Math.floor(list.length / 2)
  const subList1 = list.slice(0, listHalf)
  const subList2 = list.slice(listHalf, list.length)

  return merge(mergeSort(subList1), mergeSort(subList2))
}

export function bucketSort (list, size) {
  if (undefined === size) {
    size = 5
  }
  if (list.length === 0) {
    return list
  }
  let min = list[0]
  let max = list[0]
    for (let iList = 0; iList < list.length; iList++) {
    if (list[iList] < min) {
      min = list[iList]
    } else if (list[iList] > max) {
      max = list[iList]
    }
  }
    const count = Math.floor((max - min) / size) + 1

    const buckets = []
  for (let iCount = 0; iCount < count; iCount++) {
    buckets.push([])
  }

    for (let iBucket = 0; iBucket < list.length; iBucket++) {
    const key = Math.floor((list[iBucket] - min) / size)
    buckets[key].push(list[iBucket])
  }
  const sorted = []
    for (let iBucket = 0; iBucket < buckets.length; iBucket++) {
    const arr = buckets[iBucket].sort((a, b) => a - b)
    for (let iSorted = 0; iSorted < arr.length; iSorted++) {
      sorted.push(arr[iSorted])
    }
  }
  return sorted
}
/
export function shellSort (items) {
  let interval = 1

  while (interval < items.length / 3) {
    interval = interval * 3 + 1
  }

  while (interval > 0) {
    for (let outer = interval; outer < items.length; outer++) {
      const value = items[outer]
      let inner = outer

      while (inner > interval - 1 && items[inner - interval] >= value) {
        items[inner] = items[inner - interval]
        inner = inner - interval
      }
      items[inner] = value
    }
    interval = (interval - 1) / 3
  }
  return items
}
/

const alphaNumericalSort = (a, b) => {
  /
  return a.localeCompare(b, undefined, { numeric: true })
}

export { alphaNumericalSort }


const Timsort = (array) => {
    const RUN = 32
  const n = array.length
    for (let i = 0; i < n; i += RUN) {
    InsertionSort(array, i, Math.min(i + RUN - 1, n - 1))
  }
  for (let size = RUN; size < n; size *= 2) {
    for (let left = 0; left < n; left += 2 * size) {
      const mid = left + size - 1
      const right = Math.min(left + 2 * size - 1, n - 1)
      Merge(array, left, mid, right)
    }
  }
  return array
}



const InsertionSort = (array, left, right) => {
  for (let i = left + 1; i <= right; i++) {
    const key = array[i]
    let j = i - 1
    while (j >= left && array[j] > key) {
      array[j + 1] = array[j]
      j--
    }
    array[j + 1] = key
  }
}



const Merge = (array, left, mid, right) => {
  if (mid >= right) return
  const len1 = mid - left + 1
  const len2 = right - mid
  const larr = Array(len1)
  const rarr = Array(len2)
  for (let i = 0; i < len1; i++) {
    larr[i] = array[left + i]
  }
  for (let i = 0; i < len2; i++) {
    rarr[i] = array[mid + 1 + i]
  }
  let i = 0; let j = 0; let k = left
  while (i < larr.length && j < rarr.length) {
    if (larr[i] < rarr[j]) {
      array[k++] = larr[i++]
    } else {
      array[k++] = rarr[j++]
    }
  }
  while (i < larr.length) {
    array[k++] = larr[i++]
  }
  while (j < rarr.length) {
    array[k++] = rarr[j++]
  }
}


const demo = () => {
  const size = 1000000
  const data = Array(size)
  for (let i = 0; i < size; i++) {
    data[i] = Math.random() * Number.MAX_SAFE_INTEGER
  }
  const isSorted = function (array) {
    const n = array.length
    for (let i = 0; i < n - 1; i++) {
      if (array[i] > array[i + 1]) return false
    }
    return true
  }
  Timsort(data)
  if (isSorted(data)) {
    return 'RIGHT'
  } else {
    return 'FAULTY'
  }
}

export { Timsort, demo }
/


export function flipArray (array, startIndex, endIndex) {
  while (startIndex < endIndex) {
        const temp = array[startIndex]
    array[startIndex] = array[endIndex]
    array[endIndex] = temp

        startIndex++
    endIndex--
  }

  return array
}


export function findMax (array, startIndex, endIndex) {
  let maxIndex = 0
  for (let i = startIndex; i <= endIndex; i++) {
    if (array[i] > array[maxIndex]) maxIndex = i
  }

  return maxIndex
}


export function pancakeSort (array) {
  for (let subarraySize = array.length; subarraySize > 1; subarraySize--) {
    const maximumIndex = findMax(array, 0, subarraySize - 1)

    if (maximumIndex !== subarraySize - 1) {
      flipArray(array, 0, maximumIndex)
      flipArray(array, 0, subarraySize - 1)
    }
  }

  return array
}
/
/
Array.prototype.heapify = function (index, heapSize) {
  let largest = index
  const leftIndex = 2 * index + 1
  const rightIndex = 2 * index + 2

  if (leftIndex < heapSize && this[leftIndex] > this[largest]) {
    largest = leftIndex
  }

  if (rightIndex < heapSize && this[rightIndex] > this[largest]) {
    largest = rightIndex
  }

  if (largest !== index) {
    const temp = this[largest]
    this[largest] = this[index]
    this[index] = temp

    this.heapify(largest, heapSize)
  }
}

/
export function heapSort (items) {
  const length = items.length

  for (let i = Math.floor(length / 2) - 1; i > -1; i--) {
    items.heapify(i, length)
  }
  for (let j = length - 1; j > 0; j--) {
    const tmp = items[0]
    items[0] = items[j]
    items[j] = tmp
    items.heapify(0, j)
  }
  return items
}



export function isSorted (array) {
  const length = array.length
  for (let i = 0; i < length - 1; i++) {
    if (array[i] > array[i + 1]) {
      return false
    }
  }
  return true
}


function shuffle (array) {
  for (let i = array.length - 1; i; i--) {
    const m = Math.floor(Math.random() * i)
    const n = array[i - 1]
    array[i - 1] = array[m]
    array[m] = n
  }
}


export function bogoSort (items) {
  while (!isSorted(items)) {
    shuffle(items)
  }
  return items
}
/
export function stoogeSort (items, leftEnd, rightEnd) {
  if (items[rightEnd - 1] < items[leftEnd]) {
    const temp = items[leftEnd]
    items[leftEnd] = items[rightEnd - 1]
    items[rightEnd - 1] = temp
  }
  const length = rightEnd - leftEnd
  if (length > 2) {
    const third = Math.floor(length / 3)
    stoogeSort(items, leftEnd, rightEnd - third)
    stoogeSort(items, leftEnd + third, rightEnd)
    stoogeSort(items, leftEnd, rightEnd - third)
  }
  return items
}
const CHAR_SIZE = 8


function pad (str, bits) {
  let res = str
  while (res.length % bits !== 0) {
    res = '0' + res
  }
  return res
}


function chunkify (str, size) {
  const chunks = []
  for (let i = 0; i < str.length; i += size) {
    chunks.push(str.slice(i, i + size))
  }
  return chunks
}


function rotateLeft (bits, turns) {
  return bits.substr(turns) + bits.substr(0, turns)
}


function preProcess (message) {
      let m = message.split('')
    .map(e => e.charCodeAt(0))
    .map(e => e.toString(2))
    .map(e => pad(e, 8))
    .join('') + '1'

    while (m.length % 512 !== 448) {
    m += '0'
  }

      let ml = (message.length * CHAR_SIZE).toString(2)
  ml = pad(ml, 8)
  ml = '0'.repeat(64 - ml.length) + ml

  return m + ml
}


function SHA1 (message) {
    let H0 = 0x67452301
  let H1 = 0xEFCDAB89
  let H2 = 0x98BADCFE
  let H3 = 0x10325476
  let H4 = 0xC3D2E1F0

    const bits = preProcess(message)
  const chunks = chunkify(bits, 512)

  chunks.forEach(function (chunk, i) {
        const words = chunkify(chunk, 32)

        for (let i = 16; i < 80; i++) {
      const val = [words[i - 3], words[i - 8], words[i - 14], words[i - 16]]
        .map(e => parseInt(e, 2))
        .reduce((acc, curr) => curr ^ acc, 0)
      const bin = (val >>> 0).toString(2)
      const paddedBin = pad(bin, 32)
      const word = rotateLeft(paddedBin, 1)
      words.push(word)
    }

        let [a, b, c, d, e] = [H0, H1, H2, H3, H4]

    for (let i = 0; i < 80; i++) {
      let f, k
      if (i < 20) {
        f = (b & c) | (~b & d)
        k = 0x5A827999
      } else if (i < 40) {
        f = b ^ c ^ d
        k = 0x6ED9EBA1
      } else if (i < 60) {
        f = (b & c) | (b & d) | (c & d)
        k = 0x8F1BBCDC
      } else {
        f = b ^ c ^ d
        k = 0xCA62C1D6
      }
            f >>>= 0

      const aRot = rotateLeft(pad(a.toString(2), 32), 5)
      const aInt = parseInt(aRot, 2) >>> 0
      const wordInt = parseInt(words[i], 2) >>> 0
      const t = aInt + f + e + k + wordInt
      e = d >>> 0
      d = c >>> 0
      const bRot = rotateLeft(pad(b.toString(2), 32), 30)
      c = parseInt(bRot, 2) >>> 0
      b = a >>> 0
      a = t >>> 0
    }

        H0 = (H0 + a) >>> 0
    H1 = (H1 + b) >>> 0
    H2 = (H2 + c) >>> 0
    H3 = (H3 + d) >>> 0
    H4 = (H4 + e) >>> 0
  })

    const HH = [H0, H1, H2, H3, H4]
    .map(e => e.toString(16))
    .map(e => pad(e, 8))
    .join('')

  return HH
}

export { SHA1 }

const CHAR_SIZE = 8

const K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]


function pad (str, bits) {
  let res = str
  while (res.length % bits !== 0) {
    res = '0' + res
  }
  return res
}


function chunkify (str, size) {
  const chunks = []
  for (let i = 0; i < str.length; i += size) {
    chunks.push(str.slice(i, i + size))
  }
  return chunks
}


function rotateRight (bits, turns) {
  return bits.substr(bits.length - turns) + bits.substr(0, bits.length - turns)
}


function preProcess (message) {
      let m = message.split('')
    .map(e => e.charCodeAt(0))
    .map(e => e.toString(2))
    .map(e => pad(e, 8))
    .join('') + '1'

    while (m.length % 512 !== 448) {
    m += '0'
  }

      let ml = (message.length * CHAR_SIZE).toString(2)
  ml = pad(ml, 8)
  ml = '0'.repeat(64 - ml.length) + ml

  return m + ml
}


function SHA256 (message) {
    let H0 = 0x6a09e667
  let H1 = 0xbb67ae85
  let H2 = 0x3c6ef372
  let H3 = 0xa54ff53a
  let H4 = 0x510e527f
  let H5 = 0x9b05688c
  let H6 = 0x1f83d9ab
  let H7 = 0x5be0cd19

    const bits = preProcess(message)
  const chunks = chunkify(bits, 512)

  chunks.forEach(function (chunk, i) {
        const words = chunkify(chunk, 32)

        for (let i = 16; i < 64; i++) {
      const W1 = words[i - 15]
      const W2 = words[i - 2]
      const R1 = rotateRight(W1, 7)
      const R2 = rotateRight(W1, 18)
      const R3 = rotateRight(W2, 17)
      const R4 = rotateRight(W2, 19)
      const S0 = parseInt(R1, 2) ^ parseInt(R2, 2) ^ (parseInt(W1, 2) >>> 3)
      const S1 = parseInt(R3, 2) ^ parseInt(R4, 2) ^ (parseInt(W2, 2) >>> 10)
      const val = parseInt(words[i - 16], 2) + S0 + parseInt(words[i - 7], 2) + S1
      words[i] = pad((val >>> 0).toString(2), 32)
    }

        let [a, b, c, d, e, f, g, h] = [H0, H1, H2, H3, H4, H5, H6, H7]

    for (let i = 0; i < 64; i++) {
      const S1 = [6, 11, 25]
        .map(turns => rotateRight(pad(e.toString(2), 32), turns))
        .map(bitstring => parseInt(bitstring, 2))
        .reduce((acc, curr) => acc ^ curr, 0) >>> 0
      const CH = ((e & f) ^ (~e & g)) >>> 0
      const temp1 = (h + S1 + CH + K[i] + parseInt(words[i], 2)) >>> 0
      const S0 = [2, 13, 22]
        .map(turns => rotateRight(pad(a.toString(2), 32), turns))
        .map(bitstring => parseInt(bitstring, 2))
        .reduce((acc, curr) => acc ^ curr, 0) >>> 0
      const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0
      const temp2 = (S0 + maj) >>> 0

      h = g
      g = f
      f = e
      e = (d + temp1) >>> 0
      d = c
      c = b
      b = a
      a = (temp1 + temp2) >>> 0
    }

        H0 = (H0 + a) >>> 0
    H1 = (H1 + b) >>> 0
    H2 = (H2 + c) >>> 0
    H3 = (H3 + d) >>> 0
    H4 = (H4 + e) >>> 0
    H5 = (H5 + f) >>> 0
    H6 = (H6 + g) >>> 0
    H7 = (H7 + h) >>> 0
  })

    const HH = [H0, H1, H2, H3, H4, H5, H6, H7]
    .map(e => e.toString(16))
    .map(e => pad(e, 8))
    .join('')

  return HH
}

export { SHA256 }

'use strict'


let utils;
(function (_utils) {
  function comparator () {
    return function (v1, v2) {
      if (v1 < v2) return -1
      if (v2 < v1) return 1
      return 0
    }
  }
  _utils.comparator = comparator
})(utils || (utils = {}))


const AVLTree = (function () {
  function _avl (comp) {
    /
    this._comp = undefined
    this._comp = comp !== undefined ? comp : utils.comparator()

    /
    this.root = null
    /
    this.size = 0
  }

    const Node = function (val) {
    this._val = val
    this._left = null
    this._right = null
    this._height = 1
  }

    const getHeight = function (node) {
    if (node == null) { return 0 }
    return node._height
  }

    const getHeightDifference = function (node) {
    return node == null ? 0 : getHeight(node._left) - getHeight(node._right)
  }

    const updateHeight = function (node) {
    if (node == null) { return }
    node._height = Math.max(getHeight(node._left), getHeight(node._right)) + 1
  }

    const isValidBalanceFactor = (balanceFactor) => [0, 1, -1].includes(balanceFactor)

    const leftRotate = function (node) {
    const temp = node._right
    node._right = temp._left
    temp._left = node
    updateHeight(node)
    updateHeight(temp)
    return temp
  }
  const rightRotate = function (node) {
    const temp = node._left
    node._left = temp._right
    temp._right = node
    updateHeight(node)
    updateHeight(temp)
    return temp
  }

    const insertBalance = function (node, _val, balanceFactor) {
    if (balanceFactor > 1 && _val < node._left._val) {
      return rightRotate(node)     }
    if (balanceFactor < 1 && _val > node._right._val) {
      return leftRotate(node)     }
    if (balanceFactor > 1 && _val > node._left._val) {
      node._left = leftRotate(node._left)       return rightRotate(node)
    }
    node._right = rightRotate(node._right)
    return leftRotate(node)
  }

    const delBalance = function (node) {
    const balanceFactor1 = getHeightDifference(node)
    if (isValidBalanceFactor(balanceFactor1)) {
      return node
    }
    if (balanceFactor1 > 1) {
      if (getHeightDifference(node._left) >= 0) {
        return rightRotate(node)       }
      node._left = leftRotate(node._left)
      return rightRotate(node)     }
    if (getHeightDifference(node._right) > 0) {
      node._right = rightRotate(node._right)
      return leftRotate(node)     }
    return leftRotate(node)   }

    const insert = function (root, val, tree) {
    if (root == null) {
      tree.size++
      return new Node(val)
    }
    if (tree._comp(root._val, val) < 0) {
      root._right = insert(root._right, val, tree)
    } else if (tree._comp(root._val, val) > 0) {
      root._left = insert(root._left, val, tree)
    } else {
      return root
    }
    updateHeight(root)
    const balanceFactor = getHeightDifference(root)
    return isValidBalanceFactor(balanceFactor) ? root : insertBalance(root, val, balanceFactor)
  }

    const deleteElement = function (root, _val, tree) {
    if (root == null) { return root }
    if (tree._comp(root._val, _val) === 0) {       if (root._left === null && root._right === null) {
        root = null
        tree.size--
      } else if (root._left === null) {
        root = root._right
        tree.size--
      } else if (root._right === null) {
        root = root._left
        tree.size--
      } else {
        let temp = root._right
        while (temp._left != null) {
          temp = temp._left
        }
        root._val = temp._val
        root._right = deleteElement(root._right, temp._val, tree)
      }
    } else {
      if (tree._comp(root._val, _val) < 0) {
        root._right = deleteElement(root._right, _val, tree)
      } else {
        root._left = deleteElement(root._left, _val, tree)
      }
    }
    updateHeight(root)
    root = delBalance(root)
    return root
  }
    const searchAVLTree = function (root, val, tree) {
    if (root == null) { return null }
    if (tree._comp(root._val, val) === 0) {
      return root
    }
    if (tree._comp(root._val, val) < 0) {
      return searchAVLTree(root._right, val, tree)
    }
    return searchAVLTree(root._left, val, tree)
  }

  /
  /
  _avl.prototype.add = function (_val) {
    const prevSize = this.size
    this.root = insert(this.root, _val, this)
    return this.size !== prevSize
  }
  /
  _avl.prototype.find = function (_val) {
    const temp = searchAVLTree(this.root, _val, this)
    return temp != null
  }
  /
  _avl.prototype.remove = function (_val) {
    const prevSize = this.size
    this.root = deleteElement(this.root, _val, this)
    return prevSize !== this.size
  }
  return _avl
}())



export { AVLTree }
/

const Node = (function Node () {
    function Node (val) {
    this.value = val
    this.left = null
    this.right = null
  }

    Node.prototype.search = function (val) {
    if (this.value === val) {
      return this
    } else if (val < this.value && this.left !== null) {
      return this.left.search(val)
    } else if (val > this.value && this.right !== null) {
      return this.right.search(val)
    }
    return null
  }

    Node.prototype.visit = function (output = value => console.log(value)) {
        if (this.left !== null) {
      this.left.visit()
    }
        output(this.value)
        if (this.right !== null) {
      this.right.visit()
    }
  }

    Node.prototype.addNode = function (n) {
    if (n.value < this.value) {
      if (this.left === null) {
        this.left = n
      } else {
        this.left.addNode(n)
      }
    } else if (n.value > this.value) {
      if (this.right === null) {
        this.right = n
      } else {
        this.right.addNode(n)
      }
    }
  }

    Node.prototype.removeNode = function (val) {
    if (val === this.value) {
      if (!this.left && !this.right) {
        return null
      } else {
        if (this.left) {
          const leftMax = maxVal(this.left)
          this.value = leftMax
          this.left = this.left.removeNode(leftMax)
        } else {
          const rightMin = minVal(this.right)
          this.value = rightMin
          this.right = this.right.removeNode(rightMin)
        }
      }
    } else if (val < this.value) {
      this.left = this.left && this.left.removeNode(val)
    } else if (val > this.value) {
      this.right = this.right && this.right.removeNode(val)
    }
    return this
  }

    const maxVal = function (node) {
    if (!node.right) {
      return node.value
    }
    return maxVal(node.right)
  }

    const minVal = function (node) {
    if (!node.left) {
      return node.value
    }
    return minVal(node.left)
  }
    return Node
}())

const Tree = (function () {
  function Tree () {
        this.root = null
  };

    Tree.prototype.traverse = function () {
    if (!this.root) {
            return
    }
    this.root.visit()
  }

    Tree.prototype.search = function (val) {
    const found = this.root.search(val)
    if (found !== null) {
      return found.value
    }
        return null
  }

    Tree.prototype.addValue = function (val) {
    const n = new Node(val)
    if (this.root === null) {
      this.root = n
    } else {
      this.root.addNode(n)
    }
  }

    Tree.prototype.removeValue = function (val) {
        this.root = this.root && this.root.removeNode(val)
  }

    return Tree
}())

export { Tree }
import { AVLTree } from '../AVLTree'

describe('AVLTree Implementation: ', () => {
  const avlTree = new AVLTree()
  const dataList = []
  const demoData = [1, 4, 6, 22, 7, 99, 4, 66, 77, 98]

  beforeAll(() => {
    demoData.forEach(item => {
      if (avlTree.add(item)) {
        dataList.push(item)
      }
    })
  })

  it('checks if element is inserted properly', () => {
    expect(dataList.length).toEqual(avlTree.size)
  })

  it('search if inserted element is present', () => {
    demoData.forEach(data => {
      expect(avlTree.find(data)).toBeTruthy()
    })
  })

  it('deletes the inserted element', () => {
    const deleteElement = dataList[3]
    expect(avlTree.remove(deleteElement)).toBeTruthy()
  })
})
const TrieNode = function TrieNode (key, parent) {
  this.key = key
  this.count = 0
  this.children = Object.create(null)
  if (parent === undefined) {
    this.parent = null
  } else {
    this.parent = parent
  }
}

function Trie () {
    this.root = new TrieNode(null, null)
}

Trie.findAllWords = function (root, word, output) {
  if (root === null) return
  if (root.count > 0) {
    if (typeof output === 'object') { output.push({ word, count: root.count }) }
  }
  let key
  for (key in root.children) {
    word += key
    this.findAllWords(root.children[key], word, output)
    word = word.slice(0, -1)
  }
}

Trie.prototype.insert = function (word) {
  if (typeof word !== 'string') return
  if (word === '') {
    this.root.count += 1
    return
  }
  let node = this.root
  const len = word.length
  let i
  for (i = 0; i < len; i++) {
    if (node.children[word.charAt(i)] === undefined) { node.children[word.charAt(i)] = new TrieNode(word.charAt(i), node) }
    node = node.children[word.charAt(i)]
  }
  node.count += 1
}

Trie.prototype.findPrefix = function (word) {
  if (typeof word !== 'string') return null
  let node = this.root
  const len = word.length
  let i
    for (i = 0; i < len; i++) {
    if (node.children[word.charAt(i)] === undefined) return null     node = node.children[word.charAt(i)]
  }
  return node
}

Trie.prototype.remove = function (word, count) {
  if (typeof word !== 'string') return
  if (typeof count !== 'number') count = 1
  else if (count <= 0) return

    if (word === '') {
    if (this.root.count >= count) this.root.count -= count
    else this.root.count = 0
    return
  }

  let child = this.root
  const len = word.length
  let i, key
    for (i = 0; i < len; i++) {
    key = word.charAt(i)
    if (child.children[key] === undefined) return
    child = child.children[key]
  }

    if (child.count >= count) child.count -= count
  else child.count = 0

          if (child.count <= 0 && (Object.keys(child.children).length && child.children.constructor === Object)) {
    child.parent.children[child.key] = undefined
  }
}

Trie.prototype.findAllWords = function (prefix) {
  const output = []
    const node = this.findPrefix(prefix)
    if (node === null) return output
  Trie.findAllWords(node, prefix, output)
  return output
}

Trie.prototype.contains = function (word) {
    const node = this.findPrefix(word)
    if (node === null || node.count === 0) return false
  return true
}

Trie.prototype.findOccurences = function (word) {
    const node = this.findPrefix(word)
    if (node === null) return 0
  return node.count
}

export { Trie }
import { DoubleLinkedList } from '../DoublyLinkedList'

describe('DoubleLinkedList', () => {
  it('Check append', () => {
    const list = new DoubleLinkedList()

    list.append(1)
    expect(list.getHead().element).toEqual(1)

    list.append(2)
    expect(list.getTail().element).toEqual(2)
  })

  it('Check insert', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 1)
    expect(list.getHead().element).toEqual(1)

    list.insert(1, 20)
    expect(list.getTail().element).toEqual(20)
  })

  it('Check removeAt', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 10)
    list.insert(1, 40)
    list.insert(2, 30)

    list.removeAt(0)
    expect(list.getHead().element).toEqual(40)

    list.removeAt(1)
    expect(list.getTail().element).toEqual(40)
  })

  it('Check delete', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 10)
    list.insert(1, 40)

    list.delete(10)
    expect(list.getHead().element).toEqual(40)
  })

  it('Check deleteTail', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 10)
    list.insert(1, 40)

    list.deleteTail()
    expect(list.getTail().element).toEqual(10)
  })

  it('Check toString', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 20)
    expect(list.toString()).toEqual('20')
  })

  it('Check isEmpty', () => {
    const list = new DoubleLinkedList()

    expect(list.isEmpty()).toEqual(true)

    list.insert(0, 'Hello')
    expect(list.isEmpty()).toEqual(false)
  })

  it('Check size', () => {
    const list = new DoubleLinkedList()
    expect(list.size()).toBe(0)

    list.append(10)
    expect(list.size()).toBe(1)

    list.removeAt(1)
    expect(list.size()).toBe(1)
  })

  it('Check toArray', () => {
    const list = new DoubleLinkedList()
    list.append(1)
    list.append(2)

    const listArray = list.toArray()
    expect(listArray).toEqual([1, 2])
  })

  it('Check getHead', () => {
    const list = new DoubleLinkedList()
    expect(list.getHead()).toEqual(null)

    list.append(1)
    list.append(2)
    expect(list.getHead()).toBeInstanceOf(Object)
  })

  it('Check Iterator', () => {
    const list = new DoubleLinkedList()

    let iterate = list.iterator()
    expect(iterate).toBe(-1)

    const arr = [10, 20, 5]
    list.append(arr[0])
    list.append(arr[1])
    list.append(arr[2])
    iterate = list.iterator()

    for (let i = 0; i < arr.length; i++) {
      expect(iterate.next().value).toBe(arr[i])
    }
    expect(iterate.next().value).toBe(undefined)

    iterate = list.iterator()
    let count = 0
    for (const item of iterate) {
      expect(item).toBe(arr[count])
      count++
    }
  })
})
import { SinglyCircularLinkedList } from '../SinglyCircularLinkedList'

describe('SinglyCircularLinkedList', () => {
  let list
  beforeEach(() => {
    list = new SinglyCircularLinkedList()
  })
  it('Check get', () => {
    expect(list.get()).toEqual([])
    expect(list.add(1)).toEqual(1)
    expect(list.get()).toEqual([1])
    expect(list.add(5)).toEqual(2)
    expect(list.get()).toEqual([1, 5])
  })

  it('Check size', () => {
    expect(list.size()).toEqual(0)
    expect(list.add(1)).toEqual(1)
    expect(list.add(1)).toEqual(2)
    expect(list.size()).toEqual(2)
  })

  it('Check head', () => {
    expect(list.head()).toEqual(null)
    expect(list.add(1)).toEqual(1)
    expect(list.head()).toEqual(1)
    expect(list.add(1)).toEqual(2)
    expect(list.head()).toEqual(1)
    expect(list.addAtFirst(100)).toEqual(3)
    expect(list.head()).toEqual(100)
    expect(list.insertAt(0, 500)).toEqual(4)
    expect(list.head()).toEqual(500)
    list.clear()
    expect(list.head()).toEqual(null)
  })

  it('Check isEmpty', () => {
    expect(list.isEmpty()).toEqual(true)
    expect(list.add(1)).toEqual(1)
    expect(list.add(1)).toEqual(2)
    expect(list.isEmpty()).toEqual(false)
  })

  it('Check getElementAt', () => {
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)

    expect(list.getElementAt(1).data).toEqual(200)
    expect(list.getElementAt(3).data).toEqual(500)
  })

  it('Check addAtFirst', () => {
    list.add(1)
    list.add(5)
    list.add(7)
    list.add(9)
    list.add(0)
    expect(list.get()).toEqual([1, 5, 7, 9, 0])
    list.addAtFirst(100)
    expect(list.get()).toEqual([100, 1, 5, 7, 9, 0])
  })

  it('Check add', () => {
    list.add(1)
    list.add(5)
    list.add(7)
    list.add(9)
    list.add(0)
    expect(list.get()).toEqual([1, 5, 7, 9, 0])
    list.add(100)
    expect(list.get()).toEqual([1, 5, 7, 9, 0, 100])
  })

  it('Check insertAt', () => {
    expect(list.insertAt(0, 100)).toEqual(1)
    expect(list.get()).toEqual([100])
    expect(list.insertAt(0, 200)).toEqual(2)
    expect(list.get()).toEqual([200, 100])
    expect(list.insertAt(2, 300)).toEqual(3)
    expect(list.get()).toEqual([200, 100, 300])
  })

  it('Checks indexOf', () => {
    expect(list.indexOf(200)).toEqual(-1)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.indexOf(200)).toEqual(1)
  })

  it('Check remove', () => {
    expect(list.remove()).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.remove()
    expect(removedData).toEqual(900)
    expect(list.get()).toEqual([100, 200, 300, 500])
  })

  it('Check removeFirst', () => {
    expect(list.removeFirst()).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.removeFirst()
    expect(removedData).toEqual(100)
    expect(list.get()).toEqual([200, 300, 500, 900])
  })

  it('Check removeAt', () => {
    expect(list.removeAt(1)).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.removeAt(2)
    expect(removedData).toEqual(300)
    expect(list.get()).toEqual([100, 200, 500, 900])
  })

  it('Check removeData', () => {
    expect(list.removeData(100)).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.removeData(200)
    expect(removedData).toEqual(200)
    expect(list.get()).toEqual([100, 300, 500, 900])
  })
})
import { AddTwoNumbers } from '../AddTwoNumbers.js'
import { LinkedList } from '../SinglyLinkedList'

describe('AddTwoNumbers', () => {
  it('Check Sum Of Two Linked List', () => {
    const list1 = new LinkedList()
    list1.addFirst(2)
    list1.addLast(4)
    list1.addLast(3)

    const list2 = new LinkedList()
    list2.addFirst(5)
    list2.addLast(6)
    list2.addLast(4)

    const expected = new LinkedList()
    expected.addFirst(7)
    expected.addLast(0)
    expected.addLast(8)

    const addTwoLinkedList = new AddTwoNumbers()
    addTwoLinkedList.solution(list1.headNode, list2.headNode)

    expect(addTwoLinkedList.solutionToArray()).toEqual(expected.get())
  })
})
import { LinkedList } from '../SinglyLinkedList'

describe('SinglyLinkedList', () => {
  it('Check addLast', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    expect(list.addLast(1)).toEqual(1)
    expect(list.get()).toEqual([1])

    expect(list.addLast(5)).toEqual(2)
    expect(list.get()).toEqual([1, 5])
  })

  it('Check addFirst', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    expect(list.addFirst(1)).toEqual(1)
    expect(list.get()).toEqual([1])

    expect(list.addFirst(5)).toEqual(2)
    expect(list.get()).toEqual([5, 1])
  })

  it('Check addAt', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    expect(list.addAt(0, 10)).toEqual(1)
    expect(list.get()).toEqual([10])

    expect(list.addAt(1, 20)).toEqual(2)
    expect(list.get()).toEqual([10, 20])

    expect(list.addAt(1, 30)).toEqual(3)
    expect(list.get()).toEqual([10, 30, 20])

    expect(list.addAt(3, 40)).toEqual(4)
    expect(list.get()).toEqual([10, 30, 20, 40])
  })

  it('Check removeLast', () => {
    const list = new LinkedList()
    list.addLast(1)
    list.addLast(2)
    expect(list.get()).toEqual([1, 2])

    expect(list.removeLast()).toEqual(2)
    expect(list.get()).toEqual([1])

    expect(list.removeLast()).toEqual(1)
    expect(list.get()).toEqual([])
  })

  it('Check removeFirst', () => {
    const list = new LinkedList()
    list.addLast(1)
    list.addLast(2)
    expect(list.get()).toEqual([1, 2])

    expect(list.removeFirst()).toEqual(1)
    expect(list.get()).toEqual([2])

    expect(list.removeFirst()).toEqual(2)
    expect(list.get()).toEqual([])
  })

  it('Check removeAt', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.get()).toEqual([10, 20, 30, 40, 50])

    expect(list.removeAt(0)).toEqual(10)
    expect(list.get()).toEqual([20, 30, 40, 50])

    expect(list.removeAt(3)).toEqual(50)
    expect(list.get()).toEqual([20, 30, 40])

    expect(list.removeAt(1)).toEqual(30)
    expect(list.get()).toEqual([20, 40])
  })

  it('Check remove', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    expect(list.get()).toEqual([10, 20, 30])

    expect(list.remove(10)).toEqual(10)
    expect(list.get()).toEqual([20, 30])

    expect(list.remove(100)).toEqual(null)
    expect(list.get()).toEqual([20, 30])
  })

  it('Check indexOf', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.indexOf(10)).toBe(0)
    expect(list.indexOf(30)).toBe(2)
    expect(list.indexOf(50)).toBe(4)
    expect(list.indexOf(70)).toBe(-1)
  })

  it('Check elementAt', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.elementAt(0)).toBe(10)
    expect(list.elementAt(1)).toBe(20)
    expect(list.elementAt(3)).toBe(40)
    expect(list.elementAt(4)).toBe(50)
  })

  it('Check isEmpty', () => {
    const list = new LinkedList()
    expect(list.isEmpty()).toBe(true)
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.isEmpty()).toBe(false)
  })

  it('Check head', () => {
    const list = new LinkedList()
    expect(list.head()).toBe(null)

    list.addLast(10)
    expect(list.head()).toBe(10)

    list.addLast(20)
    expect(list.head()).toBe(10)

    list.addFirst(30)
    expect(list.head()).toBe(30)
  })

  it('Check size', () => {
    const list = new LinkedList()
    expect(list.size()).toBe(0)

    list.addLast(10)
    expect(list.size()).toBe(1)

    list.addLast(20)
    expect(list.size()).toBe(2)

    list.removeFirst()
    expect(list.size()).toBe(1)
  })

  it('Check Iterator', () => {
    const list = new LinkedList()

    let iterate = list.iterator()
    expect(iterate).toBe(-1)

    const arr = [10, 20, 5]
    list.addLast(arr[0])
    list.addLast(arr[1])
    list.addLast(arr[2])
    iterate = list.iterator()

    for (let i = 0; i < arr.length; i++) {
      expect(iterate.next().value).toBe(arr[i])
    }
    expect(iterate.next().value).toBe(undefined)

    iterate = list.iterator()
    let count = 0
    for (const item of iterate) {
      expect(item).toBe(arr[count])
      count++
    }
  })
  it('Cleans the linkedList', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.size()).toEqual(5)
    list.clean()
    expect(list.isEmpty()).toBe(true)
  })
})
import { Node } from './SinglyLinkedList.js'

class SinglyCircularLinkedList {
  constructor () {
    this.headNode = null
    this.length = 0
  }

    size = () => this.length
    head = () => this.headNode?.data || null
    isEmpty = () => this.length === 0

    initiateNodeAndIndex () {
    return { currentNode: this.headNode, currentIndex: 0 }
  }

    getElementAt (index) {
    if (this.length !== 0 && index >= 0 && index <= this.length) {
      let { currentNode } = this.initiateNodeAndIndex()
      for (let i = 0; i < index && currentNode !== null; i++) {
        currentNode = currentNode.next
      }
      return currentNode
    }
    return undefined
  }

    addAtFirst (data) {
    const node = new Node(data)
    node.next = this.headNode
    this.headNode = node
    this.length++
    return this.length
  }

    add (data) {
    if (!this.headNode) { return this.addAtFirst(data) }
    const node = new Node(data)
        const currentNode = this.getElementAt(this.length - 1)
    currentNode.next = node
    node.next = this.headNode
    this.length++
    return this.length
  }

    insertAt (index, data) {
    if (index === 0) return this.addAtFirst(data)
    if (index === this.length) return this.add(data)
    if (index < 0 || index > this.length) throw new RangeError(`Index is out of range max ${this.length}`)
    const node = new Node(data)
    const previousNode = this.getElementAt(index - 1)
    node.next = previousNode.next
    previousNode.next = node
    this.length++
    return this.length
  }

    indexOf (data) {
    let { currentNode } = this.initiateNodeAndIndex()
        let currentIndex = -1
    while (currentNode) {
      if (currentNode.data === data) {
        return currentIndex + 1
      }
      currentIndex++
      currentNode = currentNode.next
    }
    return -1
  }

    remove () {
    if (this.isEmpty()) return null
    const secondLastNode = this.getElementAt(this.length - 2)
    const removedNode = secondLastNode.next
    secondLastNode.next = this.headNode
    this.length--
    return removedNode.data || null
  }

    removeFirst () {
    if (this.isEmpty()) return null
    const removedNode = this.headNode
    if (this.length === 1) {
      this.clear()
      return removedNode.data
    }
    const lastNode = this.getElementAt(this.length - 1)
    this.headNode = this.headNode.next
    lastNode.next = this.headNode
    this.length--
    return removedNode.data || null
  }

    removeAt (index) {
    if (this.isEmpty()) return null
    if (index === 0) return this.removeFirst()
    if (index === this.length) return this.remove()
    if (index < 0 && index > this.length) return null
    const previousNode = this.getElementAt(index - 1)
    const currentNode = previousNode.next
    previousNode.next = currentNode.next
    this.length--
    return currentNode.data || null
  }

    removeData (data) {
    if (this.isEmpty()) return null
    const index = this.indexOf(data)
    return this.removeAt(index)
  }

    printData (output = value => console.log(value)) {
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()

    while (currentNode !== null && currentIndex < this.length) {
      output(currentNode.data)
      currentNode = currentNode.next
      currentIndex++
    }
  }

    get () {
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    const list = []
    while (currentNode !== null && currentIndex < this.length) {
      list.push(currentNode.data)
      currentNode = currentNode.next
      currentIndex++
    }
    return list
  }

  clear () {
    this.headNode = null
    this.length = 0
  }
}

export { SinglyCircularLinkedList }

import { Node } from './SinglyLinkedList.js'

/

class AddTwoNumbers {
  constructor () {
    this.dummyNode = new Node(0)
  }

  solution (firstList, secondList) {
    let firstRunner = firstList
    let secondRunner = secondList
    let tail = this.dummyNode
    let carry = 0
    while (firstRunner != null || secondRunner != null) {
      const firstNumber = firstRunner ? firstRunner.data : 0
      const secondNumber = secondRunner ? secondRunner.data : 0
      const sum = carry + firstNumber + secondNumber
      carry = parseInt(sum / 10)
      tail.next = new Node(sum % 10)
      tail = tail.next
      if (firstRunner) {
        firstRunner = firstRunner.next
      }
      if (secondRunner) {
        secondRunner = secondRunner.next
      }
    }
    if (carry > 0) {
      tail.next = new Node(carry % 10)
    }

    return this.dummyNode.next
  }

  solutionToArray () {
    const list = []
    let currentNode = this.dummyNode.next
    while (currentNode) {
      list.push(currentNode.data)
      currentNode = currentNode.next
    }

    return list
  }
}

export { AddTwoNumbers }


function main () {
  /
  const head = ''   let fast = head
  let slow = head

  while (fast != null && fast.next != null && slow != null) {
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) {
      return true
    }
  }
  return false
}

main()
class Node {
  constructor (element) {
    this.element = element
    this.next = null
    this.prev = null
  }
}

class DoubleLinkedList {
  constructor () {
    this.length = 0
    this.head = null
    this.tail = null
  }

    append (element) {
    const node = new Node(element)

    if (!this.head) {
      this.head = node
      this.tail = node
    } else {
      node.prev = this.tail
      this.tail.next = node
      this.tail = node
    }

    this.length++
  }

    insert (position, element) {
        if (position >= 0 && position <= this.length) {
      const node = new Node(element)
      let current = this.head
      let previous = 0
      let index = 0

      if (position === 0) {
        if (!this.head) {
          this.head = node
          this.tail = node
        } else {
          node.next = current
          current.prev = node
          this.head = node
        }
      } else if (position === this.length) {
        current = this.tail
        current.next = node
        node.prev = current
        this.tail = node
      } else {
        while (index++ < position) {
          previous = current
          current = current.next
        }

        node.next = current
        previous.next = node

                current.prev = node
        node.prev = previous
      }

      this.length++
      return true
    } else {
      return false
    }
  }

    removeAt (position) {
        if (position > -1 && position < this.length) {
      let current = this.head
      let previous = 0
      let index = 0

            if (position === 0) {
        this.head = current.next

                if (this.length === 1) {
          this.tail = null
        } else {
          this.head.prev = null
        }
      } else if (position === this.length - 1) {
        current = this.tail
        this.tail = current.prev
        this.tail.next = null
      } else {
        while (index++ < position) {
          previous = current
          current = current.next
        }

                previous.next = current.next
        current.next.prev = previous
      }

      this.length--
      return current.element
    } else {
      return null
    }
  }

    indexOf (elm) {
    let current = this.head
    let index = -1

        while (current) {
      if (elm === current.element) {
        return ++index
      }

      index++
      current = current.next
    }

        return -1
  }

    isPresent (elm) {
    return this.indexOf(elm) !== -1
  }

    delete (elm) {
    return this.removeAt(this.indexOf(elm))
  }

    deleteHead () {
    this.removeAt(0)
  }

    deleteTail () {
    this.removeAt(this.length - 1)
  }

    toString () {
    let current = this.head
    let string = ''

    while (current) {
      string += current.element + (current.next ? '\n' : '')
      current = current.next
    }

    return string
  }

    toArray () {
    const arr = []
    let current = this.head

    while (current) {
      arr.push(current.element)
      current = current.next
    }

    return arr
  }

    isEmpty () {
    return this.length === 0
  }

    size () {
    return this.length
  }

    getHead () {
    return this.head
  }

    getTail () {
    return this.tail
  }

    iterator () {
    let currentNode = this.getHead()
    if (currentNode === null) return -1

    const iterate = function * () {
      while (currentNode) {
        yield currentNode.element
        currentNode = currentNode.next
      }
    }
    return iterate()
  }

      log () {
    let currentNode = this.getHead()
    while (currentNode) {
      console.log(currentNode.element)
      currentNode = currentNode.next
    }
  }
}



export { DoubleLinkedList }


function main () {
  /
    let head = ''
  let k = ''
  let i = 0
  let current = head
  while (current) {
    i++
    current = current.next
  }
  k %= i
  current = head
  let prev = null
  while (k--) {
    if (!current || !current.next) {
      return current
    } else {
      while (current.next) {
        prev = current
        current = current.next
      }
      prev.next = current.next
      current.next = head
      head = current
    }
  }
  return head
}

main()
/


class Node {
  constructor (data) {
    this.data = data
    this.next = null
  }
}

class LinkedList {
  constructor () {
    this.headNode = null
    this.length = 0
  }

    initiateNodeAndIndex () {
    return { currentNode: this.headNode, currentIndex: 0 }
  }

    size () {
    return this.length
  }

    head () {
    return this.headNode?.data || null
  }

    isEmpty () {
    return this.length === 0
  }

    addLast (element) {
        if (this.headNode === null) {
      return this.addFirst(element)
    }
    let { currentNode } = this.initiateNodeAndIndex()

        while (currentNode.next) {
      currentNode = currentNode.next
    }

    const node = new Node(element)
        currentNode.next = node
    this.length++
    return this.size()
  }

    addFirst (element) {
    const node = new Node(element)
    node.next = this.headNode
    this.headNode = node
    this.length++
    return this.size()
  }

    removeFirst () {
    const removedNode = this.headNode
    if (this.length > 0) {
      this.headNode = this.headNode.next
      this.length--
    }
    console.log(removedNode.data)
    return removedNode?.data
  }

    removeLast () {
    if (this.isEmpty()) return null
    if (this.length === 1) {
      return this.removeFirst()
    }
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    while (currentIndex !== this.length - 2) {
      currentIndex++
      currentNode = currentNode.next
    }
    const removedNode = currentNode.next
    currentNode.next = null
    this.length--
    return removedNode.data
  }

    remove (element) {
    if (this.isEmpty()) return null
    let { currentNode } = this.initiateNodeAndIndex()
    let removedNode = null
        if (currentNode.data === element) {
      return this.removeFirst()
    }
        while (currentNode?.next) {
      if (currentNode.next.data === element) {
        removedNode = currentNode.next
        currentNode.next = currentNode.next.next
        this.length--
        break
      }
      currentNode = currentNode.next
    }
    return removedNode?.data || null
  }

    indexOf (element) {
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()

    while (currentNode) {
            if (currentNode.data === element) {
        return currentIndex
      }
      currentNode = currentNode.next
      currentIndex++
    }
    return -1
  }

    elementAt (index) {
    if (index >= this.length || index < 0) {
      throw new RangeError('Out of Range index')
    }
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    while (currentIndex < index) {
      currentIndex++
      currentNode = currentNode.next
    }
    return currentNode.data
  }

    addAt (index, element) {
        if (index > this.length || index < 0) {
      throw new RangeError('Out of Range index')
    }
    if (index === 0) return this.addFirst(element)
    if (index === this.length) return this.addLast(element)
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    const node = new Node(element)

    while (currentIndex !== index - 1) {
      currentIndex++
      currentNode = currentNode.next
    }

        const tempNode = currentNode.next
    currentNode.next = node
    node.next = tempNode
        this.length++
    return this.size()
  }

    removeAt (index) {
        if (index < 0 || index >= this.length) {
      throw new RangeError('Out of Range index')
    }
    if (index === 0) return this.removeFirst()
    if (index === this.length) return this.removeLast()

    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    while (currentIndex !== index - 1) {
      currentIndex++
      currentNode = currentNode.next
    }
    const removedNode = currentNode.next
    currentNode.next = currentNode.next.next
        this.length--
    return removedNode.data
  }

    clean () {
    this.headNode = null
    this.length = 0
  }

    get () {
    const list = []
    let { currentNode } = this.initiateNodeAndIndex()
    while (currentNode) {
      list.push(currentNode.data)
      currentNode = currentNode.next
    }

    return list
  }

    iterator () {
    let { currentNode } = this.initiateNodeAndIndex()
    if (currentNode === null) return -1

    const iterate = function * () {
      while (currentNode) {
        yield currentNode.data
        currentNode = currentNode.next
      }
    }
    return iterate()
  }

    log () {
    console.log(JSON.stringify(this.headNode, null, 2))
  }
}

export { Node, LinkedList }
import { QuickSelect } from '../QuickSelect'

describe('QuickSelect tests', () => {
  it('should return the only element of a list of length 1', () => {
        expect(QuickSelect([100], 1)).toEqual(100)
    expect(QuickSelect([-23], 1)).toEqual(-23)
    expect(QuickSelect([2007.102], 1)).toEqual(2007.102)
    expect(QuickSelect([0.9], 1)).toEqual(0.9)
    expect(QuickSelect([-0.075], 1)).toEqual(-0.075)
    expect(QuickSelect([0], 1)).toEqual(0)
    expect(QuickSelect([1], 1)).toEqual(1)
  })

  it('should throw an Error when k is greater than the length of the list', () => {
    expect(() => QuickSelect([100, 2], 5)).toThrow('Index Out of Bound')
  })

  it('should throw an Error when k is less than 1', () => {
    expect(() => QuickSelect([100, 2], 0)).toThrow('Index Out of Bound')
    expect(() => QuickSelect([100, 2], -1)).toThrow('Index Out of Bound')
  })

  describe('varieties of list composition', () => {
    it('should return the kth smallest element of a list that is in increasing order', () => {
      expect(QuickSelect([10, 22, 33, 44, 55], 1)).toEqual(10)
      expect(QuickSelect([10, 22, 33, 44, 55], 2)).toEqual(22)
      expect(QuickSelect([10, 22, 33, 44, 55], 3)).toEqual(33)
      expect(QuickSelect([10, 22, 33, 44, 55], 4)).toEqual(44)
      expect(QuickSelect([10, 22, 33, 44, 55], 5)).toEqual(55)
    })

    it('should return the kth smallest element of an input list that is in decreasing order', () => {
      expect(QuickSelect([82, 33.12, 4.0, 1], 1)).toEqual(1)
      expect(QuickSelect([82, 33.12, 4.0, 1], 2)).toEqual(4.0)
      expect(QuickSelect([82, 33.12, 4.0, 1], 2)).toEqual(4)
      expect(QuickSelect([82, 33.12, 4.0, 1], 3)).toEqual(33.12)
      expect(QuickSelect([82, 33.12, 4.0, 1], 4)).toEqual(82)
    })

    it('should return the kth smallest element of an input list that is no particular order', () => {
      expect(QuickSelect([123, 14231, -10, 0, 15], 3)).toEqual(15)
      expect(QuickSelect([0, 15, 123, 14231, -10], 3)).toEqual(15)
      expect(QuickSelect([-10, 15, 123, 14231, 0], 3)).toEqual(15)
      expect(QuickSelect([14231, 0, 15, 123, -10], 3)).toEqual(15)
      expect(QuickSelect([14231, 0, 15, -10, 123], 3)).toEqual(15)
    })
  })
})
import { LocalMaximomPoint } from '../LocalMaximomPoint'

describe('LocalMaximumPoint tests', () => {
  it('test boundary maximum points - last element', () => {
    const Array = [1, 2, 3, 4, 5, 6, 12]
    expect(LocalMaximomPoint(Array)).toEqual(6)
  })

  it('test boundary maximum points - first element', () => {
    const Array2 = [13, 6, 5, 4, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(0)
  })

  it('test boundary maximum points - should find first maximom point from the top', () => {
        const Array = [13, 2, 3, 4, 5, 6, 12]
    expect(LocalMaximomPoint(Array)).toEqual(6)
  })

  it('test inner points - second element', () => {
    const Array2 = [13, 16, 5, 4, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(1)
  })

  it('test inner points - element some where in the middle', () => {
    const Array2 = [13, 16, 5, 41, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(3)
  })
})
import { NumberOfLocalMaximumPoints } from '../NumberOfLocalMaximumPoints'

describe('LocalMaximomPoint tests', () => {
  it('test boundary maximum points - last element', () => {
    const Array = [1, 2, 3, 4, 5, 6, 12]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(1)
  })

  it('test boundary maximum points - first element', () => {
    const Array = [13, 6, 5, 4, 3, 2, 1]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(1)
  })

  it('test boundary maximum points - both boundaries have maximum points', () => {
        const Array = [13, 2, 3, 4, 5, 6, 12]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(2)
  })

  it('multiple maximum points in the middle', () => {
        const Array = [1, 3, 2, 5, 6, 9, 2, 7, 12, 1, 0]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(3)
  })

  it('multiple maximum points in the middle with one at end', () => {
        const Array = [1, 3, 2, 5, 6, 9, 2, 7, 12, 1, 10]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(4)
  })

  it('multiple maximum points in the middle with one at start', () => {
        const Array = [10, 3, 2, 5, 6, 9, 2, 7, 12, 1, 0]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(3)
  })

  it('multiple maximum points in the middle with two more at both ends', () => {
        const Array = [10, 3, 11, 5, 6, 9, 2, 7, 12, 1, 10]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(5)
  })
})

const findMaxPointIndex = (array, rangeStartIndex, rangeEndIndex, originalLength) => {
    const middleIndex = rangeStartIndex + parseInt((rangeEndIndex - rangeStartIndex) / 2)

    if ((middleIndex === 0 || array[middleIndex - 1] <= array[middleIndex]) &&
        (middleIndex === originalLength - 1 || array[middleIndex + 1] <= array[middleIndex])) {
    return middleIndex
  } else if (middleIndex > 0 && array[middleIndex - 1] > array[middleIndex]) {
    return findMaxPointIndex(array, rangeStartIndex, (middleIndex - 1), originalLength)
  } else {
        return findMaxPointIndex(array, (middleIndex + 1), rangeEndIndex, originalLength)
  }
}

const LocalMaximomPoint = (A) => findMaxPointIndex(A, 0, A.length - 1, A.length)

export { LocalMaximomPoint }


const IsMaximumPoint = (array, index) => {
      if (index === 0) {
    return array[index] > array[index + 1]
      } else if (index === array.length - 1) {
    return array[index] > array[index - 1]
      } else {
    return array[index] > array[index + 1] && array[index] > array[index - 1]
  }
}

const CountLocalMaximumPoints = (array, startIndex, endIndex) => {
    if (startIndex === endIndex) {
    return IsMaximumPoint(array, startIndex) ? 1 : 0
  }

    const middleIndex = parseInt((startIndex + endIndex) / 2)
  return CountLocalMaximumPoints(array, startIndex, middleIndex) +
    CountLocalMaximumPoints(array, middleIndex + 1, endIndex)
}

const NumberOfLocalMaximumPoints = (A) => CountLocalMaximumPoints(A, 0, A.length - 1)

export { NumberOfLocalMaximumPoints }


function QuickSelect (items, kth) {   if (kth < 1 || kth > items.length) {
    throw new RangeError('Index Out of Bound')
  }

  return RandomizedSelect(items, 0, items.length - 1, kth)
}

function RandomizedSelect (items, left, right, i) {
  if (left === right) return items[left]

  const pivotIndex = RandomizedPartition(items, left, right)
  const k = pivotIndex - left + 1

  if (i === k) return items[pivotIndex]
  if (i < k) return RandomizedSelect(items, left, pivotIndex - 1, i)

  return RandomizedSelect(items, pivotIndex + 1, right, i - k)
}

function RandomizedPartition (items, left, right) {
  const rand = getRandomInt(left, right)
  Swap(items, rand, right)
  return Partition(items, left, right)
}

function Partition (items, left, right) {
  const x = items[right]
  let pivotIndex = left - 1

  for (let j = left; j < right; j++) {
    if (items[j] <= x) {
      pivotIndex++
      Swap(items, pivotIndex, j)
    }
  }

  Swap(items, pivotIndex + 1, right)

  return pivotIndex + 1
}

function getRandomInt (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

function Swap (arr, x, y) {
  [arr[x], arr[y]] = [arr[y], arr[x]]
}

export { QuickSelect }
class Graph {
  constructor () {
    this.adjacencyMap = {}
  }

  addVertex (vertex) {
    this.adjacencyMap[vertex] = []
  }

  containsVertex (vertex) {
    return typeof (this.adjacencyMap[vertex]) !== 'undefined'
  }

  addEdge (vertex1, vertex2) {
    if (this.containsVertex(vertex1) && this.containsVertex(vertex2)) {
      this.adjacencyMap[vertex1].push(vertex2)
      this.adjacencyMap[vertex2].push(vertex1)
    }
  }

  printGraph (output = value => console.log(value)) {
    const keys = Object.keys(this.adjacencyMap)
    for (const i of keys) {
      const values = this.adjacencyMap[i]
      let vertex = ''
      for (const j of values) {
        vertex += j + ' '
      }
      output(i + ' -> ' + vertex)
    }
  }

  /
  bfs (source, output = value => console.log(value)) {
    const queue = [[source, 0]]     const visited = new Set()

    while (queue.length) {
      const [node, level] = queue.shift()       if (visited.has(node)) {         continue
      }

      visited.add(node)
      output(`Visited node ${node} at level ${level}.`)
      for (const next of this.adjacencyMap[node]) {
        queue.push([next, level + 1])       }
    }
  }

  /
  dfs (source, visited = new Set(), output = value => console.log(value)) {
    if (visited.has(source)) {       return
    }

    output(`Visited node ${source}`)
    visited.add(source)
    for (const neighbour of this.adjacencyMap[source]) {
      this.dfs(neighbour, visited, output)
    }
  }
}

const example = () => {
  const g = new Graph()
  g.addVertex(1)
  g.addVertex(2)
  g.addVertex(3)
  g.addVertex(4)
  g.addVertex(5)
  g.addEdge(1, 2)
  g.addEdge(1, 3)
  g.addEdge(2, 4)
  g.addEdge(2, 5)

            
    
    g.bfs(1)

    g.dfs(1)
}

export { Graph, example }
import { Graph } from '../Graph2'

describe('Test Graph2', () => {
  const vertices = ['A', 'B', 'C', 'D', 'E', 'F']
  const graph = new Graph(vertices.length)

    for (let i = 0; i < vertices.length; i++) {
    graph.addVertex(vertices[i])
  }

    graph.addEdge('A', 'B')
  graph.addEdge('A', 'D')
  graph.addEdge('A', 'E')
  graph.addEdge('B', 'C')
  graph.addEdge('D', 'E')
  graph.addEdge('E', 'F')
  graph.addEdge('E', 'C')
  graph.addEdge('C', 'F')

  it('Check adjacency lists', () => {
    const mockFn = jest.fn()
    graph.printGraph(mockFn)

        expect(mockFn.mock.calls.length).toBe(vertices.length)

        const adjListArr = mockFn.mock.calls.map(v => v[0])

    expect(adjListArr).toEqual([
      'A -> B D E ',
      'B -> A C ',
      'C -> B E F ',
      'D -> A E ',
      'E -> A D F C ',
      'F -> E C '
    ])
  })
})
import { Graph } from '../Graph3'

describe('Test Graph3', () => {
  const g = new Graph()

    g.addVertex('A')
  g.addVertex('B')
  g.addVertex('C')
  g.addVertex('D')
  g.addVertex('E')
  g.addVertex('F')

    g.addEdge('A', 'B')
  g.addEdge('A', 'C')
  g.addEdge('B', 'D')
  g.addEdge('C', 'E')
  g.addEdge('D', 'E')
  g.addEdge('D', 'F')
  g.addEdge('E', 'F')

  /
  it('Check iterative DFS List', () => {
    const iterativeDFSList = g.DFSIterative('A')
    expect(iterativeDFSList).toEqual(['A', 'C', 'E', 'F', 'D', 'B'])
  })

  it('Check recursive DFS List', () => {
    const recursiveDFSList = g.DFS('A')
    expect(recursiveDFSList).toEqual(['A', 'B', 'D', 'E', 'C', 'F'])
  })

  it('Check BFS List', () => {
    const BFSList = g.BFS('A')
    expect(BFSList).toEqual(['A', 'B', 'C', 'D', 'E', 'F'])
  })

  /

  it('Check iterative DFS List After Removing Vertex B', () => {
    g.removeVertex('B')
    const iterativeDFSList = g.DFSIterative('A')
    expect(iterativeDFSList).toEqual(['A', 'C', 'E', 'F', 'D'])
  })

  it('Check recursive DFS List After Removing Vertex B', () => {
    g.removeVertex('B')
    const recursiveDFSList = g.DFS('A')
    expect(recursiveDFSList).toEqual(['A', 'C', 'E', 'D', 'F'])
  })

  it('Check BFS List After Removing Vertex B', () => {
    g.removeVertex('B')
    const BFSList = g.BFS('A')
    expect(BFSList).toEqual(['A', 'C', 'E', 'D', 'F'])
  })
})
class Graph {
      constructor (noOfVertices) {
    this.noOfVertices = noOfVertices
    this.AdjList = new Map()
  }

  
      
    
    addVertex (v) {
        
    this.AdjList.set(v, [])
  }

    addEdge (v, w) {
            this.AdjList.get(v).push(w)

            this.AdjList.get(w).push(v)
  }

    printGraph (output = value => console.log(value)) {
        const getKeys = this.AdjList.keys()

        for (const i of getKeys) {
                  const getValues = this.AdjList.get(i)
      let conc = ''

                  for (const j of getValues) {
        conc += j + ' '
      }

            output(i + ' -> ' + conc)
    }
  }
}

export { Graph }
class Graph {
  constructor () {
    this.adjacencyObject = {}
  }

  addVertex (vertex) {
    if (!this.adjacencyObject[vertex]) this.adjacencyObject[vertex] = []
  }

  addEdge (vertex1, vertex2) {
    this.adjacencyObject[vertex1].push(vertex2)
    this.adjacencyObject[vertex2].push(vertex1)
  }

  removeEdge (vertex1, vertex2) {
    this.adjacencyObject[vertex1] = this.adjacencyObject[vertex1].filter(
      (v) => v !== vertex2
    )
    this.adjacencyObject[vertex2] = this.adjacencyObject[vertex2].filter(
      (v) => v !== vertex1
    )
  }

  removeVertex (vertex) {
    while (this.adjacencyObject[vertex].length) {
      const adjacentVertex = this.adjacencyObject[vertex].pop()
      this.removeEdge(vertex, adjacentVertex)
    }
  }

  /
  DFS (start) {
    if (!start) return null

    const result = []
    const visited = {}
    const adjacencyObject = this.adjacencyObject

    function dfs (vertex) {
      if (!vertex) return null
      visited[vertex] = true
      result.push(vertex)
      adjacencyObject[vertex].forEach((neighbor) => {
        if (!visited[neighbor]) {
          dfs(neighbor)
        }
      })
    }

    dfs(start)
    return result
  }

  /
  DFSIterative (start) {
    if (!start) return null

    const stack = [start]
    const visited = {}
    visited[start] = true

    const result = []
    let currentVertex

    while (stack.length) {
      currentVertex = stack.pop()
      result.push(currentVertex)

      this.adjacencyObject[currentVertex].forEach((neighbor) => {
        if (!visited[neighbor]) {
          visited[neighbor] = true
          stack.push(neighbor)
        }
      })
    }
    return result
  }

  BFS (start) {
    if (!start) return null

    const queue = [start]
    const visited = {}
    visited[start] = true

    let currentVertex
    const result = []

    while (queue.length) {
      currentVertex = queue.shift()
      result.push(currentVertex)

      this.adjacencyObject[currentVertex].forEach((neighbor) => {
        if (!visited[neighbor]) {
          visited[neighbor] = true
          queue.push(neighbor)
        }
      })
    }
    return result
  }
}

export { Graph }


class Vector2 {
  constructor (x, y) {
    this.x = x
    this.y = y
  }

  /
  equalsExactly (vector) {
    return this.x === vector.x && this.y === vector.y
  }

  /
  equalsApproximately (vector, epsilon) {
    return (Math.abs(this.x - vector.x) < epsilon && Math.abs(this.y - vector.y) < epsilon)
  }

  /
  length () {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }

  /
  normalize () {
    const length = this.length()
    if (length === 0) {
      throw new Error('Cannot normalize vectors of length 0')
    }
    return new Vector2(this.x / length, this.y / length)
  }

  /
  add (vector) {
    const x = this.x + vector.x
    const y = this.y + vector.y
    return new Vector2(x, y)
  }

  /
  subtract (vector) {
    const x = this.x - vector.x
    const y = this.y - vector.y
    return new Vector2(x, y)
  }

  /
  multiply (scalar) {
    const x = this.x * scalar
    const y = this.y * scalar
    return new Vector2(x, y)
  }

  /
  distance (vector) {
    const difference = vector.subtract(this)
    return difference.length()
  }

  /
  dotProduct (vector) {
    return this.x * vector.x + this.y * vector.y
  }

  /
  rotate (angleInRadians) {
    const ca = Math.cos(angleInRadians)
    const sa = Math.sin(angleInRadians)
    const x = ca * this.x - sa * this.y
    const y = sa * this.x + ca * this.y
    return new Vector2(x, y)
  }

  /
  angleBetween (vector) {
    return Math.atan2(vector.y, vector.x) - Math.atan2(this.y, this.x)
  }
}

export { Vector2 }
import { Vector2 } from '../Vector2.js'

describe('Vector2', () => {
  describe('#equalsExactly', () => {
    it('should compare equality correctly', () => {
      expect(new Vector2(1, 0).equalsExactly(new Vector2(1, 0))).toBe(true)

      expect(new Vector2(1.23, 4.56).equalsExactly(new Vector2(0, 0))).toBe(false)
    })
  })

  describe('#equalsApproximately', () => {
    it('should compare equality (approximately) correctly', () => {
      expect(new Vector2(1, 0).equalsApproximately(new Vector2(1, 0.0000001), 0.000001))
        .toBe(true)

      expect(new Vector2(1.23, 4.56).equalsApproximately(new Vector2(1.24, 4.56), 0.000001))
        .toBe(false)
    })
  })

  describe('#add', () => {
    it('should add two vectors correctly', () => {
      expect(new Vector2(1, 0).add(new Vector2(0, 1)).equalsApproximately(new Vector2(1, 1), 0.000001))
        .toBe(true)

      expect(new Vector2(-3.3, -9).add(new Vector2(-2.2, 3)).equalsApproximately(new Vector2(-5.5, -6), 0.000001))
        .toBe(true)
    })
  })

  describe('#subtract', () => {
    it('should subtract two vectors correctly', () => {
      expect(new Vector2(1, 0).subtract(new Vector2(0, 1)).equalsApproximately(new Vector2(1, -1), 0.000001))
        .toBe(true)

      expect(new Vector2(234.5, 1.7).subtract(new Vector2(3.3, 2.7)).equalsApproximately(new Vector2(231.2, -1), 0.000001))
        .toBe(true)
    })
  })

  describe('#multiply', () => {
    it('should multiply two vectors correctly', () => {
      expect(new Vector2(1, 0).multiply(5).equalsApproximately(new Vector2(5, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(3.41, -7.12).multiply(-3.1).equalsApproximately(new Vector2(-10.571, 22.072), 0.000001))
        .toBe(true)
    })
  })

  describe('#length', () => {
    it('should calculate it\'s length correctly', () => {
      expect(new Vector2(1, 0).length()).toBe(1)

      expect(new Vector2(-1, 1).length()).toBe(Math.sqrt(2))
    })
  })

  describe('#normalize', () => {
    it('should normalize vectors correctly', () => {
      expect(new Vector2(1, 0).normalize().equalsApproximately(new Vector2(1, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(1, -1).normalize().equalsApproximately(new Vector2(Math.sqrt(2) / 2, -Math.sqrt(2) / 2), 0.000001))
        .toBe(true)
    })
  })

  describe('#distance', () => {
    it('should calculate the distance between two vectors correctly', () => {
      expect(new Vector2(0, 0).distance(new Vector2(0, -1))).toBe(1)

      expect(new Vector2(1, 0).distance(new Vector2(0, 1))).toBe(Math.sqrt(2))
    })
  })

  describe('#dotProduct', () => {
    it('should calculate the dot product correctly', () => {
      expect(new Vector2(1, 0).dotProduct(new Vector2(0, 1))).toBe(0)

      expect(new Vector2(1, 2).dotProduct(new Vector2(3, 4))).toBe(11)     })
  })

  describe('#rotate', () => {
    it('should rotate a vector correctly', () => {
      expect(new Vector2(0, -1).rotate(Math.PI / 2).equalsApproximately(new Vector2(1, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(1.23, -4.56).rotate(Math.PI).equalsApproximately(new Vector2(-1.23, 4.56), 0.000001))
        .toBe(true)
    })
  })

  describe('#angleBetween', () => {
    it('should calculate the angle between two vectors correctly', () => {
      expect(new Vector2(1, 0).angleBetween(new Vector2(0, 1))).toBe(Math.PI / 2)

      expect(new Vector2(1, 0).angleBetween(new Vector2(1, -1))).toBe(-Math.PI / 4)
    })
  })
})


class MinHeap {
  constructor (array) {
    this.heap = this.initializeHeap(array)
  }

  /
  initializeHeap (array) {
    const startingParent = Math.floor((array.length - 2) / 2)

    for (let currIdx = startingParent; currIdx >= 0; currIdx--) {
      this.sinkDown(currIdx, array.length - 1, array)
    }
    return array
  }

  /
  sinkDown (currIdx, endIdx, heap) {
    let childOneIdx = currIdx * 2 + 1

    while (childOneIdx <= endIdx) {
      const childTwoIdx = childOneIdx + 1 <= endIdx ? childOneIdx + 1 : -1
      const swapIdx = childTwoIdx !== -1 && heap[childTwoIdx] < heap[childOneIdx]
        ? childTwoIdx
        : childOneIdx

      if (heap[swapIdx] < heap[currIdx]) {
        this.swap(currIdx, swapIdx, heap)
        currIdx = swapIdx
        childOneIdx = currIdx * 2 + 1
      } else {
        return
      }
    }
  }

  /
  bubbleUp (currIdx) {
    let parentIdx = Math.floor((currIdx - 1) / 2)

    while (currIdx > 0 && this.heap[currIdx] < this.heap[parentIdx]) {
      this.swap(currIdx, parentIdx, this.heap)
      currIdx = parentIdx
      parentIdx = Math.floor((currIdx - 1) / 2)
    }
  }

  peek () {
    return this.heap[0]
  }

  /
  extractMin () {
    this.swap(0, this.heap.length - 1, this.heap)
    const min = this.heap.pop()
    this.sinkDown(0, this.heap.length - 1, this.heap)
    return min
  }

    insert (value) {
    this.heap.push(value)
    this.bubbleUp(this.heap.length - 1)
  }

    swap (idx1, idx2, heap) {
    const temp = heap[idx1]
    heap[idx1] = heap[idx2]
    heap[idx2] = temp
  }
}

export { MinHeap }
import { MinHeap } from '../MinHeap'

describe('MinHeap', () => {
  const array = [2, 4, 10, 23, 43, 42, 39, 7, 9, 16, 85, 1, 51]
  let heap

  beforeEach(() => {
    heap = new MinHeap(array)
  })

  it('should initialize a heap from an input array', () => {
    expect(heap).toEqual({ 'heap': [1, 4, 2, 7, 16, 10, 39, 23, 9, 43, 85, 42, 51] })     })

  it('should show the top value in the heap', () => {
    const minValue = heap.peek()

    expect(minValue).toEqual(1)
  })

  it('should remove and return the top value in the heap', () => {
    const minValue = heap.extractMin()

    expect(minValue).toEqual(1)
    expect(heap).toEqual({ 'heap': [2, 4, 10, 7, 16, 42, 39, 23, 9, 43, 85, 51] })        })

  it('should insert a new value and sort until it meets heap conditions', () => {
    heap.insert(15)

    expect(heap).toEqual({ 'heap': [2, 4, 10, 7, 16, 15, 39, 23, 9, 43, 85, 51, 42] })    })
})
import { MinPriorityQueue } from '../MinPriorityQueue'

describe('MinPriorityQueue', () => {
  const values = [5, 2, 4, 1, 7, 6, 3, 8]
  const capacity = values.length
  let queue

  beforeEach(() => {
    queue = new MinPriorityQueue(capacity)
    values.forEach(v => queue.insert(v))
  })

  it('Check heap ordering', () => {
    const mockFn = jest.fn()
    queue.print(mockFn)

    expect(mockFn.mock.calls.length).toBe(1)     expect(mockFn.mock.calls[0].length).toBe(1) 
    const heap = mockFn.mock.calls[0][0]
    expect(heap.length).toBe(capacity)
    expect(heap).toStrictEqual([1, 2, 3, 5, 7, 6, 4, 8])
  })

  it('heapSort() expected to reverse the heap ordering', () => {
    queue.heapReverse()
    const mockFn = jest.fn()
    queue.print(mockFn)

    expect(mockFn.mock.calls.length).toBe(1)
    expect(mockFn.mock.calls[0].length).toBe(1)

    const heap = mockFn.mock.calls[0][0]
    expect(heap.length).toBe(capacity)
    expect(heap).toStrictEqual([8, 7, 6, 5, 4, 3, 2, 1])
  })

  describe('delete() function work properly', () => {
    it('return undefined if heap is empty', () => {
      const minqueue = new MinPriorityQueue(capacity)
      const min = minqueue.delete()
      expect(min).toBe(undefined)
    })
    it('return min value and remove it', () => {
      const sortedValues = values.sort()
      let initialSize = queue.size
      sortedValues.forEach((minValue, index) => {
        const min = queue.delete()
        expect(min).toBe(minValue)
        expect(queue.size).toBe(--initialSize)
      })
      expect(queue.size).toBe(0)
    })
  })
})


class BinaryHeap {
  constructor () {
    this.heap = []
  }

  insert (value) {
    this.heap.push(value)
    this.heapify()
  }

  size () {
    return this.heap.length
  }

  empty () {
    return this.size() === 0
  }

    heapify () {
    let index = this.size() - 1

    while (index > 0) {
      const element = this.heap[index]
      const parentIndex = Math.floor((index - 1) / 2)
      const parent = this.heap[parentIndex]

      if (parent[0] >= element[0]) break
      this.heap[index] = parent
      this.heap[parentIndex] = element
      index = parentIndex
    }
  }

    extractMax () {
    const max = this.heap[0]
    const tmp = this.heap.pop()
    if (!this.empty()) {
      this.heap[0] = tmp
      this.sinkDown(0)
    }
    return max
  }

    sinkDown (index) {
    const left = 2 * index + 1
    const right = 2 * index + 2
    let largest = index
    const length = this.size()

    if (left < length && this.heap[left][0] > this.heap[largest][0]) {
      largest = left
    }
    if (right < length && this.heap[right][0] > this.heap[largest][0]) {
      largest = right
    }
        if (largest !== index) {
      const tmp = this.heap[largest]
      this.heap[largest] = this.heap[index]
      this.heap[index] = tmp
      this.sinkDown(largest)
    }
  }
}



export { BinaryHeap }

/


class MinPriorityQueue {
    constructor (c) {
    this.heap = []
    this.capacity = c
    this.size = 0
  }

      insert (key) {
    if (this.isFull()) return
    this.heap[this.size + 1] = key
    let k = this.size + 1
    while (k > 1) {
      if (this.heap[k] < this.heap[Math.floor(k / 2)]) {
        const temp = this.heap[k]
        this.heap[k] = this.heap[Math.floor(k / 2)]
        this.heap[Math.floor(k / 2)] = temp
      }
      k = Math.floor(k / 2)
    }
    this.size++
  }

    peek () {
    return this.heap[1]
  }

    isEmpty () {
    return this.size === 0
  }

    isFull () {
    if (this.size === this.capacity) return true
    return false
  }

    print (output = value => console.log(value)) {
    output(this.heap.slice(1))
  }

        heapReverse () {
    const heapSort = []
    while (this.size > 0) {
            [this.heap[1], this.heap[this.size]] = [this.heap[this.size], this.heap[1]]
      heapSort.push(this.heap.pop())
      this.size--
      this.sink()
    }
            this.heap = [undefined, ...heapSort.reverse()]
    this.size = heapSort.length
  }

    sink () {
    let k = 1
    while (2 * k <= this.size || 2 * k + 1 <= this.size) {
      let minIndex
      if (this.heap[2 * k] >= this.heap[k]) {
        if (2 * k + 1 <= this.size && this.heap[2 * k + 1] >= this.heap[k]) {
          break
        } else if (2 * k + 1 > this.size) {
          break
        }
      }
      if (2 * k + 1 > this.size) {
        minIndex = this.heap[2 * k] < this.heap[k] ? 2 * k : k
      } else {
        if (
          this.heap[k] > this.heap[2 * k] ||
          this.heap[k] > this.heap[2 * k + 1]
        ) {
          minIndex =
            this.heap[2 * k] < this.heap[2 * k + 1] ? 2 * k : 2 * k + 1
        } else {
          minIndex = k
        }
      }
      const temp = this.heap[k]
      this.heap[k] = this.heap[minIndex]
      this.heap[minIndex] = temp
      k = minIndex
    }
  }

      delete () {
        if (this.isEmpty()) return
    if (this.size === 1) {
      this.size--
      return this.heap.pop()
    }
    const min = this.heap[1]
    this.heap[1] = this.heap.pop()
    this.size--
    this.sink()
    return min
  }
}

export { MinPriorityQueue }

class Queue {
  constructor () {
    this.inputStack = []
    this.outputStack = []
  }

    enqueue (item) {
    this.inputStack.push(item)
  }

  dequeue () {
        this.outputStack = []
    while (this.inputStack.length > 0) {
      this.outputStack.push(this.inputStack.pop())
    }
        if (this.outputStack.length > 0) {
      const top = this.outputStack.pop()
            this.inputStack = []
      while (this.outputStack.length > 0) {
        this.inputStack.push(this.outputStack.pop())
      }
      return top
    }
  }

    listIn (output = value => console.log(value)) {
    let i = 0
    while (i < this.inputStack.length) {
      output(this.inputStack[i])
      i++
    }
  }

    listOut (output = value => console.log(value)) {
    let i = 0
    while (i < this.outputStack.length) {
      output(this.outputStack[i])
      i++
    }
  }
}

export { Queue }
import { Queue } from '../QueueUsing2Stacks'

describe('QueueUsing2Stacks', () => {
  const queue = new Queue()

  it('Check enqueue/dequeue', () => {
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(8)
    queue.enqueue(9)

    expect(queue.dequeue()).toBe(1)
    expect(queue.dequeue()).toBe(2)
  })
})
import Queue from '../Queue'

describe('Testing the Queue DS', () => {
  const queue = new Queue()

  it('Testing enqueue method', () => {
    expect(queue.enqueue(1)).toBe(1)
    expect(queue.enqueue(2)).toBe(2)
    expect(queue.enqueue(8)).toBe(3)
    expect(queue.enqueue(9)).toBe(4)
  })

  it('Testing length after enqueue', () => {
    expect(queue.length).toBe(4)
  })

  it('Testing peekFirst & peekLast methods', () => {
    expect(queue.peekFirst()).toBe(1)
    expect(queue.peekLast()).toBe(9)
  })

  it('Testing toArray method', () => {
    expect(queue.toArray()).toEqual([1, 2, 8, 9])
  })

  it('Testing dequeue method', () => {
    expect(queue.dequeue()).toBe(1)
    expect(queue.dequeue()).toBe(2)
  })

  it('Testing length after dequeue', () => {
    expect(queue.length).toBe(2)
  })

  it('Testing isEmpty method', () => {
    const queue = new Queue()
    expect(queue.isEmpty()).toBeTruthy()

    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(8)
    queue.enqueue(9)

    expect(queue.isEmpty()).toBeFalsy()
  })
})
/

class Queue {
  #size

  constructor () {
    this.head = null
    this.tail = null
    this.#size = 0

    return Object.seal(this)
  }

  get length () {
    return this.#size
  }

  /
  enqueue (data) {
    const node = { data, next: null }

    if (!this.head && !this.tail) {
      this.head = node
      this.tail = node
    } else {
      this.tail.next = node
      this.tail = node
    }

    return ++this.#size
  }

  /
  dequeue () {
    if (this.isEmpty()) {
      throw new Error('Queue is Empty')
    }

    const firstData = this.peekFirst()

    this.head = this.head.next

    if (!this.head) {
      this.tail = null
    }

    this.#size--

    return firstData
  }

  /
  peekFirst () {
    if (this.isEmpty()) {
      throw new Error('Queue is Empty')
    }

    return this.head.data
  }

  /
  peekLast () {
    if (this.isEmpty()) {
      throw new Error('Queue is Empty')
    }

    return this.tail.data
  }

  /
  toArray () {
    const array = []
    let node = this.head

    while (node) {
      array.push(node.data)
      node = node.next
    }

    return array
  }

  /
  isEmpty () {
    return this.length === 0
  }
}

export default Queue

class CircularQueue {
  constructor (maxLength) {
    this.queue = []
    this.front = 0
    this.rear = 0
    this.maxLength = maxLength
  }

    enqueue (value) {
    if (this.checkOverflow()) return
    if (this.checkEmpty()) {
      this.front += 1
      this.rear += 1
    } else {
      if (this.rear === this.maxLength) {
        this.rear = 1
      } else this.rear += 1
    }
    this.queue[this.rear] = value
  }

    dequeue () {
    if (this.checkEmpty()) {
            return
    }
    const y = this.queue[this.front]
    this.queue[this.front] = '*'
    if (!this.checkSingleelement()) {
      if (this.front === this.maxLength) this.front = 1
      else {
        this.front += 1
      }
    }

    return y   }

    checkEmpty () {
    if (this.front === 0 && this.rear === 0) {
      return true
    }
  }

  checkSingleelement () {
    if (this.front === this.rear && this.rear !== 0) {
      this.front = this.rear = 0
      return true
    }
  }

    checkOverflow () {
    if ((this.front === 1 && this.rear === this.maxLength) || (this.front === this.rear + 1)) {
            return true
    }
  }

    display (output = value => console.log(value)) {
    for (let index = 1; index < this.queue.length; index++) {
      output(this.queue[index])
    }
  }

    length () {
    return this.queue.length - 1
  }

    peek () {
    return this.queue[this.front]
  }
}

export { CircularQueue }
/

class Stack {
  constructor () {
    this.stack = []
    this.top = 0
  }

    push (newValue) {
    this.stack.push(newValue)
    this.top += 1
  }

    pop () {
    if (this.top !== 0) {
      this.top -= 1
      return this.stack.pop()
    }
    throw new Error('Stack Underflow')
  }

    get length () {
    return this.top
  }

    get isEmpty () {
    return this.top === 0
  }

    get last () {
    if (this.top !== 0) {
      return this.stack[this.stack.length - 1]
    }
    return null
  }

    static isStack (el) {
    return el instanceof Stack
  }
}

export { Stack }
/


const Stack = (function () {
  function Stack () {
        this.top = 0
        this.stack = []
  }

    Stack.prototype.push = function (value) {
    this.stack[this.top] = value
    this.top++
  }

    Stack.prototype.pop = function () {
    if (this.top === 0) {
      return 'Stack is Empty'
    }

    this.top--
    const result = this.stack[this.top]
    this.stack = this.stack.splice(0, this.top)
    return result
  }

    Stack.prototype.size = function () {
    return this.top
  }

    Stack.prototype.peek = function () {
    return this.stack[this.top - 1]
  }

    Stack.prototype.view = function (output = value => console.log(value)) {
    for (let i = 0; i < this.top; i++) {
      output(this.stack[i])
    }
  }

  return Stack
}())

export { Stack }
import { FenwickTree } from '../FenwickTree'

describe('Fenwick Tree Implementation', () => {
  const fenwickArray = new Array(1000)
  const array = [3, 2, 0, 6, 5, -1, 2]
  const length = array.length

  const fenwickTree = new FenwickTree(fenwickArray, array, length)

  it('Fenwick Tree - Prefix sum of array', () => {
    const prefixSum = fenwickTree.getPrefixSum(fenwickArray, 6)
    expect(prefixSum).toBe(23)
  })

  array[2] += 6
  fenwickTree.update(fenwickArray, length, 2, 6)

  it('Fenwick Tree - Prefix sum of Updated array', () => {
    const prefixSum = fenwickTree.getPrefixSum(fenwickArray, 6)
    expect(prefixSum).toBe(23)
  })
})
import { BinaryTree, Node } from '../BreadthFirstTreeTraversal'

describe('Breadth First Tree Traversal', () => {
  const binaryTree = new BinaryTree()

  const root = new Node(7)
  root.left = new Node(5)
  root.right = new Node(8)
  root.left.left = new Node(3)
  root.left.right = new Node(6)
  root.right.right = new Node(9)
  binaryTree.root = root

              
  it('Binary tree - Level order traversal', () => {
    expect(binaryTree.traversal).toStrictEqual([])
    const traversal = binaryTree.breadthFirst()
    expect(traversal).toStrictEqual([7, 5, 8, 3, 6, 9])
  })
})
/

class Node {
  constructor (data) {
    this.data = data
    this.left = null
    this.right = null
  }
}

class BinaryTree {
  constructor () {
    this.root = null
    this.traversal = []
  }

  breadthFirst () {
    const h = this.getHeight(this.root)
    for (let i = 0; i !== h; i++) {
      this.traverseLevel(this.root, i)
    }
    return this.traversal
  }

    getHeight (node) {
    if (node === null) {
      return 0
    }
    const lheight = this.getHeight(node.left)
    const rheight = this.getHeight(node.right)
    return lheight > rheight ? lheight + 1 : rheight + 1
  }

  traverseLevel (node, levelRemaining) {
    if (node === null) {
      return
    }
    if (levelRemaining === 0) {
      this.traversal.push(node.data)
    } else {
      this.traverseLevel(node.left, levelRemaining - 1)
      this.traverseLevel(node.right, levelRemaining - 1)
    }
  }
}

export { BinaryTree, Node }
/

class FenwickTree {
  constructor (feneickArray, array, n) {
    for (let i = 1; i <= n; i++) {
      feneickArray[i] = 0
    }
    for (let i = 0; i < n; i++) {
      this.update(feneickArray, n, i, array[i])
    }
  }

  update (feneickArray, n, index, value) {
    index = index + 1
    while (index <= n) {
      feneickArray[index] += value
      index += index & (-index)
    }
  }

  getPrefixSum (feneickArray, index) {
    let currSum = 0
    index = index + 1
    while (index > 0) {
      currSum += feneickArray[index]
      index -= index & (-index)
    }

    return currSum
  }
}
export { FenwickTree }
/

function traverseDFS (root) {
  const stack = [root]
  const res = []

  while (stack.length) {
    const curr = stack.pop()
    res.push(curr.key)

    if (curr.right) {
      stack.push(curr.right)
    }

    if (curr.left) {
      stack.push(curr.left)
    }
  }

  return res.reverse()
}

function searchDFS (tree, value) {
  const stack = []

  stack.push(tree[0])

  while (stack.length !== 0) {
    for (let i = 0; i < stack.length; i++) {
      const node = stack.pop()

      if (node.value === value) {
        return node
      }
      if (node.right) {
        stack.push(tree[node.right])
      }
      if (node.left) {
        stack.push(tree[node.left])
      }
    }
  }
  return null
}

const tree = [
  { value: 6, left: 1, right: 2 },
  { value: 5, left: 3, right: 4 },
  { value: 7, left: null, right: 5 },
  { value: 3, left: 6, right: null },
  { value: 4, left: null, right: null },
  { value: 9, left: 7, right: 8 },
  { value: 2, left: 9, right: null },
  { value: 8, left: null, right: null },
  { value: 10, left: null, right: null },
  { value: 1, left: null, right: null }
]

searchDFS(tree, 9)
searchDFS(tree, 10)

traverseDFS(6)

import { memoize } from '../Memoize'
import { union } from './cacheTest'
import { fibonacci } from '../../Dynamic-Programming/FibonacciNumber'
import { factorial } from '../../Recursive/Factorial'
import LFUCache from '../LFUCache'

const multipleFactorials = (arr) => arr.map(factorial)

describe('Testing Memoize', () => {
  it('expects the fibonacci function to use the cache on the second call', () => {
    const memoFibonacci = memoize(fibonacci)

    expect(memoFibonacci(5)).toEqual(fibonacci(5))
    expect(memoFibonacci(5)).toEqual(5)
    expect(memoFibonacci(10)).toEqual(fibonacci(10))
    expect(memoFibonacci(10)).toEqual(55)
  })

  it('expects the factorial function to use the cache on the second call', () => {
    const memoFactorial = memoize(factorial)

    expect(memoFactorial(5)).toEqual(factorial(5))
    expect(memoFactorial(5)).toEqual(120)
    expect(memoFactorial(10)).toEqual(factorial(10))
    expect(memoFactorial(10)).toEqual(3628800)
  })

  it('expects the multipleFactorials function to use the cache on the second call', () => {
    const memoMultipleFactorials = memoize(multipleFactorials)
    const input = [2, 3, 4, 5]

    expect(memoMultipleFactorials(input)).toEqual([2, 6, 24, 120])
    expect(memoMultipleFactorials(input)).toEqual(multipleFactorials(input))
  })

  it('expects the multipleFactorials function to use the cache on the second call', () => {
    const memoMultipleFactorials = memoize(multipleFactorials)
    const input = [2, 3, 4, 5]

    expect(memoMultipleFactorials(input)).toEqual([2, 6, 24, 120])
    expect(memoMultipleFactorials(input)).toEqual(multipleFactorials(input))
  })

  it('expects the union function to use the cache on the second call', () => {
    const memoUnion = memoize(union)
    const inputs = [
      new Set([1, 2, 3]),
      new Set([4, 3, 2]),
      new Set([5, 3, 6])
    ]

    expect(memoUnion(...inputs)).toEqual(new Set([1, 2, 3, 4, 5, 6]))
    expect(memoUnion(...inputs)).toEqual(union(...inputs))
  })

  it('Testing with explicit cache -> LFUCache', () => {
    const LFU = new LFUCache(2)

    const memoizeFibonacci = memoize(fibonacci, LFU)     const fibOfFiveHundred = memoizeFibonacci(500)
    const fibOfOneHundred = memoizeFibonacci(100)

    expect(memoizeFibonacci(500)).toBe(fibOfFiveHundred)
    expect(memoizeFibonacci(100)).toBe(fibOfOneHundred)

    expect(LFU.leastFrequency).toBe(2)
  })
})
import LFUCache from '../LFUCache'
import { fibonacciCache } from './cacheTest'

describe('Testing LFUCache class', () => {
  it('Example 1 (Small Cache, size = 2)', () => {
    const cache = new LFUCache(1) 
    cache.capacity = 2 
    expect(cache.capacity).toBe(2)

    cache.set(1, 1)     cache.set(2, 2) 
    expect(cache.get(1)).toBe(1)     expect(cache.get(2)).toBe(2) 
        cache.set(3, 3) 
    expect(cache.get(1)).toBe(null)     expect(cache.get(2)).toBe(2)     expect(cache.get(3)).toBe(3) 
    cache.set(4, 4)     expect(cache.get(1)).toBe(null)     expect(cache.get(2)).toBe(2)     expect(cache.get(3)).toBe(null)     expect(cache.get(4)).toBe(4) 
    expect(cache.info).toEqual({
      misses: 3,
      hits: 6,
      capacity: 2,
      currentSize: 2,
      leastFrequency: 2
    })

    const json = '{"misses":3,"hits":6,"cache":{"2":{"key":"2","value":2,"frequency":4},"4":{"key":"4","value":4,"frequency":2}}}'
    expect(cache.toString()).toBe(json)

    const cacheInstance = cache.parse(json) 
    expect(cacheInstance).toBe(cache) 
    cache.capacity = 1 
    expect(cache.info).toEqual({       misses: 6,
      hits: 12,
      capacity: 1,
      currentSize: 1,
      leastFrequency: 5
    })

    const clearedCache = cache.clear()     expect(clearedCache.size).toBe(0)
  })

  it('Example 2 (Computing Fibonacci Series, size = 100)', () => {
    const cache = new LFUCache(100)

    for (let i = 1; i <= 100; i++) {
      fibonacciCache(i, cache)
    }

    expect(cache.info).toEqual({
      misses: 103,
      hits: 193,
      capacity: 100,
      currentSize: 98,
      leastFrequency: 1
    })
  })
})
import LRUCache from '../LRUCache'
import { fibonacciCache } from './cacheTest'

describe('Testing LRUCache', () => {
  it('Testing with invalid capacity', () => {
    expect(() => new LRUCache()).toThrow()
    expect(() => new LRUCache('Invalid')).toThrow()
    expect(() => new LRUCache(-1)).toThrow()
    expect(() => new LRUCache(Infinity)).toThrow()
  })

  it('Example 1 (Small Cache, size = 2)', () => {
    const cache = new LRUCache(1) 
    cache.capacity++ 
    cache.set(1, 1)
    cache.set(2, 2)

    expect(cache.get(1)).toBe(1)
    expect(cache.get(2)).toBe(2)

        cache.set(3, 3)

        expect(cache.get(1)).toBe(null)
    expect(cache.get(2)).toBe(2)
    expect(cache.get(3)).toBe(3)

    cache.set(4, 4)
    expect(cache.get(1)).toBe(null)     expect(cache.get(2)).toBe(null)     expect(cache.get(3)).toBe(3)
    expect(cache.get(4)).toBe(4)

    expect(cache.info).toEqual({
      misses: 3,
      hits: 6,
      capacity: 2,
      size: 2
    })

    const json = '{"misses":3,"hits":6,"cache":{"3":3,"4":4}}'
    expect(cache.toString()).toBe(json)

        cache.parse(json)

    cache.capacity-- 
    expect(cache.info).toEqual({
      misses: 6,
      hits: 12,
      capacity: 1,
      size: 1
    })
  })

  it('Example 2 (Computing Fibonacci Series, size = 100)', () => {
    const cache = new LRUCache(100)

    for (let i = 1; i <= 100; i++) {
      fibonacciCache(i, cache)
    }

    expect(cache.info).toEqual({
      misses: 103,
      hits: 193,
      capacity: 100,
      size: 98
    })
  })
})

export const fibonacciCache = (n, cache = null) => {
  if (cache) {
    const value = cache.get(n)

    if (value !== null) {
      return value
    }
  }

  if (n === 1 || n === 2) {
    return 1
  }

  const result = fibonacciCache(n - 1, cache) + fibonacciCache(n - 2, cache)

  cache && cache.set(n, result)

  return result
}


export const union = (...sets) => {
  return new Set(
    sets.reduce((flatArray, set) => [...flatArray, ...set], [])
  )
}

const memoize = (func, cache = new Map()) => {
  const jsonReplacer = (_, value) => {
    if (value instanceof Set) {       return [...value]
    }

    if (value instanceof Map) {       return Object.fromEntries(value)
    }

    return value
  }

  return (...args) => {
    /
    const argsKey = JSON.stringify(args, jsonReplacer)

    /
    if (cache.has(argsKey)) {
      return cache.get(argsKey)
    }

    /
    const result = func(...args)     cache.set(argsKey, result)

    return result
  }
}

export { memoize }
class LRUCache {
    #capacity

  /
  constructor (capacity) {
    if (!Number.isInteger(capacity) || capacity < 0) {
      throw new TypeError('Invalid capacity')
    }

    this.#capacity = ~~capacity
    this.misses = 0
    this.hits = 0
    this.cache = new Map()

    return Object.seal(this)
  }

  get info () {
    return Object.freeze({
      misses: this.misses,
      hits: this.hits,
      capacity: this.capacity,
      size: this.size
    })
  }

  get size () {
    return this.cache.size
  }

  get capacity () {
    return this.#capacity
  }

  set capacity (newCapacity) {
    if (newCapacity < 0) {
      throw new RangeError('Capacity should be greater than 0')
    }

    if (newCapacity < this.capacity) {
      let diff = this.capacity - newCapacity

      while (diff--) {
        this.#removeLeastRecentlyUsed()
      }
    }

    this.#capacity = newCapacity
  }

  /
  #removeLeastRecentlyUsed () {
    this.cache.delete(this.cache.keys().next().value)
  }

  /
  has (key) {
    key = String(key)

    return this.cache.has(key)
  }

  /
  set (key, value) {
    key = String(key)
        if (this.size === this.capacity) {
      this.#removeLeastRecentlyUsed()
    }

    this.cache.set(key, value)
  }

  /
  get (key) {
    key = String(key)
        if (this.cache.has(key)) {
      const value = this.cache.get(key)

            this.cache.delete(key)
      this.cache.set(key, value)

      this.hits++
      return value
    }

    this.misses++
    return null
  }

  /
  parse (json) {
    const { misses, hits, cache } = JSON.parse(json)

    this.misses += misses ?? 0
    this.hits += hits ?? 0

    for (const key in cache) {
      this.set(key, cache[key])
    }

    return this
  }

  /
  toString (indent) {
    const replacer = (_, value) => {
      if (value instanceof Set) {
        return [...value]
      }

      if (value instanceof Map) {
        return Object.fromEntries(value)
      }

      return value
    }

    return JSON.stringify(this, replacer, indent)
  }
}

export default LRUCache
class CacheNode {
  constructor (key, value, frequency) {
    this.key = key
    this.value = value
    this.frequency = frequency

    return Object.seal(this)
  }
}

class FrequencyMap extends Map {
  static get [Symbol.species] () { return Map }   get [Symbol.toStringTag] () { return '' }

  /
  refresh (node) {
    const { frequency } = node
    const freqSet = this.get(frequency)
    freqSet.delete(node)

    node.frequency++

    this.insert(node)
  }

  /
  insert (node) {
    const { frequency } = node

    if (!this.has(frequency)) {
      this.set(frequency, new Set())
    }

    this.get(frequency).add(node)
  }
}

class LFUCache {
    #capacity
    #frequencyMap

    /
    constructor (capacity) {
      this.#capacity = capacity
      this.#frequencyMap = new FrequencyMap()
      this.misses = 0
      this.hits = 0
      this.cache = new Map()

      return Object.seal(this)
    }

    /
    get capacity () {
      return this.#capacity
    }

    /
    get size () {
      return this.cache.size
    }

    /
    set capacity (newCapacity) {
      if (this.#capacity > newCapacity) {
        let diff = this.#capacity - newCapacity 
        while (diff--) {
          this.#removeCacheNode()
        }

        this.cache.size === 0 && this.#frequencyMap.clear()
      }

      this.#capacity = newCapacity
    }

    get info () {
      return Object.freeze({
        misses: this.misses,
        hits: this.hits,
        capacity: this.capacity,
        currentSize: this.size,
        leastFrequency: this.leastFrequency
      })
    }

    get leastFrequency () {
      const freqCacheIterator = this.#frequencyMap.keys()
      let leastFrequency = freqCacheIterator.next().value || null

            while (this.#frequencyMap.get(leastFrequency)?.size === 0) {
        leastFrequency = freqCacheIterator.next().value
      }

      return leastFrequency
    }

    #removeCacheNode () {
      const leastFreqSet = this.#frequencyMap.get(this.leastFrequency)
            const LFUNode = leastFreqSet.values().next().value

      leastFreqSet.delete(LFUNode)
      this.cache.delete(LFUNode.key)
    }

    /
    has (key) {
      key = String(key) 
      return this.cache.has(key)
    }

    /
    get (key) {
      key = String(key) 
      if (this.cache.has(key)) {
        const oldNode = this.cache.get(key)
        this.#frequencyMap.refresh(oldNode)

        this.hits++

        return oldNode.value
      }

      this.misses++
      return null
    }

    /
    set (key, value, frequency = 1) {
      key = String(key) 
      if (this.#capacity === 0) {
        throw new RangeError('LFUCache ERROR: The Capacity is 0')
      }

      if (this.cache.has(key)) {
        const node = this.cache.get(key)
        node.value = value

        this.#frequencyMap.refresh(node)

        return this
      }

            if (this.#capacity === this.cache.size) {
        this.#removeCacheNode()
      }

      const newNode = new CacheNode(key, value, frequency)

      this.cache.set(key, newNode)
      this.#frequencyMap.insert(newNode)

      return this
    }

    /
    parse (json) {
      const { misses, hits, cache } = JSON.parse(json)

      this.misses += misses ?? 0
      this.hits += hits ?? 0

      for (const key in cache) {
        const { value, frequency } = cache[key]
        this.set(key, value, frequency)
      }

      return this
    }

    /
    clear () {
      this.cache.clear()
      this.#frequencyMap.clear()

      return this
    }

    /
    toString (indent) {
      const replacer = (_, value) => {
        if (value instanceof Set) {
          return [...value]
        }

        if (value instanceof Map) {
          return Object.fromEntries(value)
        }

        return value
      }

      return JSON.stringify(this, replacer, indent)
    }
}

export default LFUCache
const feetToMeter = (feet) => {
  return feet * 0.3048
}

const meterToFeet = (meter) => {
  return meter / 0.3048
}

export { feetToMeter, meterToFeet }
/


const RailwayTimeConversion = (timeString) => {
    if (typeof timeString !== 'string') {
    return new TypeError('Argument is not a string.')
  }
    const [hour, minute, scondWithShift] = timeString.split(':')
    const [second, shift] = [scondWithShift.substr(0, 2), scondWithShift.substr(2)]
    if (shift === 'PM') {
    if (parseInt(hour) === 12) { return `${hour}:${minute}:${second}` } else { return `${parseInt(hour) + 12}:${minute}:${second}` }
  } else {
    if (parseInt(hour) === 12) { return `00:${minute}:${second}` } else { return `${hour}:${minute}:${second}` }
  }
}

export { RailwayTimeConversion }
/


const titleCaseConversion = (inputString) => {
  if (inputString === '') return ''
    const stringCollections = inputString.split(' ').map(word => {
    let firstChar = ''
        const firstCharCode = word[0].charCodeAt()
        if (firstCharCode >= 97 && firstCharCode <= 122) {
            firstChar += String.fromCharCode(firstCharCode - 32)
    } else {
            firstChar += word[0]
    }
    const newWordChar = word.slice(1).split('').map(char => {
            const presentCharCode = char.charCodeAt()
            if (presentCharCode >= 65 && presentCharCode <= 90) {
                return String.fromCharCode(presentCharCode + 32)
      }
            return char
    })
        return firstChar + newWordChar.join('')
  })
    return stringCollections.join(' ')
}

export { titleCaseConversion }
import { base64ToBuffer } from '../Base64ToArrayBuffer'
import { TextDecoder } from 'util'

describe('Base64ToArrayBuffer', () => {
  it('should decode "SGVsbG8sIHdvcmxkIQ==" as "Hello, world!"', () => {
    const testBase64String = 'SGVsbG8sIHdvcmxkIQ=='
    const buffer = base64ToBuffer(testBase64String)
    const decoder = new TextDecoder()
    const helloWorldString = decoder.decode(buffer)
    expect(helloWorldString).toBe('Hello, world!')
  })

  it('should decode base64 "Nxex6kQaWg==" as binary buffer [55,23,177,234,68,26,90]', () => {
    const testBase64String = 'Nxex6kQaWg=='
    const buffer = base64ToBuffer(testBase64String)
    const array = [...new Uint8Array(buffer)]
    expect(array).toEqual([55, 23, 177, 234, 68, 26, 90])
  })

  it('should decode base64 "AAECAwQFBgcICQ==" as binary buffer [0,1,2,3,4,5,6,7,8,9]', () => {
    const testBase64String = 'AAECAwQFBgcICQ=='
    const buffer = base64ToBuffer(testBase64String)
    const array = [...new Uint8Array(buffer)]
    expect(array).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  })
})
import { octalToDecimal } from '../OctToDecimal'

test('The Decimal representation of Octal number 56 is 46', () => {
  const res = octalToDecimal(56)
  expect(res).toBe(46)
})

test('The Decimal representation of Octal number 99 is 81', () => {
  const res = octalToDecimal(99)
  expect(res).toBe(81)
})

test('The Decimal representation of Octal number 17 is 15', () => {
  const res = octalToDecimal(17)
  expect(res).toBe(15)
})

test('The Decimal representation of Octal number 100 is 64', () => {
  const res = octalToDecimal(100)
  expect(res).toBe(64)
})

test('The Decimal representation of Octal number 0 is 0', () => {
  const res = octalToDecimal(0)
  expect(res).toBe(0)
})
import binaryToDecimal from '../BinaryToDecimal'

describe('BinaryToDecimal', () => {
  it('expects to return correct decimal value', () => {
    expect(binaryToDecimal('1000')).toBe(8)
  })

  it('expects to return correct hexadecimal value for more than one hex digit', () => {
    expect(binaryToDecimal('01101000')).toBe(104)
  })

  it('expects to return correct hexadecimal value for padding-required binary', () => {
    expect(binaryToDecimal('1000101')).toBe(69)
  })
})
import * as tc from '../TemperatureConversion.js'

describe('Testing Conversion of Celsius to fahrenheit', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToFahrenheit(10)
    expect(test1).toBe(50)
  })
})

describe('Testing Conversion of Celsius to kelvin', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToKelvin(15)
    expect(test1).toBe(288)
  })
})

describe('Testing Conversion of Celsius to Rankine', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToRankine(28)
    expect(test1).toBe(542)
  })
})

describe('Testing Conversion of Fahrenheit to Celsius', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToCelsius(134)
    expect(test1).toBe(57)
  })
})

describe('Testing Conversion of Fahrenheit to Kelvin', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToKelvin(125)
    expect(test1).toBe(325)
  })
})

describe('Testing Conversion of Fahrenheit to Rankine', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToRankine(10)
    expect(test1).toBe(470)
  })
})

describe('Testing Conversion of Kelvin to Celsius', () => {
  it('with Kelvin value', () => {
    const test1 = tc.kelvinToCelsius(100)
    expect(test1).toBe(-173)
  })
})

describe('Testing Conversion of Kelvin to Fahrenheit', () => {
  it('with Kelvin value', () => {
    const test1 = tc.kelvinToFahrenheit(20)
    expect(test1).toBe(-424)
  })
})

describe('Testing Conversion of Kelvin to Rankine', () => {
  it('with kelvin value', () => {
    const test1 = tc.kelvinToRankine(69)
    expect(test1).toBe(124)
  })
})
describe('Testing Conversion of Rankine to Celsius', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToCelsius(234)
    expect(test1).toBe(-143)
  })
})
describe('Testing Conversion of Rankine to Fahrenheit', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToFahrenheit(98)
    expect(test1).toBe(-362)
  })
})
describe('Testing Conversion of Rankine to Kelvin', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToKelvin(10)
    expect(test1).toBe(6)
  })
})
describe('Testing Conversion of Reamur to Celsius', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToCelsius(100)
    expect(test1).toBe(125)
  })
})
describe('Testing Conversion of Reamur to Fahrenheit', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToFahrenheit(100)
    expect(test1).toBe(257)
  })
})
describe('Testing Conversion of Reamur to Kelvin', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToKelvin(100)
    expect(test1).toBe(398)
  })
})
describe('Testing Conversion of Reamur to Rankine', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToRankine(100)
    expect(test1).toBe(717)
  })
})
import hexToBinary from '../HexToBinary'

describe('Testing hexToBinary', () => {
  it('expects throw error in invalid types', () => {
    expect(() => hexToBinary(false)).toThrowError()
    expect(() => hexToBinary(null)).toThrowError()
    expect(() => hexToBinary(23464)).toThrowError()
  })

  it('expects throw error in invalid hex', () => {
    expect(() => hexToBinary('Hello i am not a valid Hex')).toThrowError()
    expect(() => hexToBinary('Gf46f')).toThrowError()
    expect(() => hexToBinary('M')).toThrowError()
  })

  it('expects to return correct hexadecimal value', () => {
    expect(hexToBinary('8')).toBe('1000')
  })

  it('expects to return correct binary value for more than one hex digit', () => {
    expect(hexToBinary('EA')).toBe('11101010')
  })

  it('expects to test its robustness as it should be case-insensitive', () => {
    expect(hexToBinary('4d')).toBe('01001101')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(2)', () => {
    expect(hexToBinary('F')).toBe(parseInt('F', 16).toString(2))
  })
})
import { upperCaseConversion } from '../UpperCaseConversion'

describe(('Test the upperCaseConversion function'), () => {
  it('should return an empty string when the input is an empty string', () => {
    expect(upperCaseConversion('')).toEqual('')
  })

  it('should return an all-uppercase string when input is an all-uppercase string', () => {
    expect(upperCaseConversion('ALLUPPERCASE')).toEqual('ALLUPPERCASE')
  })

  it('should return an all-uppercase string when input is an all-uppercase string with spaces', () => {
    expect(upperCaseConversion('ALL UPPERCASE')).toEqual('ALL UPPERCASE')
  })

  it('should return an all-uppercase string when input is an all-uppercase string with punctuation', () => {
    expect(upperCaseConversion('ALL UPPER-CASE!')).toEqual('ALL UPPER-CASE!')
  })

  it('should return an all-uppercase string when input is an all-lowercase string', () => {
    expect(upperCaseConversion('lowercaseinput')).toEqual('LOWERCASEINPUT')
  })

  it('should return an all-uppercase string when input is an all-lowercase string with spaces', () => {
    expect(upperCaseConversion('lowercase input')).toEqual('LOWERCASE INPUT')
  })

  it('should return an all-uppercase string when input is an all-lowercase string with punctuation', () => {
    expect(upperCaseConversion('lower-case, input.')).toEqual('LOWER-CASE, INPUT.')
  })

  it('should return an all-uppercase string when input is an mixed-case string', () => {
    expect(upperCaseConversion('mixeDCaSeINPuT')).toEqual('MIXEDCASEINPUT')
  })

  it('should return an all-uppercase string when input is an mixed-case string with spaces', () => {
    expect(upperCaseConversion('mixeD CaSe INPuT')).toEqual('MIXED CASE INPUT')
  })

  it('should return an all-uppercase string when input is an mixed-case string with punctuation', () => {
    expect(upperCaseConversion('mixeD-CaSe INPuT!')).toEqual('MIXED-CASE INPUT!')
  })
})
import binaryToHex from '../BinaryToHex'

describe('BinaryToHex', () => {
  it('expects to return correct hexadecimal value', () => {
    expect(binaryToHex('1000')).toBe('8')
  })

  it('expects to return correct hexadecimal value for more than one hex digit', () => {
    expect(binaryToHex('11101010')).toBe('EA')
  })

  it('expects to return correct hexadecimal value for padding-required binary', () => {
    expect(binaryToHex('1001101')).toBe('4D')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(16)', () => {
    expect(binaryToHex('1111')).toBe(parseInt('1111', 2).toString(16).toUpperCase())
  })
})
import { DateDayDifference } from '../DateDayDifference'

test('The difference between 17/08/2002 & 10/10/2020 is 6630', () => {
  const res = DateDayDifference('17/08/2002', '10/10/2020')
  expect(res).toBe(6630)
})

test('The difference between 18/02/2001 & 16/03/2022 is 7696', () => {
  const res = DateDayDifference('18/02/2001', '16/03/2022')
  expect(res).toBe(7696)
})

test('The difference between 11/11/2011 & 12/12/2012 is 398', () => {
  const res = DateDayDifference('11/11/2011', '12/12/2012')
  expect(res).toBe(398)
})

test('The difference between 01/01/2001 & 16/03/2011 is 3727', () => {
  const res = DateDayDifference('01/01/2001', '16/03/2011')
  expect(res).toBe(3727)
})
import { LowerCaseConversion } from '../LowerCaseConversion'

test('The LowerCaseConversion of ApoLO is apolo', () => {
  const res = LowerCaseConversion('ApoLO')
  expect(res).toBe('apolo')
})

test('The LowerCaseConversion of WEB is web', () => {
  const res = LowerCaseConversion('WEB')
  expect(res).toBe('web')
})

test('The LowerCaseConversion of EaRTh is earth', () => {
  const res = LowerCaseConversion('EaRTh')
  expect(res).toBe('earth')
})

test('The LowerCaseConversion of TiGER is tiger', () => {
  const res = LowerCaseConversion('TiGER')
  expect(res).toBe('tiger')
})

test('The LowerCaseConversion of Cricket is cricket', () => {
  const res = LowerCaseConversion('Cricket')
  expect(res).toBe('cricket')
})
import { decimalToRoman } from '../DecimalToRoman'

describe('decimalToRoman', () => {
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(34)).toBe('XXXIV')
  })
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(28)).toBe('XXVIII')
  })
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(2021)).toBe('MMXXI')
  })
})
import { decimalToBinary } from '../DecimalToBinary'

test('The Binary representation of 35 is 100011', () => {
  const res = decimalToBinary(35)
  expect(res).toBe('100011')
})

test('The Binary representation of 1 is 1', () => {
  const res = decimalToBinary(1)
  expect(res).toBe('1')
})

test('The Binary representation of 1000 is 1111101000', () => {
  const res = decimalToBinary(1000)
  expect(res).toBe('1111101000')
})

test('The Binary representation of 2 is 10', () => {
  const res = decimalToBinary(2)
  expect(res).toBe('10')
})

test('The Binary representation of 17 is 10001', () => {
  const res = decimalToBinary(17)
  expect(res).toBe('10001')
})
import { decimalToHex } from '../DecimalToHex'

describe('DecimalToHex', () => {
  it('expects to return correct hexadecimal value', () => {
    expect(decimalToHex(255)).toBe('FF')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(16)', () => {
    expect(decimalToHex(32768)).toBe((32768).toString(16).toUpperCase())
  })

  it('expects to not handle negative numbers', () => {
    expect(decimalToHex(-32768)).not.toBe((-32768).toString(16).toUpperCase())
  })
})
import { convertArbitraryBase } from '../ArbitraryBase'

test('Check the answer of convertArbitraryBase(98, 0123456789, 01234567) is 142', () => {
  const res = convertArbitraryBase('98', '0123456789', '01234567')
  expect(res).toBe('142')
})

test('Check the answer of convertArbitraryBase(98, 0123456789, abcdefgh) is bec', () => {
  const res = convertArbitraryBase('98', '0123456789', 'abcdefgh')
  expect(res).toBe('bec')
})

test('Check the answer of convertArbitraryBase(98, 0123456789, 98765432) is 857', () => {
  const res = convertArbitraryBase('98', '0123456789', '98765432')
  expect(res).toBe('857')
})

test('Check the answer of convertArbitraryBase(129, 0123456789, 01234567) is 201', () => {
  const res = convertArbitraryBase('129', '0123456789', '01234567')
  expect(res).toBe('201')
})

test('Check the answer of convertArbitraryBase(112, 0123456789, 12345678) is 271', () => {
  const res = convertArbitraryBase('112', '0123456789', '12345678')
  expect(res).toBe('271')
})

test('Check the answer of convertArbitraryBase(112, 0123456789, 123456789) is 245', () => {
  const res = convertArbitraryBase('112', '0123456789', '123456789')
  expect(res).toBe('245')
})

test('Check the answer of convertArbitraryBase(111, 0123456789, abcdefgh) is bfh', () => {
  const res = convertArbitraryBase('111', '0123456789', 'abcdefgh')
  expect(res).toBe('bfh')
})
import { meterToFeet, feetToMeter } from '../MeterToFeetConversion'

describe('Testing conversion of Meter to Feet', () => {
  it('with feet value', () => {
    expect(meterToFeet(30.48)).toBe(100)
  })
})

describe('Testing conversion of Feet to Meter', () => {
  it('with feet value', () => {
    expect(feetToMeter(10)).toBe(3.048)
  })
})
import { RGBToHex } from '../RGBToHex'

test('The Hex format of RGB (225, 225, 225) is #ffffff', () => {
  const res = RGBToHex(255, 255, 255)
  expect(res).toBe('#ffffff')
})

test('The Hex format of RGB (190, 108, 217) is #be6cd9', () => {
  const res = RGBToHex(190, 108, 217)
  expect(res).toBe('#be6cd9')
})

test('The Hex format of RGB (255, 99, 71) is #ff6347', () => {
  const res = RGBToHex(255, 99, 71)
  expect(res).toBe('#ff6347')
})

test('The Hex format of RGB (100, 108, 217) is #646cd9', () => {
  const res = RGBToHex(100, 108, 217)
  expect(res).toBe('#646cd9')
})
import { approximatelyEqualHsv, hsvToRgb, rgbToHsv } from '../RgbHsvConversion'

describe('hsvToRgb', () => {
    it('should calculate the correct RGB values', () => {
    expect(hsvToRgb(0, 0, 0)).toEqual([0, 0, 0])
    expect(hsvToRgb(0, 0, 1)).toEqual([255, 255, 255])
    expect(hsvToRgb(0, 1, 1)).toEqual([255, 0, 0])
    expect(hsvToRgb(60, 1, 1)).toEqual([255, 255, 0])
    expect(hsvToRgb(120, 1, 1)).toEqual([0, 255, 0])
    expect(hsvToRgb(240, 1, 1)).toEqual([0, 0, 255])
    expect(hsvToRgb(300, 1, 1)).toEqual([255, 0, 255])
    expect(hsvToRgb(180, 0.5, 0.5)).toEqual([64, 128, 128])
    expect(hsvToRgb(234, 0.14, 0.88)).toEqual([193, 196, 224])
    expect(hsvToRgb(330, 0.75, 0.5)).toEqual([128, 32, 80])
  })
})

describe('rgbToHsv', () => {
    it('should calculate the correct HSV values', () => {
    expect(approximatelyEqualHsv(rgbToHsv(0, 0, 0), [0, 0, 0])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 255, 255), [0, 0, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 0, 0), [0, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 255, 0), [60, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(0, 255, 0), [120, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(0, 0, 255), [240, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 0, 255), [300, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(64, 128, 128), [180, 0.5, 0.5])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(193, 196, 224), [234, 0.14, 0.88])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(128, 32, 80), [330, 0.75, 0.5])).toEqual(true)
  })
})
import { DateToDay } from '../DateToDay'

test('The date 18/02/2001 is Monday', () => {
  const res = DateToDay('18/02/2001')
  expect(res).toBe('Monday')
})

test('The date 18/12/2020 is Friday', () => {
  const res = DateToDay('18/12/2020')
  expect(res).toBe('Friday')
})

test('The date 12/12/2012 is Wednesday', () => {
  const res = DateToDay('12/12/2012')
  expect(res).toBe('Wednesday')
})
test('The date 01/01/2001 is Friday', () => {
  const res = DateToDay('01/01/2001')
  expect(res).toBe('Friday')
})
import { decimalToOctal } from '../DecimalToOctal'

test('The Octal representation of 8 is 10', () => {
  const res = decimalToOctal(8)
  expect(res).toBe(10)
})

test('The Octal representation of 1 is 1', () => {
  const res = decimalToOctal(1)
  expect(res).toBe(1)
})

test('The Octal representation of 0 is 0', () => {
  const res = decimalToOctal(0)
  expect(res).toBe(0)
})

test('The Octal representation of 100 is 144', () => {
  const res = decimalToOctal(100)
  expect(res).toBe(144)
})

test('The Octal representation of 111 is 157', () => {
  const res = decimalToOctal(111)
  expect(res).toBe(157)
})
import { hexStringToRGB } from '../HexToRGB'

test('The RGB form of Hex String E1E1E1 is {r: 225, g: 225, b: 225}', () => {
  const res = hexStringToRGB('E1E1E1')
  expect(res).toEqual({ r: 225, g: 225, b: 225 })
})

test('The RGB form of Hex String 000000 is {r: 0, g: 0, b: 0}', () => {
  const res = hexStringToRGB('000000')
  expect(res).toEqual({ r: 0, g: 0, b: 0 })
})

test('The RGB form of Hex String 6CE1CD is {r: 108, g: 225, b: 205}', () => {
  const res = hexStringToRGB('6CE1CD')
  expect(res).toEqual({ r: 108, g: 225, b: 205 })
})
import { titleCaseConversion } from '../TitleCaseConversion'

describe(('Tests for the titleCaseConversion function'), () => {
  it('should return an empty string when the input is an empty string', () => {
    expect(titleCaseConversion('')).toEqual('')
  })

  it('should return the input string when the input string is a title case string', () => {
    expect(titleCaseConversion('A Proper Title Case String')).toEqual('A Proper Title Case String')
  })

  it('should return a title case string when input is an all-uppercase string', () => {
    expect(titleCaseConversion('ALL UPPER CASE')).toEqual('All Upper Case')
  })

  it('should return a title case string when input is a title case string of with spaces', () => {
    expect(titleCaseConversion('ALL UPPERCASE')).toEqual('All Uppercase')
  })

  it('should return a title case string when input is a title case string of with no spaces', () => {
    expect(titleCaseConversion('ALLUPPERCASE')).toEqual('Alluppercase')
  })

  it('should return a title case string when input is a title case string with punctuation', () => {
    expect(titleCaseConversion('All Title Case!')).toEqual('All Title Case!')
  })

  it('should return a title case string when input is an all-lowercase string with no spaces', () => {
    expect(titleCaseConversion('lowercaseinput')).toEqual('Lowercaseinput')
  })

  it('should return a title case string when input is an all-lowercase string with spaces', () => {
    expect(titleCaseConversion('lowercase input')).toEqual('Lowercase Input')
  })

  it('should return a title case string when input is an all-lowercase string with punctuation', () => {
    expect(titleCaseConversion('lower, case, input.')).toEqual('Lower, Case, Input.')
  })

  it('should return a title case string when input is an mixed-case string', () => {
    expect(titleCaseConversion('mixeD CaSe INPuT')).toEqual('Mixed Case Input')
  })

  it('should return a title case string when input is an mixed-case string with no spaces', () => {
    expect(titleCaseConversion('mixeDCaSeINPuT')).toEqual('Mixedcaseinput')
  })

  it('should return a title case string when input is an mixed-case string with punctuation', () => {
    expect(titleCaseConversion('mixeD, CaSe, INPuT!')).toEqual('Mixed, Case, Input!')
  })
})
import { bufferToBase64 } from '../ArrayBufferToBase64'
import { TextEncoder } from 'util'

describe('ArrayBufferToBase64', () => {
  it('should encode "Hello, world!" as "SGVsbG8sIHdvcmxkIQ=="', () => {
    const testString = 'Hello, world!'
    const encoder = new TextEncoder()
    const helloWorldBuffer = encoder.encode(testString)
    const result = bufferToBase64(helloWorldBuffer)
    expect(result).toBe('SGVsbG8sIHdvcmxkIQ==')
  })

  it('should encode binary buffer [55,23,177,234,68,26,90] as "Nxex6kQaWg=="', () => {
    const testBuffer = new Uint8Array([55, 23, 177, 234, 68, 26, 90])
    const result = bufferToBase64(testBuffer)
    expect(result).toBe('Nxex6kQaWg==')
  })

  it('should encode binary buffer [0,1,2,3,4,5,6,7,8,9] as "AAECAwQFBgcICQ=="', () => {
    const testBuffer = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    const result = bufferToBase64(testBuffer)
    expect(result).toBe('AAECAwQFBgcICQ==')
  })
})
import { RailwayTimeConversion } from '../RailwayTimeConversion'

test('The RailwayTimeConversion of 07:05:45AM is 07:05:45', () => {
  const res = RailwayTimeConversion('07:05:45AM')
  expect(res).toEqual('07:05:45')
})

test('The RailwayTimeConversion of 07:05:45PM is 19:05:45', () => {
  const res = RailwayTimeConversion('07:05:45PM')
  expect(res).toEqual('19:05:45')
})

test('The RailwayTimeConversion of 10:20:00AM is 10:20:00', () => {
  const res = RailwayTimeConversion('10:20:00AM')
  expect(res).toEqual('10:20:00')
})

test('The RailwayTimeConversion of 11:20:00PM is 23:20:00', () => {
  const res = RailwayTimeConversion('11:20:00PM')
  expect(res).toEqual('23:20:00')
})
import { romanToDecimal } from '../RomanToDecimal'

describe('romanToDecimal', () => {
  it('XXIIVV', () => {
    expect(romanToDecimal('XXIIVV')).toBe(28)
  })

  it('MDCCCIV', () => {
    expect(romanToDecimal('MDCCCIV')).toBe(1804)
  })

  it('XXIVI', () => {
    expect(romanToDecimal('XXIVI')).toBe(25)
  })
})
const pad = (num, padlen) => {
  const pad = new Array(1 + padlen).join(0)
  return (pad + num).slice(-pad.length)
}

const hexLookup = (bin) => {
  let binary = bin
  if (binary.length < 4) {
    binary = pad(binary, 4)
  }
  switch (binary) {
    case '0000': return '0'
    case '0001': return '1'
    case '0010': return '2'
    case '0011': return '3'
    case '0100': return '4'
    case '0101': return '5'
    case '0110': return '6'
    case '0111': return '7'
    case '1000': return '8'
    case '1001': return '9'
    case '1010': return 'A'
    case '1011': return 'B'
    case '1100': return 'C'
    case '1101': return 'D'
    case '1110': return 'E'
    case '1111': return 'F'
  }
}
const binaryToHex = (binaryString) => {
  /

  let result = ''
  binaryString = binaryString.split('')
  for (let i = binaryString.length - 1; i >= 0; i = i - 4) {
    if (i >= 3) {
      result += hexLookup(binaryString.slice(i - 3, i + 1).join(''))
    } else {
      result += hexLookup(binaryString.slice(0, i + 1).join(''))
    }
  }
  return result.split('').reverse().join('')
}

export default binaryToHex


function bufferToBase64 (binaryData) {
    const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    const padding = 3 - (binaryData.byteLength % 3)
    const byteView = new Uint8Array(binaryData)
  let result = ''

    for (let i = 0; i < byteView.byteLength; i += 3) {
        const char1 = (byteView[i] & 252) >> 2
    const char2 = ((byteView[i] & 3) << 4) + ((byteView[i + 1] & 240) >> 4)
    const char3 = ((byteView[i + 1] & 15) << 2) + ((byteView[i + 2] & 192) >> 6)
    const char4 = byteView[i + 2] & 63

    result +=
        base64Table[char1] +
        base64Table[char2] +
        base64Table[char3] +
        base64Table[char4]
  }

    if (padding !== 3) {
    const paddedResult = result.slice(0, result.length - padding) + '='.repeat(padding)
    return paddedResult
  }

  return result
}

export { bufferToBase64 }
function RGBToHex (r, g, b) {
  if (
    typeof r !== 'number' ||
    typeof g !== 'number' ||
    typeof b !== 'number'
  ) {
    throw new TypeError('argument is not a Number')
  }

  const toHex = n => (n || '0').toString(16).padStart(2, '0')

  return `#${toHex(r)}${toHex(g)}${toHex(b)}`
}

export { RGBToHex }


/

const isLeap = (year) => {
  if (year % 400 === 0) return true
  else if (year % 100 === 0) return false
  else if (year % 4 === 0) return true
  else return false
}
const DateToDay = (dd, mm, yyyy) => {
  return Math.floor((365 * (yyyy - 1)) + ((yyyy - 1) / 4) - ((yyyy - 1) / 100) + ((yyyy - 1) / 400) + dd + (((367 * mm) - 362) / 12) + (mm <= 2 ? 0 : isLeap(yyyy) ? -1 : -2))
}

const DateDayDifference = (date1, date2) => {
    if (typeof date1 !== 'string' && typeof date2 !== 'string') {
    return new TypeError('Argument is not a string.')
  }
    const [firstDateDay, firstDateMonth, firstDateYear] = date1.split('/').map((ele) => Number(ele))
    const [secondDateDay, secondDateMonth, secondDateYear] = date2.split('/').map((ele) => Number(ele))
    if (firstDateDay < 0 || firstDateDay > 31 ||
        firstDateMonth > 12 || firstDateMonth < 0 ||
        secondDateDay < 0 || secondDateDay > 31 ||
        secondDateMonth > 12 || secondDateMonth < 0) {
    return new TypeError('Date is not valid.')
  }
  return Math.abs(DateToDay(secondDateDay, secondDateMonth, secondDateYear) - DateToDay(firstDateDay, firstDateMonth, firstDateYear))
}


export { DateDayDifference }
const binLookup = (key) => ({
  0: '0000',
  1: '0001',
  2: '0010',
  3: '0011',
  4: '0100',
  5: '0101',
  6: '0110',
  7: '0111',
  8: '1000',
  9: '1001',
  a: '1010',
  b: '1011',
  c: '1100',
  d: '1101',
  e: '1110',
  f: '1111'
}[key.toLowerCase()]) 
const hexToBinary = (hexString) => {
  if (typeof hexString !== 'string') {
    throw new TypeError('Argument is not a string type')
  }

  if (/[^\da-f]/gi.test(hexString)) {
    throw new Error('Argument is not a valid HEX code!')
  }
  /

  return hexString.replace(
    /[0-9a-f]/gi,
    lexeme => binLookup(lexeme)
  )
}

export default hexToBinary
/

const values = {
  M: 1000,
  CM: 900,
  D: 500,
  CD: 400,
  C: 100,
  XC: 90,
  L: 50,
  XL: 40,
  X: 10,
  IX: 9,
  V: 5,
  IV: 4,
  I: 1
}

const orders = [
  'M',
  'CM',
  'D',
  'CD',
  'C',
  'XC',
  'L',
  'XL',
  'X',
  'IX',
  'V',
  'IV',
  'I'
]

function decimalToRoman (num) {
  let roman = ''
  for (const symbol of orders) {
    while (num >= values[symbol]) {
      roman += symbol
      num -= values[symbol]
    }
  }
  return roman
}

export { decimalToRoman }
const values = {
  I: 1,
  V: 5,
  X: 10,
  L: 50,
  C: 100,
  D: 500,
  M: 1000
}

export function romanToDecimal (romanNumber) {
  let prev = ' '

  let sum = 0

  let newPrev = 0
  for (let i = romanNumber.length - 1; i >= 0; i--) {
    const c = romanNumber.charAt(i)

    if (prev !== ' ') {
      newPrev = values[prev] > newPrev ? values[prev] : newPrev
    }

    const currentNum = values[c]
    if (currentNum >= newPrev) {
      sum += currentNum
    } else {
      sum -= currentNum
    }

    prev = c
  }
  return sum
}


function base64ToBuffer (b64) {
    const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    const paddingIdx = b64.indexOf('=')
    const b64NoPadding = paddingIdx !== -1 ? b64.slice(0, paddingIdx) : b64
    const bufferLength = Math.floor((b64NoPadding.length * 6) / 8)
    const result = new ArrayBuffer(bufferLength)
    const byteView = new Uint8Array(result)

    for (let i = 0, j = 0; i < b64NoPadding.length; i += 4, j += 3) {
        const b64Char1 = base64Table.indexOf(b64NoPadding[i])
    const b64Char2 = base64Table.indexOf(b64NoPadding[i + 1])
    let b64Char3 = base64Table.indexOf(b64NoPadding[i + 2])
    let b64Char4 = base64Table.indexOf(b64NoPadding[i + 3])

        if (b64Char3 === -1) b64Char3 = 0
    if (b64Char4 === -1) b64Char4 = 0

        const byte1 = (b64Char1 << 2) + ((b64Char2 & 48) >> 4)
    const byte2 = ((b64Char2 & 15) << 4) + ((b64Char3 & 60) >> 2)
    const byte3 = ((b64Char3 & 3) << 6) + b64Char4

    byteView[j] = byte1
    byteView[j + 1] = byte2
    byteView[j + 2] = byte3
  }

  return result
}

export { base64ToBuffer }
function octalToDecimal (num) {
  let dec = 0
  let base = 1
  while (num > 0) {
    const r = num % 10
    num = Math.floor(num / 10)
    dec = dec + (r * base)
    base = base * 8
  }
  return dec
}

export { octalToDecimal }


function hexToInt (hexNum) {
  const numArr = hexNum.split('')   return numArr.map((item, index) => {
    switch (item) {
      case 'A': return 10
      case 'B': return 11
      case 'C': return 12
      case 'D': return 13
      case 'E': return 14
      case 'F': return 15
      default: return parseInt(item)
    }
  })
}

function hexToDecimal (hexNum) {
  const intItemsArr = hexToInt(hexNum)
  return intItemsArr.reduce((accumulator, current, index) => {
    return accumulator + (current * Math.pow(16, (intItemsArr.length - (1 + index))))
  }, 0)
}

export { hexToInt, hexToDecimal }
function intToHex (num) {
  switch (num) {
    case 10: return 'A'
    case 11: return 'B'
    case 12: return 'C'
    case 13: return 'D'
    case 14: return 'E'
    case 15: return 'F'
  }
  return num
}

function decimalToHex (num) {
  const hexOut = []
  while (num > 15) {
    hexOut.unshift(intToHex(num % 16))
    num = Math.floor(num / 16)
  }
  return intToHex(num) + hexOut.join('')
}

export { decimalToHex }
/


const upperCaseConversion = (inputString) => {
    const newString = inputString.split('').map(char => {
        const presentCharCode = char.charCodeAt()
        if (presentCharCode >= 97 && presentCharCode <= 122) {
            return String.fromCharCode(presentCharCode - 32)
    }
        return char
  })
    return newString.join('')
}

export { upperCaseConversion }
function decimalToOctal (num) {
  let oct = 0
  let c = 0
  while (num > 0) {
    const r = num % 8
    oct = oct + (r * Math.pow(10, c++))
    num = Math.floor(num / 8)   }
  return oct
}

export { decimalToOctal }






const convertArbitraryBase = (stringInBaseOne, baseOneCharacters, baseTwoCharacters) => {
  if ([stringInBaseOne, baseOneCharacters, baseTwoCharacters].map(arg => typeof arg).some(type => type !== 'string')) {
    throw new TypeError('Only string arguments are allowed')
  }
  [baseOneCharacters, baseTwoCharacters].forEach(baseString => {
    const charactersInBase = [...baseString]
    if (charactersInBase.length !== new Set(charactersInBase).size) {
      throw new TypeError('Duplicate characters in character set are not allowed')
    }
  })
  const reversedStringOneChars = [...stringInBaseOne].reverse()
  const stringOneBase = baseOneCharacters.length
  let value = 0
  let placeValue = 1
  for (const digit of reversedStringOneChars) {
    const digitNumber = baseOneCharacters.indexOf(digit)
    if (digitNumber === -1) {
      throw new TypeError(`Not a valid character: ${digit}`)
    }
    value += (digitNumber * placeValue)
    placeValue *= stringOneBase
  }
  let stringInBaseTwo = ''
  const stringTwoBase = baseTwoCharacters.length
  while (value > 0) {
    const remainder = value % stringTwoBase
    stringInBaseTwo = baseTwoCharacters.charAt(remainder) + stringInBaseTwo
    value /= stringTwoBase
  }
  const baseTwoZero = baseTwoCharacters.charAt(0)
  return stringInBaseTwo.replace(new RegExp(`^${baseTwoZero}+`), '')
}

export { convertArbitraryBase }



/


const LowerCaseConversion = (inputString) => {
    const newString = inputString.split('').map(char => {
        const presentCharCode = char.charCodeAt()
        if (presentCharCode >= 65 && presentCharCode <= 90) {
            return String.fromCharCode(presentCharCode + 32)
    }
        return char
  })
    return newString.join('')
}

export { LowerCaseConversion }

const celsiusToFahrenheit = (celsius) => {
      return Math.round(((celsius) * 9 / 5) + 32)
}

const celsiusToKelvin = (celsius) => {
      return Math.round((celsius) + 273.15)
}

const celsiusToRankine = (celsius) => {
      return Math.round(((celsius) * 9 / 5) + 491.67)
}

const fahrenheitToCelsius = (fahrenheit) => {
      return Math.round(((fahrenheit) - 32) * 5 / 9)
}

const fahrenheitToKelvin = (fahrenheit) => {
      return Math.round((((fahrenheit) - 32) * 5 / 9) + 273.15)
}

const fahrenheitToRankine = (fahrenheit) => {
      return Math.round((fahrenheit) + 459.67)
}

const kelvinToCelsius = (kelvin) => {
      return Math.round((kelvin) - 273.15)
}

const kelvinToFahrenheit = (kelvin) => {
      return Math.round((((kelvin) - 273.15) * 9 / 5) + 32)
}

const kelvinToRankine = (kelvin) => {
      return Math.round(((kelvin) * 9 / 5))
}

const rankineToCelsius = (rankine) => {
      return Math.round(((rankine) - 491.67) * 5 / 9)
}

const rankineToFahrenheit = (rankine) => {
      return Math.round((rankine) - 459.67)
}

const rankineToKelvin = (rankine) => {
      return Math.round(((rankine) * 5 / 9))
}

const reaumurToKelvin = (reaumur) => {
    return Math.round(((reaumur) * 1.25 + 273.15))
}

const reaumurToFahrenheit = (reaumur) => {
    return Math.round(((reaumur) * 2.25 + 32))
}

const reaumurToCelsius = (reaumur) => {
    return Math.round(((reaumur) * 1.25))
}

const reaumurToRankine = (reaumur) => {
    return Math.round(((reaumur) * 2.25 + 32 + 459.67))
}

export {
  celsiusToFahrenheit, celsiusToKelvin, celsiusToRankine,
  fahrenheitToCelsius, fahrenheitToKelvin, fahrenheitToRankine,
  kelvinToCelsius, kelvinToFahrenheit, kelvinToRankine,
  rankineToCelsius, rankineToFahrenheit, rankineToKelvin,
  reaumurToCelsius, reaumurToFahrenheit, reaumurToKelvin, reaumurToRankine
}
/

const calcMonthList = {
  1: 11,
  2: 12,
  3: 1,
  4: 2,
  5: 3,
  6: 4,
  7: 5,
  8: 6,
  9: 7,
  10: 8,
  11: 9,
  12: 10
}

const daysNameList = {   0: 'Sunday',
  1: 'Monday',
  2: 'Tuesday',
  3: 'Wednesday',
  4: 'Thursday',
  5: 'Friday',
  6: 'Saturday'
}

const DateToDay = (date) => {
    if (typeof date !== 'string') {
    return new TypeError('Argument is not a string.')
  }
    const [day, month, year] = date.split('/').map((x) => Number(x))
    if (day < 0 || day > 31 || month > 12 || month < 0) {
    return new TypeError('Date is not valid.')
  }
    const yearDigit = (year % 100)
  const century = Math.floor(year / 100)
    const weekDay = Math.abs((day + Math.floor((2.6 * calcMonthList[month]) - 0.2) - (2 * century) + yearDigit + Math.floor(yearDigit / 4) + Math.floor(century / 4)) % 7)
    return daysNameList[weekDay]
}


export { DateToDay }
function hexStringToRGB (hexString) {
  let r = hexString.substring(0, 2)
  let g = hexString.substring(2, 4)
  let b = hexString.substring(4, 6)

  r = parseInt(r, 16)
  g = parseInt(g, 16)
  b = parseInt(b, 16)
  const obj = { r, g, b }

  return obj
}

export { hexStringToRGB }

/


export function hsvToRgb (hue, saturation, value) {
  if (hue < 0 || hue > 360) {
    throw new Error('hue should be between 0 and 360')
  }

  if (saturation < 0 || saturation > 1) {
    throw new Error('saturation should be between 0 and 1')
  }

  if (value < 0 || value > 1) {
    throw new Error('value should be between 0 and 1')
  }

  const chroma = value * saturation
  const hueSection = hue / 60
  const secondLargestComponent = chroma * (1 - Math.abs(hueSection % 2 - 1))
  const matchValue = value - chroma

  return getRgbBySection(hueSection, chroma, matchValue, secondLargestComponent)
}


export function rgbToHsv (red, green, blue) {
  if (red < 0 || red > 255) {
    throw new Error('red should be between 0 and 255')
  }

  if (green < 0 || green > 255) {
    throw new Error('green should be between 0 and 255')
  }

  if (blue < 0 || blue > 255) {
    throw new Error('blue should be between 0 and 255')
  }

  const dRed = red / 255
  const dGreen = green / 255
  const dBlue = blue / 255
  const value = Math.max(Math.max(dRed, dGreen), dBlue)
  const chroma = value - Math.min(Math.min(dRed, dGreen), dBlue)
  const saturation = value === 0 ? 0 : chroma / value
  let hue

  if (chroma === 0) {
    hue = 0
  } else if (value === dRed) {
    hue = 60 * ((dGreen - dBlue) / chroma)
  } else if (value === dGreen) {
    hue = 60 * (2 + (dBlue - dRed) / chroma)
  } else {
    hue = 60 * (4 + (dRed - dGreen) / chroma)
  }

  hue = (hue + 360) % 360

  return [hue, saturation, value]
}

export function approximatelyEqualHsv (hsv1, hsv2) {
  const bHue = Math.abs(hsv1[0] - hsv2[0]) < 0.2
  const bSaturation = Math.abs(hsv1[1] - hsv2[1]) < 0.002
  const bValue = Math.abs(hsv1[2] - hsv2[2]) < 0.002

  return bHue && bSaturation && bValue
}

function getRgbBySection (hueSection, chroma, matchValue, secondLargestComponent) {
  function convertToInt (input) {
    return Math.round(255 * input)
  }

  let red
  let green
  let blue

  if (hueSection >= 0 && hueSection <= 1) {
    red = convertToInt(chroma + matchValue)
    green = convertToInt(secondLargestComponent + matchValue)
    blue = convertToInt(matchValue)
  } else if (hueSection > 1 && hueSection <= 2) {
    red = convertToInt(secondLargestComponent + matchValue)
    green = convertToInt(chroma + matchValue)
    blue = convertToInt(matchValue)
  } else if (hueSection > 2 && hueSection <= 3) {
    red = convertToInt(matchValue)
    green = convertToInt(chroma + matchValue)
    blue = convertToInt(secondLargestComponent + matchValue)
  } else if (hueSection > 3 && hueSection <= 4) {
    red = convertToInt(matchValue)
    green = convertToInt(secondLargestComponent + matchValue)
    blue = convertToInt(chroma + matchValue)
  } else if (hueSection > 4 && hueSection <= 5) {
    red = convertToInt(secondLargestComponent + matchValue)
    green = convertToInt(matchValue)
    blue = convertToInt(chroma + matchValue)
  } else {
    red = convertToInt(chroma + matchValue)
    green = convertToInt(matchValue)
    blue = convertToInt(secondLargestComponent + matchValue)
  }

  return [red, green, blue]
}
function decimalToBinary (num) {
  const bin = []
  while (num > 0) {
    bin.unshift(num % 2)
    num >>= 1   }
  return bin.join('')
}

export { decimalToBinary }



export default function binaryToDecimal (binaryString) {
  let decimalNumber = 0
  const binaryDigits = binaryString.split('').reverse()   binaryDigits.forEach((binaryDigit, index) => {
    decimalNumber += binaryDigit * (Math.pow(2, index))   })
  return decimalNumber
}
/

const swap = (arr, i, j) => {
  const newArray = [...arr];

  [newArray[i], newArray[j]] = [newArray[j], newArray[i]] 
  return newArray
}

const permutations = arr => {
  const P = []
  const permute = (arr, low, high) => {
    if (low === high) {
      P.push([...arr])
      return P
    }
    for (let i = low; i <= high; i++) {
      arr = swap(arr, low, i)
      permute(arr, low + 1, high)
    }
    return P
  }
  return permute(arr, 0, arr.length - 1)
}

export { permutations }
class NQueen {
  constructor (size) {
    this.board = new Array(size).fill('.').map(() => new Array(size).fill('.'))
    this.size = size
    this.solutionCount = 0
  }

  isValid ([row, col]) {
    
        for (let i = 0; i < col; i++) {
      if (this.board[row][i] === 'Q') return false
    }

        for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {
      if (this.board[i][j] === 'Q') return false
    }

        for (let i = row, j = col; j >= 0 && i < this.size; i++, j--) {
      if (this.board[i][j] === 'Q') return false
    }

    return true
  }

  placeQueen (row, col) {
    this.board[row][col] = 'Q'
  }

  removeQueen (row, col) {
    this.board[row][col] = '.'
  }

  solve (col = 0) {
    if (col >= this.size) {
      this.solutionCount++
      return true
    }

    for (let i = 0; i < this.size; i++) {
      if (this.isValid([i, col])) {
        this.placeQueen(i, col)
        this.solve(col + 1)
        this.removeQueen(i, col)
      }
    }

    return false
  }

  printBoard (output = value => console.log(value)) {
    if (!output._isMockFunction) {
      output('\n')
    }
    for (const row of this.board) {
      output(row)
    }
  }
}

export { NQueen }
import { Combinations } from '../AllCombinationsOfSizeK'

describe('AllCombinationsOfSizeK', () => {
  it('should return 3x2 matrix solution for n = 3 and k = 2', () => {
    const test1 = new Combinations(3, 2)
    expect(test1.findCombinations()).toEqual([[1, 2], [1, 3], [2, 3]])
  })

  it('should return 6x2 matrix solution for n = 4 and k = 2', () => {
    const test2 = new Combinations(4, 2)
    expect(test2.findCombinations()).toEqual([[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]])
  })
})
import { NQueen } from '../NQueen'

describe('NQueen', () => {
  it('should return 2 solutions for 4x4 size board', () => {
    const _4Queen = new NQueen(4)
    _4Queen.solve()
    expect(_4Queen.solutionCount).toEqual(2)
  })

  it('should return 92 solutions for 8x8 size board', () => {
    const _8Queen = new NQueen(8)
    _8Queen.solve()
    expect(_8Queen.solutionCount).toEqual(92)
  })
})
import { OpenKnightTour } from '../KnightTour'

describe('OpenKnightTour', () => {
  it('OpenKnightTour(5)', () => {
    const KT = new OpenKnightTour(5)
    expect(KT.board).toEqual([
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0]
    ])

    KT.solve()
    expect(KT.board).toEqual([
      [19, 4, 15, 10, 25],
      [14, 9, 18, 5, 16],
      [1, 20, 3, 24, 11],
      [8, 13, 22, 17, 6],
      [21, 2, 7, 12, 23]
    ])
  })
})
import { Sudoku } from '../Sudoku'

const data = [
  [3, 0, 6, 5, 0, 8, 4, 0, 0],
  [5, 2, 0, 0, 0, 0, 0, 0, 0],
  [0, 8, 7, 0, 0, 0, 0, 3, 1],
  [0, 0, 3, 0, 1, 0, 0, 8, 0],
  [9, 0, 0, 8, 6, 3, 0, 0, 5],
  [0, 5, 0, 0, 9, 0, 6, 0, 0],
  [1, 3, 0, 0, 0, 0, 2, 5, 0],
  [0, 0, 0, 0, 0, 0, 0, 7, 4],
  [0, 0, 5, 2, 0, 6, 3, 0, 0]
]

const solved = [
  [3, 1, 6, 5, 7, 8, 4, 9, 2],
  [5, 2, 9, 1, 3, 4, 7, 6, 8],
  [4, 8, 7, 6, 2, 9, 5, 3, 1],
  [2, 6, 3, 4, 1, 5, 9, 8, 7],
  [9, 7, 4, 8, 6, 3, 1, 2, 5],
  [8, 5, 1, 7, 9, 2, 6, 4, 3],
  [1, 3, 8, 9, 4, 7, 2, 5, 6],
  [6, 9, 2, 3, 5, 1, 8, 7, 4],
  [7, 4, 5, 2, 8, 6, 3, 1, 9]
]

describe('Sudoku', () => {
  it('should create a valid board successfully', () => {
            expect(() => { new Sudoku(data) }).not.toThrow()
  })

  it('should find an empty cell', () => {
    const board = new Sudoku(data)
    const emptyCell = board.findEmptyCell()
    expect(emptyCell).not.toEqual([-1, -1])
  })

  it('should solve the board successfully', () => {
    const board = new Sudoku(data)
    board.solve()

        const emptyCell = board.findEmptyCell()
    expect(emptyCell).toEqual([-1, -1])

        for (let i = 0; i < 9; i++) {
      const section = board.getSection(i, [0, 9])
      expect(section).toEqual(solved[i])
    }
  })
})
import { permutations } from '../GeneratePermutations'

describe('Permutations', () => {
  it('Permutations of [1, 2, 3]', () => {
    expect(permutations([1, 2, 3])).toEqual([
      [1, 2, 3],
      [1, 3, 2],
      [2, 1, 3],
      [2, 3, 1],
      [3, 1, 2],
      [3, 2, 1]
    ])
  })
})
import { RatInAMaze } from '../RatInAMaze'

describe('RatInAMaze', () => {
  it('should fail for non-arrays', () => {
    const values = [undefined, null, {}, 42, 'hello, world']

    for (const value of values) {
                  expect(() => { new RatInAMaze(value) }).toThrow()
    }
  })

  it('should fail for an empty array', () => {
            expect(() => { new RatInAMaze([]) }).toThrow()
  })

  it('should fail for a non-square array', () => {
    const array = [
      [0, 0, 0],
      [0, 0]
    ]

            expect(() => { new RatInAMaze(array) }).toThrow()
  })

  it('should fail for arrays containing invalid values', () => {
    const values = [[[2]], [['a']]]

    for (const value of values) {
                  expect(() => { new RatInAMaze(value) }).toThrow()
    }
  })

  it('should work for a single-cell maze', () => {
    const maze = new RatInAMaze([[1]])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('')
  })

  it('should work for a single-cell maze that can not be solved', () => {
    const maze = new RatInAMaze([[0]])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })

  it('should work for a simple 3x3 maze', () => {
    const maze = new RatInAMaze([[1, 1, 0], [0, 1, 0], [0, 1, 1]])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('RDDR')
  })

  it('should work for a simple 2x2 that can not be solved', () => {
    const maze = new RatInAMaze([[1, 0], [0, 1]])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })

  it('should work for a more complex maze', () => {
    const maze = new RatInAMaze([
      [1, 1, 1, 1, 1, 0, 0],
      [0, 0, 0, 0, 1, 0, 0],
      [1, 1, 1, 0, 1, 0, 0],
      [1, 0, 1, 0, 1, 0, 0],
      [1, 0, 1, 1, 1, 0, 0],
      [1, 0, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 1, 1, 1]
    ])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('RRRRDDDDLLUULLDDDDRRRRRR')
  })

  it('should work for a more complex maze that can not be solved', () => {
    const maze = new RatInAMaze([
      [1, 1, 1, 1, 1, 0, 1],
      [0, 0, 0, 0, 1, 0, 1],
      [1, 1, 1, 0, 1, 0, 1],
      [1, 0, 1, 0, 1, 0, 1],
      [1, 0, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 1, 1, 1]
    ])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })
})
import { sumOfSubset } from '../SumOfSubset'

describe('SumOfSubset', () => {
  it('should return the subsets that add up to the given number', () => {
        
    const nums = [2, 5, 7, 8, 12, 16, 23, 40]

    const subsets = sumOfSubset(nums, [], 0, 0, 25)

    expect(subsets).toEqual([
      [2, 7, 16],
      [2, 23],
      [5, 8, 12]
    ])
  })
})
class Sudoku {
    constructor (board) {
    this.board = board
  }

  findEmptyCell () {
        for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        if (this.board[i][j] === 0) return [i, j]
      }
    }
    return [-1, -1]
  }

  check ([y, x], value) {
    
        for (let i = 0; i < 9; i++) {
      if (this.board[i][x] === value) return false
    }
        for (let i = 0; i < 9; i++) {
      if (this.board[y][i] === value) return false
    }

        const secRow = Math.floor(y / 3)
    const secCol = Math.floor(x / 3)
    for (let i = (secRow * 3); i < ((secRow * 3) + 3); i++) {
      for (let j = (secCol * 3); j < ((secCol * 3) + 3); j++) {
        if (y !== i && x !== j && this.board[i][j] === value) return false
      }
    }

    return true
  }

  solve () {
    const [y, x] = this.findEmptyCell()

        if (y === -1 && x === -1) return true

    for (let val = 1; val < 10; val++) {
      if (this.check([y, x], val)) {
        this.board[y][x] = val
        if (this.solve()) return true
                this.board[y][x] = 0
      }
    }
        return false
  }

  getSection (row, [start, end]) {
    return this.board[row].slice(start, end)
  }

  printBoard (output = (...v) => console.log(...v)) {
        for (let i = 0; i < 9; i++) {
      if (i % 3 === 0 && i !== 0) {
        output('- - - - - - - - - - - -')
      }
      output(
        ...this.getSection(i, [0, 3]), ' | ',
        ...this.getSection(i, [3, 6]), ' | ',
        ...this.getSection(i, [6, 9]))
    }
  }
}

export { Sudoku }
/


function validateGrid (grid) {
  if (!Array.isArray(grid) || grid.length === 0) throw new TypeError('Grid must be a non-empty array')

  const allRowsHaveCorrectLength = grid.every(row => row.length === grid.length)
  if (!allRowsHaveCorrectLength) throw new TypeError('Grid must be a square')

  const allCellsHaveValidValues = grid.every(row => {
    return row.every(cell => cell === 0 || cell === 1)
  })
  if (!allCellsHaveValidValues) throw new TypeError('Grid must only contain 0s and 1s')
}

function isSafe (grid, x, y) {
  const n = grid.length
  return x >= 0 && x < n && y >= 0 && y < n && grid[y][x] === 1
}


function getPathPart (grid, x, y, solution, path) {
  const n = grid.length

    if (x === n - 1 && y === n - 1 && grid[y][x] === 1) {
    solution[y][x] = 1
    return path
  }

    if (!isSafe(grid, x, y)) return false

    if (solution[y][x] === 1) return false

  
    solution[y][x] = 1

    const right = getPathPart(grid, x + 1, y, solution, path + 'R')
  if (right) return right

    const down = getPathPart(grid, x, y + 1, solution, path + 'D')
  if (down) return down

    const up = getPathPart(grid, x, y - 1, solution, path + 'U')
  if (up) return up

    const left = getPathPart(grid, x - 1, y, solution, path + 'L')
  if (left) return left

    solution[y][x] = 0
  return false
}

function getPath (grid) {
    const n = grid.length

    const solution = []
  for (let i = 0; i < n; i++) {
    const row = Array(n)
    row.fill(0)
    solution[i] = row
  }

  return getPathPart(grid, 0, 0, solution, '')
}


export class RatInAMaze {
  constructor (grid) {
        validateGrid(grid)

        const solution = getPath(grid)

    if (solution !== false) {
      this.path = solution
      this.solved = true
    } else {
      this.path = ''
      this.solved = false
    }
  }
}
/

class Combinations {
  constructor (n, k) {
    this.n = n
    this.k = k
    this.current = []     this.combinations = []
  }

  findCombinations (high = this.n, total = this.k, low = 1) {
    if (total === 0) {
      this.combinations.push([...this.current])
      return this.combinations
    }
    for (let i = low; i <= high; i++) {
      this.current.push(i)
      this.findCombinations(high, total - 1, i + 1)
      this.current.pop()
    }
    return this.combinations
  }
}

export { Combinations }
/

/
const sumOfSubset = (set, subset, setindex, sum, targetSum) => {
        if (sum === targetSum) return [subset]

      if (sum > targetSum) return []

    let results = []

        set.slice(setindex).forEach((num, index) => {
        const nextSubset = [...subset, num]

            const nextSetIndex = setindex + index + 1

        const nextSum = sum + num

        const subsetResult = sumOfSubset(
      set,
      nextSubset,
      nextSetIndex,
      nextSum,
      targetSum
    )

        results = [...results, ...subsetResult]
  })

    return results
}

export { sumOfSubset }

class OpenKnightTour {
  constructor (size) {
    this.board = new Array(size).fill(0).map(() => new Array(size).fill(0))
    this.size = size
  }

  getMoves ([i, j]) {
        const moves = [
      [i + 2, j - 1],
      [i + 2, j + 1],
      [i - 2, j - 1],
      [i - 2, j + 1],
      [i + 1, j - 2],
      [i + 1, j + 2],
      [i - 1, j - 2],
      [i - 1, j + 2]
    ]

    return moves.filter(([y, x]) => y >= 0 && y < this.size && x >= 0 && x < this.size)
  }

  isComplete () {
        return !this.board.map(row => row.includes(0)).includes(true)
  }

  solve () {
        for (let i = 0; i < this.size; i++) {
      for (let j = 0; j < this.size; j++) {
        if (this.solveHelper([i, j], 0)) return true
      }
    }
    return false
  }

  solveHelper ([i, j], curr) {
        if (this.isComplete()) return true

    for (const [y, x] of this.getMoves([i, j])) {
      if (this.board[y][x] === 0) {
        this.board[y][x] = curr + 1
        if (this.solveHelper([y, x], curr + 1)) return true
                this.board[y][x] = 0
      }
    }
    return false
  }

  printBoard (output = value => console.log(value)) {
        for (const row of this.board) {
      let string = ''
      for (const elem of row) {
        string += elem + '\t'
      }
      output(string)
    }
  }
}

export { OpenKnightTour }
/


export function newGeneration (cells) {
  const nextGeneration = []
  for (let i = 0; i < cells.length; i++) {
    const nextGenerationRow = []
    for (let j = 0; j < cells[i].length; j++) {
            let neighbourCount = 0
      if (i > 0 && j > 0) neighbourCount += cells[i - 1][j - 1]
      if (i > 0) neighbourCount += cells[i - 1][j]
      if (i > 0 && j < cells[i].length - 1) neighbourCount += cells[i - 1][j + 1]
      if (j > 0) neighbourCount += cells[i][j - 1]
      if (j < cells[i].length - 1) neighbourCount += cells[i][j + 1]
      if (i < cells.length - 1 && j > 0) neighbourCount += cells[i + 1][j - 1]
      if (i < cells.length - 1) neighbourCount += cells[i + 1][j]
      if (i < cells.length - 1 && j < cells[i].length - 1) neighbourCount += cells[i + 1][j + 1]

            const alive = cells[i][j] === 1
      if ((alive && neighbourCount >= 2 && neighbourCount <= 3) || (!alive && neighbourCount === 3)) {
        nextGenerationRow.push(1)
      } else {
        nextGenerationRow.push(0)
      }
    }
    nextGeneration.push(nextGenerationRow)
  }
  return nextGeneration
}
import { newGeneration } from '../ConwaysGameOfLife'

describe('newGeneration', () => {
  it('should produce the next generation according to the rules', () => {
    expect(newGeneration([[0, 1, 0], [0, 1, 0], [0, 1, 0]]))
      .toEqual([[0, 0, 0], [1, 1, 1], [0, 0, 0]])
  })
})

export function TowerOfHanoi (n, from, to, aux, output = []) {
  if (n === 1) {
    output.push(`Move disk 1 from rod ${from} to rod ${to}`)
    return output
  }
  TowerOfHanoi(n - 1, from, aux, to, output)
  output.push(`Move disk ${n} from rod ${from} to rod ${to}`)
  TowerOfHanoi(n - 1, aux, to, from, output)
  return output
}


function euclideanGCDRecursive (first, second) {
  /
  if (second === 0) {
    return first
  } else {
    return euclideanGCDRecursive(second, (first % second))
  }
}

function euclideanGCDIterative (first, second) {
  /
  while (second !== 0) {
    const temp = second
    second = first % second
    first = temp
  }
  return first
}

export { euclideanGCDIterative, euclideanGCDRecursive }
import { Vector2, iterate } from './KochSnowflake'


function getKochSnowflake (canvasWidth = 600, steps = 5) {
  if (canvasWidth <= 0) {
    throw new Error('canvasWidth should be greater than zero')
  }

  const offsetX = canvasWidth / 10.0
  const offsetY = canvasWidth / 3.7
  const vector1 = new Vector2(offsetX, offsetY)
  const vector2 = new Vector2(canvasWidth / 2, Math.sin(Math.PI / 3) * canvasWidth * 0.8 + offsetY)
  const vector3 = new Vector2(canvasWidth - offsetX, offsetY)
  const initialVectors = []
  initialVectors.push(vector1)
  initialVectors.push(vector2)
  initialVectors.push(vector3)
  initialVectors.push(vector1)
  const vectors = iterate(initialVectors, steps)
  return drawToCanvas(vectors, canvasWidth, canvasWidth)
}


function drawToCanvas (vectors, canvasWidth, canvasHeight) {
  const canvas = document.createElement('canvas')
  canvas.width = canvasWidth
  canvas.height = canvasHeight

    const ctx = canvas.getContext('2d')
  ctx.beginPath()
  ctx.moveTo(vectors[0].x, vectors[0].y)
  for (let i = 1; i < vectors.length; i++) {
    ctx.lineTo(vectors[i].x, vectors[i].y)
  }
  ctx.stroke()

  return canvas
}

if (typeof window !== 'undefined') {
  const canvas = getKochSnowflake()
  document.body.append(canvas)
}
import { factorial } from '../Factorial'

describe('Factorial', () => {
  it('should return factorial 1 for value "0"', () => {
    expect(factorial(0)).toBe(1)
  })

  it('should return factorial 120 for value "5"', () => {
    expect(factorial(5)).toBe(120)
  })
})
import { fibonacci } from '../FibonacciNumberRecursive'

describe('FibonacciNumberRecursive', () => {
  it('should return 0', () => {
    expect(fibonacci(0)).toBe(0)
  })

  it('should return 1', () => {
    expect(fibonacci(1)).toBe(1)
  })

  it('should return 5', () => {
    expect(fibonacci(5)).toBe(5)
  })

  it('should return 9', () => {
    expect(fibonacci(9)).toBe(34)
  })
})
import { binarySearch } from '../BinarySearch'

describe('BinarySearch', () => {
  const arr = [2, 3, 4, 10, 25, 40, 45, 60, 100, 501, 700, 755, 800, 999]
  const low = 0
  const high = arr.length - 1

  it('should return index 3 for searchValue 10', () => {
    const searchValue = 10
    expect(binarySearch(arr, searchValue, low, high)).toBe(3)
  })

  it('should return index 0 for searchValue 2', () => {
    const searchValue = 2
    expect(binarySearch(arr, searchValue, low, high)).toBe(0)
  })

  it('should return index 13 for searchValue 999', () => {
    const searchValue = 999
    expect(binarySearch(arr, searchValue, low, high)).toBe(13)
  })

  it('should return -1 for searchValue 1', () => {
    const searchValue = 1
    expect(binarySearch(arr, searchValue, low, high)).toBe(-1)
  })

  it('should return -1 for searchValue 1000', () => {
    const searchValue = 1000
    expect(binarySearch(arr, searchValue, low, high)).toBe(-1)
  })
})
import { palindrome } from '../Palindrome'

describe('Palindrome', () => {
  it('expects to return true for palindrome string', () => {
    const isPalindrome = palindrome('madam')
    expect(isPalindrome).toBe(true)
  })

  it('expects to return true for Empty String', () => {
    const isPalindrome = palindrome('')
    expect(isPalindrome).toBe(true)
  })

  it('expects to return false for non-palindrome string', () => {
    const isPalindrome = palindrome('foobar')
    expect(isPalindrome).toBe(false)
  })

  it('Throw Error for Invalid Input', () => {
    expect(() => palindrome(123)).toThrow('Invalid Input')
    expect(() => palindrome(null)).toThrow('Invalid Input')
    expect(() => palindrome(undefined)).toThrow('Invalid Input')
  })
})
import { breadthFirstSearch, depthFirstSearch } from '../FloodFill'

const black = [0, 0, 0]
const green = [0, 255, 0]
const violet = [255, 0, 255]
const white = [255, 255, 255]
const orange = [255, 128, 0]

describe('FloodFill', () => {
  it('should calculate the correct colors using breadth-first approach', () => {
    expect(testBreadthFirst([1, 1], green, orange, [1, 1])).toEqual(orange)
    expect(testBreadthFirst([1, 1], green, orange, [0, 1])).toEqual(violet)
    expect(testBreadthFirst([1, 1], green, orange, [6, 4])).toEqual(white)
  })

  it('should calculate the correct colors using depth-first approach', () => {
    expect(testDepthFirst([1, 1], green, orange, [1, 1])).toEqual(orange)
    expect(testDepthFirst([1, 1], green, orange, [0, 1])).toEqual(violet)
    expect(testDepthFirst([1, 1], green, orange, [6, 4])).toEqual(white)
  })
})


function testBreadthFirst (fillLocation, targetColor, replacementColor, testLocation) {
  const rgbData = generateTestRgbData()
  breadthFirstSearch(rgbData, fillLocation, targetColor, replacementColor)
  return rgbData[testLocation[0]][testLocation[1]]
}


function testDepthFirst (fillLocation, targetColor, replacementColor, testLocation) {  const rgbData = generateTestRgbData()
  depthFirstSearch(rgbData, fillLocation, targetColor, replacementColor)
  return rgbData[testLocation[0]][testLocation[1]]
}


function generateTestRgbData () {
  const layout = [
    [violet, violet, green, green, black, green, green],
    [violet, green, green, black, green, green, green],
    [green, green, green, black, green, green, green],
    [black, black, green, black, white, white, green],
    [violet, violet, black, violet, violet, white, white],
    [green, green, green, violet, violet, violet, violet],
    [violet, violet, violet, violet, violet, violet, violet]
  ]

    const transposed = []
  for (let x = 0; x < layout[0].length; x++) {
    transposed[x] = []
    for (let y = 0; y < layout.length; y++) {
      transposed[x][y] = layout[y][x]
    }
  }

  return transposed
}
import { iterate, Vector2 } from '../KochSnowflake'

describe('KochSnowflake', () => {
  it('should produce the correctly-transformed vectors', () => {
    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[0])
      .toEqual({ x: 0, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[1])
      .toEqual({ x: 1 / 3, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[2])
      .toEqual({ x: 1 / 2, y: Math.sin(Math.PI / 3) / 3 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[3])
      .toEqual({ x: 2 / 3, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[4])
      .toEqual({ x: 1, y: 0 })
  })
})


const palindrome = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Invalid Input')
  }

  if (str.length <= 1) {
    return true
  }

  if (str[0] !== str[str.length - 1]) {
    return false
  } else {
    return palindrome(str.slice(1, str.length - 1))
  }
}

export { palindrome }
/

export const subsequence = (str, seq, low, output = []) => {
  if (low <= str.length && str.length !== 0) {
    output.push(seq)
  }
  for (let i = low; i < str.length; i++) {
    subsequence(str, seq + str[i], i + 1, output)
  }
  return output
}


const neighbors = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]


export function breadthFirstSearch (rgbData, location, targetColor, replacementColor) {
  if (location[0] < 0 ||
    location[0] >= rgbData.length ||
    location[1] < 0 ||
    location[1] >= rgbData[0].length) {
    throw new Error('location should point to a pixel within the rgbData')
  }

  const queue = []
  queue.push(location)

  while (queue.length > 0) {
    breadthFirstFill(rgbData, location, targetColor, replacementColor, queue)
  }
}


export function depthFirstSearch (rgbData, location, targetColor, replacementColor) {
  if (location[0] < 0 ||
    location[0] >= rgbData.length ||
    location[1] < 0 ||
    location[1] >= rgbData[0].length) {
    throw new Error('location should point to a pixel within the rgbData')
  }

  depthFirstFill(rgbData, location, targetColor, replacementColor)
}


function breadthFirstFill (rgbData, location, targetColor, replacementColor, queue) {
  const currentLocation = queue[0]
  queue.shift()

  if (rgbData[currentLocation[0]][currentLocation[1]] === targetColor) {
    rgbData[currentLocation[0]][currentLocation[1]] = replacementColor

    for (let i = 0; i < neighbors.length; i++) {
      const x = currentLocation[0] + neighbors[i][0]
      const y = currentLocation[1] + neighbors[i][1]
      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {
        queue.push([x, y])
      }
    }
  }
}


function depthFirstFill (rgbData, location, targetColor, replacementColor) {
  if (rgbData[location[0]][location[1]] === targetColor) {
    rgbData[location[0]][location[1]] = replacementColor

    for (let i = 0; i < neighbors.length; i++) {
      const x = location[0] + neighbors[i][0]
      const y = location[1] + neighbors[i][1]
      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {
        depthFirstFill(rgbData, [x, y], targetColor, replacementColor)
      }
    }
  }
}



const binarySearch = (arr, searchValue, low = 0, high = arr.length - 1) => {
    if (high < low || arr.length === 0) return -1

  const mid = low + Math.floor((high - low) / 2)

    if (arr[mid] === searchValue) {
    return mid
  }

      if (arr[mid] > searchValue) {
    return binarySearch(arr, searchValue, low, mid - 1)
  }

    return binarySearch(arr, searchValue, mid + 1, high)
}

export { binarySearch }



export class Vector2 {
  constructor (x, y) {
    this.x = x
    this.y = y
  }

  /
  add (vector) {
    const x = this.x + vector.x
    const y = this.y + vector.y
    return new Vector2(x, y)
  }

  /
  subtract (vector) {
    const x = this.x - vector.x
    const y = this.y - vector.y
    return new Vector2(x, y)
  }

  /
  multiply (scalar) {
    const x = this.x * scalar
    const y = this.y * scalar
    return new Vector2(x, y)
  }

  /
  rotate (angleInDegrees) {
    const radians = angleInDegrees * Math.PI / 180
    const ca = Math.cos(radians)
    const sa = Math.sin(radians)
    const x = ca * this.x - sa * this.y
    const y = sa * this.x + ca * this.y
    return new Vector2(x, y)
  }
}


export function iterate (initialVectors, steps) {
  let vectors = initialVectors
  for (let i = 0; i < steps; i++) {
    vectors = iterationStep(vectors)
  }

  return vectors
}


function iterationStep (vectors) {
  const newVectors = []
  for (let i = 0; i < vectors.length - 1; i++) {
    const startVector = vectors[i]
    const endVector = vectors[i + 1]
    newVectors.push(startVector)
    const differenceVector = endVector.subtract(startVector).multiply(1 / 3)
    newVectors.push(startVector.add(differenceVector))
    newVectors.push(startVector.add(differenceVector).add(differenceVector.rotate(60)))
    newVectors.push(startVector.add(differenceVector.multiply(2)))
  }

  newVectors.push(vectors[vectors.length - 1])
  return newVectors
}
/

export const binaryEquivalent = (num) => {
  if (num === 0 || num === 1) {
    return String(num)
  }
  return binaryEquivalent(Math.floor(num / 2)) + String(num % 2)
}


const factorial = (n) => {
  if (n === 0) {
    return 1
  }
  return n * factorial(n - 1)
}

export { factorial }



const fibonacci = (n) => {
  if (n < 2) {
    return n
  }
  return fibonacci(n - 2) + fibonacci(n - 1)
}

export { fibonacci }

const haversineDistance = (latitude1 = 0, longitude1 = 0, latitude2 = 0, longitude2 = 0) => {
  validateLatOrLong(latitude1)
  validateLatOrLong(latitude2)
  validateLatOrLong(longitude1)
  validateLatOrLong(longitude2)
  const earthRadius = 6371e3   const pi = Math.PI
  const cos1 = latitude1 * pi / 180.0
  const cos2 = latitude2 * pi / 180.0
  const deltaLatitude = (latitude2 - latitude1) * pi / 180.0
  const deltaLongitude = (longitude2 - longitude1) * pi / 180.0

  const alpha = Math.sin(deltaLatitude / 2) * Math.sin(deltaLatitude / 2) + Math.cos(cos1) * Math.cos(cos2) * Math.sin(deltaLongitude / 2) * Math.sin(deltaLongitude / 2)
  const constant = 2 * Math.atan2(Math.sqrt(alpha), Math.sqrt(1 - alpha))
  return earthRadius * constant
}

const validateLatOrLong = value => {
  if (typeof value !== 'number') {
    throw new TypeError('The value of latitude or longitude should be a number')
  }
}

export { haversineDistance }
import { haversineDistance } from '../Haversine'

describe('Testing the haversine distance calculator', () => {
  it('Calculate distance', () => {
    const distance = haversineDistance(64.1265, -21.8174, 40.7128, -74.0060)
    expect(distance).toBe(4208198.758424171)
  })
  it('Test validation, expect throw', () => {
    expect(() => haversineDistance(64.1265, -21.8174, 40.7128, '74.0060')).toThrow()
  })
})



const getNumOfDivisors = (num) => {
    let numberOfDivisors = 0

      const sqrtNum = Math.sqrt(num)
  for (let i = 0; i <= sqrtNum; i++) {
        if (num % i === 0) {
      if (i === sqrtNum) {
                numberOfDivisors++
      } else {
                numberOfDivisors += 2
      }
    }
  }
  return numberOfDivisors
}


const firstTriangularWith500Divisors = () => {
  let triangularNum
    for (let n = 1; ; n++) {
        triangularNum = (1 / 2) * n * (n + 1)
    if (getNumOfDivisors(triangularNum) >= 500) return triangularNum
  }
}

export { firstTriangularWith500Divisors }
const SQ5 = 5 ** 0.5 const PHI = (1 + SQ5) / 2 
export const EvenFibonacci = (limit) => {
  const highestIndex = Math.floor(Math.log(limit * SQ5) / Math.log(PHI))
  const n = Math.floor(highestIndex / 3)
  return ((PHI ** (3 * n + 3) - 1) / (PHI ** 3 - 1) -
    ((1 - PHI) ** (3 * n + 3) - 1) / ((1 - PHI) ** 3 - 1)) / SQ5
}



const powerDigitSum = function (n = 2, pow = 1000) {
    
  const digits = [n]
  let p = 1

  while (++p <= pow) {
    let carry = 0
    for (let exp = 0; exp < digits.length; exp++) {
      const prod = digits[exp] * n + carry
      carry = Math.floor(prod / 10)
      digits[exp] = prod % 10
    }
    while (carry > 0) {
      digits.push(carry % 10)
      carry = Math.floor(carry / 10)
    }
  }

  
  return digits.reduce((prev, current) => prev + current, 0)
}

export { powerDigitSum }

export const squareDifference = (num = 100) => {
  let sumOfSquares = 0
  let sums = 0
  for (let i = 1; i <= num; i++) {
    sumOfSquares += i ** 2     sums += i   }
  return (sums ** 2) - sumOfSquares }




function sumOfNonAbundantNumbers (n = 28123) {
  const abundantNumbers = []   const sumOfAbundantNumbers = {}   let sum = 0

  for (let i = 1; i <= n; i++) {
    if (isAbundant(i)) {
      abundantNumbers.push(i)       abundantNumbers.forEach(num => {         const sum = num + i
        sumOfAbundantNumbers[sum] = true
      })
    }
  }

  for (let i = 1; i <= n; i++) {
    if (!sumOfAbundantNumbers[i]) {       sum += i
    }
  }

  return sum
}



function isAbundant (number) {
  let sum = 0
  for (let i = 1; i <= number / 2; i++) {
    if (number % i === 0) {       sum += i     }
  }
  return sum > number
}

export { sumOfNonAbundantNumbers }
import { firstTriangularWith500Divisors } from '../Problem012'

describe('checkFirstTriangularWith500Divisors()', () => {
  it('Problem Statement Answer', () => {
    const firstTriangular = firstTriangularWith500Divisors()
    expect(firstTriangular).toBe(76576500)
  })
})
import { fibonacciIndex } from '../Problem025'

describe('Check Problem 25 - 1000 digit Fibonnaci number', () => {
  it('First term of the Fibonnaci sequence containing 3 digits', () => {
    expect(fibonacciIndex(3)).toBe(12)
  })

  it('First term of the Fibonnaci sequence containing 10 digits', () => {
    expect(fibonacciIndex(10)).toBe(45)
  })

  it('First term of the Fibonnaci sequence containing 50 digits', () => {
    expect(fibonacciIndex(50)).toBe(237)
  })

  it('First term of the Fibonnaci sequence containing 100 digits', () => {
    expect(fibonacciIndex(100)).toBe(476)
  })

  it('First term of the Fibonnaci sequence containing 1000 digits', () => {
    expect(fibonacciIndex(1000)).toBe(4782)
  })

  it('First term of the Fibonnaci sequence containing 10000 digits', () => {
    expect(fibonacciIndex(10000)).toBe(47847)
  })
})
import { largestAdjacentNumber } from '../Problem008'

const grid1 = `73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
38991007832084782777189757278819047278899274961949
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
82834772897718748193457134085784719857638187485919
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
83247832478757285710958372981577583275832789327921
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
84327878357761783787589375857378271083787811983779
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
82347875831098357801578571807585817518287829189189`

const grid2 = `73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450`

const grid3 = `89125732138957892357892768971807934878999818278898
48327483578957875827583295789187588875238579887789
74358275778171870973857835738758275210873583758279
81347834738473878758758373857893758787772897580719
81232847857895758758987587501087575387538183787098
17047878395783578750837100983787587582797837508298
42894789325732857893759187987487489748377578791989
82147328972387832578327581919827382758932789798289
83243289473847328974832947832748932472387895738978
84738294738973289578753287582375238957573297892398
29383748329748397483274832748327477575018978975289
48327483758375846372864736476478364783647463278787
73281473847832974328758975890189373857875875895898
74328978748329789357389578329758329758937893758979
81738957389579287598217589127589375893275987359889
71890743894732897510875895783297591085738975837897
10783974839479879857895789758975981735870175835789
01494787857897583758975849758475107589754897589789
09939858758919788017587897587387585775289757982898
74718478978758758975897589789789798789178957789789`

const grid4 = `99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999`

describe('checkLargestAdjacentNumberProduct', () => {
  it('Random Example', () => {
    const RESULT = largestAdjacentNumber(grid1, 13)
    expect(RESULT).toBe(23514624000)
  })
  it('Problem statement Example', () => {
    const RESULT = largestAdjacentNumber(grid2, 13)
    expect(RESULT).toBe(23514624000)
  })
  it('Random Example 2', () => {
    const RESULT = largestAdjacentNumber(grid3, 13)
    expect(RESULT).toBe(580717154304)
  })
  it('Example with all 9', () => {
    const RESULT = largestAdjacentNumber(grid4, 13)
    expect(RESULT).toBe(2541865828329)
  })
})
import { maxPathSum } from '../Problem018'

const example = `
3
7 4
2 4 6
8 5 9 3
`

describe('Check Problem 18 - Maximum path sum I', () => {
  it('Check example', () => {
    expect(maxPathSum(example)).toBe(23)
  })

  it('Check solution', () => {
    expect(maxPathSum()).toBe(1074)
  })
})
import { calculateSumOfPrimeNumbers } from '../Problem010'

describe('checkAnagram', () => {
  it('Return the sum of prime numbers up to but less than 14', () => {
    const SUT = calculateSumOfPrimeNumbers(14)
    expect(SUT).toBe(41)
  })
  it('Return the sum of prime numbers up to but less than 10', () => {
    const SUT = calculateSumOfPrimeNumbers(10)
    expect(SUT).toBe(17)
  })
  it('Return the sum of prime numbers up to but less than 100', () => {
    const SUT = calculateSumOfPrimeNumbers(100)
    expect(SUT).toBe(1060)
  })
})
import { sumOfNonAbundantNumbers } from '../Problem023'

describe('Check Problem 23 - Non-Abundant Sums', () => {
  it('Sum of all positive integers <= 10000 which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(10000)).toBe(3731004)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(15000)).toBe(4039939)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(20000)).toBe(4159710)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(28123)).toBe(4179871)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(30000)).toBe(4179871)
  })
})
import { powerDigitSum } from '../Problem016'

describe('Check Problem 16 - Power digit sum', () => {
  it('Power digit sum of 2^15', () => {
    expect(powerDigitSum(2, 15)).toBe(26)
  })

  it('Power digit sum of 2^1000', () => {
    expect(powerDigitSum()).toBe(1366)
    expect(powerDigitSum(2, 1000)).toBe(1366)
  })

  it('Power digit sum of 3^5000', () => {
    expect(powerDigitSum(3, 5000)).toBe(11097)
  })
})
import { factorialDigitSum } from '../Problem020'

describe('Check Problem 20 - Factorial digit sum', () => {
  it('Factorial digit sum of 10!', () => {
    expect(factorialDigitSum(10)).toBe(27)
  })

  it('Factorial digit sum of 100!', () => {
    expect(factorialDigitSum()).toBe(648)
    expect(factorialDigitSum(100)).toBe(648)
  })

  it('Factorial digit sum of 1000!', () => {
    expect(factorialDigitSum(1000)).toBe(10539)
  })
})

export const largestPrime = (num = 600851475143) => {
  let newnumm = num
  let largestFact = 0
  let counter = 2
  while (counter * counter <= newnumm) {
    if (newnumm % counter === 0) {
      newnumm = newnumm / counter
    } else {
      counter++
    }
  }
  if (newnumm > largestFact) {
    largestFact = newnumm
  }
  return largestFact
}




const triangle = `
75
95 64
17 47 82
18 35 87 10
20 04 82 47 65
19 01 23 75 03 34
88 02 77 73 07 63 67
99 65 04 28 06 16 70 92
41 41 26 56 83 40 80 70 33
41 48 72 33 47 32 37 16 94 29
53 71 44 65 25 43 91 52 97 51 14
70 11 33 28 77 73 17 78 39 68 17 57
91 71 52 38 17 14 91 43 58 50 27 29 48
63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
`

export const maxPathSum = function (grid = triangle) {
  /

  grid = grid.split(/\r\n|\n/).filter(l => l).map(r => r.split(' ').map(n => +n))

  for (let i = grid.length - 2; i >= 0; i--) {
    for (let j = 0; j < grid[i].length; j++) {
      grid[i][j] += Math.max(grid[i + 1][j], grid[i + 1][j + 1])
    }
  }

  return grid[0][0]
}

const largestAdjacentNumber = (grid, consecutive) => {
  grid = grid.split('\n').join('')
  const splitedGrid = grid.split('\n')
  let largestProd = 0

  for (const row in splitedGrid) {
    const currentRow = splitedGrid[row].split('').map(x => Number(x))

    for (let i = 0; i < currentRow.length - consecutive; i++) {
      const combine = currentRow.slice(i, i + consecutive)

      if (!combine.includes(0)) {
        const product = combine.reduce(function (a, b) {
          return a * b
        })

        if (largestProd < product) largestProd = product
      }
    }
  }
  return largestProd
}

export { largestAdjacentNumber }
/

const isPythagoreanTriplet = (a, b, c) => Math.pow(a, 2) + Math.pow(b, 2) === Math.pow(c, 2)

export const findSpecialPythagoreanTriplet = () => {
  for (let a = 0; a < 1000; a++) {
    for (let b = a + 1; b < 1000; b++) {
      for (let c = b + 1; c < 1000; c++) {
        if (isPythagoreanTriplet(a, b, c) && a + b + c === 1000) {
          return a * b * c
        }
      }
    }
  }
}
/

const getCollatzSequenceLength = (num, seqLength) => {
  if (num === 1) {
    return seqLength
  } else {
    let newElement
    if (num % 2 === 0) {
      newElement = num / 2
    } else {
      newElement = (3 * num) + 1
    }
    seqLength++
    return getCollatzSequenceLength(newElement, seqLength)
  }
}

export const findLongestCollatzSequence = (limit = 1000000) => {
  let startingPointForLargestSequence = 1
  let largestSequenceLength = 1
  for (let i = 2; i < limit; i++) {
    const currentSequenceLength = getCollatzSequenceLength(i, 1)
    if (currentSequenceLength > largestSequenceLength) {
      startingPointForLargestSequence = i
      largestSequenceLength = currentSequenceLength
    }
  }
  return startingPointForLargestSequence
}


const factorialDigitSum = (n = 100) => {
    const digits = [1]

  for (let x = 2; x <= n; x++) {
    let carry = 0
    for (let exp = 0; exp < digits.length; exp++) {
      const prod = digits[exp] * x + carry
      carry = Math.floor(prod / 10)
      digits[exp] = prod % 10
    }
    while (carry > 0) {
      digits.push(carry % 10)
      carry = Math.floor(carry / 10)
    }
  }

  
  return digits.reduce((prev, current) => prev + current, 0)
}

export { factorialDigitSum }
/
export const largestPalindromic = (digits) => {
  let i
  let n
  let m
  let d
  let limit
  let number = 0

  for (i = 1; i < digits; i++) {
    number = 10 * number + 9
  }
  const inf = number   const sup = 10 * number + 9 
  const isPalindromic = (n) => {
    let p = 0
    const q = n
    let r
    while (n > 0) {
      r = n % 10
      p = 10 * p + r
      n = Math.floor(n / 10)
    }
    return p === q   }

  for (n = sup * sup, m = inf * inf; n > m; n--) {
    if (isPalindromic(n)) {
      limit = Math.ceil(Math.sqrt(n))
      d = sup
      while (d >= limit) {
        if (n % d === 0 && n / d > inf) {
          return n
        }
        d -= 1
      }
    }
  }
  return NaN }

const isPrime = (number) => {
  if (number === 2) return true
  if (number % 2 === 0) return false

  for (let j = 3; j * j <= number; j += 2) {
    if (number % j === 0) {
      return false
    }
  }
  return true
}

const calculateSumOfPrimeNumbers = (maxNumber) => {
  let sum = 0
  for (let i = maxNumber - 1; i >= 2; i--) {
    if (isPrime(parseInt(i)) === true) {
      sum += i
    }
  }
  return sum
}
export { calculateSumOfPrimeNumbers }



function fibonacciIndex (t = 1000) {
  const digits = 10n ** BigInt(t - 1)
  let fib0 = BigInt(0)
  let fib1 = BigInt(1)
  let index = 1
  while (fib1 < digits) {     const tempfib = fib1
    fib1 = fib1 + fib0
    fib0 = tempfib
    index += 1
  }
  return (index)
}

export { fibonacciIndex }
/

const multiplesThreeAndFive = (num) => {
  let total = 0
    for (let i = 0; i < num; i++) {
    if (i % 3 === 0 || i % 5 === 0) {
      total += i
    }
  }
  return total
}

export { multiplesThreeAndFive }
/


export const latticePath = (gridSize) => {
  let paths
  for (let i = 1, paths = 1; i <= gridSize; i++) {
    paths = paths * (gridSize + i) / i
  }
    return paths
}

/

export const findSmallestMultiple = () => {
  const divisors = [20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]
  let num = 21
  let result

  while (!result) {
    const isDivisibleByAll = divisors.every((divisor) => num % divisor === 0)
    if (isDivisibleByAll) result = num
    else num++
  }

  return result
}


function slidingWindow (arr, num) {
      if (arr.length < num) return null
    let maxSum = 0
    let tempSum = 0
    for (let i = 0; i < num; i++) {
    maxSum += arr[i]
  }
    tempSum = maxSum
    for (let i = num; i < arr.length; i++) {
        tempSum = tempSum - arr[i - num] + arr[i]
        maxSum = Math.max(maxSum, tempSum)
  }
  return maxSum
}

export { slidingWindow }


function binarySearch (arr, value, floor, ceiling) {
    const mid = Math.floor((floor + ceiling) / 2)

    if (arr[mid] === value) {
    return mid
  }

  if (floor > ceiling) return -1

      if (arr[mid] > value) {
    return binarySearch(arr, value, floor, mid - 1)
          } else {
    return binarySearch(arr, value, mid + 1, ceiling)
  }
}

function exponentialSearch (arr, length, value) {
    if (arr[0] === value) {
    return 0
  }

    let i = 1
  while (i < length && arr[i] <= value) {
    i = i * 2
  }

    return binarySearch(arr, value, i / 2, Math.min(i, length))
}

export { binarySearch, exponentialSearch }

import { exponentialSearch } from '../ExponentialSearch'

test('The Exponential Search of the Array [2, 3, 4, 10, 40, 65, 78, 100] is 6 where the value = 78', () => {
  const arr = [2, 3, 4, 10, 40, 65, 78, 100]
  const value = 78
  const result = exponentialSearch(arr, arr.length, value)
  expect(result).toEqual(6)
})

test('The Exponential Search of the Array [2, 3, 4, 10, 40, 65, 78, 100] is -1 where the value = 178', () => {
  const arr = [2, 3, 4, 10, 40, 65, 78, 100]
  const value = 178
  const result = exponentialSearch(arr, arr.length, value)
  expect(result).toEqual(-1)
})
import { ternarySearchRecursive, ternarySearchIterative } from '../TernarySearch'

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)
  expect(indexNumber).toBe(2)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 8)
  expect(indexNumber).toBe(7)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0)
  expect(indexNumber).toBe(-1)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 12)
  expect(indexNumber).toBe(-1)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Cathrynli')
  expect(indexNumber).toBe(1)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Josuke')
  expect(indexNumber).toBe(2)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Angela')
  expect(indexNumber).toBe(-1)
})
import { binarySearchIterative, binarySearchRecursive } from '../BinarySearch'

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const stringArr = [
  'Alpha',
  'Bravo',
  'Charlie',
  'Delta',
  'Echo',
  'Foxtrot',
  'Golf',
  'Hotel',
  'India',
  'Juliet',
  'Kilo',
  'Lima',
  'Mike',
  'November',
  'Oscar',
  'Papa',
  'Quebec',
  'Romeo',
  'Sierra',
  'Tango',
  'Uniform',
  'Victor',
  'Whiskey',
  'X-Ray',
  'Yankee',
  'Zulu'
]

describe('Binary Search', () => {
  const funcs = [binarySearchIterative, binarySearchRecursive]
  for (const func of funcs) {
    test('expect to return the index of the item in the array', () => {
      expect(func(arr, 3)).toBe(2)
    })
    test('expect to return -1 if not in array', () => {
      expect(func(arr, 11)).toBe(-1)
    })
    test('expect to return the index of the item in the array', () => {
      expect(func(stringArr, 'Charlie')).toBe(2)
    })
    test('expect to return -1 if not in array', () => {
      expect(func(stringArr, 'Zoft')).toBe(-1)
    })
  }
})
import { UnionFind } from '../UnionFind'

const uf = new UnionFind(5)

test('should expose .size():', () => {
  const size = uf.size()
  expect(size).toBe(5)
})

test('should do .union(num1, num2):', () => {
  uf.union(1, 2)
  uf.union(3, 4)
  uf.union(0, 4)
  expect(uf.connected(1, 2)).toBe(true)
  expect(uf.connected(1, 2)).toBe(true)

  expect(uf.connected(3, 4)).toBe(true)
  expect(uf.connected(3, 0)).toBe(true)
  expect(uf.connected(4, 0)).toBe(true)

  expect(uf.connected(1, 3)).toBe(false)
  expect(uf.connected(1, 4)).toBe(false)
  expect(uf.connected(1, 0)).toBe(false)
  expect(uf.connected(2, 3)).toBe(false)
  expect(uf.connected(2, 4)).toBe(false)
  expect(uf.connected(2, 0)).toBe(false)
})

test('.count(), should return the number of disparate groups:', () => {
  expect(uf.count()).toBe(2)
})

test('should check if two components are connected, .connected(num1, num2):', () => {
  expect(uf.connected(1, 2)).toBe(true)
  expect(uf.connected(1, 3)).toBe(false)
})

test('should find the root of the tree in which the given element lives, .find(num):', () => {
  expect(uf.find(1)).toBe(1)
  expect(uf.find(2)).toBe(1)
  expect(uf.find(3)).toBe(3)
  expect(uf.find(4)).toBe(3)
  expect(uf.find(0)).toBe(3)
})

test('should always change the id of the smaller tree and preserve the id of the larger one', () => {
  uf.union(2, 3)
  expect(uf.count()).toBe(1)
  expect(uf.find(0)).toBe(3)
  expect(uf.find(1)).toBe(3)
  expect(uf.find(2)).toBe(3)
  expect(uf.find(3)).toBe(3)
  expect(uf.find(4)).toBe(3)
})
import { slidingWindow } from '../SlidingWindow'

test('expect to return the largest sum of sequence in the array', () => {
  const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 2)
  expect(sum).toBe(10)
})

test('expect to return the largest sum of sequence in the array', () => {
  const sum = slidingWindow([5, 2, 6, 9], 3)
  expect(sum).toBe(17)
})

test('expect to return null when the sequence size is larger then the array length', () => {
  const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 15)
  expect(sum).toBe(null)
})
/
export function quickSelectSearch (array, k) {
  if (!array || array.length <= k) {
    throw new Error('Invalid arguments')
  }

  let from = 0
  let to = array.length - 1
  while (from < to) {
    let left = from
    let right = to
    const pivot = array[Math.ceil((left + right) * 0.5)]

    while (left < right) {
      if (array[left] >= pivot) {
        const tmp = array[left]
        array[left] = array[right]
        array[right] = tmp
        --right
      } else {
        ++left
      }
    }

    if (array[left] > pivot) {
      --left
    }

    if (k <= left) {
      to = left
    } else {
      from = left + 1
    }
  }
  return array
}

/

/
function SearchArray (searchNum, ar, output = v => console.log(v)) {
  const position = Search(ar, searchNum)
  if (position !== -1) {
    output('The element was found at ' + (position + 1))
  } else {
    output('The element not found')
  }
}

function Search (theArray, key) {
  for (let n = 0; n < theArray.length; n++) {
    if (theArray[n] === key) { return n }
  }
  return -1
}

export { SearchArray, Search }

/

function makeTable (str) {
      const table = new Array(str.length)
  let maxPrefix = 0
    table[0] = 0

    for (let i = 1; i < str.length; i++) {
        while (maxPrefix > 0 && str.charAt(i) !== str.charAt(maxPrefix)) {
                  maxPrefix = table[maxPrefix - 1]
    }
        if (str.charAt(maxPrefix) === str.charAt(i)) {
                                          maxPrefix++
          }
    table[i] = maxPrefix
  }
  return table
}

export function stringSearch (str, word) {
    const prefixes = makeTable(word)
  const matches = []

    let j = 0
    let i = 0
  while (i < str.length) {
        if (str.charAt(i) === word.charAt(j)) {
      i++
      j++
    }
                                                if (j === word.length) {
      matches.push(i - j)
      j = prefixes[j - 1]
                } else if (str.charAt(i) !== word.charAt(j)) {
            if (j !== 0) {
        j = prefixes[j - 1]
      } else {
                i++
      }
    }
  }

  return matches
}

/

const jumpSearch = (arr, value) => {
  const length = arr.length
  let step = Math.floor(Math.sqrt(length))
  let lowerBound = 0
  while (arr[Math.min(step, length) - 1] < value) {
    lowerBound = step
    step += step
    if (lowerBound >= length) {
      return -1
    }
  }

  const upperBound = Math.min(step, length)
  while (arr[lowerBound] < value) {
    lowerBound++
    if (lowerBound === upperBound) {
      return -1
    }
  }
  if (arr[lowerBound] === value) {
    return lowerBound
  }
  return -1
}
const arr = [0, 0, 4, 7, 10, 23, 34, 40, 55, 68, 77, 90]
jumpSearch(arr, 4)
jumpSearch(arr, 34)
jumpSearch(arr, 77)

function UnionFind (n, key) {
  if (!(this instanceof UnionFind)) return new UnionFind(n)
  if (key && typeof key !== 'function') {
    throw new Error('key has to be a function or else left undefined')
  }
  let cnt, length
      key = key || function (a) { return a }
  cnt = length = n
  const id = new Array(n)
  const sz = new Array(n)
  for (let i = 0; i < n; i++) {
    id[i] = i
    sz[i] = 1
  }
    this.size = function () {
    return length
  }
    this.count = function () {
    return cnt
  }
    this.find = function (p) {
    p = key(p)
    while (p !== id[p]) {
      id[p] = id[id[p]]
      p = id[p]
    }
    return p
  }
    this.connected = function (p, q) {
    p = key(p)
    q = key(q)
    ensureIndexWithinBounds(p, q)
    return this.find(p) === this.find(q)
  }
    this.union = function (p, q) {
    p = key(p)
    q = key(q)
    ensureIndexWithinBounds(p, q)
    const i = this.find(p)
    const j = this.find(q)
    if (i === j) return
    if (sz[i] < sz[j]) {
      id[i] = j; sz[j] += sz[i]
    } else {
      id[j] = i; sz[i] += sz[j]
    }
    cnt--
  }
  function ensureIndexWithinBounds (args) {
    for (let i = arguments.length - 1; i >= 0; i--) {
      const p = arguments[i]
      if (p >= length) throw new Error('Index out of bounds. The maximum index can be length-1')
    }
  }
}

export { UnionFind }
/

function binarySearchRecursive (arr, x, low = 0, high = arr.length - 1) {
  const mid = Math.floor(low + (high - low) / 2)

  if (high >= low) {
    if (arr[mid] === x) {
            return mid
    }

    if (x < arr[mid]) {
            return binarySearchRecursive(arr, x, low, mid - 1)
    } else {
            return binarySearchRecursive(arr, x, mid + 1, high)
    }
  } else {
        return -1
  }
}
function binarySearchIterative (arr, x, low = 0, high = arr.length - 1) {
  while (high >= low) {
    const mid = Math.floor(low + (high - low) / 2)

    if (arr[mid] === x) {
            return mid
    }

    if (x < arr[mid]) {
            high = mid - 1
    } else {
            low = mid + 1
    }
  }
    return -1
}

export { binarySearchIterative, binarySearchRecursive }


export function interpolationSearch (arr, key) {
  const length = arr.length - 1
  let low = 0
  let high = length
  let position = -1
  let delta = -1

    while (low <= high && key >= arr[low] && key <= arr[high]) {
    delta = (key - arr[low]) / (arr[high] - arr[low])
    position = low + Math.floor((high - low) * delta)

        if (arr[position] === key) {
      return position
    }

        if (arr[position] < key) {
      low = position + 1
          } else {
      high = position - 1
    }
  }

  return -1
}


/

function ternarySearchRecursive (arr, key, low = 0, high = arr.length - 1) {
  if (high >= low) {
        const mid1 = Math.floor(low + (high - low) / 3)
    const mid2 = Math.floor(high - (high - low) / 3)

        if (arr[mid1] === key) {
            return mid1
    }
    if (arr[mid2] === key) {
            return mid2
    }

                    if (key < arr[mid1]) {
            return ternarySearchRecursive(arr, key, low, mid1 - 1)
    } else if (key > arr[mid2]) {
            return ternarySearchRecursive(arr, key, mid2 + 1, high)
    } else {
            return ternarySearchRecursive(arr, key, mid1 + 1, mid2 - 1)
    }
  } else {
        return -1
  }
}

function ternarySearchIterative (arr, key, low = 0, high = arr.length - 1) {
  while (high >= low) {
        const mid1 = Math.floor(low + (high - low) / 3)
    const mid2 = Math.floor(high - (high - low) / 3)

        if (arr[mid1] === key) {
            return mid1
    }
    if (arr[mid2] === key) {
            return mid2
    }

                    if (key < arr[mid1]) {
            high = mid1 - 1
    } else if (key > arr[mid2]) {
            low = mid2 + 1
    } else {
            low = mid1 + 1
      high = mid2 - 1
    }
  }
    return -1
}

export { ternarySearchRecursive, ternarySearchIterative }


export const fibonacciSearch = (arr, x, n) => {
  let fib2 = 0   let fib1 = 1   let fibK = fib2 + fib1 
  /
  while (fibK < n) {
    fib2 = fib1
    fib1 = fibK
    fibK = fib2 + fib1
  }
    let offset = -1

  /

  while (fibK > 1) {
        const i = Math.min(offset + fib2, n - 1)

    /
    if (arr[i] < x) {
      fibK = fib1
      fib1 = fib2
      fib2 = fibK - fib1
      offset = i
      /
    } else if (arr[i] > x) {
      fibK = fib2
      fib1 = fib1 - fib2
      fib2 = fibK - fib1
    } else {
          return i
    }
  }

    if (fib1 && arr[offset + 1] === x) {
    return offset + 1
  }
    return -1
}


const fibonacci = (N) => {
  if (!Number.isInteger(N)) {
    throw new TypeError('Input should be integer')
  }

    let firstNumber = 0
  let secondNumber = 1

  for (let i = 1; i < N; i++) {
    const sumOfNumbers = firstNumber + secondNumber
        firstNumber = secondNumber
    secondNumber = sumOfNumbers
  }

  return N ? secondNumber : firstNumber
}

export { fibonacci }
/
/
function NumberOfSubsetSum (array, sum) {
  const dp = []   for (let i = 1; i <= sum; i++) {
    dp[i] = 0
  }
  dp[0] = 1 
  for (let i = 0; i < array.length; i++) {
    for (let j = sum; j >= array[i]; j--) {
      if (j - array[i] >= 0) {
        dp[j] += dp[j - array[i]]
      }
    }
  }
  return dp[sum]
}



export { NumberOfSubsetSum }
/

const minimumEditDistance = (word1, word2) => {
  const n = word1.length
  const m = word2.length
  const dp = new Array(m + 1).fill(0).map(item => [])

  /

  for (let i = 0; i < n + 1; i++) {
    dp[0][i] = i
  }

  for (let i = 0; i < m + 1; i++) {
    dp[i][0] = i
  }

  /

  for (let i = 1; i < m + 1; i++) {
    for (let j = 1; j < n + 1; j++) {
      const letter1 = word1[j - 1]
      const letter2 = word2[i - 1]

      if (letter1 === letter2) {
        dp[i][j] = dp[i - 1][j - 1]
      } else {
        dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1
      }
    }
  }

  return dp[m][n]
}

export { minimumEditDistance }
/
function shuf (datasetSource, sampleSize) {
  const output = fillBaseSample(datasetSource, sampleSize)

  return randomizeOutputFromDataset(datasetSource, output)
}


function fillBaseSample (datasetSource, sampleSize) {
  let filledIndexes = []
  let output = new Array(sampleSize)

    while (true) {
    const iterator = datasetSource.next()
    if (iterator.done) break

    let insertTo = Math.floor(Math.random() * output.length)
    while (filledIndexes.includes(insertTo)) {
      insertTo++
      if (insertTo === output.length) {
        insertTo = 0
      }
    }
    output[insertTo] = {
      value: iterator.value
    }

    filledIndexes = [...filledIndexes, insertTo]

    if (filledIndexes.length === sampleSize) {
      break
    }
  }

  if (filledIndexes.length < output.length) {
        output = output.filter((_, i) => filledIndexes.includes(i))
  }

  return output.map((o) => o.value)
}


function randomizeOutputFromDataset (datasetSource, output) {
  const newOutput = [...output]
  let readSoFar = output.length

  while (true) {
    const iterator = datasetSource.next()
    if (iterator.done) break
    readSoFar++

    const insertTo = Math.floor(Math.random() * readSoFar)
    if (insertTo < newOutput.length) {
      newOutput[insertTo] = iterator.value
    }
  }

  return newOutput
}



function * generateRandomData (length) {
  const maxValue = Math.pow(2, 31) - 1
  for (let i = 0; i < length; i++) {
    yield Math.floor(Math.random() * maxValue)
  }
}


export { shuf, generateRandomData }
import { PermutationinString } from '../PermutationinString.js'

describe('PermutationinString', () => {
  it("should  return true if one of s1's permutations is the substring of s2", () => {
    expect(PermutationinString('ab', 'eidbaooo')).toEqual(true)
    expect(PermutationinString('abc', 'bcab')).toEqual(true)
    expect(PermutationinString('ab', 'eidboaoo')).toEqual(false)
    expect(PermutationinString('abc', '')).toEqual(false)
  })
})
import { LongestSubstringWithoutRepeatingCharacters } from '../LongestSubstringWithoutRepeatingCharacters.js'

describe('LongestSubstringWithoutRepeatingCharacters', () => {
  it('should return longest substring without repeating characters', () => {
    expect(LongestSubstringWithoutRepeatingCharacters('abcabcbb')).toEqual(3)
    expect(LongestSubstringWithoutRepeatingCharacters('bbbbb')).toEqual(1)
    expect(LongestSubstringWithoutRepeatingCharacters('pwwkew')).toEqual(3)
    expect(LongestSubstringWithoutRepeatingCharacters('a')).toEqual(1)
    expect(LongestSubstringWithoutRepeatingCharacters('')).toEqual(0)
  })
})



export function PermutationinString (s1, s2) {
  if (s1.length > s2.length) return false
  let start = 0
  let end = s1.length - 1
  const s1Set = SetHash()
  const s2Set = SetHash()
  for (let i = 0; i < s1.length; i++) {
    s1Set[s1[i]]++
    s2Set[s2[i]]++
  }
  if (equals(s1Set, s2Set)) return true
  while (end < s2.length - 1) {
    if (equals(s1Set, s2Set)) return true
    end++
    const c1 = s2[start]
    const c2 = s2[end]
    if (s2Set[c1] > 0) s2Set[c1]--
    s2Set[c2]++
    start++
    if (equals(s1Set, s2Set)) return true
  }
  return false
}
function equals (a, b) {
  return JSON.stringify(a) === JSON.stringify(b)
}

function SetHash () {
  const set = new Set()
  const alphabets = 'abcdefghijklmnopqrstuvwxyz'
  for (let i = 0; i < alphabets.length; i++) {
    set[alphabets[i]] = 0
  }
  return set
}





export function LongestSubstringWithoutRepeatingCharacters (s) {
  let maxLength = 0
  let start = 0
  let end = 0
  const map = {}
  while (end < s.length) {
    if (map[s[end]] === undefined) {
      map[s[end]] = 1
      maxLength = Math.max(maxLength, end - start + 1)
      end++
    } else {
      while (s[start] !== s[end]) {
        delete map[s[start]]
        start++
      }
      delete map[s[start]]
      start++
    }
  }
  return maxLength
}





const zeroOneKnapsack = (arr, n, cap, cache) => {
  if (cap === 0 || n === 0) {
    cache[n][cap] = 0
    return cache[n][cap]
  }
  if (cache[n][cap] !== -1) {
    return cache[n][cap]
  }
  if (arr[n - 1][0] <= cap) {
    cache[n][cap] = Math.max(arr[n - 1][1] + zeroOneKnapsack(arr, n - 1, cap - arr[n - 1][0], cache), zeroOneKnapsack(arr, n - 1, cap, cache))
    return cache[n][cap]
  } else {
    cache[n][cap] = zeroOneKnapsack(arr, n - 1, cap, cache)
    return cache[n][cap]
  }
}

const example = () => {
  /
  let input = `1
    4 5
    1 8
    2 4
    3 0
    2 5
    2 3`

  input = input.trim().split('\n')
  input.shift()
  const length = input.length

  const output = []

  let i = 0
  while (i < length) {
    const cap = Number(input[i].trim().split(' ')[0])
    const currlen = Number(input[i].trim().split(' ')[1])
    let j = i + 1
    const arr = []
    while (j <= i + currlen) {
      arr.push(input[j])
      j++
    }
    const newArr = arr.map(e =>
      e.trim().split(' ').map(Number)
    )
    const cache = []
    for (let i = 0; i <= currlen; i++) {
      const temp = []
      for (let j = 0; j <= cap; j++) {
        temp.push(-1)
      }
      cache.push(temp)
    }
    const result = zeroOneKnapsack(newArr, currlen, cap, cache)
    output.push(result)
    i += currlen + 1
  }

  return output
}

export { zeroOneKnapsack, example }

const isValid = (board, row, col, k) => {
  for (let i = 0; i < 9; i++) {
    const m = 3 * Math.floor(row / 3) + Math.floor(i / 3)
    const n = 3 * Math.floor(col / 3) + i % 3
    if (board[row][i] === k || board[i][col] === k || board[m][n] === k) {
      return false
    }
  }
  return true
}

const sudokuSolver = (data) => {
  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 9; j++) {
      if (data[i][j] === '.') {
        for (let k = 1; k <= 9; k++) {
          if (isValid(data, i, j, `${k}`)) {
            data[i][j] = `${k}`
            if (sudokuSolver(data)) {
              return true
            } else {
              data[i][j] = '.'
            }
          }
        }
        return false
      }
    }
  }
  return true
}



export { sudokuSolver }

const tribonacci = (n) => {
    const dp = new Array(n + 1)
  dp[0] = 0
  dp[1] = 1
  dp[2] = 1
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
  }
  return dp[n]
}

export { tribonacci }


const climbStairs = (n) => {
  let prev = 0
  let cur = 1
  let temp

  for (let i = 0; i < n; i++) {
    temp = prev
    prev = cur
    cur += temp
  }
  return cur
}

export { climbStairs }
import { tribonacci } from '../TribonacciNumber'

describe('TribonacciNumber', () => {
  it('tribonacci of 0', () => {
    expect(tribonacci(0)).toBe(0)
  })

  it('tribonacci of 1', () => {
    expect(tribonacci(1)).toBe(1)
  })

  it('tribonacci of 2', () => {
    expect(tribonacci(2)).toBe(1)
  })

  it('tribonacci of 10', () => {
    expect(tribonacci(10)).toBe(149)
  })

  it('tribonacci of 25', () => {
    expect(tribonacci(25)).toBe(1389537)
  })
})
import { kadaneAlgo } from '../KadaneAlgo'
test('it is being checked that 15 is the answer to the corresponding array input', () => {
  expect(kadaneAlgo([1, 2, 3, 4, 5])).toBe(15)
})

test('it is being checked that 5 is the answer to the corresponding array input', () => {
  expect(kadaneAlgo([-1, -2, -3, -4, 5])).toBe(5)
})
import { trap } from '../TrappingRainWater'

describe('TrappingRainWater', () => {
  it('expects 6 units of rain water are being trapped', () => {
    expect(trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6)
  })

  it('expects 9 units of rain water are being trapped', () => {
    expect(trap([4, 2, 0, 3, 2, 5])).toBe(9)
  })
})
import { maxProductOfThree } from '../MaxProductOfThree'

describe('MaxProductOfThree', () => {
  it('expects to throw error for array with only 2 numbers', () => {
    expect(() => {
      maxProductOfThree([1, 3])
    }).toThrow('Triplet cannot exist with the given array')
  })

  it('expects to return 300 as the maximum product', () => {
    expect(maxProductOfThree([10, 6, 5, 3, 1, -10])).toBe(300)
  })

  it('expects to return 300 as the maximum product', () => {
    expect(maxProductOfThree([10, -6, 5, 3, 1, -10])).toBe(600)
  })
})
import { change, coinChangeMin } from '../CoinChange'

test('Base Case 1', () => {
  const coins = [2, 3, 5]
  const amount = 0
  expect(change(coins, amount)).toBe(1)
  expect(coinChangeMin(coins, amount)).toBe(0)
})
test('Base Case 2', () => {
  const coins = []
  const amount = 100
  expect(change(coins, amount)).toBe(0)
  expect(coinChangeMin(coins, amount)).toBe(-1)
})
test('Test Case 1', () => {
  const coins = [2, 4, 5]
  const amount = 12
  expect(change(coins, amount)).toBe(5)
  expect(coinChangeMin(coins, amount)).toBe(3)
})
test('Test Case 2', () => {
  const coins = [5, 2, 3, 7, 6, 1, 12, 11, 9, 15]
  const amount = 45
  expect(change(coins, amount)).toBe(12372)
  expect(coinChangeMin(coins, amount)).toBe(3)
})
test('Test Case 3', () => {
  const coins = [2]
  const amount = 3
  expect(change(coins, amount)).toBe(0)
  expect(coinChangeMin(coins, amount)).toBe(-1)
})
test('Test Case 4', () => {
  const coins = [3, 5, 7, 8, 9, 10, 11]
  const amount = 500
  expect(change(coins, amount)).toBe(35502874)
  expect(coinChangeMin(coins, amount)).toBe(46)
})
test('Test Case 5', () => {
  const coins = [10]
  const amount = 10
  expect(change(coins, amount)).toBe(1)
  expect(coinChangeMin(coins, amount)).toBe(1)
})
import { sieveOfEratosthenes } from '../SieveOfEratosthenes'

describe('SieveOfEratosthenes', () => {
  it('Primes till 0', () => {
    expect(sieveOfEratosthenes(0)).toEqual([])
  })

  it('Primes till 1', () => {
    expect(sieveOfEratosthenes(1)).toEqual([])
  })

  it('Primes till 10', () => {
    expect(sieveOfEratosthenes(10)).toEqual([2, 3, 5, 7])
  })

  it('Primes till 23', () => {
    expect(sieveOfEratosthenes(23)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23])
  })

  it('Primes till 70', () => {
    expect(sieveOfEratosthenes(70)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67])
  })
})
import { longestPalindromeSubsequence } from '../LongestPalindromicSubsequence'

describe('LongestPalindromicSubsequence', () => {
  it('expects to return 1 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('abcdefgh')).toBe(1)
  })

  it('expects to return 4 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('bbbab')).toBe(4)
  })

  it('expects to return 2 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('cbbd')).toBe(2)
  })

  it('expects to return 7 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('racexyzcxar')).toBe(7)
  })
})
import { longestValidParentheses } from '../LongestValidParentheses'

describe('longestValidParentheses', () => {
  it('expects to return 0 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('')).toBe(0)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('(()')).toBe(2)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses(')()())')).toBe(4)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('(((')).toBe(0)
  })
})
import { longestCommonSubsequence } from '../LongestCommonSubsequence'

describe('LongestCommonSubsequence', () => {
  it('expects to return an empty string for empty inputs', () => {
    expect(longestCommonSubsequence('', '')).toEqual(''.length)
    expect(longestCommonSubsequence('aaa', '')).toEqual(''.length)
    expect(longestCommonSubsequence('', 'bbb')).toEqual(''.length)
  })

  it('expects to return an empty string for inputs without a common subsequence', () => {
    expect(longestCommonSubsequence('abc', 'deffgf')).toEqual(''.length)
    expect(longestCommonSubsequence('de', 'ghm')).toEqual(''.length)
    expect(longestCommonSubsequence('aupj', 'xyz')).toEqual(''.length)
  })

  it('expects to return the longest common subsequence, short inputs', () => {
    expect(longestCommonSubsequence('abc', 'abc')).toEqual('abc'.length)
    expect(longestCommonSubsequence('abc', 'abcd')).toEqual('abc'.length)
    expect(longestCommonSubsequence('abc', 'ab')).toEqual('ab'.length)
    expect(longestCommonSubsequence('abc', 'a')).toEqual('a'.length)
    expect(longestCommonSubsequence('abc', 'b')).toEqual('b'.length)
    expect(longestCommonSubsequence('abc', 'c')).toEqual('c'.length)
    expect(longestCommonSubsequence('abd', 'abcd')).toEqual('abd'.length)
    expect(longestCommonSubsequence('abd', 'ab')).toEqual('ab'.length)
    expect(longestCommonSubsequence('abc', 'abd')).toEqual('ab'.length)
  })

  it('expects to return the longest common subsequence, medium-length inputs', () => {
    expect(longestCommonSubsequence('bsbininm', 'jmjkbkjkv')).toEqual('b'.length)
    expect(longestCommonSubsequence('oxcpqrsvwf', 'shmtulqrypy')).toEqual('qr'.length)
  })
})
import { rodCut } from '../RodCutting'

test('Test Case 1', () => {
  expect(rodCut([1, 5, 8, 9, 10, 17, 17, 20], 8)).toBe(22)
})

test('Test Case 2', () => {
  expect(rodCut([1, 5, 4, 2, 1, 11, 19, 12], 8)).toBe(20)
})

test('Test Case 3', () => {
  expect(rodCut([1, 2, 1], 3)).toBe(3)
})

test('Test Case 4', () => {
  expect(rodCut([5, 4, 3, 2, 1], 5)).toBe(25)
})

test('Test Case 5', () => {
  expect(rodCut([3, 5, 8, 8, 10, 16, 14, 19], 8)).toBe(24)
})
import { fibonacci } from '../FibonacciNumber'

describe('Testing FibonacciNumber', () => {
  it('Testing for invalid type', () => {
    expect(() => fibonacci('0')).toThrowError()
    expect(() => fibonacci('12')).toThrowError()
    expect(() => fibonacci(true)).toThrowError()
  })

  it('fibonacci of 0', () => {
    expect(fibonacci(0)).toBe(0)
  })

  it('fibonacci of 1', () => {
    expect(fibonacci(1)).toBe(1)
  })

  it('fibonacci of 10', () => {
    expect(fibonacci(10)).toBe(55)
  })

  it('fibonacci of 25', () => {
    expect(fibonacci(25)).toBe(75025)
  })
})
import { climbStairs } from '../ClimbingStairs'

describe('ClimbingStairs', () => {
  it('climbStairs of 0', () => {
    expect(climbStairs(0)).toBe(1)
  })

  it('climbStairs of 1', () => {
    expect(climbStairs(1)).toBe(1)
  })

  it('climbStairs of 10', () => {
    expect(climbStairs(10)).toBe(89)
  })

  it('climbStairs of 15', () => {
    expect(climbStairs(15)).toBe(987)
  })
})


/

export const trap = (heights) => {
  const maxes = new Array(heights.length).fill(0)

  let leftMax = 0
  for (let i = 0; i < heights.length; i++) {
    const height = heights[i]
    maxes[i] = leftMax
    leftMax = Math.max(leftMax, height)
  }

  let rightMax = 0
  for (let i = heights.length - 1; i >= 0; i -= 1) {
    const height = heights[i]
    const minHeight = Math.min(rightMax, maxes[i])

    if (height < minHeight) {
      maxes[i] = minHeight - height
    } else {
      maxes[i] = 0
    }
    rightMax = Math.max(rightMax, height)
  }
  return maxes.reduce((a, b) => a + b, 0)
}
/


function longestCommonSubsequence (str1, str2) {
  const memo = new Array(str1.length + 1).fill(null)
    .map(() => new Array(str2.length + 1).fill(null))

  function recursive (end1, end2) {
    if (end1 === -1 || end2 === -1) {
      return 0
    }

    if (memo[end1][end2] !== null) {
      return memo[end1][end2]
    }

    if (str1[end1] === str2[end2]) {
      memo[end1][end2] = 1 + recursive(end1 - 1, end2 - 1)
      return memo[end1][end2]
    } else {
      memo[end1][end2] = Math.max(
        recursive(end1 - 1, end2),
        recursive(end1, end2 - 1)
      )
      return memo[end1][end2]
    }
  }

  return recursive(str1.length - 1, str2.length - 1)
}

export { longestCommonSubsequence }

export function maxProductOfThree (arrayItems) {
    const n = arrayItems.length
  if (n < 3) throw new Error('Triplet cannot exist with the given array')
  let max1 = arrayItems[0]
  let max2 = -1
  let max3 = -1
  let min1 = arrayItems[0]
  let min2 = -1
  for (let i = 1; i < n; i++) {
    if (arrayItems[i] > max1) {
      max3 = max2
      max2 = max1
      max1 = arrayItems[i]
    } else if (max2 === -1 || arrayItems[i] > max2) {
      max3 = max2
      max2 = arrayItems[i]
    } else if (max3 === -1 || arrayItems[i] > max3) {
      max3 = arrayItems[i]
    }
    if (arrayItems[i] < min1) {
      min2 = min1
      min1 = arrayItems[i]
    } else if (min2 === -1 || arrayItems[i] < min2) {
      min2 = arrayItems[i]
    }
  }
  const prod1 = max1 * max2 * max3
  const prod2 = max1 * min1 * min2
  return Math.max(prod1, prod2)
}

function sieveOfEratosthenes (n) {
  if (n <= 1) return []
  const primes = new Array(n + 1).fill(true)   primes[0] = primes[1] = false   for (let i = 2; i * i <= n; i++) {
    if (primes[i]) {
      for (let j = i * i; j <= n; j += i) {
        primes[j] = false
      }
    }
  }

  return primes.reduce((result, isPrime, index) => {
    if (isPrime) {
      result.push(index)
    }
    return result
  }, [])
}



export { sieveOfEratosthenes }
/

export const longestPalindromeSubsequence = function (s) {
  const n = s.length

  const dp = new Array(n).fill(0).map(item => new Array(n).fill(0).map(item => 0))

    for (let i = 0; i < n; i++) {
    dp[i][i] = 1
  }

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < n - i; j++) {
      const col = j + i
      if (s[j] === s[col]) {
        dp[j][col] = 2 + dp[j + 1][col - 1]
      } else {
        dp[j][col] = Math.max(dp[j][col - 1], dp[j + 1][col])
      }
    }
  }

  return dp[0][n - 1]
}

const minCostPath = (matrix) => {
  /

  const n = matrix.length
  const m = matrix[0].length

    const moves = new Array(n)
  for (let i = 0; i < moves.length; i++) moves[i] = new Array(m)

    moves[0][0] = matrix[0][0]   for (let i = 1; i < m; i++) moves[0][i] = moves[0][i - 1] + matrix[0][i]
  for (let i = 1; i < n; i++) moves[i][0] = moves[i - 1][0] + matrix[i][0]

  for (let i = 1; i < n; i++) {
    for (let j = 1; j < m; j++) { moves[i][j] = Math.min(moves[i - 1][j], moves[i][j - 1]) + matrix[i][j] }
  }

  return moves[n - 1][m - 1]
}

export { minCostPath }



/

export function kadaneAlgo (array) {
  let cummulativeSum = 0
  let maxSum = Number.NEGATIVE_INFINITY   for (let i = 0; i < array.length; i++) {
    cummulativeSum = cummulativeSum + array[i]
    if (maxSum < cummulativeSum) {
      maxSum = cummulativeSum
    } else if (cummulativeSum < 0) {
      cummulativeSum = 0
    }
  }
  return maxSum
  }
function maximumNonAdjacentSum (nums) {
  /

  if (nums.length < 0) return 0

  let maxIncluding = nums[0]
  let maxExcluding = 0

  for (const num of nums.slice(1)) {
    const temp = maxIncluding
    maxIncluding = maxExcluding + num
    maxExcluding = Math.max(temp, maxExcluding)
  }

  return Math.max(maxExcluding, maxIncluding)
}



export { maximumNonAdjacentSum }


function minimum (a, b, c) {
  if (a < b && a < c) {
    return a
  } else if (b < a && b < c) {
    return b
  } else {
    return c
  }
}

function costOfSubstitution (x, y) {
  return x === y ? 0 : 1
}

function calculate (x, y) {
  const dp = new Array(x.length + 1)
  for (let i = 0; i < x.length + 1; i++) {
    dp[i] = new Array(y.length + 1)
  }

  for (let i = 0; i < x.length + 1; i++) {
    for (let j = 0; j < y.length + 1; j++) {
      if (i === 0) {
        dp[i][j] = j
      } else if (j === 0) {
        dp[i][j] = i
      } else {
        dp[i][j] = minimum(dp[i - 1][j - 1] + costOfSubstitution(x.charAt(i - 1), y.charAt(j - 1)), dp[i - 1][j] + 1, dp[i][j - 1] + 1)
      }
    }
  }

  return dp[x.length][y.length]
}

export { calculate }


function longestIncreasingSubsequence (x) {
  const length = x.length
  const dp = Array(length).fill(1)

  let res = 1

  for (let i = 0; i < length; i++) {
    for (let j = 0; j < i; j++) {
      if (x[i] > x[j]) {
        dp[i] = Math.max(dp[i], 1 + dp[j])
        if (dp[i] > res) {
          res = dp[i]
        }
      }
    }
  }

  return res
}

export { longestIncreasingSubsequence }
/

export function rodCut (prices, n) {
  const memo = new Array(n + 1)
  memo[0] = 0

  for (let i = 1; i <= n; i++) {
    let maxVal = Number.MIN_VALUE
    for (let j = 0; j < i; j++) { maxVal = Math.max(maxVal, prices[j] + memo[i - j - 1]) }
    memo[i] = maxVal
  }

  return memo[n]
}
/

export const longestValidParentheses = (s) => {
  const n = s.length
  const stack = []

    const res = new Array(n).fill(-Infinity)

  for (let i = 0; i < n; i++) {
    const bracket = s[i]

    if (bracket === ')' && s[stack[stack.length - 1]] === '(') {
      res[i] = 1
      res[stack[stack.length - 1]] = 1
      stack.pop()
    } else {
      stack.push(i)
    }
  }

    for (let i = 1; i < n; i++) {
    res[i] = Math.max(res[i], res[i] + res[i - 1])
  }

    res.push(0)
  return Math.max(...res)
}

export const change = (coins, amount) => {
    const combinations = new Array(amount + 1).fill(0)
  combinations[0] = 1
    for (let i = 0; i < coins.length; i++) {
        for (let j = coins[i]; j < combinations.length; j++) {
      combinations[j] += combinations[j - coins[i]]
    }
  }
  return combinations[amount]
}

export const coinChangeMin = (coins, amount) => {
  const map = { 0: 1 }
  for (let i = 1; i <= amount; i++) {
    let min = Infinity
    for (const coin of coins) {
      if (i < coin) continue
      min = Math.min(min, 1 + map[i - coin])
    }
    map[i] = min
  }
  return map[amount] === Infinity ? -1 : map[amount] - 1
}
/

class Month {
  constructor () {
    this.Days = ['M', 'T', 'W', 'Th', 'F', 'S', 'Su']
    this.BDays = ['M', 'Su', 'S', 'F', 'Th', 'W', 'T']
    this.epoch = { month: 1, year: 1900 }
    this.monthDays = [31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    this.monthDaysLeap = [31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  }

  printCal (days, startDay, output = value => console.log(value)) {
    output('M   T   W   Th  F   S   Su')
    const dates = []; let i
    for (i = 1; i <= days; i++) {
      dates.push(i)
    }
    for (i = 0; i < this.Days.indexOf(startDay); i++) {
      dates.unshift(' ')
    }
    while (true) {
      let row = ''
      for (i = 0; (i < 7) && (dates.length !== 0); i++) {
        row += dates.shift()
        while ((row.length % 4) !== 0) {
          row += ' '
        }
      }
      output(row)
      if (dates.length === 0) break
    }
  }

  parseDate (date) {
    const dateAr = []; let block = ''; let i
    for (i = 0; i < date.length; i++) {
      if (date[i] === '/') {
        dateAr.push(parseInt(block))
        block = ''
        continue
      }
      block += date[i]
    }
    dateAr.push(parseInt(block))
    if (dateAr.length !== 2) throw new Error('Improper string encoding')
    const dateOb = { month: dateAr[0], year: dateAr[1] }
    return dateOb
  }

  isLeapYear (year) {
    if (((year % 400) === 0) || (((year % 100) !== 0) && ((year % 4) === 0))) return true
    return false
  }

  isGreater (startDate, endDate) {
    if (startDate.year > endDate.year) {
      return true
    } else if (startDate.year < endDate.year) {
      return false
    } else if (startDate.month > endDate.month) {
      return true
    } else if (startDate.month < endDate.month) {
      return false
    }
    return true
  }

  getDayDiff (startDate, endDate) {
    if (this.isGreater(startDate, endDate) === null) {
      return 0
    } else if ((this.isGreater(startDate, endDate) === true)) {
      const midDate = startDate
      startDate = endDate
      endDate = midDate
    }
    let diff = 0
    while (startDate.year !== endDate.year) {
      diff += (this.isLeapYear(startDate.year)) ? 366 : 365
      startDate.year = startDate.year + 1
    }
    while (startDate.month !== endDate.month) {
      if (startDate.month < endDate.month) {
        if (this.isLeapYear(startDate.year)) diff += this.monthDaysLeap[startDate.month]
        else diff += this.monthDays[startDate.month]
        startDate.month = startDate.month + 1
      } else {
        if (this.isLeapYear(startDate.year)) diff -= this.monthDaysLeap[startDate.month - 1]
        else diff -= this.monthDays[startDate.month - 1]
        startDate.month = startDate.month - 1
      }
    }
    return diff
  }

  generateMonthCal (date) {
    const Month = this.parseDate(date); let day = ''
    let difference = this.getDayDiff(this.epoch, Month)
    difference = difference % 7
    let Month2 = this.parseDate(date)
    day = (this.isGreater(Month2, this.epoch)) ? this.Days[difference] : this.BDays[difference]
    Month2 = this.parseDate(date)
    if (this.isLeapYear(Month2.year)) this.printCal(this.monthDaysLeap[Month2.month], day)
    else this.printCal(this.monthDays[Month2.month], day)
  }
}

export { Month }


const XORCipher = (str, key) => {
  if (typeof str !== 'string' || !Number.isInteger(key)) {
    throw new TypeError('Arguments type are invalid')
  }

  return str.replace(
    /./g, (char) => String.fromCharCode(char.charCodeAt() ^ key)
  )
}

export default XORCipher
import caesarsCipher from '../CaesarsCipher'

describe('Testing the caesarsCipher function', () => {
  it('Test - 1, Testing for invalid types', () => {
    expect(() => caesarsCipher(false, 3)).toThrow()
    expect(() => caesarsCipher('false', -1)).toThrow()
    expect(() => caesarsCipher('true', null)).toThrow()
  })

  it('Test - 2, Testing for valid string and rotation', () => {
    expect(caesarsCipher('middle-Outz', 2)).toBe('okffng-Qwvb')
    expect(caesarsCipher('abcdefghijklmnopqrstuvwxyz', 3)).toBe('defghijklmnopqrstuvwxyzabc')
    expect(caesarsCipher('Always-Look-on-the-Bright-Side-of-Life', 5)).toBe('Fqbfdx-Qttp-ts-ymj-Gwnlmy-Xnij-tk-Qnkj')
    expect(caesarsCipher('THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG', 23)).toBe('QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD')
  })
})
import { encrypt, decrypt } from '../KeywordShiftedAlphabet'

test('Hello world! === dcrypt(encrypt(Hello world!))', () => {
  const word = 'Hello world!'
  const result = decrypt('keyword', encrypt('keyword', word))
  expect(result).toMatch(word)
})

test('The Algorithms === dcrypt(encrypt(The Algorithms))', () => {
  const word = 'The Algorithms'
  const result = decrypt('keyword', encrypt('keyword', word))
  expect(result).toMatch(word)
})
import Atbash from '../Atbash'

describe('Testing Atbash function', () => {
  it('Test - 1, passing a non-string as an argument', () => {
    expect(() => Atbash(0x345)).toThrow()
    expect(() => Atbash(123)).toThrow()
    expect(() => Atbash(123n)).toThrow()
    expect(() => Atbash(false)).toThrow()
    expect(() => Atbash({})).toThrow()
    expect(() => Atbash([])).toThrow()
  })

  it('Test - 2, passing a string as an argument', () => {
    const clearText = 'The quick brown fox jumps over the lazy dog'
    const cryptText = Atbash(clearText)
    expect(Atbash(cryptText)).toBe(clearText)
  })
})
import XORCipher from '../XORCipher'

describe('Testing XORCipher function', () => {
  it('Test - 1, passing a non-string as an argument', () => {
    expect(() => XORCipher(false, 0x345)).toThrow()
    expect(() => XORCipher(true, 123)).toThrow()
    expect(() => XORCipher(1n, 123n)).toThrow()
    expect(() => XORCipher(false, 0.34)).toThrow()
    expect(() => XORCipher({})).toThrow()
    expect(() => XORCipher([])).toThrow()
  })

  it('Test - 2, passing a string & number as an argument', () => {
        expect(XORCipher('test string', 32)).toBe('TEST\x00STRING')
    expect(XORCipher('TEST\x00STRING', 32)).toBe('test string')
  })
})
import ROT13 from '../ROT13'

describe('Testing ROT13 function', () => {
  it('Test - 1, passing a non-string as an argument', () => {
    expect(() => ROT13(0x345)).toThrow()
    expect(() => ROT13(123)).toThrow()
    expect(() => ROT13(123n)).toThrow()
    expect(() => ROT13(false)).toThrow()
    expect(() => ROT13({})).toThrow()
    expect(() => ROT13([])).toThrow()
  })

  it('Test - 2, passing a string as an argument', () => {
    expect(ROT13('Uryyb Jbeyq')).toBe('Hello World')
    expect(ROT13('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')).toBe('NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')
    expect(ROT13('The quick brown fox jumps over the lazy dog')).toBe('Gur dhvpx oebja sbk whzcf bire gur ynml qbt')
  })
})
import { encrypt, decrypt } from '../VigenereCipher'

test('Hello world! === dcrypt(encrypt(Hello world!))', () => {
  const word = 'Hello world!'
  const result = decrypt(encrypt(word, 'code'), 'code')
  expect(result).toMatch(word)
})

test('The Algorithms === dcrypt(encrypt(The Algorithms))', () => {
  const word = 'The Algorithms'
  const result = decrypt(encrypt(word, 'code'), 'code')
  expect(result).toMatch(word)
})

const caesarsCipher = (str, rotation) => {
  if (typeof str !== 'string' || !Number.isInteger(rotation) || rotation < 0) {
    throw new TypeError('Arguments are invalid')
  }

  const alphabets = new Array(26)
    .fill()
    .map((_, index) => String.fromCharCode(97 + index)) 
  const cipherMap = alphabets.reduce(
    (map, char, index) => map.set(char, alphabets[(rotation + index) % 26]),
    new Map()
  )

  return str.replace(/[a-z]/gi, (char) => {
    if (/[A-Z]/.test(char)) {
      return cipherMap.get(char.toLowerCase()).toUpperCase()
    }

    return cipherMap.get(char)
  })
}

export default caesarsCipher

function ROT13 (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

  return str.replace(/[a-z]/gi, (char) => {
    const charCode = char.charCodeAt()

    if (/[n-z]/i.test(char)) {
      return String.fromCharCode(charCode - 13)
    }

    return String.fromCharCode(charCode + 13)
  })
}

export default ROT13

function isLetter (str) {
  return str.length === 1 && str.match(/[a-zA-Z]/i)
}


function isUpperCase (character) {
  if (character === character.toUpperCase()) {
    return true
  }
  if (character === character.toLowerCase()) {
    return false
  }
}


function encrypt (message, key) {
  let result = ''

  for (let i = 0, j = 0; i < message.length; i++) {
    const c = message.charAt(i)
    if (isLetter(c)) {
      if (isUpperCase(c)) {
        result += String.fromCharCode((c.charCodeAt(0) + key.toUpperCase().charCodeAt(j) - 2 * 65) % 26 + 65)       } else {
        result += String.fromCharCode((c.charCodeAt(0) + key.toLowerCase().charCodeAt(j) - 2 * 97) % 26 + 97)       }
    } else {
      result += c
    }
    j = ++j % key.length
  }
  return result
}


function decrypt (message, key) {
  let result = ''

  for (let i = 0, j = 0; i < message.length; i++) {
    const c = message.charAt(i)
    if (isLetter(c)) {
      if (isUpperCase(c)) {
        result += String.fromCharCode(90 - (25 - (c.charCodeAt(0) - key.toUpperCase().charCodeAt(j))) % 26)
      } else {
        result += String.fromCharCode(122 - (25 - (c.charCodeAt(0) - key.toLowerCase().charCodeAt(j))) % 26)
      }
    } else {
      result += c
    }
    j = ++j % key.length
  }
  return result
}

export { encrypt, decrypt }




const alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

function checkKeywordValidity (keyword) {
  keyword.split('').forEach((char, index) => {
    const rest = keyword.slice(0, index) + keyword.slice(index + 1)
    if (rest.indexOf(char) !== -1) {
      return false
    }
  })
  return true
}

function getEncryptedAlphabet (keyword) {
  const encryptedAlphabet = keyword.split('')
  alphabet.forEach((char) => {
    if (encryptedAlphabet.indexOf(char) === -1) {
      encryptedAlphabet.push(char)
    }
  })
  return encryptedAlphabet
}

function translate (sourceAlphabet, targetAlphabet, message) {
  return message.split('').reduce((encryptedMessage, char) => {
    const isUpperCase = char === char.toUpperCase()
    const encryptedCharIndex = sourceAlphabet.indexOf(char.toLowerCase())
    const encryptedChar = encryptedCharIndex !== -1 ? targetAlphabet[encryptedCharIndex] : char
    encryptedMessage += isUpperCase ? encryptedChar.toUpperCase() : encryptedChar
    return encryptedMessage
  }, '')
}

function checkInputs (keyword, message) {
  if (!keyword || !message) {
    throw new Error('Both keyword and message must be specified')
  }

  if (!checkKeywordValidity(keyword)) {
    throw new Error('Invalid keyword!')
  }
}

function encrypt (keyword, message) {
  checkInputs(keyword, message)
  return translate(alphabet, getEncryptedAlphabet(keyword.toLowerCase()), message)
}

function decrypt (keyword, message) {
  checkInputs(keyword, message)
  return translate(getEncryptedAlphabet(keyword.toLowerCase()), alphabet, message)
}

export { encrypt, decrypt }


const Atbash = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

  return str.replace(/[a-z]/gi, (char) => {
    const charCode = char.charCodeAt()

    if (/[A-Z]/.test(char)) {
      return String.fromCharCode(90 + 65 - charCode)
    }

    return String.fromCharCode(122 + 97 - charCode)
  })
}

export default Atbash

function keyFinder (str) {   const wordBank = [
    'I ',
    'You ',
    'We ',
    'They ',
    'He ',
    'She ',
    'It ',
    ' the ',
    'The ',
    ' of ',
    ' is ',
    'Is ',
    ' am ',
    'Am ',
    ' are ',
    'Are ',
    ' have ',
    'Have ',
    ' has ',
    'Has ',
    ' may ',
    'May ',
    ' be ',
    'Be ']
      const inStr = str.toString()   let outStr = ''   let outStrElement = ''   for (let k = 0; k < 26; k++) {     outStr = caesarCipherEncodeAndDecodeEngine(inStr, k) 
        for (let s = 0; s < outStr.length; s++) {
      for (let i = 0; i < wordBank.length; i++) {
                        for (let w = 0; w < wordBank[i].length; w++) {
          outStrElement += outStr[s + w]
        }
                        if (wordBank[i] === outStrElement) {
          return k         }
        outStrElement = ''       }     }
  }
  return 0 }

/
function caesarCipherEncodeAndDecodeEngine (inStr, numShifted) {
  const shiftNum = numShifted
  let charCode = 0
  let outStr = ''
  let shiftedCharCode = 0
  let result = 0

  for (let i = 0; i < inStr.length; i++) {
    charCode = inStr[i].charCodeAt()
    shiftedCharCode = charCode + shiftNum
    result = charCode

    if ((charCode >= 48 && charCode <= 57)) {
      if (shiftedCharCode < 48) {
        let diff = Math.abs(48 - 1 - shiftedCharCode) % 10

        while (diff >= 10) {
          diff = diff % 10
        }
        document.getElementById('diffID').innerHTML = diff

        shiftedCharCode = 57 - diff

        result = shiftedCharCode
      } else if (shiftedCharCode >= 48 && shiftedCharCode <= 57) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 57) {
        let diff = Math.abs(57 + 1 - shiftedCharCode) % 10

        while (diff >= 10) {
          diff = diff % 10
        }
        document.getElementById('diffID').innerHTML = diff

        shiftedCharCode = 48 + diff

        result = shiftedCharCode
      }
    } else if ((charCode >= 65 && charCode <= 90)) {
      if (shiftedCharCode <= 64) {
        let diff = Math.abs(65 - 1 - shiftedCharCode) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 90 - diff
        result = shiftedCharCode
      } else if (shiftedCharCode >= 65 && shiftedCharCode <= 90) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 90) {
        let diff = Math.abs(shiftedCharCode - 1 - 90) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 65 + diff
        result = shiftedCharCode
      }
    } else if ((charCode >= 97 && charCode <= 122)) {
      if (shiftedCharCode <= 96) {
        let diff = Math.abs(97 - 1 - shiftedCharCode) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 122 - diff
        result = shiftedCharCode
      } else if (shiftedCharCode >= 97 && shiftedCharCode <= 122) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 122) {
        let diff = Math.abs(shiftedCharCode - 1 - 122) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 97 + diff
        result = shiftedCharCode
      }
    }
    outStr = outStr + String.fromCharCode(parseInt(result))
  }
  return outStr
}

export { keyFinder }

import { getMonthDays } from '../GetMonthDays'

describe('Get the Days of a Month', () => {
  it('expects to return 28', () => {
    expect(getMonthDays(2, 2018)).toEqual(28)
  })

  it('expects to return 30', () => {
    expect(getMonthDays(6, 254)).toEqual(30)
  })

  it('expects to return 29', () => {
    expect(getMonthDays(2, 2024)).toEqual(29)
  })

  it('expects to throw a type error', () => {
    expect(() => { getMonthDays(13, 2020) }).toThrow('Invalid Month Number.')
  })
})

class IntervalTimer {
  /
  constructor (interval = 10,
    callBack = () => {}) {
    this.prevInterval = 0
    if (this.instance == null) {
      this.interval = interval
      this.callBack = callBack
      this.instance = this
    } else {
      return this.instance
    }
  }

  /
  startTimer () {
    this.timer = setInterval(this.callBack, this.interval)
  }

  /
  resetTimer () {
    clearInterval(this.timer)
    this.callBack = () => {}
    return this.getElapsedTime()
  }

  /
  getElapsedTime (offset = 0) {
    this.timeElapsed = this.timer - this.prevInterval
    this.prevInterval = this.timer
    return this.timeElapsed - offset
  }

  /
  getRunTime () {
    return this.timer
  }
}


const ExampleIntervalTimer = function (output = v => console.log(v)) {
  /
  const timer = new IntervalTimer()
  timer.startTimer()

    
  /
  const initOffset = timer.getRunTime()

      output(timer.getElapsedTime(initOffset))

  /
  output(timer.resetTimer())
}

export { IntervalTimer, ExampleIntervalTimer }


const getMonthDays = (monthNumber, year) => {
  const the31DaysMonths = [1, 3, 5, 7, 8, 10, 12]
  const the30DaysMonths = [4, 6, 9, 11]

  if (!the31DaysMonths.includes(monthNumber) && !the30DaysMonths.includes(monthNumber) &&
    (monthNumber !== 2)
  ) {
    throw new TypeError('Invalid Month Number.')
  }

  if (the31DaysMonths.includes(monthNumber)) { return 31 }

  if (the30DaysMonths.includes(monthNumber)) { return 30 }

    if (year % 4 === 0) {
    if ((year % 100 !== 0) || (year % 100 === 0 && year % 400 === 0)) {
      return 29
    }
  }

  return 28
}

export { getMonthDays }


function integralEvaluation (N, a, b, func) {
    if (!Number.isInteger(N) || Number.isNaN(a) || Number.isNaN(b)) { throw new TypeError('Expected integer N and finite a, b') }
  if (N <= 0) { throw Error('N has to be >= 2') }   if (a > b) { throw Error('a must be less or equal than b') }   if (a === b) return 0 
    const h = (b - a) / N

    let xi = a   const pointsArray = []

    let temp
  for (let i = 0; i < N; i++) {
    temp = func(xi + h / 2)
    pointsArray.push(temp)
    xi += h
  }

    let result = h
  temp = 0
  for (let i = 0; i < pointsArray.length; i++) temp += pointsArray[i]

  result *= temp

  if (Number.isNaN(result)) { throw Error('Result is NaN. The input interval does not belong to the functions domain') }

  return result
}

export { integralEvaluation }


const perfectCube = (num) => Math.round(num ** (1 / 3)) ** 3 === num

export { perfectCube }
/

function sqrt (num, precision = 4) {
  if (!Number.isFinite(num)) { throw new TypeError(`Expected a number, received ${typeof num}`) }
  if (!Number.isFinite(precision)) { throw new TypeError(`Expected a number, received ${typeof precision}`) }
  let sqrt = 1
  for (let i = 0; i < precision; i++) {
    sqrt -= (sqrt * sqrt - num) / (2 * sqrt)
  }
  return sqrt
}

export { sqrt }
/

export const binaryExponentiation = (a, n) => {
      if (n === 0) {
    return 1
  } else if (n % 2 === 1) {
    return binaryExponentiation(a, n - 1) * a
  } else {
    const b = binaryExponentiation(a, n / 2)
    return b * b
  }
}
/

function fareyApproximation (decimal, repeat = 20) {
  let a = 0; let b = 1; let c = 1; let d = 1; let numerator; let denominator

  for (let i = 0; i < repeat; i++) {
    numerator = a + c
    denominator = b + d

    if (decimal > numerator / denominator) {
      [a, b] = [numerator, denominator]
    } else {
      [c, d] = [numerator, denominator]
    }
  }

  return { numerator, denominator }
}

export { fareyApproximation }

export const isLeapYear = (year) => {
  if (year % 400 === 0) return true
  if (year % 100 === 0) return false
  if (year % 4 === 0) return true

  return false
}
/

const factorial = (n) => {
  let fact = 1
  while (n !== 0) {
    fact = fact * n
    n--
  }
  return fact
}


const CheckKishnamurthyNumber = (number) => {
    if (typeof number !== 'number') {
    return new TypeError('Argument is not a number.')
  }
    let sumOfAllDigitFactorial = 0
    let newNumber = number
    while (newNumber > 0) {
    const lastDigit = newNumber % 10
        sumOfAllDigitFactorial += factorial(lastDigit)
    newNumber = Math.floor(newNumber / 10)
  }
    return sumOfAllDigitFactorial === number
}

export { CheckKishnamurthyNumber }


const FindMinIterator = (_iterable, _selector = undefined) => {
  let min

  const iterator = _iterable[Symbol.iterator]()
  if (!_selector) {
    let current = iterator.next()
    if (current.done) { return undefined }
    min = current.value

    current = iterator.next()
    while (!current.done) {
      const x = current.value
      if (x < min) { min = x }
      current = iterator.next()
    }
  } else {
    let current = iterator.next()
    if (current.done) { return undefined }
    min = _selector(current.value)

    current = iterator.next()
    while (!current.done) {
      const x = _selector(current.value)
      if (x < min) { min = x }
      current = iterator.next()
    }
  }
  return min
}

export { FindMinIterator }
/

const Identity = (n) => {
        const res = []
  for (let i = 0; i < n; i++) {
    res[i] = []
    for (let j = 0; j < n; j++) {
      res[i][j] = i === j ? 1 : 0
    }
  }
  return res
}

const MatMult = (matrixA, matrixB) => {
          const n = matrixA.length
  const matrixC = []
  for (let i = 0; i < n; i++) {
    matrixC[i] = []
    for (let j = 0; j < n; j++) {
      matrixC[i][j] = 0
    }
  }
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      for (let k = 0; k < n; k++) {
        matrixC[i][j] += matrixA[i][k] * matrixB[k][j]
      }
    }
  }
  return matrixC
}

export const MatrixExponentiationRecursive = (mat, m) => {
        if (m === 0) {
        return Identity(mat.length)
  } else if (m % 2 === 1) {
        const tmp = MatrixExponentiationRecursive(mat, m - 1)
        return MatMult(tmp, mat)
  } else {
        const tmp = MatrixExponentiationRecursive(mat, m >> 1)
        return MatMult(tmp, tmp)
  }
}





/

export const decimalIsolate = (number) => {
  const answer = parseFloat((number + '').replace(/^[-\d]+./, '.'))
  return isNaN(answer) === true ? 0 : answer
}
/



export const isPronic = (number) => {
  if (number === 0) {
    return true
  }
  const sqrt = Math.sqrt(number)
  return sqrt % 1 !== 0 && Math.ceil(sqrt) * Math.floor(sqrt) === number
}
/


const isOdd = (number) => Boolean(number % 2) /
const isOddBitwise = (number) => Boolean(number & 1) 
export { isOdd, isOddBitwise }

const calcRPN = (expression) => {
  const operators = {
    '+': (a, b) => a + b,
    '-': (a, b) => a - b,
    '*': (a, b) => a * b,
    '/': (a, b) => b / a
  }

  const tokens = expression.split(' ')

  const stack = []

  tokens.forEach((token) => {
    const operator = operators[token]

    if (typeof operator === 'function') {
      const a = stack.pop()
      const b = stack.pop()

      const result = operator(a, b)

      stack.push(result)
    } else {
      stack.push(parseFloat(token))
    }
  })

  return stack.pop()
}

export { calcRPN }
/


export const isEven = (number) => number % 2 === 0


export const isEvenBitwise = (number) => (number & 1) === 0
/


export const radianToDegree = (radian) => {
  return radian * (180 / Math.PI)
}
/
const euclideanDistance = (longitude1, latitude1, longitude2, latitude2) => {
  const width = longitude2 - longitude1
  const height = latitude2 - latitude1
  return (Math.sqrt(width * width + height * height))
}

const manhattanDistance = (longitude1, latitude1, longitude2, latitude2) => {
  const width = Math.abs(longitude2 - longitude1)
  const height = Math.abs(latitude2 - latitude1)
  return width + height
}

export { euclideanDistance, manhattanDistance }


const perfectSquare = (num) => Math.sqrt(num) ** 2 === num

export { perfectSquare }
import { aliquotSum } from '../AliquotSum'

describe('Aliquot Sum of a Number', () => {
  it('Aliquot Sum of 6', () => {
    expect(aliquotSum(6)).toBe(6)
  })

  it('Aliquot Sum of 1', () => {
    expect(aliquotSum(1)).toBe(0)
  })

  it('Aliquot Sum of 28', () => {
    expect(aliquotSum(28)).toBe(28)
  })
})
import { generate } from '../PascalTriangle'

describe('Pascals Triangle', () => {
  it('should have the the same length as the number', () => {
    const pascalsTriangle = generate(5)
    expect(pascalsTriangle.length).toEqual(5)
  })
  it('should have same length as its index in the array', () => {
    const pascalsTriangle = generate(5)
    pascalsTriangle.forEach((arr, index) => {
      expect(arr.length).toEqual(index + 1)
    })
  })
  it('should return an array of arrays', () => {
    const pascalsTriangle = generate(3)
    expect(pascalsTriangle).toEqual(
      expect.arrayContaining([[1], [1, 1], [1, 2, 1]])
    )
  })
})
import * as area from '../Area'

describe('Testing surfaceAreaCube calculations', () => {
  it('with natural number', () => {
    const surfaceAreaOfOne = area.surfaceAreaCube(1.2)
    const surfaceAreaOfThree = area.surfaceAreaCube(3)
    expect(surfaceAreaOfOne).toBe(8.64)
    expect(surfaceAreaOfThree).toBe(54)
  })
  it('with negative argument, expect throw', () => {
    expect(() => area.surfaceAreaCube(-1)).toThrow()
  })
  it('with non-numeric argument, expect throw', () => {
    expect(() => area.surfaceAreaCube('199')).toThrow()
  })
})

describe('Testing surfaceAreaSphere calculations', () => {
  it('with correct value', () => {
    const calculateArea = area.surfaceAreaSphere(5)
    const expected = 314.1592653589793
    expect(calculateArea).toBe(expected)
  })
  it('with negative value, expect throw', () => {
    expect(() => area.surfaceAreaSphere(-1)).toThrow()
  })
})

describe('Testing areaRectangle calculations', () => {
  it('with correct args', () => {
    const areaRectangle = area.areaRectangle(2.5, 2)
    expect(areaRectangle).toBe(5.0)
  })
  it('with incorrect args, expect throw', () => {
    expect(() => area.areaRectangle(-1, 20)).toThrow()
    expect(() => area.areaRectangle('1', 0)).toThrow()
    expect(() => area.areaRectangle(23, -1)).toThrow()
    expect(() => area.areaRectangle(23, 'zero')).toThrow()
  })
})

describe('Testing areaSquare calculations', () => {
  it('with correct args', () => {
    const areaSquare = area.areaSquare(2.5)
    expect(areaSquare).toBe(6.25)
  })
  it('with incorrect side length, expect throw', () => {
    expect(() => area.areaSquare(-1)).toThrow()
    expect(() => area.areaSquare('zero')).toThrow()
  })
})

describe('Testing areaTriangle calculations', () => {
  it('with correct args', () => {
    const areaTriangle = area.areaTriangle(1.66, 3.44)
    expect(areaTriangle).toBe(2.8552)
  })
  it('with incorrect base and height, expect throw', () => {
    expect(() => area.areaTriangle(-1, 1)).toThrow()
    expect(() => area.areaTriangle(9, 'zero')).toThrow()
  })
})

describe('Testing areaTriangleWithAllThreeSides calculations', () => {
  it('with correct args', () => {
    const areaTriangle = area.areaTriangleWithAllThreeSides(5, 6, 7)
    expect(areaTriangle).toBe(14.7)
  })
  it('with incorrect sides, expect throw', () => {
    expect(() => area.areaTriangleWithAllThreeSides(-1, 1, 10)).toThrow()
    expect(() => area.areaTriangleWithAllThreeSides(9, 'zero', 2)).toThrow()
    expect(() => area.areaTriangleWithAllThreeSides(1, 10, 12)).toThrow()
  })
})

describe('Testing areaParallelogram calculations', () => {
  it('with correct args', () => {
    const areaParallelogram = area.areaParallelogram(1.66, 3.44)
    expect(areaParallelogram).toBe(5.7104)
  })
  it('with incorrect base and height, expect throw', () => {
    expect(() => area.areaParallelogram(-1, 1)).toThrow()
    expect(() => area.areaParallelogram(9, 'zero')).toThrow()
  })
})

describe('Testing areaTrapezium calculations', () => {
  it('with correct args', () => {
    const areaTrapezium = area.areaTrapezium(1.66, 2.41, 4.1)
    expect(areaTrapezium).toBe(8.3435)
  })
  it('with incorrect bases and height, expect throw', () => {
    expect(() => area.areaTrapezium(-1, 1, 0)).toThrow()
    expect(() => area.areaTrapezium(9, 'zero', 2)).toThrow()
    expect(() => area.areaTrapezium(9, 1, 'seven')).toThrow()
  })
})

describe('Testing areaCircle calculations', () => {
  it('with correct args', () => {
    const areaCircle = area.areaCircle(3.456)
    expect(areaCircle).toBe(37.52298159254666)
  })
  it('with incorrect diagonal, expect throw', () => {
    expect(() => area.areaCircle(-1)).toThrow()
    expect(() => area.areaCircle('zero')).toThrow()
  })
})

describe('Testing areaRhombus calculations', () => {
  it('with correct args', () => {
    const areaRhombus = area.areaRhombus(2.5, 2.0)
    expect(areaRhombus).toBe(2.5)
  })
  it('with incorrect diagonals, expect throw', () => {
    expect(() => area.areaRhombus(7, -1)).toThrow()
    expect(() => area.areaRhombus('zero', 2)).toThrow()
  })
})
import { perfectCube } from '../PerfectCube'

describe('PerfectCube', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectCube(125)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectCube(100)).toBeFalsy()
  })
})
import { degreeToRadian } from '../DegreeToRadian'

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(0)
  expect(radianEqual).toBe(0)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(45)
  expect(radianEqual).toBe(Math.PI / 4)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(90)
  expect(radianEqual).toBe(Math.PI / 2)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(180)
  expect(radianEqual).toBe(Math.PI)
})
import { factorsOfANumber } from '../Factors'

describe('Factors', () => {
  factorsOfANumber(50).forEach((num) => {
    it(`${num} is a factor of 50`, () => {
      const isFactor = 50 % num === 0
      expect(isFactor).toBeTruthy()
    })
  })
})
import { isLeapYear } from '../LeapYear'

describe('Leap Year', () => {
  it('Should return true on the year 2000', () => {
    expect(isLeapYear(2000)).toBe(true)
  })
  it('Should return false on the year 2001', () => {
    expect(isLeapYear(2001)).toBe(false)
  })
  it('Should return false on the year 2002', () => {
    expect(isLeapYear(2002)).toBe(false)
  })
  it('Should return false on the year 2003', () => {
    expect(isLeapYear(2003)).toBe(false)
  })
  it('Should return false on the year 2004', () => {
    expect(isLeapYear(2004)).toBe(true)
  })
  it('Should return false on the year 1900', () => {
    expect(isLeapYear(1900)).toBe(false)
  })
})
import { calcRPN } from '../ReversePolishNotation'

describe('ReversePolishNotation', () => {
  it('should evaluate correctly for two values', () => {
    expect(calcRPN('2 3 +')).toEqual(5)
  })
  it("should evaluate' for multiple values", () => {
    expect(calcRPN('2 2 2 * +')).toEqual(6)
    expect(calcRPN('6 9 7 + 2 / + 3 *')).toEqual(42)
  })
})
import * as coordinate from '../Coordinate'

describe('Testing euclideanDistance calculations', () => {
  it('Should give a numeric output (distance between 2 points) with 4 numeric arguments', () => {
    const euclideanDistance = coordinate.euclideanDistance(2, 2, -10, -7)
    expect(euclideanDistance).toBe(15)
  })
  it('Should not give any output given non-numeric argument', () => {
    const euclideanDistance = coordinate.euclideanDistance('ABC', '123', '', '###')
    expect(euclideanDistance).toBeNaN()
  })
  it('Should not give any output given any number of numeric arguments less than 4', () => {
    const euclideanDistance3arg = coordinate.euclideanDistance(2, 2, -10)
    const euclideanDistance2arg = coordinate.euclideanDistance(2, 2)
    const euclideanDistance1arg = coordinate.euclideanDistance(2)
    const euclideanDistance0arg = coordinate.euclideanDistance()
    expect(euclideanDistance3arg).toBeNaN()
    expect(euclideanDistance2arg).toBeNaN()
    expect(euclideanDistance1arg).toBeNaN()
    expect(euclideanDistance0arg).toBeNaN()
  })
})

describe('Testing manhattanDistance calculations', () => {
  it('Should give a numeric output (distance between 2 points) with 4 numeric arguments', () => {
    const manhattanDistance = coordinate.manhattanDistance(2, 2, -10, -7)
    expect(manhattanDistance).toBe(21)
  })
  it('Should not give any output given non-numeric argument', () => {
    const manhattanDistance = coordinate.manhattanDistance('ABC', '123', '', '###')
    expect(manhattanDistance).toBeNaN()
  })
  it('Should not give any output given any number of numeric arguments less than 4', () => {
    const manhattanDistance3arg = coordinate.manhattanDistance(2, 2, -10)
    const manhattanDistance2arg = coordinate.manhattanDistance(2, 2)
    const manhattanDistance1arg = coordinate.manhattanDistance(2)
    const manhattanDistance0arg = coordinate.manhattanDistance()
    expect(manhattanDistance3arg).toBeNaN()
    expect(manhattanDistance2arg).toBeNaN()
    expect(manhattanDistance1arg).toBeNaN()
    expect(manhattanDistance0arg).toBeNaN()
  })
})
import { isDivisible } from '../IsDivisible'

describe('isDivisible', () => {
  const testCases = [
    [0, 1, true],
    [0, 2, true],
    [1, 1, true],
    [1, 2, false],
    [2, 1, true],
    [4, 4, true],
    [16, 4, true],
    [36978235, 5, true],
    [36978235, 4, false],
    [4.5, 1.5, true],
    [4.5, 1.2, false],
    [5, 0, false],
    [5, -0, false]
  ]

  test.each(testCases)('if parameters are (%i, %i) it returns %p', (dividend, divisor, expected) => {
    expect(isDivisible(dividend, divisor)).toBe(expected)
  })

  const errorCases = [
    [NaN, NaN],
    [NaN, 1],
    [1, NaN],
    ['1', 1],
    [1, '1'],
    [1, true],
    [false, 2]
  ]

  test.each(errorCases)('throws an error if parameters are (%p, %p)', (dividend, divisor) => {
    expect(() => {
      isDivisible(dividend, divisor)
    }).toThrow()
  })
})
import { calcFactorial } from '../Factorial'

describe('calcFactorial', () => {
  it('should return a statement for value "0"', () => {
    expect(calcFactorial(0)).toBe('The factorial of 0 is 1.')
  })

  it('should return a statement for "null" and "undefined"', () => {
    const nullFactorial = calcFactorial(null)
    const undefinedFactorial = calcFactorial(undefined)

    expect(nullFactorial).toBe(
      'Sorry, factorial does not exist for null or undefined numbers.'
    )
    expect(undefinedFactorial).toBe(
      'Sorry, factorial does not exist for null or undefined numbers.'
    )
  })

  it('should not support negative numbers', () => {
    const negativeFactorial = calcFactorial(-5)
    expect(negativeFactorial).toBe(
      'Sorry, factorial does not exist for negative numbers.'
    )
  })

  it('should return the factorial of a positive number', () => {
    const positiveFactorial = calcFactorial(3)
    expect(positiveFactorial).toBe('The factorial of 3 is 6')
  })
})
import { eulerFull } from '../EulerMethod'

function plotLine (label, points, width, height) {
  
    const container = document.createElement('div')
  container.style.width = width + 'px'
  container.style.height = height + 'px'
  document.body.append(container)

    const canvas = document.createElement('canvas')
  container.append(canvas)

    const chart = new Chart(canvas, {     type: 'scatter',
    data: {
      datasets: [{
        label,
        data: points,
        showLine: true,
        fill: false,
        tension: 0,
        borderColor: 'black'
      }]
    },
    options: {
      maintainAspectRatio: false,
      responsive: true
    }
  })
}

function exampleEquation1 (x, y) {
  return x
}

function exampleEquation2 (x, y) {
  return y
}

function exampleEquation3 (x, y) {
  return x + y + x * y
}

if (typeof window !== 'undefined') {
  const points1 = eulerFull(0, 4, 0.1, 0, exampleEquation1)
  const points2 = eulerFull(0, 4, 0.1, 1, exampleEquation2)
  const points3 = eulerFull(0, 0.1, 0.025, 1, exampleEquation3)

  const script = document.createElement('script')

    script.src = 'https:  script.onload = function () {
    plotLine('example 1: dy/dx = x', points1, 600, 400)
    plotLine('example 2: dy/dx = y', points2, 600, 400)
    plotLine('example 3: dy/dx = x + y + x * y', points3, 600, 400)
  }
  document.body.append(script)
}
import { isEven, isEvenBitwise } from '../IsEven'

describe('Testing isEven function', () => {
  it('should return if the number is even or not', () => {
    const isEvenNumber = isEven(4)
    expect(isEvenNumber).toBe(true)
  })

  it('should return if the number is even or not', () => {
    const isEvenNumber = isEven(7)
    expect(isEvenNumber).toBe(false)
  })
})

describe('Testing isEvenBitwise function', () => {
  it('should return if the number is even or not', () => {
    const isEvenNumber = isEvenBitwise(6)
    expect(isEvenNumber).toBe(true)
  })

  it('should return if the number is even or not', () => {
    const isEvenNumber = isEvenBitwise(3)
    expect(isEvenNumber).toBe(false)
  })
})
import { eulersTotientFunction } from '../EulersTotientFunction'

describe('eulersTotientFunction', () => {
  it('is a function', () => {
    expect(typeof eulersTotientFunction).toEqual('function')
  })
  it('should return the phi of a given number', () => {
    const phiOfNumber = eulersTotientFunction(10)
    expect(phiOfNumber).toBe(4)
  })
})
import { Softmax } from '../Softmax'

describe('Softmax', () => {
  it('should return equal distribution of 1 for equal input values', () => {
    expect(Softmax([1, 1])).toEqual([0.5, 0.5])
    expect(Softmax([1, 1, 1, 1])).toEqual([0.25, 0.25, 0.25, 0.25])
  })

  it('should return values which sum to the value of 1', () => {
    expect(Softmax([1, 2, 3, 4]).reduce((a, b) => a + b, 0)).toEqual(1)
  })
})
import { perfectSquare } from '../PerfectSquare'

describe('PerfectSquare', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectSquare(16)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectSquare(10)).toBeFalsy()
  })
})
import { Polynomial } from '../Polynomial'

describe('Polynomial', () => {
  it('should not return a expression for zero', () => {
    const polynomial = new Polynomial([0])
    expect(polynomial.display()).toBe('')
  })
  it('should not return an expression for zero values', () => {
    const polynomial = new Polynomial([0, 0, 0, 0, 0])
    expect(polynomial.display()).toBe('')
  })
  it('should return an expression for single a non zero value', () => {
    const polynomial = new Polynomial([9])
    expect(polynomial.display()).toBe('(9)')
  })
  it('should return an expression for two values', () => {
    const polynomial = new Polynomial([3, 2])
    expect(polynomial.display()).toBe('(2x) + (3)')
  })
  it('should return an expression for values including zero', () => {
    const polynomial = new Polynomial([0, 2])
    expect(polynomial.display()).toBe('(2x)')
  })
  it('should return an expression and evaluate it', () => {
    const polynomial = new Polynomial([1, 2, 3, 4])
    expect(polynomial.display()).toBe('(4x^3) + (3x^2) + (2x) + (1)')
    expect(polynomial.evaluate(2)).toEqual(49)
  })
  it('should evaluate 0 for zero values', () => {
    const polynomial = new Polynomial([0, 0, 0, 0])
    expect(polynomial.evaluate(5)).toEqual(0)
  })
  it('should evaluate for negative values', () => {
    const polynomial = new Polynomial([-1, -3, -4, -7])
    expect(polynomial.evaluate(-5)).toBe(789)
  })
})
import { isPronic } from '../IsPronic'

const pronicNumbers = [0, 2, 6, 12, 20, 30, 42, 56, 72, 90, 110, 132, 156, 182, 210, 240, 272, 306, 342, 380, 420, 462, 506, 552, 600, 650, 702, 756, 812, 870, 930, 992, 1056, 1122, 1190, 1260, 1332, 1406, 1482, 1560, 1640, 1722, 1806, 1892, 1980, 2070, 2162, 2256, 2352, 2450, 2550]

describe('Testing isPronic function', () => {
  for (let i = 0; i <= 2500; i++) {
    it('should return true', () => {
      const isPronicNumber = isPronic(i)
      expect(isPronicNumber).toBe(pronicNumbers.includes(i))
    })
  }
})
import { twinPrime } from '../TwinPrime.js'

describe('Twin Primes', () => {
  it('Should be valid twin primes', () => {
    expect(twinPrime(3)).toBe(5)
    expect(twinPrime(5)).toBe(7)
    expect(twinPrime(4)).toBe(-1)
    expect(twinPrime(17)).toBe(19)
  })
})
import { factorial, permutation, combination } from '../PermutationAndCombination'

describe('Factorial', () => {
  it('factorial(5)', () => {
    expect(factorial(5)).toBe(120)
  })
})

describe('Permutation', () => {
  it('permutation(5, 2)', () => {
    expect(permutation(5, 2)).toBe(20)
  })
})

describe('Combination', () => {
  it('combination(5, 2)', () => {
    expect(combination(5, 2)).toBe(10)
  })
})
import { fermatPrimeCheck, modularExponentiation } from '../FermatPrimalityTest'

describe('modularExponentiation', () => {
  it('should give the correct output for all exponentiations', () => {
    expect(modularExponentiation(38, 220, 221)).toBe(1)
    expect(modularExponentiation(24, 220, 221)).toBe(81)
  })
})

describe('fermatPrimeCheck', () => {
  it('should give the correct output for prime and composite numbers', () => {
    expect(fermatPrimeCheck(2, 35)).toBe(true)
    expect(fermatPrimeCheck(10, 30)).toBe(false)
    expect(fermatPrimeCheck(94286167)).toBe(true)
    expect(fermatPrimeCheck(83165867)).toBe(true)
    expect(fermatPrimeCheck(13268774)).toBe(false)
    expect(fermatPrimeCheck(13233852)).toBe(false)
  })
})
import { LinearSieve } from '../LinearSieve'
import { PrimeCheck } from '../PrimeCheck'

describe('LinearSieve', () => {
  it('should return primes below 100', () => {
    expect(LinearSieve(100)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
  })

  it('should return primes only', () => {
    const n = 100000
    const primes = LinearSieve(n)
    for (const p of primes) {
      expect(PrimeCheck(p)).toBeTruthy()
    }
  })
})
import { GetEuclidGCD } from '../GetEuclidGCD'

function testEuclidGCD (n, m, expected) {
  test('Testing on ' + n + ' and ' + m + '!', () => {
    expect(GetEuclidGCD(n, m)).toBe(expected)
  })
}

testEuclidGCD(5, 20, 5)
testEuclidGCD(109, 902, 1)
testEuclidGCD(290, 780, 10)
testEuclidGCD(104, 156, 52)
import { isOdd, isOddBitwise } from '../IsOdd'

describe('Testing the isOdd function', () => {
  it('should return true, if the number is odd', () => {
    const isOddNumber = isOdd(4)
    expect(isOddNumber).toBe(false)
  })

  it('should return true, if the number is odd', () => {
    const isOddNumber = isOdd(7)
    expect(isOddNumber).toBe(true)
  })
})

describe('Testing the isOddBitwise function', () => {
  it('should return true, if the number is odd', () => {
    const isOddNumber = isOddBitwise(6)
    expect(isOddNumber).toBe(false)
  })

  it('should return true, if the number is odd', () => {
    const isOddNumber = isOddBitwise(3)
    expect(isOddNumber).toBe(true)
  })
})
import { decExp } from '../DecimalExpansion'



describe('Finite Decimal Expansion', () => {
  it('1/2 = 0.5', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 2)
    expect(integer).toBe(0)
    expect(decimals).toEqual([5])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/5 = 0.2', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 5)
    expect(integer).toBe(0)
    expect(decimals).toEqual([2])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/8 = 0.125', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 8)
    expect(integer).toBe(0)
    expect(decimals).toEqual([1, 2, 5])
    expect(cycleIndex).toBeUndefined()
  })

  it('255/40 = 6.375', () => {
    const [integer, decimals, cycleIndex] = decExp(255, 40)
    expect(integer).toBe(6)
    expect(decimals).toEqual([3, 7, 5])
    expect(cycleIndex).toBeUndefined()
  })
})

describe('Repeating Decimal Expansion', () => {
  it('1/3 = 0.(3)', () => {
    expect(decExp(1, 3)).toStrictEqual([0, [3], 0])
  })

  it('1/6 = 0.1(6)', () => {
    expect(decExp(1, 6)).toStrictEqual([0, [1, 6], 1])
  })

  it('1/7 = 0.(142857)', () => {
    expect(decExp(1, 7)).toStrictEqual([0, [1, 4, 2, 8, 5, 7], 0])
  })
})



describe('Finite Binary Expansion', () => {
  it('1/2 = 0.1₂', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 2, 2)
    expect(integer).toBe(0)
    expect(decimals).toEqual([1])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/8 = 0.001₂', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 8, 2)
    expect(integer).toBe(0)
    expect(decimals).toEqual([0, 0, 1])
    expect(cycleIndex).toBeUndefined()
  })

  it('255/40 = 110.011₂', () => {
    const [integer, decimals, cycleIndex] = decExp(255, 40, 2)
    expect(integer).toBe(110)
    expect(decimals).toEqual([0, 1, 1])
    expect(cycleIndex).toBeUndefined()
  })
})

describe('Repeating Binary Expansion', () => {
  it('1/3 = 0.(01)₂', () => {
    expect(decExp(1, 3, 2)).toStrictEqual([0, [0, 1], 0])
  })

  it('1/5 = 0.(0011)₂', () => {
    expect(decExp(1, 5, 2)).toStrictEqual([0, [0, 0, 1, 1], 0])
  })

  it('1/6 = 0.0(01)₂', () => {
    expect(decExp(1, 6, 2)).toStrictEqual([0, [0, 0, 1], 1])
  })

  it('1/7 = 0.(001)₂', () => {
    expect(decExp(1, 7, 2)).toStrictEqual([0, [0, 0, 1], 0])
  })
})



describe('Finite Octal Expansion', () => {
  it('1/2 = 0.4₈', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 2, 8)
    expect(integer).toBe(0)
    expect(decimals).toEqual([4])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/8 = 0.1₈', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 8, 8)
    expect(integer).toBe(0)
    expect(decimals).toEqual([1])
    expect(cycleIndex).toBeUndefined()
  })

  it('255/40 = 6.3₈', () => {
    const [integer, decimals, cycleIndex] = decExp(255, 40, 8)
    expect(integer).toBe(6)
    expect(decimals).toEqual([3])
    expect(cycleIndex).toBeUndefined()
  })
})

describe('Repeating Octal Expansion', () => {
  it('1/3 = 0.(25)₈', () => {
    expect(decExp(1, 3, 8)).toStrictEqual([0, [2, 5], 0])
  })

  it('1/5 = 0.(1463)₈', () => {
    expect(decExp(1, 5, 8)).toStrictEqual([0, [1, 4, 6, 3], 0])
  })

  it('1/6 = 0.1(25)₈', () => {
    expect(decExp(1, 6, 8)).toStrictEqual([0, [1, 2, 5], 1])
  })

  it('1/7 = 0.(1)₈', () => {
    expect(decExp(1, 7, 8)).toStrictEqual([0, [1], 0])
  })
})



describe('Integers', () => {
  it('1/1 = 1', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 1)
    expect(integer).toBe(1)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })

  it('5/5 = 1', () => {
    const [integer, decimals, cycleIndex] = decExp(5, 5)
    expect(integer).toBe(1)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })

  it('2/1 = 2', () => {
    const [integer, decimals, cycleIndex] = decExp(2, 1)
    expect(integer).toBe(2)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })

  it('9/3 = 3', () => {
    const [integer, decimals, cycleIndex] = decExp(9, 3)
    expect(integer).toBe(3)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })
})



describe('Throws on unsupported base', () => {
  it('negative base', () => {
    expect(() => decExp(1, 1, -2)).toThrow(RangeError)
  })
  it('base 0', () => {
    expect(() => decExp(1, 1, 0)).toThrow(RangeError)
  })
  it('base 1', () => {
    expect(() => decExp(1, 1, 1)).toThrow(RangeError)
  })
  it('base 11', () => {
    expect(() => decExp(1, 1, 11)).toThrow(RangeError)
  })
})
import { lucas } from '../LucasSeries'

describe('Nth Lucas Number', () => {
  it('should return the 20th Lucas Number', () => {
    expect(lucas(20)).toBe(15127)
  })

  it('should return the 20th Lucas Number', () => {
    expect(lucas(0)).toBe(2)
  })

  it('should return the 20th Lucas Number', () => {
    expect(lucas(100)).toBe(792070839848372100000)
  })
})
import { factorialize } from '../WhileLoopFactorial'

function testFactorial (n, expected) {
  test('Testing on ' + n + '!', () => {
    expect(factorialize(n)).toBe(expected)
  })
}

testFactorial(3, 6)
testFactorial(7, 5040)
testFactorial(0, 1)
testFactorial(12, 479001600)
import { findMaxRecursion } from '../FindMaxRecursion'

describe('Test findMaxRecursion function', () => {
  const positiveAndNegativeArray = [1, 2, 4, 5, -1, -2, -4, -5]
  const positiveAndNegativeArray1 = [10, 40, 100, 20, -10, -40, -100, -20]

  const positiveArray = [1, 2, 4, 5]
  const positiveArray1 = [10, 40, 100, 20]

  const negativeArray = [-1, -2, -4, -5]
  const negativeArray1 = [-10, -40, -100, -20]

  const zeroArray = [0, 0, 0, 0]
  const emptyArray = []

  it('Testing with positive arrays', () => {
    expect(findMaxRecursion(positiveArray, 0, positiveArray.length - 1)).toBe(5)
    expect(findMaxRecursion(positiveArray1, 0, positiveArray1.length - 1)).toBe(
      100
    )
  })

  it('Testing with negative arrays', () => {
    expect(findMaxRecursion(negativeArray, 0, negativeArray.length - 1)).toBe(
      -1
    )
    expect(findMaxRecursion(negativeArray1, 0, negativeArray1.length - 1)).toBe(
      -10
    )
  })

  it('Testing with positive and negative arrays', () => {
    expect(
      findMaxRecursion(
        positiveAndNegativeArray,
        0,
        positiveAndNegativeArray.length - 1
      )
    ).toBe(5)
    expect(
      findMaxRecursion(
        positiveAndNegativeArray1,
        0,
        positiveAndNegativeArray1.length - 1
      )
    ).toBe(100)
  })

  it('Testing with zero arrays', () => {
    expect(findMaxRecursion(zeroArray, 0, zeroArray.length - 1)).toBe(0)
  })

  it('Testing with empty arrays', () => {
    expect(findMaxRecursion(emptyArray, 0, emptyArray.length - 1)).toBe(
      undefined
    )
  })
})
import { sieveOfEratosthenes } from '../SieveOfEratosthenes'
import { PrimeCheck } from '../PrimeCheck'

describe('should return an array of prime booleans', () => {
  it('should have each element in the array as a prime boolean', () => {
    const n = 30
    const primes = sieveOfEratosthenes(n)
    primes.forEach((primeBool, index) => {
      if (primeBool) {
        expect(PrimeCheck(index)).toBeTruthy()
      }
    })
  })
})
import { sumOfGeometricProgression } from '../SumOfGeometricProgression'

describe('Sum Of Geometric Progression', () => {
  it('should return the sum of a finite GP', () => {
    expect(sumOfGeometricProgression(100, 1.5, 4)).toBe(812.5)
  })

  it('should return the sum of an infinite GP', () => {
    expect(sumOfGeometricProgression(2, 0.5, Infinity)).toBe(4)
  })
})
import { findHCF } from '../FindHcf'

describe('findHCF', () => {
  it('should throw a statement for values less than 1', () => {
    expect(findHCF(0, 0)).toBe('Please enter values greater than zero.')
  })

  it('should throw a statement for one value less than 1', () => {
    expect(findHCF(0, 1)).toBe('Please enter values greater than zero.')
    expect(findHCF(1, 0)).toBe('Please enter values greater than zero.')
  })

  it('should return an error for values non-integer values', () => {
    expect(findHCF(2.24, 4.35)).toBe('Please enter whole numbers.')
  })

  it('should return the HCF of two given integers', () => {
    expect(findHCF(27, 36)).toBe(9)
  })
})
import { armstrongNumber } from '../ArmstrongNumber'

describe('ArmstrongNumber', () => {
  it('should return true for an armstrong number', () => {
    expect(armstrongNumber(371)).toBeTruthy()
  })

  it('should return false for a non-armstrong number', () => {
    expect(armstrongNumber(300)).toBeFalsy()
  })
  it('should return false for negative values', () => {
    expect(armstrongNumber(-2)).toBeFalsy()
  })
})
import { EulersTotient } from '../EulersTotient'

describe('EulersTotient', () => {
  it('should return 6 as 1, 2, 4, 5, 7, and 8 are coprime to 9', () => {
    expect(EulersTotient(9)).toBe(6)
  })

  it('should return 4 as 1, 3, 7, and 9 are coprime to 10', () => {
    expect(EulersTotient(10)).toBe(4)
  })
})
import { sqrt } from '../SquareRoot'

test('Check SquareRoot of 4 is 2', () => {
  const res = sqrt(4, 10)
  expect(res).toBeCloseTo(2)
})

test('Check SquareRoot of 2 is 1.4142135', () => {
  const res = sqrt(2, 10)
  expect(res).toBeCloseTo(1.4142135)
})

test('Check SquareRoot of 3.2 is 1.788854381999832', () => {
  const res = sqrt(3.2, 10)
  expect(res).toBeCloseTo(1.788854381999832)
})

test('Check SquareRoot of 1 is 1', () => {
  const res = sqrt(1, 10)
  expect(res).toBe(1)
})

test('Check SquareRoot of 144 is 12', () => {
  const res = sqrt(144, 10)
  expect(res).toBeCloseTo(12)
})

test('Check SquareRoot of 0 is 0', () => {
  const res = sqrt(0, 10)
  expect(res).toBeCloseTo(0)
})

test('Check SquareRoot of 1000 is 31.62277', () => {
  const res = sqrt(1000, 10)
  expect(res).toBeCloseTo(31.62277)
})
import { PalindromeRecursive, PalindromeIterative } from '../Palindrome'

describe('Palindrome', () => {
  it('should return true for a palindrome for PalindromeRecursive', () => {
    expect(PalindromeRecursive('mom')).toBeTruthy()
  })
  it('should return true  for a palindrome for PalindromeIterative', () => {
    expect(PalindromeIterative('mom')).toBeTruthy()
  })
  it('should return false for a non-palindrome for PalindromeRecursive', () => {
    expect(PalindromeRecursive('Algorithms')).toBeFalsy()
  })
  it('should return true  for a non-palindrome for PalindromeIterative', () => {
    expect(PalindromeIterative('JavaScript')).toBeFalsy()
  })
})
import { getRGBData } from '../Mandelbrot'

if (typeof window !== 'undefined') {
  const rgbData = getRGBData()
  const width = rgbData.length
  const height = rgbData[0].length
  const canvas = document.createElement('canvas')
  canvas.width = width
  canvas.height = height
  const ctx = canvas.getContext('2d')
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const rgb = rgbData[x][y]
      ctx.fillStyle = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')'
      ctx.fillRect(x, y, 1, 1)
    }
  }
  document.body.append(canvas)
}
import { radianToDegree } from '../RadianToDegree'

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(0)
  expect(degreeEqual).toBe(0)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI / 4)
  expect(degreeEqual).toBe(45)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI / 2)
  expect(degreeEqual).toBe(90)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI)
  expect(degreeEqual).toBe(180)
})
import { sumOfDigitsUsingLoop, sumOfDigitsUsingRecursion, sumOfDigitsUsingString } from '../SumOfDigits'

test('Testing on sumOfDigitsUsingLoop', () => {
  const sum = sumOfDigitsUsingLoop(123)
  expect(sum).toBe(6)
})

test('Testing on sumOfDigitsUsingRecursion', () => {
  const sum = sumOfDigitsUsingRecursion(123)
  expect(sum).toBe(6)
})

test('Testing on sumOfDigitsUsingString', () => {
  const sum = sumOfDigitsUsingString(123)
  expect(sum).toBe(6)
})
import { perfectNumber } from '../PerfectNumber'

describe('PerfectNumber', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectNumber(28)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectNumber(10)).toBeFalsy()
  })
})
import { findMin } from '../FindMin'

describe('FindMin', () => {
  test('Should return the minimum number in the array', () => {
    const min = findMin(2, 5, 1, 12, 43, 1, 9)
    expect(min).toBe(1)
  })

  test('Should return the minimum number in the array', () => {
    const min = findMin(21, 513, 6)
    expect(min).toBe(6)
  })

  test('Should throw error', () => {
    const min = () => findMin()
    expect(min).toThrow('Array is empty')
  })
})
import { mean } from '../AverageMean'

describe('Tests for average mean', () => {
  it('should be a function', () => {
    expect(typeof mean).toEqual('function')
  })

  it('should throw error for invalid input', () => {
    expect(() => mean(123)).toThrow()
  })

  it('should return the mean of an array of numbers', () => {
    const meanFunction = mean([1, 2, 4, 5])
    expect(meanFunction).toBe(3)
  })

  it('should return the mean of an array of numbers', () => {
    const meanFunction = mean([10, 40, 100, 20])
    expect(meanFunction).toBe(42.5)
  })
})
import { findLcm } from '../FindLcm'

describe('findLcm', () => {
  it('should throw a statement for values less than 1', () => {
    expect(findLcm(0, 0)).toBe('Please enter values greater than zero.')
  })

  it('should throw a statement for one value less than 1', () => {
    expect(findLcm(1, 0)).toBe('Please enter values greater than zero.')
    expect(findLcm(0, 1)).toBe('Please enter values greater than zero.')
  })

  it('should return an error for values non-integer values', () => {
    expect(findLcm(4.564, 7.39)).toBe('Please enter whole numbers.')
  })

  it('should return the LCM of two given integers', () => {
    expect(findLcm(27, 36)).toBe(108)
  })
})
import { integralEvaluation } from '../SimpsonIntegration'

test('Should return the integral of f(x) = sqrt(x) in [1, 3] to be equal 2.797434', () => {
  const result = integralEvaluation(16, 1, 3, (x) => { return Math.sqrt(x) })
  expect(Number(result.toPrecision(7))).toBe(2.797434)
})

test('Should return the integral of f(x) = sqrt(x) + x^2 in [1, 3] to be equal 11.46410161', () => {
  const result = integralEvaluation(64, 1, 3, (x) => { return Math.sqrt(x) + Math.pow(x, 2) })
  expect(Number(result.toPrecision(10))).toBe(11.46410161)
})

test('Should return the integral of f(x) = log(x) + Pi*x^3 in [5, 12] to be equal 15809.9141543', () => {
  const result = integralEvaluation(128, 5, 12, (x) => { return Math.log(x) + Math.PI * Math.pow(x, 3) })
  expect(Number(result.toPrecision(12))).toBe(15809.9141543)
})
import { agm } from '../ArithmeticGeometricMean.js'

describe('Tests for AGM', () => {
  it('should be a function', () => {
    expect(typeof agm).toEqual('function')
  })

  it('number of parameters should be 2', () => {
    expect(agm.length).toEqual(2)
  })

  const m = 0x100 
  it('should return NaN if any or all params has a negative argument', () => {
        expect(agm(-1 * Math.random() * m, Math.random() * m)).toBe(NaN)
    expect(agm(Math.random() * m, -1 * Math.random() * m)).toBe(NaN)
    expect(agm(-1 * Math.random() * m, -1 * Math.random() * m)).toBe(NaN)
  })

  it('should return Infinity if any arg is Infinity and the other is not 0', () => {
    expect(agm(Math.random() * m + 1, Infinity)).toEqual(Infinity)
    expect(agm(Infinity, Math.random() * m + 1)).toEqual(Infinity)
    expect(agm(Infinity, Infinity)).toEqual(Infinity)
  })

  it('should return NaN if some arg is Infinity and the other is 0', () => {
    expect(agm(0, Infinity)).toBe(NaN)
    expect(agm(Infinity, 0)).toBe(NaN)
  })

  it('should return +0 if any or all args are +0 or -0, and return -0 if all are -0', () => {
    expect(agm(Math.random() * m, 0)).toBe(0)
    expect(agm(0, Math.random() * m)).toBe(0)
    expect(agm(Math.random() * m, -0)).toBe(0)
    expect(agm(-0, Math.random() * m)).toBe(0)
    expect(agm(0, -0)).toBe(0)
    expect(agm(-0, 0)).toBe(0)
    expect(agm(-0, -0)).toBe(-0)
  })

  it('should return NaN if any or all args are NaN', () => {
    expect(agm(Math.random() * m, NaN)).toBe(NaN)
    expect(agm(NaN, Math.random() * m)).toBe(NaN)
    expect(agm(NaN, NaN)).toBe(NaN)
  })

  it('should return an accurate approximation of the AGM between 2 valid input args', () => {
        expect(agm(1, 2)).toBeCloseTo(1.4567910310469068)
    expect(agm(2, 256)).toBeCloseTo(64.45940719438667)
    expect(agm(55555, 34)).toBeCloseTo(9933.4047239552)
        expect(agm(2 ** 48, 3 ** 27)).toBeCloseTo(88506556379265.7)
  })
})
import { powLinear, powFaster } from '../Pow'

describe('Testing powLinear function', () => {
  it('should return 1 for numbers with exponent 0', () => {
    expect(powLinear(2, 0)).toBe(1)
  })

  it('should return 0.5 for numbers with exponent -1', () => {
    expect(powLinear(2, -1)).toBe(0.5)
  })

  it('should return 0 for numbers with base 0', () => {
    expect(powLinear(0, 23)).toBe(0)
  })

  it('should return the base to the exponent power', () => {
    expect(powLinear(24, 4)).toBe(331776)
  })
})

describe('Testing powFaster function', () => {
  it('should return 1 for numbers with exponent 0', () => {
    expect(powFaster(2, 0)).toBe(1)
  })

  it('should return 0.5 for numbers with exponent -1', () => {
    expect(powFaster(2, -1)).toBe(0.5)
  })

  it('should return 0 for numbers with base 0', () => {
    expect(powFaster(0, 23)).toBe(0)
  })

  it('should return the base to the exponent power', () => {
    expect(powFaster(24, 4)).toBe(331776)
  })

  it('should return the result in O(lonN) complexity', () => {
    expect(powFaster(2, 64)).toBe(18446744073709552000)   })
})
import { exponent } from '../BinaryExponentiationIterative'

describe('exponent', () => {
  it('should return 1 when power is 0', () => {
    expect(exponent(5, 0)).toBe(1)
  })

  it('should return 0 when base is 0', () => {
    expect(exponent(0, 7)).toBe(0)
  })

  it('should return the value of a base raised to a power', () => {
    expect(exponent(3, 5)).toBe(243)
  })
})
import { FindMinIterator } from '../FindMinIterator'

describe('FindMinIterator', () => {
  test('given empty array then min is undefined', () => {
    expect(FindMinIterator([])).toBeUndefined()
  })

  test('given single value array then min is found', () => {
    expect(FindMinIterator([1])).toBe(1)
    expect(FindMinIterator([-1])).toBe(-1)
    expect(FindMinIterator([0])).toBe(0)
  })

  test('given array then min is found', () => {
    expect(FindMinIterator([1, 2])).toBe(1)
    expect(FindMinIterator([-1, 10])).toBe(-1)
    expect(FindMinIterator([0, 100])).toBe(0)
    expect(FindMinIterator([100, 0])).toBe(0)
    expect(FindMinIterator([100, 50, 20, 0, -100, 0, 2, 30, 45, 99, 104, 23])).toBe(-100)
  })

  test('given empty generator then min is undefined', () => {
    const src = function* () { }     expect(FindMinIterator(src())).toBeUndefined()
  })

  test('given generator then min is found', () => {
    const src = function* () {       yield 1
      yield -1
      yield 0
    }
    expect(FindMinIterator(src())).toBe(-1)
  })

  test('given string generator then min string length is found', () => {
    const src = function* () {       yield 'abc'
      yield 'de'
      yield 'qwerty'
    }
    expect(FindMinIterator(src(), _x => _x.length)).toBe(2)
  })

  test('given array of objects then min accessor is found', () => {
    const array = [
      { name: 'Item #1', price: 1.0 },
      { name: 'Item #2', price: 0.0 },
      { name: 'Item #3', price: -1.0 }
    ]
    expect(FindMinIterator(array, _x => _x.price)).toBe(-1)
    expect(FindMinIterator(array, _x => _x.name)).toBe('Item #1')
  })
})
import {
  FibonacciDpWithoutRecursion,
  FibonacciRecursiveDP,
  FibonacciIterative,
  FibonacciRecursive,
  FibonacciMatrixExpo
} from '../Fibonacci'

describe('Fibonacci', () => {
  it('should return an array of numbers for FibonacciIterative', () => {
    expect(FibonacciIterative(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return an array of numbers for FibonacciRecursive', () => {
    expect(FibonacciRecursive(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return number for FibonacciRecursiveDP', () => {
    expect(FibonacciRecursiveDP(5)).toBe(5)
  })

  it('should return an array of numbers for FibonacciDpWithoutRecursion', () => {
    expect(FibonacciDpWithoutRecursion(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return number for FibonacciMatrixExpo', () => {
    expect(FibonacciMatrixExpo(0)).toBe(0)
    expect(FibonacciMatrixExpo(1)).toBe(1)
    expect(FibonacciMatrixExpo(2)).toBe(1)
    expect(FibonacciMatrixExpo(3)).toBe(2)
    expect(FibonacciMatrixExpo(4)).toBe(3)
    expect(FibonacciMatrixExpo(5)).toBe(5)
  })
})
import { integralEvaluation } from '../MidpointIntegration'

test('Should return the integral of f(x) = sqrt(x) in [1, 3] to be equal 2.797434', () => {
  const result = integralEvaluation(10000, 1, 3, (x) => { return Math.sqrt(x) })
  expect(Number(result.toPrecision(6))).toBe(2.79743)
})

test('Should return the integral of f(x) = sqrt(x) + x^2 in [1, 3] to be equal 11.46410161', () => {
  const result = integralEvaluation(10000, 1, 3, (x) => { return Math.sqrt(x) + Math.pow(x, 2) })
  expect(Number(result.toPrecision(10))).toBe(11.46410161)
})

test('Should return the integral of f(x) = log(x) + Pi*x^3 in [5, 12] to be equal 15809.9141543', () => {
  const result = integralEvaluation(20000, 5, 12, (x) => { return Math.log(x) + Math.PI * Math.pow(x, 3) })
  expect(Number(result.toPrecision(10))).toBe(15809.91415)
})
import { fareyApproximation } from '../FareyApproximation'

describe('fareyApproximation', () => {
  it('Return Farey Approximation of 0.7538385', () => {
    const approx = fareyApproximation(0.7538385)
    expect(approx).toStrictEqual({ numerator: 52, denominator: 69 })
  })

  it('Return Farey Approximation of 0.23584936', () => {
    const approx = fareyApproximation(0.23584936)
    expect(approx).toStrictEqual({ numerator: 196, denominator: 831 })
  })
})
import { collatz } from '../CollatzSequence'

describe('The Collatz Sequence', () => {
  it('Should be 1', () => {
    expect(collatz(1)).toStrictEqual({ result: 1, steps: [] })
    expect(collatz(5)).toStrictEqual({ result: 1, steps: [16, 8, 4, 2, 1] })
  })
})
import { abs } from '../Abs'

describe('Testing abs function', () => {
  it('Testing for invalid types', () => {
    expect(() => abs('234a')).toThrow()
    expect(() => abs({})).toThrow()
    expect(() => abs([12, -32, -60])).toThrow()
  })

  it('Testing for number of string type', () => {
    expect(abs('-345')).toBe(345)
    expect(abs('-345.455645')).toBe(345.455645)
  })

  it('Testing for a boolean type', () => {
    expect(abs(true)).toBe(1)
    expect(abs(false)).toBe(0)
  })

  it('should return an absolute value of a negative number', () => {
    const absOfNegativeNumber = abs(-34)
    expect(absOfNegativeNumber).toBe(34)
  })

  it('should return an absolute value of a positive number', () => {
    const absOfPositiveNumber = abs(50)
    expect(absOfPositiveNumber).toBe(50)
  })

  it('should return an absolute value of a zero number', () => {
    const absOfPositiveNumber = abs(0)
    expect(absOfPositiveNumber).toBe(0)
  })

  it('should return an absolute value of any floating number', () => {
    const absOfPositiveNumber = abs(-20.2034)
    expect(absOfPositiveNumber).toBe(20.2034)
  })
})
import { numberOfDigit } from '../NumberOfDigits'

describe('NumberOfDigits', () => {
  it('should return the correct number of digits for an integer', () => {
    expect(numberOfDigit(1234000)).toBe(7)
  })

  it('should return the correct number of digits for a negative number', () => {
    expect(numberOfDigit(-2346243)).toBe(7)
  })
})
import { getRGBData } from '../Mandelbrot'

describe('Mandelbrot', () => {
  it('should produce black pixels inside the set', () => {
    const blackAndWhite = getRGBData(800, 600, -0.6, 0, 3.2, 50, false)
    expect(blackAndWhite[400][300]).toEqual([0, 0, 0]) 
    const colorCoded = getRGBData(800, 600, -0.6, 0, 3.2, 50, true)
    expect(colorCoded[400][300]).toEqual([0, 0, 0])   })

  it('should produce white pixels outside of the set', () => {
    const blackAndWhite = getRGBData(800, 600, -0.6, 0, 3.2, 50, false)
    expect(blackAndWhite[0][0]).toEqual([255, 255, 255])   })

  it('should produce colored pixels distant to the set', () => {
    const colorCoded = getRGBData(800, 600, -0.6, 0, 3.2, 50, true)
    expect(colorCoded[0][0]).toEqual([255, 0, 0])   })
})
import { PrimeCheck } from '../PrimeCheck'

describe('PrimeCheck', () => {
  it('should return true for Prime Numbers', () => {
    expect(PrimeCheck(1000003)).toBeTruthy()
  })
  it('should return false for Non Prime Numbers', () => {
    expect(PrimeCheck(1000001)).toBeFalsy()
  })
  it('should return false for 1 and 0', () => {
    expect(PrimeCheck(1)).toBeFalsy()
    expect(PrimeCheck(0)).toBeFalsy()
  })
})
import { PrimeFactors } from '../PrimeFactors'

describe('EulersTotient', () => {
  it('should return the prime factors for 100', () => {
    expect(PrimeFactors(100)).toEqual([2, 2, 5, 5])
  })

  it('should return the prime factors for 2560', () => {
    expect(PrimeFactors(2560)).toEqual([2, 2, 2, 2, 2, 2, 2, 2, 2, 5])
  })
})
import { meanSquaredError } from '../MeanSquareError'

describe('meanSquareError', () => {
  it('should throw an error on non-array arguments', () => {
    expect(() => meanSquaredError(1, 4)).toThrow('Argument must be an Array')
  })

  it('should throw an error on non equal length ', () => {
    const firstArr = [1, 2, 3, 4, 5]
    const secondArr = [1, 2, 3]
    expect(() => meanSquaredError(firstArr, secondArr)).toThrow(
      'The two lists must be of equal length'
    )
  })

  it('should return the mean square error of two equal length arrays', () => {
    const firstArr = [1, 2, 3, 4, 5]
    const secondArr = [1, 3, 5, 6, 7]
    expect(meanSquaredError(firstArr, secondArr)).toBe(2.6)
  })
})
import * as volume from '../Volume'

test('Testing on volCuboid', () => {
  const volCuboid = volume.volCuboid(2.0, 5.0, 3)
  expect(volCuboid).toBe(30.0)
})

test('Testing on volCube', () => {
  const volCube = volume.volCube(2.0)
  expect(volCube).toBe(8.0)
})

test('Testing on volCone', () => {
  const volCone = volume.volCone(3.0, 8.0)
  expect(volCone).toBe(75.39822368615503)
})

test('Testing on volPyramid', () => {
  const volPyramid = volume.volPyramid(2.0, 3.0, 8.0)
  expect(volPyramid).toBe(16.0)
})

test('Testing on volCylinder', () => {
  const volCylinder = volume.volCylinder(3.0, 8.0)
  expect(volCylinder).toBe(226.1946710584651)
})

test('Testing on volTriangularPrism', () => {
  const volTriangularPrism = volume.volTriangularPrism(3.0, 6.0, 8.0)
  expect(volTriangularPrism).toBe(72.0)
})

test('Testing on volPentagonalPrism', () => {
  const volPentagonalPrism = volume.volPentagonalPrism(1.0, 4.0, 8.0)
  expect(volPentagonalPrism).toBe(80.0)
})

test('Testing on volSphere', () => {
  const volSphere = volume.volSphere(4.0)
  expect(volSphere).toBe(268.082573106329)
})

test('Testing on volHemisphere', () => {
  const volHemisphere = volume.volHemisphere(4.0)
  expect(volHemisphere).toBe(134.0412865531645)
})
import { averageMedian } from '../AverageMedian'

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([1, 2, 6, 4, 5])
  expect(medianValue).toBe(4)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([8, 9, 1, 2, 5, 10, 11])
  expect(medianValue).toBe(8)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([15, 18, 3, 9, 13, 5])
  expect(medianValue).toBe(11)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([1, 2, 3, 4, 6, 8])
  expect(medianValue).toBe(3.5)
})
import { binaryExponentiation } from '../BinaryExponentiationRecursive'

describe('BinaryExponentiationRecursive', () => {
  it('should calculate 2 to the power of 10 correctly', () => {
    expect(binaryExponentiation(2, 10)).toBe(1024)
  })

  it('should calculate 3 to the power of 9 correctly', () => {
    expect(binaryExponentiation(3, 9)).toBe(19683)
  })
})
import { gridGetX, gridGetY } from '../GridGet'

describe('GridGet', () => {
  it('should have a value of x for the 27th element if the square array has 400 elements', () => {
    expect(gridGetX(Math.sqrt(400), 27)).toEqual(8)
  })
  it('should have a value of x for the 11th element if the square array has 7 columns and 3 rows', () => {
    expect(gridGetX(7, 11)).toEqual(5)
  })
  it('should have a value of y for the 27th element if the square array has 400 elements', () => {
    expect(gridGetY(Math.sqrt(400), 27)).toEqual(2)
  })
  it('should have a value of y for the 11th element if the square array has 7 columns and 3 rows ', () => {
    expect(gridGetX(7, 11)).toEqual(5)
  })
})
import { powLogarithmic } from '../PowLogarithmic'

describe('PowLogarithmic', () => {
  it('should return 1 for numbers with exponent 0', () => {
    expect(powLogarithmic(2, 0)).toBe(1)
  })

  it('should return 0 for numbers with base 0', () => {
    expect(powLogarithmic(0, 23)).toBe(0)
  })

  it('should return the base to the exponent power', () => {
    expect(powLogarithmic(24, 4)).toBe(331776)
  })
})
import { modularBinaryExponentiation } from '../ModularBinaryExponentiationRecursive'

describe('modularBinaryExponentiation', () => {
  it('should return the binary exponentiation', () => {
    expect(modularBinaryExponentiation(2, 10, 17)).toBe(4)
  })
})
import {
  isTriangular,
  isTetrahedral,
  isPentatope,
  checkAll
} from '../FigurateNumber'

describe('FigurateNumber', () => {
  it('Triangular : should return true', () => {
    expect(isTriangular(1)).toEqual(true)
  })
  it('Triangular : should return true', () => {
    expect(isTriangular(3)).toEqual(true)
  })

  it('Triangular : should return false', () => {
    expect(isTriangular(5)).toEqual(false)
  })

  it('Triangular : should return true', () => {
    expect(isTriangular(171)).toEqual(true)
  })
  /

  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(1)).toEqual(true)
  })
  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(4)).toEqual(true)
  })

  it('Tetrahedral : should return false', () => {
    expect(isTetrahedral(3)).toEqual(false)
  })

  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(165)).toEqual(true)
  })

  /
  it('Pentatope : should return true', () => {
    expect(isPentatope(1)).toEqual(true)
  })
  it('Pentatope : should return true', () => {
    expect(isPentatope(5)).toEqual(true)
  })

  it('Pentatope : should return false', () => {
    expect(isPentatope(3)).toEqual(false)
  })

  it('Pentatope : should return true', () => {
    expect(isPentatope(1001)).toEqual(true)
  })
  /

  it('Check All : should return all true', () => {
    expect(checkAll(1)).toEqual({
      isTriangular: true,
      isTetrahedral: true,
      isPentatope: true
    })
  })

  it('Check All : should return all true,true,false', () => {
    expect(checkAll(15)).toEqual({
      isTriangular: true,
      isTetrahedral: false,
      isPentatope: true
    })
  })
})
import { findRoot } from '../BisectionMethod'

test('Equation f(x) = x^2 - 3*x + 2 = 0, has root x = 1 in [a, b] = [0, 1.5]', () => {
  const root = findRoot(0, 1.5, (x) => { return Math.pow(x, 2) - 3 * x + 2 }, 8)
  expect(root).toBe(0.9990234375)
})

test('Equation f(x) = ln(x) + sqrt(x) + π*x^2 = 0, has root x = 0.36247037 in [a, b] = [0, 10]', () => {
  const root = findRoot(0, 10, (x) => { return Math.log(x) + Math.sqrt(x) + Math.PI * Math.pow(x, 2) }, 32)
  expect(Number(Number(root).toPrecision(8))).toBe(0.36247037)
})

test('Equation f(x) = sqrt(x) + e^(2*x) - 8*x = 0, has root x = 0.93945851 in [a, b] = [0.5, 100]', () => {
  const root = findRoot(0.5, 100, (x) => { return Math.exp(2 * x) + Math.sqrt(x) - 8 * x }, 32)
  expect(Number(Number(root).toPrecision(8))).toBe(0.93945851)
})
import { BinaryConvert } from '../BinaryConvert'

describe('BinaryConvert', () => {
  it('should return the correct value', () => {
    expect(BinaryConvert(4)).toBe(100)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(12)).toBe(1100)
  })
  it('should return the correct value of the sum from two number', () => {
    expect(BinaryConvert(12 + 2)).toBe(1110)
  })
  it('should return the correct value of the subtract from two number', () => {
    expect(BinaryConvert(245 - 56)).toBe(10111101)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(254)).toBe(11111110)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(63483)).toBe(1111011111111011)
  })
})
import { eulerFull, eulerStep } from '../EulerMethod'

describe('eulerStep', () => {
  it('should calculate the next y value correctly', () => {
    expect(eulerStep(0, 0.1, 0, function (x, y) { return x })).toBe(0)
    expect(eulerStep(2, 1, 1, function (x, y) { return x * x })).toBe(5)
  })
})

describe('eulerFull', () => {
  it('should return all the points found', () => {
    expect(eulerFull(0, 3, 1, 0, function (x, y) { return x }))
      .toEqual([{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 1 }, { x: 3, y: 3 }])

    expect(eulerFull(3, 4, 0.5, 1, function (x, y) { return x * x }))
      .toEqual([{ x: 3, y: 1 }, { x: 3.5, y: 5.5 }, { x: 4, y: 11.625 }])
  })
})
import { zellersCongruenceAlgorithm } from '../ZellersCongruenceAlgorithm'

function testZeller (day, month, year, expected) {
  test('Testing on ' + day + '/' + month + '/' + year, () => {
    expect(zellersCongruenceAlgorithm(day, month, year)).toBe(expected)
  })
}

test('Testing on this/should/throw', () => {
  expect(() => {
    zellersCongruenceAlgorithm('this', 'should', 'error')
  }).toThrowError(new TypeError('Arguments are not all numbers.'))
})
testZeller(25, 1, 2013, 'Friday')
testZeller(26, 1, 2013, 'Saturday')
testZeller(16, 4, 2022, 'Saturday')
testZeller(25, 4, 2022, 'Monday')
import { piEstimation } from '../PiApproximationMonteCarlo'

describe('PiApproximationMonteCarlo', () => {
  it('should be between the range of 2 to 4', () => {
    const pi = piEstimation()
    const piRange = pi >= 2 && pi <= 4
    expect(piRange).toBeTruthy()
  })
})
import { extendedEuclideanGCD } from '../ExtendedEuclideanGCD'

describe('extendedEuclideanGCD', () => {
  it('should return valid values in order for positive arguments', () => {
    expect(extendedEuclideanGCD(240, 46)).toMatchObject([2, -9, 47])
    expect(extendedEuclideanGCD(46, 240)).toMatchObject([2, 47, -9])
  })
  it('should give error on non-positive arguments', () => {
    expect(() => extendedEuclideanGCD(0, 240)).toThrowError(new TypeError('Must be positive numbers'))
    expect(() => extendedEuclideanGCD(46, -240)).toThrowError(new TypeError('Must be positive numbers'))
  })
  it('should give error on non-numeric arguments', () => {
    expect(() => extendedEuclideanGCD('240', 46)).toThrowError(new TypeError('Not a Number'))
    expect(() => extendedEuclideanGCD([240, 46])).toThrowError(new TypeError('Not a Number'))
  })
})
/


function lucas (index) {
    if (index < 0) throw new TypeError('Index cannot be Negative')

    if (Math.floor(index) !== index) throw new TypeError('Index cannot be a Decimal')

  let a = 2
  let b = 1
  for (let i = 0; i < index; i++) {
    const temp = a + b
    a = b
    b = temp
  }
  return a
}

export { lucas }
/

const modularBinaryExponentiation = (a, n, m) => {
      if (n === 0) {
    return 1
  } else if (n % 2 === 1) {
    return (modularBinaryExponentiation(a, n - 1, m) * a) % m
  } else {
    const b = modularBinaryExponentiation(a, n / 2, m)
    return (b * b) % m
  }
}

export { modularBinaryExponentiation }


const abs = (num) => {
  const validNumber = +num 
  if (Number.isNaN(validNumber)) {
    throw new TypeError('Argument is NaN - Not a Number')
  }

  return validNumber < 0 ? -validNumber : validNumber }

export { abs }

const powLinear = (base, exponent) => {
  if (exponent < 0) {
    base = 1 / base
    exponent = -exponent
  }

  let result = 1

  while (exponent--) {     result *= base
  }

  return result
}


const powFaster = (base, exponent) => {
  if (exponent < 2) {     return base && ([1, base][exponent] || powFaster(1 / base, -exponent))
  }

  if (exponent & 1) {     return base * powFaster(base * base, exponent >> 1)   }

  return powFaster(base * base, exponent / 2)
}





export { powLinear, powFaster }


const findMin = (...nums) => {
  if (nums.length === 0) {
    throw new TypeError('Array is empty')
  }

  let min = nums[0]
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] < min) {
      min = nums[i]
    }
  }

  return min
}

export { findMin }
/

export const EulersTotient = (n) => {
      let res = n
  for (let i = 2; i * i <= n; i++) {
    if (n % i === 0) {
      while (n % i === 0) {
        n = Math.floor(n / i)
      }
                  res = res - Math.floor(res / i)
    }
  }
  if (n > 1) {
    res = res - Math.floor(res / n)
  }
  return res
}


const PalindromeRecursive = (string) => {
    if (string.length < 2) return true

    if (string[0] !== string[string.length - 1]) {
    return false
  }

  return PalindromeRecursive(string.slice(1, string.length - 1))
}

const PalindromeIterative = (string) => {
  const _string = string
    .toLowerCase()
    .replace(/ /g, '')
    .replace(/,/g, '')
    .replace(/'.'/g, '')
    .replace(/:/g, '')
    .split('')

    while (_string.length > 1) {
    if (_string.shift() !== _string.pop()) {
      return false
    }
  }

  return true
}

export { PalindromeIterative, PalindromeRecursive }
/

function integralEvaluation (N, a, b, func) {
    let isNEven = true
  if (N % 2 !== 0) isNEven = false

  if (!Number.isInteger(N) || Number.isNaN(a) || Number.isNaN(b)) { throw new TypeError('Expected integer N and finite a, b') }
  if (!isNEven) { throw Error('N is not an even number') }
  if (N <= 0) { throw Error('N has to be >= 2') }

    if (a > b) { throw Error('a must be less or equal than b') }
  if (a === b) return 0

    const h = (b - a) / N

    let xi = a   const pointsArray = []

    let temp
  for (let i = 0; i < N + 1; i++) {
    if (i === 0 || i === N) temp = func(xi)
    else if (i % 2 === 0) temp = 2 * func(xi)
    else temp = 4 * func(xi)

    pointsArray.push(temp)
    xi += h
  }

    let result = h / 3
  temp = 0
  for (let i = 0; i < pointsArray.length; i++) temp += pointsArray[i]

  result *= temp

  if (Number.isNaN(result)) { throw Error("Result is NaN. The input interval doesn't belong to the functions domain") }

  return result
}

export { integralEvaluation }
/

'use strict'

const findLcm = (num1, num2) => {
    if (num1 < 1 || num2 < 1) {
    return 'Please enter values greater than zero.'
  }

    if (num1 !== Math.round(num1) || num2 !== Math.round(num2)) {
    return 'Please enter whole numbers.'
  }

    const maxNum = Math.max(num1, num2)
  let lcm = maxNum

  while (true) {
    if (lcm % num1 === 0 && lcm % num2 === 0) return lcm
    lcm += maxNum
  }
}

export { findLcm }


export const agm = (a, g) => {
  if (a === Infinity && g === 0) return NaN
  if (Object.is(a, -0) && !Object.is(g, -0)) return 0
  if (a === g) return a   let x   do {
    [a, g, x] = [(a + g) / 2, Math.sqrt(a * g), a]
  } while (a !== x && !isNaN(a))
  /
  return a
}


const BinaryConvert = (num) => {
  let power = 1
  let binary = 0

  while (num) {
    const rem = num % 2
    num = Math.floor(num / 2)
    binary = rem * power + binary
    power *= 10
  }

  return binary
}

export { BinaryConvert }
/

const gridGetX = (columns, index) => {
  while (index + 1 > columns) {
    index = index - columns
  }
  return index + 1
}

const gridGetY = (columns, index) => {
  return Math.floor(index / columns) + 1
}

export { gridGetX, gridGetY }


const factorsOfANumber = (number = 0) => {
  return Array.from(Array(number + 1).keys()).filter(
    (num) => number % num === 0
  )
}

export { factorsOfANumber }

const piEstimation = (iterations = 100000) => {
  let circleCounter = 0

  for (let i = 0; i < iterations; i++) {
        const x = Math.random()
    const y = Math.random()
    const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))

    if (radius < 1) circleCounter += 1
  }

    const pi = (circleCounter / iterations) * 4
  return pi
}

export { piEstimation }


const armstrongNumber = (num) => {
  if (num < 0 || typeof num !== 'number') return false

  let newSum = 0

  const numArr = num.toString().split('')
  numArr.forEach((num) => {
    newSum += parseInt(num) ** numArr.length
  })

  return newSum === num
}

export { armstrongNumber }


const findRoot = (a, b, func, numberOfIterations) => {
    const belongsToDomain = (x, f) => {
    const res = f(x)
    return !Number.isNaN(res)
  }
  if (!belongsToDomain(a, func) || !belongsToDomain(b, func)) throw Error("Given interval is not a valid subset of function's domain")

    const hasRoot = (a, b, func) => {
    return func(a) * func(b) < 0
  }
  if (hasRoot(a, b, func) === false) { throw Error('Product f(a)*f(b) has to be negative so that Bolzano theorem is applied') }

    const m = (a + b) / 2

    if (numberOfIterations === 0) { return m }

    const fm = func(m)
  const prod1 = fm * func(a)
  const prod2 = fm * func(b)

    if (prod1 > 0 && prod2 < 0) return findRoot(m, b, func, --numberOfIterations)
  else if (prod1 < 0 && prod2 > 0) return findRoot(a, m, func, --numberOfIterations)
  else throw Error('Unexpected behavior')
}

export { findRoot }
const addRow = (triangle) => {
  const previous = triangle[triangle.length - 1]
  const newRow = [1]
  for (let i = 0; i < previous.length - 1; i++) {
    const current = previous[i]
    const next = previous[i + 1]
    newRow.push(current + next)
  }
  newRow.push(1)
  return triangle.push(newRow)
}

const generate = (numRows) => {
  const triangle = [[1], [1, 1]]

  if (numRows === 0) {
    return []
  } else if (numRows === 1) {
    return [[1]]
  } else if (numRows === 2) {
    return [[1], [1, 1]]
  } else {
    for (let i = 2; i < numRows; i++) {
      addRow(triangle)
    }
  }
  return triangle
}

export { generate }
/

const PrimeCheck = (n) => {
      if (n === 1) return false
  if (n === 0) return false
  if (n === 2) return true
  if (n % 2 === 0) return false

  for (let i = 3; i * i <= n; i += 2) {
    if (n % i === 0) {
      return false
    }
  }
  return true
}

export { PrimeCheck }
const sieveOfEratosthenes = (n) => {
  /
  const primes = new Array(n + 1)
  primes.fill(true)   primes[0] = primes[1] = false   const sqrtn = Math.ceil(Math.sqrt(n))
  for (let i = 2; i <= sqrtn; i++) {
    if (primes[i]) {
      for (let j = i * i; j <= n; j += i) {
        /
        primes[j] = false
      }
    }
  }
  return primes
}

export { sieveOfEratosthenes }


const matrixCheck = (matrix) => {
  let columnNumb
  for (let index = 0; index < matrix.length; index++) {
    if (index === 0) {
      columnNumb = matrix[index].length
    } else if (matrix[index].length !== columnNumb) {
          } else {
      return columnNumb
    }
  }
}

const twoMatricesCheck = (first, second) => {
  const [firstRowLength, secondRowLength, firstColLength, secondColLength] = [first.length, second.length, matrixCheck(first), matrixCheck(second)]
  if (firstRowLength !== secondColLength || secondRowLength !== firstColLength) {
        return false
  } else {
    return true
  }
}

const initiateEmptyArray = (first, second) => {
  if (twoMatricesCheck(first, second)) {
    const emptyArray = first.map(() => {
      return ['']
    })
    return emptyArray
  } else {
    return false
  }
}

export const matrixMult = (firstArray, secondArray) => {
  const multMatrix = initiateEmptyArray(firstArray, secondArray)
  for (let rm = 0; rm < firstArray.length; rm++) {
    const rowMult = []
    for (let col = 0; col < firstArray[0].length; col++) {
      rowMult.push(firstArray[rm][col])
    }
    for (let cm = 0; cm < firstArray.length; cm++) {
      const colMult = []
      for (let row = 0; row < secondArray.length; row++) {
        colMult.push(secondArray[row][cm])
      }
      let newNumb = 0
      for (let index = 0; index < rowMult.length; index++) {
        newNumb += rowMult[index] * colMult[index]
      }
      multMatrix[rm][cm] = newNumb
    }
  }
  return multMatrix
}






function findMaxRecursion (arr, left, right) {
  const len = arr.length

  if (len === 0 || !arr) {
    return undefined
  }

  if (left >= len || left < -len || right >= len || right < -len) {
    throw new Error('Index out of range')
  }

  if (left === right) {
    return arr[left]
  }

    const mid = (left + right) >> 1

  const leftMax = findMaxRecursion(arr, left, mid)
  const rightMax = findMaxRecursion(arr, mid + 1, right)

    return Math.max(leftMax, rightMax)
}

export { findMaxRecursion }
/

/
function sumOfDigitsUsingString (number) {
  if (number < 0) number = -number

  return Number.parseInt(number.toString().split('').reduce((a, b) => Number(a) + Number(b)))
}

/
function sumOfDigitsUsingLoop (number) {
  if (number < 0) number = -number
  let res = 0

  while (number > 0) {
    res += number % 10
    number = Math.floor(number / 10)
  }

  return res
}

/
function sumOfDigitsUsingRecursion (number) {
  if (number < 0) number = -number

  if (number < 10) return number

  return (number % 10) + sumOfDigitsUsingRecursion(Math.floor(number / 10))
}

export { sumOfDigitsUsingRecursion, sumOfDigitsUsingLoop, sumOfDigitsUsingString }
/

const gcdOfTwoNumbers = (x, y) => {
            return x === 0 ? y : gcdOfTwoNumbers(y % x, x)
}

const eulersTotientFunction = (n) => {
  let countOfRelativelyPrimeNumbers = 1
  for (let iterator = 2; iterator <= n; iterator++) {
    if (gcdOfTwoNumbers(iterator, n) === 1) countOfRelativelyPrimeNumbers++
  }
  return countOfRelativelyPrimeNumbers
}

export { eulersTotientFunction }
/

const GetEuclidGCD = (arg1, arg2) => {
  let less = arg1 > arg2 ? arg2 : arg1
  for (less; less >= 2; less--) {
    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)
  }
  return (less)
}


const CoPrimeCheck = (firstNumber, secondNumber) => {
    if (typeof firstNumber !== 'number' || typeof secondNumber !== 'number') {
    return new TypeError('Argument is not a number.')
  }
  /
  return GetEuclidGCD(firstNumber, secondNumber) === 1
}

export { CoPrimeCheck }


const mean = (nums) => {
  if (!Array.isArray(nums)) {
    throw new TypeError('Invalid Input')
  }

    const sum = nums.reduce((sum, cur) => sum + cur, 0)

    return sum / nums.length
}

export { mean }
/

const averageMedian = (sourceArrayOfNumbers) => {
  let numbers = [...sourceArrayOfNumbers]
  let median = 0
  const numLength = numbers.length
  numbers = numbers.sort(sortNumbers)

  if (numLength % 2 === 0) {
    median = (numbers[numLength / 2 - 1] + numbers[numLength / 2]) / 2
  } else {
    median = numbers[(numLength - 1) / 2]
  }

  return median
}

const sortNumbers = (num1, num2) => {
  return num1 - num2
}

export { averageMedian }
/


export const degreeToRadian = (degree) => {
  return degree * (Math.PI / 180)
}
/


const GetEuclidGCD = (arg1, arg2) => {
    if (typeof arg1 !== 'number' || typeof arg2 !== 'number') {
    return new TypeError('Argument is not a number.')
  }
    if (arg1 < 1 || arg2 < 1) {
    return new TypeError('Argument is a negative number.')
  }
    let less = arg1 > arg2 ? arg2 : arg1
    for (less; less >= 2; less--) {
    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)
  }
  return (less)
}

export { GetEuclidGCD }



const factorial = (n) => {
  if (n >= 0) {
    if (n === 0) {
      return 1
    } else {
      return n * factorial(n - 1)
    }
  } else {
    return NaN
  }
}


const permutation = (n, r) => {
  return factorial(n) / factorial(n - r)
}


const combination = (n, r) => {
  return factorial(n) / (factorial(r) * factorial(n - r))
}

export { factorial, permutation, combination }


const numberOfDigit = (n) => Math.abs(n).toString().length

export { numberOfDigit }



const extendedEuclideanGCD = (arg1, arg2) => {
  if (typeof arg1 !== 'number' || typeof arg2 !== 'number') throw new TypeError('Not a Number')
  if (arg1 < 1 || arg2 < 1) throw new TypeError('Must be positive numbers')

    if (arg1 < arg2) {
    const res = extendedEuclideanGCD(arg2, arg1)
    const temp = res[1]
    res[1] = res[2]
    res[2] = temp
    return res
  }

  
    let r0 = arg1
  let r1 = arg2

    let s0 = 1
  let s1 = 0

    let t0 = 0
  let t1 = 1

  while (r1 !== 0) {
    const q = Math.floor(r0 / r1)

    const r2 = r0 - r1 * q
    const s2 = s0 - s1 * q
    const t2 = t0 - t1 * q

    r0 = r1
    r1 = r2
    s0 = s1
    s1 = s2
    t0 = t1
    t1 = t2
  }
  return [r0, s0, t0]
}

export { extendedEuclideanGCD }
/


function aliquotSum (input) {
    if (input < 0) throw new TypeError('Input cannot be Negative')

    if (Math.floor(input) !== input) throw new TypeError('Input cannot be a Decimal')

    if (input === 1) return 0

  let sum = 0
  for (let i = 1; i <= (input / 2); i++) {
    if (input % i === 0) sum += i
  }

  return sum
}

export { aliquotSum }
import { PrimeCheck } from './PrimeCheck'


function twinPrime (n) {
  const prime = PrimeCheck(n)

  if (!prime) {
    return -1
  }

  if (!PrimeCheck(n + 2)) {
    return -1
  }

  return n + 2
}

export { twinPrime }

export function eulerStep (xCurrent, stepSize, yCurrent, differentialEquation) {
    return yCurrent + stepSize * differentialEquation(xCurrent, yCurrent)
}

export function eulerFull (xStart, xEnd, stepSize, yStart, differentialEquation) {
    const points = [{ x: xStart, y: yStart }]
  let yCurrent = yStart
  let xCurrent = xStart

  while (xCurrent < xEnd) {
        yCurrent = eulerStep(xCurrent, stepSize, yCurrent, differentialEquation)
    xCurrent += stepSize
    points.push({ x: xCurrent, y: yCurrent })
  }

  return points
}
/

const findHCF = (x, y) => {
    if (x < 1 || y < 1) {
    return 'Please enter values greater than zero.'
  }

    if (x !== Math.round(x) || y !== Math.round(y)) {
    return 'Please enter whole numbers.'
  }

    while (Math.max(x, y) % Math.min(x, y) !== 0) {
    if (x > y) {
      x %= y
    } else {
      y %= x
    }
  }

    return Math.min(x, y)
}

export { findHCF }

export const isDivisible = (num1, num2) => {
  if (!Number.isFinite(num1) || !Number.isFinite(num2)) {
    throw new TypeError('Expected a number')
  }
  if (num2 === 0) {
    return false
  }
  return num1 % num2 === 0
}

/
export const factorialize = (num) => {
    let result = 1
    while (num > 1) {
    result *= num     num--   }
    return result
}


const factorsExcludingNumber = (n) => {
  return [...Array(n).keys()].filter((num) => n % num === 0)
}

const perfectNumber = (n) => {
  const factorSum = factorsExcludingNumber(n).reduce((num, initialValue) => {
    return num + initialValue
  }, 0)

  return factorSum === n
}

export { perfectNumber }
const list = []

const FibonacciIterative = (nth) => {
  const sequence = []

  if (nth >= 1) sequence.push(1)
  if (nth >= 2) sequence.push(1)

  for (let i = 2; i < nth; i++) {
    sequence.push(sequence[i - 1] + sequence[i - 2])
  }

  return sequence
}

const FibonacciRecursive = (number) => {
  return (() => {
    switch (list.length) {
      case 0:
        list.push(1)
        return FibonacciRecursive(number)
      case 1:
        list.push(1)
        return FibonacciRecursive(number)
      case number:
        return list
      default:
        list.push(list[list.length - 1] + list[list.length - 2])
        return FibonacciRecursive(number)
    }
  })()
}

const dict = new Map()

const FibonacciRecursiveDP = (stairs) => {
  if (stairs <= 0) return 0
  if (stairs === 1) return 1

    if (dict.has(stairs)) return dict.get(stairs)

  const res =
    FibonacciRecursiveDP(stairs - 1) + FibonacciRecursiveDP(stairs - 2)

  dict.set(stairs, res)

  return res
}


const FibonacciDpWithoutRecursion = (number) => {
  const table = []
  table.push(1)
  table.push(1)
  for (let i = 2; i < number; ++i) {
    table.push(table[i - 1] + table[i - 2])
  }
  return table
}


const copyMatrix = (A) => {
  return A.map(row => row.map(cell => cell))
}

const Identity = (size) => {
  const I = Array(size).fill(null).map(() => Array(size).fill())
  return I.map((row, rowIdx) => row.map((_col, colIdx) => {
    return rowIdx === colIdx ? 1 : 0
  }))
}

const matrixMultiply = (A, B) => {
  A = copyMatrix(A)
  B = copyMatrix(B)
  const l = A.length
  const m = B.length
  const n = B[0].length   const C = Array(l).fill(null).map(() => Array(n).fill())
  for (let i = 0; i < l; i++) {
    for (let j = 0; j < n; j++) {
      C[i][j] = 0
      for (let k = 0; k < m; k++) {
        C[i][j] += A[i][k] * B[k][j]
      }
    }
  }
  return C
}


const matrixExpo = (A, n) => {
  A = copyMatrix(A)

    let result = Identity(A.length)   while (n > 0) {
    if (n % 2 !== 0) result = matrixMultiply(result, A)
    n = Math.floor(n / 2)
    if (n > 0) A = matrixMultiply(A, A)
  }
  return result
}

const FibonacciMatrixExpo = (n) => {
      
      
      
  if (n === 0) return 0

  const A = [
    [1, 1],
    [1, 0]
  ]
  const poweredA = matrixExpo(A, n - 1)   let F = [
    [1],
    [0]
  ]
  F = matrixMultiply(poweredA, F)
  return F[0][0]
}

export { FibonacciDpWithoutRecursion }
export { FibonacciIterative }
export { FibonacciRecursive }
export { FibonacciRecursiveDP }
export { FibonacciMatrixExpo }

const Softmax = (inputs) => {
  const eulerExpOfAllInputs = inputs.map(input => Math.exp(input))
  const sumOfEulerExpOfAllInputs = eulerExpOfAllInputs.reduce((a, b) => a + b)

  return inputs.map((input) => {
    const eulerExpInputs = Math.exp(input)
    return eulerExpInputs / sumOfEulerExpOfAllInputs
  })
}

export { Softmax }
export const zellersCongruenceAlgorithm = (day, month, year) => {
  if (typeof day !== 'number' || typeof month !== 'number' || typeof year !== 'number') {
    throw new TypeError('Arguments are not all numbers.')
  }
  const q = day
  let m = month
  let y = year
  if (month < 3) {
    m += 12
    y -= 1
  }
  day =
      (q + Math.floor(26 * (m + 1) / 10) + (y % 100) + Math.floor((y % 100) / 4) + Math.floor(Math.floor(y / 100) / 4) + (5 * Math.floor(y / 100))) %
          7
  const days = [
    'Saturday',
    'Sunday',
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday'
  ]
  return days[day]
}

class Polynomial {
  constructor (array) {
    this.coefficientArray = array     this.polynomial = ''     this.construct()
  }

  /
  construct () {
    this.polynomial = this.coefficientArray
      .map((coefficient, exponent) => {
        if (coefficient === 0) {
          return '0'
        }
        if (exponent === 0) {
          return `(${coefficient})`
        } else if (exponent === 1) {
          return `(${coefficient}x)`
        } else {
          return `(${coefficient}x^${exponent})`
        }
      })
      .filter((x) =>
        x !== '0'
      )
      .reverse()
      .join(' + ')
  }

  /
  display () {
    return this.polynomial
  }

  /
  evaluate (value) {
    return this.coefficientArray.reduce((result, coefficient, exponent) => {
      return result + coefficient * Math.pow(value, exponent)
    }, 0)
  }
}

export { Polynomial }
/


const surfaceAreaCube = (side) => {
  validateNumericParam(side, 'side')
  return 6 * side ** 2
}


const surfaceAreaSphere = (radius) => {
  validateNumericParam(radius, 'radius')
  return 4.0 * Math.PI * radius ** 2.0
}


const areaRectangle = (length, width) => {
  validateNumericParam(length, 'Length')
  validateNumericParam(width, 'Width')
  return width * length
}


const areaSquare = (side) => {
  validateNumericParam(side, 'square side')
  return side ** 2
}


const areaTriangle = (base, height) => {
  validateNumericParam(base, 'Base')
  validateNumericParam(height, 'Height')
  return (base * height) / 2.0
}


const areaTriangleWithAllThreeSides = (side1, side2, side3) => {
  validateNumericParam(side1, 'side1')
  validateNumericParam(side2, 'side2')
  validateNumericParam(side3, 'side3')
  if (
    side1 + side2 <= side3 ||
    side1 + side3 <= side2 ||
    side2 + side3 <= side1
  ) {
    throw new TypeError('Invalid Triangle sides.')
  }
    const semi = (side1 + side2 + side3) / 2

    const area = Math.sqrt(
    semi * (semi - side1) * (semi - side2) * (semi - side3)
  )
  return Number(area.toFixed(2))
}


const areaParallelogram = (base, height) => {
  validateNumericParam(base, 'Base')
  validateNumericParam(height, 'Height')
  return base * height
}


const areaTrapezium = (base1, base2, height) => {
  validateNumericParam(base1, 'Base One')
  validateNumericParam(base2, 'Base Two')
  validateNumericParam(height, 'Height')
  return (1 / 2) * (base1 + base2) * height
}


const areaCircle = (radius) => {
  validateNumericParam(radius, 'Radius')
  return Math.PI * radius ** 2
}


const areaRhombus = (diagonal1, diagonal2) => {
  validateNumericParam(diagonal1, 'diagonal one')
  validateNumericParam(diagonal2, 'diagonal two')
  return (1 / 2) * diagonal1 * diagonal2
}

const validateNumericParam = (param, paramName = 'param') => {
  if (typeof param !== 'number') {
    throw new TypeError('The ' + paramName + ' should be type Number')
  } else if (param < 0) {
    throw new Error('The ' + paramName + ' only accepts non-negative values')
  }
}

export {
  surfaceAreaCube,
  surfaceAreaSphere,
  areaRectangle,
  areaSquare,
  areaTriangle,
  areaParallelogram,
  areaTrapezium,
  areaCircle,
  areaRhombus,
  areaTriangleWithAllThreeSides
}

const meanSquaredError = (predicted, expected) => {
  if (!Array.isArray(predicted) || !Array.isArray(expected)) {
    throw new TypeError('Argument must be an Array')
  }

  if (predicted.length !== expected.length) {
    throw new TypeError('The two lists must be of equal length')
  }

  let err = 0

  for (let i = 0; i < expected.length; i++) {
    err += (expected[i] - predicted[i]) ** 2
  }

  return err / expected.length
}

export { meanSquaredError }
/

export const PrimeFactors = (n) => {
      const primeFactors = []
  for (let i = 2; i * i <= n; i++) {
    while (n % i === 0) {
      primeFactors.push(i)
      n = Math.floor(n / i)
    }
  }
  if (n > 1) {
    primeFactors.push(n)
  }
  return primeFactors
}

export function decExp (a, b, base = 10, exp = [], d = {}, dlen = 0) {
  if (base < 2 || base > 10) {
    throw new RangeError('Unsupported base. Must be in range [2, 10]')
  }

  if (a === 0) {
    return [0, [], undefined]
  }

  if (a === b && dlen === 0) {
    return [1, [], undefined]
  }

      d[a] = dlen++

  if (a < b) {
    exp.push(0)
    return decExp(a * base, b, base, exp, d, dlen)
  }

    const r = a % b
  const q = (a - r) / b

    exp.push(+q.toString(base))

  if (r === 0) {
        return [exp[0], exp.slice(1), undefined]
  }

    a = r * base

      if (a in d) {
    return [exp[0], exp.slice(1), d[a] - 1]
  }

  return decExp(a, b, base, exp, d, dlen)
}
const LinearSieve = (n) => {
  /
  const isnPrime = new Array(n + 1)
  isnPrime[0] = isnPrime[1] = true
  const primes = []
  for (let i = 2; i <= n; i++) {
    if (!isnPrime[i]) primes.push(i)
    for (const p of primes) {
      const k = i * p
      if (k > n) break
      isnPrime[k] = true
      if (i % p === 0) break
    }
  }
  return primes
}

export { LinearSieve }

export function getRGBData (
  imageWidth = 800,
  imageHeight = 600,
  figureCenterX = -0.6,
  figureCenterY = 0,
  figureWidth = 3.2,
  maxStep = 50,
  useDistanceColorCoding = true) {
  if (imageWidth <= 0) {
    throw new Error('imageWidth should be greater than zero')
  }

  if (imageHeight <= 0) {
    throw new Error('imageHeight should be greater than zero')
  }

  if (maxStep <= 0) {
    throw new Error('maxStep should be greater than zero')
  }

  const rgbData = []
  const figureHeight = figureWidth / imageWidth * imageHeight

    for (let imageX = 0; imageX < imageWidth; imageX++) {
    rgbData[imageX] = []
    for (let imageY = 0; imageY < imageHeight; imageY++) {
            const figureX = figureCenterX + (imageX / imageWidth - 0.5) * figureWidth
      const figureY = figureCenterY + (imageY / imageHeight - 0.5) * figureHeight

      const distance = getDistance(figureX, figureY, maxStep)

            rgbData[imageX][imageY] =
        useDistanceColorCoding
          ? colorCodedColorMap(distance)
          : blackAndWhiteColorMap(distance)
    }
  }

  return rgbData
}


function blackAndWhiteColorMap (distance) {
  return distance >= 1 ? [0, 0, 0] : [255, 255, 255]
}


function colorCodedColorMap (distance) {
  if (distance >= 1) {
    return [0, 0, 0]
  } else {
            const hue = 360 * distance
    const saturation = 1
    const val = 255
    const hi = (Math.floor(hue / 60)) % 6
    const f = hue / 60 - Math.floor(hue / 60)

    const v = val
    const p = 0
    const q = Math.floor(val * (1 - f * saturation))
    const t = Math.floor(val * (1 - (1 - f) * saturation))

    switch (hi) {
      case 0:
        return [v, t, p]
      case 1:
        return [q, v, p]
      case 2:
        return [p, v, t]
      case 3:
        return [p, q, v]
      case 4:
        return [t, p, v]
      default:
        return [v, p, q]
    }
  }
}


function getDistance (figureX, figureY, maxStep) {
  let a = figureX
  let b = figureY
  let currentStep = 0
  for (let step = 0; step < maxStep; step++) {
    currentStep = step
    const aNew = a * a - b * b + figureX
    b = 2 * a * b + figureY
    a = aNew

            if (a * a + b * b > 4) {
      break
    }
  }
  return currentStep / (maxStep - 1)
}
/


const modularExponentiation = (base, exponent, modulus) => {
  if (modulus === 1) return 0 
  let result = 1
  base %= modulus 
  while (exponent > 0) {
        if (exponent % 2 === 1) {
      result = (result * base) % modulus
      exponent--
    } else {
      exponent = exponent / 2       base = (base * base) % modulus
    }
  }

  return result
}


const fermatPrimeCheck = (n, numberOfIterations = 50) => {
    if (n <= 1 || n === 4) return false
  if (n <= 3) return true 
  for (let i = 0; i < numberOfIterations; i++) {
        const randomNumber = Math.floor(Math.random() * (n - 2) + 2)

        if (modularExponentiation(randomNumber, n - 1, n) !== 1) {
      return false
    }
  }

      return true
}

export { modularExponentiation, fermatPrimeCheck }
/

/
const volCuboid = (width, length, height) => {
  isNumber(width, 'Width')
  isNumber(length, 'Length')
  isNumber(height, 'Height')
  return (width * length * height)
}

/
const volCube = (length) => {
  isNumber(length, 'Length')
  return (length ** 3)
}

/
const volCone = (radius, height) => {
  isNumber(radius, 'Radius')
  isNumber(height, 'Height')
  return (Math.PI * radius ** 2 * height / 3.0)
}

/
const volPyramid = (baseLength, baseWidth, height) => {
  isNumber(baseLength, 'BaseLength')
  isNumber(baseWidth, 'BaseWidth')
  isNumber(height, 'Height')
  return (baseLength * baseWidth * height) / 3.0
}

/
const volCylinder = (radius, height) => {
  isNumber(radius, 'Radius')
  isNumber(height, 'Height')
  return (Math.PI * radius ** 2 * height)
}

/
const volTriangularPrism = (baseLengthTriangle, heightTriangle, height) => {
  isNumber(baseLengthTriangle, 'BaseLengthTriangle')
  isNumber(heightTriangle, 'HeightTriangle')
  isNumber(height, 'Height')
  return (1 / 2 * baseLengthTriangle * heightTriangle * height)
}

/
const volPentagonalPrism = (pentagonalLength, pentagonalBaseLength, height) => {
  isNumber(pentagonalLength, 'PentagonalLength')
  isNumber(pentagonalBaseLength, 'PentagonalBaseLength')
  isNumber(height, 'Height')
  return (5 / 2 * pentagonalLength * pentagonalBaseLength * height)
}

/
const volSphere = (radius) => {
  isNumber(radius, 'Radius')
  return (4 / 3 * Math.PI * radius ** 3)
}

/
const volHemisphere = (radius) => {
  isNumber(radius, 'Radius')
  return (2.0 * Math.PI * radius ** 3) / 3.0
}

const isNumber = (number, noName = 'number') => {
  if (typeof number !== 'number') {
    throw new TypeError('The ' + noName + ' should be Number type')
  } else if (number < 0 || (!Number.isFinite(number))) {
    throw new Error('The ' + noName + ' only accepts positive values')
  }
}

export { volCuboid, volCube, volCone, volPyramid, volCylinder, volTriangularPrism, volPentagonalPrism, volSphere, volHemisphere }



const exponent = (x, n) => {
  let answer = 1
  while (n > 0) {
    if (n % 2 !== 0) answer *= x
    n = Math.floor(n / 2)
    if (n > 0) x *= x
  }
  return answer
}

export { exponent }
import { isEven } from './IsEven'


const powLogarithmic = (x, n) => {
  if (n === 0) return 1
  const result = powLogarithmic(x, Math.floor(n / 2))
  if (isEven(n)) {
    return result * result
  }
  return result * result * x
}

export { powLogarithmic }
/

'use strict'

const calcRange = (num) => {
  return [...Array(num).keys()].map(i => i + 1)
}

const calcFactorial = (num) => {
  if (num === 0) {
    return 'The factorial of 0 is 1.'
  }
  if (num < 0) {
    return 'Sorry, factorial does not exist for negative numbers.'
  }
  if (!num) {
    return 'Sorry, factorial does not exist for null or undefined numbers.'
  }
  if (num > 0) {
    const range = calcRange(num)
    const factorial = range.reduce((a, c) => a * c, 1)
    return `The factorial of ${num} is ${factorial}`
  }
}

export { calcFactorial }
/


const ReverseNumber = (number) => {
    if (typeof number !== 'number') {
    return new TypeError('Argument is not a number.')
  }
    let reverseNumber = 0
    while (number > 0) {
        const lastDigit = number % 10
        reverseNumber = reverseNumber * 10 + lastDigit
        number = Math.floor(number / 10)
  }
  return reverseNumber
}

export { ReverseNumber }

export function collatz (n) {
  const steps = []

  while (n !== 1) {
    if (n % 2 === 0) {
      n = n / 2
    } else {
      n = 3 * n + 1
    }

    steps.push(n)
  }

  return { result: n, steps: steps }
}



const isTriangular = (number) => {
  for (let i = 0; i <= number; i++) {
    if ((i * (i + 1)) / 2 === number) {
      return true
    } else if ((i * (i + 1)) / 2 > number) {
      return false
    }
  }
  return false
}


const isTetrahedral = (number) => {
  for (let i = 1; i <= number; i++) {
    if ((i * (i + 1) * (i + 2)) / 6 === number) {
      return true
    } else if ((i * (i + 1) * (i + 2)) / 6 > number) {
      return false
    }
  }
  return false
}

const isPentatope = (number) => {
  for (let i = 1; i <= number; i++) {
    if ((i * (i + 1) * (i + 2) * (i + 3)) / 24 === number) {
      return true
    } else if ((i * (i + 1) * (i + 2) * (i + 3)) / 24 > number) {
      return false
    }
  }
  return false
}


const checkAll = (number) => {
  return {
    isTriangular: isTriangular(number),
    isTetrahedral: isTetrahedral(number),
    isPentatope: isPentatope(number)
  }
}
export { isTriangular }
export { isTetrahedral }
export { isPentatope }
export { checkAll }
/


function sumOfGeometricProgression (firstTerm, commonRatio, numOfTerms) {
  if (!Number.isFinite(numOfTerms)) {
    /
    if (Math.abs(commonRatio) < 1) return firstTerm / (1 - commonRatio)
    throw new Error('The geometric progression is diverging, and its sum cannot be calculated')
  }

  if (commonRatio === 1) return firstTerm * numOfTerms

  return (firstTerm * (Math.pow(commonRatio, numOfTerms) - 1)) / (commonRatio - 1)
}

export { sumOfGeometricProgression }

const validateEmail = (str) => {
  if (str === '' || str === null) {
    throw new TypeError('Email Address String Null or Empty.')
  }

  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(str)
}

export { validateEmail }

const upper = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

  return str.replace(
    /[a-z]/g, (char) => String.fromCharCode(char.charCodeAt() - 32)
  )
}

export default upper



const checkSnakeCase = (varName) => {
    if (typeof varName !== 'string') {
    throw new TypeError('Argument is not a string.')
  }

  const pat = /(.*?)_([a-zA-Z])*/
  return pat.test(varName)
}

export { checkSnakeCase }



const isScramble = (s1, s2) => {
  return helper({}, s1, s2)
}

const helper = function (dp, s1, s2) {
  const map = {}

  if (dp[s1 + s2] !== undefined) return dp[s1 + s2]
  if (s1 === s2) return true

  for (let j = 0; j < s1.length; j++) {
    if (map[s1[j]] === undefined) map[s1[j]] = 0
    if (map[s2[j]] === undefined) map[s2[j]] = 0
    map[s1[j]]++
    map[s2[j]]--
  }

  for (const key in map) {
    if (map[key] !== 0) {
      dp[s1 + s2] = false
      return false
    }
  }

  for (let i = 1; i < s1.length; i++) {
    if (
      (helper(dp, s1.substr(0, i), s2.substr(0, i)) &&
        helper(dp, s1.substr(i), s2.substr(i))) ||
      (helper(dp, s1.substr(0, i), s2.substr(s2.length - i)) &&
        helper(dp, s1.substr(i), s2.substr(0, s2.length - i)))
    ) {
      dp[s1 + s2] = true
      return true
    }
  }

  dp[s1 + s2] = false
  return false
}

export { isScramble }

const checkExceeding = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument is not a string')
  }

  const upperChars = str
    .toUpperCase()
    .replace(/[^A-Z]/g, '') 
  const adjacentDiffList = []

  for (let i = 0; i < upperChars.length - 1; i++) {
        const { [i]: char, [i + 1]: adjacentChar } = upperChars

    if (char !== adjacentChar) {
      adjacentDiffList.push(
        Math.abs(char.charCodeAt() - adjacentChar.charCodeAt())
      )
    }
  }

  for (let i = 0; i < adjacentDiffList.length - 1; i++) {
    const { [i]: charDiff, [i + 1]: secondCharDiff } = adjacentDiffList

    if (charDiff > secondCharDiff) {
      return false
    }
  }

  return true
}

export { checkExceeding }
import { checkWordOccurrence } from '../CheckWordOccurrence'

describe('Testing checkWordOccurrence', () => {
  it('expects throw on insert wrong string', () => {
    const value = 123

    expect(() => checkWordOccurrence(value)).toThrow()
  })

  it('expect throw on insert wrong param for case sensitive', () => {
    const value = 'hello'

    expect(() => checkWordOccurrence(value, value)).toThrow()
  })

  it('check occurrence with case sensitive', () => {
    const stringToTest = 'The quick brown fox jumps over the lazy dog'
    const expectResult = { The: 1, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, the: 1, lazy: 1, dog: 1 }

    expect(checkWordOccurrence(stringToTest)).toEqual(expectResult)
  })

  it('check occurrence with case insensitive', () => {
    const stringToTest = 'The quick brown fox jumps over the lazy dog'
    const expectResult = { the: 2, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, lazy: 1, dog: 1 }

    expect(checkWordOccurrence(stringToTest, true)).toEqual(expectResult)
  })
})
import { KMPSearch } from '../KMPPatternSearching'

describe('KMP Matcher', () => {
  it('TC1: expects to return matching indices for pattern in text', () => {
    const text = 'ABC ABCDAB ABCDABCDABDE'
    const pattern = 'ABCDABD'
    expect(KMPSearch(text, pattern)).toStrictEqual([15])
  })

  it('TC2: expects to return matching indices for pattern in text', () => {
    const text = 'ABC ABCDABD ABCDABCDABDE'
    const pattern = 'ABCDABD'
    expect(KMPSearch(text, pattern)).toStrictEqual([4, 16])
  })

  it('TC3: expects to return matching indices for pattern in text', () => {
    const text = 'AAAAA'
    const pattern = 'AAA'
    expect(KMPSearch(text, pattern)).toStrictEqual([0, 1, 2])
  })

  it('TC4: expects to return matching indices for pattern in text', () => {
    const text = 'ABCD'
    const pattern = 'BA'
    expect(KMPSearch(text, pattern)).toStrictEqual([])
  })
})
import { checkCamelCase } from '../CheckCamelCase'
describe('checkCamelCase', () => {
  it('expect to throw an error if input is not a string', () => {
    expect(() => checkCamelCase(null)).toThrow()
  })

  it('expects to return true if the input is in camel case format', () => {
    const value = 'dockerBuild'
    const result = checkCamelCase(value)
    expect(result).toBe(true)
  })

  it('expects to return false if the input is not in camel case format', () => {
    const value = 'docker_build'
    const result = checkCamelCase(value)
    expect(result).toBe(false)
  })
})
import { diceCoefficient } from '../DiceCoefficient'

describe('diceCoefficient', () => {
  it('should calculate edit distance between two strings', () => {
        expect(diceCoefficient('abc', 'abc')).toBe(1)
    expect(diceCoefficient('', '')).toBe(1)

        expect(diceCoefficient('a', '')).toBe(0)
    expect(diceCoefficient('', 'a')).toBe(0)

    expect(diceCoefficient('skate', 'ate')).toBe(0.66)

    expect(diceCoefficient('money', 'honey')).toBe(0.75)

    expect(diceCoefficient('love', 'hate')).toBe(0)

    expect(diceCoefficient('skilled', 'killed')).toBe(0.9)
  })
})
import { createPermutations } from '../CreatePermutations'

describe('createPermutations', () => {
  it('expects to generate 6 different combinations', () => {
    const text = 'abc'
    const SUT = createPermutations(text)
    expect(SUT).toStrictEqual(['abc', 'acb', 'bac', 'bca', 'cab', 'cba'])
  })
  it('expects to generate 2 different combinations', () => {
    const text = '12'
    const SUT = createPermutations(text)
    expect(SUT).toStrictEqual(['12', '21'])
  })
})
import reverseWords from '../ReverseWords'

describe('Testing the reverseWords function', () => {
  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => {
        reverseWords(input)
      }).toThrow('The given value is not a string')
    }
  )

  it('expects to reverse words to return a joined word', () => {
    expect(reverseWords('I Love JS')).toBe('JS Love I')
    expect(reverseWords('Hello World')).toBe('World Hello')
    expect(reverseWords('The Algorithms Javascript')).toBe('Javascript Algorithms The')
  })
})
import { AlternativeStringArrange } from '../AlternativeStringArrange'

test('AlternativeStringArrange(Agrtm, loih) -> Algorithm', () => {
  const str1 = 'Agrtm'
  const str2 = 'loih'
  const res = AlternativeStringArrange(str1, str2)
  expect(res).toEqual('Algorithm')
})

test('AlternativeStringArrange(JvSrp, aacit) -> JavaScript', () => {
  const str1 = 'JvSrp'
  const str2 = 'aacit'
  const res = AlternativeStringArrange(str1, str2)
  expect(res).toEqual('JavaScript')
})

test('AlternativeStringArrange(abc, def) -> adbecf', () => {
  const str1 = 'abc'
  const str2 = 'def'
  const res = AlternativeStringArrange(str1, str2)
  expect(res).toEqual('adbecf')
})
import { checkAnagramMap, checkAnagramRegex } from '../CheckAnagram'

describe('Testing checkAnagramRegex', () => {
  it.each`
    inputOne              | inputTwo
    ${123456}             | ${'abcd'}
    ${[1, 2, 3, 4, 5, 6]} | ${'abcd'}
    ${{ test: 'test' }}   | ${'abcd'}
    ${'abcd'}             | ${123456}
    ${'abcd'}             | ${[1, 2, 3, 4, 5, 6]}
    ${'abcd'}             | ${{ test: 'test' }}
  `(
    'expects to throw the type Error given values $inputOne and $inputTwo',
    ({ inputOne, inputTwo }) => {
      expect(
        () => checkAnagramRegex(inputOne, inputTwo)
      ).toThrowError()
    }
  )

  it('expects to return false if the arguments have different lengths', () => {
    const SUT = checkAnagramRegex('abs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return false if the arguments are not anagrams', () => {
    const SUT = checkAnagramRegex('abcs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return true if the arguments are anagrams', () => {
    const SUT = checkAnagramRegex('abcd', 'bcad')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of length 1 and are the same letter', () => {
    const SUT = checkAnagramRegex('a', 'a')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of are both empty strings', () => {
    const SUT = checkAnagramRegex('', '')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an odd length', () => {
    const SUT = checkAnagramRegex('abcde', 'edcab')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an even length', () => {
    const SUT = checkAnagramRegex('abcdef', 'fedcab')
    expect(SUT).toBe(true)
  })

  it('expects to return false if either argument is an empty string while the other is not', () => {
    const SUT = checkAnagramRegex('', 'edcab')
    expect(SUT).toBe(false)
    const SUT2 = checkAnagramRegex('edcab', '')
    expect(SUT2).toBe(false)
  })

  it('expects to return true if the arguments contain the same letters but have unequal case', () => {
    const SUT = checkAnagramRegex('ABDCE', 'abcde')
    expect(SUT).toBe(true)
    const SUT2 = checkAnagramRegex('AbCdE', 'aBCdE')
    expect(SUT2).toBe(true)
    const SUT3 = checkAnagramRegex('Eleven plus two', 'Twelve plus one')
    expect(SUT3).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain number characters', () => {
    const SUT = checkAnagramRegex('a1b2', '12ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain space characters', () => {
    const SUT = checkAnagramRegex('a1 b2', '1 2ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain punctuation characters', () => {
    const SUT = checkAnagramRegex('a!1b@2', '1@2ba!')
    expect(SUT).toBe(true)
  })

  it('expects to return false if the arguments contain the same letters but contain a different amount of space characters', () => {
    const SUT = checkAnagramRegex('ea        cb', 'e cba')
    expect(SUT).toBe(false)
  })
})

describe('Testing checkAnagramMap', () => {
  it.each`
    inputOne              | inputTwo
    ${123456}             | ${'abcd'}
    ${[1, 2, 3, 4, 5, 6]} | ${'abcd'}
    ${{ test: 'test' }}   | ${'abcd'}
    ${'abcd'}             | ${123456}
    ${'abcd'}             | ${[1, 2, 3, 4, 5, 6]}
    ${'abcd'}             | ${{ test: 'test' }}
  `(
    'expects to throw the type Error given values $inputOne and $inputTwo',
    ({ inputOne, inputTwo }) => {
      expect(
        () => checkAnagramMap(inputOne, inputTwo)
      ).toThrowError()
    }
  )

  it('expects to return false if the arguments have different lengths', () => {
    const SUT = checkAnagramMap('abs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return false if the arguments are not anagrams', () => {
    const SUT = checkAnagramMap('abcs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return true if the arguments are anagrams', () => {
    const SUT = checkAnagramMap('abcd', 'bcad')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of length 1 and are the same letter', () => {
    const SUT = checkAnagramMap('a', 'a')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of are both empty strings', () => {
    const SUT = checkAnagramMap('', '')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an odd length', () => {
    const SUT = checkAnagramMap('abcde', 'edcab')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an even length', () => {
    const SUT = checkAnagramMap('abcdef', 'fedcab')
    expect(SUT).toBe(true)
  })

  it('expects to return false if either argument is an empty string while the other is not', () => {
    const SUT = checkAnagramMap('', 'edcab')
    expect(SUT).toBe(false)
    const SUT2 = checkAnagramMap('edcab', '')
    expect(SUT2).toBe(false)
  })

  it('expects to return true if the arguments contain the same letters but have unequal case', () => {
    const SUT = checkAnagramMap('ABDCE', 'abcde')
    expect(SUT).toBe(true)
    const SUT2 = checkAnagramMap('AbCdE', 'aBCdE')
    expect(SUT2).toBe(true)
    const SUT3 = checkAnagramMap('Eleven plus two', 'Twelve plus one')
    expect(SUT3).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain number characters', () => {
    const SUT = checkAnagramMap('a1b2', '12ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain space characters', () => {
    const SUT = checkAnagramMap('a1 b2', '1 2ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain punctuation characters', () => {
    const SUT = checkAnagramMap('a!1b@2', '1@2ba!')
    expect(SUT).toBe(true)
  })

  it('expects to return false if the arguments contain the same letters but contain a different amount of space characters', () => {
    const SUT = checkAnagramMap('ea        cb', 'e cba')
    expect(SUT).toBe(false)
  })
})
import { countVowels } from '../CountVowels'

describe('CountVowels', () => {
  it('expect throws on use wrong param', () => {
    expect(() => countVowels(0)).toThrow()
  })

  it('count the vowels in a string', () => {
    const value = 'Mad World'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return 0 when input is a string with no vowels', () => {
    const value = 'bcdfgh'
    const count = countVowels(value)
    expect(count).toBe(0)
  })

  it('should return 1 when input is a string of length 1 that is a vowel', () => {
    const value = 'a'
    const count = countVowels(value)
    expect(count).toBe(1)
  })

  it('should return the correct result when input is in all uppercase letters', () => {
    const value = 'ABCDE'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return the correct result when input is in all lowercase letters', () => {
    const value = 'abcdefghi'
    const count = countVowels(value)
    expect(count).toBe(3)
  })

  it('should return the correct result when input string contains spaces', () => {
    const value = 'abc def   ghi'
    const count = countVowels(value)
    expect(count).toBe(3)
  })

  it('should return the correct result when input contains number characters', () => {
    const value = 'a1b2c3'
    const count = countVowels(value)
    expect(count).toBe(1)
  })

  it('should return the correct result when input contains punctuation characters', () => {
    const value = 'a!b.ce)'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return 0 when the input is an empty string', () => {
    const value = ''
    const count = countVowels(value)
    expect(count).toBe(0)
  })

  it('should count multiple occurrences of the same vowel in the input', () => {
    const value = 'aaaaa'
    const count = countVowels(value)
    expect(count).toBe(5)
  })
})
import { permutate } from '../PermutateString'

describe('Permutate a string', () => {
  it('expects to throw an Error with an empty string', () => {
    expect(() => { permutate() }).toThrow('The arg must be a valid, non empty string')
  })
  it('expects to permute "no" into [no, on]', () => {
    expect(['no', 'on']).toEqual(permutate('no'))
  })
  it('expects to permute "yes" into [esy, eys, sey, sye, yes, yse]', () => {
    expect(['esy', 'eys', 'sey', 'sye', 'yes', 'yse']).toEqual(permutate('yes'))
  })
  it('expects to permute "good" into [dgoo dogo doog gdoo godo good odgo odog ogdo ogod oodg oogd ]', () => {
    expect(['dgoo', 'dogo', 'doog', 'gdoo', 'godo', 'good', 'odgo', 'odog', 'ogdo', 'ogod', 'oodg', 'oogd'])
      .toEqual(permutate('good'))
  })
})
import lower from '../Lower'

describe('Testing the Lower function', () => {
  it('Test 1: Check by invalid type', () => {
    expect(() => lower(345)).toThrowError()
    expect(() => lower(true)).toThrowError()
    expect(() => lower(null)).toThrowError()
  })

  it('Test 2: Check by uppercase string', () => {
    expect(lower('WORLD')).toBe('world')
    expect(lower('Hello_WORLD')).toBe('hello_world')
  })

  it('Test 3: Check by lowercase string', () => {
    expect(lower('hello')).toBe('hello')
    expect(lower('hello_world')).toBe('hello_world')
  })
})
import { validateCreditCard } from '../ValidateCreditCard'

describe('Validate credit card number', () => {
  it('should throw error if card number is boolean', () => {
    const invalidCC = true
    expect(() => validateCreditCard(invalidCC)).toThrow(
      'The given value is not a string'
    )
  })
  it('returns true if the credit card number is valid', () => {
    const validCreditCard = '4111111111111111'
    const validationResult = validateCreditCard(validCreditCard)
    expect(validationResult).toBe(true)
  })
  it('should throw an error on non-numeric character in given credit card number', () => {
    const nonNumericCCNumbers = ['123ABCDEF', 'ABCDKDKD', 'ADS232']
    nonNumericCCNumbers.forEach(nonNumericCC => expect(() => validateCreditCard(nonNumericCC)).toThrow(
      `${nonNumericCC} is an invalid credit card number because ` + 'it has nonnumerical characters.'
    ))
  })
  it('should throw an error on credit card with invalid length', () => {
    const ccWithInvalidLength = ['41111', '4111111111111111111111']
    ccWithInvalidLength.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'of its length.'
    ))
  })
  it('should throw an error on credit card with invalid start substring', () => {
    const ccWithInvalidStartSubstring = ['12345678912345', '23456789123456', '789123456789123', '891234567891234', '912345678912345', '31345678912345', '32345678912345', '33345678912345', '38345678912345']
    ccWithInvalidStartSubstring.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'of its first two digits.'
    ))
  })
  it('should throw an error on credit card with luhn check fail', () => {
    const invalidCCs = ['411111111111111', '371211111111111', '49999999999999']
    invalidCCs.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'it fails the Luhn check.'
    ))
  })
})
import { palindromeRearranging } from '../CheckRearrangePalindrome'

test('palindromeRearranging(apple) -> false', () => {
  const word = 'apple'
  const res = palindromeRearranging(word)
  expect(res).toBeFalsy()
})

test('palindromeRearranging(aapplle) -> true', () => {
  const word = 'aapplle'
  const res = palindromeRearranging(word)
  expect(res).toBeTruthy()
})

test('palindromeRearranging(value) -> false', () => {
  const word = 'value'
  const res = palindromeRearranging(word)
  expect(res).toBeFalsy()
})

test('palindromeRearranging(aaeccrr) -> true', () => {
  const word = 'aaeccrr'
  const res = palindromeRearranging(word)
  expect(res).toBeTruthy()
})
import { maxWord } from '../MaxWord'

describe('Testing the maxWord function', () => {
  it('Expect throw with non string argument', () => {
    expect(() => maxWord(10)).toThrow()
  })
  it('get the max word', () => {
    const string = 'be be be be a a banana'
    const mostOccurringWord = maxWord(string)
    expect(mostOccurringWord).toBe('be')
  })
})
import { levenshteinDistance } from '../LevenshteinDistance'

describe('levenshteinDistance', () => {
  it('should calculate edit distance between two strings', () => {
    expect(levenshteinDistance('', '')).toBe(0)
    expect(levenshteinDistance('a', '')).toBe(1)
    expect(levenshteinDistance('', 'a')).toBe(1)
    expect(levenshteinDistance('abc', '')).toBe(3)
    expect(levenshteinDistance('', 'abc')).toBe(3)

        expect(levenshteinDistance('igloo', 'gloo')).toBe(1)

        expect(levenshteinDistance('firm', 'forge')).toBe(3)

        expect(levenshteinDistance('fighting', 'sitting')).toBe(3)

        expect(levenshteinDistance('ball', 'baseball')).toBe(4)

        expect(levenshteinDistance('baseball', 'foot')).toBe(8)
  })
})
import { checkPangramRegex, checkPangramSet } from '../CheckPangram'

describe('Testing checkPangramRegex function', () => {
  it('"The quick brown fox jumps over the lazy dog" is a pangram', () => {
    expect(
      checkPangramRegex('The quick brown fox jumps over the lazy dog')
    ).toBe(true)
  })

  it('"Waltz, bad nymph, for quick jigs vex." is a pangram', () => {
    expect(checkPangramRegex('Waltz, bad nymph, for quick jigs vex.')).toBe(true)
  })

  it('"Jived fox nymph grabs quick waltz." is a pangram', () => {
    expect(checkPangramRegex('Jived fox nymph grabs quick waltz.')).toBe(true)
  })

  it('"My name is Unknown" is NOT a pangram', () => {
    expect(checkPangramRegex('My name is Unknown')).toBe(false)
  })

  it('"The quick brown fox jumps over the la_y dog" is NOT a pangram', () => {
    expect(
      checkPangramRegex('The quick brown fox jumps over the la_y dog')
    ).toBe(false)
  })

  it('Throws an error if given param is not a string', () => {
    expect(() => {
      checkPangramRegex(undefined)
    }).toThrow('The given value is not a string')
  })
})

describe('Testing checkPangramSet function', () => {
  it('"The quick brown fox jumps over the lazy dog" is a pangram', () => {
    expect(
      checkPangramSet('The quick brown fox jumps over the lazy dog')
    ).toBe(true)
  })

  it('"Waltz, bad nymph, for quick jigs vex." is a pangram', () => {
    expect(checkPangramSet('Waltz, bad nymph, for quick jigs vex.')).toBe(true)
  })

  it('"Jived fox nymph grabs quick waltz." is a pangram', () => {
    expect(checkPangramSet('Jived fox nymph grabs quick waltz.')).toBe(true)
  })

  it('"My name is Unknown" is NOT a pangram', () => {
    expect(checkPangramSet('My name is Unknown')).toBe(false)
  })

  it('"The quick brown fox jumps over the la_y dog" is NOT a pangram', () => {
    expect(
      checkPangramSet('The quick brown fox jumps over the la_y dog')
    ).toBe(false)
  })

  it('Throws an error if given param is not a string', () => {
    expect(() => {
      checkPangramSet(undefined)
    }).toThrow('The given value is not a string')
  })
})
import { checkFlatCase } from '../CheckFlatCase'

describe('checkFlatCase function', () => {
  it('should return false when the input string is not in flatcase', () => {
    const actual = checkFlatCase('this is not in flatcase')
    expect(actual).toBe(false)
  })

  it('should return true when the input string is a single letter character', () => {
    const actual = checkFlatCase('a')
    expect(actual).toBe(true)
  })

  it('should return true when the input string is a string of lowercase letter characters with no spaces', () => {
    const actual = checkFlatCase('abcdefghijklmnopqrstuvwxyz')
    expect(actual).toBe(true)
  })
})
import formatPhoneNumber from '../FormatPhoneNumber'

describe('Testing the formatPhoneNumber functions', () => {
  it('expects to throw a type error', () => {
    expect(() => formatPhoneNumber('1234567')).toThrow('Invalid phone number!')
    expect(() => formatPhoneNumber('123456text')).toThrow('Invalid phone number!')
    expect(() => formatPhoneNumber(12345)).toThrow('Invalid phone number!')
  })

  it('expects to return the formatted phone number', () => {
    expect(formatPhoneNumber('1234567890')).toEqual('(123) 456-7890')
    expect(formatPhoneNumber('2124323322')).toEqual('(212) 432-3322')
    expect(formatPhoneNumber('1721543455')).toEqual('(172) 154-3455')
  })
})
import { checkPalindrome } from '../CheckPalindrome'

describe('checkPalindrome', () => {
  it('expects to return "Palindrome" if the given string is a palindrome', () => {
    const SUT = checkPalindrome('madam')
    expect(SUT).toBe('Palindrome')
  })
  it('expects to return "Empty string" if the given string is empty', () => {
    const SUT = checkPalindrome('')
    expect(SUT).toBe('Empty string')
  })
  it('expects to return "Not a string" if the given string is not a string', () => {
    const SUT = checkPalindrome(123)
    expect(SUT).toBe('Not a string')
  })
})
import { checkIfPatternExists } from '../PatternMatching'
describe('checkIfPatternExists', () => {
  it('expects to find a pattern with correct input', () => {
    const text = 'AABAACAADAABAAAABAA'
    const pattern = 'AABA'
    const SUT = checkIfPatternExists(text.toLowerCase(), pattern.toLowerCase())
    expect(SUT).toBe('Given pattern is found at index 0')
  })
  it('expects to return a message when there is no pattern', () => {
    const text = 'ABCDEFG'
    const pattern = 'AEG'
    const SUT = checkIfPatternExists(text.toLowerCase(), pattern.toLowerCase())
    expect(SUT).toBe(undefined)
  })
  it('expects to find a pattern independent of casing', () => {
    const text = 'AbCAAAAAAB'
    const pattern = 'abc'
    const SUT = checkIfPatternExists(text, pattern)
    expect(SUT).toBe(undefined)
  })
  it('expects to throw an error message when given input is not a string', () => {
    const text = 123444456
    const pattern = 123
    expect(() => checkIfPatternExists(text, pattern)).toThrow(
      'Given input is not a string'
    )
  })
})
import maxCharacter from '../MaxCharacter'

describe('Testing the maxCharacter function', () => {
  it('Expect throw with wrong arg', () => {
    expect(() => maxCharacter(123)).toThrow()
    expect(() => maxCharacter('')).toThrow()
  })

  it('Check the max character in string', () => {
    const theString = 'I can\'t do that'
    const maxCharInAllCount = maxCharacter(theString)
    const maxChar = maxCharacter(theString, /\s/)

    expect(maxCharInAllCount).toBe(' ')
    expect(maxChar).toBe('t')

    expect(maxCharacter('!!!Hello, World!!!', /[a-z]/)).toBe('!')

    expect(maxCharacter('!!!Hello, World!!!', /[^a-z]/i)).toBe('l')
  })
})
import { validateEmail } from '../ValidateEmail'

describe('Validation of an Email Address', () => {
  it('expects to return false', () => {
    expect(validateEmail('mahfoudh.arous.com')).toEqual(false)
  })

  it('expects to return false', () => {
    expect(validateEmail('mahfoudh.arous@com')).toEqual(false)
  })

  it('expects to return true', () => {
    expect(validateEmail('mahfoudh.arous@gmail.com')).toEqual(true)
  })

  it('expects to return true', () => {
    expect(validateEmail('icristianbaciu@.helsinki.edu')).toEqual(true)
  })

  it('expects to throw a type error', () => {
    expect(() => { validateEmail('') }).toThrow('Email Address String Null or Empty.')
    expect(() => { validateEmail(null) }).toThrow('Email Address String Null or Empty.')
  })
})
import { CheckKebabCase } from '../CheckKebabCase'

test('CheckKebabCase(The-Algorithms) -> true', () => {
  const word = 'The-Algorithms'
  const res = CheckKebabCase(word)
  expect(res).toBeTruthy()
})

test('CheckKebabCase(The Algorithms) -> false', () => {
  const word = 'The Algorithms'
  const res = CheckKebabCase(word)
  expect(res).toBeFalsy()
})
import { checkExceeding } from '../CheckExceeding'

describe('Testing CheckExceeding function', () => {
  it('Testing the invalid types', () => {
    expect(() => checkExceeding(Math.random())).toThrow('Argument is not a string')
    expect(() => checkExceeding(null)).toThrow('Argument is not a string')
    expect(() => checkExceeding(false)).toThrow('Argument is not a string')
    expect(() => checkExceeding(false)).toThrow('Argument is not a string')
  })

  it('Testing with empty string', () => {
    expect(checkExceeding('')).toBe(true)
  })

  it('Testing with linear alphabets', () => {
    expect(checkExceeding('a b c d e ')).toBe(true)
    expect(checkExceeding('f g h i j ')).toBe(true)
    expect(checkExceeding('k l m n o ')).toBe(true)
    expect(checkExceeding('p q r s t ')).toBe(true)
    expect(checkExceeding('u v w x y z')).toBe(true)
  })

  it('Testing not exceeding words', () => {
    expect(checkExceeding('Hello')).toBe(false)
    expect(checkExceeding('world')).toBe(false)
    expect(checkExceeding('update')).toBe(false)
    expect(checkExceeding('university')).toBe(false)
    expect(checkExceeding('dog')).toBe(false)
    expect(checkExceeding('exceeding')).toBe(false)
    expect(checkExceeding('resolved')).toBe(false)
    expect(checkExceeding('future')).toBe(false)
    expect(checkExceeding('fixed')).toBe(false)
    expect(checkExceeding('codes')).toBe(false)
    expect(checkExceeding('facebook')).toBe(false)
    expect(checkExceeding('vscode')).toBe(false)
  })

  it('Testing exceeding words', () => {
    expect(checkExceeding('bee')).toBe(true)     expect(checkExceeding('can')).toBe(true)     expect(checkExceeding('good')).toBe(true)     expect(checkExceeding('bad')).toBe(true)     expect(checkExceeding('play')).toBe(true)     expect(checkExceeding('delete')).toBe(true)   })
})
import { CheckPascalCase } from '../CheckPascalCase'

test('CheckPascalCase(TheAlgorithms) -> true', () => {
  const word = 'TheAlgorithms'
  const res = CheckPascalCase(word)
  expect(res).toBeTruthy()
})

test('CheckPascalCase(theAlgorithms) -> false', () => {
  const word = 'theAlgorithms'
  const res = CheckPascalCase(word)
  expect(res).toBeFalsy()
})

test('CheckPascalCase(The Algorithms) -> false', () => {
  const word = 'The Algorithms'
  const res = CheckPascalCase(word)
  expect(res).toBeFalsy()
})
import { validateURL } from '../ValidateUrl'

describe('ValidateUrl', () => {
  it('expects to return false', () => {
    expect(validateURL('google')).toEqual(false)
    expect(validateURL('link: https:  })

  it('expects to return true', () => {
    expect(validateURL('http:    expect(validateURL('https:    expect(validateURL('www.google.com')).toEqual(true)
  })
})
import { ReverseStringIterative, ReverseStringIterativeInplace } from '../ReverseString'

describe('ReverseStringIterative', () => {
  it('expects to reverse a simple string', () => {
    expect(ReverseStringIterative('reverse')).toEqual('esrever')
    expect(ReverseStringIterative('some')).toEqual('emos')
    expect(ReverseStringIterative('string')).toEqual('gnirts')
    expect(ReverseStringIterative('The Algorithms Javascript')).toEqual('tpircsavaJ smhtiroglA ehT')
  })

  it('expects to reverse a string with spaces in between', () => {
    expect(ReverseStringIterative('reverse me')).toEqual('em esrever')
  })

  it('expects to reverse a simple string without capitalizing the first letter', () => {
    expect(ReverseStringIterative('Javascript')).toEqual('tpircsavaJ')
  })

  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => ReverseStringIterative(input)).toThrow('The given value is not a string')
    }
  )

  it('expects to return a empty string with an empty string is given', () => {
    expect(ReverseStringIterative('')).toEqual('')
  })
})

describe('ReverseStringIterativeInplace', () => {
  it('expects to reverse a simple string', () => {
    expect(ReverseStringIterativeInplace('reverse')).toEqual('esrever')
    expect(ReverseStringIterativeInplace('some')).toEqual('emos')
    expect(ReverseStringIterativeInplace('string')).toEqual('gnirts')
    expect(ReverseStringIterativeInplace('The Algorithms Javascript')).toEqual('tpircsavaJ smhtiroglA ehT')
  })

  it('expects to reverse a simple string without capitalizing the first letter', () => {
    expect(ReverseStringIterativeInplace('Javascript')).toEqual('tpircsavaJ')
  })

  it('expects to return an empty string given an empty string', () => {
    expect(ReverseStringIterativeInplace('Javascript')).toEqual('tpircsavaJ')
  })

  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => ReverseStringIterativeInplace(input)).toThrow('The given value is not a string')
    }
  )
})
import upper from '../Upper'

describe('Testing the Upper function', () => {
  it('return uppercase strings', () => {
    expect(upper('hello')).toBe('HELLO')
    expect(upper('WORLD')).toBe('WORLD')
    expect(upper('hello_WORLD')).toBe('HELLO_WORLD')
  })
})
import { isScramble } from '../ScrambleStrings'

describe('ScrambleStrings', () => {
  it('expects to return true for same string', () => {
    expect(isScramble('a', 'a')).toBe(true)
  })

  it('expects to return false for non-scrambled strings', () => {
    expect(isScramble('abcde', 'caebd')).toBe(false)
  })

  it('expects to return true for scrambled strings', () => {
    expect(isScramble('great', 'rgeat')).toBe(true)
  })
})
import alphaNumericPalindrome from '../AlphaNumericPalindrome'

describe('Testing the alpha numeric palindrome', () => {
    it('Testing with valid alphabetic palindrome', () => {
    expect(alphaNumericPalindrome('eye')).toBe(true)
    expect(alphaNumericPalindrome('Madam')).toBe(true)
    expect(alphaNumericPalindrome('race CAR')).toBe(true)
    expect(alphaNumericPalindrome('A man, a plan, a canal. Panama')).toBe(true)
  })

  it('Testing with number and symbol', () => {
    expect(alphaNumericPalindrome('0_0 (: /-:) 0-0')).toBe(true)
    expect(alphaNumericPalindrome('03_|53411435|_30')).toBe(true)
  })

  it('Testing with alphabets and symbols', () => {
    expect(alphaNumericPalindrome('five|_/|evif')).toBe(true)
    expect(alphaNumericPalindrome('five|_/|four')).toBe(false)
  })
})
import { checkSnakeCase } from '../CheckSnakeCase'
describe('checkSnakeCase', () => {
  it('expect to throw an error if input is not a string', () => {
    expect(() => checkSnakeCase(0)).toThrow()
  })

  it('expects to return true if the input is in snake case format', () => {
    const value = 'docker_build'
    const result = checkSnakeCase(value)
    expect(result).toBe(true)
  })

  it('expects to return false if the input is not in snake case format', () => {
    const value = 'dockerBuild'
    const result = checkSnakeCase(value)
    expect(result).toBe(false)
  })
})
import { hammingDistance } from '../HammingDistance'

test('should throw an error when trying to compare the strings of different length', () => {
  const compareStringsOfDifferentLength = () => {
    hammingDistance('abc', 'abcd')
  }

  expect(compareStringsOfDifferentLength).toThrowError()
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('a', 'a')).toBe(0)
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('abc', 'add')).toBe(2)
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('1011101', '1001001')).toBe(2)
})
const checkPalindrome = (str) => {
    if (typeof str !== 'string') {
    return 'Not a string'
  }
  if (str.length === 0) {
    return 'Empty string'
  }
      const reversed = [...str].reverse().join('')
  return str === reversed ? 'Palindrome' : 'Not a Palindrome'
}

export { checkPalindrome }




export const hammingDistance = (a, b) => {
  if (a.length !== b.length) {
    throw new Error('Strings must be of the same length')
  }

  let distance = 0

  for (let i = 0; i < a.length; i += 1) {
    if (a[i] !== b[i]) {
      distance += 1
    }
  }

  return distance
}


const computeLPS = (pattern) => {
  const lps = Array(pattern.length)
  lps[0] = 0
  for (let i = 1; i < pattern.length; i++) {
    let matched = lps[i - 1]
    while (matched > 0 && pattern[i] !== pattern[matched]) {
      matched = lps[matched - 1]
    }
    if (pattern[i] === pattern[matched]) {
      matched++
    }
    lps[i] = matched
  }
  return lps
}


const KMPSearch = (text, pattern) => {
  if (!pattern || !text) {
    return []   }

      const lps = computeLPS(pattern)
  const result = []

  let matched = 0
  for (let i = 0; i < text.length; i++) {
    while (matched > 0 && text[i] !== pattern[matched]) {
      matched = lps[matched - 1]
    }
    if (text[i] === pattern[matched]) {
      matched++
    }
    if (matched === pattern.length) {
      result.push(i - pattern.length + 1)
      matched = lps[matched - 1]
    }
  }

  return result
}

export { KMPSearch }



const CheckPascalCase = (VarName) => {
    if (typeof VarName !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /^[A-Z][A-Za-z]*$/
  return pat.test(VarName)
}

export { CheckPascalCase }



const checkPangramRegex = (string) => {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  /
  return string.match(/([a-z])(?!.*\1)/gi).length === 26
}


const checkPangramSet = (string) => {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const lettersSet = new Set()

  for (const letter of string.toUpperCase()) {
    if (/[A-Z]/.test(letter)) {
            lettersSet.add(letter)
    }
  }

  return lettersSet.size === 26
}

export { checkPangramRegex, checkPangramSet }
/

const createPermutations = (str) => {
  const arr = str.split('')

    const strLen = arr.length
    const perms = []
  let rest
  let picked
  let restPerms
  let next

    if (strLen === 0) { return [str] }
    for (let i = 0; i < strLen; i++) {
    rest = Object.create(arr)
    picked = rest.splice(i, 1)

    restPerms = createPermutations(rest.join(''))

    for (let j = 0, jLen = restPerms.length; j < jLen; j++) {
      next = picked.concat(restPerms[j])
      perms.push(next.join(''))
    }
  }
  return perms
}
export { createPermutations }
/


function mapBigrams (string) {
  const bigrams = new Map()
  for (let i = 0; i < string.length - 1; i++) {
    const bigram = string.substring(i, i + 2)
    const count = bigrams.get(bigram)
    bigrams.set(bigram, (count || 0) + 1)
  }
  return bigrams
}


function countCommonBigrams (bigrams, string) {
  let count = 0
  for (let i = 0; i < string.length - 1; i++) {
    const bigram = string.substring(i, i + 2)
    if (bigrams.has(bigram)) count++
  }
  return count
}

function diceCoefficient (stringA, stringB) {
  if (stringA === stringB) return 1
  else if (stringA.length < 2 || stringB.length < 2) return 0

  const bigramsA = mapBigrams(stringA)

  const lengthA = stringA.length - 1
  const lengthB = stringB.length - 1

  let dice = (2 * countCommonBigrams(bigramsA, stringB)) / (lengthA + lengthB)

    dice = Math.floor(dice * 100) / 100

  return dice
}

export { diceCoefficient }
/

export const Guid = () => {
  const pattern = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
  let currentDateMilliseconds = new Date().getTime()
  return pattern.replace(/[xy]/g, currentChar => {
    const randomChar = (currentDateMilliseconds + Math.random() * 16) % 16 | 0
    currentDateMilliseconds = Math.floor(currentDateMilliseconds / 16)
    return (currentChar === 'x' ? randomChar : (randomChar & 0x7 | 0x8)).toString(16)
  })
}



const countVowels = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Input should be a string')
  }

  const vowelRegex = /[aeiou]/gi
  const vowelsArray = str.match(vowelRegex) || []

  return vowelsArray.length
}

export { countVowels }

const reverseWords = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  return str
    .split(/\s+/)     .reduceRight((reverseStr, word) => `${reverseStr} ${word}`, '')     .trim() }

export default reverseWords


export const palindromeRearranging = (str) => {
    if (typeof str !== 'string') {
    return 'Not a string'
  }
    if (str.length === 0) {
    return 'Empty string'
  }

      const charCounts = [...str].reduce((counts, char) => {
    counts[char] = counts[char] ? counts[char] + 1 : 1
    return counts
  }, {})
    return Object.values(charCounts).filter(count => count % 2 !== 0).length <= 1
}



/
const buildBadMatchTable = (str) => {
  const tableObj = {}
  const strLength = str.length
  for (let i = 0; i < strLength - 1; i++) {
    tableObj[str[i]] = strLength - 1 - i
  }
  if (tableObj[str[strLength - 1]] === undefined) {
    tableObj[str[strLength - 1]] = strLength
  }
  return tableObj
}

const boyerMoore = (str, pattern) => {
  const badMatchTable = buildBadMatchTable(pattern)
  let offset = 0
  const patternLastIndex = pattern.length - 1
  const maxOffset = str.length - pattern.length
    while (offset <= maxOffset) {
    let scanIndex = 0
    while (pattern[scanIndex] === str[scanIndex + offset]) {
      if (scanIndex === patternLastIndex) {
                return offset
      }
      scanIndex++
    }
    const badMatchString = str[offset + patternLastIndex]
    if (badMatchTable[badMatchString]) {
            offset += badMatchTable[badMatchString]
    } else {
      offset++
    }
  }
  return -1
}
export { boyerMoore }

const alphaNumericPalindrome = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

    const newStr = str.replace(/[^a-z0-9]+/ig, '').toLowerCase()
  const midIndex = newStr.length >> 1 
  for (let i = 0; i < midIndex; i++) {
    if (newStr.at(i) !== newStr.at(~i)) {       return false
    }
  }

  return true
}

export default alphaNumericPalindrome

function ReverseStringIterative (string) {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }
  let reversedString = ''
  let index

  for (index = string.length - 1; index >= 0; index--) {
    reversedString += string[index]
  }

  return reversedString
}


function ReverseStringIterativeInplace (string) {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const _string = string.split('')

  for (let i = 0; i < Math.floor(_string.length / 2); i++) {
    const first = _string[i]
    _string[i] = _string[_string.length - 1 - i]
    _string[_string.length - 1 - i] = first
  }

  return _string.join('')
}

export { ReverseStringIterative, ReverseStringIterativeInplace }



const checkCamelCase = (varName) => {
    if (typeof varName !== 'string') {
    throw new TypeError('Argument is not a string.')
  }

  const pat = /^[a-z][A-Za-z]*$/
  return pat.test(varName)
}

export { checkCamelCase }


const luhnValidation = (creditCardNumber) => {
  let validationSum = 0
  creditCardNumber.split('').forEach((digit, index) => {
    let currentDigit = parseInt(digit)
    if (index % 2 === 0) {
            currentDigit *= 2
            if (currentDigit > 9) {
        currentDigit %= 10
        currentDigit += 1
      }
    }
    validationSum += currentDigit
  })

  return validationSum % 10 === 0
}

const validateCreditCard = (creditCardString) => {
  const validStartSubString = ['4', '5', '6', '37', '34', '35'] 
  if (typeof creditCardString !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const errorMessage = `${creditCardString} is an invalid credit card number because `
  if (isNaN(creditCardString)) {
    throw new TypeError(errorMessage + 'it has nonnumerical characters.')
  }
  const creditCardStringLength = creditCardString.length
  if (!((creditCardStringLength >= 13) && (creditCardStringLength <= 16))) {
    throw new Error(errorMessage + 'of its length.')
  }
  if (!validStartSubString.some(subString => creditCardString.startsWith(subString))) {
    throw new Error(errorMessage + 'of its first two digits.')
  }
  if (!luhnValidation(creditCardString)) {
    throw new Error(errorMessage + 'it fails the Luhn check.')
  }

  return true
}

export { validateCreditCard }

const checkAnagramRegex = (str1, str2) => {
    if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    throw new TypeError('Both arguments should be strings.')
  }

    if (str1.length !== str2.length) {
    return false
  }

  /
  return ![...str1].reduce(
    (str2Acc, cur) => str2Acc.replace(new RegExp(cur, 'i'), ''),     str2
  )
}


const checkAnagramMap = (str1, str2) => {
    if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    throw new TypeError('Both arguments should be strings.')
  }

    if (str1.length !== str2.length) {
    return false
  }

  const str1List = Array.from(str1.toUpperCase()) 
    const str1Occurs = str1List.reduce(
    (map, char) => map.set(char, map.get(char) + 1 || 1),
    new Map()
  )

  for (const char of str2.toUpperCase()) {
        if (!str1Occurs.has(char)) {
      return false
    }

    let getCharCount = str1Occurs.get(char)
    str1Occurs.set(char, --getCharCount)

    getCharCount === 0 && str1Occurs.delete(char)
  }

  return true
}

export { checkAnagramRegex, checkAnagramMap }



const AlternativeStringArrange = (str1, str2) => {
    if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    return 'Not string(s)'
  }

    let outStr = ''

    const firstStringLength = str1.length
    const secondStringLength = str2.length
    const absLength = firstStringLength > secondStringLength ? firstStringLength : secondStringLength

    for (let charCount = 0; charCount < absLength; charCount++) {
        if (charCount < firstStringLength) {
      outStr += str1[charCount]
    }

        if (charCount < secondStringLength) {
      outStr += str2[charCount]
    }
  }

    return outStr
}

export { AlternativeStringArrange }
/
const checkIfPatternExists = (text, pattern) => {
  if (typeof text !== 'string' || typeof pattern !== 'string') {
    throw new TypeError('Given input is not a string')
  }
  const textLength = text.length   const patternLength = pattern.length 
    for (let i = 0; i <= textLength - patternLength; i++) {
            for (let j = 0; j < textLength; j++) {
      if (text[i + j] !== pattern[j]) break

                  if (j + 1 === patternLength) {
        return `Given pattern is found at index ${i}`
      }
    }
  }
}

export { checkIfPatternExists }
/

const levenshteinDistance = (a, b) => {
    const distanceMatrix = Array(b.length + 1)
    .fill(null)
    .map(() => Array(a.length + 1).fill(null))

    for (let i = 0; i <= a.length; i += 1) {
    distanceMatrix[0][i] = i
  }

    for (let j = 0; j <= b.length; j += 1) {
    distanceMatrix[j][0] = j
  }

  for (let j = 1; j <= b.length; j += 1) {
    for (let i = 1; i <= a.length; i += 1) {
      const indicator = a[i - 1] === b[j - 1] ? 0 : 1
            distanceMatrix[j][i] = Math.min(
        distanceMatrix[j][i - 1] + 1,         distanceMatrix[j - 1][i] + 1,         distanceMatrix[j - 1][i - 1] + indicator       )
    }
  }

  return distanceMatrix[b.length][a.length]
}

export { levenshteinDistance }



const checkFlatCase = (varname) => {
    if (typeof varname !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /^[a-z]*$/
  return pat.test(varname)
}

export { checkFlatCase }



const CheckKebabCase = (varName) => {
    if (typeof varName !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /(\w+)-(\w)([\w-]*)/
  return pat.test(varName) && !varName.includes('_')
}

export { CheckKebabCase }
'use strict'

const permutate = (aString) => {
  if (typeof aString !== 'string' || !aString) {
    throw new Error('The arg must be a valid, non empty string')
  }
  const characters = aString.split('')
  let permutations = [[characters.shift()]]
  while (characters.length) {
    const currentCharacter = characters.shift()
    permutations = calculateCurrentCharacterPermutation(permutations, currentCharacter)
  }
  return permutations
    .map(character => character.join(''))
    .filter((item, index, self) => (self.indexOf(item) === index))
    .sort()
}

const calculateCurrentCharacterPermutation = (allPermutations, currentCharacter) => {
  const currentPermutations = []
  allPermutations.forEach(permutation => {
    let index = 0
    while (index <= permutation.length) {
      const tmp = [...permutation]
      tmp.splice(index, 0, currentCharacter)
      currentPermutations.push(tmp)
      index++
    }
  })
  return currentPermutations
}

export { permutate }


const lower = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Invalid Input Type')
  }

  return str.replace(
    /[A-Z]/g, (char) => String.fromCharCode(char.charCodeAt() + 32)
  )
}

export default lower

const maxCharacter = (str, ignorePattern) => {   if (typeof str !== 'string') {
    throw new TypeError('Argument should be a string')
  } else if (!str) {
    throw new Error('The param should be a nonempty string')
  }

    const occurrenceMap = new Map()

  for (const char of str) {
    if (!ignorePattern?.test(char)) {
      occurrenceMap.set(char, occurrenceMap.get(char) + 1 || 1)
    }
  }

    let max = { char: '', occur: -Infinity }

  for (const [char, occur] of occurrenceMap) {
    if (occur > max.occur) {
      max = { char, occur }
    }
  }

  return max.char
}

export default maxCharacter

const checkWordOccurrence = (str, isCaseSensitive = false) => {
  if (typeof str !== 'string') {
    throw new TypeError('The first param should be a string')
  }

  if (typeof isCaseSensitive !== 'boolean') {
    throw new TypeError('The second param should be a boolean')
  }

  const modifiedStr = isCaseSensitive ? str.toLowerCase() : str

  return modifiedStr
    .split(/\s+/)     .reduce(
      (occurrence, word) => {
        occurrence[word] = occurrence[word] + 1 || 1
        return occurrence
      },
      {}
    )
}

export { checkWordOccurrence }


const maxWord = (sentence = '') => {
  if (typeof sentence !== 'string') {
    throw new TypeError('the param should be string')
  }

  if (!sentence) {
    return null
  }

  const words = sentence.split(' ')
  if (words.length < 2) {
    return words[0]
  }

  const occurrences = {}
  words.forEach(word => {
    occurrences[word.toLocaleLowerCase()] = occurrences[word.toLocaleLowerCase()] + 1 || 1
  })

  const max = Object.keys(occurrences).reduce((n, word) => {
    if (occurrences[word] > n.count) { return { word, count: occurrences[word] } } else { return n }
  }, { word: '', count: 0 })

  return max.word
}

export { maxWord }

const formatPhoneNumber = (phoneNumber) => {
  if ((phoneNumber.length !== 10) || isNaN(phoneNumber)) {
        throw new TypeError('Invalid phone number!')
  }

  let index = 0
  return '(XXX) XXX-XXXX'.replace(/X/g, () => phoneNumber[index++])
}

export default formatPhoneNumber

const validateURL = (url) => {
  const URL_PATTERN = /^(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})$/gi

  return URL_PATTERN.test(url)
}

export { validateURL }
function getParentPosition (position) {
    return Math.floor((position - 1) / 2)
}
function getChildrenPosition (position) {
    return [2 * position + 1, 2 * position + 2]
}

class PriorityQueue {
    constructor () {
    this._heap = []
    this.keys = {}
  }

  isEmpty () {
        return this._heap.length === 0
  }

  push (key, priority) {
        this._heap.push([key, priority])
    this.keys[key] = this._heap.length - 1
    this._shiftUp(this.keys[key])
  }

  pop () {
        this._swap(0, this._heap.length - 1)
    const [key] = this._heap.pop()
    delete this.keys[key]
    this._shiftDown(0)
    return key
  }

  contains (key) {
        return (key in this.keys)
  }

  update (key, priority) {
        const currPos = this.keys[key]
    this._heap[currPos][1] = priority
    const parentPos = getParentPosition(currPos)
    const currPriority = this._heap[currPos][1]
    let parentPriority = Infinity
    if (parentPos >= 0) {
      parentPriority = this._heap[parentPos][1]
    }
    const [child1Pos, child2Pos] = getChildrenPosition(currPos)
    let [child1Priority, child2Priority] = [Infinity, Infinity]
    if (child1Pos < this._heap.length) {
      child1Priority = this._heap[child1Pos][1]
    }
    if (child2Pos < this._heap.length) {
      child2Priority = this._heap[child2Pos][1]
    }

    if (parentPos >= 0 && parentPriority > currPriority) {
      this._shiftUp(currPos)
    } else if (child2Pos < this._heap.length &&
      (child1Priority < currPriority || child2Priority < currPriority)) {
      this._shiftDown(currPos)
    }
  }

  _shiftUp (position) {
        let currPos = position
    let parentPos = getParentPosition(currPos)
    let currPriority = this._heap[currPos][1]
    let parentPriority = Infinity
    if (parentPos >= 0) {
      parentPriority = this._heap[parentPos][1]
    }

    while (parentPos >= 0 && parentPriority > currPriority) {
      this._swap(currPos, parentPos)
      currPos = parentPos
      parentPos = getParentPosition(currPos)
      currPriority = this._heap[currPos][1]
      try {
        parentPriority = this._heap[parentPos][1]
      } catch (error) {
        parentPriority = Infinity
      }
    }
    this.keys[this._heap[currPos][0]] = currPos
  }

  _shiftDown (position) {
        let currPos = position
    let [child1Pos, child2Pos] = getChildrenPosition(currPos)
    let [child1Priority, child2Priority] = [Infinity, Infinity]
    if (child1Pos < this._heap.length) {
      child1Priority = this._heap[child1Pos][1]
    }
    if (child2Pos < this._heap.length) {
      child2Priority = this._heap[child2Pos][1]
    }
    let currPriority
    try {
      currPriority = this._heap[currPos][1]
    } catch {
      return
    }

    while (child2Pos < this._heap.length &&
      (child1Priority < currPriority || child2Priority < currPriority)) {
      if (child1Priority < currPriority && child1Priority < child2Priority) {
        this._swap(child1Pos, currPos)
        currPos = child1Pos
      } else {
        this._swap(child2Pos, currPos)
        currPos = child2Pos
      }
      [child1Pos, child2Pos] = getChildrenPosition(currPos)
      try {
        [child1Priority, child2Priority] = [this._heap[child1Pos][1], this._heap[child2Pos][1]]
      } catch (error) {
        [child1Priority, child2Priority] = [Infinity, Infinity]
      }

      currPriority = this._heap[currPos][1]
    }
    this.keys[this._heap[currPos][0]] = currPos
    if (child1Pos < this._heap.length && child1Priority < currPriority) {
      this._swap(child1Pos, currPos)
      this.keys[this._heap[child1Pos][0]] = child1Pos
    }
  }

  _swap (position1, position2) {
        [this._heap[position1], this._heap[position2]] = [this._heap[position2], this._heap[position1]]
    this.keys[this._heap[position1][0]] = position1
    this.keys[this._heap[position2][0]] = position2
  }
}

class GraphWeightedUndirectedAdjacencyList {
    constructor () {
    this.connections = {}
  }

  addNode (node) {
        this.connections[node] = {}
  }

  addEdge (node1, node2, weight) {
        if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1][node2] = weight
    this.connections[node2][node1] = weight
  }

  PrimMST (start) {
            const distance = {}
    const parent = {}
    const priorityQueue = new PriorityQueue()
        for (const node in this.connections) {
      distance[node] = (node === start.toString() ? 0 : Infinity)
      parent[node] = null
      priorityQueue.push(node, distance[node])
    }
        while (!priorityQueue.isEmpty()) {
      const node = priorityQueue.pop()
      Object.keys(this.connections[node]).forEach(neighbour => {
        if (priorityQueue.contains(neighbour) && distance[node] + this.connections[node][neighbour] < distance[neighbour]) {
          distance[neighbour] = distance[node] + this.connections[node][neighbour]
          parent[neighbour] = node
          priorityQueue.update(neighbour, distance[neighbour])
        }
      })
    }

        const graph = new GraphWeightedUndirectedAdjacencyList()
    Object.keys(parent).forEach(node => {
      if (node && parent[node]) {
        graph.addEdge(node, parent[node], this.connections[node][parent[node]])
      }
    })
    return graph
  }
}

export { GraphWeightedUndirectedAdjacencyList }

import { BellmanFord } from '../BellmanFord.js'

test('Test Case 1', () => {
  const V = 5
  const E = 8
  const destination = 3
  const graph = [[0, 1, -1], [0, 2, 4],
    [1, 2, 3], [1, 3, 2],
    [1, 4, 2], [3, 2, 5],
    [3, 1, 1], [4, 3, -3]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(-2)
})
test('Test Case 2', () => {
  const V = 6
  const E = 9
  const destination = 4
  const graph = [[0, 1, 3], [0, 3, 6],
    [0, 5, -1], [1, 2, -3],
    [1, 4, -2], [5, 2, 5],
    [2, 3, 1], [4, 3, 5], [5, 4, 2]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(1)
})
test('Test Case 3', () => {
  const V = 4
  const E = 5
  const destination = 1
  const graph = [[0, 3, -1], [0, 2, 4],
    [3, 2, 2], [3, 1, 5],
    [2, 1, -1]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(0)
})
import { breadthFirstSearch } from '../BreadthFirstSearch'

describe('BreadthFirstSearch', () => {
  const graph = {
    A: ['B', 'D'],
    B: ['E'],
    C: ['D'],
    D: ['A'],
    E: ['D'],
    F: ['G'],
    G: []
  }
  /

  it('should return the visited nodes', () => {
    expect(Array.from(breadthFirstSearch(graph, 'C'))).toEqual(['C', 'D', 'A', 'B', 'E'])
    expect(Array.from(breadthFirstSearch(graph, 'A'))).toEqual(['A', 'B', 'D', 'E'])
    expect(Array.from(breadthFirstSearch(graph, 'F'))).toEqual(['F', 'G'])
  })
})
import { breadthFirstShortestPath } from '../BreadthFirstShortestPath'

describe('BreadthFirstShortestPath', () => {
  const graph = {
    A: ['B', 'D'],
    B: ['E'],
    C: ['D'],
    D: ['A'],
    E: ['D'],
    F: ['G'],
    G: []
  }
  /

  it('should return the visited nodes', () => {
    expect(breadthFirstShortestPath(graph, 'C', 'E')).toEqual(['C', 'D', 'A', 'B', 'E'])
    expect(breadthFirstShortestPath(graph, 'E', 'B')).toEqual(['E', 'D', 'A', 'B'])
    expect(breadthFirstShortestPath(graph, 'F', 'G')).toEqual(['F', 'G'])
    expect(breadthFirstShortestPath(graph, 'A', 'G')).toEqual([])
  })
})

export function breadthFirstShortestPath (graph, startNode, targetNode) {
    if (startNode === targetNode) {
    return [startNode]
  }

    const visited = new Set()

    const initialPath = [startNode]
  const queue = [initialPath]

  while (queue.length > 0) {
        const path = queue.shift()
    const node = path[path.length - 1]

        if (!visited.has(node)) {
            visited.add(node)

      const neighbors = graph[node]

            for (let i = 0; i < neighbors.length; i++) {
        const newPath = path.concat([neighbors[i]])

                if (neighbors[i] === targetNode) {
          return newPath
        }

                queue.push(newPath)
      }
    }
  }

    return []
}


function createGraph (V, E) {
      const adjList = []   for (let i = 0; i < V; i++) {
    adjList.push([])
  }
  for (let i = 0; i < E.length; i++) {
    adjList[E[i][0]].push([E[i][1], E[i][2]])
    adjList[E[i][1]].push([E[i][0], E[i][2]])
  }
  return adjList
}

function djikstra (graph, V, src) {
  const vis = Array(V).fill(0)
  const dist = []
  for (let i = 0; i < V; i++) dist.push([10000, -1])
  dist[src][0] = 0

  for (let i = 0; i < V - 1; i++) {
    let mn = -1
    for (let j = 0; j < V; j++) {
      if (vis[j] === 0) {
        if (mn === -1 || dist[j][0] < dist[mn][0]) mn = j
      }
    }

    vis[mn] = 1
    for (let j = 0; j < graph[mn].length; j++) {
      const edge = graph[mn][j]
      if (vis[edge[0]] === 0 && dist[edge[0]][0] > dist[mn][0] + edge[1]) {
        dist[edge[0]][0] = dist[mn][0] + edge[1]
        dist[edge[0]][1] = mn
      }
    }
  }

  return dist
}

export { createGraph, djikstra }




class GraphUnweightedUndirected {
    constructor () {
    this.connections = {}
  }

  addNode (node) {
        this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
        if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSIterative (node, value) {
        const stack = [node]
    const visited = new Set()
    while (stack.length > 0) {
      const currNode = stack.pop()
            if (currNode === value) { return true }
            visited.add(currNode)
            for (const neighbour of this.connections[currNode]) {
        if (!visited.has(neighbour)) {
          stack.push(neighbour)
        }
      }
    }
    return false
  }
}

export { GraphUnweightedUndirected }


/


function BellmanFord (graph, V, E, src, dest) {
    const dis = Array(V).fill(Infinity)
    dis[src] = 0

        for (let i = 0; i < V - 1; i++) {
    for (let j = 0; j < E; j++) {
      if ((dis[graph[j][0]] + graph[j][2]) < dis[graph[j][1]]) { dis[graph[j][1]] = dis[graph[j][0]] + graph[j][2] }
    }
  }
    for (let i = 0; i < E; i++) {
    const x = graph[i][0]
    const y = graph[i][1]
    const weight = graph[i][2]
    if ((dis[x] !== Infinity) && (dis[x] + weight < dis[y])) {
      return null
    }
  }
  for (let i = 0; i < V; i++) {
    if (i === dest) return dis[i]
  }
}

export { BellmanFord }

export function breadthFirstSearch (graph, startingNode) {
    const visited = new Set()

    const queue = [startingNode]

  while (queue.length > 0) {
        const node = queue.shift()

    if (!visited.has(node)) {
            visited.add(node)
      const neighbors = graph[node]

            for (let i = 0; i < neighbors.length; i++) {
        queue.push(neighbors[i])
      }
    }
  }

  return visited
}
/

const FloydWarshall = (dist) => {
      const n = dist.length
  for (let k = 0; k < n; k++) {
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j]
        }
      }
    }
  }
  return dist
}

export { FloydWarshall }


/

const islands = (matrixGrid) => {
  const matrix = matrixGrid
  let counter = 0

  const flood = (row, col) => {
    if (row < 0 || col < 0) return     if (row >= matrix.length || col >= matrix[row].length) return 
    const tile = matrix[row][col]
    if (tile !== '1') return

    matrix[row][col] = '0'

    flood(row + 1, col)     flood(row - 1, col)     flood(row, col + 1)     flood(row, col - 1)   }

  for (let row = 0; row < matrix.length; row += 1) {
    for (let col = 0; col < matrix[row].length; col += 1) {
      const current = matrix[row][col]
      if (current === '1') {
        flood(row, col)
        counter += 1
      }
    }
  }
  return counter
}

export { islands }

class DisjointSetTreeNode {
    constructor (key) {
    this.key = key
    this.parent = this
    this.rank = 0
  }
}

class DisjointSetTree {
    constructor () {
        this.map = {}
  }

  makeSet (x) {
        this.map[x] = new DisjointSetTreeNode(x)
  }

  findSet (x) {
        if (this.map[x] !== this.map[x].parent) {
      this.map[x].parent = this.findSet(this.map[x].parent.key)
    }
    return this.map[x].parent
  }

  union (x, y) {
        this.link(this.findSet(x), this.findSet(y))
  }

  link (x, y) {
        if (x.rank > y.rank) {
      y.parent = x
    } else {
      x.parent = y
      if (x.rank === y.rank) {
        y.rank += 1
      }
    }
  }
}

class GraphWeightedUndirectedAdjacencyList {
    constructor () {
    this.connections = {}
    this.nodes = 0
  }

  addNode (node) {
        this.connections[node] = {}
    this.nodes += 1
  }

  addEdge (node1, node2, weight) {
        if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1][node2] = weight
    this.connections[node2][node1] = weight
  }

  KruskalMST () {
                const edges = []
    const seen = new Set()
    for (const start of Object.keys(this.connections)) {
      for (const end of Object.keys(this.connections[start])) {
        if (!seen.has(`${start} ${end}`)) {
          seen.add(`${end} ${start}`)
          edges.push([start, end, this.connections[start][end]])
        }
      }
    }
    edges.sort((a, b) => a[2] - b[2])
        const disjointSet = new DisjointSetTree()
    Object.keys(this.connections).forEach(node => disjointSet.makeSet(node))
        const graph = new GraphWeightedUndirectedAdjacencyList()
    let numEdges = 0
    let index = 0
    while (numEdges < this.nodes - 1) {
      const [u, v, w] = edges[index]
      index += 1
      if (disjointSet.findSet(u) !== disjointSet.findSet(v)) {
        numEdges += 1
        graph.addEdge(u, v, w)
        disjointSet.union(u, v)
      }
    }
    return graph
  }
}

export { GraphWeightedUndirectedAdjacencyList }


class Graph {
    constructor () {
    this.edges = []
  }

  addEdge (node1, node2) {
        this.edges.push({
      node1,
      node2
    })
  }

  nodeNeighbors (node) {
        const neighbors = new Set()
    for (const edge of this.edges) {
                  if (edge.node1 === node && !(neighbors.has(edge.node2))) {
        neighbors.add(edge.node2)
      } else if (edge.node2 === node && !(neighbors.has(edge.node1))) {
        neighbors.add(edge.node1)
      }
    }
    return neighbors
  }
}

export { Graph }

class GraphUnweightedUndirected {
    constructor () {
    this.connections = {}
  }

  addNode (node) {
        this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
        if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSRecursive (node, value, visited = new Set()) {
            if (node === value) { return true }
        visited.add(node)
        for (const neighbour of this.connections[node]) {
      if (!visited.has(neighbour)) {
        if (this.DFSRecursive(neighbour, value, visited)) { return true }
      }
    }
    return false
  }
}

export { GraphUnweightedUndirected }

/
function density (numberOfNodes, numberOfEdges, isDirected = false) {
  const multi = isDirected ? 1 : 2
  return (multi * numberOfEdges) / (numberOfNodes * (numberOfNodes - 1))
}

export { density }
class GraphUnweightedUndirectedAdjacencyList {
    constructor () {
    this.connections = {}
  }

  addNode (node) {
        this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
        if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSComponent (components, node, visited) {
    
        components.push(node)
    const stack = [node]
        while (stack.length > 0) {
      const curr = stack.pop()
      visited.add(curr.toString())
      for (const neighbour of this.connections[curr].keys()) {
        if (!visited.has(neighbour.toString())) { stack.push(neighbour) }
      }
    }
  }

  connectedComponents () {
            const visited = new Set()
    const components = []
    for (const node of Object.keys(this.connections)) {
      if (!visited.has(node.toString())) { this.DFSComponent(components, node, visited) }
    }
    return components
  }
}

export { GraphUnweightedUndirectedAdjacencyList }


function solve (graph, s) {
  const solutions = {}
  solutions[s] = []
  solutions[s].dist = 0

  while (true) {
    let p = null
    let neighbor = null
    let dist = Infinity

    for (const n in solutions) {
      if (!solutions[n]) { continue }
      const ndist = solutions[n].dist
      const adj = graph[n]

      for (const a in adj) {
        if (solutions[a]) { continue }

        const d = adj[a] + ndist
        if (d < dist) {
          p = solutions[n]
          neighbor = a
          dist = d
        }
      }
    }

        if (dist === Infinity) {
      break
    }

        solutions[neighbor] = p.concat(neighbor)
        solutions[neighbor].dist = dist
  }

  return solutions
}

export { solve }







import { convexHull } from '../ConvexHullGraham'

test('The ConvexHull of the following points is [{x: 0, y: 3}, {x: 4, y: 4}, {x: 3, y: 1}, {x: 0, y: 0}]', () => {
  const points = [
    { x: 0, y: 3 },
    { x: 1, y: 1 },
    { x: 2, y: 2 },
    { x: 4, y: 4 },
    { x: 0, y: 0 },
    { x: 1, y: 2 },
    { x: 3, y: 1 },
    { x: 3, y: 3 }]
  const res = convexHull(points)
  expect(res).toEqual([{ x: 0, y: 3 }, { x: 4, y: 4 }, { x: 3, y: 1 }, { x: 0, y: 0 }])
})

test('The ConvexHull of the following points is [{x: 1, y: 4}, {x: 9, y: 6}, {x: 7, y: 0}, {x: 0, y: 0}]', () => {
  const points = [
    { x: 4, y: 3 },
    { x: 1, y: 4 },
    { x: 2, y: 4 },
    { x: 0, y: 0 },
    { x: 9, y: 6 },
    { x: 1, y: 3 },
    { x: 4, y: 1 },
    { x: 7, y: 0 }]
  const res = convexHull(points)
  expect(res).toEqual([{ x: 1, y: 4 }, { x: 9, y: 6 }, { x: 7, y: 0 }, { x: 0, y: 0 }])
})


function compare (a, b) {
    if (a.x < b.x) return -1
  if (a.x === b.x && a.y < b.y) return -1
  return 1
}
function orientation (a, b, c) {
    const alpha = (b.y - a.y) / (b.x - a.x)
  const beta = (c.y - b.y) / (c.x - b.x)

    if (alpha > beta) return 1
    else if (beta > alpha) return -1
    return 0
}

function convexHull (points) {
  const pointsLen = points.length
  if (pointsLen <= 2) {
    throw new Error('Minimum of 3 points is required to form closed polygon!')
  }

  points.sort(compare)
  const p1 = points[0]; const p2 = points[pointsLen - 1]

    const upperPoints = []; const lowerPoints = []

  upperPoints.push(p1)
  lowerPoints.push(p1)

  for (let i = 1; i < pointsLen; i++) {
    if (i === pointsLen - 1 || orientation(p1, points[i], p2) !== -1) {
      let upLen = upperPoints.length

      while (upLen >= 2 && orientation(upperPoints[upLen - 2], upperPoints[upLen - 1], points[i]) === -1) {
        upperPoints.pop()
        upLen = upperPoints.length
      }
      upperPoints.push(points[i])
    }
    if (i === pointsLen - 1 || orientation(p1, points[i], p2) !== 1) {
      let lowLen = lowerPoints.length
      while (lowLen >= 2 && orientation(lowerPoints[lowLen - 2], lowerPoints[lowLen - 1], points[i]) === 1) {
        lowerPoints.pop()
        lowLen = lowerPoints.length
      }
      lowerPoints.push(points[i])
    }
  }
  const hull = []
  for (let i = 1; i < upperPoints.length - 1; i++) {
    hull.push(upperPoints[i])
  }
  for (let i = lowerPoints.length - 1; i >= 0; i--) {
    hull.push(lowerPoints[i])
  }

  return hull
}

export { convexHull }



import { setBit } from '../SetBit'

test('Set bit number 0 in 1:', () => {
  const setBitPos = setBit(1, 0)
  expect(setBitPos).toBe(1)
})

test('Set bit number 0 in 2:', () => {
  const setBitPos = setBit(2, 0)
  expect(setBitPos).toBe(3)
})

test('Set bit number 1 in 10:', () => {
  const setBitPos = setBit(10, 1)
  expect(setBitPos).toBe(10)
})

test('Set bit number 2 in 10:', () => {
  const setBitPos = setBit(10, 2)
  expect(setBitPos).toBe(14)
})
import { nextPowerOfTwo } from '../NextPowerOfTwo'

describe('NextPowerOfTwo', () => {
  it.each`
    input    | result
    ${0}     | ${1}
    ${1}     | ${1}
    ${2}     | ${2}
    ${3}     | ${4}
    ${5}     | ${8}
    ${125}   | ${128}
    ${1024}  | ${1024}
    ${10000} | ${16384}
  `('returns $result when is given $input', ({ input, result }) => {
    const res = nextPowerOfTwo(input)
    expect(res).toBe(result)
  })
})
import { IsPowerOfTwo } from '../IsPowerOfTwo'

test('Check if 0 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(0)
  expect(res).toBe(false)
})

test('Check if 1 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1)
  expect(res).toBe(true)
})

test('Check if 4 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(4)
  expect(res).toBe(true)
})

test('Check if 1024 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1024)
  expect(res).toBe(true)
})

test('Check if 1025 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1025)
  expect(res).toBe(false)
})
import { BinaryCountSetBits } from '../BinaryCountSetBits'

test('check BinaryCountSetBits of 25 is 3', () => {
  const res = BinaryCountSetBits(25)
  expect(res).toBe(3)
})
test('check BinaryCountSetBits of 36 is 2', () => {
  const res = BinaryCountSetBits(36)
  expect(res).toBe(2)
})
test('check BinaryCountSetBits of 16 is 1', () => {
  const res = BinaryCountSetBits(16)
  expect(res).toBe(1)
})
test('check BinaryCountSetBits of 58 is 4', () => {
  const res = BinaryCountSetBits(58)
  expect(res).toBe(4)
})
test('check BinaryCountSetBits of 4294967295 is 32', () => {
  const res = BinaryCountSetBits(4294967295)
  expect(res).toBe(32)
})
test('check BinaryCountSetBits of 0 is 0', () => {
  const res = BinaryCountSetBits(0)
  expect(res).toBe(0)
})
/

export const IsPowerOfTwo = (n) => {
  if (n > 0 && (n & (n - 1)) === 0) {
    return true
  }
  return false
}
/



export const setBit = (number, bitPosition) => {
  return number | (1 << bitPosition)
}


export const nextPowerOfTwo = (n) => {
  if (n > 0 && (n & (n - 1)) === 0) return n
  let result = 1
  while (n > 0) {
    result = result << 1
    n = n >> 1
  }
  return result
}
/

function BinaryCountSetBits (a) {
  'use strict'
    return a.toString(2).split('1').length - 1
}

export { BinaryCountSetBits }

function quickSort (items) {
  const length = items.length

  if (length <= 1) {
    return items
  }
  const PIVOT = items[0]
  const GREATER = []
  const LESSER = []

  for (let i = 1; i < length; i++) {
    if (items[i] > PIVOT) {
      GREATER.push(items[i])
    } else {
      LESSER.push(items[i])
    }
  }

  const sorted = [...quickSort(LESSER), PIVOT, ...quickSort(GREATER)]
  return sorted
}

export { quickSort }
/
export function gnomeSort (items) {
  if (items.length <= 1) {
    return
  }

  let i = 1

  while (i < items.length) {
    if (items[i - 1] <= items[i]) {
      i++
    } else {
      [items[i], items[i - 1]] = [items[i - 1], items[i]]

      i = Math.max(1, i - 1)
    }
  }
  return items
}




export function flashSort (arr) {
  let max = 0; let min = arr[0]
  const n = arr.length
  const m = ~~(0.45 * n)
  const l = new Array(m)

  for (let i = 1; i < n; ++i) {
    if (arr[i] < min) {
      min = arr[i]
    }
    if (arr[i] > arr[max]) {
      max = i
    }
  }

  if (min === arr[max]) {
    return arr
  }

  const c1 = (m - 1) / (arr[max] - min)

  for (let k = 0; k < m; k++) {
    l[k] = 0
  }

  for (let j = 0; j < n; ++j) {
    const k = ~~(c1 * (arr[j] - min))
    ++l[k]
  }

  for (let p = 1; p < m; ++p) {
    l[p] = l[p] + l[p - 1]
  }

  let hold = arr[max]
  arr[max] = arr[0]
  arr[0] = hold

    let move = 0; let t; let flash
  let j = 0
  let k = m - 1

  while (move < (n - 1)) {
    while (j > (l[k] - 1)) {
      ++j
      k = ~~(c1 * (arr[j] - min))
    }
    if (k < 0) break
    flash = arr[j]
    while (j !== l[k]) {
      k = ~~(c1 * (flash - min))
      hold = arr[t = --l[k]]
      arr[t] = flash
      flash = hold
      ++move
    }
  }

    for (j = 1; j < n; j++) {
    hold = arr[j]
    let i = j - 1
    while (i >= 0 && arr[i] > hold) {
      arr[i + 1] = arr[i--]
    }
    arr[i + 1] = hold
  }
  return arr
}



function introsort (array, compare) {
  /
  const defaultComparator = function (x, y) {
    if (x === undefined && y === undefined) return 0
    if (x === undefined) return 1
    if (y === undefined) return -1
    const xString = toString(x)
    const yString = toString(y)
    if (xString < yString) return -1
    if (xString > yString) return 1
    return 0
  }
  /
  const toString = function (obj) {
    if (obj === null) return 'null'
    if (typeof obj === 'boolean' || typeof obj === 'number') {
      return obj.toString()
    }
    if (typeof obj === 'string') return obj
    if (typeof obj === 'symbol') throw new TypeError()
    return obj.toString()
  }
  /
  if (Array.isArray(array) === false) {
    return
  }
  /
  if (typeof compare !== 'function') {
    compare = defaultComparator   }
  /
  return (function (array, comparator) {
    const swap = function (index1, index2) {
      const temp = array[index1]
      array[index1] = array[index2]
      array[index2] = temp
    }
    /
    const THRESHOLD = 16
    /
    const TUNEMAXDEPTH = 1
    const len = array.length
    /
    if (len === 1) {
      return
    }
    /
    const maxDepth = Math.floor(Math.log2(len)) * TUNEMAXDEPTH
    /
    quickSort(0, len, maxDepth)
    /
    insertionSort(0, len)
    /
    /
    function quickSort (start, last, depth) {
      if (last - start <= THRESHOLD) {
        insertionSort(start, last)
        return
      } else if (depth <= 0) {
        heapSort(start, last)
        return
      }
      let pivot = (last + start) >> 1
      pivot = partition(start, last, pivot)
      quickSort(start, pivot, depth - 1)
      quickSort(pivot + 1, last, depth - 1)
    }
    /
    function partition (start, last, pivot) {
      swap(start, pivot)
      pivot = start
      let lo = start
      let hi = last
      while (true) {
        lo++
        while (comparator(array[lo], array[pivot]) <= 0 && lo !== last) {
          lo++
        }
        hi--
        while (comparator(array[hi], array[pivot]) > 0 && hi !== start) {
          hi--
        }
        if (lo >= hi) {
          break
        }
        swap(lo, hi)
      }
      swap(start, hi)
      return hi
    }
    /
    function insertionSort (start, last) {
      let i, j
      for (i = start + 1; i < last; i++) {
        j = i - 1
        while (j >= 0 && comparator(array[j], array[j + 1]) > 0) {
          swap(j, j + 1)
          j--
        }
      }
    }
    /
    function heapSort (start, last) {
      let x = (last + start) >> 1
      while (x - start >= 0) {
        heapify(x, start, last)
        x--
      }
      x = last - 1
      while (x - start > 0) {
        swap(start, x)
        heapify(start, start, x)
        x--
      }
    }
    /
    function heapify (cur, start, last) {
      const size = last - start
      let max, lt, rt
      cur = cur - start
      while (true) {
        max = cur
        lt = 2 * max + 1
        rt = 2 * max + 2
        if (
          lt < size &&
          comparator(array[start + max], array[start + lt]) < 0
        ) {
          max = lt
        }
        if (
          rt < size &&
          comparator(array[start + max], array[start + rt]) < 0
        ) {
          max = rt
        }
        if (max !== cur) {
          swap(start + cur, start + max)
          cur = max
        } else {
          break
        }
      }
    }
  })(array, compare)
}


function demo1 () {
  const data = []
  const size = 1000000
  let i = 0
  let temp
  const c = function (a, b) {
    return a - b
  }
  for (i = 0; i < size; i++) {
    temp = Math.random() * Number.MAX_SAFE_INTEGER
    data.push(temp)
  }
  introsort(data, c)
  let faulty = false
  for (i = 1; i < size; i++) {
    if (data[i] < data[i - 1]) {
      faulty = true
      break
    }
  }
  if (faulty) {
    return 'WRONG!!'
  } else {
    return 'RIGHT:)'
  }
}


function demo2 () {
  const data = []
  const data2 = []
  const size = 1000000
  let i = 0
  let temp
  for (i = 0; i < size; i++) {
    temp = Math.random() * Number.MAX_SAFE_INTEGER
    data.push(temp)
    data2.push(temp)
  }
  introsort(data)
  data2.sort()
  let faulty = false
  for (i = 1; i < size; i++) {
    if (data[i] !== data2[i]) {
      faulty = true
      break
    }
  }
  if (faulty) {
    return 'WRONG Implemented Comparator!!'
  } else {
    return 'Comparator Works Fine:)'
  }
}

export { introsort, demo1, demo2 }
import { radixSort } from '../RadixSort'

test('The RadixSort of the array [4, 3, 2, 1] is [1, 2, 3, 4]', () => {
  const arr = [4, 3, 2, 1]
  const res = radixSort(arr, 10)
  expect(res).toEqual([1, 2, 3, 4])
})

test('The RadixSort of the array [] is []', () => {
  const arr = []
  const res = radixSort(arr, 10)
  expect(res).toEqual([])
})

test('The RadixSort of the array [14, 16, 10, 12] is [10, 12, 14, 16]', () => {
  const arr = [14, 16, 10, 12]
  const res = radixSort(arr, 10)
  expect(res).toEqual([10, 12, 14, 16])
})
import { oddEvenSort } from '../OddEvenSort'

test('The OddEvenSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = oddEvenSort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The OddEvenSort of the array [] is []', () => {
  const arr = []
  const res = oddEvenSort(arr)
  expect(res).toEqual([])
})

test('The OddEvenSort of the array [10, 14, 12, 20] is [10, 12, 14, 20]', () => {
  const arr = [10, 14, 12, 20]
  const res = oddEvenSort(arr)
  expect(res).toEqual([10, 12, 14, 20])
})

test('The OddEvenSort of the array [166, 169, 144] is [144, 166, 169]', () => {
  const arr = [166, 169, 144]
  const res = oddEvenSort(arr)
  expect(res).toEqual([144, 166, 169])
})
import { beadSort } from '../BeadSort'

describe('BeadSort', () => {
  it('should sort arrays correctly', () => {
    expect(beadSort([5, 4, 3, 2, 1])).toEqual([1, 2, 3, 4, 5])
    expect(beadSort([7, 9, 4, 3, 5])).toEqual([3, 4, 5, 7, 9])
  })

  it('should throw a RangeError when the array contains negative integers', () => {
    expect(() => beadSort([-1, 5, 8, 4, 3, 19])).toThrow(RangeError)
  })
})
import { cycleSort } from '../CycleSort'

describe('cycleSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(cycleSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(cycleSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(cycleSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(cycleSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(cycleSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(cycleSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(cycleSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(cycleSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(cycleSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(cycleSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(cycleSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(cycleSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(cycleSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(cycleSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(cycleSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})
import { insertionSortAlternativeImplementation } from '../InsertionSort'

describe('insertionSortAlternativeImplementation', () => {
  it('expects to work with empty array', () => {
    expect(insertionSortAlternativeImplementation([])).toEqual([])
  })

  it('expects to return input array when array.length is less than 2', () => {
    const input = [3]
    expect(insertionSortAlternativeImplementation(input)).toEqual(input)
  })

  it('expects to return array sorted in ascending order', () => {
    expect(insertionSortAlternativeImplementation([14, 11])).toEqual([11, 14])
    expect(insertionSortAlternativeImplementation([21, 22, 23])).toEqual([21, 22, 23])
    expect(insertionSortAlternativeImplementation([1, 3, 2, 3, 7, 2])).toEqual([1, 2, 2, 3, 3, 7])
    expect(insertionSortAlternativeImplementation([1, 6, 4, 5, 9, 2])).toEqual([1, 2, 4, 5, 6, 9])
  })
})
import { flipArray, findMax, pancakeSort } from '../PancakeSort'

describe('flipArray', () => {
  it('should flip any subarray of any array', () => {
    expect(flipArray([1, 2, 3, 4], 0, 3)).toEqual([4, 3, 2, 1])
    expect(flipArray([1, 2, 3, 4, 5], 2, 4)).toEqual([1, 2, 5, 4, 3])
    expect(flipArray([], 0, 0)).toEqual([])
  })
})

describe('findMax', () => {
  it('should find the index of the maximum value in any subarray of any array', () => {
    expect(findMax([1, 3, 2, 5], 0, 3)).toEqual(3)
    expect(findMax([1, 3, 2, 5], 0, 2)).toEqual(1)
  })
})

describe('pancakeSort', () => {
  it('should sort any array', () => {
    expect(pancakeSort([4, 3, 2, 1])).toEqual([1, 2, 3, 4])
    expect(pancakeSort([3, 1, 4, 2])).toEqual([1, 2, 3, 4])
    expect(pancakeSort([100, 1000, 10, 1])).toEqual([1, 10, 100, 1000])
  })
})
import { combSort } from '../CombSort'

describe('combSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(combSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(combSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(combSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(combSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(combSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(combSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(combSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(combSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(combSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(combSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(combSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(combSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(combSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(combSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(combSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})
import { flashSort } from '../FlashSort'

test('The flash sort of the array [3, 0, 2, 5, -1, 4, 1, -2] is [-2, -1, 0, 1, 2, 3, 4, 5]', () => {
  const array = [3, 0, 2, 5, -1, 4, 1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-2, -1, 0, 1, 2, 3, 4, 5])
})

test('The flash sort of the array [-3, 0, 2, -5, -1, 4, 1, -2] is [-5, -3, -2, -1, 0, 1, 2, 4]', () => {
  const array = [-3, 0, 2, -5, -1, 4, 1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-5, -3, -2, -1, 0, 1, 2, 4])
})

test('The flash sort of the array [13, 0, 12, 5, -1, 14, 1, -2] is [-2, -1, 0, 1, 5, 12, 13, 14]', () => {
  const array = [13, 0, 12, 5, -1, 14, 1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-2, -1, 0, 1, 5, 12, 13, 14])
})

test('The flash sort of the array [-3, 0, -2, -5, -1, -4, -1, -2] is [-5, -4, -3, -2, -2, -1, -1, 0]', () => {
  const array = [-3, 0, -2, -5, -1, -4, -1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-5, -4, -3, -2, -2, -1, -1, 0])
})
import { quickSort } from '../QuickSort'

describe('QuickSort', () => {
  it('should work for empty arrays', () => {
    expect(quickSort([])).toEqual([])
  })

  it('should sort arrays correctly', () => {
    expect(quickSort([5, 4, 3, 10, 2, 1])).toEqual([1, 2, 3, 4, 5, 10])
    expect(quickSort([5, 4])).toEqual([4, 5])
    expect(quickSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(quickSort([0, 5, 3, 2, 2])).toEqual([0, 2, 2, 3, 5])
  })
})
import { alphaNumericalSort } from '../AlphaNumericalSort'

describe('alphaNumericalComparer', () => {
  test('given array of eng symbols return correct sorted array', () => {
    const src = ['b', 'a', 'c']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['a', 'b', 'c'])
  })

  test('given array of numbers return correct sorted array', () => {
    const src = ['15', '0', '5']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['0', '5', '15'])
  })

  test('correct sort with numbers and strings', () => {
    const src = ['3', 'a1b15c', 'z', 'a1b14c']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['3', 'a1b14c', 'a1b15c', 'z'])
  })

  test('correct sort with long numbers', () => {
    const src = ['abc999999999999999999999999999999999cba', 'abc999999999999999999999999999999990cba', 'ab']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['ab', 'abc999999999999999999999999999999990cba', 'abc999999999999999999999999999999999cba'])
  })

  test('correct sort with z prefix', () => {
    const src = ['z', 'abc003def', 'abc1def', 'a']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['a', 'abc1def', 'abc003def', 'z'])
  })

  test('correct sort with other language', () => {
    const src = ['а10б', 'а2б', 'в10г', 'в05г']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['а2б', 'а10б', 'в05г', 'в10г'])
  })
})
import { pigeonHoleSort } from '../PigeonHoleSort'

test('The pigeonHoleSort of the array [1, 4, 3, 2] is [1, 2, 3, 4]', () => {
  const arr = [1, 4, 3, 2]
  const res = pigeonHoleSort(arr)
  expect(res).toEqual([1, 2, 3, 4])
})

test('The pigeonHoleSort of the array [5, 4, 1, 2] is [1, 2, 4, 5]', () => {
  const arr = [5, 4, 1, 2]
  const res = pigeonHoleSort(arr)
  expect(res).toEqual([1, 2, 4, 5])
})

test('The pigeonHoleSort of the array [18, 31, 29, 35, 11] is [11, 18, 29, 31, 35]', () => {
  const arr = [18, 31, 29, 35, 11]
  const res = pigeonHoleSort(arr)
  expect(res).toEqual([11, 18, 29, 31, 35])
})
import { gnomeSort } from '../GnomeSort'

test('The gnomeSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = gnomeSort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The gnomeSort of the array [-5, 4, -3, 2, -1] is [-5, -3, -1, 2, 4]', () => {
  const arr = [-5, 4, -3, 2, -1]
  const res = gnomeSort(arr)
  expect(res).toEqual([-5, -3, -1, 2, 4])
})

test('The gnomeSort of the array [15, 4, -13, 2, -11] is [-13, -11, 2, 4, 15]', () => {
  const arr = [15, 4, -13, 2, -11]
  const res = gnomeSort(arr)
  expect(res).toEqual([-13, -11, 2, 4, 15])
})
import { shellSort } from '../ShellSort'

test('The ShellSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = shellSort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The ShellSort of the array [] is []', () => {
  const arr = []
  const res = shellSort(arr)
  expect(res).toEqual([])
})

test('The ShellSort of the array [15, 24, 31, 42, 11] is [11, 15, 24, 31, 42]', () => {
  const arr = [15, 24, 31, 42, 11]
  const res = shellSort(arr)
  expect(res).toEqual([11, 15, 24, 31, 42])
})

test('The ShellSort of the array [121, 190, 169] is [121, 169, 190]', () => {
  const arr = [121, 190, 169]
  const res = shellSort(arr)
  expect(res).toEqual([121, 169, 190])
})
import { secondLargestElement } from '../FindSecondLargestElement'

test('The second largest element of the array [1, 2, 3, 4, 5] is 4', () => {
  const array = [1, 2, 3, 4, 5]
  const res = secondLargestElement(array)
  expect(res).toEqual(4)
})

test('The second largest element of the array [-1, -2, -3, -4, -5] is -2', () => {
  const array = [-1, -2, -3, -4, -5]
  const res = secondLargestElement(array)
  expect(res).toEqual(-2)
})
import { stoogeSort } from '../StoogeSort'

test('The StoogeSort of the array [1, 6, 4, 7, 2] is [1, 2, 4, 6, 7]', () => {
  const arr = [1, 6, 4, 7, 2]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([1, 2, 4, 6, 7])
})

test('The StoogeSort of the array [] is []', () => {
  const arr = []
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([])
})

test('The StoogeSort of the array [46, 15, 49, 65, 23] is [15, 23, 46, 49, 65]', () => {
  const arr = [46, 15, 49, 65, 23]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([15, 23, 46, 49, 65])
})

test('The StoogeSort of the array [136, 459, 132, 566, 465] is [132, 136, 459, 465, 566]', () => {
  const arr = [136, 459, 132, 566, 465]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([132, 136, 459, 465, 566])
})

test('The StoogeSort of the array [45, 3, 156, 1, 56] is [1, 3, 45, 56, 156]', () => {
  const arr = [45, 3, 156, 1, 56]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([1, 3, 45, 56, 156])
})
import { countingSort } from '../CountingSort'

test('The countingSort of the array [3, 0, 2, 5, 4, 1] is [0, 1, 2, 3, 4, 5]', () => {
  const array = [3, 0, 2, 5, 4, 1]
  const res = countingSort(array, 0, 5)
  expect(res).toEqual([0, 1, 2, 3, 4, 5])
})

test('The countingSort of the array [6, 4, 2, 1, 3, 5] is [1, 2, 3, 4, 5, 6]', () => {
  const array = [6, 4, 2, 1, 3, 5]
  const res = countingSort(array, 1, 6)
  expect(res).toEqual([1, 2, 3, 4, 5, 6])
})

test('The countingSort of the array [11, 14, 12, 15, 16, 13] is [11, 12, 13, 14, 15, 16]', () => {
  const array = [11, 14, 12, 15, 16, 13]
  const res = countingSort(array, 11, 16)
  expect(res).toEqual([11, 12, 13, 14, 15, 16])
})

test('The countingSort of the array [13, 18, 2, 15, 43, 11] is [2, 11, 13, 15, 18, 43]', () => {
  const array = [13, 18, 2, 15, 43, 11]
  const res = countingSort(array, 2, 43)
  expect(res).toEqual([2, 11, 13, 15, 18, 43])
})
import { bogoSort, isSorted } from '../BogoSort'

describe('isSorted', () => {
  it('should return true for empty arrays', () => {
    expect(isSorted([])).toBe(true)
  })

  it('should return true for single-element arrays', () => {
    expect(isSorted([1])).toBe(true)
  })

  it('should return true for arrays that are properly sorted', () => {
    expect(isSorted([1, 2, 3])).toBe(true)
  })

  it('should return false for arrays that are not properly sorted', () => {
    expect(isSorted([3, 2, 1])).toBe(false)
  })
})

describe('bogoSort', () => {
  it('should (eventually) sort the array', () => {
    expect(bogoSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })
})
import { Timsort } from '../TimSort'

test('The Timsort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = Timsort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The Timsort of the array [] is []', () => {
  const arr = []
  const res = Timsort(arr)
  expect(res).toEqual([])
})

test('The Timsort of the array [-5, -4, -3, -2, -1] is [-5, -4, -3, -2, -1]', () => {
  const arr = [-5, -4, -3, -2, -1]
  const res = Timsort(arr)
  expect(res).toEqual([-5, -4, -3, -2, -1])
})

test('The Timsort of the array [9, 0, -5, -11, 3] is [-11, -5, 0, 3, 9]', () => {
  const arr = [9, 0, -5, -11, 3]
  const res = Timsort(arr)
  expect(res).toEqual([-11, -5, 0, 3, 9])
})
import { quickSort } from '../QuickSortRecursive'

describe('QuickSortRecursive | Partition In Place Method', () => {
  it('Expectedly, throw some error if we pass a non-array input', () => {
    expect(() => quickSort('xyz', 0, 2)).toThrow('Please input a valid list or array.')
    expect(() => quickSort(null, 0, 4)).toThrow('Please input a valid list or array.')
    expect(() => quickSort(55, 0, 2)).toThrow('Please input a valid list or array.')
  })

  it('Expectedly, the quickSort method will sort the unsorted list in ascending order', () => {
    const unSortArray = [5, 9, 3, 4, 6, 2, 0, 1, 7, 8]
    const sortedExpectedArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    expect(quickSort(unSortArray, 0, unSortArray.length - 1)).toEqual(sortedExpectedArray)
  })

  it('Expectedly, the quickSort method will arrange the list of character values in dictionary order.', () => {
    const unSortList = ['d', 'e', 'c', 'a', 'f', 'b']
    const sortedExpectedList = ['a', 'b', 'c', 'd', 'e', 'f']
    expect(quickSort(unSortList, 0, unSortList.length - 1)).toEqual(sortedExpectedList)
  })
})
import { heapSort } from '../HeapSortV2'

test('The heapSort of the array [4, 3, 2, 1] is [1, 2, 3, 4]', () => {
  const arr = [4, 3, 2, 1]
  const res = heapSort(arr)
  expect(res).toEqual([1, 2, 3, 4])
})

test('The heapSort of the array [] is []', () => {
  const arr = []
  const res = heapSort(arr)
  expect(res).toEqual([])
})

test('The heapSort of the array [41, 31, 32, 31] is [31, 31, 32, 41]', () => {
  const arr = [41, 31, 32, 31]
  const res = heapSort(arr)
  expect(res).toEqual([31, 31, 32, 41])
})
import { selectionSort } from '../SelectionSort'

describe('selectionSort', () => {
  it('expects to return the array sorted in ascending order', () => {
    const toSort = [5, 6, 7, 8, 1, 2, 12, 14]
    const expected = [1, 2, 5, 6, 7, 8, 12, 14]

    expect(selectionSort(toSort)).toEqual(expected)
  })

  it('expects to throw if it is not a valid array', () => {
    expect(() => selectionSort('abc')).toThrow('Given input is not an array')
    expect(() => selectionSort(123)).toThrow('Given input is not an array')
    expect(() => selectionSort({})).toThrow('Given input is not an array')
    expect(() => selectionSort(null)).toThrow('Given input is not an array')
    expect(() => selectionSort()).toThrow('Given input is not an array')
  })

  it('expects to throw if one of the elements in the array is not a number', () => {
    expect(() => selectionSort([1, 'x', 2])).toThrow('One of the items in your array is not a number')
  })
})
import { shuffle } from '../FisherYatesShuffle'

describe('shuffle', () => {
  it('expects to have a new array with same size', () => {
    const fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    const mixedArray = shuffle(fibonacci)

    expect(mixedArray).toHaveLength(fibonacci.length)
  })

  it('expects to have a new array with same values', () => {
    const fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    const mixedArray = shuffle(fibonacci)

    expect(mixedArray).toContain(0)
    expect(mixedArray).toContain(1)
    expect(mixedArray).toContain(2)
    expect(mixedArray).toContain(3)
    expect(mixedArray).toContain(5)
    expect(mixedArray).toContain(8)
    expect(mixedArray).toContain(13)
    expect(mixedArray).toContain(21)
    expect(mixedArray).toContain(34)
    expect(mixedArray).toContain(55)
    expect(mixedArray).toContain(89)
  })
})
import { heapSort } from '../HeapSort'

test('The HeapSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const array = [5, 4, 3, 2, 1]
  const res = heapSort(array)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The HeapSort of the array [-5, -4, -3, -2, -1] is [-5, -4, -3, -2, -1]', () => {
  const array = [-5, -4, -3, -2, -1]
  const res = heapSort(array)
  expect(res).toEqual([-5, -4, -3, -2, -1])
})

test('The HeapSort of the array [50, 43, 31, 52, 91] is [31, 43, 50, 52, 91]', () => {
  const array = [50, 43, 31, 52, 91]
  const res = heapSort(array)
  expect(res).toEqual([31, 43, 50, 52, 91])
})

test('The HeapSort of the array [] is []', () => {
  const array = []
  const res = heapSort(array)
  expect(res).toEqual([])
})
import { secondLargestElement } from '../FindSecondLargestElement'

test('The second largest element of the array [100, 200, 300, 400] is 300', () => {
  const array = [100, 200, 300, 400]
  const res = secondLargestElement(array)
  expect(res).toBe(300)
})

test('The second largest element of the array [1100, 2400, 1300, 4002] is 2400', () => {
  const array = [1100, 2400, 1300, 4002]
  const res = secondLargestElement(array)
  expect(res).toBe(2400)
})

test('The second largest element of the array [10, 20, 39, 34] is 34', () => {
  const array = [10, 20, 39, 34]
  const res = secondLargestElement(array)
  expect(res).toBe(34)
})

test('The second largest element of the array [1, 20, 3, 40] is 20', () => {
  const array = [1, 20, 3, 40]
  const res = secondLargestElement(array)
  expect(res).toBe(20)
})
import { cocktailShakerSort } from '../CocktailShakerSort'

describe('CocktailShakerSort', () => {
  it('should sort arrays correctly', () => {
    expect(cocktailShakerSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(cocktailShakerSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(cocktailShakerSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })

  it('should work for empty arrays, too', () => {
    expect(cocktailShakerSort([])).toEqual([])
  })
})
import { bucketSort } from '../BucketSort'

describe('Tests for bucketSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(bucketSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(bucketSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(bucketSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(bucketSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(bucketSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(bucketSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(bucketSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(bucketSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(bucketSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(bucketSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(bucketSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(bucketSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(bucketSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(bucketSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(bucketSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})
import { merge, mergeSort } from '../MergeSort'

describe('merge', () => {
  it('should merge arrays correctly', () => {
    expect(merge([5, 4], [1, 2, 3])).toEqual([1, 2, 3, 5, 4])
    expect(merge([], [1, 2])).toEqual([1, 2])
    expect(merge([1, 2, 3], [1])).toEqual([1, 1, 2, 3])
    expect(merge([], [])).toEqual([])
  })
})

describe('MergeSort', () => {
  it('should work for empty arrays', () => {
    expect(mergeSort([])).toEqual([])
  })

  it('should sort arrays correctly', () => {
    expect(mergeSort([5, 4])).toEqual([4, 5])
    expect(mergeSort([8, 4, 10, 15, 9])).toEqual([4, 8, 9, 10, 15])
    expect(mergeSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(mergeSort([10, 5, 3, 8, 2, 6, 4, 7, 9, 1])).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
  })
})
import { simplifiedWiggleSort } from '../SimplifiedWiggleSort.js'

describe('simplified wiggle sort', () => {
  test('simplified wiggle sort for chars', () => {
    const src = ['a', 'b', 'c']
    expect(simplifiedWiggleSort(src)).toEqual(['a', 'c', 'b'])
  })

  test('wiggle sort with duplicates, even array', () => {
    const src = [2, 2, 1, 3]
    expect(simplifiedWiggleSort(src)).toEqual([1, 3, 2, 2])
  })

  test('wiggle sort with duplicates, odd array', () => {
    const src = [1, 1, 1, 2, 4]
    expect(simplifiedWiggleSort(src)).toEqual([1, 4, 1, 2, 1])
  })

  test('simplified wiggle sort which leads to equal values next to ' +
    'each other', () => {
    const src = [3, 3, 5, 1]
    expect(simplifiedWiggleSort(src)).toEqual([1, 5, 3, 3])
  })
})
import { alternativeBubbleSort, bubbleSort } from '../BubbleSort'

describe('bubbleSort', () => {
  it('should sort arrays correctly', () => {
    expect(bubbleSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(bubbleSort([])).toEqual([])
    expect(bubbleSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(bubbleSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
    expect(bubbleSort([5, 6, 7, 8, 9, 4])).toEqual([4, 5, 6, 7, 8, 9])
    expect(bubbleSort([20, 30, 40])).toEqual([20, 30, 40])
    expect(bubbleSort([2, 1, 3])).toEqual([1, 2, 3])
    expect(bubbleSort([10, 15, 16, 100])).toEqual([10, 15, 16, 100])
    expect(bubbleSort([10, 9, 11])).toEqual([9, 10, 11])
    expect(bubbleSort([10, 9, 12])).toEqual([9, 10, 12])
    expect(bubbleSort([3, 2, 1])).toEqual([1, 2, 3])
    expect(bubbleSort([10, 9, 8])).toEqual([8, 9, 10])
  })
})

describe('alternativeBubbleSort', () => {
  it('should sort arrays correctly', () => {
    expect(alternativeBubbleSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(alternativeBubbleSort([])).toEqual([])
    expect(alternativeBubbleSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(alternativeBubbleSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })
})



function combSort (list) {
  if (list.length === 0) {
    return list
  }
  const shrink = 1.3
  let gap = list.length
  let isSwapped = true
  let i = 0

  while (gap > 1 || isSwapped) {
        gap = parseInt(parseFloat(gap) / shrink, 10)

    isSwapped = false
    i = 0

    while (gap + i < list.length) {
      if (list[i] > list[i + gap]) {
        [list[i], list[i + gap]] = [list[i + gap], list[i]]
        isSwapped = true
      }
      i += 1
    }
  }
  return list
}

export { combSort }
/

const secondLargestElement = (array) => {
  const largestElement = Math.max(...array)
  let element = -Number.MAX_VALUE

  for (let i = 0; i < array.length; i++) {
    if (element < array[i] && array[i] !== largestElement) {
      element = array[i]
    }
  }

  return element
}

export { secondLargestElement }


export const countingSort = (arr, min, max) => {
    const res = []
    const count = new Array(max - min + 1).fill(0)
    for (let i = 0; i < arr.length; i++) {
    count[arr[i] - min]++
  }
    count[0] -= 1
  for (let i = 1; i < count.length; i++) {
    count[i] += count[i - 1]
  }
    for (let i = arr.length - 1; i >= 0; i--) {
    res[count[arr[i] - min]] = arr[i]
    count[arr[i] - min]--
  }
  return res
}


/
export function radixSort (items, RADIX) {
    if (RADIX === undefined || RADIX < 1) {
    RADIX = 10
  }

  let maxLength = false
  let placement = 1

  while (!maxLength) {
    maxLength = true
    const buckets = []

    for (let i = 0; i < RADIX; i++) {
      buckets.push([])
    }

    for (let j = 0; j < items.length; j++) {
      const tmp = items[j] / placement
      buckets[Math.floor(tmp % RADIX)].push(items[j])
      if (maxLength && tmp > 0) {
        maxLength = false
      }
    }

    let a = 0
    for (let b = 0; b < RADIX; b++) {
      const buck = buckets[b]
      for (let k = 0; k < buck.length; k++) {
        items[a] = buck[k]
        a++
      }
    }
    placement *= RADIX
  }
  return items
}
/


const quickSort = (inputList, low, high) => {
  if (!Array.isArray(inputList)) {
    throw new TypeError('Please input a valid list or array.')
  }
  if (low < high) {
        const pIndex = partition(inputList, low, high)
        quickSort(inputList, low, pIndex - 1)
    quickSort(inputList, pIndex + 1, high)
  }
  return inputList
}


const partition = (partitionList, low, high) => {
  const pivot = partitionList[high]
  let pIndex = low
  for (let index = low; index <= high - 1; index++) {
    if (partitionList[index] < pivot) {
            [partitionList[index], partitionList[pIndex]] = [partitionList[pIndex], partitionList[index]]
      pIndex += 1
    }
  }
  [partitionList[pIndex], partitionList[high]] = [partitionList[high], partitionList[pIndex]]
  return pIndex
}

export { quickSort }
/
export function pigeonHoleSort (arr) {
  let min = arr[0]
  let max = arr[0]

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > max) { max = arr[i] }
    if (arr[i] < min) { min = arr[i] }
  }

  const range = max - min + 1
  const pigeonhole = Array(range).fill(0)

  for (let i = 0; i < arr.length; i++) {
    pigeonhole[arr[i] - min]++
  }

  let index = 0

  for (let j = 0; j < range; j++) {
    while (pigeonhole[j]-- > 0) {
      arr[index++] = j + min
    }
  }
  return arr
}
/

function swap (arr, i, j) {
  const tmp = arr[i]
  arr[i] = arr[j]
  arr[j] = tmp
}

export function oddEvenSort (arr) {
  let sorted = false
  while (!sorted) {
    sorted = true
    for (let i = 1; i < arr.length - 1; i += 2) {
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1)
        sorted = false
      }
    }
    for (let i = 0; i < arr.length - 1; i += 2) {
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1)
        sorted = false
      }
    }
  }
  return arr
}

export function TopologicalSorter () {
  const graph = {}
  let isVisitedNode
  let finishTimeCount
  let finishingTimeList
  let nextNode

  this.addOrder = function (nodeA, nodeB) {
    nodeA = String(nodeA)
    nodeB = String(nodeB)
    graph[nodeA] = graph[nodeA] || []
    graph[nodeA].push(nodeB)
  }

  this.sortAndGetOrderedItems = function () {
    isVisitedNode = Object.create(null)
    finishTimeCount = 0
    finishingTimeList = []

    for (const node in graph) {
      if (Object.prototype.hasOwnProperty.call(graph, node) && !isVisitedNode[node]) {
        dfsTraverse(node)
      }
    }

    finishingTimeList.sort(function (item1, item2) {
      return item1.finishTime > item2.finishTime ? -1 : 1
    })

    return finishingTimeList.map(function (value) { return value.node })
  }

  function dfsTraverse (node) {
    isVisitedNode[node] = true
    if (graph[node]) {
      for (let i = 0; i < graph[node].length; i++) {
        nextNode = graph[node][i]
        if (isVisitedNode[nextNode]) continue
        dfsTraverse(nextNode)
      }
    }

    finishingTimeList.push({
      node,
      finishTime: ++finishTimeCount
    })
  }
}

/



function cycleSort (list) {
  for (let cycleStart = 0; cycleStart < list.length; cycleStart++) {
    let value = list[cycleStart]
    let position = cycleStart

        for (let i = cycleStart + 1; i < list.length; i++) {
      if (list[i] < value) {
        position++
      }
    }
        if (position === cycleStart) {
      continue
    }
    while (value === list[position]) {
      position++
    }

    const oldValue = list[position]
    list[position] = value
    value = oldValue

        while (position !== cycleStart) {
      position = cycleStart
      for (let i = cycleStart + 1; i < list.length; i++) {
        if (list[i] < value) {
          position++
        }
      }
      while (value === list[position]) {
        position++
      }
      const oldValueCycle = list[position]
      list[position] = value
      value = oldValueCycle
    }
  }
  return list
}

export { cycleSort }
/

export function insertionSort (unsortedList) {
  const len = unsortedList.length
  for (let i = 1; i < len; i++) {
    let j
    const tmp = unsortedList[i]     /
    for (j = i - 1; j >= 0 && (unsortedList[j] > tmp); j--) {
            unsortedList[j + 1] = unsortedList[j]
    }
            unsortedList[j + 1] = tmp
  }
}



/

export function insertionSortAlternativeImplementation (array) {
  const length = array.length
  if (length < 2) return array

  for (let i = 1; i < length; i++) {
        const currentItem = array[i]
        let j = i - 1

        while (j >= 0 && array[j] > currentItem) {
            array[j + 1] = array[j]
      j--
    }
        array[j + 1] = currentItem
  }
    return array
}
/

export const selectionSort = (list) => {
  if (!Array.isArray(list)) {
    throw new TypeError('Given input is not an array')
  }
  const items = [...list]   const length = items.length
  for (let i = 0; i < length - 1; i++) {
    if (typeof items[i] !== 'number') {
      throw new TypeError('One of the items in your array is not a number')
    }
        let min = i     for (let j = i + 1; j < length; j++) {       if (items[j] < items[min]) {         min = j       }
    }
    if (min !== i) {
                  [items[i], items[min]] = [items[min], items[i]]
    }
  }
  return items
}
export const shuffle = (array) => {
  let maxLength = array.length
  let temp
  let idx

    while (maxLength) {
        idx = Math.floor(Math.random() * maxLength--)

        temp = array[maxLength]
    array[maxLength] = array[idx]
    array[idx] = temp
  }

  return array
}
/
import { quickSelectSearch } from '../Search/QuickSelectSearch.js'

export const simplifiedWiggleSort = function (arr) {
    let median = quickSelectSearch(arr, Math.floor(arr.length / 2.0))
  median = median[Math.floor(arr.length / 2.0)]

  const sorted = new Array(arr.length)

  let smallerThanMedianIndx = 0
  let greaterThanMedianIndx = arr.length - 1 - (arr.length % 2)

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > median) {
      sorted[greaterThanMedianIndx] = arr[i]
      greaterThanMedianIndx -= 2
    } else {
      if (smallerThanMedianIndx < arr.length) {
        sorted[smallerThanMedianIndx] = arr[i]
        smallerThanMedianIndx += 2
      } else {
        sorted[greaterThanMedianIndx] = arr[i]
        greaterThanMedianIndx -= 2
      }
    }
  }

  return sorted
}

export function beadSort (sequence) {
  /
  if (sequence.some((integer) => integer < 0)) {
    throw RangeError('Sequence must be a list of Positive integers Only!')
  }

  const sequenceLength = sequence.length
  const max = Math.max(...sequence)

    const grid = sequence.map(number => {
    const maxArr = new Array(max)

    for (let i = 0; i < number; i++) {
      maxArr[i] = '*'
    }

    return maxArr
  })

    for (let col = 0; col < max; col++) {
    let beadsCount = 0

    for (let row = 0; row < sequenceLength; row++) {
      if (grid[row][col] === '*') {
        beadsCount++
      }
    }

    for (let row = sequenceLength - 1; row > -1; row--) {
      if (beadsCount) {
        grid[row][col] = '*'
        beadsCount--
      } else {
        grid[row][col] = undefined
      }
    }
  }

  /
  return grid.map((beadArray) => {
    const beadsArray = beadArray.filter(bead => bead === '*')
    return beadsArray.length
  })
}
let arrayLength = 0

/

function heapRoot (input, i) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let max = i

  if (left < arrayLength && input[left] > input[max]) {
    max = left
  }

  if (right < arrayLength && input[right] > input[max]) {
    max = right
  }

  if (max !== i) {
    swap(input, i, max)
    heapRoot(input, max)
  }
}

function swap (input, indexA, indexB) {
  [input[indexA], input[indexB]] = [input[indexB], input[indexA]]
}

export function heapSort (input) {
  arrayLength = input.length

  for (let i = Math.floor(arrayLength / 2); i >= 0; i -= 1) {
    heapRoot(input, i)
  }

  for (let i = input.length - 1; i > 0; i--) {
    swap(input, 0, i)
    arrayLength--

    heapRoot(input, 0)
  }
  return input
}

export function cocktailShakerSort (items) {
  for (let i = items.length - 1; i > 0; i--) {
    let j

        for (j = items.length - 1; j > i; j--) {
      if (items[j] < items[j - 1]) {
        [items[j], items[j - 1]] = [items[j - 1], items[j]]
      }
    }

        for (j = 0; j < i; j++) {
      if (items[j] > items[j + 1]) {
        [items[j], items[j + 1]] = [items[j + 1], items[j]]
      }
    }
  }

  return items
}
/


export function bubbleSort (items) {
  const length = items.length
  let noSwaps

  for (let i = length; i > 0; i--) {
        noSwaps = true
        for (let j = 0; j < (i - 1); j++) {
            if (items[j] > items[j + 1]) {
                [items[j], items[j + 1]] = [items[j + 1], items[j]]
        noSwaps = false
      }
    }
    if (noSwaps) {
      break
    }
  }

  return items
}


export function alternativeBubbleSort (arr) {
  let swapped = true

  while (swapped) {
    swapped = false
    for (let i = 0; i < arr.length - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]
        swapped = true
      }
    }
  }

  return arr
}
/


export function merge (list1, list2) {
  const results = []
  let i = 0
  let j = 0

  while (i < list1.length && j < list2.length) {
    if (list1[i] < list2[j]) {
      results.push(list1[i++])
    } else {
      results.push(list2[j++])
    }
  }

  return results.concat(list1.slice(i), list2.slice(j))
}


export function mergeSort (list) {
  if (list.length < 2) return list

  const listHalf = Math.floor(list.length / 2)
  const subList1 = list.slice(0, listHalf)
  const subList2 = list.slice(listHalf, list.length)

  return merge(mergeSort(subList1), mergeSort(subList2))
}

export function bucketSort (list, size) {
  if (undefined === size) {
    size = 5
  }
  if (list.length === 0) {
    return list
  }
  let min = list[0]
  let max = list[0]
    for (let iList = 0; iList < list.length; iList++) {
    if (list[iList] < min) {
      min = list[iList]
    } else if (list[iList] > max) {
      max = list[iList]
    }
  }
    const count = Math.floor((max - min) / size) + 1

    const buckets = []
  for (let iCount = 0; iCount < count; iCount++) {
    buckets.push([])
  }

    for (let iBucket = 0; iBucket < list.length; iBucket++) {
    const key = Math.floor((list[iBucket] - min) / size)
    buckets[key].push(list[iBucket])
  }
  const sorted = []
    for (let iBucket = 0; iBucket < buckets.length; iBucket++) {
    const arr = buckets[iBucket].sort((a, b) => a - b)
    for (let iSorted = 0; iSorted < arr.length; iSorted++) {
      sorted.push(arr[iSorted])
    }
  }
  return sorted
}
/
export function shellSort (items) {
  let interval = 1

  while (interval < items.length / 3) {
    interval = interval * 3 + 1
  }

  while (interval > 0) {
    for (let outer = interval; outer < items.length; outer++) {
      const value = items[outer]
      let inner = outer

      while (inner > interval - 1 && items[inner - interval] >= value) {
        items[inner] = items[inner - interval]
        inner = inner - interval
      }
      items[inner] = value
    }
    interval = (interval - 1) / 3
  }
  return items
}
/

const alphaNumericalSort = (a, b) => {
  /
  return a.localeCompare(b, undefined, { numeric: true })
}

export { alphaNumericalSort }


const Timsort = (array) => {
    const RUN = 32
  const n = array.length
    for (let i = 0; i < n; i += RUN) {
    InsertionSort(array, i, Math.min(i + RUN - 1, n - 1))
  }
  for (let size = RUN; size < n; size *= 2) {
    for (let left = 0; left < n; left += 2 * size) {
      const mid = left + size - 1
      const right = Math.min(left + 2 * size - 1, n - 1)
      Merge(array, left, mid, right)
    }
  }
  return array
}



const InsertionSort = (array, left, right) => {
  for (let i = left + 1; i <= right; i++) {
    const key = array[i]
    let j = i - 1
    while (j >= left && array[j] > key) {
      array[j + 1] = array[j]
      j--
    }
    array[j + 1] = key
  }
}



const Merge = (array, left, mid, right) => {
  if (mid >= right) return
  const len1 = mid - left + 1
  const len2 = right - mid
  const larr = Array(len1)
  const rarr = Array(len2)
  for (let i = 0; i < len1; i++) {
    larr[i] = array[left + i]
  }
  for (let i = 0; i < len2; i++) {
    rarr[i] = array[mid + 1 + i]
  }
  let i = 0; let j = 0; let k = left
  while (i < larr.length && j < rarr.length) {
    if (larr[i] < rarr[j]) {
      array[k++] = larr[i++]
    } else {
      array[k++] = rarr[j++]
    }
  }
  while (i < larr.length) {
    array[k++] = larr[i++]
  }
  while (j < rarr.length) {
    array[k++] = rarr[j++]
  }
}


const demo = () => {
  const size = 1000000
  const data = Array(size)
  for (let i = 0; i < size; i++) {
    data[i] = Math.random() * Number.MAX_SAFE_INTEGER
  }
  const isSorted = function (array) {
    const n = array.length
    for (let i = 0; i < n - 1; i++) {
      if (array[i] > array[i + 1]) return false
    }
    return true
  }
  Timsort(data)
  if (isSorted(data)) {
    return 'RIGHT'
  } else {
    return 'FAULTY'
  }
}

export { Timsort, demo }
/


export function flipArray (array, startIndex, endIndex) {
  while (startIndex < endIndex) {
        const temp = array[startIndex]
    array[startIndex] = array[endIndex]
    array[endIndex] = temp

        startIndex++
    endIndex--
  }

  return array
}


export function findMax (array, startIndex, endIndex) {
  let maxIndex = 0
  for (let i = startIndex; i <= endIndex; i++) {
    if (array[i] > array[maxIndex]) maxIndex = i
  }

  return maxIndex
}


export function pancakeSort (array) {
  for (let subarraySize = array.length; subarraySize > 1; subarraySize--) {
    const maximumIndex = findMax(array, 0, subarraySize - 1)

    if (maximumIndex !== subarraySize - 1) {
      flipArray(array, 0, maximumIndex)
      flipArray(array, 0, subarraySize - 1)
    }
  }

  return array
}
/
/
Array.prototype.heapify = function (index, heapSize) {
  let largest = index
  const leftIndex = 2 * index + 1
  const rightIndex = 2 * index + 2

  if (leftIndex < heapSize && this[leftIndex] > this[largest]) {
    largest = leftIndex
  }

  if (rightIndex < heapSize && this[rightIndex] > this[largest]) {
    largest = rightIndex
  }

  if (largest !== index) {
    const temp = this[largest]
    this[largest] = this[index]
    this[index] = temp

    this.heapify(largest, heapSize)
  }
}

/
export function heapSort (items) {
  const length = items.length

  for (let i = Math.floor(length / 2) - 1; i > -1; i--) {
    items.heapify(i, length)
  }
  for (let j = length - 1; j > 0; j--) {
    const tmp = items[0]
    items[0] = items[j]
    items[j] = tmp
    items.heapify(0, j)
  }
  return items
}



export function isSorted (array) {
  const length = array.length
  for (let i = 0; i < length - 1; i++) {
    if (array[i] > array[i + 1]) {
      return false
    }
  }
  return true
}


function shuffle (array) {
  for (let i = array.length - 1; i; i--) {
    const m = Math.floor(Math.random() * i)
    const n = array[i - 1]
    array[i - 1] = array[m]
    array[m] = n
  }
}


export function bogoSort (items) {
  while (!isSorted(items)) {
    shuffle(items)
  }
  return items
}
/
export function stoogeSort (items, leftEnd, rightEnd) {
  if (items[rightEnd - 1] < items[leftEnd]) {
    const temp = items[leftEnd]
    items[leftEnd] = items[rightEnd - 1]
    items[rightEnd - 1] = temp
  }
  const length = rightEnd - leftEnd
  if (length > 2) {
    const third = Math.floor(length / 3)
    stoogeSort(items, leftEnd, rightEnd - third)
    stoogeSort(items, leftEnd + third, rightEnd)
    stoogeSort(items, leftEnd, rightEnd - third)
  }
  return items
}
