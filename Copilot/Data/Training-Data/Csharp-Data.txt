namespace DataStructures.SegmentTrees
{
    
    
    
    public class SegmentTreeUpdate : SegmentTree
    {
        
        
        
        
        
        public SegmentTreeUpdate(int[] arr)
            : base(arr)
        {
        }

        
        
        
        
        
        
        
        public void Update(int node, int value)
        {
            Tree[node + Tree.Length / 2] = value;
            Propagate(Parent(node + Tree.Length / 2));
        }

        
        
        
        
        
        private void Propagate(int node)
        {
            if (node == 0)
            {
                
                return;
            }

            Tree[node] = Tree[Left(node)] + Tree[Right(node)];
            Propagate(Parent(node));
        }
    }
}
using System;

namespace DataStructures.SegmentTrees
{
    
    
    
    
    
    
    
    public class SegmentTree
    {
        
        
        
        
        
        public SegmentTree(int[] arr)
        {
            
            var pow = (int)Math.Pow(2, Math.Ceiling(Math.Log(arr.Length, 2)));
            Tree = new int[2 * pow];

            
            Array.Copy(arr, 0, Tree, pow, arr.Length);

            
            for (var i = pow - 1; i > 0; --i)
            {
                Tree[i] = Tree[Left(i)] + Tree[Right(i)];
            }
        }

        
        public int[] Tree { get; }

        
        
        
        
        
        
        
        
        
        public int Query(int l, int r) =>
            Query(++l, ++r, 1, Tree.Length / 2, 1);

        
        
        
        
        
        protected int Right(int node) => 2 * node + 1;

        
        
        
        
        
        protected int Left(int node) => 2 * node;

        
        
        
        
        
        protected int Parent(int node) => node / 2;

        
        
        
        
        
        
        
        
        
        protected virtual int Query(int l, int r, int a, int b, int i)
        {
            
            if (l <= a && b <= r)
            {
                return Tree[i];
            }

            
            if (r < a || b < l)
            {
                
                
                return 0;
            }

            
            var m = (a + b) / 2;

            
            
            return Query(l, r, a, m, Left(i)) + Query(l, r, m + 1, b, Right(i));
        }
    }
}
using System;

namespace DataStructures.SegmentTrees
{
    
    
    
    
    public class SegmentTreeApply : SegmentTree
    {
        
        
        
        
        
        public SegmentTreeApply(int[] arr)
            : base(arr)
        {
            
            Operand = new int[Tree.Length];
            Array.Fill(Operand, 1);
        }

        
        
        
        
        
        public int[] Operand { get; }

        
        
        
        
        
        
        
        
        public void Apply(int l, int r, int value)
        {
            
            
            Apply(++l, ++r, value, 1, Tree.Length / 2, 1);
        }

        
        
        
        
        
        
        
        
        
        protected override int Query(int l, int r, int a, int b, int i)
        {
            if (l <= a && b <= r)
            {
                return Tree[i];
            }

            if (r < a || b < l)
            {
                return 0;
            }

            var m = (a + b) / 2;

            
            return Operand[i] * (Query(l, r, a, m, Left(i)) + Query(l, r, m + 1, b, Right(i)));
        }

        
        
        
        
        
        
        
        
        
        private void Apply(int l, int r, int value, int a, int b, int i)
        {
            
            if (l <= a && b <= r)
            {
                
                Operand[i] = value * Operand[i];
                Tree[i] = value * Tree[i];
                return;
            }

            
            if (r < a || b < l)
            {
                return;
            }

            
            var m = (a + b) / 2;

            
            Apply(l, r, value, a, m, Left(i));
            Apply(l, r, value, m + 1, b, Right(i));

            
            Tree[i] = Operand[i] * (Tree[Left(i)] + Tree[Right(i)]);
        }
    }
}
using System.Collections;
using System.Collections.Generic;

namespace DataStructures
{
    
    
    
    
    public class SortedList<T> : IEnumerable<T>
    {
        private readonly IComparer<T> comparer;
        private readonly List<T> memory;

        
        
        
        public SortedList()
            : this(Comparer<T>.Default)
        {
        }

        
        
        
        public int Count => memory.Count;

        
        
        
        
        public SortedList(IComparer<T> comparer)
        {
            memory = new List<T>();
            this.comparer = comparer;
        }

        
        
        
        
        public void Add(T item)
        {
            var index = IndexFor(item, out _);
            memory.Insert(index, item);
        }

        
        
        
        
        public T this[int i] => memory[i];

        
        
        
        public void Clear()
            => memory.Clear();

        
        
        
        
        
        public bool Contains(T item)
        {
            _ = IndexFor(item, out var found);
            return found;
        }

        
        
        
        
        
        public bool TryRemove(T item)
        {
            var index = IndexFor(item, out var found);

            if (found)
            {
                memory.RemoveAt(index);
            }

            return found;
        }

        
        
        
        
        public IEnumerator<T> GetEnumerator()
            => memory.GetEnumerator();

        
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        
        
        
        
        
        
        private int IndexFor(T item, out bool found)
        {
            var left = 0;
            var right = memory.Count;

            while (right - left > 0)
            {
                var mid = (left + right) / 2;

                switch (comparer.Compare(item, memory[mid]))
                {
                    case > 0:
                        left = mid + 1;
                        break;
                    case < 0:
                        right = mid;
                        break;
                    default:
                        found = true;
                        return mid;
                }
            }

            found = false;
            return left;
        }
    }
}
namespace DataStructures.DisjointSet
{
    
    
    
    
    public class Node<T>
    {
        public int Rank { get; set; }

        public Node<T> Parent { get; set; }

        public T Data { get; set; }

        public Node(T data)
        {
            Data = data;
            Parent = this;
        }
    }
}
using System.Collections;

namespace DataStructures.DisjointSet
{
    
    
    
    
    public class DisjointSet<T>
    {
        
        
        
        
        
        public Node<T> MakeSet(T x) => new(x);

        
        
        
        
        
        public Node<T> FindSet(Node<T> node)
        {
            if (node != node.Parent)
            {
                node.Parent = FindSet(node.Parent);
            }

            return node.Parent;
        }

        
        
        
        
        
        public void UnionSet(Node<T> x, Node<T> y)
        {
            Node<T> nx = FindSet(x);
            Node<T> ny = FindSet(y);
            if (nx == ny)
            {
                return;
            }

            if (nx.Rank > ny.Rank)
            {
                ny.Parent = nx;
            }
            else if (ny.Rank > nx.Rank)
            {
                nx.Parent = ny;
            }
            else
            {
                nx.Parent = ny;
                ny.Rank++;
            }
        }
    }
}
namespace DataStructures.RedBlackTree
{
    
    
    
    public enum NodeColor : byte
    {
        
        
        
        Red,

        
        
        
        Black,
    }

    
    
    
    
    public class RedBlackTreeNode<TKey>
    {
        
        
        
        public TKey Key { get; set; }

        
        
        
        public NodeColor Color { get; set; }

        
        
        
        public RedBlackTreeNode<TKey>? Parent { get; set; }

        
        
        
        public RedBlackTreeNode<TKey>? Left { get; set; }

        
        
        
        public RedBlackTreeNode<TKey>? Right { get; set; }

        
        
        
        
        
        public RedBlackTreeNode(TKey key, RedBlackTreeNode<TKey>? parent)
        {
            Key = key;
            Parent = parent;
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.RedBlackTree
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public class RedBlackTree<TKey>
    {
        
        
        
        public int Count { get; private set; }

        
        
        
        private readonly Comparer<TKey> comparer;

        
        
        
        private RedBlackTreeNode<TKey>? root;

        
        
        
        public RedBlackTree()
        {
            comparer = Comparer<TKey>.Default;
        }

        
        
        
        
        
        public RedBlackTree(Comparer<TKey> customComparer)
        {
            comparer = customComparer;
        }

        
        
        
        
        public void Add(TKey key)
        {
            if (root is null)
            {
                
                
                root = new RedBlackTreeNode<TKey>(key, null)
                {
                    Color = NodeColor.Black,
                };
                Count++;
                return;
            }

            
            var node = Add(root, key);

            
            var childDir = comparer.Compare(node.Key, node.Parent!.Key);

            
            node = node.Parent;

            
            int addCase;
            do
            {
                addCase = GetAddCase(node);

                switch(addCase)
                {
                    case 1:
                        break;
                    case 2:
                        var oldParent = node.Parent;
                        node = AddCase2(node);

                        if (node is not null)
                        {
                            childDir = comparer.Compare(oldParent!.Key, oldParent.Parent!.Key);
                        }

                        break;
                    case 4:
                        node.Color = NodeColor.Black;
                        break;
                    case 56:
                        AddCase56(node, comparer.Compare(node.Key, node.Parent!.Key), childDir);
                        break;
                    default:
                        throw new InvalidOperationException("It should not be possible to get here!");
                }
            }
            while (addCase == 2 && node is not null);

            Count++;
        }

        
        
        
        
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys)
            {
                Add(key);
            }
        }

        
        
        
        
        public void Remove(TKey key)
        {
            
            var node = Remove(root, key);

            
            node = RemoveSimpleCases(node);

            
            if (node is null)
            {
                return;
            }

            
            DeleteLeaf(node.Parent!, comparer.Compare(node.Key, node.Parent!.Key));

            
            do
            {
                node = RemoveRecolor(node);
            }
            while (node is not null && node.Parent is not null);    

            Count--;
        }

        
        
        
        
        
        public bool Contains(TKey key)
        {
            var node = root;
            while (node is not null)
            {
                var compareResult = comparer.Compare(key, node.Key);
                if (compareResult < 0)
                {
                    node = node.Left;
                }
                else if (compareResult > 0)
                {
                    node = node.Right;
                }
                else
                {
                    return true;
                }
            }

            return false;
        }

        
        
        
        
        public TKey GetMin()
        {
            if (root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMin(root).Key;
        }

        
        
        
        
        public TKey GetMax()
        {
            if (root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMax(root).Key;
        }

        
        
        
        
        public IEnumerable<TKey> GetKeysInOrder()
        {
            var result = new List<TKey>();
            InOrderWalk(root);
            return result;

            void InOrderWalk(RedBlackTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                InOrderWalk(node.Left);
                result.Add(node.Key);
                InOrderWalk(node.Right);
            }
        }

        
        
        
        
        public IEnumerable<TKey> GetKeysPreOrder()
        {
            var result = new List<TKey>();
            PreOrderWalk(root);
            return result;

            void PreOrderWalk(RedBlackTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                result.Add(node.Key);
                PreOrderWalk(node.Left);
                PreOrderWalk(node.Right);
            }
        }

        
        
        
        
        public IEnumerable<TKey> GetKeysPostOrder()
        {
            var result = new List<TKey>();
            PostOrderWalk(root);
            return result;

            void PostOrderWalk(RedBlackTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                PostOrderWalk(node.Left);
                PostOrderWalk(node.Right);
                result.Add(node.Key);
            }
        }

        
        
        
        
        
        
        private RedBlackTreeNode<TKey> Add(RedBlackTreeNode<TKey> node, TKey key)
        {
            int compareResult;
            RedBlackTreeNode<TKey> newNode;
            while (true)
            {
                compareResult = comparer.Compare(key, node!.Key);
                if (compareResult < 0)
                {
                    if (node.Left is null)
                    {
                        newNode = new RedBlackTreeNode<TKey>(key, node);
                        node.Left = newNode;
                        break;
                    }
                    else
                    {
                        node = node.Left;
                    }
                }
                else if (compareResult > 0)
                {
                    if (node.Right is null)
                    {
                        newNode = new RedBlackTreeNode<TKey>(key, node);
                        node.Right = newNode;
                        break;
                    }
                    else
                    {
                        node = node.Right;
                    }
                }
                else
                {
                    throw new ArgumentException($"Key \"{key}\" already exists in tree!");
                }
            }

            return newNode;
        }

        
        
        
        
        
        private RedBlackTreeNode<TKey>? AddCase2(RedBlackTreeNode<TKey> node)
        {
            var grandparent = node.Parent;
            var parentDir = comparer.Compare(node.Key, node.Parent!.Key);
            var uncle = parentDir < 0 ? grandparent!.Right : grandparent!.Left;

            node.Color = NodeColor.Black;
            uncle!.Color = NodeColor.Black;
            grandparent.Color = NodeColor.Red;

            
            if (node.Parent.Parent is null)
            {
                node.Parent.Color = NodeColor.Black;
            }

            
            return node.Parent.Parent;
        }

        
        
        
        
        
        
        private void AddCase56(RedBlackTreeNode<TKey> node, int parentDir, int childDir)
        {
            if (parentDir < 0)
            {
                
                if (childDir > 0)
                {
                    node = RotateLeft(node);
                }

                
                node = RotateRight(node.Parent!);
                node.Color = NodeColor.Black;
                node.Right!.Color = NodeColor.Red;
            }
            else
            {
                
                if (childDir < 0)
                {
                    node = RotateRight(node);
                }

                
                node = RotateLeft(node.Parent!);
                node.Color = NodeColor.Black;
                node.Left!.Color = NodeColor.Red;
            }
        }

        
        
        
        
        
        private int GetAddCase(RedBlackTreeNode<TKey> node)
        {
            if (node.Color == NodeColor.Black)
            {
                return 1;
            }
            else if (node.Parent is null)
            {
                return 4;
            }
            else
            {
                
                var grandparent = node.Parent;
                var parentDir = comparer.Compare(node.Key, node.Parent.Key);
                var uncle = parentDir < 0 ? grandparent.Right : grandparent.Left;

                
                if (uncle is null || uncle.Color == NodeColor.Black)
                {
                    return 56;
                }

                return 2;
            }
        }

        
        
        
        
        
        
        private RedBlackTreeNode<TKey> Remove(RedBlackTreeNode<TKey>? node, TKey key)
        {
            if (node is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }
            else if (!Contains(key))
            {
                throw new KeyNotFoundException($"Key {key} is not in the tree!");
            }
            else
            {
                
                int dir;
                while (true)
                {
                    dir = comparer.Compare(key, node!.Key);
                    if (dir < 0)
                    {
                        node = node.Left;
                    }
                    else if (dir > 0)
                    {
                        node = node.Right;
                    }
                    else
                    {
                        break;
                    }
                }

                return node;
            }
        }

        
        
        
        
        private RedBlackTreeNode<TKey>? RemoveRecolor(RedBlackTreeNode<TKey> node)
        {
            var removeCase = GetRemoveCase(node);

            var dir = comparer.Compare(node.Key, node.Parent!.Key);

            
            var sibling = dir < 0 ? node.Parent.Right : node.Parent.Left;
            var closeNewphew = dir < 0 ? sibling!.Left : sibling!.Right;
            var distantNephew = dir < 0 ? sibling!.Right : sibling!.Left;

            switch (removeCase)
            {
                case 1:
                    sibling.Color = NodeColor.Red;
                    return node.Parent;
                case 3:
                    RemoveCase3(node, closeNewphew, dir);
                    break;
                case 4:
                    RemoveCase4(sibling);
                    break;
                case 5:
                    RemoveCase5(node, sibling, dir);
                    break;
                case 6:
                    RemoveCase6(node, distantNephew!, dir);
                    break;
                default:
                    throw new InvalidOperationException("It should not be possible to get here!");
            }

            return null;
        }

        
        
        
        
        
        private RedBlackTreeNode<TKey>? RemoveSimpleCases(RedBlackTreeNode<TKey> node)
        {
            
            if (node.Parent is null && node.Left is null && node.Right is null)
            {
                root = null;
                Count--;
                return null;
            }

            
            if (node.Left is not null && node.Right is not null)
            {
                var successor = GetMin(node.Right);
                node.Key = successor.Key;
                node = successor;
            }

            
            if (node.Color == NodeColor.Red)
            {
                
                DeleteLeaf(node.Parent!, comparer.Compare(node.Key, node.Parent!.Key));

                Count--;
                return null;
            }
            else
            {
                
                return RemoveBlackNode(node);
            }
        }

        
        
        
        
        
        private RedBlackTreeNode<TKey>? RemoveBlackNode(RedBlackTreeNode<TKey> node)
        {
            
            var child = node.Left ?? node.Right;

            
            if (child is null)
            {
                return node;
            }

            
            child.Color = NodeColor.Black;
            child.Parent = node.Parent;

            var childDir = node.Parent is null ? 0 : comparer.Compare(node.Key, node.Parent.Key);

            
            Transplant(node.Parent, child, childDir);

            Count--;
            return null;
        }

        
        
        
        
        
        
        private void RemoveCase3(RedBlackTreeNode<TKey> node, RedBlackTreeNode<TKey>? closeNephew, int childDir)
        {
            
            var sibling = childDir < 0 ? RotateLeft(node.Parent!) : RotateRight(node.Parent!);
            sibling.Color = NodeColor.Black;
            if (childDir < 0)
            {
                sibling.Left!.Color = NodeColor.Red;
            }
            else
            {
                sibling.Right!.Color = NodeColor.Red;
            }

            
            sibling = closeNephew!;
            var distantNephew = childDir < 0 ? sibling.Right : sibling.Left;

            
            if (distantNephew is not null && distantNephew.Color == NodeColor.Red)
            {
                RemoveCase6(node, distantNephew, childDir);
                return;
            }

            
            closeNephew = childDir < 0 ? sibling!.Left : sibling!.Right;

            
            if (closeNephew is not null && closeNephew.Color == NodeColor.Red)
            {
                RemoveCase5(node, sibling!, childDir);
                return;
            }

            
            RemoveCase4(sibling!);
        }

        
        
        
        
        private void RemoveCase4(RedBlackTreeNode<TKey> sibling)
        {
            sibling.Color = NodeColor.Red;
            sibling.Parent!.Color = NodeColor.Black;
        }

        
        
        
        
        
        
        private void RemoveCase5(RedBlackTreeNode<TKey> node, RedBlackTreeNode<TKey> sibling, int childDir)
        {
            sibling = childDir < 0 ? RotateRight(sibling) : RotateLeft(sibling);
            var distantNephew = childDir < 0 ? sibling.Right! : sibling.Left!;

            sibling.Color = NodeColor.Black;
            distantNephew.Color = NodeColor.Red;

            RemoveCase6(node, distantNephew, childDir);
        }

        
        
        
        
        
        
        private void RemoveCase6(RedBlackTreeNode<TKey> node, RedBlackTreeNode<TKey> distantNephew, int childDir)
        {
            var oldParent = node.Parent!;
            node = childDir < 0 ? RotateLeft(oldParent) : RotateRight(oldParent);
            node.Color = oldParent.Color;
            oldParent.Color = NodeColor.Black;
            distantNephew.Color = NodeColor.Black;
        }

        
        
        
        
        
        private int GetRemoveCase(RedBlackTreeNode<TKey> node)
        {
            var dir = comparer.Compare(node.Key, node.Parent!.Key);

            
            var sibling = dir < 0 ? node.Parent.Right : node.Parent.Left;
            var closeNewphew = dir < 0 ? sibling!.Left : sibling!.Right;
            var distantNephew = dir < 0 ? sibling!.Right : sibling!.Left;

            if (sibling.Color == NodeColor.Red)
            {
                return 3;
            }
            else if (distantNephew is not null && distantNephew.Color == NodeColor.Red)
            {
                return 6;
            }
            else if (closeNewphew is not null && closeNewphew.Color == NodeColor.Red)
            {
                return 5;
            }
            else if (node.Parent.Color == NodeColor.Red)
            {
                return 4;
            }
            else
            {
                return 1;
            }
        }

        
        
        
        
        
        
        private void Transplant(RedBlackTreeNode<TKey>? node, RedBlackTreeNode<TKey>? child, int dir)
        {
            if (node is null)
            {
                root = child;
            }
            else if (child is null)
            {
                DeleteLeaf(node, dir);
            }
            else if (dir < 0)
            {
                node.Left = child;
            }
            else
            {
                node.Right = child;
            }
        }

        
        
        
        
        
        private void DeleteLeaf(RedBlackTreeNode<TKey> node, int dir)
        {
            if (dir < 0)
            {
                node.Left = null;
            }
            else
            {
                node.Right = null;
            }
        }

        
        
        
        
        
        private RedBlackTreeNode<TKey> RotateLeft(RedBlackTreeNode<TKey> node)
        {
            var temp1 = node;
            var temp2 = node!.Right!.Left;

            node = node.Right;
            node.Parent = temp1.Parent;
            if (node.Parent is not null)
            {
                var nodeDir = comparer.Compare(node.Key, node.Parent.Key);
                if (nodeDir < 0)
                {
                    node.Parent.Left = node;
                }
                else
                {
                    node.Parent.Right = node;
                }
            }

            node.Left = temp1;
            node.Left.Parent = node;

            node.Left.Right = temp2;
            if (temp2 is not null)
            {
                node.Left.Right!.Parent = temp1;
            }

            if (node.Parent is null)
            {
                root = node;
            }

            return node;
        }

        
        
        
        
        
        private RedBlackTreeNode<TKey> RotateRight(RedBlackTreeNode<TKey> node)
        {
            var temp1 = node;
            var temp2 = node!.Left!.Right;

            node = node.Left;
            node.Parent = temp1.Parent;
            if (node.Parent is not null)
            {
                var nodeDir = comparer.Compare(node.Key, node.Parent.Key);
                if (nodeDir < 0)
                {
                    node.Parent.Left = node;
                }
                else
                {
                    node.Parent.Right = node;
                }
            }

            node.Right = temp1;
            node.Right.Parent = node;

            node.Right.Left = temp2;
            if (temp2 is not null)
            {
                node.Right.Left!.Parent = temp1;
            }

            if (node.Parent is null)
            {
                root = node;
            }

            return node;
        }

        
        
        
        
        
        
        private RedBlackTreeNode<TKey> GetMin(RedBlackTreeNode<TKey> node)
        {
            while (node.Left is not null)
            {
                node = node.Left;
            }

            return node;
        }

        
        
        
        
        
        
        private RedBlackTreeNode<TKey> GetMax(RedBlackTreeNode<TKey> node)
        {
            while (node.Right is not null)
            {
                node = node.Right;
            }

            return node;
        }
    }
}
using System;
using System.Collections.Generic;
using Utilities.Exceptions;

namespace DataStructures.LinkedList.DoublyLinkedList
{
    
    
    
    
    
    
    
    public class DoublyLinkedList<T>
    {
        
        
        
        
        public DoublyLinkedList(T data)
        {
            Head = new DoublyLinkedListNode<T>(data);
            Tail = Head;
            Count = 1;
        }

        
        
        
        
        public DoublyLinkedList(IEnumerable<T> data)
        {
            foreach (var d in data)
            {
                Add(d);
            }
        }

        
        
        
        public int Count { get; private set; }

        
        
        
        private DoublyLinkedListNode<T>? Head { get; set; }

        
        
        
        private DoublyLinkedListNode<T>? Tail { get; set; }

        
        
        
        
        
        public DoublyLinkedListNode<T> AddHead(T data)
        {
            var node = new DoublyLinkedListNode<T>(data);

            if (Head is null)
            {
                Head = node;
                Tail = node;
                Count = 1;
                return node;
            }

            Head.Previous = node;
            node.Next = Head;
            Head = node;
            Count++;
            return node;
        }

        
        
        
        
        
        public DoublyLinkedListNode<T> Add(T data)
        {
            if (Head is null)
            {
                return AddHead(data);
            }

            var node = new DoublyLinkedListNode<T>(data);
            Tail!.Next = node;
            node.Previous = Tail;
            Tail = node;
            Count++;
            return node;
        }

        
        
        
        
        
        
        public DoublyLinkedListNode<T> AddAfter(T data, DoublyLinkedListNode<T> existingNode)
        {
            if (existingNode == Tail)
            {
                return Add(data);
            }

            var node = new DoublyLinkedListNode<T>(data);
            node.Next = existingNode.Next;
            node.Previous = existingNode;
            existingNode.Next = node;

            if (existingNode.Next is not null)
            {
                existingNode.Next.Previous = node;
            }

            Count++;
            return node;
        }

        
        
        
        
        public IEnumerable<T> GetData()
        {
            var current = Head;
            while (current is not null)
            {
                yield return current.Data;
                current = current.Next;
            }
        }

        
        
        
        
        public IEnumerable<T> GetDataReversed()
        {
            var current = Tail;
            while (current is not null)
            {
                yield return current.Data;
                current = current.Previous;
            }
        }

        
        
        
        public void Reverse()
        {
            var current = Head;
            DoublyLinkedListNode<T>? temp = null;

            while (current is not null)
            {
                temp = current.Previous;
                current.Previous = current.Next;
                current.Next = temp;
                current = current.Previous;
            }

            Tail = Head;

            
            if (temp is not null)
            {
                Head = temp.Previous;
            }
        }

        
        
        
        
        
        public DoublyLinkedListNode<T> Find(T data)
        {
            var current = Head;
            while (current is not null)
            {
                if (current.Data is null && data is null || current.Data is not null && current.Data.Equals(data))
                {
                    return current;
                }

                current = current.Next;
            }

            throw new ItemNotFoundException();
        }

        
        
        
        
        
        
        public DoublyLinkedListNode<T> GetAt(int position)
        {
            if (position < 0 || position >= Count)
            {
                throw new ArgumentOutOfRangeException($"Max count is {Count}");
            }

            var current = Head;
            for (var i = 0; i < position; i++)
            {
                current = current!.Next;
            }

            return current ?? throw new ArgumentOutOfRangeException($"{nameof(position)} must be an index in the list");
        }

        
        
        
        public void RemoveHead()
        {
            if (Head is null)
            {
                throw new InvalidOperationException();
            }

            Head = Head.Next;
            if (Head is null)
            {
                Tail = null;
                Count = 0;
                return;
            }

            Head.Previous = null;
            Count--;
        }

        
        
        
        public void Remove()
        {
            if (Tail is null)
            {
                throw new InvalidOperationException("Cannot prune empty list");
            }

            Tail = Tail.Previous;
            if (Tail is null)
            {
                Head = null;
                Count = 0;
                return;
            }

            Tail.Next = null;
            Count--;
        }

        
        
        
        
        public void RemoveNode(DoublyLinkedListNode<T> node)
        {
            if (node == Head)
            {
                RemoveHead();
                return;
            }

            if (node == Tail)
            {
                Remove();
                return;
            }

            if (node.Previous is null || node.Next is null)
            {
                throw new ArgumentException(
                    $"{nameof(node)} cannot have Previous or Next null if it's an internal node");
            }

            node.Previous.Next = node.Next;
            node.Next.Previous = node.Previous;
            Count--;
        }

        
        
        
        
        public void Remove(T data)
        {
            var node = Find(data);
            RemoveNode(node);
        }

        
        
        
        
        
        public int IndexOf(T data)
        {
            var current = Head;
            var index = 0;
            while (current is not null)
            {
                if (current.Data is null && data is null || current.Data is not null && current.Data.Equals(data))
                {
                    return index;
                }

                index++;
                current = current.Next;
            }

            return -1;
        }

        
        
        
        
        
        public bool Contains(T data) => IndexOf(data) != -1;
    }
}
namespace DataStructures.LinkedList.DoublyLinkedList
{
    
    
    
    
    public class DoublyLinkedListNode<T>
    {
        
        
        
        
        public DoublyLinkedListNode(T data) => Data = data;

        
        
        
        public T Data { get; }

        
        
        
        public DoublyLinkedListNode<T>? Next { get; set; }

        
        
        
        public DoublyLinkedListNode<T>? Previous { get; set; }
    }
}
﻿namespace DataStructures.LinkedList.SinglyLinkedList
{
    public class SinglyLinkedListNode<T>
    {
        public SinglyLinkedListNode(T data)
        {
            Data = data;
            Next = null;
        }

        public T Data { get; }

        public SinglyLinkedListNode<T>? Next { get; set; }
    }
}
﻿using System;
using System.Collections.Generic;

namespace DataStructures.LinkedList.SinglyLinkedList
{
    public class SinglyLinkedList<T>
    {
        
        private SinglyLinkedListNode<T>? Head { get; set; }

        
        
        
        
        
        
        
        public SinglyLinkedListNode<T> AddFirst(T data)
        {
            var newListElement = new SinglyLinkedListNode<T>(data)
            {
                Next = Head,
            };

            Head = newListElement;
            return newListElement;
        }

        
        
        
        
        
        
        
        
        public SinglyLinkedListNode<T> AddLast(T data)
        {
            var newListElement = new SinglyLinkedListNode<T>(data);

            
            if (Head is null)
            {
                Head = newListElement;
                return newListElement;
            }

            
            var tempElement = Head;

            
            while (tempElement.Next is not null)
            {
                tempElement = tempElement.Next;
            }

            
            tempElement.Next = newListElement;
            return newListElement;
        }

        
        
        
        
        
        public T GetElementByIndex(int index)
        {
            if (index < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(index));
            }

            var tempElement = Head;

            for (var i = 0; tempElement is not null && i < index; i++)
            {
                tempElement = tempElement.Next;
            }

            if (tempElement is null)
            {
                throw new ArgumentOutOfRangeException(nameof(index));
            }

            return tempElement.Data;
        }

        public int Length()
        {
            
            if (Head is null)
            {
                return 0;
            }

            var tempElement = Head;
            var length = 1;

            while (tempElement.Next is not null)
            {
                tempElement = tempElement.Next;
                length++;
            }

            return length;
        }

        public IEnumerable<T> GetListData()
        {
            
            var tempElement = Head;

            
            while (tempElement is not null)
            {
                yield return tempElement.Data;
                tempElement = tempElement.Next;
            }
        }

        public bool DeleteElement(T element)
        {
            var currentElement = Head;
            SinglyLinkedListNode<T>? previousElement = null;

            
            while (currentElement is not null)
            {
                
                if (currentElement.Data is null && element is null ||
                    currentElement.Data is not null && currentElement.Data.Equals(element))
                {
                    
                    if (currentElement.Equals(Head))
                    {
                        Head = Head.Next;
                        return true;
                    }

                    
                    if (previousElement is not null)
                    {
                        previousElement.Next = currentElement.Next;
                        return true;
                    }
                }

                
                previousElement = currentElement;
                currentElement = currentElement.Next;
            }

            return false;
        }
    }
}
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;

namespace DataStructures.Probabilistic
{
    public class BloomFilter<T> where T : notnull
    {
        private const uint FnvPrime = 16777619;
        private const uint FnvOffsetBasis = 2166136261;
        private readonly byte[] filter;
        private readonly int numHashes;
        private readonly int sizeBits;

        
        
        
        
        
        public BloomFilter(int expectedNumElements)
        {
            numHashes = (int)Math.Ceiling(.693 * 8 * expectedNumElements / expectedNumElements); 
            filter = new byte[expectedNumElements]; 
            sizeBits = expectedNumElements * 8; 
        }

        
        
        
        
        
        
        
        public BloomFilter(int sizeBits, int numHashes)
        {
            filter = new byte[sizeBits / 8 + 1];
            this.numHashes = numHashes;
            this.sizeBits = sizeBits;
        }

        
        
        
        
        public void Insert(T item)
        {
            foreach (var slot in GetSlots(item))
            {
                filter[slot / 8] |= (byte)(1 << (slot % 8)); 
            }
        }

        
        
        
        
        
        public bool Search(T item)
        {
            foreach (var slot in GetSlots(item))
            {
                var @byte = filter[slot / 8]; 
                var mask = 1 << (slot % 8); 
                if ((@byte & mask) != mask)
                {
                    return false;
                }
            }

            return true;
        }

        
        
        
        
        
        private IEnumerable<int> GetSlots(T item)
        {
            var hash = item.GetHashCode();
            for (var i = 0; i < numHashes; i++)
            {
                yield return Math.Abs((i + 1) * hash) % sizeBits;
            }
        }
    }
}
﻿using System;

namespace DataStructures.Probabilistic
{
    public class CountMinSketch<T> where T : notnull
    {
        private readonly int[][] sketch;
        private readonly int numHashes;

        
        
        
        
        
        
        public CountMinSketch(int width, int numHashes)
        {
            sketch = new int[numHashes][];
            for (var i = 0; i < numHashes; i++)
            {
                sketch[i] = new int[width];
            }

            this.numHashes = numHashes;
        }

        
        
        
        
        
        
        public CountMinSketch(double errorRate, double errorProb)
        {
            var width = (int)Math.Ceiling(Math.E / errorRate);
            numHashes = (int)Math.Ceiling(Math.Log(1.0 / errorProb));
            sketch = new int[numHashes][];
            for (var i = 0; i < numHashes; i++)
            {
                sketch[i] = new int[width];
            }
        }

        
        
        
        
        public void Insert(T item)
        {
            var initialHash = item.GetHashCode();
            for (int i = 0; i < numHashes; i++)
            {
                var slot = GetSlot(i, initialHash);
                sketch[i][slot]++;
            }
        }

        
        
        
        
        
        public int Query(T item)
        {
            var initialHash = item.GetHashCode();
            var min = int.MaxValue;
            for (int i = 0; i < numHashes; i++)
            {
                var slot = GetSlot(i, initialHash);
                min = Math.Min(sketch[i][slot], min);
            }

            return min;
        }

        private int GetSlot(int i, int initialHash) => Math.Abs((i + 1) * initialHash) % sketch[0].Length;
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Probabilistic
{
    public class HyperLogLog<T> where T : notnull
    {
        private const int P = 16;
        private const double Alpha = .673;
        private readonly int[] registers;
        private readonly HashSet<int> setRegisters;

        
        
        
        public HyperLogLog()
        {
            var m = 1 << P;
            registers = new int[m];
            setRegisters = new HashSet<int>();
        }

        
        
        
        
        
        
        public static HyperLogLog<T> Merge(HyperLogLog<T> first, HyperLogLog<T> second)
        {
            var output = new HyperLogLog<T>();
            for (var i = 0; i < second.registers.Length; i++)
            {
                output.registers[i] = Math.Max(first.registers[i], second.registers[i]);
            }

            output.setRegisters.UnionWith(first.setRegisters);
            output.setRegisters.UnionWith(second.setRegisters);
            return output;
        }

        
        
        
        
        public void Add(T item)
        {
            var x = item.GetHashCode();
            var binString = Convert.ToString(x, 2); 
            var j = Convert.ToInt32(binString.Substring(0, Math.Min(P, binString.Length)), 2); 
            var w = (int)Math.Log2(x ^ (x & (x - 1))); 
            registers[j] = Math.Max(registers[j], w); 
            setRegisters.Add(j);
        }

        
        
        
        
        public int Cardinality()
        {
            
            double z = setRegisters.Sum(index => Math.Pow(2, -1 * registers[index]));

            
            return (int)Math.Ceiling(Alpha * setRegisters.Count * (setRegisters.Count / z));
        }
    }
}
using System.Collections.Generic;

namespace DataStructures.Graph
{
    public interface IDirectedWeightedGraph<T>
    {
        int Count { get; }

        Vertex<T>?[] Vertices { get; }

        void AddEdge(Vertex<T> startVertex, Vertex<T> endVertex, double weight);

        Vertex<T> AddVertex(T data);

        bool AreAdjacent(Vertex<T> startVertex, Vertex<T> endVertex);

        double AdjacentDistance(Vertex<T> startVertex, Vertex<T> endVertex);

        IEnumerable<Vertex<T>?> GetNeighbors(Vertex<T> vertex);

        void RemoveEdge(Vertex<T> startVertex, Vertex<T> endVertex);

        void RemoveVertex(Vertex<T> vertex);
    }
}
﻿namespace DataStructures.Graph
{
    
    
    
    
    public class Vertex<T>
    {
        
        
        
        public T Data { get; }

        
        
        
        public int Index { get; }

        
        
        
        public DirectedWeightedGraph<T>? Graph { get; private set; }

        
        
        
        
        
        
        public Vertex(T data, int index, DirectedWeightedGraph<T>? graph)
        {
            Data = data;
            Index = index;
            Graph = graph;
        }

        
        
        
        
        
        public Vertex(T data, int index)
        {
            Data = data;
            Index = index;
        }

        
        
        
        public void SetGraphNull() => Graph = null;

        
        
        
        
        public override string ToString() => $"Vertex Data: {Data}, Index: {Index}";
    }
}
﻿using System;
using System.Collections.Generic;

namespace DataStructures.Graph
{
    
    
    
    
    public class DirectedWeightedGraph<T> : IDirectedWeightedGraph<T>
    {
        
        
        
        private readonly int capacity;

        
        
        
        
        private readonly double[,] adjacencyMatrix;

        
        
        
        
        public DirectedWeightedGraph(int capacity)
        {
            ThrowIfNegativeCapacity(capacity);

            this.capacity = capacity;
            Vertices = new Vertex<T>[capacity];
            adjacencyMatrix = new double[capacity, capacity];
            Count = 0;
        }

        
        
        
        public Vertex<T>?[] Vertices { get; private set; }

        
        
        
        public int Count { get; private set; }

        
        
        
        
        
        public Vertex<T> AddVertex(T data)
        {
            ThrowIfOverflow();
            var vertex = new Vertex<T>(data, Count, this);
            Vertices[Count] = vertex;
            Count++;
            return vertex;
        }

        
        
        
        
        
        
        public void AddEdge(Vertex<T> startVertex, Vertex<T> endVertex, double weight)
        {
            ThrowIfVertexNotInGraph(startVertex);
            ThrowIfVertexNotInGraph(endVertex);

            ThrowIfWeightZero(weight);

            var currentEdgeWeight = adjacencyMatrix[startVertex.Index, endVertex.Index];

            ThrowIfEdgeExists(currentEdgeWeight);

            adjacencyMatrix[startVertex.Index, endVertex.Index] = weight;
        }

        
        
        
        
        public void RemoveVertex(Vertex<T> vertex)
        {
            ThrowIfVertexNotInGraph(vertex);

            Vertices[vertex.Index] = null;
            vertex.SetGraphNull();

            for (var i = 0; i < Count; i++)
            {
                adjacencyMatrix[i, vertex.Index] = 0;
                adjacencyMatrix[vertex.Index, i] = 0;
            }

            Count--;
        }

        
        
        
        
        
        public void RemoveEdge(Vertex<T> startVertex, Vertex<T> endVertex)
        {
            ThrowIfVertexNotInGraph(startVertex);
            ThrowIfVertexNotInGraph(endVertex);
            adjacencyMatrix[startVertex.Index, endVertex.Index] = 0;
        }

        
        
        
        
        
        public IEnumerable<Vertex<T>?> GetNeighbors(Vertex<T> vertex)
        {
            ThrowIfVertexNotInGraph(vertex);

            for (var i = 0; i < Count; i++)
            {
                if (adjacencyMatrix[vertex.Index, i] != 0)
                {
                    yield return Vertices[i];
                }
            }
        }

        
        
        
        
        
        
        public bool AreAdjacent(Vertex<T> startVertex, Vertex<T> endVertex)
        {
            ThrowIfVertexNotInGraph(startVertex);
            ThrowIfVertexNotInGraph(endVertex);

            return adjacencyMatrix[startVertex.Index, endVertex.Index] != 0;
        }

        
        
        
        
        
        
        public double AdjacentDistance(Vertex<T> startVertex, Vertex<T> endVertex)
        {
            if (AreAdjacent(startVertex, endVertex))
            {
                return adjacencyMatrix[startVertex.Index, endVertex.Index];
            }

            return 0;
        }

        private static void ThrowIfNegativeCapacity(int capacity)
        {
            if (capacity < 0)
            {
                throw new InvalidOperationException("Graph capacity should always be a non-negative integer.");
            }
        }

        private static void ThrowIfWeightZero(double weight)
        {
            if (weight.Equals(0.0d))
            {
                throw new InvalidOperationException("Edge weight cannot be zero.");
            }
        }

        private static void ThrowIfEdgeExists(double currentEdgeWeight)
        {
            if (!currentEdgeWeight.Equals(0.0d))
            {
                throw new InvalidOperationException($"Vertex already exists: {currentEdgeWeight}");
            }
        }

        private void ThrowIfOverflow()
        {
            if (Count == capacity)
            {
                throw new InvalidOperationException("Graph overflow.");
            }
        }

        private void ThrowIfVertexNotInGraph(Vertex<T> vertex)
        {
            if (vertex.Graph != this)
            {
                throw new InvalidOperationException($"Vertex does not belong to graph: {vertex}.");
            }
        }
    }
}
﻿



















































































































using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DataStructures
{
    
    
    
    
    
    public sealed class BitArray : ICloneable, IEnumerator<bool>, IEnumerable<bool>
    {
        private readonly bool[] field; 
        private int position = -1; 

        
        
        
        
        
        public BitArray(int n)
        {
            if (n < 1)
            {
                field = new bool[0];
            }

            field = new bool[n];
        }

        
        
        
        
        
        
        
        
        public BitArray(string sequence)
        {
            
            if (sequence.Length <= 0)
            {
                throw new ArgumentException("Sequence must been greater than or equal to 1");
            }

            
            ThrowIfSequenceIsInvalid(sequence);

            field = new bool[sequence.Length];
            Compile(sequence);
        }

        
        
        
        
        
        public BitArray(bool[] bits) => field = bits;

        
        
        
        private int Length => field.Length;

        
        
        
        
        
        public bool this[int offset]
        {
            get => field[offset];
            private set => field[offset] = value;
        }

        
        
        
        
        public object Clone()
        {
            var theClone = new BitArray(Length);

            for (var i = 0; i < Length; i++)
            {
                theClone[i] = field[i];
            }

            return theClone;
        }

        
        
        
        
        public IEnumerator<bool> GetEnumerator() => this;

        
        
        
        
        IEnumerator IEnumerable.GetEnumerator() => this;

        
        
        
        public bool Current => field[position];

        
        
        
        object IEnumerator.Current => field[position];

        
        
        
        
        public bool MoveNext()
        {
            if (position + 1 >= field.Length)
            {
                return false;
            }

            position++;
            return true;
        }

        
        
        
        
        public void Reset() => position = -1;

        
        
        
        public void Dispose()
        {
            
        }

        
        
        
        
        
        
        
        public static BitArray operator &(BitArray one, BitArray two)
        {
            var sequence1 = one.ToString();
            var sequence2 = two.ToString();
            var result = new StringBuilder();
            var tmp = new StringBuilder();

            
            if (one.Length != two.Length)
            {
                int difference;
                if (one.Length > two.Length)
                {
                    
                    difference = one.Length - two.Length;

                    
                    for (var i = 0; i < difference; i++)
                    {
                        tmp.Append('0');
                    }

                    tmp.Append(two);
                    sequence2 = tmp.ToString();
                }
                else
                {
                    
                    difference = two.Length - one.Length;

                    
                    for (var i = 0; i < difference; i++)
                    {
                        tmp.Append('0');
                    }

                    tmp.Append(one);
                    sequence1 = tmp.ToString();
                }
            } 

            var len = one.Length > two.Length ? one.Length : two.Length;
            var ans = new BitArray(len);

            for (var i = 0; i < one.Length; i++)
            {
                result.Append(sequence1[i].Equals('1') && sequence2[i].Equals('1') ? '1' : '0');
            }

            ans.Compile(result.ToString().Trim());

            return ans;
        }

        
        
        
        
        
        
        
        public static BitArray operator |(BitArray one, BitArray two)
        {
            var sequence1 = one.ToString();
            var sequence2 = two.ToString();
            var result = string.Empty;
            var tmp = string.Empty;

            
            if (one.Length != two.Length)
            {
                int difference;
                if (one.Length > two.Length)
                {
                    
                    difference = one.Length - two.Length;

                    
                    for (var i = 0; i < difference; i++)
                    {
                        tmp += '0';
                    }

                    tmp += two.ToString();
                    sequence2 = tmp;
                }
                else
                {
                    
                    difference = two.Length - one.Length;

                    
                    for (var i = 0; i < difference; i++)
                    {
                        tmp += '0';
                    }

                    tmp += one.ToString();
                    sequence1 = tmp;
                }
            } 

            var len = one.Length > two.Length ? one.Length : two.Length;
            var ans = new BitArray(len);

            for (var i = 0; i < len; i++)
            {
                result += sequence1[i].Equals('0') && sequence2[i].Equals('0') ? '0' : '1';
            }

            result = result.Trim();
            ans.Compile(result);

            return ans;
        }

        
        
        
        
        
        
        public static BitArray operator ~(BitArray one)
        {
            var ans = new BitArray(one.Length);
            var sequence = one.ToString();
            var result = string.Empty;

            foreach (var ch in sequence)
            {
                if (ch == '1')
                {
                    result += '0';
                }
                else
                {
                    result += '1';
                }
            }

            result = result.Trim();
            ans.Compile(result);

            return ans;
        }

        
        
        
        
        
        
        
        public static BitArray operator <<(BitArray other, int n)
        {
            var ans = new BitArray(other.Length + n);

            
            for (var i = 0; i < other.Length; i++)
            {
                ans[i] = other[i];
            }

            return ans;
        }

        
        
        
        
        
        
        
        public static BitArray operator ^(BitArray one, BitArray two)
        {
            var sequence1 = one.ToString();
            var sequence2 = two.ToString();
            var tmp = string.Empty;

            
            if (one.Length != two.Length)
            {
                int difference;
                if (one.Length > two.Length)
                {
                    
                    difference = one.Length - two.Length;

                    
                    for (var i = 0; i < difference; i++)
                    {
                        tmp += '0';
                    }

                    tmp += two.ToString();
                    sequence2 = tmp;
                }
                else
                {
                    
                    difference = two.Length - one.Length;

                    
                    for (var i = 0; i < difference; i++)
                    {
                        tmp += '0';
                    }

                    tmp += one.ToString();
                    sequence1 = tmp;
                }
            } 

            var len = one.Length > two.Length ? one.Length : two.Length;
            var ans = new BitArray(len);

            var sb = new StringBuilder();

            for (var i = 0; i < len; i++)
            {
                _ = sb.Append(sequence1[i] == sequence2[i] ? '0' : '1');
            }

            var result = sb.ToString().Trim();
            ans.Compile(result);

            return ans;
        }

        
        
        
        
        
        
        
        public static BitArray operator >>(BitArray other, int n)
        {
            var ans = new BitArray(other.Length - n);

            
            for (var i = 0; i < other.Length - n; i++)
            {
                ans[i] = other[i];
            }

            return ans;
        }

        
        
        
        
        
        
        
        public static bool operator ==(BitArray one, BitArray two)
        {
            if (ReferenceEquals(one, two))
            {
                return true;
            }

            if (one.Length != two.Length)
            {
                return false;
            }

            var status = true;
            for (var i = 0; i < one.Length; i++)
            {
                if (one[i] != two[i])
                {
                    status = false;
                    break;
                }
            }

            return status;
        }

        
        
        
        
        
        
        
        public static bool operator !=(BitArray one, BitArray two) => !(one == two);

        
        
        
        
        
        
        public void Compile(string sequence)
        {
            
            if (sequence.Length > field.Length)
            {
                throw new ArgumentException($"{nameof(sequence)} must be not longer than the bit array length");
            }

            
            ThrowIfSequenceIsInvalid(sequence);

            
            var tmp = string.Empty;
            if (sequence.Length < field.Length)
            {
                var difference = field.Length - sequence.Length;

                for (var i = 0; i < difference; i++)
                {
                    tmp += '0';
                }

                tmp += sequence;
                sequence = tmp;
            }

            
            for (var i = 0; i < sequence.Length; i++)
            {
                field[i] = sequence[i] == '1';
            }
        }

        
        
        
        
        
        public void Compile(int number)
        {
            var tmp = string.Empty;

            
            if (number <= 0)
            {
                throw new ArgumentException($"{nameof(number)} must be positive");
            }

            
            var binaryNumber = Convert.ToString(number, 2);

            
            if (binaryNumber.Length > field.Length)
            {
                throw new ArgumentException("Provided number is too big");
            }

            
            if (binaryNumber.Length < field.Length)
            {
                var difference = field.Length - binaryNumber.Length;

                for (var i = 0; i < difference; i++)
                {
                    tmp += '0';
                }

                tmp += binaryNumber;
                binaryNumber = tmp;
            }

            
            for (var i = 0; i < binaryNumber.Length; i++)
            {
                field[i] = binaryNumber[i] == '1';
            }
        }

        
        
        
        
        
        public void Compile(long number)
        {
            var tmp = string.Empty;

            
            if (number <= 0)
            {
                throw new ArgumentException($"{nameof(number)} must be positive");
            }

            
            var binaryNumber = Convert.ToString(number, 2);

            
            if (binaryNumber.Length > field.Length)
            {
                throw new ArgumentException("Provided number is too big");
            }

            
            if (binaryNumber.Length < field.Length)
            {
                var difference = field.Length - binaryNumber.Length;

                for (var i = 0; i < difference; i++)
                {
                    tmp += '0';
                }

                tmp += binaryNumber;
                binaryNumber = tmp;
            }

            
            for (var i = 0; i < binaryNumber.Length; i++)
            {
                field[i] = binaryNumber[i] == '1';
            }
        }

        
        
        
        
        public override string ToString()
        {
            
            return field.Aggregate(string.Empty, (current, t) => current + (t ? "1" : "0"));
        }

        
        
        
        
        public int NumberOfOneBits()
        {
            
            return field.Count(bit => bit);
        }

        
        
        
        
        public int NumberOfZeroBits()
        {
            
            return field.Count(bit => !bit);
        }

        
        
        
        
        public bool EvenParity() => NumberOfOneBits() % 2 == 0;

        
        
        
        
        public bool OddParity() => NumberOfOneBits() % 2 != 0;

        
        
        
        
        
        public long ToInt64()
        {
            
            if (field.Length > 64)
            {
                throw new InvalidOperationException("Value is too big to fit into Int64");
            }

            var sequence = ToString();
            return Convert.ToInt64(sequence, 2);
        }

        
        
        
        
        
        public int ToInt32()
        {
            
            if (field.Length > 32)
            {
                throw new InvalidOperationException("Value is too big to fit into Int32");
            }

            var sequence = ToString();
            return Convert.ToInt32(sequence, 2);
        }

        
        
        
        public void ResetField()
        {
            for (var i = 0; i < field.Length; i++)
            {
                field[i] = false;
            }
        }

        
        
        
        
        public void SetAll(bool flag)
        {
            for (var i = 0; i < field.Length; i++)
            {
                field[i] = flag;
            }
        }

        
        
        
        
        
        
        public override bool Equals(object? obj)
        {
            if (obj is null)
            {
                return false;
            }

            var otherBitArray = (BitArray)obj;

            if (Length != otherBitArray.Length)
            {
                return false;
            }

            for (var i = 0; i < Length; i++)
            {
                if (field[i] != otherBitArray[i])
                {
                    return false;
                }
            }

            return true;
        }

        
        
        
        
        
        public override int GetHashCode() => ToInt32();

        private static void ThrowIfSequenceIsInvalid(string sequence)
        {
            if (!Match(sequence))
            {
                throw new ArgumentException("The sequence may only contain ones or zeros");
            }
        }

        
        
        
        
        
        
        private static bool Match(string sequence) => sequence.All(ch => ch == '0' || ch == '1');
    }
}
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures
{
    
    
    
    
    
    public class Timeline<TValue> : ICollection<(DateTime Time, TValue Value)>, IEquatable<Timeline<TValue>>
    {
        
        
        
        private readonly List<(DateTime Time, TValue Value)> timeline = new();

        
        
        
        public Timeline()
        {
        }

        
        
        
        
        
        public Timeline(DateTime time, TValue value)
            => timeline = new List<(DateTime, TValue)>
            {
                (time, value),
            };

        
        
        
        
        
        public Timeline(params (DateTime, TValue)[] timeline)
            => this.timeline = timeline
                .OrderBy(pair => pair.Item1)
                .ToList();

        
        
        
        public int TimesCount
            => GetAllTimes().Length;

        
        
        
        public int ValuesCount
            => GetAllValues().Length;

        
        
        
        
        
        public TValue[] this[DateTime time]
        {
            get => GetValuesByTime(time);
            set
            {
                var overridenEvents = timeline.Where(@event => @event.Time == time).ToList();
                foreach (var @event in overridenEvents)
                {
                    timeline.Remove(@event);
                }

                foreach (var v in value)
                {
                    Add(time, v);
                }
            }
        }

        
        bool ICollection<(DateTime Time, TValue Value)>.IsReadOnly
            => false;

        
        
        
        public int Count
            => timeline.Count;

        
        
        
        public void Clear()
            => timeline.Clear();

        
        
        
        
        
        public void CopyTo((DateTime, TValue)[] array, int arrayIndex)
            => timeline.CopyTo(array, arrayIndex);

        
        
        
        
        void ICollection<(DateTime Time, TValue Value)>.Add((DateTime Time, TValue Value) item)
            => Add(item.Time, item.Value);

        
        
        
        
        
        bool ICollection<(DateTime Time, TValue Value)>.Contains((DateTime Time, TValue Value) item)
            => Contains(item.Time, item.Value);

        
        
        
        
        
        bool ICollection<(DateTime Time, TValue Value)>.Remove((DateTime Time, TValue Value) item)
            => Remove(item.Time, item.Value);

        
        IEnumerator IEnumerable.GetEnumerator()
            => timeline.GetEnumerator();

        
        IEnumerator<(DateTime Time, TValue Value)> IEnumerable<(DateTime Time, TValue Value)>.GetEnumerator()
            => timeline.GetEnumerator();

        
        public bool Equals(Timeline<TValue>? other)
            => other is not null && this == other;

        
        
        
        
        
        
        public static bool operator ==(Timeline<TValue> left, Timeline<TValue> right)
        {
            var leftArray = left.ToArray();
            var rightArray = right.ToArray();

            if (left.Count != rightArray.Length)
            {
                return false;
            }

            for (var i = 0; i < leftArray.Length; i++)
            {
                if (leftArray[i].Time != rightArray[i].Time
                    && !leftArray[i].Value!.Equals(rightArray[i].Value))
                {
                    return false;
                }
            }

            return true;
        }

        
        
        
        
        
        
        public static bool operator !=(Timeline<TValue> left, Timeline<TValue> right)
            => !(left == right);

        
        
        
        public DateTime[] GetAllTimes()
            => timeline.Select(t => t.Time)
                .Distinct()
                .ToArray();

        
        
        
        public DateTime[] GetTimesByValue(TValue value)
            => timeline.Where(pair => pair.Value!.Equals(value))
                .Select(pair => pair.Time)
                .ToArray();

        
        
        
        public DateTime[] GetTimesBefore(DateTime time)
            => GetAllTimes()
                .Where(t => t < time)
                .OrderBy(t => t)
                .ToArray();

        
        
        
        public DateTime[] GetTimesAfter(DateTime time)
            => GetAllTimes()
                .Where(t => t > time)
                .OrderBy(t => t)
                .ToArray();

        
        
        
        public TValue[] GetAllValues()
            => timeline.Select(pair => pair.Value)
                .ToArray();

        
        
        
        public TValue[] GetValuesByTime(DateTime time)
            => timeline.Where(pair => pair.Time == time)
                .Select(pair => pair.Value)
                .ToArray();

        
        
        
        public Timeline<TValue> GetValuesBefore(DateTime time)
            => new(this.Where(pair => pair.Time < time).ToArray());

        
        
        
        public Timeline<TValue> GetValuesAfter(DateTime time)
            => new(this.Where(pair => pair.Time > time).ToArray());

        
        
        
        
        
        public Timeline<TValue> GetValuesByMillisecond(int millisecond)
            => new(timeline.Where(pair => pair.Time.Millisecond == millisecond).ToArray());

        
        
        
        
        
        public Timeline<TValue> GetValuesBySecond(int second)
            => new(timeline.Where(pair => pair.Time.Second == second).ToArray());

        
        
        
        
        
        public Timeline<TValue> GetValuesByMinute(int minute)
            => new(timeline.Where(pair => pair.Time.Minute == minute).ToArray());

        
        
        
        
        
        public Timeline<TValue> GetValuesByHour(int hour)
            => new(timeline.Where(pair => pair.Time.Hour == hour).ToArray());

        
        
        
        
        
        public Timeline<TValue> GetValuesByDay(int day)
            => new(timeline.Where(pair => pair.Time.Day == day).ToArray());

        
        
        
        
        
        public Timeline<TValue> GetValuesByTimeOfDay(TimeSpan timeOfDay)
            => new(timeline.Where(pair => pair.Time.TimeOfDay == timeOfDay).ToArray());

        
        
        
        
        
        public Timeline<TValue> GetValuesByDayOfWeek(DayOfWeek dayOfWeek)
            => new(timeline.Where(pair => pair.Time.DayOfWeek == dayOfWeek).ToArray());

        
        
        
        
        
        public Timeline<TValue> GetValuesByDayOfYear(int dayOfYear)
            => new(timeline.Where(pair => pair.Time.DayOfYear == dayOfYear).ToArray());

        
        
        
        
        
        public Timeline<TValue> GetValuesByMonth(int month)
            => new(timeline.Where(pair => pair.Time.Month == month).ToArray());

        
        
        
        
        
        public Timeline<TValue> GetValuesByYear(int year)
            => new(timeline.Where(pair => pair.Time.Year == year).ToArray());

        
        
        
        
        
        public void Add(DateTime time, TValue value)
        {
            timeline.Add((time, value));
        }

        
        
        
        public void Add(params (DateTime, TValue)[] timeline)
        {
            this.timeline.AddRange(timeline);
        }

        
        
        
        public void Add(Timeline<TValue> timeline)
            => Add(timeline.ToArray());

        
        
        
        public void AddNow(params TValue[] value)
        {
            var now = DateTime.Now;
            foreach (var v in value)
            {
                Add(now, v);
            }
        }

        
        
        
        
        
        
        public bool Contains(DateTime time, TValue value)
            => timeline.Contains((time, value));

        
        
        
        
        
        public bool Contains(params (DateTime, TValue)[] timeline)
            => timeline.Any(@event => Contains(@event.Item1, @event.Item2));

        
        
        
        
        
        public bool Contains(Timeline<TValue> timeline)
            => Contains(timeline.ToArray());

        
        
        
        
        
        public bool ContainsTime(params DateTime[] times)
        {
            var storedTimes = GetAllTimes();
            return times.Any(value => storedTimes.Contains(value));
        }

        
        
        
        
        
        public bool ContainsValue(params TValue[] values)
        {
            var storedValues = GetAllValues();
            return values.Any(value => storedValues.Contains(value));
        }

        
        
        
        
        
        
        public bool Remove(DateTime time, TValue value)
            => timeline.Remove((time, value));

        
        
        
        
        
        public bool Remove(params (DateTime, TValue)[] timeline)
        {
            var result = false;
            foreach (var (time, value) in timeline)
            {
                result |= this.timeline.Remove((time, value));
            }

            return result;
        }

        
        
        
        
        
        public bool Remove(Timeline<TValue> timeline)
            => Remove(timeline.ToArray());

        
        
        
        
        public bool RemoveTimes(params DateTime[] times)
        {
            var isTimeContainedInTheTimeline = times.Any(time => GetAllTimes().Contains(time));

            if (!isTimeContainedInTheTimeline)
            {
                return false;
            }

            var eventsToRemove = times.SelectMany(time =>
                timeline.Where(@event => @event.Time == time))
                .ToList();

            foreach (var @event in eventsToRemove)
            {
                timeline.Remove(@event);
            }

            return true;
        }

        
        
        
        
        public bool RemoveValues(params TValue[] values)
        {
            var isValueContainedInTheTimeline = values.Any(v => GetAllValues().Contains(v));

            if (!isValueContainedInTheTimeline)
            {
                return false;
            }

            var eventsToRemove = values.SelectMany(value =>
                timeline.Where(@event => EqualityComparer<TValue>.Default.Equals(@event.Value, value)))
                .ToList();

            foreach (var @event in eventsToRemove)
            {
                timeline.Remove(@event);
            }

            return true;
        }

        
        
        
        
        
        
        public (DateTime Time, TValue Value)[] ToArray()
            => timeline.ToArray();

        
        
        
        
        
        
        public IList<(DateTime Time, TValue Value)> ToList()
            => timeline;

        
        
        
        
        
        
        public IDictionary<DateTime, TValue> ToDictionary()
            => timeline.ToDictionary(@event => @event.Time, @event => @event.Value);

        
        public override bool Equals(object? obj)
            => obj is Timeline<TValue> otherTimeline
               && this == otherTimeline;

        
        public override int GetHashCode()
            => timeline.GetHashCode();
    }
}
﻿using System;
using System.Collections.Generic;

namespace DataStructures.BinarySearchTree
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    public class BinarySearchTree<TKey>
    {
        
        
        
        private readonly Comparer<TKey> comparer;

        
        
        
        private BinarySearchTreeNode<TKey>? root;

        public BinarySearchTree()
        {
            root = null;
            Count = 0;
            comparer = Comparer<TKey>.Default;
        }

        public BinarySearchTree(Comparer<TKey> customComparer)
        {
            root = null;
            Count = 0;
            comparer = customComparer;
        }

        
        
        
        public int Count { get; private set; }

        
        
        
        
        
        
        
        public void Add(TKey key)
        {
            if (root is null)
            {
                root = new BinarySearchTreeNode<TKey>(key);
            }
            else
            {
                Add(root, key);
            }

            Count++;
        }

        
        
        
        
        
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys)
            {
                Add(key);
            }
        }

        
        
        
        
        
        public BinarySearchTreeNode<TKey>? Search(TKey key) => Search(root, key);

        
        
        
        
        
        public bool Contains(TKey key) => Search(root, key) is not null;

        
        
        
        
        
        public bool Remove(TKey key)
        {
            if (root is null)
            {
                return false;
            }

            var result = Remove(root, root, key);
            if (result)
            {
                Count--;
            }

            return result;
        }

        
        
        
        
        public BinarySearchTreeNode<TKey>? GetMin()
        {
            if (root is null)
            {
                return default;
            }

            return GetMin(root);
        }

        
        
        
        
        public BinarySearchTreeNode<TKey>? GetMax()
        {
            if (root is null)
            {
                return default;
            }

            return GetMax(root);
        }

        
        
        
        
        public ICollection<TKey> GetKeysInOrder() => GetKeysInOrder(root);

        
        
        
        
        public ICollection<TKey> GetKeysPreOrder() => GetKeysPreOrder(root);

        
        
        
        
        public ICollection<TKey> GetKeysPostOrder() => GetKeysPostOrder(root);

        
        
        
        
        
        
        
        
        private void Add(BinarySearchTreeNode<TKey> node, TKey key)
        {
            var compareResult = comparer.Compare(node.Key, key);
            if (compareResult > 0)
            {
                if (node.Left is not null)
                {
                    Add(node.Left, key);
                }
                else
                {
                    var newNode = new BinarySearchTreeNode<TKey>(key);
                    node.Left = newNode;
                }
            }
            else if (compareResult < 0)
            {
                if (node.Right is not null)
                {
                    Add(node.Right, key);
                }
                else
                {
                    var newNode = new BinarySearchTreeNode<TKey>(key);
                    node.Right = newNode;
                }
            }

            
            else
            {
                throw new ArgumentException($"Key \"{key}\" already exists in tree!");
            }
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        private bool Remove(BinarySearchTreeNode<TKey>? parent, BinarySearchTreeNode<TKey>? node, TKey key)
        {
            if (node is null || parent is null)
            {
                return false;
            }

            var compareResult = comparer.Compare(node.Key, key);

            if (compareResult > 0)
            {
                return Remove(node, node.Left, key);
            }

            if (compareResult < 0)
            {
                return Remove(node, node.Right, key);
            }

            BinarySearchTreeNode<TKey>? replacementNode;

            
            
            if (node.Left is null || node.Right is null)
            {
                replacementNode = node.Left ?? node.Right;
            }

            
            else
            {
                var predecessorNode = GetMax(node.Left);
                Remove(root, root, predecessorNode.Key);
                replacementNode = new BinarySearchTreeNode<TKey>(predecessorNode.Key)
                {
                    Left = node.Left,
                    Right = node.Right,
                };
            }

            
            
            if (node == root)
            {
                root = replacementNode;
            }
            else if (parent.Left == node)
            {
                parent.Left = replacementNode;
            }
            else
            {
                parent.Right = replacementNode;
            }

            return true;
        }

        
        
        
        
        
        private BinarySearchTreeNode<TKey> GetMax(BinarySearchTreeNode<TKey> node)
        {
            if (node.Right is null)
            {
                return node;
            }

            return GetMax(node.Right);
        }

        
        
        
        
        
        private BinarySearchTreeNode<TKey> GetMin(BinarySearchTreeNode<TKey> node)
        {
            if (node.Left is null)
            {
                return node;
            }

            return GetMin(node.Left);
        }

        
        
        
        
        
        private IList<TKey> GetKeysInOrder(BinarySearchTreeNode<TKey>? node)
        {
            if (node is null)
            {
                return new List<TKey>();
            }

            var result = new List<TKey>();
            result.AddRange(GetKeysInOrder(node.Left));
            result.Add(node.Key);
            result.AddRange(GetKeysInOrder(node.Right));
            return result;
        }

        
        
        
        
        
        private IList<TKey> GetKeysPreOrder(BinarySearchTreeNode<TKey>? node)
        {
            if (node is null)
            {
                return new List<TKey>();
            }

            var result = new List<TKey>();
            result.Add(node.Key);
            result.AddRange(GetKeysPreOrder(node.Left));
            result.AddRange(GetKeysPreOrder(node.Right));
            return result;
        }

        
        
        
        
        
        private IList<TKey> GetKeysPostOrder(BinarySearchTreeNode<TKey>? node)
        {
            if (node is null)
            {
                return new List<TKey>();
            }

            var result = new List<TKey>();
            result.AddRange(GetKeysPostOrder(node.Left));
            result.AddRange(GetKeysPostOrder(node.Right));
            result.Add(node.Key);
            return result;
        }

        
        
        
        
        
        
        private BinarySearchTreeNode<TKey>? Search(BinarySearchTreeNode<TKey>? node, TKey key)
        {
            if (node is null)
            {
                return default;
            }

            var compareResult = comparer.Compare(node.Key, key);
            if (compareResult > 0)
            {
                return Search(node.Left, key);
            }

            if (compareResult < 0)
            {
                return Search(node.Right, key);
            }

            return node;
        }
    }
}
﻿namespace DataStructures.BinarySearchTree
{
    
    
    
    
    
    public class BinarySearchTreeNode<TKey>
    {
        
        
        
        
        public BinarySearchTreeNode(TKey key) => Key = key;

        
        
        
        public TKey Key { get; }

        
        
        
        public BinarySearchTreeNode<TKey>? Left { get; set; }

        
        
        
        public BinarySearchTreeNode<TKey>? Right { get; set; }
    }
}
﻿namespace DataStructures.AATree
{
    
    
    
    
    public class AaTreeNode<TKey>
    {
        
        
        
        
        
        public AaTreeNode(TKey key, int level)
        {
            Key = key;
            Level = level;
        }

        
        
        
        public TKey Key { get; set; }

        
        
        
        public int Level { get; set; }

        
        
        
        public AaTreeNode<TKey>? Left { get; set; }

        
        
        
        public AaTreeNode<TKey>? Right { get; set; }
    }
}
﻿using System;
using System.Collections.Generic;

namespace DataStructures.AATree
{
    
    
    
    
    
    
    
    
    
    
    
    public class AaTree<TKey>
    {
        
        
        
        private readonly Comparer<TKey> comparer;

        
        
        
        public AaTree()
            : this(Comparer<TKey>.Default)
        {
        }

        
        
        
        
        public AaTree(Comparer<TKey> customComparer) => comparer = customComparer;

        
        
        
        public AaTreeNode<TKey>? Root { get; private set; }

        
        
        
        public int Count { get; private set; }

        
        
        
        
        public void Add(TKey key)
        {
            Root = Add(key, Root);
            Count++;
        }

        
        
        
        
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys)
            {
                Root = Add(key, Root);
                Count++;
            }
        }

        
        
        
        
        public void Remove(TKey key)
        {
            if (!Contains(key, Root))
            {
                throw new InvalidOperationException($"{nameof(key)} is not in the tree");
            }

            Root = Remove(key, Root);
            Count--;
        }

        
        
        
        
        
        public bool Contains(TKey key) => Contains(key, Root);

        
        
        
        
        
        public TKey GetMax()
        {
            if (Root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMax(Root).Key;
        }

        
        
        
        
        
        public TKey GetMin()
        {
            if (Root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMin(Root).Key;
        }

        
        
        
        
        public IEnumerable<TKey> GetKeysInOrder()
        {
            var result = new List<TKey>();
            InOrderWalk(Root);
            return result;

            void InOrderWalk(AaTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                InOrderWalk(node.Left);
                result.Add(node.Key);
                InOrderWalk(node.Right);
            }
        }

        
        
        
        
        public IEnumerable<TKey> GetKeysPreOrder()
        {
            var result = new List<TKey>();
            PreOrderWalk(Root);
            return result;

            void PreOrderWalk(AaTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                result.Add(node.Key);
                PreOrderWalk(node.Left);
                PreOrderWalk(node.Right);
            }
        }

        
        
        
        
        public IEnumerable<TKey> GetKeysPostOrder()
        {
            var result = new List<TKey>();
            PostOrderWalk(Root);
            return result;

            void PostOrderWalk(AaTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                PostOrderWalk(node.Left);
                PostOrderWalk(node.Right);
                result.Add(node.Key);
            }
        }

        
        
        
        
        
        
        
        private AaTreeNode<TKey> Add(TKey key, AaTreeNode<TKey>? node)
        {
            if (node is null)
            {
                return new AaTreeNode<TKey>(key, 1);
            }

            if (comparer.Compare(key, node.Key) < 0)
            {
                node.Left = Add(key, node.Left);
            }
            else if (comparer.Compare(key, node.Key) > 0)
            {
                node.Right = Add(key, node.Right);
            }
            else
            {
                throw new ArgumentException($"Key \"{key}\" already in tree!", nameof(key));
            }

            return Split(Skew(node)) !;
        }

        
        
        
        
        
        
        private AaTreeNode<TKey>? Remove(TKey key, AaTreeNode<TKey>? node)
        {
            if (node is null)
            {
                return null;
            }

            if (comparer.Compare(key, node.Key) < 0)
            {
                node.Left = Remove(key, node.Left);
            }
            else if (comparer.Compare(key, node.Key) > 0)
            {
                node.Right = Remove(key, node.Right);
            }
            else
            {
                if (node.Left is null && node.Right is null)
                {
                    return null;
                }

                if (node.Left is null)
                {
                    var successor = GetMin(node.Right!);
                    node.Right = Remove(successor.Key, node.Right);
                    node.Key = successor.Key;
                }
                else
                {
                    var predecessor = GetMax(node.Left);
                    node.Left = Remove(predecessor.Key, node.Left);
                    node.Key = predecessor.Key;
                }
            }

            node = DecreaseLevel(node);
            node = Skew(node);
            node!.Right = Skew(node.Right);

            if (node.Right is not null)
            {
                node.Right.Right = Skew(node.Right.Right);
            }

            node = Split(node);
            node!.Right = Split(node.Right);
            return node;
        }

        
        
        
        
        
        
        private bool Contains(TKey key, AaTreeNode<TKey>? node) =>
            node is { }
            && comparer.Compare(key, node.Key) is { } v
            && v switch
            {
                { } when v > 0 => Contains(key, node.Right),
                { } when v < 0 => Contains(key, node.Left),
                _ => true,
            };

        
        
        
        
        
        private AaTreeNode<TKey> GetMax(AaTreeNode<TKey> node)
        {
            while (true)
            {
                if (node.Right is null)
                {
                    return node;
                }

                node = node.Right;
            }
        }

        
        
        
        
        
        private AaTreeNode<TKey> GetMin(AaTreeNode<TKey> node)
        {
            while (true)
            {
                if (node.Left is null)
                {
                    return node;
                }

                node = node.Left;
            }
        }

        
        
        
        
        
        
        private AaTreeNode<TKey>? Skew(AaTreeNode<TKey>? node)
        {
            if (node?.Left is null || node.Left.Level != node.Level)
            {
                return node;
            }

            var left = node.Left;
            node.Left = left.Right;
            left.Right = node;
            return left;
        }

        
        
        
        
        
        
        private AaTreeNode<TKey>? Split(AaTreeNode<TKey>? node)
        {
            if (node?.Right?.Right is null || node.Level != node.Right.Right.Level)
            {
                return node;
            }

            var right = node.Right;
            node.Right = right.Left;
            right.Left = node;
            right.Level++;
            return right;
        }

        
        
        
        
        
        private AaTreeNode<TKey> DecreaseLevel(AaTreeNode<TKey> node)
        {
            var newLevel = Math.Min(GetLevel(node.Left), GetLevel(node.Right)) + 1;
            if (newLevel >= node.Level)
            {
                return node;
            }

            node.Level = newLevel;
            if (node.Right is { } && newLevel < node.Right.Level)
            {
                node.Right.Level = newLevel;
            }

            return node;

            static int GetLevel(AaTreeNode<TKey>? x) => x?.Level ?? 0;
        }
    }
}
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
    <CodeAnalysisRuleSet>..\stylecop.ruleset</CodeAnalysisRuleSet>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DocumentationFile>./bin/DataStructures.xml</DocumentationFile>
  </PropertyGroup>

  <ItemGroup>
    <AdditionalFiles Include="..\stylecop.json" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="StyleCop.Analyzers" Version="1.1.118">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\Utilities\Utilities.csproj" />
  </ItemGroup>

</Project>
﻿using System.Collections.Generic;
using System.Linq;

namespace DataStructures
{
    
    
    
    
    
    
    
    public class InvertedIndex
    {
        private readonly Dictionary<string, List<string>> invertedIndex = new();

        
        
        
        
        
        public void AddToIndex(string sourceName, string sourceContent)
        {
            var context = sourceContent.Split(' ').Distinct();
            foreach (var word in context)
            {
                if (!invertedIndex.ContainsKey(word))
                {
                    invertedIndex.Add(word, new List<string> { sourceName });
                }
                else
                {
                    invertedIndex[word].Add(sourceName);
                }
            }
        }

        
        
        
        
        
        public IEnumerable<string> And(IEnumerable<string> terms)
        {
            var entries = terms
                .Select(term => invertedIndex
                    .Where(x => x.Key.Equals(term))
                    .SelectMany(x => x.Value))
                .ToList();

            var intersection = entries
                .Skip(1)
                .Aggregate(new HashSet<string>(entries.First()), (hashSet, enumerable) =>
                {
                    hashSet.IntersectWith(enumerable);
                    return hashSet;
                });

            return intersection;
        }

        
        
        
        
        
        public IEnumerable<string> Or(IEnumerable<string> terms)
        {
            var sources = new List<string>();
            foreach (var term in terms)
            {
                var source = invertedIndex
                    .Where(x => x.Key.Equals(term))
                    .SelectMany(x => x.Value);

                sources.AddRange(source);
            }

            return sources.Distinct();
        }
    }
}
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Heap.PairingHeap
{
    
    
    
    
    public class PairingHeap<T> : IEnumerable<T> where T : IComparable
    {
        private readonly Sorting sorting;
        private readonly IComparer<T> comparer;
        private readonly Dictionary<T, List<PairingHeapNode<T>>> mapping = new();

        private PairingHeapNode<T> root = null!;

        public int Count { get; private set; }

        public PairingHeap(Sorting sortDirection = Sorting.Ascending)
        {
            sorting = sortDirection;
            comparer = new PairingNodeComparer<T>(sortDirection, Comparer<T>.Default);
        }

        
        
        
        public void Insert(T newItem)
        {
            var newNode = new PairingHeapNode<T>(newItem);

            root = RebuildHeap(root, newNode);
            Map(newItem, newNode);

            Count++;
        }

        
        
        
        public T Extract()
        {
            var minMax = root;

            RemoveMapping(minMax.Value, minMax);
            RebuildHeap(root.ChildrenHead);

            Count--;
            return minMax.Value;
        }

        
        
        
        public void UpdateKey(T currentValue, T newValue)
        {
            if(!mapping.ContainsKey(currentValue))
            {
                throw new ArgumentException("Current value is not present in this heap.");
            }

            var node = mapping[currentValue]?.Where(x => x.Value.Equals(currentValue)).FirstOrDefault();

            if (comparer.Compare(newValue, node!.Value) > 0)
            {
                throw new ArgumentException($"New value is not {(sorting != Sorting.Descending ? "less" : "greater")} than old value.");
            }

            UpdateNodeValue(currentValue, newValue, node);

            if (node == root)
            {
                return;
            }

            DeleteChild(node);

            root = RebuildHeap(root, node);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public IEnumerator<T> GetEnumerator()
        {
            return mapping.SelectMany(x => x.Value).Select(x => x.Value).GetEnumerator();
        }

        
        
        
        private void RebuildHeap(PairingHeapNode<T> headNode)
        {
            if (headNode == null)
            {
                return;
            }

            var passOneResult = new List<PairingHeapNode<T>>();
            var current = headNode;

            if (current.Next == null)
            {
                headNode.Next = null!;
                headNode.Previous = null!;
                passOneResult.Add(headNode);
            }
            else
            {
                while (true)
                {
                    if (current == null)
                    {
                        break;
                    }

                    if (current.Next != null)
                    {
                        var next = current.Next;
                        var nextNext = next.Next;
                        passOneResult.Add(RebuildHeap(current, next));
                        current = nextNext;
                    }
                    else
                    {
                        var lastInserted = passOneResult[^1];
                        passOneResult[^1] = RebuildHeap(lastInserted, current);
                        break;
                    }
                }
            }

            var passTwoResult = passOneResult[^1];

            if (passOneResult.Count == 1)
            {
                root = passTwoResult;
                return;
            }

            for (var i = passOneResult.Count - 2; i >= 0; i--)
            {
                current = passOneResult[i];
                passTwoResult = RebuildHeap(passTwoResult, current);
            }

            root = passTwoResult;
        }

        private PairingHeapNode<T> RebuildHeap(PairingHeapNode<T> node1, PairingHeapNode<T> node2)
        {
            if (node2 != null)
            {
                node2.Previous = null!;
                node2.Next = null!;
            }

            if (node1 == null)
            {
                return node2!;
            }

            node1.Previous = null!;
            node1.Next = null!;

            if (node2 != null && comparer.Compare(node1.Value, node2.Value) <= 0)
            {
                AddChild(ref node1, node2);
                return node1;
            }

            AddChild(ref node2!, node1);
            return node2;
        }

        private void AddChild(ref PairingHeapNode<T> parent, PairingHeapNode<T> child)
        {
            if (parent.ChildrenHead == null)
            {
                parent.ChildrenHead = child;
                child.Previous = parent;
                return;
            }

            var head = parent.ChildrenHead;

            child.Previous = head;
            child.Next = head.Next;

            if (head.Next != null)
            {
                head.Next.Previous = child;
            }

            head.Next = child;
        }

        private void DeleteChild(PairingHeapNode<T> node)
        {
            if (node.IsHeadChild)
            {
                var parent = node.Previous;

                if (node.Next != null)
                {
                    node.Next.Previous = parent;
                }

                parent.ChildrenHead = node.Next!;
            }
            else
            {
                node.Previous.Next = node.Next;

                if (node.Next != null)
                {
                    node.Next.Previous = node.Previous;
                }
            }
        }

        private void Map(T newItem, PairingHeapNode<T> newNode)
        {
            if (mapping.ContainsKey(newItem))
            {
                mapping[newItem].Add(newNode);
            }
            else
            {
                mapping[newItem] = new List<PairingHeapNode<T>>(new[] { newNode });
            }
        }

        private void UpdateNodeValue(T currentValue, T newValue, PairingHeapNode<T> node)
        {
            RemoveMapping(currentValue, node);
            node.Value = newValue;
            Map(newValue, node);
        }

        private void RemoveMapping(T currentValue, PairingHeapNode<T> node)
        {
            mapping[currentValue].Remove(node);
            if (mapping[currentValue].Count == 0)
            {
                mapping.Remove(currentValue);
            }
        }
    }
}
﻿namespace DataStructures.Heap.PairingHeap
{
    public enum Sorting
    {
        
        
        
        Ascending = 0,

        
        
        
        Descending = 1,
    }
}
﻿using System;
using System.Collections.Generic;

namespace DataStructures.Heap.PairingHeap
{
    
    
    
    
    public class PairingNodeComparer<T> : IComparer<T> where T : IComparable
    {
        private readonly bool isMax;
        private readonly IComparer<T> nodeComparer;

        public PairingNodeComparer(Sorting sortDirection, IComparer<T> comparer)
        {
            isMax = sortDirection == Sorting.Descending;
            nodeComparer = comparer;
        }

        public int Compare(T? x, T? y)
        {
            return !isMax
                ? CompareNodes(x, y)
                : CompareNodes(y, x);
        }

        private int CompareNodes(T? one, T? second)
        {
            return nodeComparer.Compare(one, second);
        }
    }
}
﻿using System;

namespace DataStructures.Heap.PairingHeap
{
    
    
    
    
    public class PairingHeapNode<T>
    {
        public PairingHeapNode(T value)
        {
            Value = value;
        }

        public T Value { get; set; }

        public PairingHeapNode<T> ChildrenHead { get; set; } = null!;

        public bool IsHeadChild => Previous != null && Previous.ChildrenHead == this;

        public PairingHeapNode<T> Previous { get; set; } = null!;

        public PairingHeapNode<T> Next { get; set; } = null!;
    }
}
using System;

namespace DataStructures.Heap.FibonacciHeap
{
    
    
    
    
    
    
    public class FHeapNode<T> where T : IComparable
    {
        
        
        
        
        public FHeapNode(T key)
        {
            Key = key;

            
            
            Left = Right = this;
            Parent = Child = null;
        }

        
        
        
        public T Key { get; set; }

        
        
        
        public FHeapNode<T>? Parent { get; set; }

        
        
        
        public FHeapNode<T> Left { get; set; }

        
        
        
        public FHeapNode<T> Right { get; set; }

        
        
        
        
        
        public FHeapNode<T>? Child { get; set; }

        
        
        
        
        public bool Mark { get; set; }

        
        
        
        public int Degree { get; set; }

        public void SetSiblings(FHeapNode<T> left, FHeapNode<T> right)
        {
            Left = left;
            Right = right;
        }

        
        
        
        
        
        public void AddRight(FHeapNode<T> node)
        {
            Right.Left = node;
            node.Right = Right;
            node.Left = this;
            Right = node;
        }

        
        
        
        
        public void AddChild(FHeapNode<T> node)
        {
            Degree++;

            if (Child == null)
            {
                Child = node;
                Child.Parent = this;
                Child.Left = Child.Right = Child;

                return;
            }

            Child.AddRight(node);
        }

        
        
        
        public void Remove()
        {
            Left.Right = Right;
            Right.Left = Left;
        }

        
        
        
        
        
        
        
        
        
        
        public void ConcatenateRight(FHeapNode<T> otherList)
        {
            Right.Left = otherList.Left;
            otherList.Left.Right = Right;

            Right = otherList;
            otherList.Left = this;
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Heap.FibonacciHeap
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public class FibonacciHeap<T> where T : IComparable
    {
        
        
        
        public int Count { get; set; }

        
        
        
        
        
        private FHeapNode<T>? MinItem { get; set; }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        public FHeapNode<T> Push(T x)
        {
            Count++;

            var newItem = new FHeapNode<T>(x);

            if (MinItem == null)
            {
                MinItem = newItem;
            }
            else
            {
                MinItem.AddRight(newItem);

                if (newItem.Key.CompareTo(MinItem.Key) < 0)
                {
                    MinItem = newItem;
                }
            }

            return newItem;
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        public void Union(FibonacciHeap<T> other)
        {
            
            if (other.MinItem == null)
            {
                return;
            }

            
            if (MinItem == null)
            {
                
                MinItem = other.MinItem;
                Count = other.Count;

                
                other.MinItem = null;
                other.Count = 0;

                return;
            }

            Count += other.Count;

            
            MinItem.ConcatenateRight(other.MinItem);

            
            if (other.MinItem.Key.CompareTo(MinItem.Key) < 0)
            {
                MinItem = other.MinItem;
            }

            other.MinItem = null;
            other.Count = 0;
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        public T Pop()
        {
            FHeapNode<T>? z = null;
            if (MinItem == null)
            {
                throw new InvalidOperationException("Heap is empty!");
            }

            z = MinItem;

            
            if (z.Child != null)
            {
                foreach (var x in SiblingIterator(z.Child))
                {
                    x.Parent = null;
                }

                
                z.ConcatenateRight(z.Child);
            }

            if (Count == 1)
            {
                MinItem = null;
                Count = 0;
                return z.Key;
            }

            
            
            MinItem = MinItem.Right;

            
            z.Remove();

            
            Consolidate();

            Count -= 1;

            return z.Key;
        }

        
        
        
        
        
        
        
        public T Peek()
        {
            if (MinItem == null)
            {
                throw new InvalidOperationException("The heap is empty");
            }

            return MinItem.Key;
        }

        
        
        
        
        
        
        
        
        public void DecreaseKey(FHeapNode<T> x, T k)
        {
            if (MinItem == null)
            {
                throw new ArgumentException($"{nameof(x)} is not from the heap");
            }

            if (x.Key == null)
            {
                throw new ArgumentException("x has no value");
            }

            if (k.CompareTo(x.Key) > 0)
            {
                throw new InvalidOperationException("Value cannot be increased");
            }

            x.Key = k;
            var y = x.Parent;
            if (y != null && x.Key.CompareTo(y.Key) < 0)
            {
                Cut(x, y);
                CascadingCut(y);
            }

            if (x.Key.CompareTo(MinItem.Key) < 0)
            {
                MinItem = x;
            }
        }

        
        
        
        
        
        protected void Cut(FHeapNode<T> x, FHeapNode<T> y)
        {
            if (MinItem == null)
            {
                throw new InvalidOperationException("Heap malformed");
            }

            if (y.Degree == 1)
            {
                y.Child = null;
                MinItem.AddRight(x);
            }
            else if (y.Degree > 1)
            {
                x.Remove();
            }
            else
            {
                throw new InvalidOperationException("Heap malformed");
            }

            y.Degree--;
            x.Mark = false;
            x.Parent = null;
        }

        
        
        
        
        protected void CascadingCut(FHeapNode<T> y)
        {
            var z = y.Parent;
            if (z != null)
            {
                if (!y.Mark)
                {
                    y.Mark = true;
                }
                else
                {
                    Cut(y, z);
                    CascadingCut(z);
                }
            }
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        protected void Consolidate()
        {
            if (MinItem == null)
            {
                return;
            }

            
            
            
            
            
            
            var maxDegree = 1 + (int)Math.Log(Count, (1 + Math.Sqrt(5)) / 2);

            
            var a = new FHeapNode<T>?[maxDegree];
            var siblings = SiblingIterator(MinItem).ToList();
            foreach (var w in siblings)
            {
                var x = w;
                var d = x.Degree;

                var y = a[d];

                
                while (y != null)
                {
                    if (x.Key.CompareTo(y.Key) > 0)
                    {
                        
                        var temp = x;
                        x = y;
                        y = temp;
                    }

                    
                    FibHeapLink(y, x);

                    
                    a[d] = null;

                    
                    d++;

                    y = a[d];
                }

                
                a[d] = x;
            }

            ReconstructHeap(a);
        }

        
        
        
        
        private void ReconstructHeap(FHeapNode<T>?[] a)
        {
            
            MinItem = null;

            for (var i = 0; i < a.Length; i++)
            {
                var r = a[i];
                if (r == null)
                {
                    continue;
                }

                if (MinItem == null)
                {
                    
                    
                    MinItem = r;

                    
                    
                    MinItem.SetSiblings(MinItem, MinItem);
                    MinItem.Parent = null;
                }
                else
                {
                    
                    MinItem.AddRight(r);

                    
                    if (MinItem.Key.CompareTo(r.Key) > 0)
                    {
                        MinItem = a[i];
                    }
                }
            }
        }

        
        
        
        
        
        private void FibHeapLink(FHeapNode<T> y, FHeapNode<T> x)
        {
            y.Remove();
            x.AddChild(y);
            y.Mark = false;
        }

        
        
        
        
        
        
        private IEnumerable<FHeapNode<T>> SiblingIterator(FHeapNode<T> node)
        {
            var currentNode = node;
            yield return currentNode;

            currentNode = node.Right;
            while (currentNode != node)
            {
                yield return currentNode;
                currentNode = currentNode.Right;
            }
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Heap
{
    
    
    
    
    
    
    
    public class MinMaxHeap<T>
    {
        private readonly List<T> heap;

        
        
        
        
        
        
        public MinMaxHeap(IEnumerable<T>? collection = null, IComparer<T>? comparer = null)
        {
            Comparer = comparer ?? Comparer<T>.Default;
            collection ??= Enumerable.Empty<T>();

            heap = collection.ToList();
            for (var i = Count / 2 - 1; i >= 0; --i)
            {
                PushDown(i);
            }
        }

        
        
        
        public IComparer<T> Comparer { get; }

        
        
        
        public int Count => heap.Count;

        
        
        
        
        public void Add(T item)
        {
            heap.Add(item);
            PushUp(Count - 1);
        }

        
        
        
        
        
        public T ExtractMax()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty");
            }

            var max = GetMax();
            RemoveNode(GetMaxNodeIndex());
            return max;
        }

        
        
        
        
        
        public T ExtractMin()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty");
            }

            var min = GetMin();
            RemoveNode(0);
            return min;
        }

        
        
        
        
        
        public T GetMax()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty");
            }

            return heap[GetMaxNodeIndex()];
        }

        
        
        
        
        
        public T GetMin()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty");
            }

            return heap[0];
        }

        
        
        
        
        
        private int IndexOfMaxChildOrGrandchild(int index)
        {
            var descendants = new[]
            {
                2 * index + 1,
                2 * index + 2,
                4 * index + 3,
                4 * index + 4,
                4 * index + 5,
                4 * index + 6,
            };
            var resIndex = descendants[0];
            foreach (var descendant in descendants)
            {
                if (descendant >= Count)
                {
                    break;
                }

                if (Comparer.Compare(heap[descendant], heap[resIndex]) > 0)
                {
                    resIndex = descendant;
                }
            }

            return resIndex;
        }

        
        
        
        
        
        private int IndexOfMinChildOrGrandchild(int index)
        {
            var descendants = new[] { 2 * index + 1, 2 * index + 2, 4 * index + 3, 4 * index + 4, 4 * index + 5, 4 * index + 6 };
            var resIndex = descendants[0];
            foreach (var descendant in descendants)
            {
                if (descendant >= Count)
                {
                    break;
                }

                if (Comparer.Compare(heap[descendant], heap[resIndex]) < 0)
                {
                    resIndex = descendant;
                }
            }

            return resIndex;
        }

        private int GetMaxNodeIndex()
        {
            return Count switch
            {
                0 => throw new InvalidOperationException("Heap is empty"),
                1 => 0,
                2 => 1,
                _ => Comparer.Compare(heap[1], heap[2]) > 0 ? 1 : 2,
            };
        }

        private bool HasChild(int index) => index * 2 + 1 < Count;

        private bool IsGrandchild(int node, int grandchild) => grandchild > 2 && Grandparent(grandchild) == node;

        
        
        
        
        
        
        
        private bool IsMinLevelIndex(int index)
        {
            
            const uint minLevelsBits = 0x55555555;
            const uint maxLevelsBits = 0xAAAAAAAA;
            return ((index + 1) & minLevelsBits) > ((index + 1) & maxLevelsBits);
        }

        private int Parent(int index) => (index - 1) / 2;

        private int Grandparent(int index) => ((index - 1) / 2 - 1) / 2;

        
        
        
        
        
        private void PushDown(int index)
        {
            if (IsMinLevelIndex(index))
            {
                PushDownMin(index);
            }
            else
            {
                PushDownMax(index);
            }
        }

        private void PushDownMax(int index)
        {
            if (!HasChild(index))
            {
                return;
            }

            var maxIndex = IndexOfMaxChildOrGrandchild(index);

            
            
            if (IsGrandchild(index, maxIndex))
            {
                if (Comparer.Compare(heap[maxIndex], heap[index]) > 0)
                {
                    SwapNodes(maxIndex, index);
                    if (Comparer.Compare(heap[maxIndex], heap[Parent(maxIndex)]) < 0)
                    {
                        SwapNodes(maxIndex, Parent(maxIndex));
                    }

                    PushDownMax(maxIndex);
                }
            }
            else
            {
                if (Comparer.Compare(heap[maxIndex], heap[index]) > 0)
                {
                    SwapNodes(maxIndex, index);
                }
            }
        }

        private void PushDownMin(int index)
        {
            if (!HasChild(index))
            {
                return;
            }

            var minIndex = IndexOfMinChildOrGrandchild(index);

            
            
            if (IsGrandchild(index, minIndex))
            {
                if (Comparer.Compare(heap[minIndex], heap[index]) < 0)
                {
                    SwapNodes(minIndex, index);
                    if (Comparer.Compare(heap[minIndex], heap[Parent(minIndex)]) > 0)
                    {
                        SwapNodes(minIndex, Parent(minIndex));
                    }

                    PushDownMin(minIndex);
                }
            }
            else
            {
                if (Comparer.Compare(heap[minIndex], heap[index]) < 0)
                {
                    SwapNodes(minIndex, index);
                }
            }
        }

        
        
        
        
        
        
        
        
        private void PushUp(int index)
        {
            if (index == 0)
            {
                return;
            }

            var parent = Parent(index);

            if (IsMinLevelIndex(index))
            {
                if (Comparer.Compare(heap[index], heap[parent]) > 0)
                {
                    SwapNodes(index, parent);
                    PushUpMax(parent);
                }
                else
                {
                    PushUpMin(index);
                }
            }
            else
            {
                if (Comparer.Compare(heap[index], heap[parent]) < 0)
                {
                    SwapNodes(index, parent);
                    PushUpMin(parent);
                }
                else
                {
                    PushUpMax(index);
                }
            }
        }

        private void PushUpMax(int index)
        {
            if (index > 2)
            {
                var grandparent = Grandparent(index);
                if (Comparer.Compare(heap[index], heap[grandparent]) > 0)
                {
                    SwapNodes(index, grandparent);
                    PushUpMax(grandparent);
                }
            }
        }

        private void PushUpMin(int index)
        {
            if (index > 2)
            {
                var grandparent = Grandparent(index);
                if (Comparer.Compare(heap[index], heap[grandparent]) < 0)
                {
                    SwapNodes(index, grandparent);
                    PushUpMin(grandparent);
                }
            }
        }

        private void RemoveNode(int index)
        {
            SwapNodes(index, Count - 1);
            heap.RemoveAt(Count - 1);
            if (Count != 0)
            {
                PushDown(index);
            }
        }

        private void SwapNodes(int i, int j)
        {
            var temp = heap[i];
            heap[i] = heap[j];
            heap[j] = temp;
        }
    }
}
﻿using System;
using System.Collections.Generic;

namespace DataStructures.Heap
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    public class BinaryHeap<T>
    {
        
        
        
        private readonly Comparer<T> comparer;

        
        
        
        private readonly List<T> data;

        
        
        
        public BinaryHeap()
        {
            data = new List<T>();
            comparer = Comparer<T>.Default;
        }

        
        
        
        
        public BinaryHeap(Comparer<T> customComparer)
        {
            data = new List<T>();
            comparer = customComparer;
        }

        
        
        
        public int Count => data.Count;

        
        
        
        
        
        
        
        
        
        public void Push(T element)
        {
            data.Add(element);
            HeapifyUp(data.Count - 1);
        }

        
        
        
        
        
        
        
        
        
        
        public T Pop()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty!");
            }

            var elem = data[0];
            data[0] = data[^1];
            data.RemoveAt(data.Count - 1);
            HeapifyDown(0);

            return elem;
        }

        
        
        
        
        
        public T Peek()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Heap is empty!");
            }

            return data[0];
        }

        
        
        
        
        
        
        public T PushPop(T element)
        {
            if (Count == 0)
            {
                return element;
            }

            if (comparer.Compare(element, data[0]) < 0)
            {
                var tmp = data[0];
                data[0] = element;
                HeapifyDown(0);
                return tmp;
            }

            return element;
        }

        
        
        
        
        
        public bool Contains(T element) => data.Contains(element);

        
        
        
        
        
        
        
        
        
        
        public void Remove(T element)
        {
            var idx = data.IndexOf(element);

            if (idx == -1)
            {
                throw new ArgumentException($"{element} not in heap!");
            }

            Swap(idx, data.Count - 1);
            var tmp = data[^1];
            data.RemoveAt(data.Count - 1);

            if (idx < data.Count)
            {
                if (comparer.Compare(tmp, data[idx]) > 0)
                {
                    HeapifyDown(idx);
                }
                else
                {
                    HeapifyUp(idx);
                }
            }
        }

        
        
        
        
        
        private void Swap(int idx1, int idx2)
        {
            var tmp = data[idx1];
            data[idx1] = data[idx2];
            data[idx2] = tmp;
        }

        
        
        
        
        
        
        
        
        private void HeapifyUp(int elemIdx)
        {
            var parent = (elemIdx - 1) / 2;

            if (parent >= 0 && comparer.Compare(data[elemIdx], data[parent]) > 0)
            {
                Swap(elemIdx, parent);
                HeapifyUp(parent);
            }
        }

        
        
        
        
        
        
        
        
        private void HeapifyDown(int elemIdx)
        {
            var left = 2 * elemIdx + 1;
            var right = 2 * elemIdx + 2;

            var leftLargerThanElem = left < Count && comparer.Compare(data[elemIdx], data[left]) < 0;
            var rightLargerThanElem = right < Count && comparer.Compare(data[elemIdx], data[right]) < 0;
            var leftLargerThanRight = left < Count && right < Count && comparer.Compare(data[left], data[right]) > 0;

            if (leftLargerThanElem && leftLargerThanRight)
            {
                Swap(elemIdx, left);
                HeapifyDown(left);
            }
            else if (rightLargerThanElem && !leftLargerThanRight)
            {
                Swap(elemIdx, right);
                HeapifyDown(right);
            }
        }
    }
}
using System;

namespace DataStructures.Queue
{
    
    
    
    
    public class ArrayBasedQueue<T>
    {
        private readonly T[] queue;
        private int endIndex;
        private bool isEmpty;
        private bool isFull;
        private int startIndex;

        
        
        
        public ArrayBasedQueue(int capacity)
        {
            queue = new T[capacity];
            Clear();
        }

        
        
        
        public void Clear()
        {
            startIndex = 0;
            endIndex = 0;
            isEmpty = true;
            isFull = false;
        }

        
        
        
        
        public T Dequeue()
        {
            if (IsEmpty())
            {
                throw new InvalidOperationException("There are no items in the queue.");
            }

            var dequeueIndex = endIndex;
            endIndex++;
            if (endIndex >= queue.Length)
            {
                endIndex = 0;
            }

            isFull = false;
            isEmpty = startIndex == endIndex;

            return queue[dequeueIndex];
        }

        
        
        
        public bool IsEmpty() => isEmpty;

        
        
        
        public bool IsFull() => isFull;

        
        
        
        
        public T Peek()
        {
            if (IsEmpty())
            {
                throw new InvalidOperationException("There are no items in the queue.");
            }

            return queue[endIndex];
        }

        
        
        
        
        public void Enqueue(T item)
        {
            if (IsFull())
            {
                throw new InvalidOperationException("The queue has reached its capacity.");
            }

            queue[startIndex] = item;

            startIndex++;
            if (startIndex >= queue.Length)
            {
                startIndex = 0;
            }

            isEmpty = false;
            isFull = startIndex == endIndex;
        }
    }
}
﻿using System;
using System.Collections.Generic;

namespace DataStructures.Queue
{
    
    
    
    
    
    
    
    public class StackBasedQueue<T>
    {
        private readonly Stack<T> input;
        private readonly Stack<T> output;

        
        
        
        public StackBasedQueue()
        {
            input = new Stack<T>();
            output = new Stack<T>();
        }

        
        
        
        public void Clear()
        {
            input.Clear();
            output.Clear();
        }

        
        
        
        
        public T Dequeue()
        {
            if (input.Count == 0 && output.Count == 0)
            {
                throw new InvalidOperationException("The queue contains no items.");
            }

            if (output.Count == 0)
            {
                while (input.Count > 0)
                {
                    var item = input.Pop();
                    output.Push(item);
                }
            }

            return output.Pop();
        }

        
        
        
        public bool IsEmpty() => input.Count == 0 && output.Count == 0;

        
        
        
        public bool IsFull() => false;

        
        
        
        
        public T Peek()
        {
            if (input.Count == 0 && output.Count == 0)
            {
                throw new InvalidOperationException("The queue contains no items.");
            }

            if (output.Count == 0)
            {
                while (input.Count > 0)
                {
                    var item = input.Pop();
                    output.Push(item);
                }
            }

            return output.Peek();
        }

        
        
        
        public void Enqueue(T item) => input.Push(item);
    }
}
using System;
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Queue
{
    
    
    
    
    public class ListBasedQueue<T>
    {
        private readonly LinkedList<T> queue;

        
        
        
        public ListBasedQueue() => queue = new LinkedList<T>();

        
        
        
        public void Clear()
        {
            queue.Clear();
        }

        
        
        
        
        public T Dequeue()
        {
            if (queue.First is null)
            {
                throw new InvalidOperationException("There are no items in the queue.");
            }

            var item = queue.First;
            queue.RemoveFirst();
            return item.Value;
        }

        
        
        
        public bool IsEmpty() => !queue.Any();

        
        
        
        public bool IsFull() => false;

        
        
        
        
        public T Peek()
        {
            if (queue.First is null)
            {
                throw new InvalidOperationException("There are no items in the queue.");
            }

            return queue.First.Value;
        }

        
        
        
        
        public void Enqueue(T item)
        {
            queue.AddLast(item);
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.Tries
{
    
    
    
    
    
    
    public class Trie
    {
        
        
        
        private const char Mark = '$';

        
        
        
        private readonly TrieNode root;

        
        
        
        public Trie()
        {
            root = new TrieNode(Mark);
        }

        
        
        
        
        public Trie(IEnumerable<string> words)
            : this()
        {
            foreach (string s in words)
            {
                Insert(s);
            }
        }

        
        
        
        
        public void Insert(string s)
        {
            s += Mark;

            int index = 0;
            TrieNode match = PrefixQuery(s, ref index);

            for (int i = index; i < s.Length; i++)
            {
                TrieNode t = new(s[i], match);
                match[s[i]] = t;
                match = t;
            }
        }

        
        
        
        
        public void Remove(string s)
        {
            s += Mark;
            int index = 0;
            TrieNode match = PrefixQuery(s, ref index);
            while(match.IsLeaf())
            {
                char c = match.Value;
                if(match.Parent == null)
                {
                    break;
                }

                match = match.Parent;
                match.Children.Remove(c);
            }
        }

        
        
        
        
        
        public bool Find(string s)
        {
            int index = 0;
            return PrefixQuery(s + Mark, ref index).IsLeaf();
        }

        
        
        
        
        
        
        
        
        private TrieNode PrefixQuery(string s, ref int index)
        {
            TrieNode current = root;
            for (int i = 0; i < s.Length && current != null; i++)
            {
                if (current[s[i]] != null)
                {
                    current = current[s[i]] ?? throw new NullReferenceException();
                    index = i + 1;
                }
                else
                {
                    break;
                }
            }

            return current ?? throw new NullReferenceException();
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.Tries
{
    
    
    
    internal class TrieNode
    {
        
        
        
        
        internal TrieNode(char value)
            : this(value, null)
        {
        }

        
        
        
        
        
        internal TrieNode(char value, TrieNode? parent)
        {
            Children = new SortedList<char, TrieNode>();
            Parent = parent;
            Value = value;
        }

        
        
        
        
        internal SortedList<char, TrieNode> Children { get; private set; }

        
        
        
        
        internal TrieNode? Parent { get; private set; }

        
        
        
        
        internal char Value { get; private set; }

        
        
        
        
        public TrieNode? this[char c]
        {
            get => Children.ContainsKey(c) ? Children[c] : null;
            set => Children[c] = value ?? throw new NullReferenceException();
        }

        
        
        
        
        public bool IsLeaf()
        {
            return Children.Count == 0;
        }
    }
}
﻿using System;
using System.Collections.Generic;

namespace DataStructures.Stack
{
    
    
    
    
    public class ListBasedStack<T>
    {
        
        
        
        private readonly LinkedList<T> stack;

        
        
        
        public ListBasedStack() => stack = new LinkedList<T>();

        
        
        
        
        public ListBasedStack(T item)
            : this() => Push(item);

        
        
        
        
        public ListBasedStack(IEnumerable<T> items)
            : this()
        {
            foreach (var item in items)
            {
                Push(item);
            }
        }

        
        
        
        public int Count => stack.Count;

        
        
        
        public void Clear() => stack.Clear();

        
        
        
        
        
        public bool Contains(T item) => stack.Contains(item);

        
        
        
        
        public T Peek()
        {
            if (stack.First is null)
            {
                throw new InvalidOperationException("Stack is empty");
            }

            return stack.First.Value;
        }

        
        
        
        
        public T Pop()
        {
            if (stack.First is null)
            {
                throw new InvalidOperationException("Stack is empty");
            }

            var item = stack.First.Value;
            stack.RemoveFirst();
            return item;
        }

        
        
        
        
        public void Push(T item) => stack.AddFirst(item);
    }
}
﻿using System;
using System.Collections.Generic;

namespace DataStructures.Stack
{
    
    
    
    
    public class ArrayBasedStack<T>
    {
        private const int DefaultCapacity = 10;
        private const string StackEmptyErrorMessage = "Stack is empty";

        
        
        
        private T[] stack;

        
        
        
        private int top;

        
        
        
        public ArrayBasedStack()
        {
            stack = new T[DefaultCapacity];
            top = -1;
        }

        
        
        
        
        public ArrayBasedStack(T item)
            : this() => Push(item);

        
        
        
        
        public ArrayBasedStack(IEnumerable<T> items)
            : this()
        {
            foreach (var item in items)
            {
                Push(item);
            }
        }

        
        
        
        public int Top => top;

        
        
        
        public int Capacity
        {
            get => stack.Length;
            set => Array.Resize(ref stack, value);
        }

        
        
        
        public void Clear()
        {
            top = -1;
            Capacity = DefaultCapacity;
        }

        
        
        
        
        
        public bool Contains(T item) => Array.IndexOf(stack, item, 0, top + 1) > -1;

        
        
        
        
        public T Peek()
        {
            if (top == -1)
            {
                throw new InvalidOperationException(StackEmptyErrorMessage);
            }

            return stack[top];
        }

        
        
        
        
        public T Pop()
        {
            if (top == -1)
            {
                throw new InvalidOperationException(StackEmptyErrorMessage);
            }

            return stack[top--];
        }

        
        
        
        
        public void Push(T item)
        {
            if (top == Capacity - 1)
            {
                Capacity *= 2;
            }

            stack[++top] = item;
        }
    }
}
using System.Collections.Generic;
using System.Linq;

namespace DataStructures.Fenwick
{
    
    
    
    
    
    
    public class BinaryIndexedTree
    {
        private readonly int[] fenwickTree;

        
        
        
        
        
        public BinaryIndexedTree(int[] array)
        {
            fenwickTree = new int[array.Length + 1];

            for (var i = 0; i < array.Length; i++)
            {
                UpdateTree(i, array[i]);
            }
        }

        
        
        
        
        
        
        public int GetSum(int index)
        {
            var sum = 0;
            var startFrom = index + 1;

            while (startFrom > 0)
            {
                sum += fenwickTree[startFrom];
                startFrom -= startFrom & (-startFrom);
            }

            return sum;
        }

        
        
        
        
        
        
        public void UpdateTree(int index, int val)
        {
            var startFrom = index + 1;

            while (startFrom <= fenwickTree.Length)
            {
                fenwickTree[startFrom] += val;
                startFrom += startFrom & (-startFrom);
            }
        }
    }
}
﻿using System;

namespace DataStructures.UnrolledList
{
    
    
    
    public class UnrolledLinkedListNode
    {
        private readonly int[] array;

        public UnrolledLinkedListNode(int nodeSize)
        {
            Next = null!;

            Count = 0;
            array = new int[nodeSize];
        }

        public UnrolledLinkedListNode Next { get; set; }

        public int Count { get; set; }

        
        
        
        
        
        
        public void Set(int pos, int val)
        {
            if (pos < 0 || pos > array.Length - 1)
            {
                throw new ArgumentException("Position is out of size", nameof(pos));
            }

            array[pos] = val;
            Count++;
        }

        
        
        
        
        
        public int Get(int pos)
        {
            if (pos < 0 || pos > array.Length - 1)
            {
                throw new ArgumentException("Position is out of size", nameof(pos));
            }

            return array[pos];
        }
    }
}
﻿using System.Collections.Generic;

namespace DataStructures.UnrolledList
{
    
    
    
    
    
    public class UnrolledLinkedList
    {
        private readonly int sizeNode;

        private UnrolledLinkedListNode start = null!;
        private UnrolledLinkedListNode end = null!;

        
        
        
        
        
        public UnrolledLinkedList(int chunkSize)
        {
            sizeNode = chunkSize + 1;
        }

        
        
        
        
        public void Insert(int value)
        {
            if (start == null)
            {
                start = new UnrolledLinkedListNode(sizeNode);
                start.Set(0, value);

                end = start;
                return;
            }

            if (end.Count + 1 < sizeNode)
            {
                end.Set(end.Count, value);
            }
            else
            {
                var pointer = new UnrolledLinkedListNode(sizeNode);
                var j = 0;
                for (var pos = end.Count / 2 + 1; pos < end.Count; pos++)
                {
                    pointer.Set(j++, end.Get(pos));
                }

                pointer.Set(j++, value);
                pointer.Count = j;

                end.Count = end.Count / 2 + 1;
                end.Next = pointer;
                end = pointer;
            }
        }

        
        
        
        
        public IEnumerable<int> GetRolledItems()
        {
            UnrolledLinkedListNode pointer = start;
            List<int> result = new();

            while (pointer != null)
            {
                for (var i = 0; i < pointer.Count; i++)
                {
                    result.Add(pointer.Get(i));
                }

                pointer = pointer.Next;
            }

            return result;
        }
    }
}
using System;

namespace DataStructures.ScapegoatTree
{
    
    
    
    
    public class Node<TKey> where TKey : IComparable
    {
        private Node<TKey>? right;
        private Node<TKey>? left;

        public TKey Key { get; }

        public Node<TKey>? Right
        {
            get => right;
            set
            {
                if (value != null && !value.IsGreaterThanOrSameAs(Key))
                {
                    throw new ArgumentException("The value's key is smaller than or equal to node's right child's key.", nameof(value));
                }

                right = value;
            }
        }

        public Node<TKey>? Left
        {
            get => left;
            set
            {
                if (value != null && value.IsGreaterThanOrSameAs(Key))
                {
                    throw new ArgumentException("The value's key is greater than or equal to node's left child's key.", nameof(value));
                }

                left = value;
            }
        }

        public Node(TKey key) => Key = key;

        public Node(TKey key, Node<TKey>? right, Node<TKey>? left)
            : this(key)
        {
            Right = right;
            Left = left;
        }

        
        
        
        
        public int GetSize() => (Left?.GetSize() ?? 0) + 1 + (Right?.GetSize() ?? 0);

        
        
        
        
        
        public double GetAlphaHeight(double alpha) => Math.Floor(Math.Log(GetSize(), 1.0 / alpha));

        public Node<TKey> GetSmallestKeyNode() => Left?.GetSmallestKeyNode() ?? this;

        public Node<TKey> GetLargestKeyNode() => Right?.GetLargestKeyNode() ?? this;

        
        
        
        
        
        public bool IsAlphaWeightBalanced(double a)
        {
            var isLeftBalanced = (Left?.GetSize() ?? 0) <= a * GetSize();
            var isRightBalanced = (Right?.GetSize() ?? 0) <= a * GetSize();

            return isLeftBalanced && isRightBalanced;
        }

        private bool IsGreaterThanOrSameAs(TKey key)
        {
            return Key.CompareTo(key) >= 0;
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.ScapegoatTree
{
    public static class Extensions
    {
        
        
        
        
        
        
        public static void FlattenTree<TKey>(Node<TKey> root, List<Node<TKey>> list) where TKey : IComparable
        {
            if (root.Left != null)
            {
                FlattenTree(root.Left, list);
            }

            list.Add(root);

            if (root.Right != null)
            {
                FlattenTree(root.Right, list);
            }
        }

        
        
        
        
        
        
        
        
        
        
        public static Node<TKey> RebuildFromList<TKey>(IList<Node<TKey>> list, int start, int end)
            where TKey : IComparable
        {
            if (start > end)
            {
                throw new ArgumentException("The parameter's value is invalid.", nameof(start));
            }

            var pivot = Convert.ToInt32(Math.Ceiling(start + (end - start) / 2.0));

            return new Node<TKey>(list[pivot].Key)
            {
                Left = start > (pivot - 1) ? null : RebuildFromList(list, start, pivot - 1),
                Right = (pivot + 1) > end ? null : RebuildFromList(list, pivot + 1, end),
            };
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.ScapegoatTree
{
    
    
    
    
    
    public class ScapegoatTree<TKey> where TKey : IComparable
    {
        
        
        
        public double Alpha { get; private set; }

        
        
        
        public Node<TKey>? Root { get; private set; }

        
        
        
        public int Size { get; private set; }

        
        
        
        public int MaxSize { get; private set; }

        
        
        
        public event EventHandler? TreeIsUnbalanced;

        public ScapegoatTree()
            : this(alpha: 0.5, size: 0)
        {
        }

        public ScapegoatTree(double alpha)
            : this(alpha, size: 0)
        {
        }

        public ScapegoatTree(Node<TKey> node, double alpha)
            : this(alpha, size: node.GetSize())
        {
            Root = node;
        }

        public ScapegoatTree(TKey key, double alpha = 0.5)
            : this(alpha, size: 1)
        {
            Root = new Node<TKey>(key);
        }

        private ScapegoatTree(double alpha, int size)
        {
            CheckAlpha(alpha);

            Alpha = alpha;

            Size = size;
            MaxSize = size;
        }

        
        
        
        
        public bool IsAlphaWeightBalanced()
        {
            return Root?.IsAlphaWeightBalanced(Alpha) ?? true;
        }

        
        
        
        
        
        public bool Contains(TKey key)
        {
            return Search(key) != null;
        }

        
        
        
        
        
        public Node<TKey>? Search(TKey key)
        {
            if (Root == null)
            {
                return null;
            }

            var current = Root;

            while (true)
            {
                var result = current.Key.CompareTo(key);

                switch (result)
                {
                    case 0:
                        return current;
                    case > 0 when current.Left != null:
                        current = current.Left;
                        break;
                    case < 0 when current.Right != null:
                        current = current.Right;
                        break;
                    default:
                        return null;
                }
            }
        }

        
        
        
        
        
        public bool Insert(TKey key)
        {
            var node = new Node<TKey>(key);

            if (Root == null)
            {
                Root = node;

                UpdateSizes();

                return true;
            }

            var path = new Stack<Node<TKey>>();

            var current = Root;

            var found = false;

            while (!found)
            {
                path.Push(current);

                var result = current.Key.CompareTo(node.Key);

                switch (result)
                {
                    case < 0 when current.Right != null:
                        current = current.Right;
                        continue;
                    case < 0:
                        current.Right = node;
                        found = true;
                        break;
                    case > 0 when current.Left != null:
                        current = current.Left;
                        continue;
                    case > 0:
                        current.Left = node;
                        found = true;
                        break;
                    default:
                        return false;
                }
            }

            UpdateSizes();

            if (path.Count > Root.GetAlphaHeight(Alpha))
            {
                TreeIsUnbalanced?.Invoke(this, EventArgs.Empty);

                BalanceFromPath(path);

                MaxSize = Math.Max(MaxSize, Size);
            }

            return true;
        }

        
        
        
        
        
        public bool Delete(TKey key)
        {
            if (Root == null)
            {
                return false;
            }

            if (Remove(Root, Root, key))
            {
                Size--;

                if (Root != null && Size < Alpha * MaxSize)
                {
                    TreeIsUnbalanced?.Invoke(this, EventArgs.Empty);

                    var list = new List<Node<TKey>>();

                    Extensions.FlattenTree(Root, list);

                    Root = Extensions.RebuildFromList(list, 0, list.Count - 1);

                    MaxSize = Size;
                }

                return true;
            }

            return false;
        }

        
        
        
        public void Clear()
        {
            Size = 0;
            MaxSize = 0;
            Root = null;
        }

        
        
        
        
        public void Tune(double value)
        {
            CheckAlpha(value);
            Alpha = value;
        }

        
        
        
        
        
        
        
        public (Node<TKey>? parent, Node<TKey> scapegoat) FindScapegoatInPath(Stack<Node<TKey>> path)
        {
            if (path.Count == 0)
            {
                throw new ArgumentException("The path collection should not be empty.", nameof(path));
            }

            var depth = 1;

            while (path.TryPop(out var next))
            {
                if (depth > next.GetAlphaHeight(Alpha))
                {
                    return path.TryPop(out var parent) ? (parent, next) : (null, next);
                }

                depth++;
            }

            throw new InvalidOperationException("Scapegoat node wasn't found. The tree should be unbalanced.");
        }

        private static void CheckAlpha(double alpha)
        {
            if (alpha is < 0.5 or > 1.0)
            {
                throw new ArgumentException("The alpha parameter's value should be in 0.5..1.0 range.", nameof(alpha));
            }
        }

        private bool Remove(Node<TKey>? parent, Node<TKey>? node, TKey key)
        {
            if (node is null || parent is null)
            {
                return false;
            }

            var compareResult = node.Key.CompareTo(key);

            if (compareResult > 0)
            {
                return Remove(node, node.Left, key);
            }

            if (compareResult < 0)
            {
                return Remove(node, node.Right, key);
            }

            Node<TKey>? replacementNode;

            
            
            if (node.Left is null || node.Right is null)
            {
                replacementNode = node.Left ?? node.Right;
            }

            
            else
            {
                var predecessorNode = node.Left.GetLargestKeyNode();
                Remove(Root, Root, predecessorNode.Key);
                replacementNode = new Node<TKey>(predecessorNode.Key)
                {
                    Left = node.Left,
                    Right = node.Right,
                };
            }

            
            
            if (node == Root)
            {
                Root = replacementNode;
            }
            else if (parent.Left == node)
            {
                parent.Left = replacementNode;
            }
            else
            {
                parent.Right = replacementNode;
            }

            return true;
        }

        private void BalanceFromPath(Stack<Node<TKey>> path)
        {
            var (parent, scapegoat) = FindScapegoatInPath(path);

            var list = new List<Node<TKey>>();

            Extensions.FlattenTree(scapegoat, list);

            var tree = Extensions.RebuildFromList(list, 0, list.Count - 1);

            if (parent == null)
            {
                Root = tree;
            }
            else
            {
                var result = parent.Key.CompareTo(tree.Key);

                if (result < 0)
                {
                    parent.Right = tree;
                }
                else
                {
                    parent.Left = tree;
                }
            }
        }

        private void UpdateSizes()
        {
            Size += 1;
            MaxSize = Math.Max(Size, MaxSize);
        }
    }
}
using System;
using System.Collections.Generic;

namespace DataStructures.AVLTree
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public class AvlTree<TKey>
    {
        
        
        
        public int Count { get; private set; }

        
        
        
        private readonly Comparer<TKey> comparer;

        
        
        
        private AvlTreeNode<TKey>? root;

        
        
        
        public AvlTree()
        {
            comparer = Comparer<TKey>.Default;
        }

        
        
        
        
        
        public AvlTree(Comparer<TKey> customComparer)
        {
            comparer = customComparer;
        }

        
        
        
        
        public void Add(TKey key)
        {
            if (root is null)
            {
                root = new AvlTreeNode<TKey>(key);
            }
            else
            {
                root = Add(root, key);
            }

            Count++;
        }

        
        
        
        
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach(var key in keys)
            {
                Add(key);
            }
        }

        
        
        
        
        public void Remove(TKey key)
        {
            if (root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }
            else if (!Contains(key))
            {
                throw new KeyNotFoundException($"Key {key} is not in the tree");
            }
            else
            {
                root = Remove(root, key);
                Count--;
            }
        }

        
        
        
        
        
        public bool Contains(TKey key)
        {
            var node = root;
            while (node is not null)
            {
                var compareResult = comparer.Compare(key, node.Key);
                if (compareResult < 0)
                {
                    node = node.Left;
                }
                else if (compareResult > 0)
                {
                    node = node.Right;
                }
                else
                {
                    return true;
                }
            }

            return false;
        }

        
        
        
        
        public TKey GetMin()
        {
            if(root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMin(root).Key;
        }

        
        
        
        
        public TKey GetMax()
        {
            if(root is null)
            {
                throw new InvalidOperationException("Tree is empty!");
            }

            return GetMax(root).Key;
        }

        
        
        
        
        public IEnumerable<TKey> GetKeysInOrder()
        {
            List<TKey> result = new();
            InOrderWalk(root);
            return result;

            void InOrderWalk(AvlTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                InOrderWalk(node.Left);
                result.Add(node.Key);
                InOrderWalk(node.Right);
            }
        }

        
        
        
        
        public IEnumerable<TKey> GetKeysPreOrder()
        {
            var result = new List<TKey>();
            PreOrderWalk(root);
            return result;

            void PreOrderWalk(AvlTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                result.Add(node.Key);
                PreOrderWalk(node.Left);
                PreOrderWalk(node.Right);
            }
        }

        
        
        
        
        public IEnumerable<TKey> GetKeysPostOrder()
        {
            var result = new List<TKey>();
            PostOrderWalk(root);
            return result;

            void PostOrderWalk(AvlTreeNode<TKey>? node)
            {
                if (node is null)
                {
                    return;
                }

                PostOrderWalk(node.Left);
                PostOrderWalk(node.Right);
                result.Add(node.Key);
            }
        }

        
        
        
        
        
        
        private AvlTreeNode<TKey> Add(AvlTreeNode<TKey> node, TKey key)
        {
            
            int compareResult = comparer.Compare(key, node.Key);
            if (compareResult < 0)
            {
                if (node.Left is null)
                {
                    var newNode = new AvlTreeNode<TKey>(key);
                    node.Left = newNode;
                }
                else
                {
                    node.Left = Add(node.Left, key);
                }
            }
            else if (compareResult > 0)
            {
                if (node.Right is null)
                {
                    var newNode = new AvlTreeNode<TKey>(key);
                    node.Right = newNode;
                }
                else
                {
                    node.Right = Add(node.Right, key);
                }
            }
            else
            {
                throw new ArgumentException($"Key \"{key}\" already exists in tree!");
            }

            
            
            node.UpdateBalanceFactor();

            return Rebalance(node);
        }

        
        
        
        
        
        
        private AvlTreeNode<TKey>? Remove(AvlTreeNode<TKey> node, TKey key)
        {
            
            var compareResult = comparer.Compare(key, node.Key);
            if (compareResult < 0)
            {
                node.Left = Remove(node.Left!, key);
            }
            else if (compareResult > 0)
            {
                node.Right = Remove(node.Right!, key);
            }
            else
            {
                if (node.Left is null && node.Right is null)
                {
                    return null;
                }
                else if (node.Left is null)
                {
                    var successor = GetMin(node.Right!);
                    node.Right = Remove(node.Right!, successor.Key);
                    node.Key = successor.Key;
                }
                else
                {
                    var predecessor = GetMax(node.Left!);
                    node.Left = Remove(node.Left!, predecessor.Key);
                    node.Key = predecessor.Key;
                }
            }

            
            
            node.UpdateBalanceFactor();

            return Rebalance(node);
        }

        
        
        
        
        
        
        private AvlTreeNode<TKey> Rebalance(AvlTreeNode<TKey> node)
        {
            if (node.BalanceFactor > 1)
            {
                if (node.Right!.BalanceFactor == -1)
                {
                    node.Right = RotateRight(node.Right);
                }

                return RotateLeft(node);
            }
            else if (node.BalanceFactor < -1)
            {
                if (node.Left!.BalanceFactor == 1)
                {
                    node.Left = RotateLeft(node.Left);
                }

                return RotateRight(node);
            }
            else
            {
                return node;
            }
        }

        
        
        
        
        
        private AvlTreeNode<TKey> RotateLeft(AvlTreeNode<TKey> node)
        {
            var temp1 = node;
            var temp2 = node!.Right!.Left;
            node = node.Right;
            node.Left = temp1;
            node.Left.Right = temp2;

            node.Left.UpdateBalanceFactor();
            node.UpdateBalanceFactor();

            return node;
        }

        
        
        
        
        
        private AvlTreeNode<TKey> RotateRight(AvlTreeNode<TKey> node)
        {
            var temp1 = node;
            var temp2 = node!.Left!.Right;
            node = node.Left;
            node.Right = temp1;
            node.Right.Left = temp2;

            node.Right.UpdateBalanceFactor();
            node.UpdateBalanceFactor();

            return node;
        }

        
        
        
        
        
        
        private AvlTreeNode<TKey> GetMin(AvlTreeNode<TKey> node)
        {
            while (node.Left is not null)
            {
                node = node.Left;
            }

            return node;
        }

        
        
        
        
        
        
        private AvlTreeNode<TKey> GetMax(AvlTreeNode<TKey> node)
        {
            while (node.Right is not null)
            {
                node = node.Right;
            }

            return node;
        }
    }
}
using System;

namespace DataStructures.AVLTree
{
    
    
    
    
    public class AvlTreeNode<TKey>
    {
        
        
        
        public TKey Key { get; set; }

        
        
        
        public int Height { get; private set; }

        
        
        
        public int BalanceFactor { get; private set; }

        
        
        
        public AvlTreeNode<TKey>? Left { get; set; }

        
        
        
        public AvlTreeNode<TKey>? Right { get; set; }

        
        
        
        
        public AvlTreeNode(TKey key)
        {
            Key = key;
        }

        
        
        
        public void UpdateBalanceFactor()
        {
            if(Left is null && Right is null)
            {
                Height = 0;
                BalanceFactor = 0;
            }
            else if(Left is null)
            {
                Height = Right!.Height + 1;
                BalanceFactor = Height;
            }
            else if(Right is null)
            {
                Height = Left!.Height + 1;
                BalanceFactor = -Height;
            }
            else
            {
                Height = Math.Max(Left.Height, Right.Height) + 1;
                BalanceFactor = Right.Height - Left.Height;
            }
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Strings
{
    public class KnuthMorrisPrattSearcher
    {
        
        
        
        
        
        
        
        
        
        
        public IEnumerable<int> FindIndexes(string str, string pat)
        {
            var lps = FindLongestPrefixSuffixValues(pat);

            for (int i = 0, j = 0; i < str.Length;)
            {
                if (pat[j] == str[i])
                {
                    j++;
                    i++;
                }

                if (j == pat.Length)
                {
                    yield return i - j;
                    j = lps[j - 1];
                    continue;
                }

                if (i < str.Length && pat[j] != str[i])
                {
                    if (j != 0)
                    {
                        j = lps[j - 1];
                    }
                    else
                    {
                        i += 1;
                    }
                }
            }
        }

        
        
        
        
        
        public int[] FindLongestPrefixSuffixValues(string pat)
        {
            var lps = new int[pat.Length];
            for (int i = 1, len = 0; i < pat.Length;)
            {
                if (pat[i] == pat[len])
                {
                    len++;
                    lps[i] = len;
                    i++;
                    continue;
                }

                if (len != 0)
                {
                    len = lps[len - 1];
                }
                else
                {
                    lps[i] = 0;
                    i++;
                }
            }

            return lps;
        }
    }
}
using System;

namespace Algorithms.Strings
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public static class BoyerMoore
    {
        
        
        
        
        
        
        public static int FindFirstOccurrence(string t, string p)
        {
            
            var m = p.Length;

            
            var n = t.Length;

            
            
            int[] badChar = BadCharacterRule(p, m);

            
            
            int[] goodSuffix = GoodSuffixRule(p, m);

            
            var i = 0;

            
            int j;

            while (i <= n - m)
            {
                
                j = m - 1;

                
                while (j >= 0 && p[j] == t[i + j])
                {
                    j--;
                }

                
                if (j < 0)
                {
                    return i;
                }

                
                
                i += Math.Max(goodSuffix[j + 1], j - badChar[t[i + j]]);
            }

            
            return -1;
        }

        
        
        
        
        
        
        
        private static int[] BadCharacterRule(string p, int m)
        {
            
            int[] badChar = new int[256];
            Array.Fill(badChar, -1);

            
            for (var j = 0; j < m; j++)
            {
                badChar[p[j]] = j;
            }

            return badChar;
        }

        
        
        
        
        
        
        
        private static int[] GoodSuffixRule(string p, int m)
        {
            
            
            

            
            int[] f = new int[p.Length + 1];

            
            f[m] = m + 1;

            
            int[] s = new int[p.Length + 1];

            
            
            var i = m;

            
            var j = m + 1;

            while (i > 0)
            {
                
                while (j <= m && p[i - 1] != p[j - 1])
                {
                    if (s[j] == 0)
                    {
                        s[j] = j - i;
                    }

                    j = f[j];
                }

                --i;
                --j;
                f[i] = j;
            }

            
            
            
            j = f[0];
            for (i = 0; i <= m; i++)
            {
                
                if (s[i] == 0)
                {
                    s[i] = j;
                }

                
                if (i == j)
                {
                    j = f[j];
                }
            }

            return s;
        }
    }
}
using System.Collections.Generic;


namespace Algorithms.Strings
{
    
    
    
    public static class NaiveStringSearch
    {
        
        
        
        
        
        
        
        public static int[] NaiveSearch(string content, string pattern)
        {
            var m = pattern.Length;
            var n = content.Length;
            List<int> indices = new();
            for (var e = 0; e <= n - m; e++)
            {
                int j;
                for (j = 0; j < m; j++)
                {
                    if (content[e + j] != pattern[j])
                    {
                        break;
                    }
                }

                if (j == m)
                {
                    indices.Add(e);
                }
            }

            return indices.ToArray();
        }
    }
}
using System;
using System.Text.RegularExpressions;

namespace Algorithms.Strings
{
    
    
    
    public static class Palindrome
    {
        
        
        
        
        
        public static bool IsStringPalindrome(string word) =>
            TypifyString(word).Equals(TypifyString(ReverseString(word)));

        
        private static string TypifyString(string word) =>
            Regex.Replace(word.ToLowerInvariant(), @"\s+", string.Empty);

        private static string ReverseString(string s)
        {
            var arr = s.ToCharArray();
            Array.Reverse(arr);
            return new string(arr);
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Strings
{
    
    
    
    
    
    
    
    
    
    public static class RabinKarp
    {
        
        
        
        
        public static List<int> FindAllOccurrences(string text, string pattern)
        {
            
            const ulong p = 65537;

            
            const ulong m = (ulong)1e9 + 7;

            
            ulong[] pPow = new ulong[Math.Max(pattern.Length, text.Length)];
            pPow[0] = 1;
            for (var i = 1; i < pPow.Length; i++)
            {
                pPow[i] = pPow[i - 1] * p % m;
            }

            
            
            ulong[] hashT = new ulong[text.Length + 1];
            for (var i = 0; i < text.Length; i++)
            {
                hashT[i + 1] = (hashT[i] + text[i] * pPow[i]) % m;
            }

            
            ulong hashS = 0;
            for (var i = 0; i < pattern.Length; i++)
            {
                hashS = (hashS + pattern[i] * pPow[i]) % m;
            }

            
            List<int> occurrences = new();
            for (var i = 0; i + pattern.Length - 1 < text.Length; i++)
            {
                
                
                var currentHash = (hashT[i + pattern.Length] + m - hashT[i]) % m;

                
                if (currentHash == hashS * pPow[i] % m)
                {
                    
                    var j = 0;
                    while (j < pattern.Length && text[i + j] == pattern[j])
                    {
                        ++j;
                    }

                    if (j == pattern.Length)
                    {
                        
                        
                        occurrences.Add(i);
                    }
                }
            }

            return occurrences;
        }
    }
}
using System;

namespace Algorithms.Strings
{
    
    
    
    public static class GeneralStringAlgorithms
    {
        
        
        
        
        
        public static Tuple<char, int> FindLongestConsecutiveCharacters(string input)
        {
            var maxChar = input[0];

            var max = 1;
            var current = 1;

            for (var i = 1; i < input.Length; i++)
            {
                if (input[i] == input[i - 1])
                {
                    current++;
                    if (current > max)
                    {
                        max = current;
                        maxChar = input[i];
                    }
                }
                else
                {
                    current = 1;
                }
            }

            return new Tuple<char, int>(maxChar, max);
        }
    }
}
﻿using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Strings
{
    public static class Permutation
    {
        
        
        
        
        public static List<string> GetEveryUniquePermutation(string word)
        {
            if (word.Length < 2)
            {
                return new List<string>
                {
                    word,
                };
            }

            var result = new HashSet<string>();

            for (var i = 0; i < word.Length; i++)
            {
                var temp = GetEveryUniquePermutation(word.Remove(i, 1));

                result.UnionWith(temp.Select(subPerm => word[i] + subPerm));
            }

            return result.ToList();
        }
    }
}
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
    <CodeAnalysisRuleSet>..\stylecop.ruleset</CodeAnalysisRuleSet>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DocumentationFile>./bin/Algorithms.xml</DocumentationFile>
  </PropertyGroup>

  <ItemGroup>
    <AdditionalFiles Include="..\stylecop.json" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="StyleCop.Analyzers" Version="1.1.118">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="System.Drawing.Common" Version="5.0.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\DataStructures\DataStructures.csproj" />
    <ProjectReference Include="..\Utilities\Utilities.csproj" />
  </ItemGroup>

</Project>
namespace Algorithms.Knapsack
{
    public class BranchAndBoundNode
    {
        
        public bool IsTaken { get; }

        
        public int CumulativeWeight { get; set; }

        
        public double CumulativeValue { get; set; }

        
        public double UpperBound { get; set; }

        
        public int Level { get; }

        
        public BranchAndBoundNode? Parent { get; }

        public BranchAndBoundNode(int level, bool taken, BranchAndBoundNode? parent = null)
        {
            Level = level;
            IsTaken = taken;
            Parent = parent;
        }
    }
}
﻿using System;

namespace Algorithms.Knapsack
{
    
    
    
    
    
    
    public interface IHeuristicKnapsackSolver<T>
    {
        
        
        
        
        
        
        
        
        
        
        T[] Solve(T[] items, double capacity, Func<T, double> weightSelector, Func<T, double> valueSelector);
    }
}
﻿using System;
using System.Collections.Generic;

namespace Algorithms.Knapsack
{
    
    
    
    
    public class DynamicProgrammingKnapsackSolver<T>
    {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        public T[] Solve(T[] items, int capacity, Func<T, int> weightSelector, Func<T, double> valueSelector)
        {
            var cache = Tabulate(items, weightSelector, valueSelector, capacity);
            return GetOptimalItems(items, weightSelector, cache, capacity);
        }

        private static T[] GetOptimalItems(T[] items, Func<T, int> weightSelector, double[,] cache, int capacity)
        {
            var currentCapacity = capacity;

            var result = new List<T>();
            for (var i = items.Length - 1; i >= 0; i--)
            {
                if (cache[i + 1, currentCapacity] > cache[i, currentCapacity])
                {
                    var item = items[i];
                    result.Add(item);
                    currentCapacity -= weightSelector(item);
                }
            }

            result.Reverse(); 
            return result.ToArray();
        }

        private static double[,] Tabulate(
            T[] items,
            Func<T, int> weightSelector,
            Func<T, double> valueSelector,
            int maxCapacity)
        {
            
            var n = items.Length;
            var results = new double[n + 1, maxCapacity + 1];
            for (var i = 0; i <= n; i++)
            {
                for (var w = 0; w <= maxCapacity; w++)
                {
                    if (i == 0 || w == 0)
                    {
                        
                        
                        
                        results[i, w] = 0;
                    }
                    else if (weightSelector(items[i - 1]) <= w)
                    {
                        
                        var iut = items[i - 1]; 
                        var vut = valueSelector(iut); 
                        var wut = weightSelector(iut); 
                        var valueIfTaken = vut + results[i - 1, w - wut];
                        var valueIfNotTaken = results[i - 1, w];
                        results[i, w] = Math.Max(valueIfTaken, valueIfNotTaken);
                    }
                    else
                    {
                        
                        results[i, w] = results[i - 1, w];
                    }
                }
            }

            return results;
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Knapsack
{
    
    
    
    
    public class BranchAndBoundKnapsackSolver<T>
    {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        public T[] Solve(T[] items, int capacity, Func<T, int> weightSelector, Func<T, double> valueSelector)
        {
            
            items = items.OrderBy(i => valueSelector(i) / weightSelector(i)).ToArray();

            
            Queue<BranchAndBoundNode> nodesQueue = new();

            
            var maxCumulativeValue = 0.0;

            
            BranchAndBoundNode root = new(level: -1, taken: false);

            
            BranchAndBoundNode lastNodeOfOptimalPath = root;

            nodesQueue.Enqueue(root);

            while (nodesQueue.Count != 0)
            {
                
                BranchAndBoundNode parent = nodesQueue.Dequeue();

                
                if (parent.Level == items.Length - 1)
                {
                    continue;
                }

                
                var left = new BranchAndBoundNode(parent.Level + 1, true, parent);

                
                var right = new BranchAndBoundNode(parent.Level + 1, false, parent);

                
                
                
                left.CumulativeWeight = parent.CumulativeWeight + weightSelector(items[left.Level]);
                left.CumulativeValue = parent.CumulativeValue + valueSelector(items[left.Level]);
                right.CumulativeWeight = parent.CumulativeWeight;
                right.CumulativeValue = parent.CumulativeValue;

                
                
                if (left.CumulativeWeight <= capacity && left.CumulativeValue > maxCumulativeValue)
                {
                    maxCumulativeValue = left.CumulativeValue;
                    lastNodeOfOptimalPath = left;
                }

                left.UpperBound = ComputeUpperBound(left, items, capacity, weightSelector, valueSelector);
                right.UpperBound = ComputeUpperBound(right, items, capacity, weightSelector, valueSelector);

                
                
                
                if (left.UpperBound > maxCumulativeValue && left.CumulativeWeight < capacity)
                {
                    nodesQueue.Enqueue(left);
                }

                
                if (right.UpperBound > maxCumulativeValue)
                {
                    nodesQueue.Enqueue(right);
                }
            }

            return GetItemsFromPath(items, lastNodeOfOptimalPath);
        }

        
        private static T[] GetItemsFromPath(T[] items, BranchAndBoundNode lastNodeOfPath)
        {
            List<T> takenItems = new();

            
            for (var current = lastNodeOfPath; current.Parent is not null; current = current.Parent)
            {
                if(current.IsTaken)
                {
                    takenItems.Add(items[current.Level]);
                }
            }

            return takenItems.ToArray();
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        private static double ComputeUpperBound(BranchAndBoundNode aNode, T[] items, int capacity, Func<T, int> weightSelector, Func<T, double> valueSelector)
        {
            var upperBound = aNode.CumulativeValue;
            var availableWeight = capacity - aNode.CumulativeWeight;
            var nextLevel = aNode.Level + 1;

            while (availableWeight > 0 && nextLevel < items.Length)
            {
                if (weightSelector(items[nextLevel]) <= availableWeight)
                {
                    upperBound += valueSelector(items[nextLevel]);
                    availableWeight -= weightSelector(items[nextLevel]);
                }
                else
                {
                    upperBound += valueSelector(items[nextLevel]) / weightSelector(items[nextLevel]) * availableWeight;
                    availableWeight = 0;
                }

                nextLevel++;
            }

            return upperBound;
        }
    }
}
﻿using System;
using System.Collections.Generic;

namespace Algorithms.Knapsack
{
    
    
    
    
    public class NaiveKnapsackSolver<T> : IHeuristicKnapsackSolver<T>
    {
        
        
        
        
        
        
        
        
        public T[] Solve(T[] items, double capacity, Func<T, double> weightSelector, Func<T, double> valueSelector)
        {
            var weight = 0d;
            var left = new List<T>();

            foreach (var item in items)
            {
                var weightDelta = weightSelector(item);
                if (weight + weightDelta <= capacity)
                {
                    weight += weightDelta;
                    left.Add(item);
                }
            }

            return left.ToArray();
        }
    }
}
﻿namespace Algorithms.Knapsack
{
    
    
    
    
    
    
    public interface IKnapsackSolver<T> : IHeuristicKnapsackSolver<T>
    {
    }
}
using System.Collections.Generic;
using System.Linq;
using DataStructures.Graph;

namespace Algorithms.Graph
{
    
    
    
    
    
    
    public static class Kosaraju<T>
    {
        
        
        
        
        
        
        
        public static void Visit(Vertex<T> v, IDirectedWeightedGraph<T> graph, HashSet<Vertex<T>> visited, Stack<Vertex<T>> reversed)
        {
            if (visited.Contains(v))
            {
                return;
            }

            
            visited.Add(v);

            
            
            
            reversed.Push(v);

            
            foreach (var u in graph.GetNeighbors(v))
            {
                Visit(u!, graph, visited, reversed);
            }
        }

        
        
        
        
        
        
        
        
        
        
        public static void Assign(Vertex<T> v, Vertex<T> root, IDirectedWeightedGraph<T> graph, Dictionary<Vertex<T>, Vertex<T>> roots)
        {
            
            if (roots.ContainsKey(v))
            {
                return;
            }

            
            roots.Add(v, root);

            
            foreach (var u in graph.GetNeighbors(v))
            {
                Assign(u!, root, graph, roots);
            }
        }

        
        
        
        
        
        public static Dictionary<Vertex<T>, Vertex<T>> GetRepresentatives(IDirectedWeightedGraph<T> graph)
        {
            HashSet<Vertex<T>> visited = new HashSet<Vertex<T>>();
            Stack<Vertex<T>> reversedL = new Stack<Vertex<T>>();
            Dictionary<Vertex<T>, Vertex<T>> representatives = new Dictionary<Vertex<T>, Vertex<T>>();

            foreach (var v in graph.Vertices)
            {
                if (v != null)
                {
                    Visit(v, graph, visited, reversedL);
                }
            }

            visited.Clear();

            while (reversedL.Count > 0)
            {
                Vertex<T> v = reversedL.Pop();
                Assign(v, v, graph, representatives);
            }

            return representatives;
        }

        
        
        
        
        
        public static IEnumerable<Vertex<T>>[] GetScc(IDirectedWeightedGraph<T> graph)
        {
            var representatives = GetRepresentatives(graph);
            Dictionary<Vertex<T>, List<Vertex<T>>> scc = new Dictionary<Vertex<T>, List<Vertex<T>>>();
            foreach (var kv in representatives)
            {
                
                if (scc.ContainsKey(kv.Value))
                {
                    scc[kv.Value].Add(kv.Key);
                }
                else
                {
                    scc.Add(kv.Value, new List<Vertex<T>> { kv.Key });
                }
            }

            return scc.Values.ToArray();
        }
    }
}
using System;
using DataStructures.Graph;

namespace Algorithms.Graph
{
    
    
    
    
    public class FloydWarshall<T>
    {
        
        
        
        
        
        
        
        
        public double[,] Run(DirectedWeightedGraph<T> graph)
        {
            var distances = SetupDistances(graph);
            var vertexCount = distances.GetLength(0);
            for (var k = 0; k < vertexCount; k++)
            {
                for (var i = 0; i < vertexCount; i++)
                {
                    for (var j = 0; j < vertexCount; j++)
                    {
                        distances[i, j] = distances[i, j] > distances[i, k] + distances[k, j]
                        ? distances[i, k] + distances[k, j]
                        : distances[i, j];
                    }
                }
            }

            return distances;
        }

        
        
        
        
        
        private double[,] SetupDistances(DirectedWeightedGraph<T> graph)
        {
            var distances = new double[graph.Count, graph.Count];
            for (int i = 0; i < distances.GetLength(0); i++)
            {
                for (var j = 0; j < distances.GetLength(0); j++)
                {
                    var dist = graph.AdjacentDistance(graph.Vertices[i] !, graph.Vertices[j] !);
                    distances[i, j] = dist != 0 ? dist : double.PositiveInfinity;
                }
            }

            for (var i = 0; i < distances.GetLength(0); i++)
            {
                distances[i, i] = 0;
            }

            return distances;
        }
    }
}
using System;
using System.Collections.Generic;
using DataStructures.Graph;

namespace Algorithms.Graph
{
    
    
    
    
    
    
    public class BreadthFirstSearch<T> : IGraphSearch<T> where T : IComparable<T>
    {
        
        
        
        
        
        
        public void VisitAll(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action = default)
        {
            Bfs(graph, startVertex, action, new HashSet<Vertex<T>>());
        }

        
        
        
        
        
        
        
        private void Bfs(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action, HashSet<Vertex<T>> visited)
        {
            var queue = new Queue<Vertex<T>>();

            queue.Enqueue(startVertex);

            while (queue.Count > 0)
            {
                var currentVertex = queue.Dequeue();

                if (currentVertex == null || visited.Contains(currentVertex))
                {
                    continue;
                }

                foreach (var vertex in graph.GetNeighbors(currentVertex))
                {
                    queue.Enqueue(vertex!);
                }

                action?.Invoke(currentVertex);

                visited.Add(currentVertex);
            }
        }
    }
}
using System;
using DataStructures.Graph;

namespace Algorithms.Graph
{
    public interface IGraphSearch<T>
    {
        
        
        
        
        
        
        void VisitAll(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action = null);
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;
using DataStructures.Graph;

namespace Algorithms.Graph.Dijkstra
{
    public static class DijkstraAlgorithm
    {
        
        
        
        
        
        
        
        
        
        
        public static DistanceModel<T>[] GenerateShortestPath<T>(DirectedWeightedGraph<T> graph, Vertex<T> startVertex)
        {
            ValidateGraphAndStartVertex(graph, startVertex);

            var visitedVertices = new List<Vertex<T>>();

            var distanceArray = InitializeDistanceArray(graph, startVertex);

            var currentVertex = startVertex;

            var currentPath = 0d;

            while (true)
            {
                visitedVertices.Add(currentVertex);

                var neighborVertices = graph
                    .GetNeighbors(currentVertex)
                    .Where(x => x != null && !visitedVertices.Contains(x))
                    .ToList();

                foreach (var vertex in neighborVertices)
                {
                    var adjacentDistance = graph.AdjacentDistance(currentVertex, vertex!);

                    var distance = distanceArray[vertex!.Index];

                    if (distance.Distance <= currentPath + adjacentDistance)
                    {
                        continue;
                    }

                    distance.Distance = currentPath + adjacentDistance;
                    distance.PreviousVertex = currentVertex;
                }

                var minimalAdjacentVertex = GetMinimalUnvisitedAdjacentVertex(graph, currentVertex, neighborVertices);

                if (neighborVertices.Count == 0 || minimalAdjacentVertex is null)
                {
                    break;
                }

                currentPath += graph.AdjacentDistance(currentVertex, minimalAdjacentVertex);

                currentVertex = minimalAdjacentVertex;
            }

            return distanceArray;
        }

        private static DistanceModel<T>[] InitializeDistanceArray<T>(
            IDirectedWeightedGraph<T> graph,
            Vertex<T> startVertex)
        {
            var distArray = new DistanceModel<T>[graph.Count];

            distArray[startVertex.Index] = new DistanceModel<T>(startVertex, startVertex, 0);

            foreach (var vertex in graph.Vertices.Where(x => x != null && !x.Equals(startVertex)))
            {
                distArray[vertex!.Index] = new DistanceModel<T>(vertex, null, double.MaxValue);
            }

            return distArray;
        }

        private static void ValidateGraphAndStartVertex<T>(DirectedWeightedGraph<T> graph, Vertex<T> startVertex)
        {
            if (graph is null)
            {
                throw new ArgumentNullException(nameof(graph));
            }

            if (startVertex.Graph != null && !startVertex.Graph.Equals(graph))
            {
                throw new ArgumentNullException(nameof(graph));
            }
        }

        private static Vertex<T>? GetMinimalUnvisitedAdjacentVertex<T>(
            IDirectedWeightedGraph<T> graph,
            Vertex<T> startVertex,
            IEnumerable<Vertex<T>?> adjacentVertices)
        {
            var minDistance = double.MaxValue;
            Vertex<T>? minVertex = default;

            foreach (var vertex in adjacentVertices)
            {
                var currentDistance = graph.AdjacentDistance(startVertex, vertex!);

                if (minDistance <= currentDistance)
                {
                    continue;
                }

                minDistance = currentDistance;
                minVertex = vertex;
            }

            return minVertex;
        }
    }
}
﻿using DataStructures.Graph;

namespace Algorithms.Graph.Dijkstra
{
    
    
    
    
    
    public class DistanceModel<T>
    {
        public Vertex<T>? Vertex { get; }

        public Vertex<T>? PreviousVertex { get; set; }

        public double Distance { get; set; }

        public DistanceModel(Vertex<T>? vertex, Vertex<T>? previousVertex, double distance)
        {
            Vertex = vertex;
            PreviousVertex = previousVertex;
            Distance = distance;
        }

        public override string ToString() =>
            $"Vertex: {Vertex} - Distance: {Distance} - Previous: {PreviousVertex}";
    }
}
using System;
using System.Collections.Generic;
using DataStructures.Graph;

namespace Algorithms.Graph
{
    
    
    
    
    
    
    public class DepthFirstSearch<T> : IGraphSearch<T> where T : IComparable<T>
    {
        
        
        
        
        
        
        public void VisitAll(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action = default)
        {
            Dfs(graph, startVertex, action, new HashSet<Vertex<T>>());
        }

        
        
        
        
        
        
        
        private void Dfs(IDirectedWeightedGraph<T> graph, Vertex<T> startVertex, Action<Vertex<T>>? action, HashSet<Vertex<T>> visited)
        {
            action?.Invoke(startVertex);

            visited.Add(startVertex);

            foreach (var vertex in graph.GetNeighbors(startVertex))
            {
                if (vertex == null || visited.Contains(vertex))
                {
                    continue;
                }

                Dfs(graph, vertex!, action, visited);
            }
        }
    }
}
using System;

namespace Algorithms.Graph.MinimumSpanningTree
{
    
    
    
    
    
    
    
    
    
    public static class PrimMatrix
    {
        
        
        
        
        
        
        public static float[,] Solve(float[,] adjacencyMatrix, int start)
        {
            ValidateMatrix(adjacencyMatrix);

            var numNodes = adjacencyMatrix.GetLength(0);

            
            var mst = new float[numNodes, numNodes];

            
            var added = new bool[numNodes];

            
            var key = new float[numNodes];

            
            var parent = new int[numNodes];

            for (var i = 0; i < numNodes; i++)
            {
                mst[i, i] = float.PositiveInfinity;
                key[i] = float.PositiveInfinity;

                for (var j = i + 1; j < numNodes; j++)
                {
                    mst[i, j] = float.PositiveInfinity;
                    mst[j, i] = float.PositiveInfinity;
                }
            }

            
            key[start] = 0;

            
            for (var i = 0; i < numNodes - 1; i++)
            {
                GetNextNode(adjacencyMatrix, key, added, parent);
            }

            
            for (var i = 0; i < numNodes; i++)
            {
                if (i == start)
                {
                    continue;
                }

                mst[i, parent[i]] = adjacencyMatrix[i, parent[i]];
                mst[parent[i], i] = adjacencyMatrix[i, parent[i]];
            }

            return mst;
        }

        
        
        
        
        private static void ValidateMatrix(float[,] adjacencyMatrix)
        {
            
            if (adjacencyMatrix.GetLength(0) != adjacencyMatrix.GetLength(1))
            {
                throw new ArgumentException("Adjacency matrix must be square!");
            }

            
            for (var i = 0; i < adjacencyMatrix.GetLength(0); i++)
            {
                var connection = false;
                for (var j = 0; j < adjacencyMatrix.GetLength(0); j++)
                {
                    if (Math.Abs(adjacencyMatrix[i, j] - adjacencyMatrix[j, i]) > 1e-6)
                    {
                        throw new ArgumentException("Adjacency matrix must be symmetric!");
                    }

                    if (!connection && float.IsFinite(adjacencyMatrix[i, j]))
                    {
                        connection = true;
                    }
                }

                if (!connection)
                {
                    throw new ArgumentException("Graph must be connected!");
                }
            }
        }

        
        
        
        
        
        
        
        private static void GetNextNode(float[,] adjacencyMatrix, float[] key, bool[] added, int[] parent)
        {
            var numNodes = adjacencyMatrix.GetLength(0);
            var minWeight = float.PositiveInfinity;

            var node = -1;

            
            for (var i = 0; i < numNodes; i++)
            {
                if (!added[i] && key[i] < minWeight)
                {
                    minWeight = key[i];
                    node = i;
                }
            }

            
            added[node] = true;

            
            for (var i = 0; i < numNodes; i++)
            {
                if (!added[i] && adjacencyMatrix[node, i] < key[i])
                {
                    key[i] = adjacencyMatrix[node, i];
                    parent[i] = node;
                }
            }
        }
    }
}
using System;
using System.Collections.Generic;
using DataStructures.DisjointSet;

namespace Algorithms.Graph.MinimumSpanningTree
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    public static class Kruskal
    {
        
        
        
        
        
        public static float[,] Solve(float[,] adjacencyMatrix)
        {
            ValidateGraph(adjacencyMatrix);

            var numNodes = adjacencyMatrix.GetLength(0);
            var set = new DisjointSet<int>();
            var nodes = new Node<int>[numNodes];
            var edgeWeightList = new List<float>();
            var nodeConnectList = new List<(int, int)>();

            
            for (var i = 0; i < numNodes; i++)
            {
                nodes[i] = set.MakeSet(i);
            }

            
            for (var i = 0; i < numNodes - 1; i++)
            {
                for (var j = i + 1; j < numNodes; j++)
                {
                    if (float.IsFinite(adjacencyMatrix[i, j]))
                    {
                        edgeWeightList.Add(adjacencyMatrix[i, j]);
                        nodeConnectList.Add((i, j));
                    }
                }
            }

            var edges = Solve(set, nodes, edgeWeightList.ToArray(), nodeConnectList.ToArray());

            
            var mst = new float[numNodes, numNodes];
            for (var i = 0; i < numNodes; i++)
            {
                mst[i, i] = float.PositiveInfinity;

                for (var j = i + 1; j < numNodes; j++)
                {
                    mst[i, j] = float.PositiveInfinity;
                    mst[j, i] = float.PositiveInfinity;
                }
            }

            foreach (var (node1, node2) in edges)
            {
                mst[node1, node2] = adjacencyMatrix[node1, node2];
                mst[node2, node1] = adjacencyMatrix[node1, node2];
            }

            return mst;
        }

        
        
        
        
        
        public static Dictionary<int, float>[] Solve(Dictionary<int, float>[] adjacencyList)
        {
            ValidateGraph(adjacencyList);

            var numNodes = adjacencyList.Length;
            var set = new DisjointSet<int>();
            var nodes = new Node<int>[numNodes];
            var edgeWeightList = new List<float>();
            var nodeConnectList = new List<(int, int)>();

            
            for (var i = 0; i < numNodes; i++)
            {
                nodes[i] = set.MakeSet(i);

                foreach(var (node, weight) in adjacencyList[i])
                {
                    edgeWeightList.Add(weight);
                    nodeConnectList.Add((i, node));
                }
            }

            var edges = Solve(set, nodes, edgeWeightList.ToArray(), nodeConnectList.ToArray());

            
            var mst = new Dictionary<int, float>[numNodes];
            for (var i = 0; i < numNodes; i++)
            {
                mst[i] = new Dictionary<int, float>();
            }

            foreach (var (node1, node2) in edges)
            {
                mst[node1].Add(node2, adjacencyList[node1][node2]);
                mst[node2].Add(node1, adjacencyList[node1][node2]);
            }

            return mst;
        }

        
        
        
        
        private static void ValidateGraph(float[,] adj)
        {
            if (adj.GetLength(0) != adj.GetLength(1))
            {
                throw new ArgumentException("Matrix must be square!");
            }

            for (var i = 0; i < adj.GetLength(0) - 1; i++)
            {
                for (var j = i + 1; j < adj.GetLength(1); j++)
                {
                    if (Math.Abs(adj[i, j] - adj[j, i]) > 1e-6)
                    {
                        throw new ArgumentException("Matrix must be symmetric!");
                    }
                }
            }
        }

        
        
        
        
        private static void ValidateGraph(Dictionary<int, float>[] adj)
        {
            for (var i = 0; i < adj.Length; i++)
            {
                foreach (var edge in adj[i])
                {
                    if (!adj[edge.Key].ContainsKey(i) || Math.Abs(edge.Value - adj[edge.Key][i]) > 1e-6)
                    {
                        throw new ArgumentException("Graph must be undirected!");
                    }
                }
            }
        }

        
        
        
        
        
        
        
        
        private static (int, int)[] Solve(DisjointSet<int> set, Node<int>[] nodes, float[] edgeWeights, (int, int)[] connections)
        {
            var edges = new List<(int, int)>();

            Array.Sort(edgeWeights, connections);

            foreach (var (node1, node2) in connections)
            {
                if (set.FindSet(nodes[node1]) != set.FindSet(nodes[node2]))
                {
                    set.UnionSet(nodes[node1], nodes[node2]);
                    edges.Add((node1, node2));
                }
            }

            return edges.ToArray();
        }
    }
}
﻿using System;

namespace Algorithms.Other
{
    public static class GeoLocation
    {
        private const double EarthRadiusKm = 6371.01d;

        
        
        
        
        
        
        
        
        
        public static double CalculateDistanceFromLatLng(double lat1, double lng1, double lat2, double lng2)
        {
            var pi180 = Math.PI / 180d;
            var lat1Radian = lat1 * pi180;
            var lng1Radian = lng1 * pi180;
            var lat2Radian = lat2 * pi180;
            var lng2Radian = lng2 * pi180;

            var diffLat = lat2Radian - lat1Radian;
            var diffLng = lng2Radian - lng1Radian;

            var haversine =
                Math.Sin(diffLat / 2) * Math.Sin(diffLat / 2)
                + Math.Cos(lat1Radian) * Math.Cos(lat2Radian) * Math.Sin(diffLng / 2) * Math.Sin(diffLng / 2);
            var distance = EarthRadiusKm * (2d * Math.Atan2(Math.Sqrt(haversine), Math.Sqrt(1 - haversine)));

            return distance * 1000; 
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Other
{
    
    
    
    public static class SieveOfEratosthenes
    {
        
        
        
        
        
        public static List<BigInteger> GetPrimeNumbers(int count)
        {
            var output = new List<BigInteger>();
            for (BigInteger n = 2; output.Count < count; n++)
            {
                if (output.All(x => n % x != 0))
                {
                    output.Add(n);
                }
            }

            return output;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Drawing;
using System.Numerics;

namespace Algorithms.Other
{
    
    
    
    
    
    
    
    
    public static class FloodFill
    {
        private static readonly List<(int xOffset, int yOffset)> Neighbors = new() { (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1) };

        
        
        
        
        
        
        
        public static void BreadthFirstSearch(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor)
        {
            if (location.x < 0 || location.x >= bitmap.Width || location.y < 0 || location.y >= bitmap.Height)
            {
                throw new ArgumentOutOfRangeException(nameof(location), $"{nameof(location)} should point to a pixel within the bitmap");
            }

            var queue = new List<(int x, int y)>();
            queue.Add(location);

            while (queue.Count > 0)
            {
                BreadthFirstFill(bitmap, location, targetColor, replacementColor, queue);
            }
        }

        
        
        
        
        
        
        
        public static void DepthFirstSearch(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor)
        {
            if (location.x < 0 || location.x >= bitmap.Width || location.y < 0 || location.y >= bitmap.Height)
            {
                throw new ArgumentOutOfRangeException(nameof(location), $"{nameof(location)} should point to a pixel within the bitmap");
            }

            DepthFirstFill(bitmap, location, targetColor, replacementColor);
        }

        private static void BreadthFirstFill(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor, List<(int x, int y)> queue)
        {
            (int x, int y) currentLocation = queue[0];
            queue.RemoveAt(0);

            if (bitmap.GetPixel(currentLocation.x, currentLocation.y) == targetColor)
            {
                bitmap.SetPixel(currentLocation.x, currentLocation.y, replacementColor);

                for (int i = 0; i < Neighbors.Count; i++)
                {
                    int x = currentLocation.x + Neighbors[i].xOffset;
                    int y = currentLocation.y + Neighbors[i].yOffset;
                    if (x >= 0 && x < bitmap.Width && y >= 0 && y < bitmap.Height)
                    {
                        queue.Add((x, y));
                    }
                }
            }
        }

        private static void DepthFirstFill(Bitmap bitmap, (int x, int y) location, Color targetColor, Color replacementColor)
        {
            if (bitmap.GetPixel(location.x, location.y) == targetColor)
            {
                bitmap.SetPixel(location.x, location.y, replacementColor);

                for (int i = 0; i < Neighbors.Count; i++)
                {
                    int x = location.x + Neighbors[i].xOffset;
                    int y = location.y + Neighbors[i].yOffset;
                    if (x >= 0 && x < bitmap.Width && y >= 0 && y < bitmap.Height)
                    {
                        DepthFirstFill(bitmap, (x, y), targetColor, replacementColor);
                    }
                }
            }
        }
    }
}
using System.Text;

namespace Algorithms.Other
{
    
    
    
    public static class Int2Binary
    {
        
        
        
        
        
        public static string Int2Bin(ushort input)
        {
            ushort msb = ushort.MaxValue / 2 + 1;
            var output = new StringBuilder();
            for (var i = 0; i < 16; i++)
            {
                if (input >= msb)
                {
                    output.Append("1");
                    input -= msb;
                    msb /= 2;
                }
                else
                {
                    output.Append("0");
                    msb /= 2;
                }
            }

            return output.ToString();
        }

        
        
        
        
        
        public static string Int2Bin(uint input)
        {
            var msb = uint.MaxValue / 2 + 1;
            var output = new StringBuilder();
            for (var i = 0; i < 32; i++)
            {
                if (input >= msb)
                {
                    output.Append("1");
                    input -= msb;
                    msb /= 2;
                }
                else
                {
                    output.Append("0");
                    msb /= 2;
                }
            }

            return output.ToString();
        }

        
        
        
        
        
        public static string Int2Bin(ulong input)
        {
            var msb = ulong.MaxValue / 2 + 1;
            var output = new StringBuilder();
            for (var i = 0; i < 64; i++)
            {
                if (input >= msb)
                {
                    output.Append("1");
                    input -= msb;
                    msb /= 2;
                }
                else
                {
                    output.Append("0");
                    msb /= 2;
                }
            }

            return output.ToString();
        }
    }
}
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Numerics;

namespace Algorithms.Other
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public static class KochSnowflake
    {
        
        
        
        
        
        
        
        
        
        
        
        public static List<Vector2> Iterate(List<Vector2> initialVectors, int steps = 5)
        {
            List<Vector2> vectors = initialVectors;
            for (var i = 0; i < steps; i++)
            {
                vectors = IterationStep(vectors);
            }

            return vectors;
        }

        
        
        
        
        
        
        
        public static Bitmap GetKochSnowflake(
            int bitmapWidth = 600,
            int steps = 5)
        {
            if (bitmapWidth <= 0)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(bitmapWidth),
                    $"{nameof(bitmapWidth)} should be greater than zero");
            }

            var offsetX = bitmapWidth / 10f;
            var offsetY = bitmapWidth / 3.7f;
            var vector1 = new Vector2(offsetX, offsetY);
            var vector2 = new Vector2(bitmapWidth / 2, (float)Math.Sin(Math.PI / 3) * bitmapWidth * 0.8f + offsetY);
            var vector3 = new Vector2(bitmapWidth - offsetX, offsetY);
            List<Vector2> initialVectors = new() { vector1, vector2, vector3, vector1 };
            List<Vector2> vectors = Iterate(initialVectors, steps);
            return GetBitmap(vectors, bitmapWidth, bitmapWidth);
        }

        
        
        
        
        
        
        
        
        
        
        
        private static List<Vector2> IterationStep(List<Vector2> vectors)
        {
            List<Vector2> newVectors = new();
            for (var i = 0; i < vectors.Count - 1; i++)
            {
                var startVector = vectors[i];
                var endVector = vectors[i + 1];
                newVectors.Add(startVector);
                var differenceVector = endVector - startVector;
                newVectors.Add(startVector + differenceVector / 3);
                newVectors.Add(startVector + differenceVector / 3 + Rotate(differenceVector / 3, 60));
                newVectors.Add(startVector + differenceVector * 2 / 3);
            }

            newVectors.Add(vectors[^1]);
            return newVectors;
        }

        
        
        
        
        
        
        
        private static Vector2 Rotate(Vector2 vector, float angleInDegrees)
        {
            var radians = angleInDegrees * (float)Math.PI / 180;
            var ca = (float)Math.Cos(radians);
            var sa = (float)Math.Sin(radians);
            return new Vector2(ca * vector.X - sa * vector.Y, sa * vector.X + ca * vector.Y);
        }

        
        
        
        
        
        
        
        private static Bitmap GetBitmap(
            List<Vector2> vectors,
            int bitmapWidth,
            int bitmapHeight)
        {
            Bitmap bitmap = new(bitmapWidth, bitmapHeight);

            using (Graphics graphics = Graphics.FromImage(bitmap))
            {
                
                var imageSize = new Rectangle(0, 0, bitmapWidth, bitmapHeight);
                graphics.FillRectangle(Brushes.White, imageSize);

                
                for (var i = 0; i < vectors.Count - 1; i++)
                {
                    Pen blackPen = new(Color.Black, 1);

                    var x1 = vectors[i].X;
                    var y1 = vectors[i].Y;
                    var x2 = vectors[i + 1].X;
                    var y2 = vectors[i + 1].Y;

                    graphics.DrawLine(blackPen, x1, y1, x2, y2);
                }
            }

            return bitmap;
        }
    }
}
using System;
using System.Drawing;

namespace Algorithms.Other
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public static class Mandelbrot
    {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        public static Bitmap GetBitmap(
            int bitmapWidth = 800,
            int bitmapHeight = 600,
            double figureCenterX = -0.6,
            double figureCenterY = 0,
            double figureWidth = 3.2,
            int maxStep = 50,
            bool useDistanceColorCoding = true)
        {
            if (bitmapWidth <= 0)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(bitmapWidth),
                    $"{nameof(bitmapWidth)} should be greater than zero");
            }

            if (bitmapHeight <= 0)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(bitmapHeight),
                    $"{nameof(bitmapHeight)} should be greater than zero");
            }

            if (maxStep <= 0)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(maxStep),
                    $"{nameof(maxStep)} should be greater than zero");
            }

            var bitmap = new Bitmap(bitmapWidth, bitmapHeight);
            var figureHeight = figureWidth / bitmapWidth * bitmapHeight;

            
            for (var bitmapX = 0; bitmapX < bitmapWidth; bitmapX++)
            {
                for (var bitmapY = 0; bitmapY < bitmapHeight; bitmapY++)
                {
                    
                    var figureX = figureCenterX + ((double)bitmapX / bitmapWidth - 0.5) * figureWidth;
                    var figureY = figureCenterY + ((double)bitmapY / bitmapHeight - 0.5) * figureHeight;

                    var distance = GetDistance(figureX, figureY, maxStep);

                    
                    bitmap.SetPixel(
                        bitmapX,
                        bitmapY,
                        useDistanceColorCoding ? ColorCodedColorMap(distance) : BlackAndWhiteColorMap(distance));
                }
            }

            return bitmap;
        }

        
        
        
        
        
        
        private static Color BlackAndWhiteColorMap(double distance) =>
            distance >= 1
                ? Color.FromArgb(255, 0, 0, 0)
                : Color.FromArgb(255, 255, 255, 255);

        
        
        
        
        
        
        private static Color ColorCodedColorMap(double distance)
        {
            if (distance >= 1)
            {
                return Color.FromArgb(255, 0, 0, 0);
            }

            
            
            var hue = 360 * distance;
            double saturation = 1;
            double val = 255;
            var hi = (int)Math.Floor(hue / 60) % 6;
            var f = hue / 60 - Math.Floor(hue / 60);

            var v = (int)val;
            var p = 0;
            var q = (int)(val * (1 - f * saturation));
            var t = (int)(val * (1 - (1 - f) * saturation));

            switch (hi)
            {
                case 0: return Color.FromArgb(255, v, t, p);
                case 1: return Color.FromArgb(255, q, v, p);
                case 2: return Color.FromArgb(255, p, v, t);
                case 3: return Color.FromArgb(255, p, q, v);
                case 4: return Color.FromArgb(255, t, p, v);
                default: return Color.FromArgb(255, v, p, q);
            }
        }

        
        
        
        
        
        
        
        
        
        private static double GetDistance(double figureX, double figureY, int maxStep)
        {
            var a = figureX;
            var b = figureY;
            var currentStep = 0;
            for (var step = 0; step < maxStep; step++)
            {
                currentStep = step;
                var aNew = a * a - b * b + figureX;
                b = 2 * a * b + figureY;
                a = aNew;

                
                
                if (a * a + b * b > 4)
                {
                    break;
                }
            }

            return (double)currentStep / (maxStep - 1);
        }
    }
}
using System;
using System.Numerics;

namespace Algorithms.Other
{
    
    
    
    public static class FermatPrimeChecker
    {
        
        
        
        
        
        
        public static bool IsPrime(int numberToTest, int timesToCheck)
        {
            
            
            
            var numberToTestBigInteger = new BigInteger(numberToTest);
            var exponentBigInteger = new BigInteger(numberToTest - 1);

            
            var r = new Random(default(DateTime).Millisecond);

            var iterator = 1;
            var prime = true;

            while (iterator < timesToCheck && prime)
            {
                var randomNumber = r.Next(1, numberToTest);
                var randomNumberBigInteger = new BigInteger(randomNumber);
                if (BigInteger.ModPow(randomNumberBigInteger, exponentBigInteger, numberToTestBigInteger) != 1)
                {
                    prime = false;
                }

                iterator++;
            }

            return prime;
        }
    }
}
﻿using System;

namespace Algorithms.Other
{
    
    
    
    
    
    
    
    
    
    
    
    public static class RgbHsvConversion
    {
        
        
        
        
        
        
        
        public static (byte red, byte green, byte blue) HsvToRgb(
            double hue,
            double saturation,
            double value)
        {
            if (hue < 0 || hue > 360)
            {
                throw new ArgumentOutOfRangeException(nameof(hue), $"{nameof(hue)} should be between 0 and 360");
            }

            if (saturation < 0 || saturation > 1)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(saturation),
                    $"{nameof(saturation)} should be between 0 and 1");
            }

            if (value < 0 || value > 1)
            {
                throw new ArgumentOutOfRangeException(nameof(value), $"{nameof(value)} should be between 0 and 1");
            }

            var chroma = value * saturation;
            var hueSection = hue / 60;
            var secondLargestComponent = chroma * (1 - Math.Abs(hueSection % 2 - 1));
            var matchValue = value - chroma;

            return GetRgbBySection(hueSection, chroma, matchValue, secondLargestComponent);
        }

        
        
        
        
        
        
        
        public static (double hue, double saturation, double value) RgbToHsv(
            byte red,
            byte green,
            byte blue)
        {
            var dRed = (double)red / 255;
            var dGreen = (double)green / 255;
            var dBlue = (double)blue / 255;
            var value = Math.Max(Math.Max(dRed, dGreen), dBlue);
            var chroma = value - Math.Min(Math.Min(dRed, dGreen), dBlue);
            var saturation = value.Equals(0) ? 0 : chroma / value;
            double hue;

            if (chroma.Equals(0))
            {
                hue = 0;
            }
            else if (value.Equals(dRed))
            {
                hue = 60 * (0 + (dGreen - dBlue) / chroma);
            }
            else if (value.Equals(dGreen))
            {
                hue = 60 * (2 + (dBlue - dRed) / chroma);
            }
            else
            {
                hue = 60 * (4 + (dRed - dGreen) / chroma);
            }

            hue = (hue + 360) % 360;

            return (hue, saturation, value);
        }

        private static (byte red, byte green, byte blue) GetRgbBySection(
            double hueSection,
            double chroma,
            double matchValue,
            double secondLargestComponent)
        {
            byte red;
            byte green;
            byte blue;

            if (hueSection >= 0 && hueSection <= 1)
            {
                red = ConvertToByte(chroma + matchValue);
                green = ConvertToByte(secondLargestComponent + matchValue);
                blue = ConvertToByte(matchValue);
            }
            else if (hueSection > 1 && hueSection <= 2)
            {
                red = ConvertToByte(secondLargestComponent + matchValue);
                green = ConvertToByte(chroma + matchValue);
                blue = ConvertToByte(matchValue);
            }
            else if (hueSection > 2 && hueSection <= 3)
            {
                red = ConvertToByte(matchValue);
                green = ConvertToByte(chroma + matchValue);
                blue = ConvertToByte(secondLargestComponent + matchValue);
            }
            else if (hueSection > 3 && hueSection <= 4)
            {
                red = ConvertToByte(matchValue);
                green = ConvertToByte(secondLargestComponent + matchValue);
                blue = ConvertToByte(chroma + matchValue);
            }
            else if (hueSection > 4 && hueSection <= 5)
            {
                red = ConvertToByte(secondLargestComponent + matchValue);
                green = ConvertToByte(matchValue);
                blue = ConvertToByte(chroma + matchValue);
            }
            else
            {
                red = ConvertToByte(chroma + matchValue);
                green = ConvertToByte(matchValue);
                blue = ConvertToByte(secondLargestComponent + matchValue);
            }

            return (red, green, blue);
        }

        private static byte ConvertToByte(double input) => (byte)Math.Round(255 * input);
    }
}
﻿using System;

namespace Algorithms.Other
{
    
    
    
    
    
    
    
    
    public static class Luhn
    {
        
        
        
        
        
        
        
        
        public static bool Validate(string number) => GetSum(number) % 10 == 0;

        
        
        
        
        
        
        public static int GetLostNum(string number)
        {
            var lostIndex = number.Length - 1 - number.LastIndexOf("x", StringComparison.CurrentCultureIgnoreCase);
            var lostNum = GetSum(number.Replace("x", "0", StringComparison.CurrentCultureIgnoreCase)) * 9 % 10;

            
            if (lostIndex % 2 == 0)
            {
                return lostNum;
            }

            var tempLostNum = lostNum / 2;

            
            
            return Validate(number.Replace("x", tempLostNum.ToString())) ? tempLostNum : (lostNum + 9) / 2;
        }

        
        
        
        
        
        private static int GetSum(string number)
        {
            var sum = 0;
            for (var i = 0; i < number.Length; i++)
            {
                var d = number[i] - '0';
                d = (i + number.Length) % 2 == 0
                    ? 2 * d
                    : d;
                if (d > 9)
                {
                    d -= 9;
                }

                sum += d;
            }

            return sum;
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Problems.StableMarriage
{
    public static class GaleShapley
    {
        
        
        
        
        
        
        
        
        public static void Match(Proposer[] proposers, Accepter[] accepters)
        {
            if (proposers.Length != accepters.Length)
            {
                throw new ArgumentException("Collections must have equal count");
            }

            while (proposers.Any(m => !IsEngaged(m)))
            {
                DoSingleMatchingRound(proposers.Where(m => !IsEngaged(m)));
            }
        }

        private static bool IsEngaged(Proposer proposer) => proposer.EngagedTo is not null;

        private static void DoSingleMatchingRound(IEnumerable<Proposer> proposers)
        {
            foreach (var newProposer in proposers)
            {
                var accepter = newProposer.PreferenceOrder.First!.Value;

                if (accepter.EngagedTo is null)
                {
                    Engage(newProposer, accepter);
                }
                else
                {
                    if (accepter.PrefersOverCurrent(newProposer))
                    {
                        Free(accepter.EngagedTo);
                        Engage(newProposer, accepter);
                    }
                }

                newProposer.PreferenceOrder.RemoveFirst();
            }
        }

        private static void Free(Proposer proposer)
        {
            proposer.EngagedTo = null;
        }

        private static void Engage(Proposer proposer, Accepter accepter)
        {
            proposer.EngagedTo = accepter;
            accepter.EngagedTo = proposer;
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Problems.StableMarriage
{
    public class Accepter
    {
        public Proposer? EngagedTo { get; set; }

        public List<Proposer> PreferenceOrder { get; set; } = new();

        public bool PrefersOverCurrent(Proposer newProposer) =>
            EngagedTo is null ||
            PreferenceOrder.IndexOf(newProposer) < PreferenceOrder.IndexOf(EngagedTo);
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Problems.StableMarriage
{
    public class Proposer
    {
        public Accepter? EngagedTo { get; set; }

        public LinkedList<Accepter> PreferenceOrder { get; set; } = new();
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Problems.CoinChange
{
    public static class DynamicCoinChangeSolver
    {
        
        
        
        
        
        
        
        
        public static int[] GenerateSingleCoinChanges(int coin, int[] coins)
        {
            ValidateCoin(coin);
            ValidateCoinsArray(coins);

            var coinsArrayCopy = new int[coins.Length];

            Array.Copy(coins, coinsArrayCopy, coins.Length);
            Array.Sort(coinsArrayCopy);
            Array.Reverse(coinsArrayCopy);

            var list = new List<int>();

            foreach (var item in coinsArrayCopy)
            {
                if (item > coin)
                {
                    continue;
                }

                var difference = coin - item;

                list.Add(difference);
            }

            var result = list.ToArray();

            return result;
        }

        
        
        
        
        
        
        
        
        public static Dictionary<int, int[]> GenerateChangesDictionary(int coin, int[] coins)
        {
            var dict = new Dictionary<int, int[]>();
            var currentCoin = 1;

            while (currentCoin <= coin)
            {
                var changeArray = GenerateSingleCoinChanges(currentCoin, coins);
                dict[currentCoin] = changeArray;
                currentCoin++;
            }

            return dict;
        }

        
        
        
        
        
        
        
        
        public static int GetMinimalNextCoin(int coin, Dictionary<int, int[]> exchanges)
        {
            var nextCoin = int.MaxValue;
            var minChange = int.MaxValue;

            var coinChanges = exchanges[coin];

            foreach (var change in coinChanges)
            {
                if (change == 0)
                {
                    return 0;
                }

                var currentChange = exchanges[change];
                var min = currentChange.Min();

                var minIsLesser = min < minChange;

                if (minIsLesser)
                {
                    nextCoin = change;
                    minChange = min;
                }
            }

            return nextCoin;
        }

        
        
        
        
        
        
        public static int[] MakeCoinChangeDynamic(int coin, int[] coins)
        {
            var changesTable = GenerateChangesDictionary(coin, coins);
            var list = new List<int>();

            var currentCoin = coin;
            var nextCoin = int.MaxValue;

            while (nextCoin != 0)
            {
                nextCoin = GetMinimalNextCoin(currentCoin, changesTable);
                var difference = currentCoin - nextCoin;
                list.Add(difference);
                currentCoin = nextCoin;
            }

            var result = list.ToArray();

            return result;
        }

        private static void ValidateCoin(int coin)
        {
            if (coin <= 0)
            {
                throw new InvalidOperationException($"The coin cannot be lesser or equal to zero {nameof(coin)}.");
            }
        }

        private static void ValidateCoinsArray(int[] coinsArray)
        {
            var coinsAsArray = coinsArray.ToArray();

            if (coinsAsArray.Length == 0)
            {
                throw new InvalidOperationException($"Coins array cannot be empty {nameof(coinsAsArray)}.");
            }

            var coinsContainOne = coinsAsArray.Any(x => x == 1);

            if (!coinsContainOne)
            {
                throw new InvalidOperationException($"Coins array must contain coin 1 {nameof(coinsAsArray)}.");
            }

            var containsNonPositive = coinsAsArray.Any(x => x <= 0);

            if (containsNonPositive)
            {
                throw new InvalidOperationException(
                    $"{nameof(coinsAsArray)} cannot contain numbers less than or equal to zero");
            }

            var containsDuplicates = coinsAsArray.GroupBy(x => x).Any(g => g.Count() > 1);

            if (containsDuplicates)
            {
                throw new InvalidOperationException($"Coins array cannot contain duplicates {nameof(coinsAsArray)}.");
            }
        }
    }
}
﻿using System;
using System.Collections.Generic;

namespace Algorithms.Problems.NQueens
{
    public class BacktrackingNQueensSolver
    {
        
        
        
        
        
        
        public IEnumerable<bool[,]> BacktrackSolve(int n)
        {
            if (n < 0)
            {
                throw new ArgumentException(nameof(n));
            }

            return BacktrackSolve(new bool[n, n], 0);
        }

        private static IEnumerable<bool[,]> BacktrackSolve(bool[,] board, int col)
        {
            var solutions = col < board.GetLength(0) - 1
                ? HandleIntermediateColumn(board, col)
                : HandleLastColumn(board);
            return solutions;
        }

        private static IEnumerable<bool[,]> HandleIntermediateColumn(bool[,] board, int col)
        {
            
            for (var i = 0; i < board.GetLength(0); i++)
            {
                if (CanPlace(board, i, col))
                {
                    board[i, col] = true;

                    foreach (var solution in BacktrackSolve(board, col + 1))
                    {
                        yield return solution;
                    }

                    board[i, col] = false;
                }
            }
        }

        private static IEnumerable<bool[,]> HandleLastColumn(bool[,] board)
        {
            var n = board.GetLength(0);
            for (var i = 0; i < n; i++)
            {
                if (CanPlace(board, i, n - 1))
                {
                    board[i, n - 1] = true;

                    yield return (bool[,])board.Clone();

                    board[i, n - 1] = false;
                }
            }
        }

        
        
        
        
        
        
        
        
        private static bool CanPlace(bool[,] board, int row, int col)
        {
            
            for (var i = 0; i < col; i++)
            {
                if (board[row, i])
                {
                    return false;
                }
            }

            
            for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)
            {
                if (board[i, j])
                {
                    return false;
                }
            }

            
            for (int i = row + 1, j = col - 1; j >= 0 && i < board.GetLength(0); i++, j--)
            {
                if (board[i, j])
                {
                    return false;
                }
            }

            
            return true;
        }
    }
}
﻿namespace Algorithms.Sorters.Integer
{
    
    
    
    public interface IIntegerSorter
    {
        
        
        
        
        void Sort(int[] array);
    }
}
using System;
using System.Linq;

namespace Algorithms.Sorters.Integer
{
    
    
    
    
    
    
    
    
    
    public class CountingSorter : IIntegerSorter
    {
        
        
        
        
        
        
        
        
        
        
        
        
        public void Sort(int[] array)
        {
            if (array.Length == 0)
            {
                return;
            }

            var max = array.Max();
            var min = array.Min();
            var count = new int[max - min + 1];
            var output = new int[array.Length];
            for (var i = 0; i < array.Length; i++)
            {
                count[array[i] - min]++;
            }

            for (var i = 1; i < count.Length; i++)
            {
                count[i] += count[i - 1];
            }

            for (var i = array.Length - 1; i >= 0; i--)
            {
                output[count[array[i] - min] - 1] = array[i];
                count[array[i] - min]--;
            }

            Array.Copy(output, array, array.Length);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Sorters.Integer
{
    
    
    
    public class BucketSorter : IIntegerSorter
    {
        private const int NumOfDigitsInBase10 = 10;

        
        
        
        
        public void Sort(int[] array)
        {
            if (array.Length <= 1)
            {
                return;
            }

            
            var totalDigits = NumberOfDigits(array);

            
            var buckets = new int[NumOfDigitsInBase10, array.Length + 1];

            
            
            for (var pass = 1; pass <= totalDigits; pass++)
            {
                DistributeElements(array, buckets, pass); 
                CollectElements(array, buckets); 

                if (pass != totalDigits)
                {
                    EmptyBucket(buckets); 
                }
            }
        }

        
        
        
        
        
        private static int NumberOfDigits(IEnumerable<int> array) => (int)Math.Floor(Math.Log10(array.Max()) + 1);

        
        
        
        
        
        
        private static void DistributeElements(IEnumerable<int> data, int[,] buckets, int digit)
        {
            
            var divisor = (int)Math.Pow(10, digit);

            foreach (var element in data)
            {
                
                
                var bucketNumber = NumOfDigitsInBase10 * (element % divisor) / divisor;

                
                
                var elementNumber = ++buckets[bucketNumber, 0]; 
                buckets[bucketNumber, elementNumber] = element;
            }
        }

        
        
        
        
        
        private static void CollectElements(IList<int> data, int[,] buckets)
        {
            var subscript = 0; 

            
            for (var i = 0; i < NumOfDigitsInBase10; i++)
            {
                
                for (var j = 1; j <= buckets[i, 0]; j++)
                {
                    data[subscript++] = buckets[i, j]; 
                }
            }
        }

        
        
        
        
        private static void EmptyBucket(int[,] buckets)
        {
            for (var i = 0; i < NumOfDigitsInBase10; i++)
            {
                buckets[i, 0] = 0; 
            }
        }
    }
}
﻿namespace Algorithms.Sorters.Integer
{
    
    
    
    
    
    
    
    
    public class RadixSorter : IIntegerSorter
    {
        
        
        
        
        public void Sort(int[] array)
        {
            var bits = 4;
            var b = new int[array.Length];
            var rshift = 0;
            for (var mask = ~(-1 << bits); mask != 0; mask <<= bits, rshift += bits)
            {
                var cntarray = new int[1 << bits];
                foreach (var t in array)
                {
                    var key = (t & mask) >> rshift;
                    ++cntarray[key];
                }

                for (var i = 1; i < cntarray.Length; ++i)
                {
                    cntarray[i] += cntarray[i - 1];
                }

                for (var p = array.Length - 1; p >= 0; --p)
                {
                    var key = (array[p] & mask) >> rshift;
                    --cntarray[key];
                    b[cntarray[key]] = array[p];
                }

                var temp = b;
                b = array;
                array = temp;
            }
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public sealed class MedianOfThreeQuickSorter<T> : QuickSorter<T>
    {
        protected override T SelectPivot(T[] array, IComparer<T> comparer, int left, int right)
        {
            var leftPoint = array[left];
            var middlePoint = array[left + (right - left) / 2];
            var rightPoint = array[right];

            return FindMedian(comparer, leftPoint, middlePoint, rightPoint);
        }

        private static T FindMedian(IComparer<T> comparer, T a, T b, T c)
        {
            if (comparer.Compare(a, b) <= 0)
            {
                
                if (comparer.Compare(b, c) <= 0)
                {
                    return b;
                }

                
                if (comparer.Compare(a, c) <= 0)
                {
                    return c;
                }

                
                return a;
            }

            
            if (comparer.Compare(b, c) >= 0)
            {
                return b;
            }

            
            if (comparer.Compare(a, c) >= 0)
            {
                return c;
            }

            
            return a;
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public class PancakeSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            var n = array.Length;

            
            
            for (var currSize = n; currSize > 1; --currSize)
            {
                
                
                var mi = FindMax(array, currSize, comparer);

                
                
                if (mi != currSize - 1)
                {
                    
                    
                    Flip(array, mi);

                    
                    
                    Flip(array, currSize - 1);
                }
            }
        }

        
        private void Flip(T[] array, int i)
        {
            T temp;
            var start = 0;
            while (start < i)
            {
                temp = array[start];
                array[start] = array[i];
                array[i] = temp;
                start++;
                i--;
            }
        }

        
        
        private int FindMax(T[] array, int n, IComparer<T> comparer)
        {
            var mi = 0;
            for (var i = 0; i < n; i++)
            {
                if (comparer.Compare(array[i], array[mi]) == 1)
                {
                    mi = i;
                }
            }

            return mi;
        }
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public class SelectionSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                var jmin = i;
                for (var j = i + 1; j < array.Length; j++)
                {
                    if (comparer.Compare(array[jmin], array[j]) > 0)
                    {
                        jmin = j;
                    }
                }

                var t = array[i];
                array[i] = array[jmin];
                array[jmin] = t;
            }
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public class BubbleSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                var wasChanged = false;
                for (var j = 0; j < array.Length - i - 1; j++)
                {
                    if (comparer.Compare(array[j], array[j + 1]) > 0)
                    {
                        var temp = array[j];
                        array[j] = array[j + 1];
                        array[j + 1] = temp;
                        wasChanged = true;
                    }
                }

                if (!wasChanged)
                {
                    break;
                }
            }
        }
    }
}
﻿using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public sealed class RandomPivotQuickSorter<T> : QuickSorter<T>
    {
        private readonly Random random = new();

        protected override T SelectPivot(T[] array, IComparer<T> comparer, int left, int right) =>
            array[random.Next(left, right + 1)];
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public interface IComparisonSorter<T>
    {
        
        
        
        
        
        void Sort(T[] array, IComparer<T> comparer);
    }
}
﻿using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public class CombSorter<T> : IComparisonSorter<T>
    {
        public CombSorter(double shrinkFactor = 1.3) => ShrinkFactor = shrinkFactor;

        private double ShrinkFactor { get; }

        
        
        
        
        
        
        
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            var gap = array.Length;
            var sorted = false;
            while (!sorted)
            {
                gap = (int)Math.Floor(gap / ShrinkFactor);
                if (gap <= 1)
                {
                    gap = 1;
                    sorted = true;
                }

                for (var i = 0; i < array.Length - gap; i++)
                {
                    if (comparer.Compare(array[i], array[i + gap]) > 0)
                    {
                        (array[i], array[i + gap]) = (array[i + gap], array[i]);
                        sorted = false;
                    }
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    
    
    public class MergeSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            if (array.Length <= 1)
            {
                return;
            }

            var (left, right) = Split(array);
            Sort(left, comparer);
            Sort(right, comparer);
            Merge(array, left, right, comparer);
        }

        private static void Merge(T[] array, T[] left, T[] right, IComparer<T> comparer)
        {
            var mainIndex = 0;
            var leftIndex = 0;
            var rightIndex = 0;

            while (leftIndex < left.Length && rightIndex < right.Length)
            {
                var compResult = comparer.Compare(left[leftIndex], right[rightIndex]);
                array[mainIndex++] = compResult <= 0 ? left[leftIndex++] : right[rightIndex++];
            }

            while (leftIndex < left.Length)
            {
                array[mainIndex++] = left[leftIndex++];
            }

            while (rightIndex < right.Length)
            {
                array[mainIndex++] = right[rightIndex++];
            }
        }

        private static (T[] left, T[] right) Split(T[] array)
        {
            var mid = array.Length / 2;
            return (array.Take(mid).ToArray(), array.Skip(mid).ToArray());
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public class BinaryInsertionSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 1; i < array.Length; i++)
            {
                var target = array[i];
                var moveIndex = i - 1;
                var targetInsertLocation = BinarySearch(array, 0, moveIndex, target, comparer);
                Array.Copy(array, targetInsertLocation, array, targetInsertLocation + 1, i - targetInsertLocation);

                array[targetInsertLocation] = target;
            }
        }

        
        
        
        
        
        
        
        
        
        
        private static int BinarySearch(T[] array, int from, int to, T target, IComparer<T> comparer)
        {
            var left = from;
            var right = to;
            while (right > left)
            {
                var middle = (left + right) / 2;
                var comparisonResult = comparer.Compare(target, array[middle]);

                if (comparisonResult == 0)
                {
                    return middle + 1;
                }

                if (comparisonResult > 0)
                {
                    left = middle + 1;
                }
                else
                {
                    right = middle - 1;
                }
            }

            return comparer.Compare(target, array[left]) < 0 ? left : left + 1;
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public abstract class QuickSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer) => Sort(array, comparer, 0, array.Length - 1);

        protected abstract T SelectPivot(T[] array, IComparer<T> comparer, int left, int right);

        private void Sort(T[] array, IComparer<T> comparer, int left, int right)
        {
            if (left >= right)
            {
                return;
            }

            var p = Partition(array, comparer, left, right);
            Sort(array, comparer, left, p);
            Sort(array, comparer, p + 1, right);
        }

        private int Partition(T[] array, IComparer<T> comparer, int left, int right)
        {
            var pivot = SelectPivot(array, comparer, left, right);
            var nleft = left;
            var nright = right;
            while (true)
            {
                while (comparer.Compare(array[nleft], pivot) < 0)
                {
                    nleft++;
                }

                while (comparer.Compare(array[nright], pivot) > 0)
                {
                    nright--;
                }

                if (nleft >= nright)
                {
                    return nright;
                }

                var t = array[nleft];
                array[nleft] = array[nright];
                array[nright] = t;

                nleft++;
                nright--;
            }
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    public class TimSorter<T> : IComparisonSorter<T>
    {
        private readonly int minMerge;
        private readonly int initMinGallop;
        private readonly int[] runBase;
        private readonly int[] runLengths;

        private int minGallop;
        private int stackSize;

        private IComparer<T> comparer = default!;

        
        
        
        
        private class TimChunk<Tc>
        {
            public Tc[] Array { get; set; } = default!;

            public int Index { get; set; }

            public int Remaining { get; set; }

            public int Wins { get; set; }
        }

        public TimSorter(int minMerge = 32, int minGallop = 7)
        {
            initMinGallop = minGallop;
            this.minMerge = minMerge;
            runBase = new int[85];
            runLengths = new int[85];

            stackSize = 0;
            this.minGallop = minGallop;
        }

        
        
        
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            this.comparer = comparer;
            var start = 0;
            var remaining = array.Length;

            if (remaining < minMerge)
            {
                if (remaining < 2)
                {
                    
                    return;
                }

                
                BinarySort(array, start, remaining, start);
                return;
            }

            var minRun = MinRunLength(remaining, minMerge);

            do
            {
                
                var runLen = CountRunAndMakeAscending(array, start);

                
                if (runLen < minRun)
                {
                    var force = Math.Min(minRun, remaining);
                    BinarySort(array, start, start + force, start + runLen);
                    runLen = force;
                }

                runBase[stackSize] = start;
                runLengths[stackSize] = runLen;
                stackSize++;

                MergeCollapse(array);

                start += runLen;
                remaining -= runLen;
            }
            while (remaining != 0);

            MergeForceCollapse(array);
        }

        
        
        
        
        
        
        
        
        
        
        
        
        private static int MinRunLength(int total, int minRun)
        {
            var r = 0;
            while (total >= minRun)
            {
                r |= total & 1;
                total >>= 1;
            }

            return total + r;
        }

        
        
        
        
        
        
        private static void ReverseRange(T[] array, int start, int end)
        {
            end--;
            while (start < end)
            {
                var t = array[start];
                array[start++] = array[end];
                array[end--] = t;
            }
        }

        
        
        
        
        
        private static int BoundLeftShift(int shiftable) => (shiftable << 1) < 0
                ? (shiftable << 1) + 1
                : int.MaxValue;

        
        
        
        
        
        
        
        private static bool NeedsMerge(TimChunk<T> left, TimChunk<T> right, ref int dest)
        {
            right.Array[dest++] = right.Array[right.Index++];
            if (--right.Remaining == 0)
            {
                Array.Copy(left.Array, left.Index, right.Array, dest, left.Remaining);
                return false;
            }

            if (left.Remaining == 1)
            {
                Array.Copy(right.Array, right.Index, right.Array, dest, right.Remaining);
                right.Array[dest + right.Remaining] = left.Array[left.Index];
                return false;
            }

            return true;
        }

        
        
        
        
        
        
        private static void FinalizeMerge(TimChunk<T> left, TimChunk<T> right, int dest)
        {
            if (left.Remaining == 1)
            {
                Array.Copy(right.Array, right.Index, right.Array, dest, right.Remaining);
                right.Array[dest + right.Remaining] = left.Array[left.Index];
            }
            else if (left.Remaining == 0)
            {
                throw new ArgumentException("Comparison method violates its general contract!");
            }
            else
            {
                Array.Copy(left.Array, left.Index, right.Array, dest, left.Remaining);
            }
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        private int CountRunAndMakeAscending(T[] array, int start)
        {
            var runHi = start + 1;
            if (runHi == array.Length)
            {
                return 1;
            }

            
            if (comparer.Compare(array[runHi++], array[start]) < 0)
            { 
                while (runHi < array.Length && comparer.Compare(array[runHi], array[runHi - 1]) < 0)
                {
                    runHi++;
                }

                ReverseRange(array, start, runHi);
            }
            else
            { 
                while (runHi < array.Length && comparer.Compare(array[runHi], array[runHi - 1]) >= 0)
                {
                    runHi++;
                }
            }

            return runHi - start;
        }

        
        
        
        
        
        
        
        
        
        private int GallopLeft(T[] array, T key, int i, int len, int hint)
        {
            var (offset, lastOfs) = comparer.Compare(key, array[i + hint]) > 0
                ? RightRun(array, key, i, len, hint, 0)
                : LeftRun(array, key, i, hint, 1);

            return FinalOffset(array, key, i, offset, lastOfs, 1);
        }

        
        
        
        
        
        
        
        
        
        private int GallopRight(T[] array, T key, int i, int len, int hint)
        {
            var (offset, lastOfs) = comparer.Compare(key, array[i + hint]) < 0
                ? LeftRun(array, key, i, hint, 0)
                : RightRun(array, key, i, len, hint, -1);

            return FinalOffset(array, key, i, offset, lastOfs, 0);
        }

        private (int offset, int lastOfs) LeftRun(T[] array, T key, int i, int hint, int lt)
        {
            var maxOfs = hint + 1;
            var (offset, tmp) = (1, 0);

            while (offset < maxOfs && comparer.Compare(key, array[i + hint - offset]) < lt)
            {
                tmp = offset;
                offset = BoundLeftShift(offset);
            }

            if (offset > maxOfs)
            {
                offset = maxOfs;
            }

            var lastOfs = hint - offset;
            offset = hint - tmp;

            return (offset, lastOfs);
        }

        private (int offset, int lastOfs) RightRun(T[] array, T key, int i, int len, int hint, int gt)
        {
            var (offset, lastOfs) = (1, 0);
            var maxOfs = len - hint;
            while (offset < maxOfs && comparer.Compare(key, array[i + hint + offset]) > gt)
            {
                lastOfs = offset;
                offset = BoundLeftShift(offset);
            }

            if (offset > maxOfs)
            {
                offset = maxOfs;
            }

            offset += hint;
            lastOfs += hint;

            return (offset, lastOfs);
        }

        private int FinalOffset(T[] array, T key, int i, int offset, int lastOfs, int lt)
        {
            lastOfs++;
            while (lastOfs < offset)
            {
                var m = lastOfs + (int)((uint)(offset - lastOfs) >> 1);

                if (comparer.Compare(key, array[i + m]) < lt)
                {
                    offset = m;
                }
                else
                {
                    lastOfs = m + 1;
                }
            }

            return offset;
        }

        
        
        
        
        
        
        
        
        private void BinarySort(T[] array, int start, int end, int first)
        {
            if (first >= end || first <= start)
            {
                first = start + 1;
            }

            for (; first < end; first++)
            {
                var target = array[first];
                var targetInsertLocation = BinarySearch(array, start, first - 1, target);
                Array.Copy(array, targetInsertLocation, array, targetInsertLocation + 1, first - targetInsertLocation);

                array[targetInsertLocation] = target;
            }
        }

        private int BinarySearch(T[] array, int left, int right, T target)
        {
            while (left < right)
            {
                var mid = (left + right) >> 1;
                if (comparer.Compare(target, array[mid]) < 0)
                {
                    right = mid;
                }
                else
                {
                    left = mid + 1;
                }
            }

            return comparer.Compare(target, array[left]) < 0
                ? left
                : left + 1;
        }

        private void MergeCollapse(T[] array)
        {
            while (stackSize > 1)
            {
                var n = stackSize - 2;
                if (n > 0 && runLengths[n - 1] <= runLengths[n] + runLengths[n + 1])
                {
                    if (runLengths[n - 1] < runLengths[n + 1])
                    {
                        n--;
                    }

                    MergeAt(array, n);
                }
                else if (runLengths[n] <= runLengths[n + 1])
                {
                    MergeAt(array, n);
                }
                else
                {
                    break;
                }
            }
        }

        private void MergeForceCollapse(T[] array)
        {
            while (stackSize > 1)
            {
                var n = stackSize - 2;
                if (n > 0 && runLengths[n - 1] < runLengths[n + 1])
                {
                    n--;
                }

                MergeAt(array, n);
            }
        }

        private void MergeAt(T[] array, int index)
        {
            var baseA = runBase[index];
            var lenA = runLengths[index];
            var baseB = runBase[index + 1];
            var lenB = runLengths[index + 1];

            runLengths[index] = lenA + lenB;

            if (index == stackSize - 3)
            {
                runBase[index + 1] = runBase[index + 2];
                runLengths[index + 1] = runLengths[index + 2];
            }

            stackSize--;

            var k = GallopRight(array, array[baseB], baseA, lenA, 0);

            baseA += k;
            lenA -= k;

            if (lenA <= 0)
            {
                return;
            }

            lenB = GallopLeft(array, array[baseA + lenA - 1], baseB, lenB, lenB - 1);

            if (lenB <= 0)
            {
                return;
            }

            Merge(array, baseA, lenA, baseB, lenB);
        }

        private void Merge(T[] array, int baseA, int lenA, int baseB, int lenB)
        {
            var endA = baseA + lenA;
            var dest = baseA;

            TimChunk<T> left = new()
            {
                Array = array[baseA..endA],
                Remaining = lenA,
            };

            TimChunk<T> right = new()
            {
                Array = array,
                Index = baseB,
                Remaining = lenB,
            };

            
            if (!TimSorter<T>.NeedsMerge(left, right, ref dest))
            {
                
                return;
            }

            var gallop = minGallop;

            while (RunMerge(left, right, ref dest, ref gallop))
            {
                
                gallop = gallop > 0
                    ? gallop + 2
                    : 2;
            }

            minGallop = gallop >= 1
                ? gallop
                : 1;

            FinalizeMerge(left, right, dest);
        }

        private bool RunMerge(TimChunk<T> left, TimChunk<T> right, ref int dest, ref int gallop)
        {
            
            left.Wins = 0;
            right.Wins = 0;

            
            if (StableMerge(left, right, ref dest, gallop))
            {
                
                return false;
            }

            
            
            do
            {
                if (GallopMerge(left, right, ref dest))
                {
                    
                    return false;
                }

                
                gallop--;
            }
            while (left.Wins >= initMinGallop || right.Wins >= initMinGallop);

            return true;
        }

        private bool StableMerge(TimChunk<T> left, TimChunk<T> right, ref int dest, int gallop)
        {
            do
            {
                if (comparer.Compare(right.Array[right.Index], left.Array[left.Index]) < 0)
                {
                    right.Array[dest++] = right.Array[right.Index++];
                    right.Wins++;
                    left.Wins = 0;
                    if (--right.Remaining == 0)
                    {
                        return true;
                    }
                }
                else
                {
                    right.Array[dest++] = left.Array[left.Index++];
                    left.Wins++;
                    right.Wins = 0;
                    if (--left.Remaining == 1)
                    {
                        return true;
                    }
                }
            }
            while ((left.Wins | right.Wins) < gallop);

            return false;
        }

        private bool GallopMerge(TimChunk<T> left, TimChunk<T> right, ref int dest)
        {
            left.Wins = GallopRight(left.Array, right.Array[right.Index], left.Index, left.Remaining, 0);
            if (left.Wins != 0)
            {
                Array.Copy(left.Array, left.Index, right.Array, dest, left.Wins);
                dest += left.Wins;
                left.Index += left.Wins;
                left.Remaining -= left.Wins;
                if (left.Remaining <= 1)
                {
                    return true;
                }
            }

            right.Array[dest++] = right.Array[right.Index++];
            if (--right.Remaining == 0)
            {
                return true;
            }

            right.Wins = GallopLeft(right.Array, left.Array[left.Index], right.Index, right.Remaining, 0);
            if (right.Wins != 0)
            {
                Array.Copy(right.Array, right.Index, right.Array, dest, right.Wins);
                dest += right.Wins;
                right.Index += right.Wins;
                right.Remaining -= right.Wins;
                if (right.Remaining == 0)
                {
                    return true;
                }
            }

            right.Array[dest++] = left.Array[left.Index++];
            if (--left.Remaining == 1)
            {
                return true;
            }

            return false;
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public class ExchangeSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                for (var j = i + 1; j < array.Length; j++)
                {
                    if (comparer.Compare(array[i], array[j]) > 0)
                    {
                        (array[j], array[i]) = (array[i], array[j]);
                    }
                }
            }
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    
    public class CocktailSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer) => CocktailSort(array, comparer);

        private static void CocktailSort(IList<T> array, IComparer<T> comparer)
        {
            var swapped = true;

            var startIndex = 0;
            var endIndex = array.Count - 1;

            while (swapped)
            {
                for (var i = startIndex; i < endIndex; i++)
                {
                    if (comparer.Compare(array[i], array[i + 1]) != 1)
                    {
                        continue;
                    }

                    var highValue = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = highValue;
                }

                endIndex--;
                swapped = false;

                for (var i = endIndex; i > startIndex; i--)
                {
                    if (comparer.Compare(array[i], array[i - 1]) != -1)
                    {
                        continue;
                    }

                    var highValue = array[i];
                    array[i] = array[i - 1];
                    array[i - 1] = highValue;

                    swapped = true;
                }

                startIndex++;
            }
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public sealed class MiddlePointQuickSorter<T> : QuickSorter<T>
    {
        protected override T SelectPivot(T[] array, IComparer<T> comparer, int left, int right) =>
            array[left + (right - left) / 2];
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public class InsertionSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                var imin = i;
                for (var j = i + 1; j < array.Length; j++)
                {
                    if (comparer.Compare(array[j], array[imin]) < 0)
                    {
                        imin = j;
                    }
                }

                var t = array[imin];
                array[imin] = array[i];
                array[i] = t;
            }
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public class ShellSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var step = array.Length / 2; step > 0; step /= 2)
            {
                for (var i = 0; i < step; i++)
                {
                    GappedBubbleSort(array, comparer, i, step);
                }
            }
        }

        private static void GappedBubbleSort(T[] array, IComparer<T> comparer, int start, int step)
        {
            for (var j = start; j < array.Length - step; j += step)
            {
                var wasChanged = false;
                for (var k = start; k < array.Length - j - step; k += step)
                {
                    if (comparer.Compare(array[k], array[k + step]) > 0)
                    {
                        var temp = array[k];
                        array[k] = array[k + step];
                        array[k + step] = temp;
                        wasChanged = true;
                    }
                }

                if (!wasChanged)
                {
                    break;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    
    public class HeapSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer) => HeapSort(array, comparer);

        private static void HeapSort(IList<T> data, IComparer<T> comparer)
        {
            var heapSize = data.Count;
            for (var p = (heapSize - 1) / 2; p >= 0; p--)
            {
                MakeHeap(data, heapSize, p, comparer);
            }

            for (var i = data.Count - 1; i > 0; i--)
            {
                var temp = data[i];
                data[i] = data[0];
                data[0] = temp;

                heapSize--;
                MakeHeap(data, heapSize, 0, comparer);
            }
        }

        private static void MakeHeap(IList<T> input, int heapSize, int index, IComparer<T> comparer)
        {
            var rIndex = index;

            while (true)
            {
                var left = (rIndex + 1) * 2 - 1;
                var right = (rIndex + 1) * 2;
                var largest = left < heapSize && comparer.Compare(input[left], input[rIndex]) == 1 ? left : rIndex;

                
                if (right < heapSize && comparer.Compare(input[right], input[largest]) == 1)
                {
                    largest = right;
                }

                if (largest == rIndex)
                {
                    return;
                }

                
                var temp = input[rIndex];
                input[rIndex] = input[largest];
                input[largest] = temp;

                rIndex = largest;
            }
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    
    
    
    
    public class CycleSorter<T> : IComparisonSorter<T>
    {
        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                MoveCycle(array, i, comparer);
            }
        }

        private static void MoveCycle(T[] array, int startingIndex, IComparer<T> comparer)
        {
            var item = array[startingIndex];
            var pos = startingIndex + CountSmallerElements(array, startingIndex + 1, item, comparer);

            if (pos == startingIndex)
            {
                return;
            }

            pos = SkipSameElements(array, pos, item, comparer);

            var temp = array[pos];
            array[pos] = item;
            item = temp;

            while (pos != startingIndex)
            {
                pos = startingIndex + CountSmallerElements(array, startingIndex + 1, item, comparer);
                pos = SkipSameElements(array, pos, item, comparer);

                temp = array[pos];
                array[pos] = item;
                item = temp;
            }
        }

        private static int SkipSameElements(T[] array, int nextIndex, T item, IComparer<T> comparer)
        {
            while (comparer.Compare(array[nextIndex], item) == 0)
            {
                nextIndex++;
            }

            return nextIndex;
        }

        private static int CountSmallerElements(T[] array, int startingIndex, T element, IComparer<T> comparer)
        {
            var smallerElements = 0;
            for (var i = startingIndex; i < array.Length; i++)
            {
                if (comparer.Compare(array[i], element) < 0)
                {
                    smallerElements++;
                }
            }

            return smallerElements;
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.Comparison
{
    
    
    
    
    public class BogoSorter<T> : IComparisonSorter<T>
    {
        private readonly Random random = new();

        
        
        
        
        
        public void Sort(T[] array, IComparer<T> comparer)
        {
            while (!IsSorted(array, comparer))
            {
                Shuffle(array);
            }
        }

        private bool IsSorted(T[] array, IComparer<T> comparer)
        {
            for (var i = 0; i < array.Length - 1; i++)
            {
                if (comparer.Compare(array[i], array[i + 1]) > 0)
                {
                    return false;
                }
            }

            return true;
        }

        private void Shuffle(T[] array)
        {
            var taken = new bool[array.Length];
            var newArray = new T[array.Length];
            for (var i = 0; i < array.Length; i++)
            {
                int nextPos;
                do
                {
                    nextPos = random.Next(0, int.MaxValue) % array.Length;
                }
                while (taken[nextPos]);

                taken[nextPos] = true;
                newArray[nextPos] = array[i];
            }

            for (var i = 0; i < array.Length; i++)
            {
                array[i] = newArray[i];
            }
        }
    }
}
namespace Algorithms.Sorters.String
{
    
    
    
    
    
    
    
    
    public class MsdRadixStringSorter : IStringSorter
    {
        
        
        
        
        public void Sort(string[] array) => Sort(array, 0, array.Length - 1, 0, new string[array.Length]);

        private static void Sort(string[] array, int l, int r, int d, string[] temp)
        {
            if (l >= r)
            {
                return;
            }

            const int k = 256;

            var count = new int[k + 2];
            for (var i = l; i <= r; i++)
            {
                var j = Key(array[i]);
                count[j + 2]++;
            }

            for (var i = 1; i < count.Length; i++)
            {
                count[i] += count[i - 1];
            }

            for (var i = l; i <= r; i++)
            {
                var j = Key(array[i]);
                temp[count[j + 1]++] = array[i];
            }

            for (var i = l; i <= r; i++)
            {
                array[i] = temp[i - l];
            }

            for (var i = 0; i < k; i++)
            {
                Sort(array, l + count[i], l + count[i + 1] - 1, d + 1, temp);
            }

            int Key(string s) => d >= s.Length ? -1 : s[d];
        }
    }
}
﻿namespace Algorithms.Sorters.String
{
    
    
    
    public interface IStringSorter
    {
        
        
        
        
        void Sort(string[] array);
    }
}
namespace Algorithms.Sorters.External.Storages
{
    public class IntInMemoryStorage : ISequentialStorage<int>
    {
        private readonly int[] storage;

        public IntInMemoryStorage(int[] array) => storage = array;

        public int Length => storage.Length;

        public ISequentialStorageReader<int> GetReader() => new InMemoryReader(storage);

        public ISequentialStorageWriter<int> GetWriter() => new InMemoryWriter(storage);

        private class InMemoryReader : ISequentialStorageReader<int>
        {
            private readonly int[] storage;
            private int offset;

            public InMemoryReader(int[] storage) => this.storage = storage;

            public void Dispose()
            {
                
            }

            public int Read() => storage[offset++];
        }

        private class InMemoryWriter : ISequentialStorageWriter<int>
        {
            private readonly int[] storage;
            private int offset;

            public InMemoryWriter(int[] storage) => this.storage = storage;

            public void Write(int value) => storage[offset++] = value;

            public void Dispose()
            {
                
            }
        }
    }
}
using System.IO;

namespace Algorithms.Sorters.External.Storages
{
    public class IntFileStorage : ISequentialStorage<int>
    {
        private readonly string filename;

        public IntFileStorage(string filename, int length)
        {
            Length = length;
            this.filename = filename;
        }

        public int Length { get; }

        public ISequentialStorageReader<int> GetReader() => new FileReader(filename);

        public ISequentialStorageWriter<int> GetWriter() => new FileWriter(filename);

        private class FileReader : ISequentialStorageReader<int>
        {
            private readonly BinaryReader reader;

            public FileReader(string filename) => reader = new BinaryReader(File.OpenRead(filename));

            public void Dispose() => reader.Dispose();

            public int Read() => reader.ReadInt32();
        }

        private class FileWriter : ISequentialStorageWriter<int>
        {
            private readonly BinaryWriter writer;

            public FileWriter(string filename) => writer = new BinaryWriter(File.OpenWrite(filename));

            public void Write(int value) => writer.Write(value);

            public void Dispose() => writer.Dispose();
        }
    }
}
namespace Algorithms.Sorters.External
{
    public interface ISequentialStorage<T>
    {
        public int Length { get; }

        ISequentialStorageReader<T> GetReader();

        ISequentialStorageWriter<T> GetWriter();
    }
}
using System;

namespace Algorithms.Sorters.External
{
    public interface ISequentialStorageWriter<in T> : IDisposable
    {
        void Write(T value);
    }
}
using System;

namespace Algorithms.Sorters.External
{
    public interface ISequentialStorageReader<out T> : IDisposable
    {
        T Read();
    }
}
using System.Collections.Generic;

namespace Algorithms.Sorters.External
{
    public interface IExternalSorter<T>
    {
        
        
        
        
        
        void Sort(ISequentialStorage<T> mainMemory, ISequentialStorage<T> temporaryMemory, IComparer<T> comparer);
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Sorters.External
{
    public class ExternalMergeSorter<T> : IExternalSorter<T>
    {
        public void Sort(
            ISequentialStorage<T> mainMemory,
            ISequentialStorage<T> temporaryMemory,
            IComparer<T> comparer)
        {
            var originalSource = mainMemory;
            var source = mainMemory;
            var temp = temporaryMemory;
            var totalLength = mainMemory.Length;
            for (var stripLength = 1L; stripLength < totalLength; stripLength *= 2)
            {
                using var left = source.GetReader();
                using var right = source.GetReader();
                using var output = temp.GetWriter();

                for (var i = 0L; i < stripLength; i++)
                {
                    right.Read();
                }

                Merge(left, right, output, stripLength, Math.Min(stripLength, totalLength - stripLength), comparer);
                var step = 2 * stripLength;
                long rightStripStart;
                for (rightStripStart = stripLength + step; rightStripStart < mainMemory.Length; rightStripStart += step)
                {
                    for (var i = 0L; i < stripLength; i++)
                    {
                        left.Read();
                        right.Read();
                    }

                    Merge(
                        left,
                        right,
                        output,
                        stripLength,
                        Math.Min(stripLength, totalLength - rightStripStart),
                        comparer);
                }

                for (var i = 0L; i < totalLength + stripLength - rightStripStart; i++)
                {
                    output.Write(right.Read());
                }

                (source, temp) = (temp, source);
            }

            if (source == originalSource)
            {
                return;
            }

            using var sorted = source.GetReader();
            using var dest = originalSource.GetWriter();
            for (var i = 0; i < totalLength; i++)
            {
                dest.Write(sorted.Read());
            }
        }

        private static void Merge(
            ISequentialStorageReader<T> left,
            ISequentialStorageReader<T> right,
            ISequentialStorageWriter<T> output,
            long leftLength,
            long rightLength,
            IComparer<T> comparer)
        {
            var leftIndex = 0L;
            var rightIndex = 0L;

            var l = left.Read();
            var r = right.Read();
            while (true)
            {
                if (comparer.Compare(l, r) < 0)
                {
                    output.Write(l);
                    leftIndex++;
                    if (leftIndex == leftLength)
                    {
                        break;
                    }

                    l = left.Read();
                }
                else
                {
                    output.Write(r);
                    rightIndex++;
                    if (rightIndex == rightLength)
                    {
                        break;
                    }

                    r = right.Read();
                }
            }

            if (leftIndex < leftLength)
            {
                output.Write(l);
                Copy(left, output, leftLength - leftIndex - 1);
            }

            if (rightIndex < rightLength)
            {
                output.Write(r);
                Copy(right, output, rightLength - rightIndex - 1);
            }
        }

        private static void Copy(ISequentialStorageReader<T> from, ISequentialStorageWriter<T> to, long count)
        {
            for (var i = 0; i < count; i++)
            {
                to.Write(from.Read());
            }
        }
    }
}
﻿using System;
using System.Collections.Generic;

namespace Algorithms.Search
{
    
    
    
    
    public class RecursiveBinarySearcher<T> where T : IComparable<T>
    {
        
        
        
        
        
        
        
        
        
        
        public int FindIndex(IList<T>? collection, T item)
        {
            if (collection is null)
            {
                throw new ArgumentNullException(nameof(collection));
            }

            var leftIndex = 0;
            var rightIndex = collection.Count - 1;

            return FindIndex(collection, item, leftIndex, rightIndex);
        }

        
        
        
        
        
        
        
        
        
        
        
        private int FindIndex(IList<T> collection, T item, int leftIndex, int rightIndex)
        {
            if (leftIndex > rightIndex)
            {
                return -1;
            }

            var middleIndex = leftIndex + (rightIndex - leftIndex) / 2;
            var result = item.CompareTo(collection[middleIndex]);

            return result switch
            {
                var r when r == 0 => middleIndex,
                var r when r > 0 => FindIndex(collection, item, middleIndex + 1, rightIndex),
                var r when r < 0 => FindIndex(collection, item, leftIndex, middleIndex - 1),
                _ => -1,
            };
        }
    }
}
using System;

namespace Algorithms.Search
{
    
    
    
    
    public class FibonacciSearcher<T> where T : IComparable<T>
    {
        
        
        
        
        
        
        
        
        
        
        
        public int FindIndex(T[] array, T item)
        {
            if (array is null)
            {
                throw new ArgumentNullException("array");
            }

            if (item is null)
            {
                throw new ArgumentNullException("item");
            }

            var arrayLength = array.Length;

            if (arrayLength > 0)
            {
                
                var fibonacciNumberBeyondPrevious = 0;
                var fibonacciNumPrevious = 1;
                var fibonacciNum = fibonacciNumPrevious;

                while (fibonacciNum <= arrayLength)
                {
                    fibonacciNumberBeyondPrevious = fibonacciNumPrevious;
                    fibonacciNumPrevious = fibonacciNum;
                    fibonacciNum = fibonacciNumberBeyondPrevious + fibonacciNumPrevious;
                }

                
                var offset = -1;

                while (fibonacciNum > 1)
                {
                    var index = Math.Min(offset + fibonacciNumberBeyondPrevious, arrayLength - 1);

                    switch (item.CompareTo(array[index]))
                    {
                        
                        
                        case > 0:
                            fibonacciNum = fibonacciNumPrevious;
                            fibonacciNumPrevious = fibonacciNumberBeyondPrevious;
                            fibonacciNumberBeyondPrevious = fibonacciNum - fibonacciNumPrevious;
                            offset = index;
                            break;

                        
                        
                        case < 0:
                            fibonacciNum = fibonacciNumberBeyondPrevious;
                            fibonacciNumPrevious = fibonacciNumPrevious - fibonacciNumberBeyondPrevious;
                            fibonacciNumberBeyondPrevious = fibonacciNum - fibonacciNumPrevious;
                            break;
                        default:
                            return index;
                    }
                }

                
                if (fibonacciNumPrevious == 1 && item.Equals(array[^1]))
                {
                    return arrayLength - 1;
                }
            }

            return -1;
        }
    }
}
﻿using System;
using System.Collections.Generic;


namespace Algorithms.Search.AStar
{
    
    
    
    
    
    
    
    
    public class PriorityQueue<T>
        where T : IComparable<T>
    {
        private readonly bool isDescending;

        
        private readonly List<T> list;

        public PriorityQueue(bool isDescending = false)
        {
            this.isDescending = isDescending;
            list = new List<T>();
        }

        
        
        
        
        
        public PriorityQueue(int capacity, bool isDescending = false)
        {
            list = new List<T>(capacity);
            this.isDescending = isDescending;
        }

        
        
        
        
        
        public PriorityQueue(IEnumerable<T> collection, bool isDescending = false)
            : this()
        {
            this.isDescending = isDescending;
            foreach (var item in collection)
            {
                Enqueue(item);
            }
        }

        
        
        
        public int Count => list.Count;

        
        
        
        
        public void Enqueue(T x)
        {
            list.Add(x);
            var i = Count - 1; 

            while (i > 0)
            {
                var p = (i - 1) / 2; 
                if ((isDescending ? -1 : 1) * list[p].CompareTo(x) <= 0)
                {
                    break;
                }

                list[i] = list[p]; 
                i = p; 
            }

            if (Count > 0)
            {
                list[i] = x; 
            }
        }

        
        
        
        
        public T Dequeue()
        {
            var target = Peek(); 
            var root = list[Count - 1]; 
            list.RemoveAt(Count - 1); 

            var i = 0;
            while (i * 2 + 1 < Count)
            {
                var a = i * 2 + 1; 
                var b = i * 2 + 2; 
                var c = b < Count && (isDescending ? -1 : 1) * list[b].CompareTo(list[a]) < 0
                    ? b
                    : a; 

                if ((isDescending ? -1 : 1) * list[c].CompareTo(root) >= 0)
                {
                    break;
                }

                list[i] = list[c];
                i = c;
            }

            if (Count > 0)
            {
                list[i] = root;
            }

            return target;
        }

        
        
        
        
        public T Peek()
        {
            if (Count == 0)
            {
                throw new InvalidOperationException("Queue is empty.");
            }

            return list[0];
        }

        
        
        
        public void Clear() => list.Clear();

        
        
        
        
        public List<T> GetData() => list;
    }
}
﻿using System;

namespace Algorithms.Search.AStar
{
    
    
    
    public class Node : IComparable<Node>, IEquatable<Node>
    {
        public Node(VecN position, bool traversable, double traverseMultiplier)
        {
            Traversable = traversable;
            Position = position;
            TraversalCostMultiplier = traverseMultiplier;
        }

        
        
        
        
        public double TotalCost => EstimatedCost + CurrentCost;

        
        
        
        public double EstimatedCost { get; set; }

        
        
        
        public double TraversalCostMultiplier { get; }

        
        
        
        public double CurrentCost { get; set; }

        
        
        
        
        public NodeState State { get; set; }

        
        
        
        public bool Traversable { get; }

        
        
        
        public Node[] ConnectedNodes { get; set; } = new Node[0];

        
        
        
        public Node? Parent { get; set; }

        
        
        
        public VecN Position { get; }

        
        
        
        
        
        
        
        
        public int CompareTo(Node? other) => TotalCost.CompareTo(other?.TotalCost ?? 0);

        public bool Equals(Node? other) => CompareTo(other) == 0;

        public static bool operator ==(Node left, Node right) => left?.Equals(right) != false;

        public static bool operator >(Node left, Node right) => left.CompareTo(right) > 0;

        public static bool operator <(Node left, Node right) => left.CompareTo(right) < 0;

        public static bool operator !=(Node left, Node right) => !(left == right);

        public static bool operator <=(Node left, Node right) => left.CompareTo(right) <= 0;

        public static bool operator >=(Node left, Node right) => left.CompareTo(right) >= 0;

        public override bool Equals(object? obj) => obj is Node other && Equals(other);

        public override int GetHashCode() =>
            Position.GetHashCode()
            + Traversable.GetHashCode()
            + TraversalCostMultiplier.GetHashCode();

        
        
        
        
        
        public double DistanceTo(Node other) => Math.Sqrt(Position.SqrDistance(other.Position));
    }
}
﻿namespace Algorithms.Search.AStar
{
    
    
    
    public enum NodeState
    {
        
        
        
        Unconsidered = 0,

        
        
        
        Open = 1,

        
        
        
        Closed = 2,
    }
}
﻿using System;

namespace Algorithms.Search.AStar
{
    
    
    
    public class PathfindingException : ApplicationException
    {
        public PathfindingException(string message)
            : base(message)
        {
        }
    }
}
﻿using System;

namespace Algorithms.Search.AStar
{
    
    
    
    public struct VecN : IEquatable<VecN>
    {
        private readonly double[] data;

        
        
        
        
        public VecN(params double[] vals) => data = vals;

        
        
        
        public int N => data.Length;

        
        
        
        
        public double SqrLength()
        {
            double ret = 0;
            for (var i = 0; i < data.Length; i++)
            {
                ret += data[i] * data[i];
            }

            return ret;
        }

        
        
        
        
        public double Length() => Math.Sqrt(SqrLength());

        
        
        
        
        
        public double Distance(VecN other)
        {
            var delta = Subtract(other);
            return delta.Length();
        }

        
        
        
        
        
        public double SqrDistance(VecN other)
        {
            var delta = Subtract(other);
            return delta.SqrLength();
        }

        
        
        
        
        
        public VecN Subtract(VecN other)
        {
            var dd = new double[Math.Max(data.Length, other.data.Length)];
            for (var i = 0; i < dd.Length; i++)
            {
                double val = 0;
                if (data.Length > i)
                {
                    val = data[i];
                }

                if (other.data.Length > i)
                {
                    val -= other.data[i];
                }

                dd[i] = val;
            }

            return new VecN(dd);
        }

        
        
        
        
        
        public bool Equals(VecN other)
        {
            if (other.N != N)
            {
                return false;
            }

            for (var i = 0; i < other.data.Length; i++)
            {
                if (Math.Abs(data[i] - other.data[i]) > 0.000001)
                {
                    return false;
                }
            }

            return true;
        }
    }
}
﻿using System.Collections.Generic;

namespace Algorithms.Search.AStar
{
    
    
    
    public static class AStar
    {
        
        
        
        
        public static void ResetNodes(List<Node> nodes)
        {
            foreach (var node in nodes)
            {
                node.CurrentCost = 0;
                node.EstimatedCost = 0;
                node.Parent = null;
                node.State = NodeState.Unconsidered;
            }
        }

        
        
        
        
        
        public static List<Node> GeneratePath(Node target)
        {
            var ret = new List<Node>();
            var current = target;
            while (!(current is null))
            {
                ret.Add(current);
                current = current.Parent;
            }

            ret.Reverse();
            return ret;
        }

        
        
        
        
        
        
        public static List<Node> Compute(Node from, Node to)
        {
            var done = new List<Node>();

            
            var open = new PriorityQueue<Node>();
            foreach (var node in from.ConnectedNodes)
            {
                
                if (node.Traversable)
                {
                    
                    node.CurrentCost = from.CurrentCost + from.DistanceTo(node) * node.TraversalCostMultiplier;
                    node.EstimatedCost = from.CurrentCost + node.DistanceTo(to);

                    
                    open.Enqueue(node);
                }
            }

            while (true)
            {
                
                if (open.Count == 0)
                {
                    ResetNodes(done);
                    ResetNodes(open.GetData());
                    return new List<Node>();
                }

                
                var current = open.Dequeue();

                
                done.Add(current);

                current.State = NodeState.Closed;

                
                if (current == to)
                {
                    var ret = GeneratePath(to); 

                    
                    ResetNodes(done);
                    ResetNodes(open.GetData());
                    return ret;
                }

                AddOrUpdateConnected(current, to, open);
            }
        }

        private static void AddOrUpdateConnected(Node current, Node to, PriorityQueue<Node> queue)
        {
            foreach (var connected in current.ConnectedNodes)
            {
                if (!connected.Traversable ||
                    connected.State == NodeState.Closed)
                {
                    continue; 
                }

                
                if (connected.State == NodeState.Unconsidered)
                {
                    connected.Parent = current;
                    connected.CurrentCost =
                        current.CurrentCost + current.DistanceTo(connected) * connected.TraversalCostMultiplier;
                    connected.EstimatedCost = connected.CurrentCost + connected.DistanceTo(to);
                    connected.State = NodeState.Open;
                    queue.Enqueue(connected);
                }
                else if (current != connected)
                {
                    
                    var newCCost = current.CurrentCost + current.DistanceTo(connected);
                    var newTCost = newCCost + current.EstimatedCost;
                    if (newTCost < connected.TotalCost)
                    {
                        connected.Parent = current;
                        connected.CurrentCost = newCCost;
                    }
                }
                else
                {
                    
                    throw new PathfindingException(
                        "Detected the same node twice. Confusion how this could ever happen");
                }
            }
        }
    }
}
﻿using System;

namespace Algorithms.Search
{
    
    
    
    
    public class BinarySearcher<T> where T : IComparable<T>
    {
        
        
        
        
        
        
        
        
        
        public int FindIndex(T[] sortedData, T item)
        {
            var leftIndex = 0;
            var rightIndex = sortedData.Length - 1;

            while (leftIndex <= rightIndex)
            {
                var middleIndex = leftIndex + (rightIndex - leftIndex) / 2;

                if (item.CompareTo(sortedData[middleIndex]) > 0)
                {
                    leftIndex = middleIndex + 1;
                    continue;
                }

                if (item.CompareTo(sortedData[middleIndex]) < 0)
                {
                    rightIndex = middleIndex - 1;
                    continue;
                }

                return middleIndex;
            }

            return -1;
        }
    }
}
using System;

namespace Algorithms.Search
{
    
    
    
    
    
    
    
    public class JumpSearcher<T> where T : IComparable<T>
    {
        
        
        
        
        
        
        public int FindIndex(T[] sortedArray, T searchItem)
        {
            if (sortedArray is null)
            {
                throw new ArgumentNullException("sortedArray");
            }

            if (searchItem is null)
            {
                throw new ArgumentNullException("searchItem");
            }

            int jumpStep = (int)Math.Floor(Math.Sqrt(sortedArray.Length));
            int currentIndex = 0;
            int nextIndex = jumpStep;

            if (sortedArray.Length != 0)
            {
                while (sortedArray[nextIndex - 1].CompareTo(searchItem) < 0)
                {
                    currentIndex = nextIndex;
                    nextIndex += jumpStep;

                    if (nextIndex >= sortedArray.Length)
                    {
                        nextIndex = sortedArray.Length - 1;
                        break;
                    }
                }

                for (int i = currentIndex; i <= nextIndex; i++)
                {
                    if (sortedArray[i].CompareTo(searchItem) == 0)
                    {
                        return i;
                    }
                }
            }

            return -1;
        }
    }
}
using System;
using Utilities.Exceptions;

namespace Algorithms.Search
{
    
    
    
    
    public class LinearSearcher<T>
    {
        
        
        
        
        
        
        
        
        public T Find(T[] data, Func<T, bool> term)
        {
            for (var i = 0; i < data.Length; i++)
            {
                if (term(data[i]))
                {
                    return data[i];
                }
            }

            throw new ItemNotFoundException();
        }

        
        
        
        
        
        
        
        
        public int FindIndex(T[] data, Func<T, bool> term)
        {
            for (var i = 0; i < data.Length; i++)
            {
                if (term(data[i]))
                {
                    return i;
                }
            }

            return -1;
        }
    }
}
﻿using System;
using Utilities.Exceptions;

namespace Algorithms.Search
{
    
    
    
    
    
    
    
    
    public class FastSearcher
    {
        
        
        
        
        
        
        
        
        public int FindIndex(Span<int> array, int item)
        {
            if (array.Length == 0)
            {
                throw new ItemNotFoundException();
            }

            if (item < array[0] || item > array[^1])
            {
                throw new ItemNotFoundException();
            }

            if (array[0] == array[^1])
            {
                return item == array[0] ? 0 : throw new ItemNotFoundException();
            }

            var (left, right) = ComputeIndices(array, item);
            var (from, to) = SelectSegment(array, left, right, item);

            return from + FindIndex(array.Slice(from, to - from + 1), item);
        }

        private (int left, int right) ComputeIndices(Span<int> array, int item)
        {
            var indexBinary = array.Length / 2;

            int[] section =
            {
                array.Length - 1,
                item - array[0],
                array[^1] - array[0],
            };
            var indexInterpolation = section[0] * section[1] / section[2];

            
            return indexInterpolation > indexBinary
                ? (indexBinary, indexInterpolation)
                : (indexInterpolation, indexBinary);
        }

        private (int from, int to) SelectSegment(Span<int> array, int left, int right, int item)
        {
            if (item < array[left])
            {
                return (0, left - 1);
            }

            if (item < array[right])
            {
                return (left, right - 1);
            }

            return (right, array.Length - 1);
        }
    }
}
using System;
using System.Linq;

namespace Algorithms.Numeric.Series
{
    
    
    
    
    
    
    public static class Maclaurin
    {
        
        
        
        
        
        
        
        
        
        public static double Exp(double x, int n) =>
            Enumerable.Range(0, n).Sum(i => ExpTerm(x, i));

        
        
        
        
        
        
        
        
        
        public static double Sin(double x, int n) =>
            Enumerable.Range(0, n).Sum(i => SinTerm(x, i));

        
        
        
        
        
        
        
        
        
        public static double Cos(double x, int n) =>
            Enumerable.Range(0, n).Sum(i => CosTerm(x, i));

        
        
        
        
        
        
        
        
        
        public static double Exp(double x, double error = 0.00001) => ErrorTermWrapper(x, error, ExpTerm);

        
        
        
        
        
        
        
        
        
        public static double Sin(double x, double error = 0.00001) => ErrorTermWrapper(x, error, SinTerm);

        
        
        
        
        
        
        
        
        
        public static double Cos(double x, double error = 0.00001) => ErrorTermWrapper(x, error, CosTerm);

        
        
        
        
        
        
        
        
        
        private static double ErrorTermWrapper(double x, double error, Func<double, int, double> term)
        {
            if (error <= 0.0 || error >= 1.0)
            {
                throw new ArgumentException("Error value is not on interval (0.0; 1.0).");
            }

            var i = 0;
            var termCoefficient = 0.0;
            var result = 0.0;

            do
            {
                result += termCoefficient;
                termCoefficient = term(x, i);
                i++;
            }
            while (Math.Abs(termCoefficient) > error);

            return result;
        }

        
        
        
        
        
        
        private static double ExpTerm(double x, int i) => Math.Pow(x, i) / Factorial.Calculate(i);

        
        
        
        
        
        
        private static double SinTerm(double x, int i) =>
            Math.Pow(-1, i) / Factorial.Calculate(2 * i + 1) * Math.Pow(x, 2 * i + 1);

        
        
        
        
        
        
        private static double CosTerm(double x, int i) =>
            Math.Pow(-1, i) / Factorial.Calculate(2 * i) * Math.Pow(x, 2 * i);
    }
}
using System;

namespace Algorithms.Numeric
{
    
    
    
    
    
    public static class KeithNumberChecker
    {
        
        
        
        
        
        public static bool IsKeithNumber(int number)
        {
            if (number < 0)
            {
                throw new ArgumentException($"{nameof(number)} cannot be negative");
            }

            var tempNumber = number;

            var stringNumber = number.ToString();

            var digitsInNumber = stringNumber.Length;

            */
            var termsArray = new int[number];

            for (var i = digitsInNumber - 1; i >= 0; i--)
            {
                termsArray[i] = tempNumber % 10;
                tempNumber /= 10;
            }

            var sum = 0;
            var k = digitsInNumber;
            while (sum < number)
            {
                sum = 0;

                for (var j = 1; j <= digitsInNumber; j++)
                {
                    sum += termsArray[k - j];
                }

                termsArray[k] = sum;
                k++;
            }

            return sum == number;
        }
    }
}
﻿using System;

namespace Algorithms.Numeric
{
    
    
    
    
    public static class NarcissisticNumberChecker
    {
        
        
        
        
        
        public static bool IsNarcissistic(int number)
        {
            var sum = 0;
            var temp = number;
            var numberOfDigits = 0;
            while (temp != 0)
            {
                numberOfDigits++;
                temp /= 10;
            }

            temp = number;
            while (number > 0)
            {
                var remainder = number % 10;
                var power = (int)Math.Pow(remainder, numberOfDigits);

                sum += power;
                number /= 10;
            }

            return sum == temp;
        }
    }
}
﻿using System;

namespace Algorithms.Numeric
{
    
    
    
    public static class PerfectSquareChecker
    {
        
        
        
        
        
        public static bool IsPerfectSquare(int number)
        {
            if (number < 0)
            {
                return false;
            }

            var sqrt = (int)Math.Sqrt(number);
            return sqrt * sqrt == number;
        }
    }
}
﻿namespace Algorithms.Numeric.Factorization
{
    
    
    
    public interface IFactorizer
    {
        
        
        
        
        
        
        bool TryFactor(int n, out int factor);
    }
}
﻿using System;
using System.Linq;

namespace Algorithms.Numeric.Factorization
{
    
    
    
    public class TrialDivisionFactorizer : IFactorizer
    {
        
        
        
        
        
        
        public bool TryFactor(int n, out int factor)
        {
            n = Math.Abs(n);
            factor = Enumerable.Range(2, (int)Math.Sqrt(n) - 1).FirstOrDefault(i => n % i == 0);
            return factor != 0;
        }
    }
}
using System;

namespace Algorithms.Numeric
{
    
    
    
    
    
    public class ModularExponentiation
    {
        
        
        
        
        
        
        
        public int ModularPow(int b, int e, int m)
        {
            
            int res = 1;
            if (m == 1)
            {
                
                return 0;
            }

            if (m <= 0)
            {
                
                throw new ArgumentException(string.Format("{0} is not a positive integer", m));
            }

            for (int i = 0; i < e; i++)
            {
                res = (res * b) % m;
            }

            return res;
        }
    }
}
﻿using System;
using Algorithms.Numeric.Decomposition;
using Utilities.Extensions;

namespace Algorithms.Numeric.Pseudoinverse
{
    
    
    
    
    
    
    
    public static class PseudoInverse
    {
        
        
        
        
        
        
        public static double[,] PInv(double[,] inMat)
        {
            
            var (u, s, v) = ThinSvd.Decompose(inMat);

            
            var len = s.Length;

            var sigma = new double[len];
            for (var i = 0; i < len; i++)
            {
                sigma[i] = Math.Abs(s[i]) < 0.0001 ? 0 : 1 / s[i];
            }

            
            var diag = sigma.ToDiagonalMatrix();

            
            var matinv = u.Multiply(diag).Multiply(v.Transpose());

            
            return matinv.Transpose();
        }
    }
}
﻿using System;

namespace Algorithms.Numeric
{
    
    
    
    
    public static class BinomialCoefficient
    {
        
        
        
        
        
        
        public static long Calculate(int num, int k)
        {
            if (num < k || k < 0)
            {
                throw new ArgumentException("n ≥ k ≥ 0");
            }

            return Factorial.Calculate(num) / (Factorial.Calculate(k) * Factorial.Calculate(num - k));
        }
    }
}
using System;

namespace Algorithms.Numeric.GreatestCommonDivisor
{
    
    
    
    
    
    public class BinaryGreatestCommonDivisorFinder : IGreatestCommonDivisorFinder
    {
        public int FindGcd(int u, int v)
        {
            
            if (u == 0 && v == 0)
            {
                return 0;
            }

            
            if (u == 0 || v == 0)
            {
                return u + v;
            }

            
            u = Math.Sign(u) * u;
            v = Math.Sign(v) * v;

            
            var shift = 0;
            while (((u | v) & 1) == 0)
            {
                u >>= 1;
                v >>= 1;
                shift++;
            }

            while ((u & 1) == 0)
            {
                u >>= 1;
            }

            
            do
            {
                
                
                while ((v & 1) == 0)
                {
                    v >>= 1;
                }

                
                if (u > v)
                {
                    var t = v;
                    v = u;
                    u = t;
                }

                
                v -= u;
            }
            while (v != 0);

            
            return u << shift;
        }
    }
}
﻿namespace Algorithms.Numeric.GreatestCommonDivisor
{
    public interface IGreatestCommonDivisorFinder
    {
        int FindGcd(int a, int b);
    }
}
namespace Algorithms.Numeric.GreatestCommonDivisor
{
    
    
    
    public class EuclideanGreatestCommonDivisorFinder : IGreatestCommonDivisorFinder
    {
        
        
        
        
        
        
        
        public int FindGcd(int a, int b)
        {
            if (a == 0 && b == 0)
            {
                return int.MaxValue;
            }

            if (a == 0 || b == 0)
            {
                return a + b;
            }

            var aa = a;
            var bb = b;
            var cc = aa % bb;

            while (cc != 0)
            {
                aa = bb;
                bb = cc;
                cc = aa % bb;
            }

            return bb;
        }
    }
}
﻿using System;

namespace Algorithms.Numeric
{
    
    
    
    public class GaussJordanElimination
    {
        private int RowCount { get; set; }

        
        
        
        
        
        
        
        
        public bool Solve(double[,] matrix)
        {
            RowCount = matrix.GetUpperBound(0) + 1;

            if (!CanMatrixBeUsed(matrix))
            {
                throw new ArgumentException("Please use a n*(n+1) matrix with Length > 0.");
            }

            var pivot = PivotMatrix(ref matrix);
            if (!pivot)
            {
                return false;
            }

            Elimination(ref matrix);

            return ElementaryReduction(ref matrix);
        }

        
        
        
        
        
        
        
        
        private bool CanMatrixBeUsed(double[,] matrix) => matrix?.Length == RowCount * (RowCount + 1) && RowCount > 1;

        
        
        
        
        
        private bool PivotMatrix(ref double[,] matrix)
        {
            for (var col = 0; col + 1 < RowCount; col++)
            {
                if (matrix[col, col] == 0)
                {
                    
                    var rowToSwap = FindNonZeroCoefficient(ref matrix, col);

                    if (matrix[rowToSwap, col] != 0)
                    {
                        var tmp = new double[RowCount + 1];
                        for (var i = 0; i < RowCount + 1; i++)
                        {
                            
                            tmp[i] = matrix[rowToSwap, i];
                            matrix[rowToSwap, i] = matrix[col, i];
                            matrix[col, i] = tmp[i];
                        }
                    }
                    else
                    {
                        
                        return false;
                    }
                }
            }

            return true;
        }

        private int FindNonZeroCoefficient(ref double[,] matrix, int col)
        {
            var rowToSwap = col + 1;

            
            for (; rowToSwap < RowCount; rowToSwap++)
            {
                if (matrix[rowToSwap, col] != 0)
                {
                    return rowToSwap;
                }
            }

            return col + 1;
        }

        
        
        
        
        private void Elimination(ref double[,] matrix)
        {
            for (var srcRow = 0; srcRow + 1 < RowCount; srcRow++)
            {
                for (var destRow = srcRow + 1; destRow < RowCount; destRow++)
                {
                    var df = matrix[srcRow, srcRow];
                    var sf = matrix[destRow, srcRow];

                    for (var i = 0; i < RowCount + 1; i++)
                    {
                        matrix[destRow, i] = matrix[destRow, i] * df - matrix[srcRow, i] * sf;
                    }
                }
            }
        }

        
        
        
        
        
        private bool ElementaryReduction(ref double[,] matrix)
        {
            for (var row = RowCount - 1; row >= 0; row--)
            {
                var element = matrix[row, row];
                if (element == 0)
                {
                    return false;
                }

                for (var i = 0; i < RowCount + 1; i++)
                {
                    matrix[row, i] /= element;
                }

                for (var destRow = 0; destRow < row; destRow++)
                {
                    matrix[destRow, RowCount] -= matrix[destRow, row] * matrix[row, RowCount];
                    matrix[destRow, row] = 0;
                }
            }

            return true;
        }
    }
}
using System;
using System.Numerics;

namespace Algorithms.Numeric
{
    
    
    
    
    
    
    
    
    public static class MillerRabinPrimalityChecker
    {
        
        
        
        
        
        
        
        public static bool IsProbablyPrimeNumber(BigInteger n, BigInteger rounds)
        {
            if (n <= 3)
            {
                throw new ArgumentException($"{nameof(n)} should be more than 3");
            }

            
            
            
            

            
            BigInteger r = 0;
            BigInteger d = n - 1;
            while (d % 2 == 0)
            {
                r++;
                d /= 2;
            }

            BigInteger x;
            Random rand = new();

            
            int nMaxValue = (n > int.MaxValue) ? int.MaxValue : (int)n;
            BigInteger a = rand.Next(2, nMaxValue - 2); 

            while (rounds > 0)
            {
                rounds--;
                x = BigInteger.ModPow(a, d, n);
                if (x == 1 || x == (n - 1))
                {
                    continue;
                }

                BigInteger tempr = r - 1;
                while (tempr > 0 && (x != n - 1))
                {
                    tempr--;
                    x = BigInteger.ModPow(x, 2, n);
                }

                if (x == n - 1)
                {
                    continue;
                }

                return false;
            }

            return true;
        }
    }
}
﻿using System;

namespace Algorithms.Numeric
{
    
    
    
    
    
    public static class PerfectNumberChecker
    {
        
        
        
        
        
        
        public static bool IsPerfectNumber(int number)
        {
            if (number < 0)
            {
                throw new ArgumentException($"{nameof(number)} cannot be negative");
            }

            var sum = 0; */
            for (var i = 1; i < number; ++i)
            {
                if (number % i == 0)
                {
                    sum += i;
                }
            }

            return sum == number;
        }
    }
}
using System;
using System.Collections.Generic;

namespace Algorithms.Numeric
{
    
    
    
    
    
    
    
    
    
    
    
    public static class EulerMethod
    {
        
        
        
        
        
        
        
        
        
        
        public static List<double[]> EulerFull(
            double xStart,
            double xEnd,
            double stepSize,
            double yStart,
            Func<double, double, double> yDerivative)
        {
            if (xStart >= xEnd)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(xEnd),
                    $"{nameof(xEnd)} should be greater than {nameof(xStart)}");
            }

            if (stepSize <= 0)
            {
                throw new ArgumentOutOfRangeException(
                    nameof(stepSize),
                    $"{nameof(stepSize)} should be greater than zero");
            }

            List<double[]> points = new();
            double[] firstPoint = { xStart, yStart };
            points.Add(firstPoint);
            var yCurrent = yStart;
            var xCurrent = xStart;

            while (xCurrent < xEnd)
            {
                yCurrent = EulerStep(xCurrent, stepSize, yCurrent, yDerivative);
                xCurrent += stepSize;
                double[] point = { xCurrent, yCurrent };
                points.Add(point);
            }

            return points;
        }

        
        
        
        
        
        
        
        
        private static double EulerStep(
            double xCurrent,
            double stepSize,
            double yCurrent,
            Func<double, double, double> yDerivative)
        {
            var yNext = yCurrent + stepSize * yDerivative(xCurrent, yCurrent);
            return yNext;
        }
    }
}
﻿using System;

namespace Algorithms.Numeric
{
    
    
    
    
    
    
    public static class AliquotSumCalculator
    {
        
        
        
        
        
        
        public static int CalculateAliquotSum(int number)
        {
            if (number < 0)
            {
                throw new ArgumentException($"{nameof(number)} cannot be negative");
            }

            var sum = 0;
            for (int i = 1, limit = number / 2; i <= limit; ++i)
            {
                if (number % i == 0)
                {
                    sum += i;
                }
            }

            return sum;
        }
    }
}
using System;
using Utilities.Extensions;
using M = Utilities.Extensions.MatrixExtensions;
using V = Utilities.Extensions.VectorExtensions;

namespace Algorithms.Numeric.Decomposition
{
    
    
    
    
    public static class ThinSvd
    {
        
        
        
        
        
        public static double[] RandomUnitVector(int dimensions)
        {
            Random random = new();
            double[] result = new double[dimensions];
            for (var i = 0; i < dimensions; i++)
            {
                result[i] = 2 * random.NextDouble() - 1;
            }

            var magnitude = result.Magnitude();
            result = result.Scale(1 / magnitude);
            return result;
        }

        
        
        
        
        
        public static double[] Decompose1D(double[,] matrix) =>
            Decompose1D(matrix, 1E-5, 100);

        
        
        
        
        
        
        
        public static double[] Decompose1D(double[,] matrix, double epsilon, int maxIterations)
        {
            var n = matrix.GetLength(1);
            var iterations = 0;
            double mag;
            double[] lastIteration;
            double[] currIteration = RandomUnitVector(n);
            double[,] b = matrix.Transpose().Multiply(matrix);
            do
            {
                lastIteration = currIteration.Copy();
                currIteration = b.MultiplyVector(lastIteration);
                currIteration = currIteration.Scale(100);
                mag = currIteration.Magnitude();
                if (mag > epsilon)
                {
                    currIteration = currIteration.Scale(1 / mag);
                }

                iterations++;
            }
            while (lastIteration.Dot(currIteration) < 1 - epsilon && iterations < maxIterations);

            return currIteration;
        }

        public static (double[,] U, double[] S, double[,] V) Decompose(double[,] matrix) =>
            Decompose(matrix, 1E-5, 100);

        
        
        
        
        
        
        
        public static (double[,] U, double[] S, double[,] V) Decompose(
            double[,] matrix,
            double epsilon,
            int maxIterations)
        {
            var m = matrix.GetLength(0);
            var n = matrix.GetLength(1);
            var numValues = Math.Min(m, n);

            
            double[] sigmas = new double[numValues];
            double[,] us = new double[m, numValues];
            double[,] vs = new double[n, numValues];

            
            double[,] remaining = matrix.Copy();

            
            for (var i = 0; i < numValues; i++)
            {
                
                double[] v = Decompose1D(remaining, epsilon, maxIterations);
                double[] u = matrix.MultiplyVector(v);

                
                double[,] contrib = u.OuterProduct(v);

                
                var s = u.Magnitude();

                
                if (s < epsilon)
                {
                    u = new double[m];
                    v = new double[n];
                }
                else
                {
                    u = u.Scale(1 / s);
                }

                
                for (var j = 0; j < u.Length; j++)
                {
                    us[j, i] = u[j];
                }

                for (var j = 0; j < v.Length; j++)
                {
                    vs[j, i] = v[j];
                }

                sigmas[i] = s;

                
                remaining = remaining.Subtract(contrib);
            }

            return (U: us, S: sigmas, V: vs);
        }
    }
}
using System;

namespace Algorithms.Numeric.Decomposition
{
    
    
    
    
    public static class Lu
    {
        
        
        
        
        
        
        
        
        public static (double[,] L, double[,] U) Decompose(double[,] source)
        {
            if (source.GetLength(0) != source.GetLength(1))
            {
                throw new ArgumentException("Source matrix is not square shaped.");
            }

            var pivot = source.GetLength(0);
            var lower = new double[pivot, pivot];
            var upper = new double[pivot, pivot];

            for (var i = 0; i < pivot; i++)
            {
                for (var k = i; k < pivot; k++)
                {
                    double sum = 0;

                    for (var j = 0; j < i; j++)
                    {
                        sum += lower[i, j] * upper[j, k];
                    }

                    upper[i, k] = source[i, k] - sum;
                }

                for (var k = i; k < pivot; k++)
                {
                    if (i == k)
                    {
                        lower[i, i] = 1;
                    }
                    else
                    {
                        double sum = 0;

                        for (var j = 0; j < i; j++)
                        {
                            sum += lower[k, j] * upper[j, i];
                        }

                        lower[k, i] = (source[k, i] - sum) / upper[i, i];
                    }
                }
            }

            return (L: lower, U: upper);
        }

        
        
        
        
        
        
        
        
        public static double[] Eliminate(double[,] matrix, double[] coefficients)
        {
            if (matrix.GetLength(0) != matrix.GetLength(1))
            {
                throw new ArgumentException("Matrix of equation coefficients is not square shaped.");
            }

            var pivot = matrix.GetLength(0);
            var upperTransform = new double[pivot, 1]; 
            var solution = new double[pivot]; 
            (double[,] l, double[,] u) = Decompose(matrix);

            for (var i = 0; i < pivot; i++)
            {
                double pivotPointSum = 0;

                for (var j = 0; j < i; j++)
                {
                    pivotPointSum += upperTransform[j, 0] * l[i, j];
                }

                upperTransform[i, 0] = (coefficients[i] - pivotPointSum) / l[i, i];
            }

            for (var i = pivot - 1; i >= 0; i--)
            {
                double pivotPointSum = 0;

                for (var j = i; j < pivot; j++)
                {
                    pivotPointSum += solution[j] * u[i, j];
                }

                solution[i] = (upperTransform[i, 0] - pivotPointSum) / u[i, i];
            }

            return solution;
        }
    }
}
﻿using System;

namespace Algorithms.Numeric
{
    
    
    
    
    public static class Factorial
    {
        
        
        
        
        
        public static long Calculate(int num)
        {
            if (num < 0)
            {
                throw new ArgumentException("Only for num >= 0");
            }

            return num == 0 ? 1 : num * Calculate(num - 1);
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using Algorithms.Sorters.Comparison;
using Utilities.Extensions;

namespace Algorithms.DataCompression
{
    
    
    
    public class HuffmanCompressor
    {
        
        private readonly IComparisonSorter<ListNode> sorter;
        private readonly Translator translator;

        public HuffmanCompressor(IComparisonSorter<ListNode> sorter, Translator translator)
        {
            this.sorter = sorter;
            this.translator = translator;
        }

        
        
        
        
        
        
        public (string compressedText, Dictionary<string, string> decompressionKeys) Compress(string uncompressedText)
        {
            if (string.IsNullOrEmpty(uncompressedText))
            {
                return (string.Empty, new Dictionary<string, string>());
            }

            if (uncompressedText.Distinct().Count() == 1)
            {
                var dict = new Dictionary<string, string>
                {
                    { "1", uncompressedText[0].ToString() },
                };
                return (new string('1', uncompressedText.Length), dict);
            }

            var nodes = GetListNodesFromText(uncompressedText);
            var tree = GenerateHuffmanTree(nodes);
            var (compressionKeys, decompressionKeys) = GetKeys(tree);
            return (translator.Translate(uncompressedText, compressionKeys), decompressionKeys);
        }

        
        
        
        
        private static ListNode[] GetListNodesFromText(string text)
        {
            var occurenceCounts = new Dictionary<char, int>();

            foreach (var ch in text)
            {
                if (!occurenceCounts.ContainsKey(ch))
                {
                    occurenceCounts.Add(ch, 0);
                }

                occurenceCounts[ch]++;
            }

            return occurenceCounts.Select(kvp => new ListNode(kvp.Key, 1d * kvp.Value / text.Length)).ToArray();
        }

        private (Dictionary<string, string> compressionKeys, Dictionary<string, string> decompressionKeys) GetKeys(
            ListNode tree)
        {
            var compressionKeys = new Dictionary<string, string>();
            var decompressionKeys = new Dictionary<string, string>();

            if (tree.HasData)
            {
                compressionKeys.Add(tree.Data.ToString(), string.Empty);
                decompressionKeys.Add(string.Empty, tree.Data.ToString());
                return (compressionKeys, decompressionKeys);
            }

            if (tree.LeftChild is not null)
            {
                var (lsck, lsdk) = GetKeys(tree.LeftChild);
                compressionKeys.AddMany(lsck.Select(kvp => (kvp.Key, "0" + kvp.Value)));
                decompressionKeys.AddMany(lsdk.Select(kvp => ("0" + kvp.Key, kvp.Value)));
            }

            if (tree.RightChild is not null)
            {
                var (rsck, rsdk) = GetKeys(tree.RightChild);
                compressionKeys.AddMany(rsck.Select(kvp => (kvp.Key, "1" + kvp.Value)));
                decompressionKeys.AddMany(rsdk.Select(kvp => ("1" + kvp.Key, kvp.Value)));

                return (compressionKeys, decompressionKeys);
            }

            return (compressionKeys, decompressionKeys);
        }

        private ListNode GenerateHuffmanTree(ListNode[] nodes)
        {
            var comparer = new ListNodeComparer();
            while (nodes.Length > 1)
            {
                sorter.Sort(nodes, comparer);

                var left = nodes[0];
                var right = nodes[1];

                var newNodes = new ListNode[nodes.Length - 1];
                Array.Copy(nodes, 2, newNodes, 1, nodes.Length - 2);
                newNodes[0] = new ListNode(left, right);
                nodes = newNodes;
            }

            return nodes[0];
        }

        
        
        
        public class ListNode
        {
            public ListNode(char data, double frequency)
            {
                HasData = true;
                Data = data;
                Frequency = frequency;
            }

            public ListNode(ListNode leftChild, ListNode rightChild)
            {
                LeftChild = leftChild;
                RightChild = rightChild;
                Frequency = leftChild.Frequency + rightChild.Frequency;
            }

            public char Data { get; }

            public bool HasData { get; }

            public double Frequency { get; }

            public ListNode? RightChild { get; }

            public ListNode? LeftChild { get; }
        }

        public class ListNodeComparer : IComparer<ListNode>
        {
            public int Compare(ListNode? x, ListNode? y)
            {
                if (x is null || y is null)
                {
                    return 0;
                }

                return x.Frequency.CompareTo(y.Frequency);
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Text;

namespace Algorithms.DataCompression
{
    
    
    
    public class Translator
    {
        
        
        
        
        
        
        public string Translate(string text, Dictionary<string, string> translationKeys)
        {
            var sb = new StringBuilder();

            var start = 0;
            for (var i = 0; i < text.Length; i++)
            {
                var key = text.Substring(start, i - start + 1);
                if (translationKeys.ContainsKey(key))
                {
                    _ = sb.Append(translationKeys[key]);
                    start = i + 1;
                }
            }

            return sb.ToString();
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using Algorithms.Knapsack;
using Utilities.Extensions;

namespace Algorithms.DataCompression
{
    
    
    
    public class ShannonFanoCompressor
    {
        private readonly IHeuristicKnapsackSolver<(char symbol, double frequency)> splitter;
        private readonly Translator translator;

        public ShannonFanoCompressor(
            IHeuristicKnapsackSolver<(char symbol, double frequency)> splitter,
            Translator translator)
        {
            this.splitter = splitter;
            this.translator = translator;
        }

        
        
        
        
        
        
        public (string compressedText, Dictionary<string, string> decompressionKeys) Compress(string uncompressedText)
        {
            if (string.IsNullOrEmpty(uncompressedText))
            {
                return (string.Empty, new Dictionary<string, string>());
            }

            if (uncompressedText.Distinct().Count() == 1)
            {
                var dict = new Dictionary<string, string>
                {
                    { "1", uncompressedText[0].ToString() },
                };
                return (new string('1', uncompressedText.Length), dict);
            }

            var node = GetListNodeFromText(uncompressedText);
            var tree = GenerateShannonFanoTree(node);
            var (compressionKeys, decompressionKeys) = GetKeys(tree);
            return (translator.Translate(uncompressedText, compressionKeys), decompressionKeys);
        }

        private (Dictionary<string, string> compressionKeys, Dictionary<string, string> decompressionKeys) GetKeys(
            ListNode tree)
        {
            var compressionKeys = new Dictionary<string, string>();
            var decompressionKeys = new Dictionary<string, string>();

            if (tree.Data.Length == 1)
            {
                compressionKeys.Add(tree.Data[0].symbol.ToString(), string.Empty);
                decompressionKeys.Add(string.Empty, tree.Data[0].symbol.ToString());
                return (compressionKeys, decompressionKeys);
            }

            if (tree.LeftChild is not null)
            {
                var (lsck, lsdk) = GetKeys(tree.LeftChild);
                compressionKeys.AddMany(lsck.Select(kvp => (kvp.Key, "0" + kvp.Value)));
                decompressionKeys.AddMany(lsdk.Select(kvp => ("0" + kvp.Key, kvp.Value)));
            }

            if (tree.RightChild is not null)
            {
                var (rsck, rsdk) = GetKeys(tree.RightChild);
                compressionKeys.AddMany(rsck.Select(kvp => (kvp.Key, "1" + kvp.Value)));
                decompressionKeys.AddMany(rsdk.Select(kvp => ("1" + kvp.Key, kvp.Value)));
            }

            return (compressionKeys, decompressionKeys);
        }

        private ListNode GenerateShannonFanoTree(ListNode node)
        {
            if (node.Data.Length == 1)
            {
                return node;
            }

            var left = splitter.Solve(node.Data, 0.5 * node.Data.Sum(x => x.frequency), x => x.frequency, _ => 1);
            var right = node.Data.Except(left).ToArray();

            node.LeftChild = GenerateShannonFanoTree(new ListNode(left));
            node.RightChild = GenerateShannonFanoTree(new ListNode(right));

            return node;
        }

        
        
        
        
        private ListNode GetListNodeFromText(string text)
        {
            var occurenceCounts = new Dictionary<char, double>();

            for (var i = 0; i < text.Length; i++)
            {
                var ch = text[i];
                if (!occurenceCounts.ContainsKey(ch))
                {
                    occurenceCounts.Add(ch, 0);
                }

                occurenceCounts[ch]++;
            }

            return new ListNode(occurenceCounts.Select(kvp => (kvp.Key, 1d * kvp.Value / text.Length)).ToArray());
        }

        
        
        
        public class ListNode
        {
            public ListNode((char symbol, double frequency)[] data) => Data = data;

            public (char symbol, double frequency)[] Data { get; }

            public ListNode? RightChild { get; set; }

            public ListNode? LeftChild { get; set; }
        }
    }
}
﻿using System;
using System.Linq;

namespace Algorithms.DataCompression
{
    
    
    
    
    
    
    public class BurrowsWheelerTransform
    {
        
        
        
        
        
        public (string encoded, int index) Encode(string s)
        {
            if (s.Length == 0)
            {
                return (string.Empty, 0);
            }

            var rotations = GetRotations(s);
            Array.Sort(rotations, StringComparer.Ordinal);
            var lastColumn = rotations
                .Select(x => x[^1])
                .ToArray();
            var encoded = new string(lastColumn);
            return (encoded, Array.IndexOf(rotations, s));
        }

        
        
        
        
        
        public string Decode(string s, int index)
        {
            if (s.Length == 0)
            {
                return string.Empty;
            }

            var rotations = new string[s.Length];

            for (var i = 0; i < s.Length; i++)
            {
                for (var j = 0; j < s.Length; j++)
                {
                    rotations[j] = s[j] + rotations[j];
                }

                Array.Sort(rotations, StringComparer.Ordinal);
            }

            return rotations[index];
        }

        private string[] GetRotations(string s)
        {
            var result = new string[s.Length];

            for (var i = 0; i < s.Length; i++)
            {
                result[i] = s.Substring(i) + s.Substring(0, i);
            }

            return result;
        }
    }
}
﻿using System;
using System.Linq;
using Algorithms.Numeric;

namespace Algorithms.Encoders
{
    
    
    
    
    
    public class HillEncoder : IEncoder<double[,]>
    {
        private readonly GaussJordanElimination linearEquationSolver;

        public HillEncoder() => linearEquationSolver = new GaussJordanElimination(); 

        public string Encode(string text, double[,] key)
        {
            var preparedText = FillGaps(text);
            var chunked = ChunkTextToArray(preparedText);
            var splitted = SplitToCharArray(chunked);

            var ciphered = new double[chunked.Length][];

            for (var i = 0; i < chunked.Length; i++)
            {
                var vector = new double[3];
                Array.Copy(splitted, i * 3, vector, 0, 3);
                var product = MatrixCipher(vector, key);
                ciphered[i] = product;
            }

            var merged = MergeArrayList(ciphered);

            return BuildStringFromArray(merged);
        }

        public string Decode(string text, double[,] key)
        {
            var chunked = ChunkTextToArray(text);
            var split = SplitToCharArray(chunked);

            var deciphered = new double[chunked.Length][];

            for (var i = 0; i < chunked.Length; i++)
            {
                var vector = new double[3];
                Array.Copy(split, i * 3, vector, 0, 3);
                var product = MatrixDeCipher(vector, key);
                deciphered[i] = product;
            }

            var merged = MergeArrayList(deciphered);
            var str = BuildStringFromArray(merged);

            return UnFillGaps(str);
        }

        
        
        
        
        
        private static string BuildStringFromArray(double[] arr) => new(arr.Select(c => (char)c).ToArray());

        
        
        
        
        
        
        private static double[] MatrixCipher(double[] vector, double[,] key)
        {
            var multiplied = new double[vector.Length];

            for (var i = 0; i < key.GetLength(1); i++)
            {
                for (var j = 0; j < key.GetLength(0); j++)
                {
                    multiplied[i] += key[i, j] * vector[j];
                }
            }

            return multiplied;
        }

        
        
        
        
        
        private static double[] MergeArrayList(double[][] list)
        {
            var merged = new double[list.Length * 3];

            for (var i = 0; i < list.Length; i++)
            {
                Array.Copy(list[i], 0, merged, i * 3, list[0].Length);
            }

            return merged;
        }

        
        
        
        
        
        private static char[] SplitToCharArray(string[] chunked)
        {
            var splitted = new char[chunked.Length * 3];

            for (var i = 0; i < chunked.Length; i++)
            {
                for (var j = 0; j < 3; j++)
                {
                    splitted[i * 3 + j] = chunked[i].ToCharArray()[j];
                }
            }

            return splitted;
        }

        
        
        
        
        
        private static string[] ChunkTextToArray(string text)
        {
            
            var div = text.Length / 3;
            var chunks = new string[div];

            for (var i = 0; i < div; i++)
            {
                chunks.SetValue(text.Substring(i * 3, 3), i);
            }

            return chunks;
        }

        
        
        
        
        
        
        private static string FillGaps(string text)
        {
            var remainder = text.Length % 3;
            return remainder == 0 ? text : text + new string(' ', 3 - remainder);
        }

        
        
        
        
        
        private static string UnFillGaps(string text) => text.TrimEnd();

        
        
        
        
        
        
        private double[] MatrixDeCipher(double[] vector, double[,] key)
        {
            
            var augM = new double[3, 4];

            for (var i = 0; i < key.GetLength(0); i++)
            {
                for (var j = 0; j < key.GetLength(1); j++)
                {
                    augM[i, j] = key[i, j];
                }
            }

            for (var k = 0; k < vector.Length; k++)
            {
                augM[k, 3] = vector[k];
            }

            _ = linearEquationSolver.Solve(augM);

            return new[] { augM[0, 3], augM[1, 3], augM[2, 3] };
        }
    }
}
using System.Text;

namespace Algorithms.Encoders
{
    
    
    
    public class CaesarEncoder : IEncoder<int>
    {
        
        
        
        
        
        
        
        
        
        public string Encode(string text, int key) => Cipher(text, key);

        
        
        
        
        
        
        
        
        
        public string Decode(string text, int key) => Cipher(text, -key);

        private static string Cipher(string text, int key)
        {
            var newText = new StringBuilder(text.Length);
            for (var i = 0; i < text.Length; i++)
            {
                if (!char.IsLetter(text[i]))
                {
                    _ = newText.Append(text[i]);
                    continue;
                }

                var letterA = char.IsUpper(text[i]) ? 'A' : 'a';
                var letterZ = char.IsUpper(text[i]) ? 'Z' : 'z';

                var c = text[i] + key;
                c -= c > letterZ ? 26 * (1 + (c - letterZ - 1) / 26) : 0;
                c += c < letterA ? 26 * (1 + (letterA - c - 1) / 26) : 0;

                _ = newText.Append((char)c);
            }

            return newText.ToString();
        }
    }
}
﻿namespace Algorithms.Encoders
{
    
    
    
    
    public interface IEncoder<TKey>
    {
        
        
        
        
        
        
        string Encode(string text, TKey key);

        
        
        
        
        
        
        string Decode(string text, TKey key);
    }
}
using System;
using System.Collections.Generic;
using System.Text;

namespace Algorithms.Encoders
{
    
    
    
    
    
    
    
    
    
    
    public class FeistelCipher : IEncoder<uint>
    {
        
        private const int Rounds = 32;

        
        
        
        
        
        
        
        
        public string Encode(string text, uint key)
        {
            List<ulong> blocksListPlain = SplitTextToBlocks(text);
            StringBuilder encodedText = new();

            foreach (ulong block in blocksListPlain)
            {
                uint temp = 0;

                
                uint rightSubblock = (uint)(block & 0x00000000FFFFFFFF);
                uint leftSubblock = (uint)(block >> 32);

                uint roundKey;

                
                for (int round = 0; round < Rounds; round++)
                {
                    roundKey = GetRoundKey(key, round);
                    temp = rightSubblock ^ BlockModification(leftSubblock, roundKey);
                    rightSubblock = leftSubblock;
                    leftSubblock = temp;
                }

                
                ulong encodedBlock = leftSubblock;
                encodedBlock = (encodedBlock << 32) | rightSubblock;
                encodedText.Append(string.Format("{0:X16}", encodedBlock));
            }

            return encodedText.ToString();
        }

        
        
        
        
        
        
        
        
        public string Decode(string text, uint key)
        {
            
            if (text.Length % 16 != 0)
            {
                throw new ArgumentException($"The length of {nameof(key)} should be divisible by 16");
            }

            List<ulong> blocksListEncoded = GetBlocksFromEncodedText(text);
            StringBuilder decodedTextHex = new();

            foreach (ulong block in blocksListEncoded)
            {
                uint temp = 0;

                
                uint rightSubblock = (uint)(block & 0x00000000FFFFFFFF);
                uint leftSubblock = (uint)(block >> 32);

                
                uint roundKey;
                for (int round = Rounds - 1; round >= 0; round--)
                {
                    roundKey = GetRoundKey(key, round);
                    temp = leftSubblock ^ BlockModification(rightSubblock, roundKey);
                    leftSubblock = rightSubblock;
                    rightSubblock = temp;
                }

                
                ulong decodedBlock = leftSubblock;
                decodedBlock = (decodedBlock << 32) | rightSubblock;

                for(int i = 0; i < 8; i++)
                {
                    ulong a = (decodedBlock & 0xFF00000000000000) >> 56;

                    
                    if (a != 0)
                    {
                        decodedTextHex.Append((char)a);
                    }

                    decodedBlock = decodedBlock << 8;
                }
            }

            return decodedTextHex.ToString();
        }

        
        
        private static List<ulong> SplitTextToBlocks(string text)
        {
            List<ulong> blocksListPlain = new();
            byte[] textArray = Encoding.ASCII.GetBytes(text);
            int offset = 8;
            for(int i = 0; i < text.Length; i += 8)
            {
                
                if (i > text.Length - 8)
                {
                    offset = text.Length - i;
                }

                string block = Convert.ToHexString(textArray, i, offset);
                blocksListPlain.Add(Convert.ToUInt64(block, 16));
            }

            return blocksListPlain;
        }

        
        private static List<ulong> GetBlocksFromEncodedText(string text)
        {
            List<ulong> blocksListPlain = new();
            for(int i = 0; i < text.Length; i += 16)
            {
                ulong block = Convert.ToUInt64(text.Substring(i, 16), 16);
                blocksListPlain.Add(block);
            }

            return blocksListPlain;
        }

        
        private static uint BlockModification(uint block, uint key)
        {
            for (int i = 0; i < 32; i++)
            {
                
                block = ((block ^ 0x55555555) * block) % key;
                block = block ^ key;
            }

            return block;
        }

        
        private static uint GetRoundKey(uint key, int round)
        {
            
            uint a = (uint)Math.Pow((double)key, round + 2);
            return a ^ key;
        }
    }
}
using System.Collections.Generic;
using System.Linq;

namespace Algorithms.Encoders
{
    
    
    
    public class SoundexEncoder
    {
        
        
        
        
        
        public string Encode(string text)
        {
            text = text.ToLowerInvariant();
            var chars = OmitHAndW(text);
            IEnumerable<int> numbers = ProduceNumberCoding(chars);
            numbers = CollapseDoubles(numbers);
            numbers = OmitVowels(numbers);
            numbers = CollapseLeadingDigit(numbers, text[0]);
            numbers = numbers.Take(3);
            numbers = PadTo3Numbers(numbers);
            var final = numbers.ToArray();
            return $"{text.ToUpperInvariant()[0]}{final[0]}{final[1]}{final[2]}";
        }

        private IEnumerable<int> CollapseLeadingDigit(IEnumerable<int> numbers, char c)
        {
            using var enumerator = numbers.GetEnumerator();
            enumerator.MoveNext();
            if (enumerator.Current == MapToNumber(c))
            {
                enumerator.MoveNext();
            }

            do
            {
                yield return enumerator.Current;
            }
            while (enumerator.MoveNext());
        }

        private IEnumerable<int> PadTo3Numbers(IEnumerable<int> numbers)
        {
            using var enumerator = numbers.GetEnumerator();
            for (var i = 0; i < 3; i++)
            {
                yield return enumerator.MoveNext()
                    ? enumerator.Current
                    : 0;
            }
        }

        private IEnumerable<int> OmitVowels(IEnumerable<int> numbers) => numbers.Where(i => i != 0);

        private IEnumerable<char> OmitHAndW(string text) => text.Where(c => c != 'h' && c != 'w');

        private IEnumerable<int> CollapseDoubles(IEnumerable<int> numbers)
        {
            var previous = int.MinValue;
            foreach (var i in numbers)
            {
                if (previous != i)
                {
                    yield return i;
                    previous = i;
                }
            }
        }

        private IEnumerable<int> ProduceNumberCoding(IEnumerable<char> text) => text.Select(MapToNumber);

        private int MapToNumber(char ch)
        {
            var mapping = new Dictionary<char, int>
            {
                ['a'] = 0,
                ['e'] = 0,
                ['i'] = 0,
                ['o'] = 0,
                ['u'] = 0,
                ['y'] = 0,
                ['h'] = 8,
                ['w'] = 8,
                ['b'] = 1,
                ['f'] = 1,
                ['p'] = 1,
                ['v'] = 1,
                ['c'] = 2,
                ['g'] = 2,
                ['j'] = 2,
                ['k'] = 2,
                ['q'] = 2,
                ['s'] = 2,
                ['x'] = 2,
                ['z'] = 2,
                ['d'] = 3,
                ['t'] = 3,
                ['l'] = 4,
                ['m'] = 5,
                ['n'] = 5,
                ['r'] = 6,
            };

            return mapping[ch];
        }
    }
}
﻿using System;
using System.Text;

namespace Algorithms.Encoders
{
    
    
    
    public class VigenereEncoder : IEncoder<string>
    {
        private readonly CaesarEncoder caesarEncoder = new();

        
        
        
        
        
        
        
        
        
        public string Encode(string text, string key) => Cipher(text, key, caesarEncoder.Encode);

        
        
        
        
        
        
        
        
        
        public string Decode(string text, string key) => Cipher(text, key, caesarEncoder.Decode);

        private string Cipher(string text, string key, Func<string, int, string> symbolCipher)
        {
            key = AppendKey(key, text.Length);
            var encodedTextBuilder = new StringBuilder(text.Length);
            for (var i = 0; i < text.Length; i++)
            {
                if (!char.IsLetter(text[i]))
                {
                    _ = encodedTextBuilder.Append(text[i]);
                    continue;
                }

                var letterZ = char.IsUpper(key[i]) ? 'Z' : 'z';
                var encodedSymbol = symbolCipher(text[i].ToString(), letterZ - key[i]);
                _ = encodedTextBuilder.Append(encodedSymbol);
            }

            return encodedTextBuilder.ToString();
        }

        private string AppendKey(string key, int length)
        {
            if (string.IsNullOrEmpty(key))
            {
                throw new ArgumentOutOfRangeException($"{nameof(key)} must be non-empty string");
            }

            var keyBuilder = new StringBuilder(key, length);
            while (keyBuilder.Length < length)
            {
                _ = keyBuilder.Append(key);
            }

            return keyBuilder.ToString();
        }
    }
}
using System.Globalization;
using System.Linq;
using System.Text;

namespace Algorithms.Encoders
{
    
    
    
    public class NysiisEncoder
    {
        private static readonly char[] Vowels = { 'A', 'E', 'I', 'O', 'U' };

        
        
        
        
        
        public string Encode(string text)
        {
            text = text.ToUpper(CultureInfo.CurrentCulture);
            text = TrimSpaces(text);
            text = StartReplace(text);
            text = EndReplace(text);

            for (var i = 1; i < text.Length; i++)
            {
                text = ReplaceStep(text, i);
            }

            text = RemoveDuplicates(text);
            return TrimEnd(text);
        }

        private string TrimSpaces(string text) => text.Replace(" ", string.Empty);

        private string RemoveDuplicates(string text)
        {
            var sb = new StringBuilder();
            sb.Append(text[0]);
            foreach (var c in text)
            {
                if (sb[^1] != c)
                {
                    sb.Append(c);
                }
            }

            return sb.ToString();
        }

        private string TrimEnd(string text)
        {
            var checks = new (string from, string to)?[]
            {
                ("S", string.Empty),
                ("AY", "Y"),
                ("A", string.Empty),
            };
            var replacement = checks.FirstOrDefault(t => text.EndsWith(t!.Value.from));
            if (replacement is { })
            {
                var (from, to) = replacement!.Value;
                text = Replace(text, text.Length - from.Length, from.Length, to);
            }

            return text;
        }

        private string ReplaceStep(string text, int i)
        {
            (string from, string to)[] replacements =
            {
                ("EV", "AF"),
                ("E", "A"),
                ("I", "A"),
                ("O", "A"),
                ("U", "A"),
                ("Q", "G"),
                ("Z", "S"),
                ("M", "N"),
                ("KN", "NN"),
                ("K", "C"),
                ("SCH", "SSS"),
                ("PH", "FF"),
            };
            var replaced = TryReplace(text, i, replacements, out text);
            if (replaced)
            {
                return text;
            }

            
            if (text[i] == 'H')
            {
                if (!Vowels.Contains(text[i - 1]))
                {
                    return ReplaceWithPrevious();
                }

                if (i < text.Length - 1 && !Vowels.Contains(text[i + 1]))
                {
                    return ReplaceWithPrevious();
                }
            }

            
            if (text[i] == 'W' && Vowels.Contains(text[i - 1]))
            {
                return ReplaceWithPrevious();
            }

            return text;

            string ReplaceWithPrevious() => Replace(text, i, 1, text[i - 1].ToString());
        }

        private bool TryReplace(string text, int index, (string, string)[] opts, out string result)
        {
            for (var i = 0; i < opts.Length; i++)
            {
                var check = opts[i].Item1;
                var repl = opts[i].Item2;
                if (text.Length >= index + check.Length && text.Substring(index, check.Length) == check)
                {
                    result = Replace(text, index, check.Length, repl);
                    return true;
                }
            }

            result = text;
            return false;
        }

        private string StartReplace(string start)
        {
            var checks = new (string from, string to)?[]
            {
                ("MAC", "MCC"),
                ("KN", "NN"),
                ("K", "C"),
                ("PH", "FF"),
                ("PF", "FF"),
                ("SCH", "SSS"),
            };
            var replacement = checks.FirstOrDefault(t => start.StartsWith(t!.Value.from));
            if (replacement is { })
            {
                var (from, to) = replacement!.Value;
                start = Replace(start, 0, from.Length, to);
            }

            return start;
        }

        private string EndReplace(string end)
        {
            var checks = new (string from, string to)?[]
            {
                ("EE", "Y"),
                ("IE", "Y"),
                ("DT", "D"),
                ("RT", "D"),
                ("NT", "D"),
                ("ND", "D"),
            };
            var replacement = checks.FirstOrDefault(t => end.EndsWith(t!.Value.from));
            if (replacement is { })
            {
                var (from, to) = replacement!.Value;
                end = Replace(end, end.Length - from.Length, from.Length, to);
            }

            return end;
        }

        private string Replace(string text, int index, int length, string substitute) =>
            text[..index] + substitute + text[(index + length) ..];
    }
}
﻿using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class FibonacciSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 0;
                yield return 1;
                BigInteger previous = 0;
                BigInteger current = 1;
                while (true)
                {
                    var next = previous + current;
                    previous = current;
                    current = next;
                    yield return next;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class ThreeNPlusOneStepsSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                BigInteger startingValue = 1;

                while (true)
                {
                    BigInteger counter = 0;
                    BigInteger currentValue = startingValue;

                    while (currentValue != 1)
                    {
                        if (currentValue.IsEven)
                        {
                            currentValue /= 2;
                        }
                        else
                        {
                            currentValue = 3 * currentValue + 1;
                        }

                        counter++;
                    }

                    yield return counter;
                    startingValue++;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class CatalanSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                
                var catalan = new BigInteger(1);
                var n = 0;
                while (true)
                {
                    yield return catalan;
                    catalan = (2 * (2 * n + 1) * catalan) / (n + 2);
                    n++;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class EuclidNumbersSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var primorialNumbers = new PrimorialNumbersSequence().Sequence;

                foreach (var n in primorialNumbers)
                {
                    yield return n + 1;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    
    public class BinaryPrimeConstantSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                ISequence primes = new PrimesSequence();
                var n = new BigInteger(0);

                foreach (var p in primes.Sequence)
                {
                    for (n++; n < p; n++)
                    {
                        yield return 0;
                    }

                    yield return 1;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class GolombsSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 1;
                yield return 2;
                yield return 2;

                var queue = new Queue<BigInteger>();
                queue.Enqueue(2);

                for (var i = 3; ; i++)
                {
                    var repetitions = queue.Dequeue();
                    for (var j = 0; j < repetitions; j++)
                    {
                        queue.Enqueue(i);
                        yield return i;
                    }
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class PrimorialNumbersSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var primes = new PrimesSequence().Sequence;
                var n = new BigInteger(1);

                foreach (var p in primes)
                {
                    yield return n;
                    n *= p;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class BinomialSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var i = 0;

                while (true)
                {
                    var row = GenerateRow(i);
                    foreach (var coefficient in row)
                    {
                        yield return coefficient;
                    }

                    i++;
                }
            }
        }

        private static BigInteger BinomialCoefficient(long n, long k)
        {
            if (k == 0 || k == n)
            {
                return new BigInteger(1);
            }

            if (n < 0)
            {
                return new BigInteger(0);
            }

            return BinomialCoefficient(n - 1, k) + BinomialCoefficient(n - 1, k - 1);
        }

        private static IEnumerable<BigInteger> GenerateRow(long n)
        {
            long k = 0;

            while (k <= n)
            {
                yield return BinomialCoefficient(n, k);
                k++;
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    public class DivisorsCountSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return BigInteger.One;
                for (var n = new BigInteger(2); ; n++)
                {
                    var count = 2;
                    for (var k = 2; k < n; k++)
                    {
                        BigInteger.DivRem(n, k, out var remainder);
                        if (remainder == 0)
                        {
                            count++;
                        }
                    }

                    yield return count;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class NaturalSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(1);
                while (true)
                {
                    yield return n++;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class FermatPrimesSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var fermatNumbers = new FermatNumbersSequence().Sequence.Take(5);

                foreach (var n in fermatNumbers)
                {
                    yield return n;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    public interface ISequence
    {
        
        
        
        IEnumerable<BigInteger> Sequence { get; }
    }
}
﻿using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class NegativeIntegersSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(-1);

                while (true)
                {
                    yield return n--;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    
    public class NumberOfBooleanFunctionsSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(2);

                while (true)
                {
                    yield return n;
                    n *= n;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    
    public class KummerNumbersSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var primorialNumbers = new PrimorialNumbersSequence().Sequence.Skip(1);

                foreach (var n in primorialNumbers)
                {
                    yield return n - 1;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class KolakoskiSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 1;
                yield return 2;
                yield return 2;

                var queue = new Queue<int>();
                queue.Enqueue(2);
                var nextElement = 1;
                while (true)
                {
                    var nextRun = queue.Dequeue();
                    for (var i = 0; i < nextRun; i++)
                    {
                        queue.Enqueue(nextElement);
                        yield return nextElement;
                    }

                    nextElement = 1 + nextElement % 2;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class PrimesSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 2;
                var primes = new List<BigInteger>
                {
                    2,
                };
                var n = new BigInteger(3);

                while (true)
                {
                    if (primes.All(p => n % p != 0))
                    {
                        yield return n;
                        primes.Add(n);
                    }

                    n += 2;
                }
            }
        }
    }
}
using System;
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    public class MakeChangeSequence : ISequence
    {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var seed = new List<BigInteger>
                           {
                               1, 1, 2, 2, 3, 4, 5, 6, 7, 8,
                               11, 12, 15, 16, 19, 22, 25,
                           };
                foreach (var value in seed)
                {
                    yield return value;
                }

                for(var index = 17; ; index++)
                {
                    BigInteger newValue = seed[index - 2] + seed[index - 5] - seed[index - 7]
                                        + seed[index - 10] - seed[index - 12] - seed[index - 15]
                                        + seed[index - 17] + 1;

                    seed.Add(newValue);
                    yield return newValue;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class NumberOfPrimesByPowersOf10Sequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                ISequence primes = new PrimesSequence();
                var powerOf10 = new BigInteger(1);
                var counter = new BigInteger(0);

                foreach (var p in primes.Sequence)
                {
                    if (p > powerOf10)
                    {
                        yield return counter;
                        powerOf10 *= 10;
                    }

                    counter++;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class FermatNumbersSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(2);

                while (true)
                {
                    yield return n + 1;
                    n *= n;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    public class VanEcksSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 0;
                var dictionary = new Dictionary<BigInteger, BigInteger>();
                BigInteger previous = 0;
                BigInteger currentIndex = 2; 
                while (true)
                {
                    BigInteger element = 0;
                    if (dictionary.TryGetValue(previous, out var previousIndex))
                    {
                        element = currentIndex - previousIndex;
                    }

                    yield return element;

                    dictionary[previous] = currentIndex;
                    previous = element;
                    currentIndex++;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class FactorialSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = 0;
                var factorial = new BigInteger(1);
                while (true)
                {
                    yield return factorial;
                    n++;
                    factorial *= n;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class EulerTotientSequence : ISequence
    {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return BigInteger.One;

                for (BigInteger i = 2; ; i++)
                {
                    var n = i;
                    var result = n;

                    var factors = PrimeFactors(i);
                    foreach (var factor in factors)
                    {
                        while (n % factor == 0)
                        {
                            n /= factor;
                        }

                        result -= result / factor;
                    }

                    if (n > 1)
                    {
                        result -= result / n;
                    }

                    yield return result;
                }
            }
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        private static IEnumerable<BigInteger> PrimeFactors(BigInteger target)
        {
            return new PrimesSequence()
                  .Sequence.TakeWhile(prime => prime * prime <= target)
                  .Where(prime => target % prime == 0)
                  .ToList();
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class CubesSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = BigInteger.Zero;

                while (true)
                {
                    yield return n * n * n;
                    n++;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class SquaresSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(0);

                while (true)
                {
                    yield return n * n;
                    n++;
                }
            }
        }
    }
}
﻿using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class PowersOf2Sequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(1);

                while (true)
                {
                    yield return n;
                    n *= 2;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    
    public class NumberOfPrimesByNumberOfDigitsSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                ISequence primes = new PrimesSequence();
                var powerOf10 = new BigInteger(1);
                var counter = new BigInteger(0);

                foreach (var p in primes.Sequence)
                {
                    if (p > powerOf10)
                    {
                        yield return counter;
                        counter = 0;
                        powerOf10 *= 10;
                    }

                    counter++;
                }
            }
        }
    }
}
using System.Collections;
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    public class ZeroSequence : ISequence
    {
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                while (true)
                {
                    yield return 0;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class PowersOf10Sequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                var n = new BigInteger(1);

                while (true)
                {
                    yield return n;
                    n *= 10;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class RecamansSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 0;
                var elements = new HashSet<BigInteger> { 0 };
                var previous = 0;
                var i = 1;

                while (true)
                {
                    var current = previous - i;
                    if (current < 0 || elements.Contains(current))
                    {
                        current = previous + i;
                    }

                    yield return current;
                    previous = current;
                    elements.Add(current);
                    i++;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class KolakoskiSequence2 : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                yield return 1;
                yield return 2;
                yield return 2;

                var inner = new KolakoskiSequence2().Sequence.Skip(2);
                var nextElement = 1;
                foreach (var runLength in inner)
                {
                    yield return nextElement;
                    if (runLength > 1)
                    {
                        yield return nextElement;
                    }

                    nextElement = 1 + nextElement % 2;
                }
            }
        }
    }
}
using System.Collections.Generic;
using System.Numerics;

namespace Algorithms.Sequences
{
    
    
    
    
    
    
    
    
    
    
    
    public class PrimePiSequence : ISequence
    {
        
        
        
        public IEnumerable<BigInteger> Sequence
        {
            get
            {
                ISequence primes = new PrimesSequence();
                var n = new BigInteger(0);
                var counter = new BigInteger(0);

                foreach (var p in primes.Sequence)
                {
                    for (n++; n < p; n++)
                    {
                        yield return counter;
                    }

                    yield return ++counter;
                }
            }
        }
    }
}
using System;

namespace Algorithms.Shufflers
{
    
    
    
    
    
    public class FisherYatesShuffler<T> : IShuffler<T>
    {
        
        
        
        
        
        
        
        public void Shuffle(T[] array)
        {
            var random = new Random();

            for (var i = array.Length - 1; i > 0; i--)
            {
                var j = random.Next(0, i + 1);

                (array[i], array[j]) = (array[j], array[i]);
            }
        }
    }
}
namespace Algorithms.Shufflers
{
    
    
    
    
    public interface IShuffler<in T>
    {
        
        
        
        
        void Shuffle(T[] array);
    }
}
using System;
using System.Linq;
using Utilities.Extensions;

namespace Algorithms.LinearAlgebra.Eigenvalue
{
    
    
    
    
    public static class PowerIteration
    {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        public static (double eigenvalue, double[] eigenvector) Dominant(
            double[,] source,
            double[] startVector,
            double error = 0.00001)
        {
            if (source.GetLength(0) != source.GetLength(1))
            {
                throw new ArgumentException("The source matrix is not square-shaped.");
            }

            if (source.GetLength(0) != startVector.Length)
            {
                throw new ArgumentException(
                    "The length of the start vector doesn't equal the size of the source matrix.");
            }

            double eigenNorm;
            double[] previousEigenVector;
            double[] currentEigenVector = startVector;

            do
            {
                previousEigenVector = currentEigenVector;
                currentEigenVector = source.Multiply(
                        previousEigenVector.ToColumnVector())
                    .ToRowVector();

                eigenNorm = currentEigenVector.Magnitude();
                currentEigenVector = currentEigenVector.Select(x => x / eigenNorm).ToArray();
            }
            while (Math.Abs(currentEigenVector.Dot(previousEigenVector)) < 1.0 - error);

            var eigenvalue = source.Multiply(currentEigenVector.ToColumnVector()).ToRowVector().Magnitude();

            return (eigenvalue, eigenvector: currentEigenVector);
        }

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        public static (double eigenvalue, double[] eigenvector) Dominant(double[,] source, double error = 0.00001) =>
            Dominant(source, new Random().NextVector(source.GetLength(1)), error);
    }
}
﻿using System;

namespace Utilities.Exceptions
{
    
    
    
    public class ItemNotFoundException : ApplicationException
    {
    }
}
using System;

namespace Utilities.Extensions
{
    public static class VectorExtensions
    {
        
        
        
        
        
        public static double[] Copy(this double[] vector)
        {
            var result = new double[vector.Length];
            for (var i = 0; i < vector.Length; i++)
            {
                result[i] = vector[i];
            }

            return result;
        }

        
        
        
        
        
        
        public static double[,] OuterProduct(this double[] lhs, double[] rhs)
        {
            var result = new double[lhs.Length, rhs.Length];
            for (var i = 0; i < lhs.Length; i++)
            {
                for (var j = 0; j < rhs.Length; j++)
                {
                    result[i, j] = lhs[i] * rhs[j];
                }
            }

            return result;
        }

        
        
        
        
        
        
        
        public static double Dot(this double[] lhs, double[] rhs)
        {
            if (lhs.Length != rhs.Length)
            {
                throw new ArgumentException("Dot product arguments must have same dimension");
            }

            double result = 0;
            for (var i = 0; i < lhs.Length; i++)
            {
                result += lhs[i] * rhs[i];
            }

            return result;
        }

        
        
        
        
        
        public static double Magnitude(this double[] vector)
        {
            var magnitude = Dot(vector, vector);
            magnitude = Math.Sqrt(magnitude);
            return magnitude;
        }

        
        
        
        
        
        
        public static double[] Scale(this double[] vector, double factor)
        {
            var result = new double[vector.Length];
            for (var i = 0; i < vector.Length; i++)
            {
                result[i] = vector[i] * factor;
            }

            return result;
        }

        
        
        
        
        
        public static double[,] ToColumnVector(this double[] source)
        {
            var columnVector = new double[source.Length, 1];

            for (var i = 0; i < source.Length; i++)
            {
                columnVector[i, 0] = source[i];
            }

            return columnVector;
        }

        
        
        
        
        
        
        public static double[] ToRowVector(this double[,] source)
        {
            if (source.GetLength(1) != 1)
            {
                throw new InvalidOperationException("The column vector should have only 1 element in width.");
            }

            var rowVector = new double[source.Length];

            for (var i = 0; i < rowVector.Length; i++)
            {
                rowVector[i] = source[i, 0];
            }

            return rowVector;
        }

        
        
        
        
        
        public static double[,] ToDiagonalMatrix(this double[] vector)
        {
            var len = vector.Length;
            var result = new double[len, len];

            for (var i = 0; i < len; i++)
            {
                result[i, i] = vector[i];
            }

            return result;
        }
    }
}
﻿using System.Collections.Generic;

namespace Utilities.Extensions
{
    public static class DictionaryExtensions
    {
        public static void AddMany<TKey, TValue>(
            this Dictionary<TKey, TValue> keys,
            IEnumerable<(TKey, TValue)> enumerable) where TKey : notnull
        {
            foreach (var (key, value) in enumerable)
            {
                keys.Add(key, value);
            }
        }
    }
}
using System;

namespace Utilities.Extensions
{
    public static class MatrixExtensions
    {
        
        
        
        
        
        
        
        public static double[,] Multiply(this double[,] source, double[,] operand)
        {
            if (source.GetLength(1) != operand.GetLength(0))
            {
                throw new InvalidOperationException(
                    "The width of a first operand should match the height of a second.");
            }

            var result = new double[source.GetLength(0), operand.GetLength(1)];

            for (var i = 0; i < result.GetLength(0); i++)
            {
                for (var j = 0; j < result.GetLength(1); j++)
                {
                    double elementProduct = 0;

                    for (var k = 0; k < source.GetLength(1); k++)
                    {
                        elementProduct += source[i, k] * operand[k, j];
                    }

                    result[i, j] = elementProduct;
                }
            }

            return result;
        }

        
        
        
        
        
        public static double[,] Copy(this double[,] matrix)
        {
            var result = new double[matrix.GetLength(0), matrix.GetLength(1)];
            for (var i = 0; i < matrix.GetLength(0); i++)
            {
                for (var j = 0; j < matrix.GetLength(1); j++)
                {
                    result[i, j] = matrix[i, j];
                }
            }

            return result;
        }

        
        
        
        
        
        public static double[,] Transpose(this double[,] matrix)
        {
            var result = new double[matrix.GetLength(1), matrix.GetLength(0)];
            for (var i = 0; i < matrix.GetLength(0); i++)
            {
                for (var j = 0; j < matrix.GetLength(1); j++)
                {
                    result[j, i] = matrix[i, j];
                }
            }

            return result;
        }

        
        
        
        
        
        
        
        public static double[] MultiplyVector(this double[,] matrix, double[] vector)
        {
            var vectorReshaped = new double[vector.Length, 1];
            for (var i = 0; i < vector.Length; i++)
            {
                vectorReshaped[i, 0] = vector[i];
            }

            var resultMatrix = matrix.Multiply(vectorReshaped);
            var result = new double[resultMatrix.GetLength(0)];
            for (var i = 0; i < result.Length; i++)
            {
                result[i] = resultMatrix[i, 0];
            }

            return result;
        }

        
        
        
        
        
        
        
        public static double[,] Subtract(this double[,] lhs, double[,] rhs)
        {
            if (lhs.GetLength(0) != rhs.GetLength(0) ||
                lhs.GetLength(1) != rhs.GetLength(1))
            {
                throw new ArgumentException("Dimensions of matrices must be the same");
            }

            var result = new double[lhs.GetLength(0), lhs.GetLength(1)];
            for (var i = 0; i < lhs.GetLength(0); i++)
            {
                for (var j = 0; j < lhs.GetLength(1); j++)
                {
                    result[i, j] = lhs[i, j] - rhs[i, j];
                }
            }

            return result;
        }

        
        
        
        
        
        
        public static bool IsEqual(this double[,] source, double[,] operand)
        {
            if (source.Length != operand.Length ||
                source.GetLength(0) != operand.GetLength(0) ||
                source.GetLength(1) != operand.GetLength(1))
            {
                return false;
            }

            for (var i = 0; i < source.GetLength(0); i++)
            {
                for (var j = 0; j < source.GetLength(0); j++)
                {
                    if (Math.Abs(source[i, j] - operand[i, j]) >= 0.0001)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        
        
        
        
        
        public static double[,] RoundToNextInt(this double[,] source)
        {
            var rows = source.GetLength(0);
            var cols = source.GetLength(1);

            var result = new double[rows, cols];

            for (var i = 0; i < rows; i++)
            {
                for (var j = 0; j < cols; j++)
                {
                    result[i, j] = Math.Round(source[i, j]);
                }
            }

            return result;
        }
    }
}
using System;
using System.Linq;

namespace Utilities.Extensions
{
    public static class RandomExtensions
    {
        public static double[] NextVector(this Random rand, int size)
        {
            var vector = Enumerable.Range(0, size)
                .Select(_ => rand.NextDouble()).ToArray();
            var norm = vector.Magnitude();
            return vector.Select(x => x / norm).ToArray();
        }
    }
}
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
    <CodeAnalysisRuleSet>..\stylecop.ruleset</CodeAnalysisRuleSet>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
    <DocumentationFile>./bin/Utilities.xml</DocumentationFile>
  </PropertyGroup>

  <ItemGroup>
    <AdditionalFiles Include="..\stylecop.json" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="StyleCop.Analyzers" Version="1.1.118">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

</Project>
