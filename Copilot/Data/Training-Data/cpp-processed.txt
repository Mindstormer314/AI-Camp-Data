#include <limits.h>
#include <iostream>

using namespace std;

class Graph {
 public:
    int vertexNum;
    int **edges;

        Graph(const int V) {
                this->edges = new int *[V];
        for (int i = 0; i < V; i++) {
            edges[i] = new int[V];
        }

                for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                edges[i][j] = 0;
            }
        }

        this->vertexNum = V;
    }

        void addEdge(int src, int dst, int weight) {
        this->edges[src][dst] = weight;
    }
};
int minDistance(int mdist[], bool vset[], int V) {
    int minVal = INT_MAX, minInd = 0;
    for (int i = 0; i < V; i++) {
        if (!vset[i] && (mdist[i] < minVal)) {
            minVal = mdist[i];
            minInd = i;
        }
    }

    return minInd;
}

void print(int dist[], int V) {
    cout << "\nVertex  Distance" << endl;
    for (int i = 0; i < V; i++) {
        if (dist[i] < INT_MAX)
            cout << i << "\t" << dist[i] << endl;
        else
            cout << i << "\tINF" << endl;
    }
}

void Dijkstra(Graph graph, int src) {
    int V = graph.vertexNum;
    int mdist[V];      bool vset[V];      
        for (int i = 0; i < V; i++) {
        mdist[i] = INT_MAX;
        vset[i] = false;
    }

    mdist[src] = 0;

        for (int count = 0; count < V - 1; count++) {
        int u = minDistance(mdist, vset, V);

        vset[u] = true;

        for (int v = 0; v < V; v++) {
            if (!vset[v] && graph.edges[u][v] &&
                mdist[u] + graph.edges[u][v] < mdist[v]) {
                mdist[v] = mdist[u] + graph.edges[u][v];
            }
        }
    }

    print(mdist, V);
}

int main() {
    int V, E, gsrc;
    int src, dst, weight;
    cout << "Enter number of vertices: ";
    cin >> V;
    cout << "Enter number of edges: ";
    cin >> E;
    Graph G(V);
    for (int i = 0; i < E; i++) {
        cout << "\nEdge " << i + 1 << "\nEnter source: ";
        cin >> src;
        cout << "Enter destination: ";
        cin >> dst;
        cout << "Enter weight: ";
        cin >> weight;

                if (src >= 0 && src < V && dst >= 0 && dst < V) {
            G.addEdge(src, dst, weight);
        } else {
            cout << "source and/or destination out of bounds" << endl;
            i--;
            continue;
        }
    }
    cout << "\nEnter source:";
    cin >> gsrc;
    Dijkstra(G, gsrc);

    return 0;
}
#include <iostream>
using namespace std;

struct Item {
    int weight;
    int profit;
};

float profitPerUnit(Item x) { return (float)x.profit / (float)x.weight; }

int partition(Item arr[], int low, int high) {
    Item pivot = arr[high];      int i = (low - 1);       
    for (int j = low; j < high; j++) {
                        if (profitPerUnit(arr[j]) <= profitPerUnit(pivot)) {
            i++;              Item temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    Item temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return (i + 1);
}

void quickSort(Item arr[], int low, int high) {
    if (low < high) {
        int p = partition(arr, low, high);

        quickSort(arr, low, p - 1);
        quickSort(arr, p + 1, high);
    }
}

int main() {
    cout << "\nEnter the capacity of the knapsack : ";
    float capacity;
    cin >> capacity;
    cout << "\n Enter the number of Items : ";
    int n;
    cin >> n;
    Item itemArray[n];
    for (int i = 0; i < n; i++) {
        cout << "\nEnter the weight and profit of item " << i + 1 << " : ";
        cin >> itemArray[i].weight;
        cin >> itemArray[i].profit;
    }

    quickSort(itemArray, 0, n - 1);

    
    float maxProfit = 0;
    int i = n;
    while (capacity > 0 && --i >= 0) {
        if (capacity >= itemArray[i].weight) {
            maxProfit += itemArray[i].profit;
            capacity -= itemArray[i].weight;
            cout << "\n\t" << itemArray[i].weight << "\t"
                 << itemArray[i].profit;
        } else {
            maxProfit += profitPerUnit(itemArray[i]) * capacity;
            cout << "\n\t" << capacity << "\t"
                 << profitPerUnit(itemArray[i]) * capacity;
            capacity = 0;
            break;
        }
    }

    cout << "\nMax Profit : " << maxProfit;

    return 0;
}


#include <vector>
#include <iostream>
#include <cassert>


   
bool canJump(const std::vector<int> &nums) {
    auto lastPos = nums.size() - 1;
    for (auto i = nums.size() - 1; i >= 0; i--) {
        if (i + nums[i] >= lastPos) {
            lastPos = i;
        }
    }
    return lastPos == 0;
}



static void test(){
    std::vector<int> num1={4,3,1,0,5};
  assert(canJump(num1)==true);
  std::cout<<"Input: ";
  for(auto i: num1){
    std::cout<<i<<" ";
  }
  std::cout<<"Output: true"<<std::endl;
    std::vector<int> num2={3,2,1,0,4};
  assert(canJump(num2)==false);
  std::cout<<"Input: ";
  for(auto i: num2){
    std::cout<<i<<" ";
  }
  std::cout<<"Output: false"<<std::endl;
}



int main(){
    test();
    return 0;
}
#include <array>
#include <iostream>

void findMinimumEdge(int INFINITY, std::array<std::array<int, 6>, 6> graph) {
    for (int i = 0; i < graph.size(); i++) {
        int min = INFINITY;
        int minIndex = 0;
        for (int j = 0; j < graph.size(); j++) {
            if (graph[i][j] != 0 && graph[i][j] < min) {
                min = graph[i][j];
                minIndex = j;
            }
        }
        std::cout << i << "  -  " << minIndex << "\t" << graph[i][minIndex]
                  << std::endl;
    }
}

int main() {
    constexpr int INFINITY = 99999;
    std::array<std::array<int, 6>, 6> graph{
        0,        4,        1,        4,        INFINITY, INFINITY,
        4,        0,        3,        8,        3,        INFINITY,
        1,        3,        0,        INFINITY, 1,        INFINITY,
        4,        8,        INFINITY, 0,        5,        7,
        INFINITY, 3,        1,        5,        0,        INFINITY,
        INFINITY, INFINITY, INFINITY, 7,        INFINITY, 0};

    findMinimumEdge(INFINITY, graph);
    return 0;
}
#include <iostream>
using namespace std;

#define V 4
#define INFINITY 99999

int graph[V][V] = {{0, 5, 1, 2}, {5, 0, 3, 3}, {1, 3, 0, 4}, {2, 3, 4, 0}};

struct mst {
    bool visited;
    int key;
    int near;
};

mst MST_Array[V];

void initilize() {
    for (int i = 0; i < V; i++) {
        MST_Array[i].visited = false;
        MST_Array[i].key = INFINITY;          MST_Array[i].near = i;
    }

    MST_Array[0].key = 0;
}

void updateNear() {
    for (int v = 0; v < V; v++) {
        int min = INFINITY;
        int minIndex = 0;
        for (int i = 0; i < V; i++) {
            if (MST_Array[i].key < min && MST_Array[i].visited == false &&
                MST_Array[i].key != INFINITY) {
                min = MST_Array[i].key;
                minIndex = i;
            }
        }

        MST_Array[minIndex].visited = true;

        for (int i = 0; i < V; i++) {
            if (graph[minIndex][i] != 0 && graph[minIndex][i] < INFINITY) {
                if (graph[minIndex][i] < MST_Array[i].key) {
                    MST_Array[i].key = graph[minIndex][i];
                    MST_Array[i].near = minIndex;
                }
            }
        }
    }
}

void show() {
    for (int i = 0; i < V; i++) {
        cout << i << "  -  " << MST_Array[i].near << "\t"
             << graph[i][MST_Array[i].near] << "\n";
    }
}

int main() {
    initilize();
    updateNear();
    show();
    return 0;
}
#include <iostream>
#include <queue>
using namespace std;

struct MinHeapNode {
        char data;

        unsigned freq;

        MinHeapNode *left, *right;

    MinHeapNode(char data, unsigned freq)

    {
        left = right = NULL;
        this->data = data;
        this->freq = freq;
    }
};

struct compare {
    bool operator()(MinHeapNode* l, MinHeapNode* r)

    {
        return (l->freq > r->freq);
    }
};

void printCodes(struct MinHeapNode* root, string str) {
    if (!root)
        return;

    if (root->data != '$')
        cout << root->data << ": " << str << "\n";

    printCodes(root->left, str + "0");
    printCodes(root->right, str + "1");
}

void HuffmanCodes(char data[], int freq[], int size) {
    struct MinHeapNode *left, *right, *top;

        priority_queue<MinHeapNode*, vector<MinHeapNode*>, compare> minHeap;

    for (int i = 0; i < size; ++i)
        minHeap.push(new MinHeapNode(data[i], freq[i]));

        while (minHeap.size() != 1) {
                        left = minHeap.top();
        minHeap.pop();

        right = minHeap.top();
        minHeap.pop();

                                                                top = new MinHeapNode('$', left->freq + right->freq);

        top->left = left;
        top->right = right;

        minHeap.push(top);
    }

            printCodes(minHeap.top(), "");
}

int main() {
    char arr[] = {'a', 'b', 'c', 'd', 'e', 'f'};
    int freq[] = {5, 9, 12, 13, 16, 45};

    int size = sizeof(arr) / sizeof(arr[0]);

    HuffmanCodes(arr, freq, size);

    return 0;
}

#include <iostream>

struct node {
    int val;
    node *left;
    node *right;
};

struct Queue {
    node *t[100];
    int front;
    int rear;
};

Queue queue;

void enqueue(node *n) { queue.t[queue.rear++] = n; }

node *dequeue() { return (queue.t[queue.front++]); }

void Insert(node *n, int x) {
    if (x < n->val) {
        if (n->left == NULL) {
            node *temp = new node;
            temp->val = x;
            temp->left = NULL;
            temp->right = NULL;
            n->left = temp;
        } else {
            Insert(n->left, x);
        }
    } else {
        if (n->right == NULL) {
            node *temp = new node;
            temp->val = x;
            temp->left = NULL;
            temp->right = NULL;
            n->right = temp;
        } else {
            Insert(n->right, x);
        }
    }
}

int findMaxInLeftST(node *n) {
    while (n->right != NULL) {
        n = n->right;
    }
    return n->val;
}

void Remove(node *p, node *n, int x) {
    if (n->val == x) {
        if (n->right == NULL && n->left == NULL) {
            if (x < p->val) {
                p->right = NULL;
            } else {
                p->left = NULL;
            }
        } else if (n->right == NULL) {
            if (x < p->val) {
                p->right = n->left;
            } else {
                p->left = n->left;
            }
        } else if (n->left == NULL) {
            if (x < p->val) {
                p->right = n->right;
            } else {
                p->left = n->right;
            }
        } else {
            int y = findMaxInLeftST(n->left);
            n->val = y;
            Remove(n, n->right, y);
        }
    } else if (x < n->val) {
        Remove(n, n->left, x);
    } else {
        Remove(n, n->right, x);
    }
}

void BFT(node *n) {
    if (n != NULL) {
        std::cout << n->val << "  ";
        enqueue(n->left);
        enqueue(n->right);
        BFT(dequeue());
    }
}

void Pre(node *n) {
    if (n != NULL) {
        std::cout << n->val << "  ";
        Pre(n->left);
        Pre(n->right);
    }
}

void In(node *n) {
    if (n != NULL) {
        In(n->left);
        std::cout << n->val << "  ";
        In(n->right);
    }
}

void Post(node *n) {
    if (n != NULL) {
        Post(n->left);
        Post(n->right);
        std::cout << n->val << "  ";
    }
}

int main() {
    queue.front = 0;
    queue.rear = 0;
    int value;
    int ch;
    node *root = new node;
    std::cout << "\nEnter the value of root node :";
    std::cin >> value;
    root->val = value;
    root->left = NULL;
    root->right = NULL;
    do {
        std::cout << "\n1. Insert"
                  << "\n2. Delete"
                  << "\n3. Breadth First"
                  << "\n4. Preorder Depth First"
                  << "\n5. Inorder Depth First"
                  << "\n6. Postorder Depth First";

        std::cout << "\nEnter Your Choice : ";
        std::cin >> ch;
        int x;
        switch (ch) {
        case 1:
            std::cout << "\nEnter the value to be Inserted : ";
            std::cin >> x;
            Insert(root, x);
            break;
        case 2:
            std::cout << "\nEnter the value to be Deleted : ";
            std::cin >> x;
            Remove(root, root, x);
            break;
        case 3:
            BFT(root);
            break;
        case 4:
            Pre(root);
            break;
        case 5:
            In(root);
            break;
        case 6:
            Post(root);
            break;
        }
    } while (ch != 0);

    return 0;
}


#include <array>     #include <cassert>   #include <iostream>  

namespace data_structures {


namespace sparse_table {


constexpr uint32_t N = 12345;  constexpr uint8_t M = 14;      
struct Sparse_table {
    size_t n = 0;  
    

    std::array<int64_t, N> A = {};      std::array<std::array<int64_t, N>, M>
        ST{};      std::array<int64_t, N> LOG = {};  
    
    void buildST() {
        LOG[0] = -1;

        for (size_t i = 0; i < n; ++i) {
            ST[0][i] = static_cast<int64_t>(i);
            LOG[i + 1] = LOG[i] + !(i & (i + 1));          }

        for (size_t j = 1; static_cast<size_t>(1 << j) <= n; ++j) {
            for (size_t i = 0; static_cast<size_t>(i + (1 << j)) <= n; ++i) {
                

                int64_t x = ST[j - 1][i];                                                             int64_t y =
                    ST[j - 1]
                      [i + (1 << (j - 1))];                                               
                ST[j][i] =
                    (A[x] <= A[y] ? x : y);                                                           }
        }
    }

    
    int64_t query(int64_t l, int64_t r) {
        int64_t g = LOG[r - l + 1];          int64_t x = ST[g][l];                                         int64_t y =
            ST[g][r - (1 << g) + 1];                                        
        return (A[x] <= A[y] ? x : y);                                              }
};
}  }  

static void test() {

    std::array<int64_t, 10> testcase = {
        1, 2, 3, 4, 5,
        6, 7, 8, 9, 10};      size_t testcase_size =
        sizeof(testcase) / sizeof(testcase[0]);  
    data_structures::sparse_table::Sparse_table
        st{};  
    std::copy(std::begin(testcase), std::end(testcase),
              std::begin(st.A));      st.n = testcase_size;         
    st.buildST();  
        assert(st.query(1, 9) == 1);      assert(st.query(2, 6) == 2);      assert(st.query(3, 8) == 3);  
    std::cout << "Self-test implementations passed!" << std::endl;
}


int main(int argc, char *argv[]) {
    test();      return 0;
}

#include <array>
#include <cassert>
#include <iostream>
#include <memory>
#include <string>
#include <vector>


namespace data_structures {

class trie {
 private:
    static constexpr uint8_t NUM_CHARS = 26;      
    std::array<std::shared_ptr<trie>, NUM_CHARS << 1> arr;
    bool isEndofWord = false;  
    
    uint8_t char_to_int(const char& ch) const {
        if (ch >= 'A' && ch <= 'Z') {
            return ch - 'A';
        } else if (ch >= 'a' && ch <= 'z') {
            return ch - 'a' + NUM_CHARS;
        }

        std::cerr << "Invalid character present. Exiting...";
        std::exit(EXIT_FAILURE);
        return 0;
    }

    
    bool search(const std::shared_ptr<trie>& root, const std::string& str,
                int index) {
        if (index == str.length()) {
            if (!root->isEndofWord) {
                return false;
            }
            return true;
        }
        int j = char_to_int(str[index]);
        if (!root->arr[j]) {
            return false;
        }
        return search(root->arr[j], str, index + 1);
    }

 public:
    trie() = default;  
    
    void insert(const std::string& str) {
        std::shared_ptr<trie> root(nullptr);

        for (const char& ch : str) {
            int j = char_to_int(ch);
            if (root) {
                if (root->arr[j]) {
                    root = root->arr[j];
                } else {
                    std::shared_ptr<trie> temp(new trie());
                    root->arr[j] = temp;
                    root = temp;
                }
            } else if (arr[j]) {
                root = arr[j];
            } else {
                std::shared_ptr<trie> temp(new trie());
                arr[j] = temp;
                root = temp;
            }
        }
        root->isEndofWord = true;
    }

    
    bool search(const std::string& str, int index) {
        if (index == str.length()) {
            if (!isEndofWord) {
                return false;
            }
            return true;
        }
        int j = char_to_int(str[index]);
        if (!arr[j]) {
            return false;
        }
        return search(arr[j], str, index + 1);
    }

    
    bool deleteString(const std::string& str, int index) {
        if (index == str.length()) {
            if (!isEndofWord) {
                return false;
            }
            isEndofWord = false;
                                                            return true;
        }
        int j = char_to_int(str[index]);
        if (!arr[j]) {
            return false;
        }
        bool var = deleteString(str, index + 1);
        if (var) {
            arr[j].reset();
            if (isEndofWord) {
                return false;
            } else {
                int i = 0;
                for (i = 0; i < NUM_CHARS; i++) {
                    if (arr[i]) {
                        return false;
                    }
                }
                return true;
            }
        }
        std::cout << __func__ << ":" << __LINE__
                  << "Should not reach this line\n";
        return false;
    }
};
}  

static void test() {
    data_structures::trie root;
    root.insert("Hello");
    root.insert("World");

    assert(!root.search("hello", 0));
    std::cout << "hello - " << root.search("hello", 0) << "\n";

    assert(root.search("Hello", 0));
    std::cout << "Hello - " << root.search("Hello", 0) << "\n";

    assert(!root.search("Word", 0));
    std::cout << "Word - " << root.search("Word", 0) << "\n";

    assert(root.search("World", 0));
    std::cout << "World - " << root.search("World", 0) << "\n";

                }


int main() {
    test();

    return 0;
}
#include <iostream>
#include <string>

#include "./queue.h"

int main() {
    queue<std::string> q;
    std::cout << "---------------------- Test construct ----------------------"
              << std::endl;
    q.display();
    std::cout
        << "---------------------- Test isEmptyQueue ----------------------"
        << std::endl;
    if (q.isEmptyQueue())
        std::cout << "PASS" << std::endl;
    else
        std::cout << "FAIL" << std::endl;
    std::cout << "---------------------- Test enQueue ----------------------"
              << std::endl;
    std::cout << "After Hai, Jeff, Tom, Jkingston go into queue: " << std::endl;
    q.enQueue("Hai");
    q.enQueue("Jeff");
    q.enQueue("Tom");
    q.enQueue("Jkingston");
    q.display();
    std::cout << "---------------------- Test front ----------------------"
              << std::endl;
    std::string value = q.front();
    if (value == "Hai")
        std::cout << "PASS" << std::endl;
    else
        std::cout << "FAIL" << std::endl;
    std::cout << "---------------------- Test deQueue ----------------------"
              << std::endl;
    q.display();
    q.deQueue();
    q.deQueue();
    std::cout << "After Hai, Jeff left the queue: " << std::endl;
    q.display();
    return 0;
}


#include <cassert>
#include <iostream>
#include <stack>

namespace {

template <typename T>
class MyQueue {
 private:
    std::stack<T> s1, s2;

 public:
    
    MyQueue() = default;

    
    void push(T x);

    
    const T& pop();

    
    const T& peek() const;

    
    bool empty() const;
};


template <typename T>
void MyQueue<T>::push(T x) {
    while (!s2.empty()) {
        s1.push(s2.top());
        s2.pop();
    }
    s2.push(x);
    while (!s1.empty()) {
        s2.push(s1.top());
        s1.pop();
    }
}


template <typename T>
const T& MyQueue<T>::pop() {
    const T& temp = MyQueue::peek();
    s2.pop();
    return temp;
}


template <typename T>
const T& MyQueue<T>::peek() const {
    if (!empty()) {
        return s2.top();
    }
    std::cerr << "Queue is empty" << std::endl;
    exit(0);
}


template <typename T>
bool MyQueue<T>::empty() const {
    return s2.empty() && s1.empty();
}
}  

void queue_test() {
    MyQueue<int> que;
    std::cout << "Test #1\n";
    que.push(2);
    que.push(5);
    que.push(0);
    assert(que.peek() == 2);
    assert(que.pop() == 2);
    assert(que.peek() == 5);
    assert(que.pop() == 5);
    assert(que.peek() == 0);
    assert(que.pop() == 0);
    assert(que.empty() == true);
    std::cout << "PASSED\n";

    std::cout << "Test #2\n";
    que.push(-1);
    assert(que.empty() == false);
    assert(que.peek() == -1);
    assert(que.pop() == -1);
    std::cout << "PASSED\n";

    MyQueue<double> que2;
    std::cout << "Test #3\n";
    que2.push(2.31223);
    que2.push(3.1415926);
    que2.push(2.92);

    assert(que2.peek() == 2.31223);
    assert(que2.pop() == 2.31223);
    assert(que2.peek() == 3.1415926);
    assert(que2.pop() == 3.1415926);
    assert(que2.peek() == 2.92);
    assert(que2.pop() == 2.92);
    std::cout << "PASSED\n";
}


int main() {
    queue_test();
    return 0;
}

#include <cassert>        #include <iostream>       #include <memory>         #include <stack>          #include <unordered_map>  #include <vector>         

namespace data_structures {


namespace trie_using_hashmap {


class Trie {
 private:
    
    struct Node {
        std::unordered_map<char16_t, std::shared_ptr<Node>>
            children;                                 bool word_end = false;      };

    std::shared_ptr<Node> root_node =
        std::make_shared<Node>();  
 public:
        Trie() = default;

    
    void insert(const std::string& word) {
        std::shared_ptr<Node> curr = root_node;
        for (char ch : word) {
            if (curr->children.find(ch) == curr->children.end()) {
                curr->children[ch] = std::make_shared<Node>();
            }
            curr = curr->children[ch];
        }

        if (!curr->word_end && curr != root_node) {
            curr->word_end = true;
        }
    }

    
    bool search(const std::string& word) {
        std::shared_ptr<Node> curr = root_node;
        for (char ch : word) {
            if (curr->children.find(ch) == curr->children.end()) {
                return false;
            }
            curr = curr->children[ch];
            if (!curr) {
                return false;
            }
        }

        if (curr->word_end) {
            return true;
        } else {
            return false;
        }
    }

    
    bool startwith(const std::string& prefix) {
        std::shared_ptr<Node> curr = root_node;
        for (char ch : prefix) {
            if (curr->children.find(ch) == curr->children.end()) {
                return false;
            }
            curr = curr->children[ch];
        }
        return true;
    }

    
    void delete_word(std::string word) {
        std::shared_ptr<Node> curr = root_node;
        std::stack<std::shared_ptr<Node>> nodes;
        int cnt = 0;
        for (char ch : word) {
            if (curr->children.find(ch) == curr->children.end()) {
                return;
            }
            if (curr->word_end) {
                cnt++;
            }

            nodes.push(curr->children[ch]);
            curr = curr->children[ch];
        }
                        if (nodes.top()->word_end) {
            nodes.top()->word_end = false;
        }
                        while (!(nodes.top()->word_end) && nodes.top()->children.empty()) {
            nodes.pop();
            nodes.top()->children.erase(word.back());
            word.pop_back();
        }
    }

    
    std::vector<std::string> get_all_words(std::vector<std::string> results,
                                           const std::shared_ptr<Node>& element,
                                           std::string prefix) {
        if (element->word_end) {
            results.push_back(prefix);
        }
        if (element->children.empty()) {
            return results;
        }
        for (auto const& x : element->children) {
            std::string key = "";
            key = x.first;
            prefix += key;

            results =
                get_all_words(results, element->children[x.first], prefix);

            prefix.pop_back();
        }

        return results;
    }

    
    std::vector<std::string> predict_words(const std::string& prefix) {
        std::vector<std::string> result;
        std::shared_ptr<Node> curr = root_node;
        
        for (char ch : prefix) {
            if (curr->children.find(ch) == curr->children.end()) {
                return result;
            }

            curr = curr->children[ch];
        }

                if (curr->word_end && curr->children.empty()) {
            result.push_back(prefix);
            return result;
        }

        result = get_all_words(
            result, curr,
            prefix);  
        return result;
    }
};
}  }  

static void test() {
    data_structures::trie_using_hashmap::Trie obj;
            obj.insert("app");
    obj.insert("abscond");
    obj.insert("about");
    obj.insert("apps");
    obj.insert("apen");
    obj.insert("apples");
    obj.insert("apple");
    obj.insert("approach");
    obj.insert("bus");
    obj.insert("buses");
    obj.insert("Apple");
    obj.insert("Bounce");

    assert(!obj.search("appy"));
    std::cout << "appy is not a word in trie" << std::endl;

    assert(!obj.search("car"));
    std::cout << "car is not a word in trie" << std::endl;
    assert(obj.search("app"));
    assert(obj.search("apple"));
    assert(obj.search("apples"));
    assert(obj.search("apps"));
    assert(obj.search("apen"));
    assert(obj.search("approach"));
    assert(obj.search("about"));
    assert(obj.search("abscond"));
    assert(obj.search("bus"));
    assert(obj.search("buses"));
    assert(obj.search("Bounce"));
    assert(obj.search("Apple"));

    std::cout << "All the Inserted words are present in the trie" << std::endl;

        assert(!obj.startwith("approachs"));
    assert(obj.startwith("approach"));
    assert(obj.startwith("about"));
    assert(!obj.startwith("appy"));
    assert(obj.startwith("abscond"));
    assert(obj.startwith("bus"));
    assert(obj.startwith("buses"));
    assert(obj.startwith("Bounce"));
    assert(obj.startwith("Apple"));
    assert(obj.startwith("abs"));
    assert(obj.startwith("b"));
    assert(obj.startwith("bus"));
    assert(obj.startwith("Bo"));
    assert(obj.startwith("A"));
    assert(!obj.startwith("Ca"));

    assert(!obj.startwith("C"));

    std::cout << "All the tests passed for startwith method" << std::endl;

    
    std::vector<std::string> pred_words = obj.predict_words("a");

    for (const std::string& str : obj.predict_words("a")) {
        std::cout << str << std::endl;
    }
    assert(pred_words.size() == 8);
    std::cout << "Returned all words that start with prefix a " << std::endl;
    pred_words = obj.predict_words("app");

    for (const std::string& str : pred_words) {
        std::cout << str << std::endl;
    }

    assert(pred_words.size() == 5);
    std::cout << "Returned all words that start with prefix app " << std::endl;
    pred_words = obj.predict_words("A");

    for (const std::string& str : pred_words) {
        std::cout << str << std::endl;
    }

    assert(pred_words.size() == 1);
    std::cout << "Returned all words that start with prefix A " << std::endl;
    pred_words = obj.predict_words("bu");

    for (const std::string& str : pred_words) {
        std::cout << str << std::endl;
    }

    assert(pred_words.size() == 2);
    std::cout << "Returned all words that start with prefix bu " << std::endl;

    
    obj.delete_word("app");
    assert(!obj.search("app"));
    std::cout << "word app is deleted sucessful" << std::endl;

    pred_words = obj.predict_words("app");
    for (const std::string& str : pred_words) {
        std::cout << str << std::endl;
    }
    assert(pred_words.size() == 4);
    std::cout << "app is deleted sucessful" << std::endl;

    
    obj.insert("苹果");
    assert(obj.startwith("苹"));
    pred_words = obj.predict_words("h");

    assert(pred_words.size() == 0);
    std::cout << "No word starts with prefix h in trie" << std::endl;

    std::cout << "All tests passed" << std::endl;
}


int main() {
    test();      return 0;
}


#include <iostream> #include <array>   #include <cassert> 

namespace data_structures {

namespace list_array {
    
    struct list {
        std::array<uint64_t, 50> data{};         uint64_t top = 0;         bool isSorted = false;         
        uint64_t BinarySearch(const std::array<uint64_t, 50> &dataArr, const uint64_t &first, const uint64_t &last,
                              const uint64_t &val) {
                        if (last < first) {
                return -1;
            }
            uint64_t mid = (first + last) / 2;
                        if (dataArr[mid] == val)
                return mid;
                            else if (val < dataArr[mid])
                return (BinarySearch(dataArr, first, mid - 1, val));
                            else if (val > dataArr[mid])
                return (BinarySearch(dataArr, mid + 1, last, val));

            std::cerr << __func__ << ":" << __LINE__ << ": Undefined condition\n";
            return -1;
        }

        
        uint64_t LinearSearch(const std::array<uint64_t, 50> &dataArr, const uint64_t &val) const {
                        for (uint64_t i = 0; i < top; i++) {
                if (dataArr[i] == val) {
                    return i;                 }
            }
                        return -1;
        }
	
        uint64_t search(const uint64_t &val) {
            uint64_t pos;                         if (isSorted) {
                pos = BinarySearch(data, 0, top - 1, val);
            } else {
                pos = LinearSearch(data, val);
            }
                                    if (pos != -1) {
                std::cout << "\nElement found at position : " << pos;
            } else {
                std::cout << "\nElement not found";
            }
                        return pos;
        }

        
        void sort() {
                        for (uint64_t i = 0; i < top; i++) {
                uint64_t min_idx = i;                 for (uint64_t j = i + 1; j < top; j++) {
                                        if (data[j] < data[min_idx]) {
                        min_idx = j;                     }
                }
                                std::swap(data[min_idx], data[i]);
            }
                        isSorted = true;
        }

        
        void insert(const uint64_t &val) {
                        if (top == 49) {
                std::cout << "\nOverflow";
                return;
            }
                                    if (!isSorted) {
                data[top] = val;
                top++;
            } else {
                uint64_t pos = 0;                                 for (uint64_t i = 0; i < top - 1; i++) {
                                        if (data[i] <= val && val <= data[i + 1]) {
                        pos = i + 1;                         break;                     }
                }
                                if (pos == 0) {
                    pos = top - 1;
                }
                                for (uint64_t i = top; i > pos; i--) {
                    data[i] = data[i - 1];
                }
                top++;                 data[pos] = val;             }
        }

        
        void remove(const uint64_t &val) {
            uint64_t pos = search(val);                         if (pos == -1) {
                std::cout << "\n Element does not present in the list ";
                return;
            }
            std::cout << "\n" << data[pos] << " deleted";                         for (uint64_t i = pos; i < top; i++) {
                data[i] = data[i + 1];
            }
            top--;         }

        
        void show() {
                        std::cout << '\n';
            for (uint64_t i = 0; i < top; i++) {
                std::cout << data[i] << " ";             }
        }
    }; } } 

static void test() {
    data_structures::list_array::list L;

        L.insert(11);
    L.insert(12);
    assert(L.top == 2);
    L.insert(15);
    L.insert(10);
    L.insert(12);
    L.insert(20);
    L.insert(18);
    assert(L.top == 7);
    L.show(); 
        L.remove(12);     L.remove(15);     assert(L.top == 5);
    L.remove(50);     assert(L.top == 5);

        assert(L.search(11) == 0);     assert(L.search(12) == 2);
    assert(L.search(50) == -1); 
        L.sort();
    assert(L.isSorted == true);
    L.show();

        assert(L.search(11) == 1);     assert(L.search(12) == 2);
    assert(L.search(50) == -1); }


int main() {
    test();     return 0;
}


#include <iostream>
#include <vector>

using std::cout;
using std::endl;
using std::vector;

vector<int> root, rank;


void CreateSet(int n) {
    root = vector<int>(n + 1);
    rank = vector<int>(n + 1, 1);
    for (int i = 1; i <= n; ++i) {
        root[i] = i;
    }
}


int Find(int x) {
    if (root[x] == x) {
        return x;
    }
    return root[x] = Find(root[x]);
}


bool InSameUnion(int x, int y) { return Find(x) == Find(y); }


void Union(int x, int y) {
    int a = Find(x), b = Find(y);
    if (a != b) {
        if (rank[a] < rank[b]) {
            root[a] = b;
        } else if (rank[a] > rank[b]) {
            root[b] = a;
        } else {
            root[a] = b;
            ++rank[b];
        }
    }
}


int main() {
        int n = 100;
    CreateSet(n);
    for (int i = 1; i <= 100; ++i) {
        if (root[i] != i) {
            cout << "Fail" << endl;
            break;
        }
    }
        cout << "1 and 2 are initially not in the same subset" << endl;
    if (InSameUnion(1, 2)) {
        cout << "Fail" << endl;
    }
    Union(1, 2);
    cout << "1 and 2 are now in the same subset" << endl;
    if (!InSameUnion(1, 2)) {
        cout << "Fail" << endl;
    }
    return 0;
}

#include <cassert>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <string>

#include "./stack.h"

int main(int argc, char* argv[]) {
    double GPA;
    double highestGPA;
    std::string name;

    assert(argc == 2);
    std::ifstream infile;
    stack<std::string> stk;

    infile.open(argv[1]);
    std::cout << std::fixed << std::showpoint;
    std::cout << std::setprecision(2);
    infile >> GPA >> name;
    highestGPA = GPA;

    while (infile) {
        if (GPA > highestGPA) {
            stk.clear();
            stk.push(name);
            highestGPA = GPA;
        } else if (GPA == highestGPA) {
            stk.push(name);
        }
        infile >> GPA >> name;
    }
    std::cout << "Highest GPA: " << highestGPA << std::endl;
    std::cout << "Students the highest GPA are: " << std::endl;
    while (!stk.isEmptyStack()) {
        std::cout << stk.top() << std::endl;
        stk.pop();
    }
    std::cout << std::endl;
    return 0;
}


#include <cassert>
#include <functional>
#include <iostream>
#include <memory>
#include <vector>


template <class T>
class binary_search_tree {
 private:
    
    struct bst_node {
        T value; 
        std::unique_ptr<bst_node> left; 
        std::unique_ptr<bst_node> right; 

        
        explicit bst_node(T _value) {
            value = _value;
            left = nullptr;
            right = nullptr;
        }
    };

    std::unique_ptr<bst_node> root_; 
    std::size_t size_ = 0; 

    
    bool find_max(std::unique_ptr<bst_node>& node, T& ret_value) {
        if (!node) {
            return false;
        } else if (!node->right) {
            ret_value = node->value;
            return true;
        }
        return find_max(node->right, ret_value);
    }

    
    bool find_min(std::unique_ptr<bst_node>& node, T& ret_value) {
        if (!node) {
            return false;
        } else if (!node->left) {
            ret_value = node->value;
            return true;
        }

        return find_min(node->left, ret_value);
    }

    
    bool insert(std::unique_ptr<bst_node>& node, T new_value) {
        if (root_ == node && !root_) {
            root_ = std::unique_ptr<bst_node>(new bst_node(new_value));
            return true;
        }

        if (new_value < node->value) {
            if (!node->left) {
                node->left = std::unique_ptr<bst_node>(new bst_node(new_value));
                return true;
            } else {
                return insert(node->left, new_value);
            }
        } else if (new_value > node->value) {
            if (!node->right) {
                node->right =
                    std::unique_ptr<bst_node>(new bst_node(new_value));
                return true;
            } else {
                return insert(node->right, new_value);
            }
        } else {
            return false;
        }
    }

    
    bool remove(std::unique_ptr<bst_node>& parent,
                std::unique_ptr<bst_node>& node, T rm_value) {
        if (!node) {
            return false;
        }

        if (node->value == rm_value) {
            if (node->left && node->right) {
                T successor_node_value{};
                find_max(node->left, successor_node_value);
                remove(root_, root_, successor_node_value);
                node->value = successor_node_value;
                return true;
            } else if (node->left || node->right) {
                std::unique_ptr<bst_node>& non_null =
                    (node->left ? node->left : node->right);

                if (node == root_) {
                    root_ = std::move(non_null);
                } else if (rm_value < parent->value) {
                    parent->left = std::move(non_null);
                } else {
                    parent->right = std::move(non_null);
                }

                return true;
            } else {
                if (node == root_) {
                    root_.reset(nullptr);
                } else if (rm_value < parent->value) {
                    parent->left.reset(nullptr);
                } else {
                    parent->right.reset(nullptr);
                }

                return true;
            }
        } else if (rm_value < node->value) {
            return remove(node, node->left, rm_value);
        } else {
            return remove(node, node->right, rm_value);
        }
    }

    
    bool contains(std::unique_ptr<bst_node>& node, T value) {
        if (!node) {
            return false;
        }

        if (value < node->value) {
            return contains(node->left, value);
        } else if (value > node->value) {
            return contains(node->right, value);
        } else {
            return true;
        }
    }

    
    void traverse_inorder(std::function<void(T)> callback,
                          std::unique_ptr<bst_node>& node) {
        if (!node) {
            return;
        }

        traverse_inorder(callback, node->left);
        callback(node->value);
        traverse_inorder(callback, node->right);
    }

    
    void traverse_preorder(std::function<void(T)> callback,
                           std::unique_ptr<bst_node>& node) {
        if (!node) {
            return;
        }

        callback(node->value);
        traverse_preorder(callback, node->left);
        traverse_preorder(callback, node->right);
    }

    
    void traverse_postorder(std::function<void(T)> callback,
                            std::unique_ptr<bst_node>& node) {
        if (!node) {
            return;
        }

        traverse_postorder(callback, node->left);
        traverse_postorder(callback, node->right);
        callback(node->value);
    }

 public:
    
    binary_search_tree() {
        root_ = nullptr;
        size_ = 0;
    }

    
    bool insert(T new_value) {
        bool result = insert(root_, new_value);
        if (result) {
            size_++;
        }
        return result;
    }

    
    bool remove(T rm_value) {
        bool result = remove(root_, root_, rm_value);
        if (result) {
            size_--;
        }
        return result;
    }

    
    bool contains(T value) { return contains(root_, value); }

    
    bool find_min(T& ret_value) { return find_min(root_, ret_value); }

    
    bool find_max(T& ret_value) { return find_max(root_, ret_value); }

    
    std::size_t size() { return size_; }

    
    std::vector<T> get_elements_inorder() {
        std::vector<T> result;
        traverse_inorder([&](T node_value) { result.push_back(node_value); },
                         root_);
        return result;
    }

    
    std::vector<T> get_elements_preorder() {
        std::vector<T> result;
        traverse_preorder([&](T node_value) { result.push_back(node_value); },
                          root_);
        return result;
    }

    
    std::vector<T> get_elements_postorder() {
        std::vector<T> result;
        traverse_postorder([&](T node_value) { result.push_back(node_value); },
                           root_);
        return result;
    }
};


static void test_insert() {
    std::cout << "Testing BST insert...";

    binary_search_tree<int> tree;
    bool res = tree.insert(5);
    int min = -1, max = -1;
    assert(res);
    assert(tree.find_max(max));
    assert(tree.find_min(min));
    assert(max == 5);
    assert(min == 5);
    assert(tree.size() == 1);

    tree.insert(4);
    tree.insert(3);
    tree.insert(6);
    assert(tree.find_max(max));
    assert(tree.find_min(min));
    assert(max == 6);
    assert(min == 3);
    assert(tree.size() == 4);

    bool fail_res = tree.insert(4);
    assert(!fail_res);
    assert(tree.size() == 4);

    std::cout << "ok" << std::endl;
}


static void test_remove() {
    std::cout << "Testing BST remove...";

    binary_search_tree<int> tree;
    tree.insert(5);
    tree.insert(4);
    tree.insert(3);
    tree.insert(6);

    bool res = tree.remove(5);
    int min = -1, max = -1;
    assert(res);
    assert(tree.find_max(max));
    assert(tree.find_min(min));
    assert(max == 6);
    assert(min == 3);
    assert(tree.size() == 3);
    assert(tree.contains(5) == false);

    tree.remove(4);
    tree.remove(3);
    tree.remove(6);
    assert(tree.size() == 0);
    assert(tree.contains(6) == false);

    bool fail_res = tree.remove(5);
    assert(!fail_res);
    assert(tree.size() == 0);

    std::cout << "ok" << std::endl;
}


static void test_contains() {
    std::cout << "Testing BST contains...";

    binary_search_tree<int> tree;
    tree.insert(5);
    tree.insert(4);
    tree.insert(3);
    tree.insert(6);

    assert(tree.contains(5));
    assert(tree.contains(4));
    assert(tree.contains(3));
    assert(tree.contains(6));
    assert(!tree.contains(999));

    std::cout << "ok" << std::endl;
}


static void test_find_min() {
    std::cout << "Testing BST find_min...";

    int min = 0;
    binary_search_tree<int> tree;
    assert(!tree.find_min(min));

    tree.insert(5);
    tree.insert(4);
    tree.insert(3);
    tree.insert(6);

    assert(tree.find_min(min));
    assert(min == 3);

    std::cout << "ok" << std::endl;
}


static void test_find_max() {
    std::cout << "Testing BST find_max...";

    int max = 0;
    binary_search_tree<int> tree;
    assert(!tree.find_max(max));

    tree.insert(5);
    tree.insert(4);
    tree.insert(3);
    tree.insert(6);

    assert(tree.find_max(max));
    assert(max == 6);

    std::cout << "ok" << std::endl;
}


static void test_get_elements_inorder() {
    std::cout << "Testing BST get_elements_inorder...";

    binary_search_tree<int> tree;
    tree.insert(5);
    tree.insert(4);
    tree.insert(3);
    tree.insert(6);

    std::vector<int> expected = {3, 4, 5, 6};
    std::vector<int> actual = tree.get_elements_inorder();
    assert(actual == expected);

    std::cout << "ok" << std::endl;
}


static void test_get_elements_preorder() {
    std::cout << "Testing BST get_elements_preorder...";

    binary_search_tree<int> tree;
    tree.insert(5);
    tree.insert(4);
    tree.insert(3);
    tree.insert(6);

    std::vector<int> expected = {5, 4, 3, 6};
    std::vector<int> actual = tree.get_elements_preorder();
    assert(actual == expected);

    std::cout << "ok" << std::endl;
}


static void test_get_elements_postorder() {
    std::cout << "Testing BST get_elements_postorder...";

    binary_search_tree<int> tree;
    tree.insert(5);
    tree.insert(4);
    tree.insert(3);
    tree.insert(6);

    std::vector<int> expected = {3, 4, 6, 5};
    std::vector<int> actual = tree.get_elements_postorder();
    assert(actual == expected);

    std::cout << "ok" << std::endl;
}

int main() {
    test_insert();
    test_remove();
    test_contains();
    test_find_max();
    test_find_min();
    test_get_elements_inorder();
    test_get_elements_preorder();
    test_get_elements_postorder();
}


#include <cassert>   #include <iostream>  #include <vector>    
using std::cout;
using std::endl;
using std::vector;


class dsu {
 private:
    vector<uint64_t> p;               vector<uint64_t> depth;           vector<uint64_t> setSize;         vector<uint64_t> maxElement;      vector<uint64_t> minElement;   public:
    
    explicit dsu(uint64_t n) {
        p.assign(n, 0);
                for (uint64_t i = 0; i < n; i++) {
            p[i] = i;
        }
                depth.assign(n, 0);
        maxElement.assign(n, 0);
        minElement.assign(n, 0);
        for (uint64_t i = 0; i < n; i++) {
            depth[i] = 0;
            maxElement[i] = i;
            minElement[i] = i;
        }
        setSize.assign(n, 0);
                for (uint64_t i = 0; i < n; i++) {
            setSize[i] = 1;
        }
    }

    
    uint64_t findSet(uint64_t i) {
                if (p[i] == i) {
            return i;
        }
        return (p[i] = findSet(p[i]));
    }
    
    void UnionSet(uint64_t i, uint64_t j) {
                if (isSame(i, j)) {
            return;
        }

                uint64_t x = findSet(i);
        uint64_t y = findSet(j);

                        if (depth[x] > depth[y]) {
            std::swap(x, y);
        }
                p[x] = y;

                if (depth[x] == depth[y]) {
            depth[y]++;
        }
                setSize[y] += setSize[x];
                maxElement[y] = std::max(maxElement[x], maxElement[y]);
        minElement[y] = std::min(minElement[x], minElement[y]);
    }
    
    bool isSame(uint64_t i, uint64_t j) {
        if (findSet(i) == findSet(j)) {
            return true;
        }
        return false;
    }
    
    vector<uint64_t> get(uint64_t i) {
        vector<uint64_t> ans;
        ans.push_back(get_min(i));
        ans.push_back(get_max(i));
        ans.push_back(size(i));
        return ans;
    }
    
    uint64_t size(uint64_t i) { return setSize[findSet(i)]; }
    
    uint64_t get_max(uint64_t i) { return maxElement[findSet(i)]; }
    
    uint64_t get_min(uint64_t i) { return minElement[findSet(i)]; }
};


static void test1() {
        uint64_t n = 10;      dsu d(n + 1);             d.UnionSet(1, 2);      d.UnionSet(1, 4);      vector<uint64_t> ans = {1, 4, 3};
    for (uint64_t i = 0; i < ans.size(); i++) {
        assert(d.get(4).at(i) == ans[i]);      }
    cout << "1st test passed!" << endl;
}

static void test2() {
        uint64_t n = 10;      dsu d(n + 1);             d.UnionSet(3, 5);
    d.UnionSet(5, 6);
    d.UnionSet(5, 7);
    vector<uint64_t> ans = {3, 7, 4};
    for (uint64_t i = 0; i < ans.size(); i++) {
        assert(d.get(3).at(i) == ans[i]);      }
    cout << "2nd test passed!" << endl;
}


int main() {
    uint64_t n = 10;      dsu d(n + 1);     
    test1();      test2();  
    return 0;
}


#include <array>
#include <cstring>
#include <ctime>
#include <iostream>
#include <memory>
#include <vector>


namespace data_structures {
constexpr int MAX_LEVEL = 2;        constexpr float PROBABILITY = 0.5;  

struct Node {
    int key;          void* value;      std::vector<std::shared_ptr<Node>>
        forward;  
    
    Node(int key, int level, void* value = nullptr) : key(key), value(value) {
                for (int i = 0; i < (level + 1); i++) {
            forward.push_back(nullptr);
        }
    }
};


class SkipList {
    int level;                         std::shared_ptr<Node> header;  
 public:
    
    SkipList() {
        level = 0;
                header = std::make_shared<Node>(-1, MAX_LEVEL);
    }

    
    int randomLevel() {
        int lvl = 0;
        while (static_cast<float>(std::rand()) / RAND_MAX < PROBABILITY &&
               lvl < MAX_LEVEL) {
            lvl++;
        }
        return lvl;
    }

    
    void insertElement(int key, void* value) {
        std::cout << "Inserting" << key << "...";
        std::shared_ptr<Node> x = header;
        std::array<std::shared_ptr<Node>, MAX_LEVEL + 1> update;
        update.fill(nullptr);

        for (int i = level; i >= 0; i--) {
            while (x->forward[i] != nullptr && x->forward[i]->key < key) {
                x = x->forward[i];
            }
            update[i] = x;
        }

        x = x->forward[0];

        bool doesnt_exist = (x == nullptr || x->key != key);
        if (doesnt_exist) {
            int rlevel = randomLevel();

            if (rlevel > level) {
                for (int i = level + 1; i < rlevel + 1; i++) update[i] = header;

                                level = rlevel;
            }

            std::shared_ptr<Node> n =
                std::make_shared<Node>(key, rlevel, value);
            for (int i = 0; i <= rlevel; i++) {
                n->forward[i] = update[i]->forward[i];
                update[i]->forward[i] = n;
            }
            std::cout << "Inserted" << std::endl;

        } else {
            std::cout << "Exists" << std::endl;
        }
    }

    
    void deleteElement(int key) {
        std::shared_ptr<Node> x = header;

        std::array<std::shared_ptr<Node>, MAX_LEVEL + 1> update;
        update.fill(nullptr);

        for (int i = level; i >= 0; i--) {
            while (x->forward[i] != nullptr && x->forward[i]->key < key) {
                x = x->forward[i];
            }
            update[i] = x;
        }

        x = x->forward[0];

        bool doesnt_exist = (x == nullptr || x->key != key);

        if (!doesnt_exist) {
            for (int i = 0; i <= level; i++) {
                if (update[i]->forward[i] != x) {
                    break;
                }
                update[i]->forward[i] = x->forward[i];
            }
            while (level > 0 && header->forward[level] == nullptr) level--;
            std::cout << "Deleted" << std::endl;
        } else {
            std::cout << "Doesn't exist" << std::endl;
        }
    }

    
    void* searchElement(int key) {
        std::shared_ptr<Node> x = header;
        std::cout << "Searching for " << key << std::endl;

        for (int i = level; i >= 0; i--) {
            while (x->forward[i] && x->forward[i]->key < key) x = x->forward[i];
        }

        x = x->forward[0];
        if (x && x->key == key) {
            std::cout << "Found" << std::endl;
            return x->value;
        } else {
            std::cout << "Not Found" << std::endl;
            return nullptr;
        }
    }

    
    void displayList() {
        std::cout << "Displaying list:\n";
        for (int i = 0; i <= level; i++) {
            std::shared_ptr<Node> node = header->forward[i];
            std::cout << "Level " << (i) << ": ";
            while (node != nullptr) {
                std::cout << node->key << " ";
                node = node->forward[i];
            }
            std::cout << std::endl;
        }
    }
};

}  

int main() {
    std::srand(std::time(nullptr));

    data_structures::SkipList lst;

    for (int j = 0; j < (1 << (data_structures::MAX_LEVEL + 1)); j++) {
        int k = (std::rand() % (1 << (data_structures::MAX_LEVEL + 2)) + 1);
        lst.insertElement(k, &j);
    }

    lst.displayList();

    return 0;
}
#include <iostream>
#include <queue>



using namespace std;

struct Btree {
    int data;
    struct Btree *left;       struct Btree *right;  };

void insert(Btree **root, int d) {
    Btree *nn = new Btree();      nn->data = d;
    nn->left = NULL;
    nn->right = NULL;
    if (*root == NULL) {
        *root = nn;
        return;
    } else {
        queue<Btree *> q;
                q.push(*root);
        while (!q.empty()) {
            Btree *node = q.front();
                        q.pop();
            if (node->left)
                                q.push(node->left);
            else {
                                node->left = nn;
                return;
            }
            if (node->right)
                                q.push(node->right);
            else {
                                node->right = nn;
                return;
            }
        }
    }
}

void morrisInorder(Btree *root) {
    Btree *curr = root;
    Btree *temp;
    while (curr) {
        if (curr->left == NULL) {
            cout << curr->data << " ";
                        curr = curr->right;
        } else {
                        temp = curr->left;
                        while (temp->right && temp->right != curr) temp = temp->right;
                                    if (temp->right == NULL) {
                temp->right = curr;
                                curr = curr->left;
            }
                                    else if (temp->right == curr) {
                cout << curr->data << " ";
                temp->right = NULL;
                                curr = curr->right;
            }
        }
    }
}

int main() {
        Btree *root = NULL;
    int i;
    for (i = 1; i <= 7; i++) insert(&root, i);
    cout << "Morris Inorder: ";
    morrisInorder(root);
    return 0;
}
#include <iostream>
using namespace std;

struct node {
    int val;
    node *next;
};

node *front, *rear;

void Enque(int x) {
    if (rear == NULL) {
        node *n = new node;
        n->val = x;
        n->next = NULL;
        rear = n;
        front = n;
    }

    else {
        node *n = new node;
        n->val = x;
        n->next = NULL;
        rear->next = n;
        rear = n;
    }
}

void Deque() {
    if (rear == NULL && front == NULL) {
        cout << "\nUnderflow";
    } else {
        node *t = front;
        cout << "\n" << t->val << " deleted";
        front = front->next;
        delete t;
        if (front == NULL)
            rear = NULL;
    }
}

void show() {
    node *t = front;
    while (t != NULL) {
        cout << t->val << "\t";
        t = t->next;
    }
}

int main() {
    int ch, x;
    do {
        cout << "\n1. Enque";
        cout << "\n2. Deque";
        cout << "\n3. Print";
        cout << "\nEnter Your Choice : ";
        cin >> ch;
        if (ch == 1) {
            cout << "\nInsert : ";
            cin >> x;
            Enque(x);
        } else if (ch == 2) {
            Deque();
        } else if (ch == 3) {
            show();
        }
    } while (ch != 0);

    return 0;
}
#include <iostream>
#include <list>
using namespace std;

struct node {
    int val;
    node *left;
    node *right;
};

void CreateTree(node *curr, node *n, int x, char pos) {
    if (n != NULL) {
        char ch;
        cout << "\nLeft or Right of " << n->val << " : ";
        cin >> ch;
        if (ch == 'l')
            CreateTree(n, n->left, x, ch);
        else if (ch == 'r')
            CreateTree(n, n->right, x, ch);
    } else {
        node *t = new node;
        t->val = x;
        t->left = NULL;
        t->right = NULL;
        if (pos == 'l') {
            curr->left = t;
        } else if (pos == 'r') {
            curr->right = t;
        }
    }
}

void BFT(node *n) {
    list<node *> queue;

    queue.push_back(n);

    while (!queue.empty()) {
        n = queue.front();
        cout << n->val << "  ";
        queue.pop_front();

        if (n->left != NULL)
            queue.push_back(n->left);
        if (n->right != NULL)
            queue.push_back(n->right);
    }
}

void Pre(node *n) {
    if (n != NULL) {
        cout << n->val << "  ";
        Pre(n->left);
        Pre(n->right);
    }
}

void In(node *n) {
    if (n != NULL) {
        In(n->left);
        cout << n->val << "  ";
        In(n->right);
    }
}

void Post(node *n) {
    if (n != NULL) {
        Post(n->left);
        Post(n->right);
        cout << n->val << "  ";
    }
}

int main() {
    int value;
    int ch;
    node *root = new node;
    cout << "\nEnter the value of root node :";
    cin >> value;
    root->val = value;
    root->left = NULL;
    root->right = NULL;
    do {
        cout << "\n1. Insert";
        cout << "\n2. Breadth First";
        cout << "\n3. Preorder Depth First";
        cout << "\n4. Inorder Depth First";
        cout << "\n5. Postorder Depth First";

        cout << "\nEnter Your Choice : ";
        cin >> ch;
        switch (ch) {
        case 1:
            int x;
            char pos;
            cout << "\nEnter the value to be Inserted : ";
            cin >> x;
            cout << "\nLeft or Right of Root : ";
            cin >> pos;
            if (pos == 'l')
                CreateTree(root, root->left, x, pos);
            else if (pos == 'r')
                CreateTree(root, root->right, x, pos);
            break;
        case 2:
            BFT(root);
            break;
        case 3:
            Pre(root);
            break;
        case 4:
            In(root);
            break;
        case 5:
            Post(root);
            break;
        }
    } while (ch != 0);
}

#include <climits>
#include <iostream>
#include <utility>


class MinHeap {
    int *harr;          int capacity;       int heap_size;  
 public:
    
    explicit MinHeap(int cap) {
        heap_size = 0;
        capacity = cap;
        harr = new int[cap];
    }

    
    void MinHeapify(int);

    int parent(int i) { return (i - 1) / 2; }

    
    int left(int i) { return (2 * i + 1); }

    
    int right(int i) { return (2 * i + 2); }

    
    int extractMin();

    
    void decreaseKey(int i, int new_val);

    
    int getMin() { return harr[0]; }

    
    void deleteKey(int i);

    
    void insertKey(int k);

    ~MinHeap() { delete[] harr; }
};

void MinHeap::insertKey(int k) {
    if (heap_size == capacity) {
        std::cout << "\nOverflow: Could not insertKey\n";
        return;
    }

        heap_size++;
    int i = heap_size - 1;
    harr[i] = k;

        while (i != 0 && harr[parent(i)] > harr[i]) {
        std::swap(harr[i], harr[parent(i)]);
        i = parent(i);
    }
}


void MinHeap::decreaseKey(int i, int new_val) {
    harr[i] = new_val;
    while (i != 0 && harr[parent(i)] > harr[i]) {
        std::swap(harr[i], harr[parent(i)]);
        i = parent(i);
    }
}

int MinHeap::extractMin() {
    if (heap_size <= 0)
        return INT_MAX;
    if (heap_size == 1) {
        heap_size--;
        return harr[0];
    }

        int root = harr[0];
    harr[0] = harr[heap_size - 1];
    heap_size--;
    MinHeapify(0);

    return root;
}


void MinHeap::deleteKey(int i) {
    decreaseKey(i, INT_MIN);
    extractMin();
}


void MinHeap::MinHeapify(int i) {
    int l = left(i);
    int r = right(i);
    int smallest = i;
    if (l < heap_size && harr[l] < harr[i])
        smallest = l;
    if (r < heap_size && harr[r] < harr[smallest])
        smallest = r;
    if (smallest != i) {
        std::swap(harr[i], harr[smallest]);
        MinHeapify(smallest);
    }
}

int main() {
    MinHeap h(11);
    h.insertKey(3);
    h.insertKey(2);
    h.deleteKey(1);
    h.insertKey(15);
    h.insertKey(5);
    h.insertKey(4);
    h.insertKey(45);
    std::cout << h.extractMin() << " ";
    std::cout << h.getMin() << " ";
    h.decreaseKey(2, 1);
    std::cout << h.getMin();
    return 0;
}

#include <array>     #include <iostream>  
constexpr uint16_t max_size{10};  

namespace data_structures {


namespace queue_using_array {


class Queue_Array {
 public:
    void enqueue(const int16_t&);      int dequeue();                     void display() const;           private:
    int8_t front{-1};                         int8_t rear{-1};                          std::array<int16_t, max_size> arr{};  };


void Queue_Array::enqueue(const int16_t& ele) {
    if (rear == arr.size() - 1) {
        std::cout << "\nStack is full";
    } else if (front == -1 && rear == -1) {
        front = 0;
        rear = 0;
        arr[rear] = ele;
    } else if (rear < arr.size()) {
        ++rear;
        arr[rear] = ele;
    }
}


int Queue_Array::dequeue() {
    int8_t d{0};
    if (front == -1) {
        std::cout << "\nstack is empty ";
        return 0;
    } else if (front == rear) {
        d = arr.at(front);
        front = rear = -1;
    } else {
        d = arr.at(front++);
    }

    return d;
}


void Queue_Array::display() const {
    if (front == -1) {
        std::cout << "\nStack is empty";
    } else {
        for (int16_t i{front}; i <= rear; ++i) std::cout << arr.at(i) << " ";
    }
}

}  }  

int main() {
    int op{0}, data{0};
    data_structures::queue_using_array::Queue_Array ob;

    std::cout << "\n1. enqueue(Insertion) ";
    std::cout << "\n2. dequeue(Deletion)";
    std::cout << "\n3. Display";
    std::cout << "\n4. Exit";
    while (true) {
        std::cout << "\nEnter your choice ";
        std::cin >> op;
        if (op == 1) {
            std::cout << "Enter data  ";
            std::cin >> data;
            ob.enqueue(data);
        } else if (op == 2) {
            data = ob.dequeue();
            std::cout << "\ndequeue element is:\t" << data;
        } else if (op == 3) {
            ob.display();
        } else if (op == 4) {
            exit(0);
        } else {
            std::cout << "\nWrong choice ";
        }
    }

    return 0;
}

#include <cassert>   #include <iostream>  #include <queue>     

namespace data_structures {

namespace stack_using_queue {

struct Stack {
    std::queue<int64_t> main_q;           std::queue<int64_t> auxiliary_q;                                            uint32_t current_size = 0;        
    
    int top() { return main_q.front(); }

    
    void push(int val) {
        auxiliary_q.push(val);
        while (!main_q.empty()) {
            auxiliary_q.push(main_q.front());
            main_q.pop();
        }
        swap(main_q, auxiliary_q);
        current_size++;
    }

    
    void pop() {
        if (main_q.empty()) {
            return;
        }
        main_q.pop();
        current_size--;
    }

    
    int size() { return current_size; }
};
}  }  

static void test() {
    data_structures::stack_using_queue::Stack s;
    s.push(1);      s.push(2);      s.push(3);  
    assert(s.size() == 3);  
    assert(s.top() == 3);  
    s.pop();                   assert(s.top() == 2);  
    s.pop();      assert(s.top() == 1);

    s.push(5);                 assert(s.top() == 5);  
    s.pop();                   assert(s.top() == 1);  
    assert(s.size() == 1);  }


int main() {
    test();      return 0;
}

#include <iostream>

struct linkedlist {
    int data;
    linkedlist *next;
};
class stack_linkedList {
 public:
    linkedlist *front;
    linkedlist *rear;

    stack_linkedList() { front = rear = NULL; }
    void enqueue(int);
    int dequeue();
    void display();
};
void stack_linkedList::enqueue(int ele) {
    linkedlist *temp = new linkedlist();
    temp->data = ele;
    temp->next = NULL;

    if (front == NULL)
        front = rear = temp;
    else {
        rear->next = temp;
        rear = temp;
    }
}
int stack_linkedList::dequeue() {
    linkedlist *temp;
    int ele;
    if (front == NULL)
        std::cout << "\nStack is empty";
    else {
        temp = front;
        ele = temp->data;
        if (front == rear)              rear = rear->next;
        front = front->next;
        delete (temp);
    }
    return ele;
}
void stack_linkedList::display() {
    if (front == NULL)
        std::cout << "\nStack is empty";

    else {
        linkedlist *temp;
        temp = front;
        while (temp != NULL) {
            std::cout << temp->data << " ";
            temp = temp->next;
        }
    }
}

int main() {
    int op, data;
    stack_linkedList ob;
    std::cout << "\n1. enqueue(Insertion) ";
    std::cout << "\n2. dequeue(Deletion)";
    std::cout << "\n3. Display";
    std::cout << "\n4. Exit";

    while (1) {
        std::cout << "\nEnter your choice ";
        std::cin >> op;
        if (op == 1) {
            std::cout << "Enter data ";
            std::cin >> data;
            ob.enqueue(data);
        } else if (op == 2)
            data = ob.dequeue();
        else if (op == 3)
            ob.display();
        else if (op == 4)
            exit(0);
        else
            std::cout << "\nWrong choice ";
    }
    return 0;
}

#include <iostream>
#include <memory>
#include <string>


namespace data_structures {


namespace linked_list {


bool isDigit(const std::string& s) {
        for (char i : s) {
        if (!isdigit(i)) {
            return false;
        }
    }
    return true;
}


class link {
 private:
    int pvalue;                       std::shared_ptr<link> psucc;  
 public:
    
    int val() { return pvalue; }

    
    std::shared_ptr<link>& succ() { return psucc; }

    
    explicit link(int value = 0) : pvalue(value), psucc(nullptr) {}
};


class list {
 private:
    std::shared_ptr<link> first;      std::shared_ptr<link> last;    public:
    
    list() {
                first = std::make_shared<link>();
                last = nullptr;
    }

    bool isEmpty();

    void push_back(int new_elem);
    void push_front(int new_elem);
    void erase(int old_elem);
    void display();
    std::shared_ptr<link> search(int find_elem);
    void reverse();
};


bool list::isEmpty() {
    if (last == nullptr) {
        return true;
    } else {
        return false;
    }
}


void list::push_back(int new_elem) {
    if (isEmpty()) {
        first->succ() = std::make_shared<link>(new_elem);
        last = first->succ();
    } else {
        last->succ() = std::make_shared<link>(new_elem);
        last = last->succ();
    }
}


void list::push_front(int new_elem) {
    if (isEmpty()) {
        first->succ() = std::make_shared<link>(new_elem);
        last = first->succ();
    } else {
        std::shared_ptr<link> t = std::make_shared<link>(new_elem);
        t->succ() = first->succ();
        first->succ() = t;
    }
}


void list::erase(int old_elem) {
    if (isEmpty()) {
        std::cout << "List is Empty!";
        return;
    }
    std::shared_ptr<link> t = first;
    std::shared_ptr<link> to_be_removed = nullptr;
    while (t != last && t->succ()->val() != old_elem) {
        t = t->succ();
    }
    if (t == last) {
        std::cout << "Element not found\n";
        return;
    }
    to_be_removed = t->succ();
    t->succ() = t->succ()->succ();
    to_be_removed.reset();
    if (t->succ() == nullptr) {
        last = t;
    }
    if (first == last){
        last = nullptr;
    }
}


void list::display() {
    if (isEmpty()) {
        std::cout << "List is Empty!";
        return;
    }
    std::shared_ptr<link> t = first;
    while (t->succ() != nullptr) {
        std::cout << t->succ()->val() << "\t";
        t = t->succ();
    }
}


std::shared_ptr<link> list::search(int find_elem) {
    if (isEmpty()) {
        std::cout << "List is Empty!";
        return nullptr;
    }
    std::shared_ptr<link> t = first;
    while (t != last && t->succ()->val() != find_elem) {
        t = t->succ();
    }
    if (t == last) {
        std::cout << "Element not found\n";
        return nullptr;
    }
    std::cout << "Element was found\n";
    return t->succ();
}
}  }  

int main() {
    data_structures::linked_list::list l;
    int choice = 0;
    int x = 0;
    std::string s;
    do {
        std::cout << "\n1. Insert";
        std::cout << "\n2. Delete";
        std::cout << "\n3. Search";
        std::cout << "\n4. Print";
        std::cout << "\n0. Exit";
        std::cout << "\n\nEnter you choice : ";
        std::cin >> choice;
        switch (choice) {
            case 0:
                std::cout << "\nQuitting the program...\n";
                break;
            case 1:
                std::cout << "\nEnter the element to be inserted : ";
                std::cin >> s;

                if (data_structures::linked_list::isDigit(s)) {
                    x = std::stoi(s);
                    l.push_back(x);
                } else {
                    std::cout << "Wrong Input!\n";
                }
                break;
            case 2:
                std::cout << "\nEnter the element to be removed : ";
                std::cin >> s;
                if (data_structures::linked_list::isDigit(s)) {
                    x = std::stoi(s);
                    l.erase(x);
                } else {
                    std::cout << "Wrong Input!\n";
                }
                break;
            case 3:
                std::cout << "\nEnter the element to be searched : ";
                std::cin >> s;
                if (data_structures::linked_list::isDigit(s)) {
                    x = std::stoi(s);
                    std::shared_ptr<data_structures::linked_list::link> found =
                        l.search(x);
                } else {
                    std::cout << "Wrong Input!\n";
                }
                break;
            case 4:
                l.display();
                std::cout << "\n";
                break;
            default:
                std::cout << "Invalid Input\n" << std::endl;
                break;
        }
    } while (choice != 0);
    return 0;
}
#include <cstdio>
#include <cstdlib>
#include <iostream>

struct node {
    int val;
    node *prev;
    node *next;
} * start;

class double_linked_list {
 public:
    double_linked_list() { start = NULL; }
    void insert(int x);
    void remove(int x);
    void search(int x);
    void show();
    void reverseShow();
};

void double_linked_list::insert(int x) {
    node *t = start;
    if (start != NULL) {
        while (t->next != NULL) {
            t = t->next;
        }
        node *n = new node;
        t->next = n;
        n->prev = t;
        n->val = x;
        n->next = NULL;
    } else {
        node *n = new node;
        n->val = x;
        n->prev = NULL;
        n->next = NULL;
        start = n;
    }
}

void double_linked_list::remove(int x) {
    node *t = start;
    while (t != NULL && t->val != x) {
        t = t->next;
    }
    if (t == NULL) {
        return;
    }
    if (t->prev == NULL) {
        if (t->next == NULL) {
            start = NULL;
        } else {
            start = t->next;
            start->prev = NULL;
        }
    } else if (t->next == NULL) {
        t->prev->next = NULL;
    } else {
        t->prev->next = t->next;
        t->next->prev = t->prev;
    }
    delete t;
}

void double_linked_list::search(int x) {
    node *t = start;
    int found = 0;
    while (t != NULL) {
        if (t->val == x) {
            std::cout << "\nFound";
            found = 1;
            break;
        }
        t = t->next;
    }
    if (found == 0) {
        std::cout << "\nNot Found";
    }
}

void double_linked_list::show() {
    node *t = start;
    while (t != NULL) {
        std::cout << t->val << "\t";
        t = t->next;
    }
}

void double_linked_list::reverseShow() {
    node *t = start;
    while (t != NULL && t->next != NULL) {
        t = t->next;
    }
    while (t != NULL) {
        std::cout << t->val << "\t";
        t = t->prev;
    }
}

int main() {
    int choice, x;
    double_linked_list ob;
    do {
        std::cout << "\n1. Insert";
        std::cout << "\n2. Delete";
        std::cout << "\n3. Search";
        std::cout << "\n4. Forward print";
        std::cout << "\n5. Reverse print";
        std::cout << "\n\nEnter you choice : ";
        std::cin >> choice;
        switch (choice) {
        case 1:
            std::cout << "\nEnter the element to be inserted : ";
            std::cin >> x;
            ob.insert(x);
            break;
        case 2:
            std::cout << "\nEnter the element to be removed : ";
            std::cin >> x;
            ob.remove(x);
            break;
        case 3:
            std::cout << "\nEnter the element to be searched : ";
            std::cin >> x;
            ob.search(x);
            break;
        case 4:
            ob.show();
            break;
        case 5:
            ob.reverseShow();
            break;
        }
    } while (choice != 0);
    return 0;
}


#include <cassert>   #include <iostream>  #include <memory>    #include <new>       

namespace data_structures {

namespace linked_list {

class Node {
 public:
    int32_t val;      Node *next;   };


class list {
 private:
    Node *head;   public:
    
    list() {
        head = nullptr;      }
    bool isEmpty();
    void insert(int32_t new_elem);
    void reverseList();
    void display();
    int32_t top();
    int32_t last();
    int32_t traverse(int32_t index);
};


bool list::isEmpty() { return head == nullptr; }


void list::insert(int32_t n) {
    try {
        Node *new_node = new Node();
        Node *temp = nullptr;
        new_node->val = n;
        new_node->next = nullptr;
        if (isEmpty()) {
            head = new_node;
        } else {
            temp = head;
            while (temp->next != nullptr) {
                temp = temp->next;
            }
            temp->next = new_node;
        }
    } catch (std::bad_alloc &exception) {
        std::cerr << "bad_alloc detected: " << exception.what() << "\n";
    }
}


void list::reverseList() {
    Node *curr = head;
    Node *prev = nullptr, *next_node = nullptr;
    while (curr != nullptr) {
        next_node = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next_node;
    }
    head = prev;
}


int32_t list::top() {
    if (!isEmpty()) {
        return head->val;
    } else {
        throw std::logic_error("List is empty");
    }
}

int32_t list::last() {
    if (!isEmpty()) {
        Node *t = head;
        while (t->next != nullptr) {
            t = t->next;
        }
        return t->val;
    } else {
        throw std::logic_error("List is empty");
    }
}

int32_t list::traverse(int index) {
    Node *current = head;

    int count = 0;
    while (current != nullptr) {
        if (count == index) {
            return (current->val);
        }
        count++;
        current = current->next;
    }

    exit(1);
}

}  }  

static void test() {
    data_structures::linked_list::list L;
        L.insert(11);
    L.insert(12);
    L.insert(15);
    L.insert(10);
    L.insert(-12);
    L.insert(-20);
    L.insert(18);
    assert(L.top() == 11);
    assert(L.last() == 18);
    L.reverseList();
        assert(L.top() == 18);
    assert(L.traverse(1) == -20);
    assert(L.traverse(2) == -12);
    assert(L.traverse(3) == 10);
    assert(L.traverse(4) == 15);
    assert(L.traverse(5) == 12);
    assert(L.last() == 11);
    std::cout << "All tests have successfully passed!" << std::endl;
}


int main() {
    test();      return 0;
}

#include <iostream>  #include <memory>    #include <string>    

class Trie {
 private:
    static constexpr size_t ALPHABETS = 26;

    
    struct TrieNode {
                        std::shared_ptr<TrieNode> character[ALPHABETS]{nullptr};

        bool isEndOfWord{false};
    };

    
    inline static bool hasChildren(std::shared_ptr<TrieNode> node) {
        for (size_t i = 0; i < ALPHABETS; i++) {
            if (node->character[i]) {
                return true;
            }
        }
        return false;
    }

    
    std::shared_ptr<TrieNode> removeWordHelper(const std::string& word,
                                               std::shared_ptr<TrieNode> curr,
                                               size_t index) {
        if (word.size() == index) {
            if (curr->isEndOfWord) {
                curr->isEndOfWord = false;
            }
            if (hasChildren(curr)) {
                return curr;
            }
            return nullptr;
        }

        size_t idx = word[index] - 'a';

                        if (!curr->character[idx]) {
            throw std::runtime_error(std::move(std::string("Word not found.")));
        }

        curr->character[idx] =
            removeWordHelper(word, curr->character[idx], index + 1);

                                                                if (curr->character[idx] || hasChildren(curr)) {
            return curr;
        }
        return nullptr;
    }

 public:
        Trie() : m_root(std::make_shared<TrieNode>()) {}

    
    void insert(const std::string& word) {
        auto curr = m_root;
        for (char ch : word) {
            size_t index = ch - 'a';

                                    if (!curr->character[index]) {
                curr->character[index] = std::make_shared<TrieNode>();
            }

            curr = curr->character[index];
        }
        curr->isEndOfWord = true;
    }

    
    bool search(const std::string& word) {
        auto curr = m_root;
        for (char ch : word) {
            size_t index = ch - 'a';

                                    if (!curr->character[index]) {
                return false;
            }
            curr = curr->character[index];
        }
        return curr->isEndOfWord;
    }

        void removeWord(const std::string& word) {
        m_root = removeWordHelper(word, m_root, 0);
    }

 private:
        std::shared_ptr<TrieNode> m_root;
};


int main() {
    Trie trie;
    trie.insert("hel");
    trie.insert("hello");
    trie.removeWord("hel");
    std::cout << trie.search("hello") << '\n';

    return 0;
}

#include <algorithm>
#include <iostream>
#include <queue>

typedef struct node {
    int data;
    int height;
    struct node *left;
    struct node *right;
} node;


node *createNode(int data) {
    node *nn = new node();
    nn->data = data;
    nn->height = 0;
    nn->left = NULL;
    nn->right = NULL;
    return nn;
}


int height(node *root) {
    if (root == NULL)
        return 0;
    return 1 + std::max(height(root->left), height(root->right));
}


int getBalance(node *root) { return height(root->left) - height(root->right); }


node *rightRotate(node *root) {
    node *t = root->left;
    node *u = t->right;
    t->right = root;
    root->left = u;
    return t;
}


node *leftRotate(node *root) {
    node *t = root->right;
    node *u = t->left;
    t->left = root;
    root->right = u;
    return t;
}


node *minValue(node *root) {
    if (root->left == NULL)
        return root;
    return minValue(root->left);
}


node *insert(node *root, int item) {
    node *nn = createNode(item);
    if (root == NULL)
        return nn;
    if (item < root->data)
        root->left = insert(root->left, item);
    else
        root->right = insert(root->right, item);
    int b = getBalance(root);
    if (b > 1) {
        if (getBalance(root->left) < 0)
            root->left = leftRotate(root->left);          return rightRotate(root);                     } else if (b < -1) {
        if (getBalance(root->right) > 0)
            root->right = rightRotate(root->right);          return leftRotate(root);                         }
    return root;
}


node *deleteNode(node *root, int key) {
    if (root == NULL)
        return root;
    if (key < root->data)
        root->left = deleteNode(root->left, key);
    else if (key > root->data)
        root->right = deleteNode(root->right, key);

    else {
                if (!root->right) {
            node *temp = root->left;
            delete (root);
            root = NULL;
            return temp;
        } else if (!root->left) {
            node *temp = root->right;
            delete (root);
            root = NULL;
            return temp;
        }
                node *temp = minValue(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
        return root;
}


void levelOrder(node *root) {
    std::queue<node *> q;
    q.push(root);
    while (!q.empty()) {
        root = q.front();
        std::cout << root->data << " ";
        q.pop();
        if (root->left)
            q.push(root->left);
        if (root->right)
            q.push(root->right);
    }
}


int main() {
        node *root = NULL;
    int i;
    for (i = 1; i <= 7; i++) root = insert(root, i);
    std::cout << "LevelOrder: ";
    levelOrder(root);
    root = deleteNode(root, 1);      std::cout << "\nLevelOrder: ";
    levelOrder(root);
    root = deleteNode(root, 4);      std::cout << "\nLevelOrder: ";
    levelOrder(root);
    return 0;
}
#include <iostream>

int *stack;
int stack_idx = 0, stack_size;

void push(int x) {
    if (stack_idx == stack_size) {
        std::cout << "\nOverflow";
    } else {
        stack[stack_idx++] = x;
    }
}

void pop() {
    if (stack_idx == 0) {
        std::cout << "\nUnderflow";
    } else {
        std::cout << "\n" << stack[--stack_idx] << " deleted";
    }
}

void show() {
    for (int i = 0; i < stack_idx; i++) {
        std::cout << stack[i] << "\n";
    }
}

void topmost() { std::cout << "\nTopmost element: " << stack[stack_idx - 1]; }
void bottom() { std::cout << "\nBottom element: " << stack[0]; } int main() {
    std::cout << "\nEnter stack_size of stack : ";
    std::cin >> stack_size;
    stack = new int[stack_size];
    int ch, x;
    do {
        std::cout << "\n0. Exit";
        std::cout << "\n1. Push";
        std::cout << "\n2. Pop";
        std::cout << "\n3. Print";
        std::cout << "\n4. Print topmost element:";
        std::cout << "\n5. Print Bottom element:";
        std::cout << "\nEnter Your Choice : ";
        std::cin >> ch;
        if (ch == 1) {
            std::cout << "\nInsert : ";
            std::cin >> x;
            push(x);
        } else if (ch == 2) {
            pop();
        } else if (ch == 3) {
            show();
        } else if (ch == 4) {
            topmost();
        } else if(ch == 5) {
            bottom();
        }
    } while (ch != 0);

    delete[] stack;

    return 0;
}
#include <iostream>

struct node {
    int data;
    struct node* next;
};
class Queue {
    node* front=nullptr;
    node* rear=nullptr;

public:
    Queue() = default; 
    void createNode(int val) {
        auto* nn = new node;
        nn->data = val;
        nn->next = nullptr;
        front = nn;
        rear = nn;
    }
    void enqueue(int val) {
        if (front == nullptr || rear == nullptr) {
            createNode(val);
        }
        else {
            node* nn;
            nn = new node;
            nn->data = val;
            rear->next = nn;
            nn->next = front;
            rear = nn;
        }
    }
    void dequeue() {
        node* n;
        n = front;
        if (n) {
            front = front->next;
            delete n;
        }
    }
    void traverse() {
        node* ptr;
        ptr = front;
        if (ptr) {
            do {
                std::cout << ptr->data << " ";
                ptr = ptr->next;
            } while (ptr != rear->next);
            std::cout << front->data << std::endl;
        }
    }
};
int main(void) {
    Queue q;
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);
    q.enqueue(50);
    q.enqueue(60);
    q.enqueue(70);
    q.traverse();
    q.dequeue();
    q.traverse();
    return 0;
}

#include <iostream>

struct Node {
    int data;
    int next;
};

Node AvailArray[100];  
int head = -1;
int avail = 0;
void initialise_list() {
    for (int i = 0; i <= 98; i++) {
        AvailArray[i].next = i + 1;
    }
    AvailArray[99].next = -1;  }


int getnode() {
    int NodeIndexToBeReturned = avail;
    avail = AvailArray[avail].next;
    return NodeIndexToBeReturned;
}


void freeNode(int nodeToBeDeleted) {
    AvailArray[nodeToBeDeleted].next = avail;
    avail = nodeToBeDeleted;
}


void insertAtTheBeginning(int data) {
    int newNode = getnode();
    AvailArray[newNode].data = data;
    AvailArray[newNode].next = head;
    head = newNode;
}

void insertAtTheEnd(int data) {
    int newNode = getnode();
    int temp = head;
    while (AvailArray[temp].next != -1) {
        temp = AvailArray[temp].next;
    }
        AvailArray[newNode].data = data;
    AvailArray[newNode].next = -1;
    AvailArray[temp].next = newNode;
}

void display() {
    int temp = head;
    while (temp != -1) {
        std::cout << AvailArray[temp].data << "->";
        temp = AvailArray[temp].next;
    }
    std::cout << "-1" << std::endl;
}


int main() {
    initialise_list();
    int x, y, z;
    for (;;) {
        std::cout << "1. Insert At The Beginning" << std::endl;
        std::cout << "2. Insert At The End" << std::endl;
        std::cout << "3. Display" << std::endl;
        std::cout << "4.Exit" << std::endl;
        std::cout << "Enter Your choice" << std::endl;
        std::cin >> z;
        switch (z) {
        case 1:
            std::cout << "Enter the number you want to enter" << std::endl;
            std::cin >> x;
            insertAtTheBeginning(x);
            break;
        case 2:
            std::cout << "Enter the number you want to enter" << std::endl;
            std::cin >> y;
            insertAtTheEnd(y);
            break;
        case 3:
            std::cout
                << "The linked list contains the following element in order"
                << std::endl;
            display();
            break;
        case 4:
            return 0;
        default:
            std::cout << "The entered choice is not correct" << std::endl;
        }
    }

    return 0;
}
#include <iostream>
using namespace std;

int queue[10];
int front = 0;
int rear = 0;

void Enque(int x) {
    if (rear == 10) {
        cout << "\nOverflow";
    } else {
        queue[rear++] = x;
    }
}

void Deque() {
    if (front == rear) {
        cout << "\nUnderflow";
    }

    else {
        cout << "\n" << queue[front++] << " deleted";
        for (int i = front; i < rear; i++) {
            queue[i - front] = queue[i];
        }
        rear = rear - front;
        front = 0;
    }
}

void show() {
    for (int i = front; i < rear; i++) {
        cout << queue[i] << "\t";
    }
}

int main() {
    int ch, x;
    do {
        cout << "\n1. Enque";
        cout << "\n2. Deque";
        cout << "\n3. Print";
        cout << "\nEnter Your Choice : ";
        cin >> ch;
        if (ch == 1) {
            cout << "\nInsert : ";
            cin >> x;
            Enque(x);
        } else if (ch == 2) {
            Deque();
        } else if (ch == 3) {
            show();
        }
    } while (ch != 0);

    return 0;
}
#include <iostream>

struct node {
    int val;
    node *next;
};

node *top_var;

void push(int x) {
    node *n = new node;
    n->val = x;
    n->next = top_var;
    top_var = n;
}

void pop() {
    if (top_var == nullptr) {
        std::cout << "\nUnderflow";
    } else {
        node *t = top_var;
        std::cout << "\n" << t->val << " deleted";
        top_var = top_var->next;
        delete t;
    }
}

void show() {
    node *t = top_var;
    while (t != nullptr) {
        std::cout << t->val << "\n";
        t = t->next;
    }
}

int main() {
    int ch = 0, x = 0;
    do {
        std::cout << "\n0. Exit or Ctrl+C";
        std::cout << "\n1. Push";
        std::cout << "\n2. Pop";
        std::cout << "\n3. Print";
        std::cout << "\nEnter Your Choice: ";
        std::cin >> ch;
        switch (ch) {
            case 0:
                break;
            case 1:
                std::cout << "\nInsert : ";
                std::cin >> x;
                push(x);
                break;
            case 2:
                pop();
                break;
            case 3:
                show();
                break;
            default:
                std::cout << "Invalid option!\n";
                break;
        }
    } while (ch != 0);

    return 0;
}

#include <array>     #include <cassert>   #include <fstream>   #include <iostream>  #include <memory>    #include <queue>     #include <string>    

namespace data_structures {

namespace tree_234 {

class Node {
 public:
    
    explicit Node(int64_t item)
        : count(1),
          items({{item, 0, 0}}),
          children({{nullptr, nullptr, nullptr, nullptr}}) {}

    
    int8_t GetCount() { return count; }

    
    void SetCount(int8_t c) { count = c; }

    
    bool IsLeaf() { return children[0] == nullptr; }

    
    bool IsFull() { return count == 3; }

    
    bool Is2Node() { return count == 1; }

    
    bool Is34Node() { return count == 2 || count == 3; }

    
    bool Contains(int64_t item) {
        for (int8_t i = 0; i < count; i++) {
            if (item == items[i]) {
                return true;
            }
        }
        return false;
    }

    
    int8_t GetItemIndex(int64_t item) {
        for (int8_t i = 0; i < count; i++) {
            if (items[i] == item) {
                return i;
            }
        }
        return -1;
    }

    
    int64_t GetMaxItem() { return items[count - 1]; }

    
    int64_t GetMinItem() { return items[0]; }

    
    int64_t GetItem(int8_t index) { return items[index]; }

    
    void SetItem(int8_t index, int64_t new_item) {
        assert(index >= 0 && index <= 2);

        items[index] = new_item;
    }

    
    int InsertItem(int item) {
        assert(!IsFull());

        if (Contains(item)) {
            return -1;
        }

        int8_t i = 0;
        for (i = 0; i < count; i++) {
            if (items[i] > item) {
                break;
            }
        }

        InsertItemByIndex(i, item, nullptr, true);
        return i;
    }

    
    void InsertItemByIndex(int8_t index, int64_t item, Node *with_child,
                           bool to_left = true) {
        assert(count < 3 && index >= 0 && index < 3);

        for (int8_t i = count - 1; i >= index; i--) {
            items[i + 1] = items[i];
        }

        items[index] = item;

        int8_t start_index = to_left ? index : index + 1;

        for (int8_t i = count; i >= start_index; i--) {
            children[i + 1] = children[i];
        }

        children[start_index] = with_child;

        count++;
    }

    
    Node *RemoveItemByIndex(int8_t index, bool keep_left) {
        assert(index >= 0 && index < count);
        Node *removed_child = keep_left ? children[index + 1] : children[index];
        for (int8_t i = index; i < count - 1; i++) {
            items[i] = items[i + 1];
        }

        for (int8_t i = keep_left ? index + 1 : index; i < count; i++) {
            children[i] = children[i + 1];
        }

        count--;
        return removed_child;
    }

    
    int8_t GetChildIndex(Node *child) {
        for (int8_t i = 0; i < count + 1; i++) {
            if (children[i] == child) {
                return i;
            }
        }

        return -1;
    }

    
    Node *GetChild(int8_t index) { return children[index]; }

    
    void SetChild(int8_t index, Node *child) { children[index] = child; }

    
    Node *GetRightmostChild() { return children[count]; }

    
    Node *GetLeftmostChild() { return children[0]; }

    
    Node *GetItemLeftChild(int8_t item_index) {
        if (item_index < 0 || item_index > count - 1) {
            return nullptr;
        }

        return children[item_index];
    }

    
    Node *GetItemRightChild(int8_t item_index) {
        if (item_index < 0 || item_index > count - 1) {
            return nullptr;
        }

        return children[item_index + 1];
    }

    
    Node *GetNextPossibleChild(int64_t item) {
        int i = 0;
        for (i = 0; i < count; i++) {
            if (items[i] > item) {
                break;
            }
        }
        return children[i];
    }

 private:
    std::array<int64_t, 3> items;  
    std::array<Node *, 4> children;  
    int8_t count = 0;  };


class Tree234 {
 public:
    Tree234() = default;
    Tree234(const Tree234 &) = delete;
    Tree234(const Tree234 &&) = delete;
    Tree234 &operator=(const Tree234 &) = delete;
    Tree234 &operator=(const Tree234 &&) = delete;

    ~Tree234();

    
    void Insert(int64_t item);

    
    bool Remove(int64_t item);

    
    void Traverse();

    
    void Print(const char *file_name = nullptr);

 private:
    
    void InsertPreSplit(int64_t item);

    
    void InsertPostMerge(int64_t item);

    
    Node *Insert(Node *tree, int64_t item);

    
    Node *MergeNode(Node *dst_node, Node *node);

    
    void MergeNodeNotFull(Node *dst_node, Node *node);

    
    Node *SplitNode(Node *node);

    
    int64_t GetTreeMaxItem(Node *tree);

    
    int64_t GetTreeMinItem(Node *tree);

    
    bool TryLeftRotate(Node *parent, Node *to_child);

    
    bool TryRightRotate(Node *parent, Node *to_child);

    
    void RightRotate(Node *parent, int8_t index);

    
    void LeftRotate(Node *parent, int8_t index);

    
    bool RemovePreMerge(Node *node, int64_t item);

    
    Node *Merge(Node *parent, int8_t index);

    
    void DeleteNode(Node *tree);

    
    void Traverse(Node *tree);

    
    void PrintNode(std::ofstream &ofs, Node *node, int64_t parent_index,
                   int64_t index, int8_t parent_child_index);

    Node *root_{nullptr};  };

Tree234::~Tree234() { DeleteNode(root_); }


void Tree234::DeleteNode(Node *tree) {
    if (!tree) {
        return;
    }
    for (int8_t i = 0; i <= tree->GetCount(); i++) {
        DeleteNode(tree->GetChild(i));
    }

    delete tree;
}


void Tree234::Traverse() {
    Traverse(root_);
    std::cout << std::endl;
}

void Tree234::Traverse(Node *node) {
    if (!node) {
        return;
    }

    int8_t i = 0;
    for (i = 0; i < node->GetCount(); i++) {
        Traverse(node->GetChild(i));
        std::cout << node->GetItem(i) << ", ";
    }

    Traverse(node->GetChild(i));
}


void Tree234::InsertPreSplit(int64_t item) {
    if (!root_) {
        root_ = new Node(item);
        return;
    }

    Node *parent = nullptr;
    Node *node = root_;

    while (true) {
        if (!node) {
            std::unique_ptr<Node> tmp(new Node(item));
            MergeNodeNotFull(parent, tmp.get());
            return;
        }

        if (node->Contains(item)) {
            return;
        }

        if (node->IsFull()) {
            node = SplitNode(node);

            Node *cur_node = nullptr;

            if (item < node->GetItem(0)) {
                cur_node = node->GetChild(0);
            } else {
                cur_node = node->GetChild(1);
            }

            if (!parent) {
                                                root_ = node;
            } else {
                                MergeNodeNotFull(parent, node);
            }

            node = cur_node;
        }

        parent = node;
        node = parent->GetNextPossibleChild(item);
    }
}


void Tree234::InsertPostMerge(int64_t item) {
    if (!root_) {
        root_ = new Node(item);
        return;
    }

    Node *split_node = Insert(root_, item);

        if (split_node) {
        root_ = split_node;
    }
}


void Tree234::Insert(int64_t item) { InsertPreSplit(item); }


Node *Tree234::Insert(Node *tree, int64_t item) {
    assert(tree != nullptr);

    std::unique_ptr<Node> split_node;

    if (tree->Contains(item)) {
                return nullptr;
    }

    Node *next_node = tree->GetNextPossibleChild(item);
    if (next_node) {
        split_node.reset(Insert(next_node, item));
    } else {
        split_node.reset(new Node(item));
    }

    if (split_node) {
        return MergeNode(tree, split_node.get());
    }

    return nullptr;
}


Node *Tree234::MergeNode(Node *dst_node, Node *node) {
    assert(dst_node != nullptr && node != nullptr);

    if (!dst_node->IsFull()) {
        MergeNodeNotFull(dst_node, node);
        return nullptr;
    }

    dst_node = SplitNode(dst_node);

    if (node->GetItem(0) < dst_node->GetItem(0)) {
        MergeNodeNotFull(dst_node->GetChild(0), node);

    } else {
        MergeNodeNotFull(dst_node->GetChild(1), node);
    }

    return dst_node;
}


void Tree234::MergeNodeNotFull(Node *dst_node, Node *node) {
    assert(dst_node && node && !dst_node->IsFull() && node->Is2Node());

    int8_t i = dst_node->InsertItem(node->GetItem(0));

    dst_node->SetChild(i, node->GetChild(0));
    dst_node->SetChild(i + 1, node->GetChild(1));
}


Node *Tree234::SplitNode(Node *node) {
    assert(node->GetCount() == 3);

    Node *left = node;

    Node *right = new Node(node->GetItem(2));
    right->SetChild(0, node->GetChild(2));
    right->SetChild(1, node->GetChild(3));

    Node *parent = new Node(node->GetItem(1));
    parent->SetChild(0, left);
    parent->SetChild(1, right);

    left->SetCount(1);

    return parent;
}


bool Tree234::TryLeftRotate(Node *parent, Node *to_child) {
    int to_child_index = parent->GetChildIndex(to_child);

        if (to_child_index >= parent->GetCount()) {
        return false;
    }

    Node *right_sibling = parent->GetChild(to_child_index + 1);

        if (right_sibling->Is2Node()) {
        return false;
    }

    LeftRotate(parent, to_child_index);

    return true;
}


bool Tree234::TryRightRotate(Node *parent, Node *to_child) {
    int8_t to_child_index = parent->GetChildIndex(to_child);

        if (to_child_index <= 0) {
        return false;
    }

    Node *left_sibling = parent->GetChild(to_child_index - 1);

        if (left_sibling->Is2Node()) {
        return false;
    }

    RightRotate(parent, to_child_index - 1);

    return true;
}


void Tree234::RightRotate(Node *parent, int8_t index) {
    Node *left = parent->GetItemLeftChild(index);
    Node *right = parent->GetItemRightChild(index);

    assert(left && left->Is34Node());
    assert(right && right->Is2Node());

    right->InsertItemByIndex(0, parent->GetItem(index),
                             left->GetRightmostChild(), true);
    parent->SetItem(index, left->GetMaxItem());
    left->RemoveItemByIndex(left->GetCount() - 1, true);
}


void Tree234::LeftRotate(Node *parent, int8_t index) {
    Node *left = parent->GetItemLeftChild(index);
    Node *right = parent->GetItemRightChild(index);

    assert(right && right->Is34Node());
    assert(left && left->Is2Node());

    left->InsertItemByIndex(left->GetCount(), parent->GetItem(index),
                            right->GetLeftmostChild(), false);
    parent->SetItem(index, right->GetMinItem());
    right->RemoveItemByIndex(0, false);
}


Node *Tree234::Merge(Node *parent, int8_t index) {
    assert(parent);

    
    Node *left_child = parent->GetItemLeftChild(index);
    Node *right_child = parent->GetItemRightChild(index);

    assert(left_child->Is2Node() && right_child->Is2Node());

    int64_t item = parent->GetItem(index);

        left_child->SetItem(1, item);
    left_child->SetItem(2, right_child->GetItem(0));
    left_child->SetChild(2, right_child->GetChild(0));
    left_child->SetChild(3, right_child->GetChild(1));

    left_child->SetCount(3);

        parent->RemoveItemByIndex(index, true);

        delete right_child;

    return left_child;
}


bool Tree234::Remove(int64_t item) { return RemovePreMerge(root_, item); }


bool Tree234::RemovePreMerge(Node *node, int64_t item) {
    while (node) {
        if (node->IsLeaf()) {
            if (node->Contains(item)) {
                if (node->Is2Node()) {
                                        delete node;
                    root_ = nullptr;
                } else {
                    node->RemoveItemByIndex(node->GetItemIndex(item), true);
                }
                return true;
            }
            return false;
        }

                if (node->Contains(item)) {
            int8_t index = node->GetItemIndex(item);

                                    Node *left_child = node->GetItemLeftChild(index);
            Node *right_child = node->GetItemRightChild(index);
            assert(left_child && right_child);

            if (left_child->Is2Node() && right_child->Is2Node()) {
                                                                                                                
                                                                                                                                                                                                                                
                                if (node->Is2Node()) {
                                                                                Node *new_root = Merge(node, index);
                    delete root_;
                    root_ = new_root;
                    node = root_;

                                        continue;
                }

                                                                                do {
                    if (index > 0) {
                                                                        Node *left_sibling = node->GetItemLeftChild(index - 1);
                        if (left_sibling->Is34Node()) {
                            RightRotate(node, index - 1);
                            break;
                        }
                    }

                    if (index < node->GetCount() - 1) {
                                                                        Node *right_sibling =
                            node->GetItemRightChild(index + 1);
                        if (right_sibling->Is34Node()) {
                            LeftRotate(node, index + 1);
                            break;
                        }
                    }

                                                            if (index > 0) {
                        Merge(node, index - 1);
                        break;
                    }

                    Merge(node, index + 1);

                } while (false);
            }

                                    left_child = node->GetItemLeftChild(index);
            right_child = node->GetItemRightChild(index);

            if (left_child->Is34Node()) {
                int64_t predecessor_item = GetTreeMaxItem(left_child);
                node->SetItem(node->GetItemIndex(item), predecessor_item);

                node = left_child;
                item = predecessor_item;
                continue;
            }

            if (right_child->Is34Node()) {
                int64_t successor_item = GetTreeMinItem(right_child);
                node->SetItem(node->GetItemIndex(item), successor_item);
                node = right_child;
                item = successor_item;
                continue;
            }
        }

        Node *next_node = node->GetNextPossibleChild(item);

        if (next_node->Is34Node()) {
            node = next_node;
            continue;
        }

        if (TryRightRotate(node, next_node)) {
            node = next_node;
            continue;
        }

        if (TryLeftRotate(node, next_node)) {
            node = next_node;
            continue;
        }

                        int8_t child_index = node->GetChildIndex(next_node);
        if (child_index > 0) {
            node = Merge(node, child_index - 1);
        } else {
            node = Merge(node, child_index);
        }

    }  
    return false;
}


int64_t Tree234::GetTreeMaxItem(Node *tree) {
    assert(tree);
    int64_t max = 0;

    while (tree) {
        max = tree->GetMaxItem();
        tree = tree->GetRightmostChild();
    }

    return max;
}


int64_t Tree234::GetTreeMinItem(Node *tree) {
    assert(tree);
    int64_t min = 0;

    while (tree) {
        min = tree->GetMinItem();
        tree = tree->GetLeftmostChild();
    }

    return min;
}


void Tree234::Print(const char *file_name) {
    if (!file_name) {
        file_name = "out.dot";
    }

    std::ofstream ofs;

    ofs.open(file_name);
    if (!ofs) {
        std::cout << "create tree dot file failed, " << file_name << std::endl;
        return;
    }

    ofs << "digraph G {\n";
    ofs << "node [shape=record]\n";

    int64_t index = 0;

    
    struct NodeInfo {
        Node *node;             int64_t index;                              };

    std::queue<NodeInfo> q;

    if (root_) {
                PrintNode(ofs, root_, -1, index, 0);

        NodeInfo ni{};
        ni.node = root_;
        ni.index = index;

        q.push(ni);

        while (!q.empty()) {
            NodeInfo node_info = q.front();
            q.pop();

            assert(node_info.node->GetCount() > 0);

            if (!node_info.node->IsLeaf()) {
                if (node_info.node->GetCount() > 0) {
                    PrintNode(ofs, node_info.node->GetChild(0), node_info.index,
                              ++index, 0);
                    ni.node = node_info.node->GetChild(0);
                    ni.index = index;
                    q.push(ni);

                    PrintNode(ofs, node_info.node->GetChild(1), node_info.index,
                              ++index, 1);
                    ni.node = node_info.node->GetChild(1);
                    ni.index = index;
                    q.push(ni);
                }

                if (node_info.node->GetCount() > 1) {
                    PrintNode(ofs, node_info.node->GetChild(2), node_info.index,
                              ++index, 2);
                    ni.node = node_info.node->GetChild(2);
                    ni.index = index;
                    q.push(ni);
                }

                if (node_info.node->GetCount() > 2) {
                    PrintNode(ofs, node_info.node->GetChild(3), node_info.index,
                              ++index, 3);
                    ni.node = node_info.node->GetChild(3);
                    ni.index = index;
                    q.push(ni);
                }
            }
        }
    }

    ofs << "}\n";
    ofs.close();
}


void Tree234::PrintNode(std::ofstream &ofs, Node *node, int64_t parent_index,
                        int64_t index, int8_t parent_child_index) {
    assert(node);

    switch (node->GetCount()) {
        case 1:
            ofs << "node_" << index << " [label=\"<f0> " << node->GetItem(0)
                << "\"]\n";
            break;
        case 2:
            ofs << "node_" << index << " [label=\"<f0> " << node->GetItem(0)
                << " | <f1> " << node->GetItem(1) << "\"]\n";
            break;
        case 3:
            ofs << "node_" << index << " [label=\"<f0> " << node->GetItem(0)
                << " | <f1> " << node->GetItem(1) << "| <f2> "
                << node->GetItem(2) << "\"]\n";
            break;

        default:
            break;
    }

        if (parent_index >= 0) {
        ofs << "node_" << parent_index << ":f"
            << (parent_child_index == 0 ? 0 : parent_child_index - 1) << ":"
            << (parent_child_index == 0 ? "sw" : "se") << " -> node_" << index
            << "\n";
    }
}
}  }  


static void test1() {
    std::array<int16_t, 13> arr = {3, 1, 5, 4, 2, 9, 10, 8, 7, 6, 16, 13, 14};
    data_structures::tree_234::Tree234 tree;

    for (auto i : arr) {
        tree.Insert(i);
    }

        tree.Remove(5);
    tree.Print();
}


static void test2(int64_t n) {
    data_structures::tree_234::Tree234 tree;

    for (int64_t i = 0; i < n; i++) {
        tree.Insert(i);
    }

    tree.Traverse();
    tree.Print((std::to_string(n) + ".dot").c_str());
}


int main(int argc, char *argv[]) {
    if (argc < 2) {
        test1();      } else {
        test2(std::stoi(argv[1]));      }

    return 0;
}
#include <iostream>

#include "./stack.h"

int main() {
    stack<int> stk;
    std::cout << "---------------------- Test construct ----------------------"
              << std::endl;
    stk.display();
    std::cout
        << "---------------------- Test isEmptyStack ----------------------"
        << std::endl;
    if (stk.isEmptyStack())
        std::cout << "PASS" << std::endl;
    else
        std::cout << "FAIL" << std::endl;
    std::cout << "---------------------- Test push ----------------------"
              << std::endl;
    std::cout << "After pushing 10 20 30 40 into stack: " << std::endl;
    stk.push(10);
    stk.push(20);
    stk.push(30);
    stk.push(40);
    stk.display();
    std::cout << "---------------------- Test top ----------------------"
              << std::endl;
    int value = stk.top();
    if (value == 40)
        std::cout << "PASS" << std::endl;
    else
        std::cout << "FAIL" << std::endl;
    std::cout << "---------------------- Test pop ----------------------"
              << std::endl;
    stk.display();
    stk.pop();
    stk.pop();
    std::cout << "After popping 2 times: " << std::endl;
    stk.display();
    std::cout << "---------------------- Test overload = operator "
                 "----------------------"
              << std::endl;
    stack<int> stk1;
    std::cout << "stk current: " << std::endl;
    stk.display();
    std::cout << std::endl << "Assign stk1 = stk " << std::endl;
    stk1 = stk;
    stk1.display();
    std::cout << std::endl << "After pushing 8 9 10 into stk1:" << std::endl;
    stk1.push(8);
    stk1.push(9);
    stk1.push(10);
    stk1.display();
    std::cout << std::endl << "stk current: " << std::endl;
    stk.display();
    std::cout << "Assign back stk = stk1:" << std::endl;
    stk = stk1;
    stk.display();
    return 0;
}


#include <cassert>   #include <iostream>  #include <vector>    
using std::cout;
using std::endl;
using std::vector;


class dsu {
 private:
    vector<uint64_t> p;            vector<uint64_t> depth;        vector<uint64_t> setSize;   public:
    
    explicit dsu(uint64_t n) {
        p.assign(n, 0);
                depth.assign(n, 0);
        setSize.assign(n, 0);
        for (uint64_t i = 0; i < n; i++) {
            p[i] = i;
            depth[i] = 0;
            setSize[i] = 1;
        }
    }
    
    uint64_t findSet(uint64_t i) {
                while (i != p[i]) {
            i = p[i];
        }
        return i;
    }
    
    void unionSet(uint64_t i, uint64_t j) {
                if (isSame(i, j)) {
            return;
        }
                uint64_t x = findSet(i);
        uint64_t y = findSet(j);

                        if (depth[x] > depth[y]) {
            std::swap(x, y);
        }
                p[x] = y;

                if (depth[x] == depth[y]) {
            depth[y]++;
        }
                setSize[y] += setSize[x];
    }
    
    bool isSame(uint64_t i, uint64_t j) {
        if (findSet(i) == findSet(j)) {
            return true;
        }
        return false;
    }
    
    vector<uint64_t> getParents(uint64_t i) {
        vector<uint64_t> ans;
        while (p[i] != i) {
            ans.push_back(i);
            i = p[i];
        }
        ans.push_back(i);
        return ans;
    }
};

static void test1() {
    uint64_t n = 10;       dsu d(n + 1);          d.unionSet(2, 1);      d.unionSet(1, 4);
    d.unionSet(8, 1);
    d.unionSet(3, 5);
    d.unionSet(5, 6);
    d.unionSet(5, 7);
    d.unionSet(9, 10);
    d.unionSet(2, 10);
        vector<uint64_t> ans = {7, 5};
    for (uint64_t i = 0; i < ans.size(); i++) {
        assert(d.getParents(7).at(i) ==
               ans[i]);      }
    cout << "1st test passed!" << endl;
}

static void test2() {
        uint64_t n = 10;       dsu d(n + 1);          d.unionSet(2, 1);      d.unionSet(1, 4);
    d.unionSet(8, 1);
    d.unionSet(3, 5);
    d.unionSet(5, 6);
    d.unionSet(5, 7);
    d.unionSet(9, 10);
    d.unionSet(2, 10);

        vector<uint64_t> ans = {2, 1, 10};
    for (uint64_t i = 0; i < ans.size(); i++) {
        assert(d.getParents(2).at(i) ==
               ans[i]);      }
    cout << "2nd test passed!" << endl;
}

int main() {
    test1();      test2();  
    return 0;
}
#include<iostream>

using namespace std;

struct node
{
	int key;
	node *parent;
	char color;
	node *left;
	node *right;
};
class RBtree
{
	node *root;
	node *q;
public:
	RBtree()
	{
		q = NULL;
		root = NULL;
	}
	void insert();
	void insertfix(node *);
	void leftrotate(node *);
	void rightrotate(node *);
	void del();
	node* successor(node *);
	void delfix(node *);
	void disp();
	void display(node *);
	void search();
};
void RBtree::insert()
{
	int z, i = 0;
	cout << "\nEnter key of the node to be inserted: ";
	cin >> z;
	node *p, *q;
	node *t = new node;
	t->key = z;
	t->left = NULL;
	t->right = NULL;
	t->color = 'r';
	p = root;
	q = NULL;
	if (root == NULL)
	{
		root = t;
		t->parent = NULL;
	}
	else
	{
		while (p != NULL)
		{
			q = p;
			if (p->key < t->key)
				p = p->right;
			else
				p = p->left;
		}
		t->parent = q;
		if (q->key < t->key)
			q->right = t;
		else
			q->left = t;
	}
	insertfix(t);
}
void RBtree::insertfix(node *t)
{
	node *u;
	if (root == t)
	{
		t->color = 'b';
		return;
	}
	while (t->parent != NULL && t->parent->color == 'r')
	{
		node *g = t->parent->parent;
		if (g->left == t->parent)
		{
			if (g->right != NULL)
			{
				u = g->right;
				if (u->color == 'r')
				{
					t->parent->color = 'b';
					u->color = 'b';
					g->color = 'r';
					t = g;
				}
			}
			else
			{
				if (t->parent->right == t)
				{
					t = t->parent;
					leftrotate(t);
				}
				t->parent->color = 'b';
				g->color = 'r';
				rightrotate(g);
			}
		}
		else
		{
			if (g->left != NULL)
			{
				u = g->left;
				if (u->color == 'r')
				{
					t->parent->color = 'b';
					u->color = 'b';
					g->color = 'r';
					t = g;
				}
			}
			else
			{
				if (t->parent->left == t)
				{
					t = t->parent;
					rightrotate(t);
				}
				t->parent->color = 'b';
				g->color = 'r';
				leftrotate(g);
			}
		}
		root->color = 'b';
	}
}

void RBtree::del()
{
	if (root == NULL)
	{
		cout << "\nEmpty Tree.";
		return;
	}
	int x;
	cout << "\nEnter the key of the node to be deleted: ";
	cin >> x;
	node *p;
	p = root;
	node *y = NULL;
	node *q = NULL;
	int found = 0;
	while (p != NULL && found == 0)
	{
		if (p->key == x)
			found = 1;
		if (found == 0)
		{
			if (p->key < x)
				p = p->right;
			else
				p = p->left;
		}
	}
	if (found == 0)
	{
		cout << "\nElement Not Found.";
		return;
	}
	else
	{
		cout << "\nDeleted Element: " << p->key;
		cout << "\nColour: ";
		if (p->color == 'b')
			cout << "Black\n";
		else
			cout << "Red\n";

		if (p->parent != NULL)
			cout << "\nParent: " << p->parent->key;
		else
			cout << "\nThere is no parent of the node.  ";
		if (p->right != NULL)
			cout << "\nRight Child: " << p->right->key;
		else
			cout << "\nThere is no right child of the node.  ";
		if (p->left != NULL)
			cout << "\nLeft Child: " << p->left->key;
		else
			cout << "\nThere is no left child of the node.  ";
		cout << "\nNode Deleted.";
		if (p->left == NULL || p->right == NULL)
			y = p;
		else
			y = successor(p);
		if (y->left != NULL)
			q = y->left;
		else
		{
			if (y->right != NULL)
				q = y->right;
			else
				q = NULL;
		}
		if (q != NULL)
			q->parent = y->parent;
		if (y->parent == NULL)
			root = q;
		else
		{
			if (y == y->parent->left)
				y->parent->left = q;
			else
				y->parent->right = q;
		}
		if (y != p)
		{
			p->color = y->color;
			p->key = y->key;
		}
		if (y->color == 'b')
			delfix(q);
	}
}

void RBtree::delfix(node *p)
{
	node *s;
	while (p != root && p->color == 'b')
	{
		if (p->parent->left == p)
		{
			s = p->parent->right;
			if (s->color == 'r')
			{
				s->color = 'b';
				p->parent->color = 'r';
				leftrotate(p->parent);
				s = p->parent->right;
			}
			if (s->right->color == 'b'&&s->left->color == 'b')
			{
				s->color = 'r';
				p = p->parent;
			}
			else
			{
				if (s->right->color == 'b')
				{
					s->left->color = 'b';
					s->color = 'r';
					rightrotate(s);
					s = p->parent->right;
				}
				s->color = p->parent->color;
				p->parent->color = 'b';
				s->right->color = 'b';
				leftrotate(p->parent);
				p = root;
			}
		}
		else
		{
			s = p->parent->left;
			if (s->color == 'r')
			{
				s->color = 'b';
				p->parent->color = 'r';
				rightrotate(p->parent);
				s = p->parent->left;
			}
			if (s->left->color == 'b'&&s->right->color == 'b')
			{
				s->color = 'r';
				p = p->parent;
			}
			else
			{
				if (s->left->color == 'b')
				{
					s->right->color = 'b';
					s->color = 'r';
					leftrotate(s);
					s = p->parent->left;
				}
				s->color = p->parent->color;
				p->parent->color = 'b';
				s->left->color = 'b';
				rightrotate(p->parent);
				p = root;
			}
		}
		p->color = 'b';
		root->color = 'b';
	}
}

void RBtree::leftrotate(node *p)
{
	if (p->right == NULL)
		return;
	else
	{
		node *y = p->right;
		if (y->left != NULL)
		{
			p->right = y->left;
			y->left->parent = p;
		}
		else
			p->right = NULL;
		if (p->parent != NULL)
			y->parent = p->parent;
		if (p->parent == NULL)
			root = y;
		else
		{
			if (p == p->parent->left)
				p->parent->left = y;
			else
				p->parent->right = y;
		}
		y->left = p;
		p->parent = y;
	}
}
void RBtree::rightrotate(node *p)
{
	if (p->left == NULL)
		return;
	else
	{
		node *y = p->left;
		if (y->right != NULL)
		{
			p->left = y->right;
			y->right->parent = p;
		}
		else
			p->left = NULL;
		if (p->parent != NULL)
			y->parent = p->parent;
		if (p->parent == NULL)
			root = y;
		else
		{
			if (p == p->parent->left)
				p->parent->left = y;
			else
				p->parent->right = y;
		}
		y->right = p;
		p->parent = y;
	}
}

node* RBtree::successor(node *p)
{
	node *y = NULL;
	if (p->left != NULL)
	{
		y = p->left;
		while (y->right != NULL)
			y = y->right;
	}
	else
	{
		y = p->right;
		while (y->left != NULL)
			y = y->left;
	}
	return y;
}

void RBtree::disp()
{
	display(root);
}
void RBtree::display(node *p)
{
	if (root == NULL)
	{
		cout << "\nEmpty Tree.";
		return;
	}
	if (p != NULL)
	{
		cout << "\n\t NODE: ";
		cout << "\n Key: " << p->key;
		cout << "\n Colour: ";
		if (p->color == 'b')
			cout << "Black";
		else
			cout << "Red";
		if (p->parent != NULL)
			cout << "\n Parent: " << p->parent->key;
		else
			cout << "\n There is no parent of the node.  ";
		if (p->right != NULL)
			cout << "\n Right Child: " << p->right->key;
		else
			cout << "\n There is no right child of the node.  ";
		if (p->left != NULL)
			cout << "\n Left Child: " << p->left->key;
		else
			cout << "\n There is no left child of the node.  ";
		cout << endl;
		if (p->left)
		{
			cout << "\n\nLeft:\n";
			display(p->left);
		}
		
		if (p->right)
		{
			cout << "\n\nRight:\n";
			display(p->right);
		}
		
	}
}
void RBtree::search()
{
	if (root == NULL)
	{
		cout << "\nEmpty Tree\n";
		return;
	}
	int x;
	cout << "\n Enter key of the node to be searched: ";
	cin >> x;
	node *p = root;
	int found = 0;
	while (p != NULL && found == 0)
	{
		if (p->key == x)
			found = 1;
		if (found == 0)
		{
			if (p->key < x)
				p = p->right;
			else
				p = p->left;
		}
	}
	if (found == 0)
		cout << "\nElement Not Found.";
	else
	{
		cout << "\n\t FOUND NODE: ";
		cout << "\n Key: " << p->key;
		cout << "\n Colour: ";
		if (p->color == 'b')
			cout << "Black";
		else
			cout << "Red";
		if (p->parent != NULL)
			cout << "\n Parent: " << p->parent->key;
		else
			cout << "\n There is no parent of the node.  ";
		if (p->right != NULL)
			cout << "\n Right Child: " << p->right->key;
		else
			cout << "\n There is no right child of the node.  ";
		if (p->left != NULL)
			cout << "\n Left Child: " << p->left->key;
		else
			cout << "\n There is no left child of the node.  ";
		cout << endl;

	}
}
int main()
{
	int ch, y = 0;
	RBtree obj;
	do
	{
		cout << "\n\t RED BLACK TREE ";
		cout << "\n 1. Insert in the tree ";
		cout << "\n 2. Delete a node from the tree";
		cout << "\n 3. Search for an element in the tree";
		cout << "\n 4. Display the tree ";
		cout << "\n 5. Exit ";
		cout << "\nEnter Your Choice: ";
		cin >> ch;
		switch (ch)
		{
		case 1: obj.insert();
			cout << "\nNode Inserted.\n";
			break;
		case 2: obj.del();
			break;
		case 3: obj.search();
			break;
		case 4: obj.disp();
			break;
		case 5: y = 1;
			break;
		default: cout << "\nEnter a Valid Choice.";
		}
		cout << endl;

	} while (y != 1);
	return 1;
}


#include <cassert>   #include <iostream>  #include <vector>    #ifdef _MSC_VER
#include <string>  #else
#include <cstring>  #endif


namespace strings {

namespace manacher {

std::string manacher(const std::string &prototype) {
    if (prototype.size() > 0) {
                        std::string stuffed_string = "";
        for (auto str : prototype) {
            stuffed_string += str;
            stuffed_string += "#";
        }
        stuffed_string = "@#" + stuffed_string + "&";

        std::vector<uint64_t> palindrome_max_half_length(
            stuffed_string.size(),
            0);                                                     
        uint64_t bigger_center =
            0;                                  
        uint64_t right = 0;                               
                        for (uint64_t i = 1; i < stuffed_string.size() - 1; i++) {
            if (i < right) {                                                uint64_t opposite_to_i =
                    2 * bigger_center -
                    i;                          
                                                                                palindrome_max_half_length[i] = std::min(
                    palindrome_max_half_length[opposite_to_i], right - i);
            }

                                    while (stuffed_string[i + (palindrome_max_half_length[i] + 1)] ==
                   stuffed_string[i - (palindrome_max_half_length[i] + 1)]) {
                palindrome_max_half_length[i]++;
            }

                                                            if (i + palindrome_max_half_length[i] > right) {
                bigger_center = i;
                right = i + palindrome_max_half_length[i];
            }
        }

                uint64_t half_length = 0;           uint64_t center_index = 0;  
        for (uint64_t i = 1; i < stuffed_string.size() - 1; i++) {
            if (palindrome_max_half_length[i] > half_length) {
                half_length = palindrome_max_half_length[i];
                center_index = i;
            }
        }

        std::string palindromic_substring =
            "";  
        if (half_length > 0) {
                                    
            uint64_t start =
                center_index - half_length +
                1;              uint64_t end =
                center_index + half_length -
                1;              for (uint64_t index = start; index <= end; index += 2) {
                palindromic_substring += stuffed_string[index];
            }
        } else {
                                                palindromic_substring = prototype[0];
        }
        return palindromic_substring;

    } else {
                return "";
    }
}

}  }  

static void test() {
    assert(strings::manacher::manacher("") == "");
    assert(strings::manacher::manacher("abababc") == "ababa");
    assert(strings::manacher::manacher("cbaabd") == "baab");
    assert(strings::manacher::manacher("DedzefDeD") == "DeD");
    assert(strings::manacher::manacher("XZYYXXYZXX") == "YXXY");
    assert(strings::manacher::manacher("1sm222m10abc") == "m222m");
    assert(strings::manacher::manacher("798989591") == "98989");
    assert(strings::manacher::manacher("xacdedcax") == "xacdedcax");
    assert(strings::manacher::manacher("xaccax") == "xaccax");
    assert(strings::manacher::manacher("a") == "a");
    assert(strings::manacher::manacher("xy") == "x");
    assert(strings::manacher::manacher("abced") == "a");

    std::cout << "All tests have passed!" << std::endl;
}


int main() {
    test();      return 0;
}

#include <iostream>
#ifdef _MSC_VER
#include <string>  #else
#include <cstring>
#endif
#include <vector>

namespace string_search {

int brute_force(const std::string &text, const std::string &pattern) {
    size_t pat_l = pattern.length();
    size_t txt_l = text.length();
    int index = -1;
    if (pat_l <= txt_l) {
        for (size_t i = 0; i < txt_l - pat_l + 1; i++) {
            std::string s = text.substr(i, pat_l);
            if (s == pattern) {
                index = i;
                break;
            }
        }
    }
    return index;
}
}  
using string_search::brute_force;


const std::vector<std::vector<std::string>> test_set = {
        {"a", "aa", "-1"},  {"a", "a", "0"},    {"ba", "b", "0"},
    {"bba", "bb", "0"}, {"bbca", "c", "2"}, {"ab", "b", "1"}};


int main() {
    for (const auto &i : test_set) {
        int output = brute_force(i[0], i[1]);

        if (std::to_string(output) == i[2]) {
            std::cout << "success\n";
        } else {
            std::cout << "failure\n";
        }
    }
    return 0;
}


#include <iostream>
#include <unordered_map>
#include <cassert>


namespace strings {

namespace horspool {

std::unordered_map<char, int> findShiftTable(const std::string &prototype) {
    std::unordered_map<char, int>
        shiftTable;  
    for (int i = 0; i < prototype.size();
         i++) {          if (shiftTable.find(prototype[i]) ==
            shiftTable.end()) {              if (i != prototype.size() - 1) {
                shiftTable.insert(std::make_pair(
                    prototype[i], prototype.size() - i -
                                      1));              } else {
                shiftTable.insert(std::make_pair(
                    prototype[i],
                    prototype.size()));              }
        } else {
            if (i != prototype.size() - 1) {
                shiftTable[prototype[i]] = prototype.size() - i - 1;
            }
        }
    }
    return shiftTable;
}


bool horspool(const std::string &text, const std::string &prototype) {
    std::unordered_map<char, int> shiftTable = findShiftTable(
        prototype);  
    int i = static_cast<int>(
        prototype.size() -
        1);      while (i < text.size()) {
        int j = i, k = 0;
        bool flag = true;

        for (int z = static_cast<int>(prototype.size() - 1); z >= 0 && flag;
             z--) {              if (text[j] == prototype[z]) {
                k++;
                j--;
            } else {
                flag = false;              }
        }

        if (k ==
            prototype.size()) {              return true;
        } else {
            if (shiftTable.find(text[i]) != shiftTable.end()) {
                i += shiftTable[text[i]];              } else {
                i += prototype.size();              }
        }
    }
    return false;
}
} } 

static void test(){
    assert(strings::horspool::horspool("Hello World","World") == true);
    assert(strings::horspool::horspool("Hello World"," World") == true);
    assert(strings::horspool::horspool("Hello World","ello") == true);
    assert(strings::horspool::horspool("Hello World","rld") == true);
    assert(strings::horspool::horspool("Hello","Helo") == false);
    assert(strings::horspool::horspool("c++_algorithms","c++_algorithms") == true);
    assert(strings::horspool::horspool("c++_algorithms","c++_") == true);
    assert(strings::horspool::horspool("Hello","Hello World") == false);
    assert(strings::horspool::horspool("c++_algorithms","") == false);
    assert(strings::horspool::horspool("c++","c") == true);
    assert(strings::horspool::horspool("3458934793","4793") == true);
    assert(strings::horspool::horspool("3458934793","123") == false);
}


int main(){
    test();
    return 0;
}

#include <cassert>
#include <cmath>
#include <iostream>
#ifdef _MSC_VER
#include <string>  #else
#include <cstring>
#endif

#define PRIME 5  
namespace string_search {

int64_t create_hash(const std::string& s, int n) {
    int64_t result = 0;
    for (int i = 0; i < n; ++i) {
        result += (int64_t)(s[i] * (int64_t)pow(PRIME, i));
    }
    return result;
}


int64_t recalculate_hash(const std::string& s, int old_index, int new_index,
                         int64_t old_hash, int patLength) {
    int64_t new_hash = old_hash - s[old_index];
    new_hash /= PRIME;
    new_hash += (int64_t)(s[new_index] * (int64_t)pow(PRIME, patLength - 1));
    return new_hash;
}


bool check_if_equal(const std::string& str1, const std::string& str2,
                    int start1, int end1, int start2, int end2) {
    if (end1 - start1 != end2 - start2) {
        return false;
    }
    while (start1 <= end1 && start2 <= end2) {
        if (str1[start1] != str2[start2]) {
            return false;
        }
        start1++;
        start2++;
    }
    return true;
}



int rabin_karp(const std::string& str, const std::string& pat) {
    int64_t pat_hash = create_hash(pat, pat.size());
    int64_t str_hash = create_hash(str, pat.size());
    for (int i = 0; i <= str.size() - pat.size(); ++i) {
        if (pat_hash == str_hash &&
            check_if_equal(str, pat, i, i + pat.size() - 1, 0,
                           pat.size() - 1)) {
            return i;
        }
        if (i < str.size() - pat.size()) {
            str_hash =
                recalculate_hash(str, i, i + pat.size(), str_hash, pat.size());
        }
    }
    return -1;  }

}  
using string_search::rabin_karp;


int main(void) {
    assert(rabin_karp("helloWorld", "world") == -1);
    assert(rabin_karp("helloWorld", "World") == 5);
    assert(rabin_karp("this_is_c++", "c++") == 8);
    assert(rabin_karp("happy_coding", "happy") == 0);
    return 0;
}


#include <iostream>  #ifdef _MSC_VER
#include <string>  #else
#include <cstring>  #endif
#include <cassert>  #include <vector>   

std::vector<uint64_t> Z_function(const std::string &pattern) {
    uint64_t pattern_length = pattern.size();
    std::vector<uint64_t> z(pattern_length, 0);

    for (uint64_t i = 1, l = 0, r = 0; i < pattern_length; i++) {
        if (i <= r) {
            z[i] = std::min(r - i + 1, z[i - l]);
        }
        while (i + z[i] < pattern_length &&
               pattern[z[i]] == pattern[i + z[i]]) {
            z[i]++;
        }
        if (i + z[i] - 1 > r) {
            r = i + z[i] - 1;
        }
    }
    return z;
}


std::vector<uint64_t> find_pat_in_text(const std::string &pattern,
                                       const std::string &text) {
    uint64_t text_length = text.size(), pattern_length = pattern.size();
    std::vector<uint64_t> z = Z_function(pattern + '#' + text);
    std::vector<uint64_t> matching_indexes;

    for (uint64_t i = 0; i < text_length; i++) {
        if (z[i + pattern_length + 1] == pattern_length) {
            matching_indexes.push_back(i);
        }
    }
    return matching_indexes;
}


static void test() {
        std::string text1 = "alskfjaldsabc1abc1abcbksbcdnsdabcabc";
    std::string pattern1 = "abc";

        std::vector<uint64_t> matching_indexes1 = find_pat_in_text(pattern1, text1);
    assert((matching_indexes1 == std::vector<uint64_t>{10, 14, 18, 30, 33}));

        std::string text2 = "greengrass";
    std::string pattern2 = "abc";

        std::vector<uint64_t> matching_indexes2 = find_pat_in_text(pattern2, text2);
    assert((matching_indexes2 == std::vector<uint64_t>{}));
}


int main() {
    test();      return 0;
}


#include <iostream>
#ifdef _MSC_VER
#include <string>  #else
#include <cstring>
#endif
#include <vector>


namespace string_search {

std::vector<int> getFailureArray(const std::string &pattern) {
    int pattern_length = pattern.size();
    std::vector<int> failure(pattern_length + 1);
    failure[0] = -1;
    int j = -1;

    for (int i = 0; i < pattern_length; i++) {
        while (j != -1 && pattern[j] != pattern[i]) {
            j = failure[j];
        }
        j++;
        failure[i + 1] = j;
    }
    return failure;
}


bool kmp(const std::string &pattern, const std::string &text) {
    int text_length = text.size(), pattern_length = pattern.size();
    std::vector<int> failure = getFailureArray(pattern);

    int k = 0;
    for (int j = 0; j < text_length; j++) {
        while (k != -1 && pattern[k] != text[j]) {
            k = failure[k];
        }
        k++;
        if (k == pattern_length)
            return true;
    }
    return false;
}
}  
using string_search::kmp;


int main() {
    std::string text = "alskfjaldsabc1abc1abc12k23adsfabcabc";
    std::string pattern = "abc1abc12l";

    if (kmp(pattern, text) == true) {
        std::cout << "Found" << std::endl;
    } else {
        std::cout << "Not Found" << std::endl;
    }

    text = "abcabc";
    pattern = "bca";
    if (kmp(pattern, text) == true) {
        std::cout << "Found" << std::endl;
    } else {
        std::cout << "Not Found" << std::endl;
    }

    return 0;
}

#include <cassert>   #include <iostream>  
namespace bit_manipulation {

namespace count_bits_flip {

std::uint64_t countBitsFlip(
    std::int64_t A,
    std::int64_t B) {                         
    int count =
        0;                  A = A ^ B;
    while (A) {
        A = A & (A - 1);
        count++;
    }
    return count;
}
}  }  

static void test() {
        assert(bit_manipulation::count_bits_flip::countBitsFlip(10, 20) == 4);
        assert(bit_manipulation::count_bits_flip::countBitsFlip(20, 25) == 3);
        assert(bit_manipulation::count_bits_flip::countBitsFlip(7, 10) == 3);
        assert(bit_manipulation::count_bits_flip::countBitsFlip(17, 25) == 1);
        assert(bit_manipulation::count_bits_flip::countBitsFlip(11, 8) == 2);
        assert(bit_manipulation::count_bits_flip::countBitsFlip(21, 22) == 2);
        assert(bit_manipulation::count_bits_flip::countBitsFlip(7, 786) == 5);
    std::cout << "All test cases successfully passed!" << std::endl;
}

int main() {
    test();      return 0;
}


#include <cassert>   #include <iostream>  

namespace bit_manipulation {

namespace count_of_trailing_ciphers_in_factorial_n {

uint64_t numberOfCiphersInFactorialN(uint64_t n) {
        uint64_t count = 0;

            for (uint64_t i = 5; n / i >= 1; i *= 5) {
        count += static_cast<uint64_t>(n) / i;
    }

    return count;
}
}  }  

static void test() {
        std::cout << "1st test ";
    assert(bit_manipulation::count_of_trailing_ciphers_in_factorial_n::
               numberOfCiphersInFactorialN(395) == 97);
    std::cout << "passed" << std::endl;

        std::cout << "2nd test ";
    assert(bit_manipulation::count_of_trailing_ciphers_in_factorial_n::
               numberOfCiphersInFactorialN(977) == 242);
    std::cout << "passed" << std::endl;

        std::cout << "3rd test ";
    assert(bit_manipulation::count_of_trailing_ciphers_in_factorial_n::
               numberOfCiphersInFactorialN(871) == 215);
    std::cout << "passed" << std::endl;

        std::cout << "4th test ";
    assert(bit_manipulation::count_of_trailing_ciphers_in_factorial_n::
               numberOfCiphersInFactorialN(239) == 57);
    std::cout << "passed" << std::endl;

        std::cout << "5th test ";
    assert(bit_manipulation::count_of_trailing_ciphers_in_factorial_n::
               numberOfCiphersInFactorialN(0) == 0);
    std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}


#include <cassert>   #include <iostream>  

namespace bit_manipulation {

namespace hamming_distance {

uint64_t bitCount(uint64_t value) {
    uint64_t count = 0;
    while (value) {               if (value & 1) {              count++;
        }
        value >>= 1;      }
    return count;
}


uint64_t hamming_distance(uint64_t a, uint64_t b) { return bitCount(a ^ b); }


uint64_t hamming_distance(const std::string& a, const std::string& b) {
    assert(a.size() == b.size());
    size_t n = a.size();
    uint64_t count = 0;
    for (size_t i = 0; i < n; i++) {
        count += (b[i] != a[i]);
    }
    return count;
}
}  }  

static void test() {
    assert(bit_manipulation::hamming_distance::hamming_distance(11, 2) == 2);
    assert(bit_manipulation::hamming_distance::hamming_distance(2, 0) == 1);
    assert(bit_manipulation::hamming_distance::hamming_distance(11, 0) == 3);

    assert(bit_manipulation::hamming_distance::hamming_distance("1101",
                                                                "1111") == 1);
    assert(bit_manipulation::hamming_distance::hamming_distance("1111",
                                                                "1111") == 0);
    assert(bit_manipulation::hamming_distance::hamming_distance("0000",
                                                                "1111") == 4);

    assert(bit_manipulation::hamming_distance::hamming_distance("alpha",
                                                                "alphb") == 1);
    assert(bit_manipulation::hamming_distance::hamming_distance("abcd",
                                                                "abcd") == 0);
    assert(bit_manipulation::hamming_distance::hamming_distance("dcba",
                                                                "abcd") == 4);
}


int main() {
    test();               uint64_t a = 11;      uint64_t b = 2;   
    std::cout << "Hamming distance between " << a << " and " << b << " is "
              << bit_manipulation::hamming_distance::hamming_distance(a, b)
              << std::endl;
}


#include <cassert>   #include <iostream>  

namespace bit_manipulation {

namespace set_kth_bit {

std::uint64_t setKthBit(std ::int64_t N,
                        std ::int64_t k) {                                              
    int pos =
        1 << k;                   
    return N | pos;                       }
}  }  

static void test() {
        assert(bit_manipulation::set_kth_bit::setKthBit(10, 2) == 14);
        assert(bit_manipulation::set_kth_bit::setKthBit(25, 1) == 27);
        assert(bit_manipulation::set_kth_bit::setKthBit(400001, 5) == 400033);
        assert(bit_manipulation::set_kth_bit::setKthBit(123, 3) == 123);

    std::cout << "All test cases successfully passed!" << std::endl;
}

int main() {
    test();      return 0;
}

#include <cassert>   #include <iostream>  
namespace bit_manipulation {

namespace count_of_set_bits {

std::uint64_t countSetBits(
    std ::int64_t n) {                          
    int count = 0;                          while (n != 0) {
        ++count;
        n = (n & (n - 1));
    }
    return count;
                }
}  }  
static void test() {
        assert(bit_manipulation::count_of_set_bits::countSetBits(4) == 1);
        assert(bit_manipulation::count_of_set_bits::countSetBits(6) == 2);
        assert(bit_manipulation::count_of_set_bits::countSetBits(13) == 3);
        assert(bit_manipulation::count_of_set_bits::countSetBits(9) == 2);
        assert(bit_manipulation::count_of_set_bits::countSetBits(15) == 4);
        assert(bit_manipulation::count_of_set_bits::countSetBits(25) == 3);
        assert(bit_manipulation::count_of_set_bits::countSetBits(97) == 3);
        assert(bit_manipulation::count_of_set_bits::countSetBits(31) == 5);
    std::cout << "All test cases successfully passed!" << std::endl;
}

int main() {
    test();      return 0;
}
#include <iostream>
using namespace std;
const int N = 1e6 + 5;
int a[N], bucket[N], cnt[N];
int bucket_size;
struct query {
    int l, r, i;
} q[N];
int ans = 0;

void add(int index) {
    cnt[a[index]]++;
    if (cnt[a[index]] == 1)
        ans++;
}
void remove(int index) {
    cnt[a[index]]--;
    if (cnt[a[index]] == 0)
        ans--;
}

bool mycmp(query x, query y) {
    if (x.l / bucket_size != y.l / bucket_size)
        return x.l / bucket_size < y.l / bucket_size;
    return x.r < y.r;
}

int main() {
    int n, t, i, j, k = 0;
    scanf("%d", &n);
    for (i = 0; i < n; i++) scanf("%d", &a[i]);
    bucket_size = ceil(sqrt(n));
    scanf("%d", &t);
    for (i = 0; i < t; i++) {
        scanf("%d %d", &q[i].l, &q[i].r);
        q[i].l--;
        q[i].r--;
        q[i].i = i;
    }
    sort(q, q + t, mycmp);
    int left = 0, right = 0;
    for (i = 0; i < t; i++) {
        int L = q[i].l, R = q[i].r;
        while (left < L) {
            remove(left);
            left++;
        }
        while (left > L) {
            add(left - 1);
            left--;
        }
        while (right <= R) {
            add(right);
            right++;
        }
        while (right > R + 1) {
            remove(right - 1);
            right--;
        }
        bucket[q[i].i] = ans;
    }
    for (i = 0; i < t; i++) printf("%d\n", bucket[i]);
    return 0;
}


#include <vector>
#include <cassert>
#include <iostream>
#include <algorithm>


namespace range_queries {

 namespace sparse_table {

template<typename T>
std::vector<T> computeLogs(const std::vector<T>& A) {
    int n = A.size();
    std::vector<T> logs(n);
    logs[1] = 0;
    for (int i = 2 ; i < n ; i++) {
        logs[i] = logs[i/2] + 1;
    }
    return logs;
}


template<typename T>
std::vector<std::vector<T> > buildTable(const std::vector<T>& A, const std::vector<T>& logs) {
    int n = A.size();
    std::vector<std::vector<T> > table(20, std::vector<T>(n+5, 0));
    int curLen = 0;
    for (int i = 0 ; i <= logs[n] ; i++) {
        curLen = 1 << i;
        for (int j = 0 ; j + curLen < n ; j++) {
            if (curLen == 1) {
                table[i][j] = A[j];
            }
            else {
                table[i][j] = std::min(table[i-1][j], table[i-1][j + curLen/2]);
            }
        }
    }
    return table;
}


template<typename T>
int getMinimum(int beg, int end, const std::vector<T>& logs, const std::vector<std::vector<T> >& table) {
    int p = logs[end - beg + 1];
    int pLen = 1 << p;
    return std::min(table[p][beg], table[p][end - pLen + 1]);
}
}
} 

int main() {
    std::vector<int> A{1, 2, 0, 3, 9};
    std::vector<int> logs = range_queries::sparse_table::computeLogs(A);
    std::vector<std::vector<int> >  table = range_queries::sparse_table::buildTable(A, logs);
    assert(range_queries::sparse_table::getMinimum(0, 0, logs, table) == 1);
    assert(range_queries::sparse_table::getMinimum(0, 4, logs, table) == 0);
    assert(range_queries::sparse_table::getMinimum(2, 4, logs, table) == 0);
    return 0;
}


#include <iostream>  #include <memory>    #include <vector>    

namespace range_queries {


class perSegTree {
 private:
    class Node {
     public:
        std::shared_ptr<Node> left = nullptr;           std::shared_ptr<Node> right = nullptr;          int64_t val = 0,
                prop = 0;                                                                                       };

    uint32_t n = 0;      std::vector<std::shared_ptr<Node>>
        ptrs{};                                        std::vector<int64_t> vec{};                                   
    
    std::shared_ptr<Node> newKid(std::shared_ptr<Node> const &curr) {
        auto newNode = std::make_shared<Node>(Node());
        newNode->left = curr->left;
        newNode->right = curr->right;
        newNode->prop = curr->prop;
        newNode->val = curr->val;
        return newNode;
    }

    
    void lazy(const uint32_t &i, const uint32_t &j,
              std::shared_ptr<Node> const &curr) {
        if (!curr->prop) {
            return;
        }
        curr->val += (j - i + 1) * curr->prop;
        if (i != j) {
            curr->left = newKid(curr->left);
            curr->right = newKid(curr->right);
            curr->left->prop += curr->prop;
            curr->right->prop += curr->prop;
        }
        curr->prop = 0;
    }

    
    std::shared_ptr<Node> construct(const uint32_t &i, const uint32_t &j) {
        auto newNode = std::make_shared<Node>(Node());
        if (i == j) {
            newNode->val = vec[i];
        } else {
            uint32_t mid = i + (j - i) / 2;
            auto leftt = construct(i, mid);
            auto right = construct(mid + 1, j);
            newNode->val = leftt->val + right->val;
            newNode->left = leftt;
            newNode->right = right;
        }
        return newNode;
    }

    
    std::shared_ptr<Node> update(const uint32_t &i, const uint32_t &j,
                                 const uint32_t &l, const uint32_t &r,
                                 const int64_t &value,
                                 std::shared_ptr<Node> const &curr) {
        lazy(i, j, curr);
        if (i >= l && j <= r) {
            std::shared_ptr<Node> newNode = newKid(curr);
            newNode->prop += value;
            lazy(i, j, newNode);
            return newNode;
        }
        if (i > r || j < l) {
            return curr;
        }
        auto newNode = std::make_shared<Node>(Node());
        uint32_t mid = i + (j - i) / 2;
        newNode->left = update(i, mid, l, r, value, curr->left);
        newNode->right = update(mid + 1, j, l, r, value, curr->right);
        newNode->val = newNode->left->val + newNode->right->val;
        return newNode;
    }

    
    int64_t query(const uint32_t &i, const uint32_t &j, const uint32_t &l,
                  const uint32_t &r, std::shared_ptr<Node> const &curr) {
        lazy(i, j, curr);
        if (j < l || r < i) {
            return 0;
        }
        if (i >= l && j <= r) {
            return curr->val;
        }
        uint32_t mid = i + (j - i) / 2;
        return query(i, mid, l, r, curr->left) +
               query(mid + 1, j, l, r, curr->right);
    }

    
 public:
    
    void construct(const std::vector<int64_t>
                       &vec)                                    {
        if (vec.empty()) {
            return;
        }
        n = vec.size();
        this->vec = vec;
        auto root = construct(0, n - 1);
        ptrs.push_back(root);
    }

    
    void update(const uint32_t &l, const uint32_t &r,
                const int64_t
                    &value)                                   {
        ptrs.push_back(update(
            0, n - 1, l, r, value,
            ptrs[ptrs.size() -
                 1]));      }

    
    int64_t query(
        const uint32_t &l, const uint32_t &r,
        const uint32_t
            &version)                             {
        return query(0, n - 1, l, r, ptrs[version]);
    }

    
    uint32_t size()                                                {
        return ptrs.size();
    }
};
}  

static void test() {
    std::vector<int64_t> arr = {-5, 2, 3, 11, -2, 7, 0, 1};
    range_queries::perSegTree tree;
    std::cout << "Elements before any updates are {";
    for (uint32_t i = 0; i < arr.size(); ++i) {
        std::cout << arr[i];
        if (i != arr.size() - 1) {
            std::cout << ",";
        }
    }
    std::cout << "}\n";
    tree.construct(
        arr);      std::cout << "Querying range sum on version 0 from index 2 to 4 = 3+11-2 = "
              << tree.query(2, 4, 0) << '\n';
    std::cout
        << "Subtract 7 from all elements from index 1 to index 5 inclusive\n";
    tree.update(1, 5, -7);      std::cout << "Elements of the segment tree whose version = 1 (after 1 "
                 "update) are {";
    for (uint32_t i = 0; i < arr.size(); ++i) {
        std::cout << tree.query(i, i, 1);
        if (i != arr.size() - 1) {
            std::cout << ",";
        }
    }
    std::cout << "}\n";
    std::cout << "Add 10 to all elements from index 0 to index 7 inclusive\n";
    tree.update(0, 7, 10);      std::cout << "Elements of the segment tree whose version = 2 (after 2 "
                 "updates) are {";
    for (uint32_t i = 0; i < arr.size(); ++i) {
        std::cout << tree.query(i, i, 2);
        if (i != arr.size() - 1) {
            std::cout << ",";
        }
    }
    std::cout << "}\n";
    std::cout << "Number of segment trees (versions) now = " << tree.size()
              << '\n';
    std::cout << "Querying range sum on version 0 from index 3 to 5 = 11-2+7 = "
              << tree.query(3, 5, 0) << '\n';
    std::cout << "Querying range sum on version 1 from index 3 to 5 = 4-9+0 = "
              << tree.query(3, 5, 1) << '\n';
}


int main() {
    test();      return 0;
}


#include <cassert>   #include <iostream>  #include <vector>    

namespace range_queries {

namespace prefix_sum_array {

std::vector<int64_t> PSA(1, 0);


void build(std::vector<int64_t> original_array) {
    for (int i = 1; i <= static_cast<int>(original_array.size()); i++) {
        PSA.push_back(PSA[i - 1] + original_array[i]);
    }
}

int64_t query(int64_t beg, int64_t end) { return PSA[end] - PSA[beg - 1]; }

}  }  

static void test() {
    std::vector<int64_t> values{0,  123, 0,  2,  -2, 5,
                                24, 0,   23, -1, -1};  
    range_queries::prefix_sum_array::build(values);
    
    assert(range_queries::prefix_sum_array::query(1, 10) ==
           173);      assert(range_queries::prefix_sum_array::query(4, 6) ==
           27);      assert(range_queries::prefix_sum_array::query(5, 9) ==
           51);  }


int main() {
    test();      return 0;
}

#include <cassert>
#include <iostream>
#include <vector>


class FenwickTree {
    int n;
    std::vector<int> bit;

    
    inline int offset(int x) { return (x & (-x)); }

 public:
    
    explicit FenwickTree(const std::vector<int>& arr) {
        n = arr.size();
        bit.assign(n + 1, 0);
        for (int i = 0; i < n; ++i) {
            update(i, arr[i]);
        }
    }

    
    explicit FenwickTree(int x) {
        n = x;
        bit.assign(n + 1, 0);
    }

    
    void update(int id, int val) {
        id++;
        while (id <= n) {
            bit[id] += val;
            id += offset(id);
        }
    }

    
    int sum(int id) {
        id++;
        int res = 0;
        while (id > 0) {
            res += bit[id];
            id -= offset(id);
        }
        return res;
    }

    
    int sum_range(int l, int r) { return sum(r) - sum(l - 1); }
};


int main() {
    int n = 5;
    std::vector<int> arr = {1, 2, 3, 4, 5};
    FenwickTree fenwick_tree(arr);

    assert(fenwick_tree.sum_range(0, 0) == 1);
    assert(fenwick_tree.sum_range(0, 1) == 3);
    assert(fenwick_tree.sum_range(0, 2) == 6);
    fenwick_tree.update(0, 6);
    assert(fenwick_tree.sum_range(0, 0) == 6);
    assert(fenwick_tree.sum_range(0, 1) == 8);
    assert(fenwick_tree.sum_range(0, 2) == 11);
    return 0;
}


#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstring>
#include <iostream>
#include <list>
#include <numeric>
#include <string>
#include <vector>


namespace range_queries {

namespace heavy_light_decomposition {

template <typename X> class Tree {
  
private:
  std::vector<std::list<int>>
      t_adj;           const int t_nodes,       t_maxlift;       std::vector<std::vector<int>>
      t_par;                  std::vector<int> t_depth,       t_size; 
  int t_root;             std::vector<X> t_val;   template <typename T> friend class HLD;

  
  void dfs_size(int u, int p = -1) {
    for (const int &v : t_adj[u]) {
      if (v ^ p) {
        dfs_size(v, u);
        t_size[u] += t_size[v];
      }
    }
  }

  
  void dfs_lca(int u, int p = -1) {
    t_par[u][0] = p;
    if (p != -1) {
      t_depth[u] = 1 + t_depth[p];
    }
    for (int k = 1; k < t_maxlift; k++) {
      if (t_par[u][k - 1] != -1) {
        t_par[u][k] = t_par[t_par[u][k - 1]][k - 1];
      }
    }

    for (const int &v : t_adj[u]) {
      if (v ^ p) {
        dfs_lca(v, u);
      }
    }
  }

public:
  
  explicit Tree(int nodes)
      : t_nodes(nodes), t_maxlift(static_cast<int>(floor(log2(nodes))) + 1) {
    t_root = 0; 
    t_adj.resize(t_nodes);
    t_par.assign(t_nodes, std::vector<int>(t_maxlift, -1));
    t_depth.assign(t_nodes, 0);
    t_size.assign(t_nodes, 1);
    t_val.resize(t_nodes);
  }

  
  void add_edge(const int u, const int v) {
    t_adj[u].push_back(v);
    t_adj[v].push_back(u);
  }

  
  void change_root(int new_root) { t_root = new_root; }

  
  void set_node_val(const std::vector<X> &node_val) {
    assert(static_cast<int>(node_val.size()) == t_nodes);
    t_val = node_val;
  }

  
  void init() {
    assert(t_nodes > 0);
    dfs_size(t_root);
    dfs_lca(t_root);
  }

  
  void lift(int *const p, int dist) {
    for (int k = 0; k < t_maxlift; k++) {
      if (*p == -1) {
        return;
      }
      if (dist & 1) {
        *p = t_par[*p][k];
      }
      dist >>= 1;
    }
  }

  
  int kth_ancestor(int p, const int &dist) {
    lift(&p, dist);
    return p;
  }

  
  int lca(int a, int b) {
    assert(a >= 0 and b >= 0 and a < t_nodes and b < t_nodes);
    if (t_depth[a] > t_depth[b]) {
      lift(&a, t_depth[a] - t_depth[b]);
    }
    if (t_depth[b] > t_depth[a]) {
      lift(&b, t_depth[b] - t_depth[a]);
    }
    if (a == b) {
      return a;
    }
    for (int k = t_maxlift - 1; k >= 0; k--) {
      if (t_par[a][k] != t_par[b][k]) {
        a = t_par[a][k];
        b = t_par[b][k];
      }
    }
    return t_par[a][0];
  }
};


template <typename X> class SG {
private:
  

  std::vector<X> s_tree;   int s_size;              X sret_init = 0;         template <typename T> friend class HLD;

  
  X combine(X lhs, X rhs) { return lhs + rhs; }

  
  explicit SG(int size) {
    s_size = size;
    s_tree.assign(2 * s_size, 0ll);
  }

  
  void update(int p, X v) {
    for (p += s_size; p > 0; p >>= 1) {
      s_tree[p] += v;
    }
  }

  
  X query(int l, int r) {
    X lhs = sret_init, rhs = sret_init;
    for (l += s_size, r += s_size + 1; l < r; l >>= 1, r >>= 1) {
      if (l & 1) {
        lhs = combine(lhs, s_tree[l++]);
      }
      if (r & 1) {
        rhs = combine(s_tree[--r], rhs);
      }
    }
    return combine(lhs, rhs);
  }

  
  void set_sret_init(X new_sret_init) { sret_init = new_sret_init; }
};


template <typename X> class HLD : public Tree<X>, public SG<X> {
private:
  int label;                  std::vector<int> h_label,       h_heavychlid,               h_parent;             
  
  void dfs_hc(int u, int p = -1) {
    int hc_size = -1, hc_id = -1;
    for (const int &v : Tree<X>::t_adj[u]) {
      if (v ^ p) {
        dfs_hc(v, u);
        if (Tree<X>::t_size[v] > hc_size) {
          hc_size = Tree<X>::t_size[v];
          hc_id = v;
        }
      }
    }
    h_heavychlid[u] = hc_id;
  }

  
  void dfs_par(int u, int p = -1) {
    if (h_heavychlid[u] != -1) {
      h_parent[h_heavychlid[u]] = h_parent[u];
      dfs_par(h_heavychlid[u], u);
    }
    for (const int &v : Tree<X>::t_adj[u]) {
      if (v ^ p and v ^ h_heavychlid[u]) {
        dfs_par(v, u);
      }
    }
  }

  
  void dfs_labels(int u, int p = -1) {
    h_label[u] = label++;
    if (h_heavychlid[u] != -1) {
      dfs_labels(h_heavychlid[u], u);
    }
    for (const int &v : Tree<X>::t_adj[u]) {
      if (v ^ p and v ^ h_heavychlid[u]) {
        dfs_labels(v, u);
      }
    }
  }

  
  X chain_query(int a, int b) {
    X ret = SG<X>::sret_init;
    if (Tree<X>::t_depth[a] < Tree<X>::t_depth[b]) {
      std::swap(a, b);
    }
    while (Tree<X>::t_depth[a] >= Tree<X>::t_depth[b]) {
      int l = h_label[h_parent[a]];
      int r = h_label[a];
      if (Tree<X>::t_depth[h_parent[a]] < Tree<X>::t_depth[b]) {
        l += Tree<X>::t_depth[b] - Tree<X>::t_depth[h_parent[a]];
      }
      ret = SG<X>::combine(ret, SG<X>::query(l, r));
      a = Tree<X>::t_par[h_parent[a]][0];
      if (a == -1) {
        break;
      }
    }
    return ret;
  }

public:
  
  explicit HLD<X>(int nodes) : Tree<X>(nodes), SG<X>(nodes) {
    label = 0;
    h_label.assign(Tree<X>::t_nodes, -1);
    h_heavychlid.assign(Tree<X>::t_nodes, -1);
    h_parent.resize(Tree<X>::t_nodes);
    iota(h_parent.begin(), h_parent.end(), 0);
  }

  
  void init() {
    Tree<X>::init();

        label = 0;
    dfs_hc(Tree<X>::t_root);
    dfs_par(Tree<X>::t_root);
    dfs_labels(Tree<X>::t_root);

        for (int i = 0; i < Tree<X>::t_nodes; i++) {
      SG<X>::s_tree[h_label[i] + Tree<X>::t_nodes] = Tree<X>::t_val[i];
    }
    for (int i = Tree<X>::t_nodes - 1; i > 0; i--) {
      SG<X>::s_tree[i] =
          SG<X>::combine(SG<X>::s_tree[i << 1], SG<X>::s_tree[i << 1 | 1]);
    }
  }

  
  void update(int node, X val) {
    X diff = val - Tree<X>::t_val[node];
    SG<X>::update(h_label[node], diff);
    Tree<X>::t_val[node] = val;
  }

  
  X query(int a, int b) {
    int lc = Tree<X>::lca(a, b);
    X ret = SG<X>::sret_init;
    assert(lc != -1);
    ret += chain_query(a, lc);
    ret += chain_query(b, lc);
    return ret - Tree<X>::t_val[lc];
  }
};
} } 

static void test_1() {
  std::cout << "Test 1:\n";

    int n = 5;
  std::vector<int64_t> node_values = {4, 2, 5, 2, 1};
  std::vector<std::vector<int>> edges = {{1, 2}, {1, 3}, {3, 4}, {3, 5}};
  std::vector<std::vector<int>> queries = {
      {2, 1, 4},
      {1, 3, 2},
      {2, 1, 4},
  };
  std::vector<int> expected_result = {11, 8};
  std::vector<int> code_result;

  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);
  hld.set_node_val(node_values);
  for (int i = 0; i < n - 1; i++) {
    int u = edges[i][0], v = edges[i][1];
    hld.add_edge(u - 1, v - 1);
  }
  hld.init();
  for (const auto &q : queries) {
    int type = q[0];
    if (type == 1) {
      int p = q[1], x = q[2];
      hld.update(p - 1, x);
    } else if (type == 2) {
      int a = q[1], b = q[2];
      code_result.push_back(hld.query(a - 1, b - 1));
    } else {
      continue;
    }
  }
  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {
    assert(expected_result[i] == code_result[i]);
  }
  std::cout << "\nTest 1 passed!\n";
}


static void test_2() {
  std::cout << "Test 2:\n";

    int n = 10;
  std::vector<int64_t> node_values = {1, 8, 6, 8, 6, 2, 9, 2, 3, 2};
  std::vector<std::vector<int>> edges = {
      {10, 5}, {6, 2}, {10, 7}, {5, 2}, {3, 9}, {8, 3}, {1, 4}, {6, 4}, {8, 7}};
  std::vector<std::vector<int>> queries = {
      {2, 1, 10}, {2, 1, 6}, {1, 3, 4}, {2, 1, 9}, {1, 5, 3},
      {1, 7, 8},  {2, 1, 4}, {2, 1, 8}, {1, 1, 4}, {1, 2, 7}};
  std::vector<int> expected_result = {27, 11, 45, 9, 34};
  std::vector<int> code_result;

  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);
  hld.set_node_val(node_values);
  for (int i = 0; i < n - 1; i++) {
    int u = edges[i][0], v = edges[i][1];
    hld.add_edge(u - 1, v - 1);
  }
  hld.init();
  for (const auto &q : queries) {
    int type = q[0];
    if (type == 1) {
      int p = q[1], x = q[2];
      hld.update(p - 1, x);
    } else if (type == 2) {
      int a = q[1], b = q[2];
      code_result.push_back(hld.query(a - 1, b - 1));
    } else {
      continue;
    }
  }
  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {
    assert(expected_result[i] == code_result[i]);
  }
  std::cout << "\nTest2 passed!\n";
}


static void test_3() {
  std::cout << "Test 3:\n";

    int n = 8;
  std::vector<int64_t> node_values = {1, 8, 6, 8, 6, 2, 9, 2};
  std::vector<std::vector<int>> edges = {{1, 2}, {2, 3}, {3, 4}, {1, 5},
                                         {6, 3}, {7, 5}, {8, 7}};
  std::vector<std::vector<int>> queries = {
      {2, 6, 8}, {2, 3, 6}, {1, 3, 4}, {2, 7, 1}, {1, 5, 3},
      {1, 7, 8}, {2, 6, 4}, {2, 7, 8}, {1, 1, 4}, {1, 2, 7}};
  std::vector<int> expected_result = {34, 8, 16, 14, 10};
  std::vector<int> code_result;

  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);
  hld.set_node_val(node_values);
  for (int i = 0; i < n - 1; i++) {
    int u = edges[i][0], v = edges[i][1];
    hld.add_edge(u - 1, v - 1);
  }
  hld.init();
  for (const auto &q : queries) {
    int type = q[0];
    if (type == 1) {
      int p = q[1], x = q[2];
      hld.update(p - 1, x);
    } else if (type == 2) {
      int a = q[1], b = q[2];
      code_result.push_back(hld.query(a - 1, b - 1));
    } else {
      continue;
    }
  }
  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {
    assert(expected_result[i] == code_result[i]);
  }
  std::cout << "\nTest3 passed!\n";
}


int main() {
  test_1();
  test_2();
  test_3();
  return 0;
}


#include <cassert>   #include <cmath>     #include <iostream>  #include <vector>    

void ConsTree(const std::vector<int64_t> &arr, std::vector<int64_t> *segtree,
              uint64_t low, uint64_t high, uint64_t pos) {
    if (low == high) {
        (*segtree)[pos] = arr[low];
        return;
    }

    uint64_t mid = (low + high) / 2;
    ConsTree(arr, segtree, low, mid, 2 * pos + 1);
    ConsTree(arr, segtree, mid + 1, high, 2 * pos + 2);
    (*segtree)[pos] = (*segtree)[2 * pos + 1] + (*segtree)[2 * pos + 2];
}


int64_t query(std::vector<int64_t> *segtree, std::vector<int64_t> *lazy,
              uint64_t qlow, uint64_t qhigh, uint64_t low, uint64_t high,
              uint64_t pos) {
    if (low > high || qlow > high || low > qhigh) {
        return 0;
    }

    if ((*lazy)[pos] != 0) {
        (*segtree)[pos] += (*lazy)[pos] * (high - low + 1);

        if (low != high) {
            (*lazy)[2 * pos + 1] += (*lazy)[pos];
            (*lazy)[2 * pos + 2] += (*lazy)[pos];
        }
        (*lazy)[pos] = 0;
    }

    if (qlow <= low && qhigh >= high) {
        return (*segtree)[pos];
    }

    uint64_t mid = (low + high) / 2;

    return query(segtree, lazy, qlow, qhigh, low, mid, 2 * pos + 1) +
           query(segtree, lazy, qlow, qhigh, mid + 1, high, 2 * pos + 2);
}


void update(std::vector<int64_t> *segtree, std::vector<int64_t> *lazy,
            int64_t start, int64_t end, int64_t delta, uint64_t low,
            uint64_t high, uint64_t pos) {
    if (low > high) {
        return;
    }

    if ((*lazy)[pos] != 0) {
        (*segtree)[pos] += (*lazy)[pos] * (high - low + 1);

        if (low != high) {
            (*lazy)[2 * pos + 1] += (*lazy)[pos];
            (*lazy)[2 * pos + 2] += (*lazy)[pos];
        }
        (*lazy)[pos] = 0;
    }

    if (start > high || end < low) {
        return;
    }

    if (start <= low && end >= high) {
        (*segtree)[pos] += delta * (high - low + 1);

        if (low != high) {
            (*lazy)[2 * pos + 1] += delta;
            (*lazy)[2 * pos + 2] += delta;
        }

        return;
    }

    uint64_t mid = (low + high) / 2;

    update(segtree, lazy, start, end, delta, low, mid, 2 * pos + 1);
    update(segtree, lazy, start, end, delta, mid + 1, high, 2 * pos + 2);
    (*segtree)[pos] = (*segtree)[2 * pos + 1] + (*segtree)[2 * pos + 2];
}


static void test() {
    auto max = static_cast<int64_t>(2 * pow(2, ceil(log2(7))) - 1);
    assert(max == 15);

    std::vector<int64_t> arr{1, 2, 3, 4, 5, 6, 7}, lazy(max), segtree(max);
    ConsTree(arr, &segtree, 0, 7 - 1, 0);

    assert(query(&segtree, &lazy, 1, 5, 0, 7 - 1, 0) == 2 + 3 + 4 + 5 + 6);

    update(&segtree, &lazy, 2, 4, 1, 0, 7 - 1, 0);
    assert(query(&segtree, &lazy, 1, 5, 0, 7 - 1, 0) == 2 + 4 + 5 + 6 + 6);

    update(&segtree, &lazy, 0, 6, -2, 0, 7 - 1, 0);
    assert(query(&segtree, &lazy, 0, 4, 0, 7 - 1, 0) == -1 + 0 + 2 + 3 + 4);
}


int main() {
    test();  
    std::cout << "Enter number of elements: ";

    uint64_t n = 0;
    std::cin >> n;

    auto max = static_cast<uint64_t>(2 * pow(2, ceil(log2(n))) - 1);
    std::vector<int64_t> arr(n), lazy(max), segtree(max);

    int choice = 0;
    std::cout << "\nDo you wish to enter each number?:\n"
                 "1: Yes\n"
                 "0: No (default initialize them to 0)\n";

    std::cin >> choice;
    if (choice == 1) {
        std::cout << "Enter " << n << " numbers:\n";
        for (int i = 1; i <= n; i++) {
            std::cout << i << ": ";
            std::cin >> arr[i];
        }
    }

    ConsTree(arr, &segtree, 0, n - 1, 0);

    do {
        std::cout << "\nMake your choice:\n"
                     "1: Range update (input)\n"
                     "2: Range query (output)\n"
                     "0: Exit\n";
        std::cin >> choice;

        if (choice == 1) {
            std::cout << "Enter 1-indexed lower bound, upper bound & value:\n";

            uint64_t p = 1, q = 1, v = 0;
            std::cin >> p >> q >> v;
            update(&segtree, &lazy, p - 1, q - 1, v, 0, n - 1, 0);
        } else if (choice == 2) {
            std::cout << "Enter 1-indexed lower bound & upper bound:\n";

            uint64_t p = 1, q = 1;
            std::cin >> p >> q;
            std::cout << query(&segtree, &lazy, p - 1, q - 1, 0, n - 1, 0);
            std::cout << "\n";
        }
    } while (choice > 0);

    return 0;
}

#include <cassert>  #include <cstdlib>  #include <ctime>    #include <list>     #include <set>  #include <vector>  

namespace probability {

namespace windowed_median {
using Window = std::list<int>;
using size_type = Window::size_type;


class WindowedMedian {
    const size_type _windowSize;      Window _window;      std::multiset<int> _sortedValues;                                             std::multiset<int>::const_iterator
        _itMedian;                      
    
    void insertToSorted(int value) {
        _sortedValues.insert(value);          const auto sz = _sortedValues.size();
        if (sz == 1) {              _itMedian = _sortedValues.begin();
            return;
        }

                                if (value < *_itMedian && sz % 2 == 0) {
            --_itMedian;          }

                        else if (value >= *_itMedian && sz % 2 != 0) {
            ++_itMedian;          }
    }

    
    void eraseFromSorted(int value) {
        const auto sz = _sortedValues.size();

                                if (value <= *_itMedian && sz % 2 == 0) {
            ++_itMedian;          }

                                else if (value >= *_itMedian && sz % 2 != 0) {
            --_itMedian;          }

                        const auto it = _sortedValues.find(value);          _sortedValues.erase(it);                        }

 public:
    
    explicit WindowedMedian(size_type windowSize) : _windowSize(windowSize){};

    
    void insert(int value) {
                _window.push_back(value);
        insertToSorted(value);          if (_window.size() > _windowSize) {                                                           eraseFromSorted(
                _window.front());                                                 _window.pop_front();                                              }
    }

    
    float getMedian() const {
        if (_sortedValues.size() % 2 != 0) {
            return *_itMedian;          }
        return 0.5f * *_itMedian + 0.5f * *next(_itMedian);      }

    
    float getMedianNaive() const {
        auto window = _window;
        window.sort();          auto median =
            *next(window.begin(),
                  window.size() / 2);          if (window.size() % 2 != 0) {
            return median;
        }
        return 0.5f * median +
               0.5f * *next(window.begin(), window.size() / 2 - 1);      }
};
}  }  

static void test(const std::vector<int> &vals, int windowSize) {
    probability::windowed_median::WindowedMedian windowedMedian(windowSize);
    for (const auto val : vals) {
        windowedMedian.insert(val);

                assert(windowedMedian.getMedian() == windowedMedian.getMedianNaive());
    }
}


int main(int argc, const char *argv[]) {
        test({1, 2, 3, 4, 5, 6, 7, 8, 9},
         3);      test({9, 8, 7, 6, 5, 4, 3, 2, 1},
         3);      test({9, 8, 7, 6, 5, 4, 5, 6}, 4);         test({3, 3, 3, 3, 3, 3, 3, 3, 3}, 3);      test({3, 3, 3, 3, 7, 3, 3, 3, 3}, 3);      test({4, 3, 3, -5, -5, 1, 3, 4, 5},
         5);  
                test({470211272, 101027544, 1457850878, 1458777923, 2007237709, 823564440,
          1115438165, 1784484492, 74243042, 114807987},
         6);

        std::srand(static_cast<unsigned int>(std::time(nullptr)));
    std::vector<int> vals;
    for (int i = 8; i < 100; i++) {
        const auto n =
            1 + std::rand() /
                    ((RAND_MAX + 5u) / 20);          auto windowSize =
            1 + std::rand() / ((RAND_MAX + 3u) /
                               10);          vals.clear();
        vals.reserve(n);
        for (int i = 0; i < n; i++) {
            vals.push_back(
                rand() - RAND_MAX);          }
        test(vals, windowSize);      }
    return 0;
}

#include <cmath>
#include <iostream>


double poisson_rate(double events, double timeframe) {
    return events / timeframe;
}


double poisson_expected(double rate, double time) { return rate * time; }


double fact(double x) {
    double x_fact = x;
    for (int i = x - 1; i > 0; i--) {
        x_fact *= i;
    }

    if (x_fact <= 0) {
        x_fact = 1;
    }
    return x_fact;
}


double poisson_x_successes(double expected, double x) {
    return (std::pow(expected, x) * std::exp(-expected)) / fact(x);
}


double poisson_range_successes(double expected, double lower, double upper) {
    double probability = 0;
    for (int i = lower; i <= upper; i++) {
        probability += poisson_x_successes(expected, i);
    }
    return probability;
}


int main() {
    double rate, expected;
    rate = poisson_rate(3, 1);
    std::cout << "Poisson rate : " << rate << std::endl;

    expected = poisson_expected(rate, 2);
    std::cout << "Poisson expected : " << expected << std::endl;

    std::cout << "Poisson 0 successes : " << poisson_x_successes(expected, 0)
              << std::endl;
    std::cout << "Poisson 0-8 successes : "
              << poisson_range_successes(expected, 0, 8) << std::endl;

    return 0;
}

#include <iostream>


double addition_rule_independent(double A, double B) {
    return (A + B) - (A * B);
}


double addition_rule_dependent(double A, double B, double B_given_A) {
    return (A + B) - (A * B_given_A);
}


int main() {
    double A = 0.5;
    double B = 0.25;
    double B_given_A = 0.05;

    std::cout << "independent P(A or B) = " << addition_rule_independent(A, B)
              << std::endl;

    std::cout << "dependent P(A or B) = "
              << addition_rule_dependent(A, B, B_given_A) << std::endl;

    return 0;
}

#include <iostream>


double bayes_AgivenB(double BgivenA, double A, double B) {
    return (BgivenA * A) / B;
}


double bayes_BgivenA(double AgivenB, double A, double B) {
    return (AgivenB * B) / A;
}


int main() {
    double A = 0.01;
    double B = 0.1;
    double BgivenA = 0.9;
    double AgivenB = bayes_AgivenB(BgivenA, A, B);
    std::cout << "A given B = " << AgivenB << std::endl;
    std::cout << "B given A = " << bayes_BgivenA(AgivenB, A, B) << std::endl;
    return 0;
}


#include <cassert>   #include <cmath>     #include <cstdint>   #include <ctime>     #include <iostream>  #include <limits>    #include <random>    #include <vector>    

namespace probability {

namespace geometric_dist {

float generate_uniform() {
    return static_cast<float>(rand()) / static_cast<float>(RAND_MAX);
}


class geometric_distribution {
 private:
    float p;  
 public:
    
    explicit geometric_distribution(const float& p) : p(p) {}

    
    float expected_value() const { return 1.0f / p; }

    
    float variance() const { return (1.0f - p) / (p * p); }

    
    float standard_deviation() const { return std::sqrt(variance()); }

    
    float probability_density(const uint32_t& k) const {
        return std::pow((1.0f - p), static_cast<float>(k - 1)) * p;
    }

    
    float cumulative_distribution(const uint32_t& k) const {
        return 1.0f - std::pow((1.0f - p), static_cast<float>(k));
    }

    
    float inverse_cumulative_distribution(const float& cdf) const {
        return std::log(1.0f - cdf) / std::log(1.0f - p);
    }

    
    uint32_t draw_sample() const {
        float uniform_sample = generate_uniform();
        return static_cast<uint32_t>(
                   inverse_cumulative_distribution(uniform_sample)) +
               1;
    }

    
    float range_tries(const uint32_t& min_tries = 1,
                      const uint32_t& max_tries =
                          std::numeric_limits<uint32_t>::max()) const {
        float cdf_lower = cumulative_distribution(min_tries - 1);
        float cdf_upper = max_tries == std::numeric_limits<uint32_t>::max()
                              ? 1.0f
                              : cumulative_distribution(max_tries);
        return cdf_upper - cdf_lower;
    }
};
}  }  

void sample_test(
    const probability::geometric_dist::geometric_distribution& dist) {
    uint32_t n_tries = 1000000;
    std::vector<float> tries;
    tries.resize(n_tries);

    float mean = 0.0f;
    for (uint32_t i = 0; i < n_tries; ++i) {
        tries[i] = static_cast<float>(dist.draw_sample());
        mean += tries[i];
    }

    mean /= static_cast<float>(n_tries);

    float var = 0.0f;
    for (uint32_t i = 0; i < n_tries; ++i) {
        var += (tries[i] - mean) * (tries[i] - mean);
    }

        var /= static_cast<float>(n_tries - 1);

    std::cout << "This value should be near " << dist.expected_value() << ": "
              << mean << std::endl;
    std::cout << "This value should be near " << dist.variance() << ": " << var
              << std::endl;
}


static void test() {
    probability::geometric_dist::geometric_distribution dist(0.3);

    const float threshold = 1e-3f;

    std::cout << "Starting tests for p = 0.3..." << std::endl;
    assert(std::abs(dist.expected_value() - 3.33333333f) < threshold);
    assert(std::abs(dist.variance() - 7.77777777f) < threshold);
    assert(std::abs(dist.standard_deviation() - 2.788866755) < threshold);
    assert(std::abs(dist.probability_density(5) - 0.07203) < threshold);
    assert(std::abs(dist.cumulative_distribution(6) - 0.882351) < threshold);
    assert(std::abs(dist.inverse_cumulative_distribution(
                        dist.cumulative_distribution(8)) -
                    8) < threshold);
    assert(std::abs(dist.range_tries() - 1.0f) < threshold);
    assert(std::abs(dist.range_tries(3) - 0.49f) < threshold);
    assert(std::abs(dist.range_tries(5, 11) - 0.2203267f) < threshold);
    std::cout << "All tests passed" << std::endl;
    sample_test(dist);

    dist = probability::geometric_dist::geometric_distribution(0.5f);

    std::cout << "Starting tests for p = 0.5..." << std::endl;
    assert(std::abs(dist.expected_value() - 2.0f) < threshold);
    assert(std::abs(dist.variance() - 2.0f) < threshold);
    assert(std::abs(dist.standard_deviation() - 1.4142135f) < threshold);
    assert(std::abs(dist.probability_density(5) - 0.03125) < threshold);
    assert(std::abs(dist.cumulative_distribution(6) - 0.984375) < threshold);
    assert(std::abs(dist.inverse_cumulative_distribution(
                        dist.cumulative_distribution(8)) -
                    8) < threshold);
    assert(std::abs(dist.range_tries() - 1.0f) < threshold);
    assert(std::abs(dist.range_tries(3) - 0.25f) < threshold);
    assert(std::abs(dist.range_tries(5, 11) - 0.062011f) < threshold);
    std::cout << "All tests passed" << std::endl;
    sample_test(dist);

    dist = probability::geometric_dist::geometric_distribution(0.8f);

    std::cout << "Starting tests for p = 0.8..." << std::endl;
    assert(std::abs(dist.expected_value() - 1.25f) < threshold);
    assert(std::abs(dist.variance() - 0.3125f) < threshold);
    assert(std::abs(dist.standard_deviation() - 0.559016f) < threshold);
    assert(std::abs(dist.probability_density(5) - 0.00128) < threshold);
    assert(std::abs(dist.cumulative_distribution(6) - 0.999936) < threshold);
    assert(std::abs(dist.inverse_cumulative_distribution(
                        dist.cumulative_distribution(8)) -
                    8) < threshold);
    assert(std::abs(dist.range_tries() - 1.0f) < threshold);
    assert(std::abs(dist.range_tries(3) - 0.04f) < threshold);
    assert(std::abs(dist.range_tries(5, 11) - 0.00159997f) < threshold);
    std::cout << "All tests have successfully passed!" << std::endl;
    sample_test(dist);
}


int main() {
    srand(time(nullptr));
    test();      return 0;
}

#include <cmath>
#include <iostream>


double binomial_expected(double n, double p) { return n * p; }


double binomial_variance(double n, double p) { return n * p * (1 - p); }


double binomial_standard_deviation(double n, double p) {
    return std::sqrt(binomial_variance(n, p));
}


double nCr(double n, double r) {
    double numerator = n;
    double denominator = r;

    for (int i = n - 1; i >= ((n - r) + 1); i--) {
        numerator *= i;
    }

    for (int i = 1; i < r; i++) {
        denominator *= i;
    }

    return numerator / denominator;
}


double binomial_x_successes(double n, double p, double x) {
    return nCr(n, x) * std::pow(p, x) * std::pow(1 - p, n - x);
}


double binomial_range_successes(double n, double p, double lower_bound,
                                double upper_bound) {
    double probability = 0;
    for (int i = lower_bound; i <= upper_bound; i++) {
        probability += nCr(n, i) * std::pow(p, i) * std::pow(1 - p, n - i);
    }
    return probability;
}


int main() {
    std::cout << "expected value : " << binomial_expected(100, 0.5)
              << std::endl;

    std::cout << "variance : " << binomial_variance(100, 0.5) << std::endl;

    std::cout << "standard deviation : "
              << binomial_standard_deviation(100, 0.5) << std::endl;

    std::cout << "exactly 30 successes : " << binomial_x_successes(100, 0.5, 30)
              << std::endl;

    std::cout << "45 or more successes : "
              << binomial_range_successes(100, 0.5, 45, 100) << std::endl;

    return 0;
}


#include <cassert>   #include <cstring>   #include <iostream>  #include <vector>    

namespace divide_and_conquer {

namespace karatsuba_algorithm {

std::string addStrings(std::string first, std::string second) {
    std::string result;  
    int64_t len1 = first.size();
    int64_t len2 = second.size();
    int64_t length = std::max(len1, len2);
    std::string zero = "0";
    if (len1 < len2)      {
        for (int64_t i = 0; i < len2 - len1; i++) {
            zero += first;
            first = zero;
        }
    } else if (len1 > len2) {
        zero = "0";
        for (int64_t i = 0; i < len1 - len2; i++) {
            zero += second;
            second = zero;
        }
    }
    int64_t carry = 0;
    for (int64_t i = length - 1; i >= 0; i--) {
        int64_t firstBit = first.at(i) - '0';
        int64_t secondBit = second.at(i) - '0';

        int64_t sum = (firstBit ^ secondBit ^ carry) + '0';          std::string temp;
        temp = std::to_string(sum);
        temp += result;
        result = temp;

        carry = (firstBit & secondBit) | (secondBit & carry) |
                (firstBit & carry);      }

    if (carry) {
        result = '1' + result;      }
    return result;
}

int64_t karatsuba_algorithm(std::string str1, std::string str2) {
    int64_t len1 = str1.size();
    int64_t len2 = str2.size();
    int64_t n = std::max(len1, len2);
    std::string zero = "0";
    if (len1 < len2) {
        for (int64_t i = 0; i < len2 - len1; i++) {
            zero += str1;
            str1 = zero;
        }
    } else if (len1 > len2) {
        zero = "0";
        for (int64_t i = 0; i < len1 - len2; i++) {
            zero += str2;
            str2 = zero;
        }
    }
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return (str1[0] - '0') * (str2[0] - '0');
    }
    int64_t fh = n / 2;         int64_t sh = (n - fh);  
    std::string Xl = str1.substr(0, fh);       std::string Xr = str1.substr(fh, sh);  
    std::string Yl = str2.substr(0, fh);       std::string Yr = str2.substr(fh, sh);  
        int64_t product1 = karatsuba_algorithm(Xl, Yl);
    int64_t product2 = karatsuba_algorithm(Xr, Yr);
    int64_t product3 = karatsuba_algorithm(
        divide_and_conquer::karatsuba_algorithm::addStrings(Xl, Xr),
        divide_and_conquer::karatsuba_algorithm::addStrings(Yl, Yr));

    return product1 * (1 << (2 * sh)) +
           (product3 - product1 - product2) * (1 << sh) +
           product2;  }
}  }  

static void test() {
        std::string s11 = "1";
    std::string s12 = "1010";
    std::cout << "1st test... ";
    assert(divide_and_conquer::karatsuba_algorithm::karatsuba_algorithm(
               s11, s12) == 10);      std::cout << "passed" << std::endl;

        std::string s21 = "11";
    std::string s22 = "1010";
    std::cout << "2nd test... ";
    assert(divide_and_conquer::karatsuba_algorithm::karatsuba_algorithm(
               s21, s22) == 30);      std::cout << "passed" << std::endl;

        std::string s31 = "110";
    std::string s32 = "1010";
    std::cout << "3rd test... ";
    assert(divide_and_conquer::karatsuba_algorithm::karatsuba_algorithm(
               s31, s32) == 60);      std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}


#include <algorithm>
#include <cassert>
#include <chrono>
#include <cmath>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <valarray>
#include <vector>

#include "vector_ops.hpp"  

namespace machine_learning {

namespace neural_network {

namespace activations {

double sigmoid(const double &x) { return 1.0 / (1.0 + std::exp(-x)); }


double dsigmoid(const double &x) { return x * (1 - x); }


double relu(const double &x) { return std::max(0.0, x); }


double drelu(const double &x) { return x >= 0.0 ? 1.0 : 0.0; }


double tanh(const double &x) { return 2 / (1 + std::exp(-2 * x)) - 1; }


double dtanh(const double &x) { return 1 - x * x; }
}  
namespace util_functions {

double square(const double &x) { return x * x; }

double identity_function(const double &x) { return x; }
}  
namespace layers {

class DenseLayer {
 public:
        double (*activation_function)(const double &);
    double (*dactivation_function)(const double &);
    int neurons;                 std::string activation;      std::vector<std::valarray<double>> kernel;  
    
    DenseLayer(const int &neurons, const std::string &activation,
               const std::pair<size_t, size_t> &kernel_shape,
               const bool &random_kernel) {
                if (activation == "sigmoid") {
            activation_function = neural_network::activations::sigmoid;
            dactivation_function = neural_network::activations::sigmoid;
        } else if (activation == "relu") {
            activation_function = neural_network::activations::relu;
            dactivation_function = neural_network::activations::drelu;
        } else if (activation == "tanh") {
            activation_function = neural_network::activations::tanh;
            dactivation_function = neural_network::activations::dtanh;
        } else if (activation == "none") {
                        activation_function =
                neural_network::util_functions::identity_function;
            dactivation_function =
                neural_network::util_functions::identity_function;
        } else {
                        std::cerr << "ERROR (" << __func__ << ") : ";
            std::cerr << "Invalid argument. Expected {none, sigmoid, relu, "
                         "tanh} got ";
            std::cerr << activation << std::endl;
            std::exit(EXIT_FAILURE);
        }
        this->activation = activation;          this->neurons = neurons;                        if (random_kernel) {
            uniform_random_initialization(kernel, kernel_shape, -1.0, 1.0);
        } else {
            unit_matrix_initialization(kernel, kernel_shape);
        }
    }
    
    DenseLayer(const int &neurons, const std::string &activation,
               const std::vector<std::valarray<double>> &kernel) {
                if (activation == "sigmoid") {
            activation_function = neural_network::activations::sigmoid;
            dactivation_function = neural_network::activations::sigmoid;
        } else if (activation == "relu") {
            activation_function = neural_network::activations::relu;
            dactivation_function = neural_network::activations::drelu;
        } else if (activation == "tanh") {
            activation_function = neural_network::activations::tanh;
            dactivation_function = neural_network::activations::dtanh;
        } else if (activation == "none") {
                        activation_function =
                neural_network::util_functions::identity_function;
            dactivation_function =
                neural_network::util_functions::identity_function;
        } else {
                        std::cerr << "ERROR (" << __func__ << ") : ";
            std::cerr << "Invalid argument. Expected {none, sigmoid, relu, "
                         "tanh} got ";
            std::cerr << activation << std::endl;
            std::exit(EXIT_FAILURE);
        }
        this->activation = activation;          this->neurons = neurons;                this->kernel = kernel;              }

    
    DenseLayer(const DenseLayer &layer) = default;

    
    ~DenseLayer() = default;

    
    DenseLayer &operator=(const DenseLayer &layer) = default;

    
    DenseLayer(DenseLayer &&) = default;

    
    DenseLayer &operator=(DenseLayer &&) = default;
};
}  
class NeuralNetwork {
 private:
    std::vector<neural_network::layers::DenseLayer> layers;      
    NeuralNetwork(
        const std::vector<std::pair<int, std::string>> &config,
        const std::vector<std::vector<std::valarray<double>>> &kernels) {
                if (config.begin()->second != "none") {
            std::cerr << "ERROR (" << __func__ << ") : ";
            std::cerr
                << "First layer can't have activation other than none got "
                << config.begin()->second;
            std::cerr << std::endl;
            std::exit(EXIT_FAILURE);
        }
                if (config.size() <= 1) {
            std::cerr << "ERROR (" << __func__ << ") : ";
            std::cerr << "Invalid size of network, ";
            std::cerr << "Atleast two layers are required";
            std::exit(EXIT_FAILURE);
        }
                for (size_t i = 0; i < config.size(); i++) {
            layers.emplace_back(neural_network::layers::DenseLayer(
                config[i].first, config[i].second, kernels[i]));
        }
        std::cout << "INFO: Network constructed successfully" << std::endl;
    }
    
    std::vector<std::vector<std::valarray<double>>>
    __detailed_single_prediction(const std::vector<std::valarray<double>> &X) {
        std::vector<std::vector<std::valarray<double>>> details;
        std::vector<std::valarray<double>> current_pass = X;
        details.emplace_back(X);
        for (const auto &l : layers) {
            current_pass = multiply(current_pass, l.kernel);
            current_pass = apply_function(current_pass, l.activation_function);
            details.emplace_back(current_pass);
        }
        return details;
    }

 public:
    
    NeuralNetwork() = default;

    
    explicit NeuralNetwork(
        const std::vector<std::pair<int, std::string>> &config) {
                if (config.begin()->second != "none") {
            std::cerr << "ERROR (" << __func__ << ") : ";
            std::cerr
                << "First layer can't have activation other than none got "
                << config.begin()->second;
            std::cerr << std::endl;
            std::exit(EXIT_FAILURE);
        }
                if (config.size() <= 1) {
            std::cerr << "ERROR (" << __func__ << ") : ";
            std::cerr << "Invalid size of network, ";
            std::cerr << "Atleast two layers are required";
            std::exit(EXIT_FAILURE);
        }
                        layers.push_back(neural_network::layers::DenseLayer(
            config[0].first, config[0].second,
            {config[0].first, config[0].first}, false));
                for (size_t i = 1; i < config.size(); i++) {
            layers.push_back(neural_network::layers::DenseLayer(
                config[i].first, config[i].second,
                {config[i - 1].first, config[i].first}, true));
        }
        std::cout << "INFO: Network constructed successfully" << std::endl;
    }

    
    NeuralNetwork(const NeuralNetwork &model) = default;

    
    ~NeuralNetwork() = default;

    
    NeuralNetwork &operator=(const NeuralNetwork &model) = default;

    
    NeuralNetwork(NeuralNetwork &&) = default;

    
    NeuralNetwork &operator=(NeuralNetwork &&) = default;

    
    std::pair<std::vector<std::vector<std::valarray<double>>>,
              std::vector<std::vector<std::valarray<double>>>>
    get_XY_from_csv(const std::string &file_name, const bool &last_label,
                    const bool &normalize, const int &slip_lines = 1) {
        std::ifstream in_file;                                  in_file.open(file_name.c_str(), std::ios::in);                  if (!in_file.is_open()) {
            std::cerr << "ERROR (" << __func__ << ") : ";
            std::cerr << "Unable to open file: " << file_name << std::endl;
            std::exit(EXIT_FAILURE);
        }
        std::vector<std::vector<std::valarray<double>>> X,
            Y;                     std::string line;                  for (int i = 0; i < slip_lines; i++) {
            std::getline(in_file, line, '\n');          }
                while (!in_file.eof() && std::getline(in_file, line, '\n')) {
            std::valarray<double> x_data,
                y_data;                              std::stringstream ss(line);              std::string token;              while (std::getline(ss, token, ',')) {                                  x_data = insert_element(x_data, std::stod(token));
            }
                        if (last_label) {
                y_data.resize(this->layers.back().neurons);
                                if (y_data.size() > 1) {
                    y_data[x_data[x_data.size() - 1]] = 1;
                }
                                else {
                    y_data[0] = x_data[x_data.size() - 1];
                }
                x_data = pop_back(x_data);              } else {
                y_data.resize(this->layers.back().neurons);
                                if (y_data.size() > 1) {
                    y_data[x_data[x_data.size() - 1]] = 1;
                }
                                else {
                    y_data[0] = x_data[x_data.size() - 1];
                }
                x_data = pop_front(x_data);              }
                        X.push_back({x_data});
            Y.push_back({y_data});
        }
                if (normalize) {
                        X = minmax_scaler(X, 0.01, 1.0);
        }
        in_file.close();                 return make_pair(X, Y);      }

    
    std::vector<std::valarray<double>> single_predict(
        const std::vector<std::valarray<double>> &X) {
                auto activations = this->__detailed_single_prediction(X);
                return activations.back();
    }

    
    std::vector<std::vector<std::valarray<double>>> batch_predict(
        const std::vector<std::vector<std::valarray<double>>> &X) {
                std::vector<std::vector<std::valarray<double>>> predicted_batch(
            X.size());
        for (size_t i = 0; i < X.size(); i++) {                          predicted_batch[i] = this->single_predict(X[i]);
        }
        return predicted_batch;      }

    
    void fit(const std::vector<std::vector<std::valarray<double>>> &X_,
             const std::vector<std::vector<std::valarray<double>>> &Y_,
             const int &epochs = 100, const double &learning_rate = 0.01,
             const size_t &batch_size = 32, const bool &shuffle = true) {
        std::vector<std::vector<std::valarray<double>>> X = X_, Y = Y_;
                if (X.size() != Y.size()) {
            std::cerr << "ERROR (" << __func__ << ") : ";
            std::cerr << "X and Y in fit have different sizes" << std::endl;
            std::exit(EXIT_FAILURE);
        }
        std::cout << "INFO: Training Started" << std::endl;
        for (int epoch = 1; epoch <= epochs; epoch++) {                          if (shuffle) {
                equal_shuffle(X, Y);
            }
            auto start =
                std::chrono::high_resolution_clock::now();              double loss = 0,
                   acc = 0;                          for (size_t batch_start = 0; batch_start < X.size();
                 batch_start += batch_size) {
                for (size_t i = batch_start;
                     i < std::min(X.size(), batch_start + batch_size); i++) {
                    std::vector<std::valarray<double>> grad, cur_error,
                        predicted;
                    auto activations = this->__detailed_single_prediction(X[i]);
                                                            std::vector<std::vector<std::valarray<double>>> gradients;
                    gradients.resize(this->layers.size());
                                        for (size_t i = 0; i < gradients.size(); i++) {
                        zeroes_initialization(
                            gradients[i], get_shape(this->layers[i].kernel));
                    }
                    predicted = activations.back();                      cur_error = predicted - Y[i];                                            loss += sum(apply_function(
                        cur_error, neural_network::util_functions::square));
                                        if (argmax(predicted) == argmax(Y[i])) {
                        acc += 1;
                    }
                                        for (size_t j = this->layers.size() - 1; j >= 1; j--) {
                                                cur_error = hadamard_product(
                            cur_error,
                            apply_function(
                                activations[j + 1],
                                this->layers[j].dactivation_function));
                                                grad = multiply(transpose(activations[j]), cur_error);
                                                cur_error = multiply(cur_error,
                                             transpose(this->layers[j].kernel));
                                                gradients[j] = gradients[j] + grad / double(batch_size);
                    }
                                        for (size_t j = this->layers.size() - 1; j >= 1; j--) {
                                                this->layers[j].kernel = this->layers[j].kernel -
                                                 gradients[j] * learning_rate;
                    }
                }
            }
            auto stop =
                std::chrono::high_resolution_clock::now();                          auto duration =
                std::chrono::duration_cast<std::chrono::microseconds>(stop -
                                                                      start);
            loss /= X.size();                    acc /= X.size();                     std::cout.precision(4);                          std::cout << "Training: Epoch " << epoch << '/' << epochs;
            std::cout << ", Loss: " << loss;
            std::cout << ", Accuracy: " << acc;
            std::cout << ", Taken time: " << duration.count() / 1e6
                      << " seconds";
            std::cout << std::endl;
        }
        return;
    }

    
    void fit_from_csv(const std::string &file_name, const bool &last_label,
                      const int &epochs, const double &learning_rate,
                      const bool &normalize, const int &slip_lines = 1,
                      const size_t &batch_size = 32,
                      const bool &shuffle = true) {
                auto data =
            this->get_XY_from_csv(file_name, last_label, normalize, slip_lines);
                this->fit(data.first, data.second, epochs, learning_rate, batch_size,
                  shuffle);
        return;
    }

    
    void evaluate(const std::vector<std::vector<std::valarray<double>>> &X,
                  const std::vector<std::vector<std::valarray<double>>> &Y) {
        std::cout << "INFO: Evaluation Started" << std::endl;
        double acc = 0, loss = 0;          for (size_t i = 0; i < X.size(); i++) {                          std::vector<std::valarray<double>> pred =
                this->single_predict(X[i]);
                        if (argmax(pred) == argmax(Y[i])) {
                acc += 1;              }
                        loss += sum(apply_function((Y[i] - pred),
                                       neural_network::util_functions::square) *
                        0.5);
        }
        acc /= X.size();           loss /= X.size();                  std::cout << "Evaluation: Loss: " << loss;
        std::cout << ", Accuracy: " << acc << std::endl;
        return;
    }

    
    void evaluate_from_csv(const std::string &file_name, const bool &last_label,
                           const bool &normalize, const int &slip_lines = 1) {
                auto data =
            this->get_XY_from_csv(file_name, last_label, normalize, slip_lines);
                this->evaluate(data.first, data.second);
        return;
    }

    
    void save_model(const std::string &_file_name) {
        std::string file_name = _file_name;
                if (file_name.find(".model") == file_name.npos) {
            file_name += ".model";
        }
        std::ofstream out_file;                  out_file.open(file_name.c_str(),
                      std::ofstream::out | std::ofstream::trunc);
                if (!out_file.is_open()) {
            std::cerr << "ERROR (" << __func__ << ") : ";
            std::cerr << "Unable to open file: " << file_name << std::endl;
            std::exit(EXIT_FAILURE);
        }
        
                out_file << layers.size();
        out_file << std::endl;
        for (const auto &layer : this->layers) {
            out_file << layer.neurons << ' ' << layer.activation << std::endl;
            const auto shape = get_shape(layer.kernel);
            out_file << shape.first << ' ' << shape.second << std::endl;
            for (const auto &row : layer.kernel) {
                for (const auto &val : row) {
                    out_file << val << ' ';
                }
                out_file << std::endl;
            }
        }
        std::cout << "INFO: Model saved successfully with name : ";
        std::cout << file_name << std::endl;
        out_file.close();          return;
    }

    
    NeuralNetwork load_model(const std::string &file_name) {
        std::ifstream in_file;                    in_file.open(file_name.c_str());                  if (!in_file.is_open()) {
            std::cerr << "ERROR (" << __func__ << ") : ";
            std::cerr << "Unable to open file: " << file_name << std::endl;
            std::exit(EXIT_FAILURE);
        }
        std::vector<std::pair<int, std::string>> config;          std::vector<std::vector<std::valarray<double>>>
            kernels;                  size_t total_layers = 0;
        in_file >> total_layers;
        for (size_t i = 0; i < total_layers; i++) {
            int neurons = 0;
            std::string activation;
            size_t shape_a = 0, shape_b = 0;
            std::vector<std::valarray<double>> kernel;
            in_file >> neurons >> activation >> shape_a >> shape_b;
            for (size_t r = 0; r < shape_a; r++) {
                std::valarray<double> row(shape_b);
                for (size_t c = 0; c < shape_b; c++) {
                    in_file >> row[c];
                }
                kernel.push_back(row);
            }
            config.emplace_back(make_pair(neurons, activation));
            ;
            kernels.emplace_back(kernel);
        }
        std::cout << "INFO: Model loaded successfully" << std::endl;
        in_file.close();          return NeuralNetwork(
            config, kernels);      }

    
    void summary() {
                std::cout
            << "==============================================================="
            << std::endl;
        std::cout << "\t\t+ MODEL SUMMARY +\t\t\n";
        std::cout
            << "==============================================================="
            << std::endl;
        for (size_t i = 1; i <= layers.size(); i++) {              std::cout << i << ")";
            std::cout << " Neurons : "
                      << layers[i - 1].neurons;              std::cout << ", Activation : "
                      << layers[i - 1].activation;              std::cout << ", kernel Shape : "
                      << get_shape(layers[i - 1].kernel);              std::cout << std::endl;
        }
        std::cout
            << "==============================================================="
            << std::endl;
        return;
    }
};
}  }  

static void test() {
        machine_learning::neural_network::NeuralNetwork myNN =
        machine_learning::neural_network::NeuralNetwork({
            {4, "none"},              {6,
             "relu"},              {3, "sigmoid"}                                      });
        myNN.summary();
        myNN.fit_from_csv("iris.csv", true, 100, 0.3, false, 2, 32, true);
        assert(machine_learning::argmax(
               myNN.single_predict({{5, 3.4, 1.6, 0.4}})) == 0);
    assert(machine_learning::argmax(
               myNN.single_predict({{6.4, 2.9, 4.3, 1.3}})) == 1);
    assert(machine_learning::argmax(
               myNN.single_predict({{6.2, 3.4, 5.4, 2.3}})) == 2);
    return;
}


int main() {
        test();
    return 0;
}

#include <cassert>
#include <cmath>    #include <iomanip>  #include <iostream>
#include <vector>


template <typename T>
std::ostream &operator<<(std::ostream &out,
                         std::vector<std::vector<T>> const &v) {
    const int width = 10;
    const char separator = ' ';

    for (size_t row = 0; row < v.size(); row++) {
        for (size_t col = 0; col < v[row].size(); col++) {
            out << std::left << std::setw(width) << std::setfill(separator)
                << v[row][col];
        }
        out << std::endl;
    }

    return out;
}


template <typename T>
std::ostream &operator<<(std::ostream &out, std::vector<T> const &v) {
    const int width = 15;
    const char separator = ' ';

    for (size_t row = 0; row < v.size(); row++) {
        out << std::left << std::setw(width) << std::setfill(separator)
            << v[row];
    }

    return out;
}


template <typename T>
inline bool is_square(std::vector<std::vector<T>> const &A) {
        size_t N = A.size();
    for (size_t i = 0; i < N; i++) {
        if (A[i].size() != N) {
            return false;
        }
    }
    return true;
}


template <typename T>
std::vector<std::vector<T>> operator*(std::vector<std::vector<T>> const &A,
                                      std::vector<std::vector<T>> const &B) {
        size_t N_A = A.size();
        size_t N_B = B[0].size();

    std::vector<std::vector<T>> result(N_A);

    if (A[0].size() != B.size()) {
        std::cerr << "Number of columns in A != Number of rows in B ("
                  << A[0].size() << ", " << B.size() << ")" << std::endl;
        return result;
    }

    for (size_t row = 0; row < N_A; row++) {
        std::vector<T> v(N_B);
        for (size_t col = 0; col < N_B; col++) {
            v[col] = static_cast<T>(0);
            for (size_t j = 0; j < B.size(); j++) {
                v[col] += A[row][j] * B[j][col];
            }
        }
        result[row] = v;
    }

    return result;
}


template <typename T>
std::vector<T> operator*(std::vector<std::vector<T>> const &A,
                         std::vector<T> const &B) {
        size_t N_A = A.size();

    std::vector<T> result(N_A);

    if (A[0].size() != B.size()) {
        std::cerr << "Number of columns in A != Number of rows in B ("
                  << A[0].size() << ", " << B.size() << ")" << std::endl;
        return result;
    }

    for (size_t row = 0; row < N_A; row++) {
        result[row] = static_cast<T>(0);
        for (size_t j = 0; j < B.size(); j++) result[row] += A[row][j] * B[j];
    }

    return result;
}


template <typename T>
std::vector<float> operator*(float const scalar, std::vector<T> const &A) {
        size_t N_A = A.size();

    std::vector<float> result(N_A);

    for (size_t row = 0; row < N_A; row++) {
        result[row] += A[row] * static_cast<float>(scalar);
    }

    return result;
}


template <typename T>
std::vector<float> operator*(std::vector<T> const &A, float const scalar) {
        size_t N_A = A.size();

    std::vector<float> result(N_A);

    for (size_t row = 0; row < N_A; row++) {
        result[row] = A[row] * static_cast<float>(scalar);
    }

    return result;
}


template <typename T>
std::vector<float> operator/(std::vector<T> const &A, float const scalar) {
    return (1.f / scalar) * A;
}


template <typename T>
std::vector<T> operator-(std::vector<T> const &A, std::vector<T> const &B) {
        size_t N = A.size();

    std::vector<T> result(N);

    if (B.size() != N) {
        std::cerr << "Vector dimensions shouldbe identical!" << std::endl;
        return A;
    }

    for (size_t row = 0; row < N; row++) result[row] = A[row] - B[row];

    return result;
}


template <typename T>
std::vector<T> operator+(std::vector<T> const &A, std::vector<T> const &B) {
        size_t N = A.size();

    std::vector<T> result(N);

    if (B.size() != N) {
        std::cerr << "Vector dimensions shouldbe identical!" << std::endl;
        return A;
    }

    for (size_t row = 0; row < N; row++) result[row] = A[row] + B[row];

    return result;
}


template <typename T>
std::vector<std::vector<float>> get_inverse(
    std::vector<std::vector<T>> const &A) {
        size_t N = A.size();

    std::vector<std::vector<float>> inverse(N);
    for (size_t row = 0; row < N; row++) {
                inverse[row] = std::vector<float>(N);
        for (size_t col = 0; col < N; col++) {
            inverse[row][col] = (row == col) ? 1.f : 0.f;
        }
    }

    if (!is_square(A)) {
        std::cerr << "A must be a square matrix!" << std::endl;
        return inverse;
    }

        std::vector<std::vector<float>> temp(N);
    for (size_t row = 0; row < N; row++) {
        std::vector<float> v(N);
        for (size_t col = 0; col < N; col++) {
            v[col] = static_cast<float>(A[row][col]);
        }
        temp[row] = v;
    }

        for (size_t row = 0; row < N; row++) {
        for (size_t row2 = row; row2 < N && temp[row][row] == 0; row2++) {
                        temp[row] = temp[row] + temp[row2];
            inverse[row] = inverse[row] + inverse[row2];
        }

        for (size_t col2 = row; col2 < N && temp[row][row] == 0; col2++) {
                        for (size_t row2 = 0; row2 < N; row2++) {
                temp[row2][row] = temp[row2][row] + temp[row2][col2];
                inverse[row2][row] = inverse[row2][row] + inverse[row2][col2];
            }
        }

        if (temp[row][row] == 0) {
                        std::cerr << "Low-rank matrix, no inverse!" << std::endl;
            return inverse;
        }

                auto divisor = static_cast<float>(temp[row][row]);
        temp[row] = temp[row] / divisor;
        inverse[row] = inverse[row] / divisor;
                for (size_t row2 = 0; row2 < N; row2++) {
            if (row2 == row) {
                continue;
            }
            float factor = temp[row2][row];
            temp[row2] = temp[row2] - factor * temp[row];
            inverse[row2] = inverse[row2] - factor * inverse[row];
        }
    }

    return inverse;
}


template <typename T>
std::vector<std::vector<T>> get_transpose(
    std::vector<std::vector<T>> const &A) {
    std::vector<std::vector<T>> result(A[0].size());

    for (size_t row = 0; row < A[0].size(); row++) {
        std::vector<T> v(A.size());
        for (size_t col = 0; col < A.size(); col++) v[col] = A[col][row];

        result[row] = v;
    }
    return result;
}


template <typename T>
std::vector<float> fit_OLS_regressor(std::vector<std::vector<T>> const &X,
                                     std::vector<T> const &Y) {
        std::vector<std::vector<T>> X2 = X;
    for (size_t i = 0; i < X2.size(); i++) {
                X2[i].push_back(1);
    }
        std::vector<std::vector<T>> Xt = get_transpose(X2);
        std::vector<std::vector<T>> tmp = get_inverse(Xt * X2);
        std::vector<std::vector<float>> out = tmp * Xt;
        
        return out * Y;
}


template <typename T>
std::vector<float> predict_OLS_regressor(std::vector<std::vector<T>> const &X,
                                         std::vector<float> const &beta 
) {
    std::vector<float> result(X.size());

    for (size_t rows = 0; rows < X.size(); rows++) {
                result[rows] = beta[X[0].size()];
        for (size_t cols = 0; cols < X[0].size(); cols++) {
            result[rows] += beta[cols] * X[rows][cols];
        }
    }
        return result;
}


void ols_test() {
    int F = 3, N = 5;

    std::cout << "Test 1 (quadratic function)....";
        std::vector<std::vector<float>> data1(
        {{-5, 25, -125}, {-1, 1, -1}, {0, 0, 0}, {1, 1, 1}, {6, 36, 216}});
        std::vector<float> Y1({20, -4, -5, -4, 31});
        std::vector<float> beta1 = fit_OLS_regressor(data1, Y1);
        std::vector<std::vector<float>> test_data1(
        {{-2, 4, -8}, {2, 4, 8}, {-10, 100, -1000}, {10, 100, 1000}});
        std::vector<float> expected1({-1, -1, 95, 95});
        std::vector<float> out1 = predict_OLS_regressor(test_data1, beta1);
        for (size_t rows = 0; rows < out1.size(); rows++) {
        assert(std::abs(out1[rows] - expected1[rows]) < 0.01);
    }
    std::cout << "passed\n";

    std::cout << "Test 2 (cubic function)....";
        std::vector<std::vector<float>> data2(
        {{-5, 25, -125}, {-1, 1, -1}, {0, 0, 0}, {1, 1, 1}, {6, 36, 216}});
        std::vector<float> Y2({-200, -100, -100, 98, 152});
        std::vector<float> beta2 = fit_OLS_regressor(data2, Y2);
        std::vector<std::vector<float>> test_data2(
        {{-2, 4, -8}, {2, 4, 8}, {-10, 100, -1000}, {10, 100, 1000}});
        std::vector<float> expected2({-104, -88, -1000, 1000});
        std::vector<float> out2 = predict_OLS_regressor(test_data2, beta2);
        for (size_t rows = 0; rows < out2.size(); rows++) {
        assert(std::abs(out2[rows] - expected2[rows]) < 0.01);
    }
    std::cout << "passed\n";

    std::cout << std::endl;                               }


int main() {
    ols_test();

    size_t N = 0, F = 0;

    std::cout << "Enter number of features: ";
        std::cin >> F;
    std::cout << "Enter number of samples: ";
        std::cin >> N;

    std::vector<std::vector<float>> data(N);
    std::vector<float> Y(N);

    std::cout
        << "Enter training data. Per sample, provide features and one output."
        << std::endl;

    for (size_t rows = 0; rows < N; rows++) {
        std::vector<float> v(F);
        std::cout << "Sample# " << rows + 1 << ": ";
        for (size_t cols = 0; cols < F; cols++) {
                        std::cin >> v[cols];
        }
        data[rows] = v;
                std::cin >> Y[rows];
    }

    std::vector<float> beta = fit_OLS_regressor(data, Y);
    std::cout << std::endl << std::endl << "beta:" << beta << std::endl;

    size_t T = 0;
    std::cout << "Enter number of test samples: ";
        std::cin >> T;
    std::vector<std::vector<float>> data2(T);
    
    for (size_t rows = 0; rows < T; rows++) {
        std::cout << "Sample# " << rows + 1 << ": ";
        std::vector<float> v(F);
        for (size_t cols = 0; cols < F; cols++) std::cin >> v[cols];
        data2[rows] = v;
    }

    std::vector<float> out = predict_OLS_regressor(data2, beta);
    for (size_t rows = 0; rows < T; rows++) std::cout << out[rows] << std::endl;

    return 0;
}

#define _USE_MATH_DEFINES  #include <algorithm>
#include <array>
#include <cerrno>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <fstream>
#include <iostream>
#include <valarray>
#include <vector>
#ifdef _OPENMP  #include <omp.h>
#endif


double _random(double a, double b) {
    return ((b - a) * (std::rand() % 100) / 100.f) + a;
}


int save_2d_data(const char *fname,
                 const std::vector<std::valarray<double>> &X) {
    size_t num_points = X.size();           size_t num_features = X[0].size();  
    std::ofstream fp;
    fp.open(fname);
    if (!fp.is_open()) {
                std::cerr << "Error opening file " << fname << ": "
                  << std::strerror(errno) << "\n";
        return -1;
    }

        for (int i = 0; i < num_points; i++) {
                for (int j = 0; j < num_features; j++) {
            fp << X[i][j];                           if (j < num_features - 1) {                  fp << ",";                           }
        }
        if (i < num_points - 1) {              fp << "\n";                    }
    }

    fp.close();
    return 0;
}


void get_min_2d(const std::vector<std::valarray<double>> &X, double *val,
                int *x_idx, int *y_idx) {
    val[0] = INFINITY;      size_t N = X.size();

    for (int i = 0; i < N; i++) {          auto result = std::min_element(std::begin(X[i]), std::end(X[i]));
        double d_min = *result;
        std::ptrdiff_t j = std::distance(std::begin(X[i]), result);

        if (d_min < val[0]) {                                             x_idx[0] = i;
            y_idx[0] = j;
            val[0] = d_min;
        }
    }
}


namespace machine_learning {

constexpr double MIN_DISTANCE = 1e-4;


int save_u_matrix(const char *fname,
                  const std::vector<std::vector<std::valarray<double>>> &W) {
    std::ofstream fp(fname);
    if (!fp) {          std::cerr << "File error (" << fname << "): " << std::strerror(errno)
                  << std::endl;
        return -1;
    }

        unsigned int R = 1;

    for (int i = 0; i < W.size(); i++) {                 for (int j = 0; j < W[0].size(); j++) {              double distance = 0.f;

            int from_x = std::max<int>(0, i - R);
            int to_x = std::min<int>(W.size(), i + R + 1);
            int from_y = std::max<int>(0, j - R);
            int to_y = std::min<int>(W[0].size(), j + R + 1);
            int l = 0, m = 0;
#ifdef _OPENMP
#pragma omp parallel for reduction(+ : distance)
#endif
            for (l = from_x; l < to_x; l++) {                      for (m = from_y; m < to_y; m++) {                      auto d = W[i][j] - W[l][m];
                    double d2 = std::pow(d, 2).sum();
                    distance += std::sqrt(d2);
                                    }
            }

            distance /= R * R;                      fp << distance;                         if (j < W[0].size() - 1) {                  fp << ',';                          }
        }
        if (i < W.size() - 1) {              fp << '\n';                  }
    }

    fp.close();
    return 0;
}


double update_weights(const std::valarray<double> &X,
                      std::vector<std::vector<std::valarray<double>>> *W,
                      std::vector<std::valarray<double>> *D, double alpha,
                      int R) {
    int x = 0, y = 0;
    int num_out_x = static_cast<int>(W->size());           int num_out_y = static_cast<int>(W[0][0].size());              double d_min = 0.f;

#ifdef _OPENMP
#pragma omp for
#endif
        for (x = 0; x < num_out_x; x++) {
        for (y = 0; y < num_out_y; y++) {
            (*D)[x][y] = 0.f;
                                    auto d = ((*W)[x][y] - X);
            (*D)[x][y] = (d * d).sum();
            (*D)[x][y] = std::sqrt((*D)[x][y]);
        }
    }

            int d_min_x = 0, d_min_y = 0;
    get_min_2d(*D, &d_min, &d_min_x, &d_min_y);

        int from_x = std::max(0, d_min_x - R);
    int to_x = std::min(num_out_x, d_min_x + R + 1);
    int from_y = std::max(0, d_min_y - R);
    int to_y = std::min(num_out_y, d_min_y + R + 1);

        #ifdef _OPENMP
#pragma omp for
#endif
    for (x = from_x; x < to_x; x++) {
        for (y = from_y; y < to_y; y++) {

            double d2 =
                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);
            double scale_factor = std::exp(-d2 / (2.f * alpha * alpha));

            (*W)[x][y] += (X - (*W)[x][y]) * alpha * scale_factor;
        }
    }
    return d_min;
}


void kohonen_som(const std::vector<std::valarray<double>> &X,
                 std::vector<std::vector<std::valarray<double>>> *W,
                 double alpha_min) {
    size_t num_samples = X.size();          size_t num_out = W->size();      size_t R = num_out >> 2, iter = 0;
    double alpha = 1.f;

    std::vector<std::valarray<double>> D(num_out);
    for (int i = 0; i < num_out; i++) D[i] = std::valarray<double>(num_out);

    double dmin = 1.f;            double past_dmin = 1.f;       double dmin_ratio = 1.f;  
        for (; alpha > 0 && dmin_ratio > 1e-5; alpha -= 1e-4, iter++) {
                for (int sample = 0; sample < num_samples; sample++) {
                        dmin += update_weights(X[sample], W, &D, alpha, R);
        }

                if (iter % 300 == 0 && R > 1) {
            R--;
        }

        dmin /= num_samples;

                dmin_ratio = (past_dmin - dmin) / past_dmin;
        if (dmin_ratio < 0) {
            dmin_ratio = 1.f;
        }
        past_dmin = dmin;

        std::cout << "iter: " << iter << "\t alpha: " << alpha << "\t R: " << R
                  << "\t d_min: " << dmin_ratio << "\r";
    }

    std::cout << "\n";
}

}  
using machine_learning::kohonen_som;
using machine_learning::save_u_matrix;




void test_2d_classes(std::vector<std::valarray<double>> *data) {
    const int N = data->size();
    const double R = 0.3;      int i = 0;
    const int num_classes = 4;
    std::array<std::array<double, 2>, num_classes> centres = {
                std::array<double, 2>({.5, .5}),           std::array<double, 2>({.5, -.5}),          std::array<double, 2>({-.5, .5}),          std::array<double, 2>({-.5, -.5})      };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++) {
                int cls = std::rand() % num_classes;

                data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);
        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);

    }
}


void test1() {
    int j = 0, N = 300;
    int features = 2;
    int num_out = 30;
    std::vector<std::valarray<double>> X(N);
    std::vector<std::vector<std::valarray<double>>> W(num_out);
    for (int i = 0; i < std::max(num_out, N); i++) {
                if (i < N) {              X[i] = std::valarray<double>(features);
        }
        if (i < num_out) {              W[i] = std::vector<std::valarray<double>>(num_out);
            for (int k = 0; k < num_out; k++) {
                W[i][k] = std::valarray<double>(features);
#ifdef _OPENMP
#pragma omp for
#endif
                for (j = 0; j < features; j++) {
                                        W[i][k][j] = _random(-10, 10);
                }
            }
        }
    }

    test_2d_classes(&X);      save_2d_data("test1.csv", X);      save_u_matrix("w11.csv", W);       kohonen_som(X, &W, 1e-4);          save_u_matrix("w12.csv", W);   }


void test_3d_classes1(std::vector<std::valarray<double>> *data) {
    const size_t N = data->size();
    const double R = 0.3;      int i = 0;
    const int num_classes = 4;
    const std::array<std::array<double, 3>, num_classes> centres = {
                std::array<double, 3>({.5, .5, .5}),            std::array<double, 3>({.5, -.5, -.5}),          std::array<double, 3>({-.5, .5, .5}),           std::array<double, 3>({-.5, -.5 - .5})      };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++) {
                int cls = std::rand() % num_classes;

                data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);
        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);
        data[0][i][2] = _random(centres[cls][2] - R, centres[cls][2] + R);

       
    }
}


void test2() {
    int j = 0, N = 300;
    int features = 3;
    int num_out = 30;
    std::vector<std::valarray<double>> X(N);
    std::vector<std::vector<std::valarray<double>>> W(num_out);
    for (int i = 0; i < std::max(num_out, N); i++) {
                if (i < N) {              X[i] = std::valarray<double>(features);
        }
        if (i < num_out) {              W[i] = std::vector<std::valarray<double>>(num_out);
            for (int k = 0; k < num_out; k++) {
                W[i][k] = std::valarray<double>(features);
#ifdef _OPENMP
#pragma omp for
#endif
                for (j = 0; j < features; j++) {
                                        W[i][k][j] = _random(-10, 10);
                }
            }
        }
    }

    test_3d_classes1(&X);      save_2d_data("test2.csv", X);      save_u_matrix("w21.csv", W);       kohonen_som(X, &W, 1e-4);          save_u_matrix("w22.csv", W);   }


void test_3d_classes2(std::vector<std::valarray<double>> *data) {
    const size_t N = data->size();
    const double R = 0.2;      int i = 0;
    const int num_classes = 8;
    const std::array<std::array<double, 3>, num_classes> centres = {
                std::array<double, 3>({.5, .5, .5}),            std::array<double, 3>({.5, .5, -.5}),           std::array<double, 3>({.5, -.5, .5}),           std::array<double, 3>({.5, -.5, -.5}),          std::array<double, 3>({-.5, .5, .5}),           std::array<double, 3>({-.5, .5, -.5}),          std::array<double, 3>({-.5, -.5, .5}),          std::array<double, 3>({-.5, -.5, -.5})      };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++) {
                int cls = std::rand() % num_classes;

                data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);
        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);
        data[0][i][2] = _random(centres[cls][2] - R, centres[cls][2] + R);

    }
}


void test3() {
    int j = 0, N = 500;
    int features = 3;
    int num_out = 30;
    std::vector<std::valarray<double>> X(N);
    std::vector<std::vector<std::valarray<double>>> W(num_out);
    for (int i = 0; i < std::max(num_out, N); i++) {
                if (i < N) {              X[i] = std::valarray<double>(features);
        }
        if (i < num_out) {              W[i] = std::vector<std::valarray<double>>(num_out);
            for (int k = 0; k < num_out; k++) {
                W[i][k] = std::valarray<double>(features);
#ifdef _OPENMP
#pragma omp for
#endif
                for (j = 0; j < features; j++) {
                                        W[i][k][j] = _random(-10, 10);
                }
            }
        }
    }

    test_3d_classes2(&X);      save_2d_data("test3.csv", X);      save_u_matrix("w31.csv", W);       kohonen_som(X, &W, 1e-4);          save_u_matrix("w32.csv", W);   }


double get_clock_diff(clock_t start_t, clock_t end_t) {
    return static_cast<double>(end_t - start_t) / CLOCKS_PER_SEC;
}


int main(int argc, char **argv) {
#ifdef _OPENMP
    std::cout << "Using OpenMP based parallelization\n";
#else
    std::cout << "NOT using OpenMP based parallelization\n";
#endif

    std::srand(std::time(nullptr));

    std::clock_t start_clk = std::clock();
    test1();
    auto end_clk = std::clock();
    std::cout << "Test 1 completed in " << get_clock_diff(start_clk, end_clk)
              << " sec\n";

    start_clk = std::clock();
    test2();
    end_clk = std::clock();
    std::cout << "Test 2 completed in " << get_clock_diff(start_clk, end_clk)
              << " sec\n";

    start_clk = std::clock();
    test3();
    end_clk = std::clock();
    std::cout << "Test 3 completed in " << get_clock_diff(start_clk, end_clk)
              << " sec\n";

    std::cout
        << "(Note: Calculated times include: creating test sets, training "
           "model and writing files to disk.)\n\n";
    return 0;
}

#define _USE_MATH_DEFINES  #include <algorithm>
#include <array>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <iostream>
#include <valarray>
#include <vector>
#ifdef _OPENMP  #include <omp.h>
#endif


double _random(double a, double b) {
    return ((b - a) * (std::rand() % 100) / 100.f) + a;
}


int save_nd_data(const char *fname,
                 const std::vector<std::valarray<double>> &X) {
    size_t num_points = X.size();           size_t num_features = X[0].size();  
    std::ofstream fp;
    fp.open(fname);
    if (!fp.is_open()) {
                std::cerr << "Error opening file " << fname << "\n";
        return -1;
    }

        for (int i = 0; i < num_points; i++) {
                for (int j = 0; j < num_features; j++) {
            fp << X[i][j];                           if (j < num_features - 1) {                  fp << ",";                           }
        }
        if (i < num_points - 1) {              fp << "\n";                    }
    }

    fp.close();
    return 0;
}


namespace machine_learning {


void update_weights(const std::valarray<double> &x,
                    std::vector<std::valarray<double>> *W,
                    std::valarray<double> *D, double alpha, int R) {
    int j = 0, k = 0;
    int num_out = W->size();      
#ifdef _OPENMP
#pragma omp for
#endif
        for (j = 0; j < num_out; j++) {
                        (*D)[j] = (((*W)[j] - x) * ((*W)[j] - x)).sum();
    }

            auto result = std::min_element(std::begin(*D), std::end(*D));
        int d_min_idx = std::distance(std::begin(*D), result);

        int from_node = std::max(0, d_min_idx - R);
    int to_node = std::min(num_out, d_min_idx + R + 1);

        #ifdef _OPENMP
#pragma omp for
#endif
    for (j = from_node; j < to_node; j++) {
                (*W)[j] += alpha * (x - (*W)[j]);
    }
}


void kohonen_som_tracer(const std::vector<std::valarray<double>> &X,
                        std::vector<std::valarray<double>> *W,
                        double alpha_min) {
    int num_samples = X.size();          int num_out = W->size();      int R = num_out >> 2, iter = 0;
    double alpha = 1.f;

    std::valarray<double> D(num_out);

        do {
                for (int sample = 0; sample < num_samples; sample++) {
                        update_weights(X[sample], W, &D, alpha, R);
        }

                if (iter % 10 == 0 && R > 1) {
            R--;
        }

        alpha -= 0.01;
        iter++;
    } while (alpha > alpha_min);
}

}  


using machine_learning::kohonen_som_tracer;


void test_circle(std::vector<std::valarray<double>> *data) {
    const int N = data->size();
    const double R = 0.75, dr = 0.3;
    double a_t = 0., b_t = 2.f * M_PI;      double a_r = R - dr, b_r = R + dr;      int i = 0;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++) {
        double r = _random(a_r, b_r);              double theta = _random(a_t, b_t);          data[0][i][0] = r * cos(theta);            data[0][i][1] = r * sin(theta);
    }
}


void test1() {
    int j = 0, N = 500;
    int features = 2;
    int num_out = 50;
    std::vector<std::valarray<double>> X(N);
    std::vector<std::valarray<double>> W(num_out);
    for (int i = 0; i < std::max(num_out, N); i++) {
                if (i < N) {              X[i] = std::valarray<double>(features);
        }
        if (i < num_out) {              W[i] = std::valarray<double>(features);

#ifdef _OPENMP
#pragma omp for
#endif
            for (j = 0; j < features; j++) {
                                W[i][j] = _random(-1, 1);
            }
        }
    }

    test_circle(&X);      save_nd_data("test1.csv", X);        save_nd_data("w11.csv", W);          kohonen_som_tracer(X, &W, 0.1);      save_nd_data("w12.csv", W);      }


void test_lamniscate(std::vector<std::valarray<double>> *data) {
    const int N = data->size();
    const double dr = 0.2;
    int i = 0;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++) {
        double dx = _random(-dr, dr);             double dy = _random(-dr, dr);             double theta = _random(0, M_PI);          data[0][i][0] = dx + cos(theta);          data[0][i][1] = dy + sin(2. * theta) / 2.f;
    }
}


void test2() {
    int j = 0, N = 500;
    int features = 2;
    int num_out = 20;
    std::vector<std::valarray<double>> X(N);
    std::vector<std::valarray<double>> W(num_out);
    for (int i = 0; i < std::max(num_out, N); i++) {
                if (i < N) {              X[i] = std::valarray<double>(features);
        }
        if (i < num_out) {              W[i] = std::valarray<double>(features);

#ifdef _OPENMP
#pragma omp for
#endif
            for (j = 0; j < features; j++) {
                                W[i][j] = _random(-1, 1);
            }
        }
    }

    test_lamniscate(&X);                  save_nd_data("test2.csv", X);         save_nd_data("w21.csv", W);           kohonen_som_tracer(X, &W, 0.01);      save_nd_data("w22.csv", W);       }


void test_3d_classes(std::vector<std::valarray<double>> *data) {
    const int N = data->size();
    const double R = 0.1;      int i = 0;
    const int num_classes = 8;
    const std::array<const std::array<double, 3>, num_classes> centres = {
                std::array<double, 3>({.5, .5, .5}),            std::array<double, 3>({.5, .5, -.5}),           std::array<double, 3>({.5, -.5, .5}),           std::array<double, 3>({.5, -.5, -.5}),          std::array<double, 3>({-.5, .5, .5}),           std::array<double, 3>({-.5, .5, -.5}),          std::array<double, 3>({-.5, -.5, .5}),          std::array<double, 3>({-.5, -.5, -.5})      };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++) {
        int cls =
            std::rand() % num_classes;  
                data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);
        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);
        data[0][i][2] = _random(centres[cls][2] - R, centres[cls][2] + R);

    }
}


void test3() {
    int j = 0, N = 200;
    int features = 3;
    int num_out = 20;
    std::vector<std::valarray<double>> X(N);
    std::vector<std::valarray<double>> W(num_out);
    for (int i = 0; i < std::max(num_out, N); i++) {
                if (i < N) {              X[i] = std::valarray<double>(features);
        }
        if (i < num_out) {              W[i] = std::valarray<double>(features);

#ifdef _OPENMP
#pragma omp for
#endif
            for (j = 0; j < features; j++) {
                                W[i][j] = _random(-1, 1);
            }
        }
    }

    test_3d_classes(&X);                  save_nd_data("test3.csv", X);         save_nd_data("w31.csv", W);           kohonen_som_tracer(X, &W, 0.01);      save_nd_data("w32.csv", W);       }


double get_clock_diff(clock_t start_t, clock_t end_t) {
    return static_cast<double>(end_t - start_t) / CLOCKS_PER_SEC;
}


int main(int argc, char **argv) {
#ifdef _OPENMP
    std::cout << "Using OpenMP based parallelization\n";
#else
    std::cout << "NOT using OpenMP based parallelization\n";
#endif

    std::srand(std::time(nullptr));

    std::clock_t start_clk = std::clock();
    test1();
    auto end_clk = std::clock();
    std::cout << "Test 1 completed in " << get_clock_diff(start_clk, end_clk)
              << " sec\n";

    start_clk = std::clock();
    test2();
    end_clk = std::clock();
    std::cout << "Test 2 completed in " << get_clock_diff(start_clk, end_clk)
              << " sec\n";

    start_clk = std::clock();
    test3();
    end_clk = std::clock();
    std::cout << "Test 3 completed in " << get_clock_diff(start_clk, end_clk)
              << " sec\n";

    std::cout
        << "(Note: Calculated times include: creating test sets, training "
           "model and writing files to disk.)\n\n";
    return 0;
}


#include <array>
#include <cassert>
#include <climits>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <numeric>
#include <vector>


constexpr int MAX_ITER = 500;  

namespace machine_learning {
class adaline {
 public:
    
    explicit adaline(int num_features, const double eta = 0.01f,
                     const double accuracy = 1e-5)
        : eta(eta), accuracy(accuracy) {
        if (eta <= 0) {
            std::cerr << "learning rate should be positive and nonzero"
                      << std::endl;
            std::exit(EXIT_FAILURE);
        }

        weights = std::vector<double>(
            num_features +
            1);  
                for (double &weight : weights) weight = 1.f;
            }

    
    friend std::ostream &operator<<(std::ostream &out, const adaline &ada) {
        out << "<";
        for (int i = 0; i < ada.weights.size(); i++) {
            out << ada.weights[i];
            if (i < ada.weights.size() - 1) {
                out << ", ";
            }
        }
        out << ">";
        return out;
    }

    
    int predict(const std::vector<double> &x, double *out = nullptr) {
        if (!check_size_match(x)) {
            return 0;
        }

        double y = weights.back();  
                y = std::inner_product(x.begin(), x.end(), weights.begin(), y);

        if (out != nullptr) {              *out = y;
        }

        return activation(y);      }

    
    double fit(const std::vector<double> &x, const int &y) {
        if (!check_size_match(x)) {
            return 0;
        }

        int p = predict(x);
        int prediction_error = y - p;          double correction_factor = eta * prediction_error;

        for (int i = 0; i < x.size(); i++) {
            weights[i] += correction_factor * x[i];
        }
        weights[x.size()] += correction_factor;  
        return correction_factor;
    }

    
    template <size_t N>
    void fit(std::array<std::vector<double>, N> const &X,
             std::array<int, N> const &Y) {
        double avg_pred_error = 1.f;

        int iter = 0;
        for (iter = 0; (iter < MAX_ITER) && (avg_pred_error > accuracy);
             iter++) {
            avg_pred_error = 0.f;

                        for (int i = 0; i < N; i++) {
                double err = fit(X[i], Y[i]);
                avg_pred_error += std::abs(err);
            }
            avg_pred_error /= N;

                                    std::cout << "\tIter " << iter << ": Training weights: " << *this
                      << "\tAvg error: " << avg_pred_error << std::endl;
        }

        if (iter < MAX_ITER) {
            std::cout << "Converged after " << iter << " iterations."
                      << std::endl;
        } else {
            std::cout << "Did not converge after " << iter << " iterations."
                      << std::endl;
        }
    }

    
    int activation(double x) { return x > 0 ? 1 : -1; }

 private:
    
    bool check_size_match(const std::vector<double> &x) {
        if (x.size() != (weights.size() - 1)) {
            std::cerr << __func__ << ": "
                      << "Number of features in x does not match the feature "
                         "dimension in model!"
                      << std::endl;
            return false;
        }
        return true;
    }

    const double eta;                 const double accuracy;            std::vector<double> weights;  };

}  
using machine_learning::adaline;




void test1(double eta = 0.01) {
    adaline ada(2, eta);  
    const int N = 10;  
    std::array<std::vector<double>, N> X = {
        std::vector<double>({0, 1}),   std::vector<double>({1, -2}),
        std::vector<double>({2, 3}),   std::vector<double>({3, -1}),
        std::vector<double>({4, 1}),   std::vector<double>({6, -5}),
        std::vector<double>({-7, -3}), std::vector<double>({-8, 5}),
        std::vector<double>({-9, 2}),  std::vector<double>({-10, -15})};
    std::array<int, N> y = {1,  -1, 1, -1, -1,
                            -1, 1,  1, 1,  -1};  
    std::cout << "------- Test 1 -------" << std::endl;
    std::cout << "Model before fit: " << ada << std::endl;

    ada.fit<N>(X, y);
    std::cout << "Model after fit: " << ada << std::endl;

    int predict = ada.predict({5, -3});
    std::cout << "Predict for x=(5,-3): " << predict;
    assert(predict == -1);
    std::cout << " ...passed" << std::endl;

    predict = ada.predict({5, 8});
    std::cout << "Predict for x=(5,8): " << predict;
    assert(predict == 1);
    std::cout << " ...passed" << std::endl;
}


void test2(double eta = 0.01) {
    adaline ada(2, eta);  
    const int N = 50;  
    std::array<std::vector<double>, N> X;
    std::array<int, N> Y{};  
            int range = 500;              int range2 = range >> 1;      for (int i = 0; i < N; i++) {
        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;
        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;
        X[i] = std::vector<double>({x0, x1});
        Y[i] = (x0 + 3. * x1) > -1 ? 1 : -1;
    }

    std::cout << "------- Test 2 -------" << std::endl;
    std::cout << "Model before fit: " << ada << std::endl;

    ada.fit(X, Y);
    std::cout << "Model after fit: " << ada << std::endl;

    int N_test_cases = 5;
    for (int i = 0; i < N_test_cases; i++) {
        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;
        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;

        int predict = ada.predict({x0, x1});

        std::cout << "Predict for x=(" << x0 << "," << x1 << "): " << predict;

        int expected_val = (x0 + 3. * x1) > -1 ? 1 : -1;
        assert(predict == expected_val);
        std::cout << " ...passed" << std::endl;
    }
}


void test3(double eta = 0.01) {
    adaline ada(6, eta);  
    const int N = 100;  
    std::array<std::vector<double>, N> X;
    std::array<int, N> Y{};  
            int range = 200;              int range2 = range >> 1;      for (int i = 0; i < N; i++) {
        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;
        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;
        double x2 = (static_cast<double>(std::rand() % range) - range2) / 100.f;
        X[i] = std::vector<double>({x0, x1, x2, x0 * x0, x1 * x1, x2 * x2});
        Y[i] = ((x0 * x0) + (x1 * x1) + (x2 * x2)) <= 1.f ? 1 : -1;
    }

    std::cout << "------- Test 3 -------" << std::endl;
    std::cout << "Model before fit: " << ada << std::endl;

    ada.fit(X, Y);
    std::cout << "Model after fit: " << ada << std::endl;

    int N_test_cases = 5;
    for (int i = 0; i < N_test_cases; i++) {
        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;
        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;
        double x2 = (static_cast<double>(std::rand() % range) - range2) / 100.f;

        int predict = ada.predict({x0, x1, x2, x0 * x0, x1 * x1, x2 * x2});

        std::cout << "Predict for x=(" << x0 << "," << x1 << "," << x2
                  << "): " << predict;

        int expected_val = ((x0 * x0) + (x1 * x1) + (x2 * x2)) <= 1.f ? 1 : -1;
        assert(predict == expected_val);
        std::cout << " ...passed" << std::endl;
    }
}


int main(int argc, char **argv) {
    std::srand(std::time(nullptr));  
    double eta = 0.1;      if (argc == 2) {           eta = strtof(argv[1], nullptr);
    }

    test1(eta);

    std::cout << "Press ENTER to continue..." << std::endl;
    std::cin.get();

    test2(eta);

    std::cout << "Press ENTER to continue..." << std::endl;
    std::cin.get();

    test3(eta);

    return 0;
}

#include <algorithm>   #include <array>       #include <cassert>     #include <functional>  #include <iostream>    #include <map>         #include <memory>      #include <set>         #include <vector>      
namespace machine_learning {

namespace aystar_search {

template <size_t N = 3>
class EightPuzzle {
    std::array<std::array<uint32_t, N>, N>
        board;  
    std::vector<std::pair<int8_t, int8_t>> moves = {
        {0, 1},
        {1, 0},
        {0, -1},
        {-1,
         0}};      
    std::pair<uint32_t, uint32_t> find_zero() {
        for (size_t i = 0; i < N; ++i) {
            for (size_t j = 0; j < N; ++j) {
                if (!board[i][j]) {
                    return {i, j};
                }
            }
        }
        return {-1, -1};
    }
    
    inline bool in_range(const uint32_t value) const { return value < N; }

 public:
    
    uint32_t get(size_t i, size_t j) const {
        if (in_range(i) && in_range(j)) {
            return board[i][j];
        }
        return -1;
    }
    
    std::array<std::array<uint32_t, N>, N> get_state() { return board; }

    
    inline size_t get_size() const { return N; }
    
    EightPuzzle() {
        for (size_t i = 0; i < N; ++i) {
            for (size_t j = 0; j < N; ++j) {
                board[i][j] = ((i * 3 + j + 1) % (N * N));
            }
        }
    }
    
    explicit EightPuzzle(const std::array<std::array<uint32_t, N>, N> &init)
        : board(init) {}

    
    EightPuzzle(const EightPuzzle<N> &A) : board(A.board) {}

    
    EightPuzzle(const EightPuzzle<N> &&A) noexcept
        : board(std::move(A.board)) {}
    
    ~EightPuzzle() = default;

    
    EightPuzzle &operator=(const EightPuzzle &A) {
        board = A.board;
        return *this;
    }

    
    EightPuzzle &operator=(EightPuzzle &&A) noexcept {
        board = std::move(A.board);
        return *this;
    }

    
    std::vector<EightPuzzle<N>> generate_possible_moves() {
        auto zero_pos = find_zero();
                std::vector<EightPuzzle<N>> NewStates;
        for (auto &move : moves) {
            if (in_range(zero_pos.first + move.first) &&
                in_range(zero_pos.second + move.second)) {
                                std::array<std::array<uint32_t, N>, N> new_config = board;
                std::swap(new_config[zero_pos.first][zero_pos.second],
                          new_config[zero_pos.first + move.first]
                                    [zero_pos.second + move.second]);
                EightPuzzle<N> new_state(new_config);
                                NewStates.emplace_back(new_state);
            }
        }
        return NewStates;
    }
    
    bool operator==(const EightPuzzle<N> &check) const {
        if (check.get_size() != N) {
            return false;
        }
        for (size_t i = 0; i < N; ++i) {
            for (size_t j = 0; j < N; ++j) {
                if (board[i][j] != check.board[i][j]) {
                    return false;
                }
            }
        }
        return true;
    }
    
    bool operator<(const EightPuzzle<N> &check) const {
        for (size_t i = 0; i < N; ++i) {
            for (size_t j = 0; j < N; ++j) {
                if (board[i][j] != check.board[i][j]) {
                    return board[i][j] < check.board[i][j];
                }
            }
        }
        return false;
    }
    
    bool operator<=(const EightPuzzle<N> &check) const {
        for (size_t i = 0; i < N; ++i) {
            for (size_t j = 0; j < N; ++j) {
                if (board[i][j] != check.board[i][j]) {
                    return board[i][j] < check.board[i][j];
                }
            }
        }
        return true;
    }

    
    friend std::ostream &operator<<(std::ostream &op,
                                    const EightPuzzle<N> &SomeState) {
        for (size_t i = 0; i < N; ++i) {
            for (size_t j = 0; j < N; ++j) {
                op << SomeState.board[i][j] << " ";
            }
            op << "\n";
        }
        return op;
    }
};

template <typename Puzzle>
class AyStarSearch {
    
    typedef struct Info {
        std::shared_ptr<Puzzle> state;          size_t heuristic_value = 0;             size_t depth = 0;               
        
        Info() = default;

        
        explicit Info(const Puzzle &A) : state(std::make_shared<Puzzle>(A)) {}

        
        Info(const Puzzle &A, size_t h_value, size_t d)
            : state(std::make_shared<Puzzle>(A)),
              heuristic_value(h_value),
              depth(d) {}

        
        Info(const Info &A)
            : state(std::make_shared<Puzzle>(A.state)),
              heuristic_value(A.heuristic_value),
              depth(A.depth) {}

        
        Info(const Info &&A) noexcept
            : state(std::make_shared<Puzzle>(std::move(A.state))),
              heuristic_value(std::move(A.heuristic_value)),
              depth(std::move(A.depth)) {}

        
        Info &operator=(const Info &A) {
            state = A.state;
            heuristic_value = A.heuristic_value;
            depth = A.depth;
            return *this;
        }

        
        Info &operator=(Info &&A) noexcept {
            state = std::move(A.state);
            heuristic_value = std::move(A.heuristic_value);
            depth = std::move(A.depth);
            return *this;
        }
        
        ~Info() = default;
    } Info;

    std::shared_ptr<Info> Initial;      std::shared_ptr<Info> Final;        
    struct comparison_operator {
        bool operator()(const std::shared_ptr<Info> &a,
                        const std::shared_ptr<Info> &b) const {
            return *(a->state) < *(b->state);
        }
    };

 public:
    using MapOfPuzzleInfoWithPuzzleInfo =
        std::map<std::shared_ptr<Info>, std::shared_ptr<Info>,
                 comparison_operator>;

    using MapOfPuzzleInfoWithInteger =
        std::map<std::shared_ptr<Info>, uint32_t, comparison_operator>;

    using SetOfPuzzleInfo =
        std::set<std::shared_ptr<Info>, comparison_operator>;
    
    AyStarSearch(const Puzzle &initial, const Puzzle &final) {
        Initial = std::make_shared<Info>(initial);
        Final = std::make_shared<Info>(final);
    }
    
    std::vector<Puzzle> Solution(
        std::shared_ptr<Info> FinalState,
        const MapOfPuzzleInfoWithPuzzleInfo &parent_of) {
                auto current_state = FinalState;
      
        std::vector<Puzzle> answer;
        while (current_state != nullptr) {
            answer.emplace_back(*current_state->state);
            current_state = parent_of.find(current_state)->second;
        }
        return answer;
    }
    
    std::vector<Puzzle> a_star_search(
        const std::function<uint32_t(const Puzzle &, const Puzzle &)> &dist,
        const uint32_t permissible_depth = 30) {
        MapOfPuzzleInfoWithPuzzleInfo
            parent_of;                               MapOfPuzzleInfoWithInteger g_score;          SetOfPuzzleInfo open_list;                   SetOfPuzzleInfo closed_list;  
                open_list.emplace(Initial);
        parent_of[Initial] = nullptr;
        g_score[Initial] = 0;

        while (!open_list.empty()) {
                        typename SetOfPuzzleInfo::iterator it_low_f_score;
            uint32_t min_f_score = 1e9;
            for (auto iter = open_list.begin(); iter != open_list.end();
                 ++iter) {
                                                uint32_t f_score = (*iter)->heuristic_value + (*iter)->depth;
                if (f_score < min_f_score) {
                    min_f_score = f_score;
                    it_low_f_score = iter;
                }
            }

                        std::shared_ptr<Info> current_state = *it_low_f_score;

                        if (*(current_state->state) == *(Final->state)) {
                return Solution(current_state, parent_of);
            }
                        open_list.erase(it_low_f_score);
                                    if (current_state->depth >= permissible_depth) {
                continue;
            }
                                    std::vector<Puzzle> total_possible_moves =
                current_state->state->generate_possible_moves();

            for (Puzzle &neighbor : total_possible_moves) {
                                                std::shared_ptr<Info> Neighbor = std::make_shared<Info>(
                    neighbor, dist(neighbor, *(Final->state)),
                    current_state->depth + 1U);
                uint32_t temp_g_score = Neighbor->depth;

                                                                auto closed_list_iter = closed_list.find(Neighbor);
                if (closed_list_iter != closed_list.end()) {
                                                                                if (Neighbor->depth < (*closed_list_iter)->depth) {
                        closed_list.erase(closed_list_iter);
                    } else {
                        continue;
                    }
                }
                auto neighbor_g_score_iter = g_score.find(Neighbor);
                                                if (neighbor_g_score_iter != g_score.end()) {
                    if (neighbor_g_score_iter->second > temp_g_score) {
                        neighbor_g_score_iter->second = temp_g_score;
                        parent_of[Neighbor] = current_state;
                    }
                } else {
                    g_score[Neighbor] = temp_g_score;
                    parent_of[Neighbor] = current_state;
                }
                                                                auto iter = open_list.find(Neighbor);
                if (iter == open_list.end()) {
                    open_list.emplace(Neighbor);
                } else if ((*iter)->depth > Neighbor->depth) {
                    (*iter)->depth = Neighbor->depth;
                }
            }
            closed_list.emplace(current_state);
        }
                return std::vector<Puzzle>(0);
    }
};
}  }  

static void test() {
        using matrix3 = std::array<std::array<uint32_t, 3>, 3>;
    using row3 = std::array<uint32_t, 3>;
    using matrix4 = std::array<std::array<uint32_t, 4>, 4>;
    using row4 = std::array<uint32_t, 4>;
        matrix3 puzzle;
    puzzle[0] = row3({0, 2, 3});
    puzzle[1] = row3({1, 5, 6});
    puzzle[2] = row3({4, 7, 8});

    matrix3 ideal;
    ideal[0] = row3({1, 2, 3});
    ideal[1] = row3({4, 5, 6});
    ideal[2] = row3({7, 8, 0});

    auto manhattan_distance =
        [](const machine_learning::aystar_search::EightPuzzle<> &first,
           const machine_learning::aystar_search::EightPuzzle<> &second) {
            uint32_t ret = 0;
            for (size_t i = 0; i < first.get_size(); ++i) {
                for (size_t j = 0; j < first.get_size(); ++j) {
                    uint32_t find = first.get(i, j);
                    size_t m = first.get_size(), n = first.get_size();
                    for (size_t k = 0; k < second.get_size(); ++k) {
                        for (size_t l = 0; l < second.get_size(); ++l) {
                            if (find == second.get(k, l)) {
                                std::tie(m, n) = std::make_pair(k, l);
                                break;
                            }
                        }
                        if (m != first.get_size()) {
                            break;
                        }
                    }
                    if (m != first.get_size()) {
                        ret += (std::max(m, i) - std::min(m, i)) +
                               (std::max(n, j) - std::min(n, j));
                    }
                }
            }
            return ret;
        };

    machine_learning::aystar_search::EightPuzzle<> Puzzle(puzzle);
    machine_learning::aystar_search::EightPuzzle<> Ideal(ideal);
    machine_learning::aystar_search::AyStarSearch<
        machine_learning::aystar_search::EightPuzzle<3>>
        search(Puzzle, Ideal);  
    std::vector<matrix3> answer;  
    answer.push_back(
        matrix3({row3({0, 2, 3}), row3({1, 5, 6}), row3({4, 7, 8})}));
    answer.push_back(
        matrix3({row3({1, 2, 3}), row3({0, 5, 6}), row3({4, 7, 8})}));
    answer.push_back(
        matrix3({row3({1, 2, 3}), row3({4, 5, 6}), row3({0, 7, 8})}));
    answer.push_back(
        matrix3({row3({1, 2, 3}), row3({4, 5, 6}), row3({7, 0, 8})}));
    answer.push_back(
        matrix3({row3({1, 2, 3}), row3({4, 5, 6}), row3({7, 8, 0})}));

    auto Solution = search.a_star_search(manhattan_distance);
    std::cout << Solution.size() << std::endl;

    assert(Solution.size() == answer.size());

    uint32_t i = 0;
    for (auto it = Solution.rbegin(); it != Solution.rend(); ++it) {
        assert(it->get_state() == answer[i]);
        ++i;
    }

            puzzle[0] = row3({5, 7, 3});
    puzzle[1] = row3({2, 0, 6});
    puzzle[2] = row3({1, 4, 8});
        ideal[0] = row3({1, 2, 3});
    ideal[1] = row3({4, 5, 6});
    ideal[2] = row3({7, 8, 0});

    Puzzle = machine_learning::aystar_search::EightPuzzle<>(puzzle);
    Ideal = machine_learning::aystar_search::EightPuzzle<>(ideal);

        search = machine_learning::aystar_search::AyStarSearch<
        machine_learning::aystar_search::EightPuzzle<3>>(Puzzle, Ideal);

    Solution = search.a_star_search(manhattan_distance);
    std::cout << Solution.size() << std::endl;
        assert(13 == Solution.size());
        assert(Solution[0].get_state() == ideal);
    for (auto it = Solution.rbegin(); it != Solution.rend(); ++it) {
        std::cout << *it << std::endl;
    }

            matrix4 puzzle2;
    puzzle2[0] = row4({10, 1, 6, 2});
    puzzle2[1] = row4({5, 8, 4, 3});
    puzzle2[2] = row4({13, 0, 7, 11});
    puzzle2[3] = row4({14, 9, 15, 12});
        matrix4 ideal2;
    ideal2[0] = row4({1, 2, 3, 4});
    ideal2[1] = row4({5, 6, 7, 8});
    ideal2[2] = row4({9, 10, 11, 12});
    ideal2[3] = row4({13, 14, 15, 0});

        machine_learning::aystar_search::EightPuzzle<4> Puzzle2(puzzle2),
        Ideal2(ideal2);
        machine_learning::aystar_search::AyStarSearch<
        machine_learning::aystar_search::EightPuzzle<4>>
        search2(Puzzle2, Ideal2);
    
    auto manhattan_distance2 =
        [](const machine_learning::aystar_search::EightPuzzle<4> &first,
           const machine_learning::aystar_search::EightPuzzle<4> &second) {
            uint32_t ret = 0;
            for (size_t i = 0; i < first.get_size(); ++i) {
                for (size_t j = 0; j < first.get_size(); ++j) {
                    uint32_t find = first.get(i, j);
                    size_t m = first.get_size(), n = first.get_size();
                    for (size_t k = 0; k < second.get_size(); ++k) {
                        for (size_t l = 0; l < second.get_size(); ++l) {
                            if (find == second.get(k, l)) {
                                std::tie(m, n) = std::make_pair(k, l);
                                break;
                            }
                        }
                        if (m != first.get_size()) {
                            break;
                        }
                    }
                    if (m != first.get_size()) {
                        ret += (std::max(m, i) - std::min(m, i)) +
                               (std::max(n, j) - std::min(n, j));
                    }
                }
            }
            return ret;
        };

    auto sol2 = search2.a_star_search(manhattan_distance2);
    std::cout << sol2.size() << std::endl;

        assert(24 == sol2.size());
        assert(sol2[0].get_state() == ideal2);

    for (auto it = sol2.rbegin(); it != sol2.rend(); ++it) {
        std::cout << *it << std::endl;
    }
}

int main() {
    test();      return 0;
}


#include <algorithm>      #include <cassert>        #include <cstdlib>        #include <ctime>          #include <iomanip>        #include <iostream>       #include <queue>          #include <unordered_set>  #include <vector>         
using std::cin;
using std::cout;
using std::endl;
using std::get;
using std::left;
using std::make_tuple;
using std::priority_queue;
using std::rand;
using std::srand;
using std::tuple;
using std::unordered_set;
using std::vector;

template <typename S, typename T, typename E>
bool sortcol(tuple<S, T, E>& t1, tuple<S, T, E>& t2) {
    if (get<1>(t1) < get<1>(t2)) {
        return true;
    } else if (get<1>(t1) == get<1>(t2) && get<0>(t1) < get<0>(t2)) {
        return true;
    }
    return false;
}


template <typename S, typename T, typename E>
class Compare {
 public:
    
    bool operator()(tuple<S, T, E, double, double, double>& t1,
                    tuple<S, T, E, double, double, double>& t2) {
                if (get<1>(t2) < get<1>(t1)) {
            return true;
        }
                else if (get<1>(t2) == get<1>(t1)) {
            return get<0>(t2) < get<0>(t1);
        }
        return false;
    }
};


template <typename S, typename T, typename E>
class FCFS {
    
    priority_queue<tuple<S, T, E, double, double, double>,
                   vector<tuple<S, T, E, double, double, double>>,
                   Compare<S, T, E>>
        schedule;

        vector<tuple<S, T, E, double, double, double>> result;

            unordered_set<S> idList;

 public:
    
    void addProcess(S id, T arrival, E burst) {
                if (idList.find(id) == idList.end()) {
            tuple<S, T, E, double, double, double> t =
                make_tuple(id, arrival, burst, 0, 0, 0);
            schedule.push(t);
            idList.insert(id);
        }
    }

    
    vector<tuple<S, T, E, double, double, double>> scheduleForFcfs() {
                double timeElapsed = 0;

        while (!schedule.empty()) {
            tuple<S, T, E, double, double, double> cur = schedule.top();

                                    if (get<1>(cur) > timeElapsed) {
                timeElapsed += get<1>(cur) - timeElapsed;
            }

                        timeElapsed += get<2>(cur);

                                    get<3>(cur) = timeElapsed;

                        get<4>(cur) = get<3>(cur) - get<1>(cur);

                        get<5>(cur) = get<4>(cur) - get<2>(cur);

            result.push_back(cur);
            schedule.pop();
        }
        return result;
    }

    
    void printResult() {
        cout << "Status of all the proceses post completion is as follows:"
             << endl;

        cout << std::setw(17) << left << "Process ID" << std::setw(17) << left
             << "Arrival Time" << std::setw(17) << left << "Burst Time"
             << std::setw(17) << left << "Completion Time" << std::setw(17)
             << left << "Turnaround Time" << std::setw(17) << left
             << "Waiting Time" << endl;

        for (size_t i{}; i < result.size(); i++) {
            cout << std::setprecision(2) << std::fixed << std::setw(17) << left
                 << get<0>(result[i]) << std::setw(17) << left
                 << get<1>(result[i]) << std::setw(17) << left
                 << get<2>(result[i]) << std::setw(17) << left
                 << get<3>(result[i]) << std::setw(17) << left
                 << get<4>(result[i]) << std::setw(17) << left
                 << get<5>(result[i]) << endl;
        }
    }
};


template <typename S, typename T, typename E>
vector<tuple<S, T, E, double, double, double>> get_final_status(
    vector<tuple<uint32_t, uint32_t, uint32_t>> input) {
    sort(input.begin(), input.end(), sortcol<S, T, E>);
    vector<tuple<S, T, E, double, double, double>> result(input.size());
    double timeElapsed = 0;
    for (size_t i{}; i < input.size(); i++) {
        T arrival = get<1>(input[i]);
        E burst = get<2>(input[i]);

        if (arrival > timeElapsed) {
            timeElapsed += arrival - timeElapsed;
        }
        timeElapsed += burst;
        double completion = timeElapsed;
        double turnaround = completion - arrival;
        double waiting = turnaround - burst;

        get<0>(result[i]) = get<0>(input[i]);
        get<1>(result[i]) = arrival;
        get<2>(result[i]) = burst;
        get<3>(result[i]) = completion;
        get<4>(result[i]) = turnaround;
        get<5>(result[i]) = waiting;
    }
    return result;
}


static void test() {
    for (int i{}; i < 1000; i++) {
        srand(time(nullptr));
        uint32_t n = 1 + rand() % 1000;
        FCFS<uint32_t, uint32_t, uint32_t> readyQueue;
        vector<tuple<uint32_t, uint32_t, uint32_t>> input(n);

        for (uint32_t i{}; i < n; i++) {
            get<0>(input[i]) = i;
            srand(time(nullptr));
            get<1>(input[i]) = 1 + rand() % 10000;
            srand(time(nullptr));
            get<2>(input[i]) = 1 + rand() % 10000;
        }

        for (uint32_t i{}; i < n; i++) {
            readyQueue.addProcess(get<0>(input[i]), get<1>(input[i]),
                                  get<2>(input[i]));
        }
        vector<tuple<uint32_t, uint32_t, uint32_t, double, double, double>>
            res = get_final_status<uint32_t, uint32_t, uint32_t>(input);
        assert(res == readyQueue.scheduleForFcfs());
            }
    cout << "All the tests have successfully passed!" << endl;
}


int main() {
    test();      return 0;
}


#include <cassert>  #include <cmath>    #include <cmath>
#include <cstdint>     #include <cstdlib>     #include <functional>  #include <iostream>    #include <map>         

namespace numerical_methods {

namespace simpson_method {

double evaluate_by_simpson(std::int32_t N, double h, double a,
                           const std::function<double(double)>& func) {
    std::map<std::int32_t, double>
        data_table;      double xi = a;   
        double temp = NAN;
    for (std::int32_t i = 0; i <= N; i++) {
        temp = func(xi);
        data_table.insert(
            std::pair<std::int32_t, double>(i, temp));          xi += h;      }

            double evaluate_integral = 0;
    for (std::int32_t i = 0; i <= N; i++) {
        if (i == 0 || i == N) {
            evaluate_integral += data_table.at(i);
        } else if (i % 2 == 1) {
            evaluate_integral += 4 * data_table.at(i);
        } else {
            evaluate_integral += 2 * data_table.at(i);
        }
    }

        evaluate_integral *= h / 3;

            assert(!std::isnan(evaluate_integral) &&
           "The definite integral can't be evaluated. Check the validity of "
           "your input.\n");
        return evaluate_integral;
}


double f(double x) { return std::sqrt(x) + std::log(x); }

double g(double x) { return std::exp(-x) * (4 - std::pow(x, 2)); }

double k(double x) { return std::sqrt(2 * std::pow(x, 3) + 3); }

double l(double x) { return x + std::log(2 * x + 1); }
}  }  

static void test(std::int32_t N, double h, double a, double b,
                 bool used_argv_parameters) {
        double result_f = numerical_methods::simpson_method::evaluate_by_simpson(
        N, h, a, numerical_methods::simpson_method::f);
    assert((used_argv_parameters || (result_f >= 4.09 && result_f <= 4.10)) &&
           "The result of f(x) is wrong");
    std::cout << "The result of integral f(x) on interval [" << a << ", " << b
              << "] is equal to: " << result_f << std::endl;

    double result_g = numerical_methods::simpson_method::evaluate_by_simpson(
        N, h, a, numerical_methods::simpson_method::g);
    assert((used_argv_parameters || (result_g >= 0.27 && result_g <= 0.28)) &&
           "The result of g(x) is wrong");
    std::cout << "The result of integral g(x) on interval [" << a << ", " << b
              << "] is equal to: " << result_g << std::endl;

    double result_k = numerical_methods::simpson_method::evaluate_by_simpson(
        N, h, a, numerical_methods::simpson_method::k);
    assert((used_argv_parameters || (result_k >= 9.06 && result_k <= 9.07)) &&
           "The result of k(x) is wrong");
    std::cout << "The result of integral k(x) on interval [" << a << ", " << b
              << "] is equal to: " << result_k << std::endl;

    double result_l = numerical_methods::simpson_method::evaluate_by_simpson(
        N, h, a, numerical_methods::simpson_method::l);
    assert((used_argv_parameters || (result_l >= 7.16 && result_l <= 7.17)) &&
           "The result of l(x) is wrong");
    std::cout << "The result of integral l(x) on interval [" << a << ", " << b
              << "] is equal to: " << result_l << std::endl;
}


int main(int argc, char** argv) {
    std::int32_t N = 16;                                double a = 1, b = 3;                                double h = NAN;       
    bool used_argv_parameters =
        false;                  
            if (argc == 4) {
        N = std::atoi(argv[1]);
        a = std::atof(argv[2]);
        b = std::atof(argv[3]);
                assert(a < b && "a has to be less than b");
        assert(N > 0 && "N has to be > 0");
        if (N < 16 || a != 1 || b != 3) {
            used_argv_parameters = true;
        }
        std::cout << "You selected N=" << N << ", a=" << a << ", b=" << b
                  << std::endl;
    } else {
        std::cout << "Default N=" << N << ", a=" << a << ", b=" << b
                  << std::endl;
    }

        h = (b - a) / N;

    test(N, h, a, b, used_argv_parameters);  
    return 0;
}

#define _USE_MATH_DEFINES  #include <cassert>
#include <cmath>
#include <functional>
#include <iostream>
#include <limits>

#define EPSILON 1e-7  

double get_minima(const std::function<double(double)> &f, double lim_a,
                  double lim_b) {
    uint32_t iters = 0;
    double c, d;
    double prev_mean, mean = std::numeric_limits<double>::infinity();

        const double M_GOLDEN_RATIO = (1.f + std::sqrt(5.f)) / 2.f;

        if (lim_a > lim_b) {
        std::swap(lim_a, lim_b);
    } else if (std::abs(lim_a - lim_b) <= EPSILON) {
        std::cerr << "Search range must be greater than " << EPSILON << "\n";
        return lim_a;
    }

    do {
        prev_mean = mean;

                double ratio = (lim_b - lim_a) / M_GOLDEN_RATIO;
        c = lim_b - ratio;          d = lim_a + ratio;  
        if (f(c) < f(d)) {
                        lim_b = d;
        } else {
                        lim_a = c;
        }

        mean = (lim_a + lim_b) / 2.f;
        iters++;

            } while (std::abs(lim_a - lim_b) > EPSILON);

    std::cout << " (iters: " << iters << ") ";
    return prev_mean;
}


void test1() {
        std::function<double(double)> f1 = [](double x) {
        return (x - 2) * (x - 2);
    };

    std::cout << "Test 1.... ";

    double minima = get_minima(f1, 1, 5);

    std::cout << minima << "...";

    assert(std::abs(minima - 2) < EPSILON);
    std::cout << "passed\n";
}


void test2() {
            std::function<double(double)> func = [](double x) {
        return -std::pow(x, 1.f / x);
    };

    std::cout << "Test 2.... ";

    double minima = get_minima(func, -2, 10);

    std::cout << minima << " (" << M_E << ")...";

    assert(std::abs(minima - M_E) < EPSILON);
    std::cout << "passed\n";
}


void test3() {
            std::function<double(double)> func = [](double x) { return std::cos(x); };

    std::cout << "Test 3.... ";

    double minima = get_minima(func, -4, 12);

    std::cout << minima << " (" << M_PI << ")...";

    assert(std::abs(minima - M_PI) < EPSILON);
    std::cout << "passed\n";
}


int main() {
    std::cout.precision(9);

    std::cout << "Computations performed with machine epsilon: " << EPSILON
              << "\n";

    test1();
    test2();
    test3();

    return 0;
}

#define _USE_MATH_DEFINES  #include <cassert>
#include <cmath>
#include <functional>
#include <iostream>
#include <limits>

#define EPSILON \
    std::sqrt(  \
        std::numeric_limits<double>::epsilon())  

double get_minima(const std::function<double(double)> &f, double lim_a,
                  double lim_b) {
    uint32_t iters = 0;

    if (lim_a > lim_b) {
        std::swap(lim_a, lim_b);
    } else if (std::abs(lim_a - lim_b) <= EPSILON) {
        std::cerr << "Search range must be greater than " << EPSILON << "\n";
        return lim_a;
    }

        const double M_GOLDEN_RATIO = (3.f - std::sqrt(5.f)) / 2.f;

    double v = lim_a + M_GOLDEN_RATIO * (lim_b - lim_a);
    double u, w = v, x = v;
    double fu, fv = f(v);
    double fw = fv, fx = fv;

    double mid_point = (lim_a + lim_b) / 2.f;
    double p = 0, q = 0, r = 0;

    double d, e = 0;
    double tolerance, tolerance2;

    do {
        mid_point = (lim_a + lim_b) / 2.f;
        tolerance = EPSILON * std::abs(x);
        tolerance2 = 2 * tolerance;

        if (std::abs(e) > tolerance2) {
                        r = (x - w) * (fx - fv);
            q = (x - v) * (fx - fw);
            p = (x - v) * q - (x - w) * r;
            q = 2.f * (q - r);
            if (q > 0)
                p = -p;
            else
                q = -q;
            r = e;
            e = d;
        }

        if (std::abs(p) < std::abs(0.5 * q * r) && p < q * (lim_b - x)) {
                        d = p / q;
            u = x + d;
            if (u - lim_a < tolerance2 || lim_b - u < tolerance2)
                d = x < mid_point ? tolerance : -tolerance;
        } else {
                        e = (x < mid_point ? lim_b : lim_a) - x;
            d = M_GOLDEN_RATIO * e;
        }

                if (std::abs(d) >= tolerance)
            u = d;
        else if (d > 0)
            u = tolerance;
        else
            u = -tolerance;
        u += x;
        fu = f(u);

                if (fu <= fx) {
            if (u < x)
                lim_b = x;
            else
                lim_a = x;
            v = w;
            fv = fw;
            w = x;
            fw = fx;
            x = u;
            fx = fu;
        } else {
            if (u < x)
                lim_a = u;
            else
                lim_b = u;
            if (fu <= fw || x == w) {
                v = w;
                fv = fw;
                w = u;
                fw = fu;
            } else if (fu <= fv || v == x || v == w) {
                v = u;
                fv = fu;
            }
        }

        iters++;
    } while (std::abs(x - mid_point) > (tolerance - (lim_b - lim_a) / 2.f));

    std::cout << " (iters: " << iters << ") ";

    return x;
}


void test1() {
        std::function<double(double)> f1 = [](double x) {
        return (x - 2) * (x - 2);
    };

    std::cout << "Test 1.... ";

    double minima = get_minima(f1, -1, 5);

    std::cout << minima << "...";

    assert(std::abs(minima - 2) < EPSILON);
    std::cout << "passed\n";
}


void test2() {
            std::function<double(double)> func = [](double x) {
        return -std::pow(x, 1.f / x);
    };

    std::cout << "Test 2.... ";

    double minima = get_minima(func, -2, 5);

    std::cout << minima << " (" << M_E << ")...";

    assert(std::abs(minima - M_E) < EPSILON);
    std::cout << "passed\n";
}


void test3() {
            std::function<double(double)> func = [](double x) { return std::cos(x); };

    std::cout << "Test 3.... ";

    double minima = get_minima(func, -4, 12);

    std::cout << minima << " (" << M_PI << ")...";

    assert(std::abs(minima - M_PI) < EPSILON);
    std::cout << "passed\n";
}


int main() {
    std::cout.precision(18);

    std::cout << "Computations performed with machine epsilon: " << EPSILON
              << "\n";

    test1();
    test2();
    test3();

    return 0;
}


#include <cassert>   #include <cmath>     #include <complex>   #include <iostream>  #include <vector>    

namespace numerical_methods {

std::complex<double> *InverseFastFourierTransform(std::complex<double> *p,
                                                  uint8_t n) {
    if (n == 1) {
        return p;      }

    double pi = 2 * asin(1.0);  
    std::complex<double> om = std::complex<double>(
        cos(2 * pi / n), sin(2 * pi / n));  
    om.real(om.real() / n);      om.imag(om.imag() / n);  
    auto *pe = new std::complex<double>[n / 2];  
    auto *po = new std::complex<double>[n / 2];  
    int k1 = 0, k2 = 0;
    for (int j = 0; j < n; j++) {
        if (j % 2 == 0) {
            pe[k1++] = p[j];  
        } else {
            po[k2++] = p[j];          }
    }

    std::complex<double> *ye =
        InverseFastFourierTransform(pe, n / 2);  
    std::complex<double> *yo =
        InverseFastFourierTransform(po, n / 2);  
    auto *y = new std::complex<double>[n];  
    k1 = 0, k2 = 0;

    for (int i = 0; i < n / 2; i++) {
        y[i] =
            ye[k1] + pow(om, i) * yo[k2];          y[i + n / 2] =
            ye[k1] - pow(om, i) * yo[k2];  
        k1++;
        k2++;
    }

    if (n != 2) {
        delete[] pe;
        delete[] po;
    }

    delete[] ye;      delete[] yo;      return y;
}

}  

static void test() {

    auto *t1 = new std::complex<double>[2];      auto *t2 = new std::complex<double>[4];  
    t1[0] = {3, 0};
    t1[1] = {-1, 0};
    t2[0] = {10, 0};
    t2[1] = {-2, -2};
    t2[2] = {-2, 0};
    t2[3] = {-2, 2};

    uint8_t n1 = 2;
    uint8_t n2 = 4;
    std::vector<std::complex<double>> r1 = {
        {1, 0}, {2, 0}};  
    std::vector<std::complex<double>> r2 = {
        {1, 0}, {2, 0}, {3, 0}, {4, 0}};  
    std::complex<double> *o1 =
        numerical_methods::InverseFastFourierTransform(t1, n1);

    std::complex<double> *o2 =
        numerical_methods::InverseFastFourierTransform(t2, n2);

    for (uint8_t i = 0; i < n1; i++) {
        assert((r1[i].real() - o1[i].real() < 0.000000000001) &&
               (r1[i].imag() - o1[i].imag() <
                0.000000000001));                                         }

    for (uint8_t i = 0; i < n2; i++) {
        assert((r2[i].real() - o2[i].real() < 0.000000000001) &&
               (r2[i].imag() - o2[i].imag() <
                0.000000000001));                                         }

    delete[] t1;
    delete[] t2;
    delete[] o1;
    delete[] o2;
    std::cout << "All tests have successfully passed!\n";
}



int main(int argc, char const *argv[]) {
    test();                   return 0;
}

#include <iostream>


int main() {
    int mat_size, i, j, step;

    std::cout << "Matrix size: ";
    std::cin >> mat_size;

        double **mat = new double *[mat_size + 1], **x = new double *[mat_size];
    for (i = 0; i <= mat_size; i++) {
        mat[i] = new double[mat_size + 1];
        if (i < mat_size)
            x[i] = new double[mat_size + 1];
    }

        std::cout << std::endl << "Enter value of the matrix: " << std::endl;
    for (i = 0; i < mat_size; i++) {
        for (j = 0; j <= mat_size; j++) {
            std::cin >>
                mat[i][j];          }
    }

        for (step = 0; step < mat_size - 1; step++) {
        for (i = step; i < mat_size - 1; i++) {
            double a = (mat[i + 1][step] / mat[step][step]);

            for (j = step; j <= mat_size; j++)
                mat[i + 1][j] = mat[i + 1][j] - (a * mat[step][j]);
        }
    }

    std::cout << std::endl
              << "Matrix using Gaussian Elimination method: " << std::endl;
    for (i = 0; i < mat_size; i++) {
        for (j = 0; j <= mat_size; j++) {
            x[i][j] = mat[i][j];
            std::cout << mat[i][j] << " ";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl
              << "Value of the Gaussian Elimination method: " << std::endl;
    for (i = mat_size - 1; i >= 0; i--) {
        double sum = 0;
        for (j = mat_size - 1; j > i; j--) {
            x[i][j] = x[j][j] * x[i][j];
            sum = x[i][j] + sum;
        }
        if (x[i][i] == 0)
            x[i][i] = 0;
        else
            x[i][i] = (x[i][mat_size] - sum) / (x[i][i]);

        std::cout << "x" << i << "= " << x[i][i] << std::endl;
    }

    for (i = 0; i <= mat_size; i++) {
        delete[] mat[i];
        if (i < mat_size)
            delete[] x[i];
    }
    delete[] mat;
    delete[] x;

    return 0;
}


#include <array>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <iostream>

#include "./qr_decompose.h"

using qr_algorithm::qr_decompose;
using qr_algorithm::operator<<;


int main(void) {
    unsigned int ROWS, COLUMNS;

    std::cout << "Enter the number of rows and columns: ";
    std::cin >> ROWS >> COLUMNS;

    std::cout << "Enter matrix elements row-wise:\n";

    std::valarray<std::valarray<double>> A(ROWS);
    std::valarray<std::valarray<double>> Q(ROWS);
    std::valarray<std::valarray<double>> R(COLUMNS);
    for (int i = 0; i < std::max(ROWS, COLUMNS); i++) {
        if (i < ROWS) {
            A[i] = std::valarray<double>(COLUMNS);
            Q[i] = std::valarray<double>(COLUMNS);
        }
        if (i < COLUMNS) {
            R[i] = std::valarray<double>(COLUMNS);
        }
    }

    for (int i = 0; i < ROWS; i++)
        for (int j = 0; j < COLUMNS; j++) std::cin >> A[i][j];

    std::cout << A << "\n";

    clock_t t1 = clock();
    qr_decompose(A, &Q, &R);
    double dtime = static_cast<double>(clock() - t1) / CLOCKS_PER_SEC;

    std::cout << Q << "\n";
    std::cout << R << "\n";
    std::cout << "Time taken to compute: " << dtime << " sec\n ";

    return 0;
}


#include <cmath>
#include <ctime>
#include <fstream>
#include <iostream>
#include <valarray>


void problem(const double &x, std::valarray<double> *y,
             std::valarray<double> *dy) {
    const double omega = 1.F;                 dy[0][0] = y[0][1];                       dy[0][1] = -omega * omega * y[0][0];  }


void exact_solution(const double &x, std::valarray<double> *y) {
    y[0][0] = std::cos(x);
    y[0][1] = -std::sin(x);
}



void midpoint_euler_step(const double dx, const double &x,
                         std::valarray<double> *y, std::valarray<double> *dy) {
    problem(x, y, dy);
    double tmp_x = x + 0.5 * dx;

    std::valarray<double> tmp_y = y[0] + dy[0] * (0.5 * dx);

    problem(tmp_x, &tmp_y, dy);

    y[0] += dy[0] * dx;
}


double midpoint_euler(double dx, double x0, double x_max,
                      std::valarray<double> *y, bool save_to_file = false) {
    std::valarray<double> dy = y[0];

    std::ofstream fp;
    if (save_to_file) {
        fp.open("midpoint_euler.csv", std::ofstream::out);
        if (!fp.is_open()) {
            std::perror("Error! ");
        }
    }

    std::size_t L = y->size();

    std::clock_t t1 = std::clock();
    double x = x0;
    do {          if (save_to_file && fp.is_open()) {
                        fp << x << ",";
            for (int i = 0; i < L - 1; i++) {
                fp << y[0][i] << ",";
            }
            fp << y[0][L - 1] << "\n";
        }

        midpoint_euler_step(dx, x, y, &dy);          x += dx;                                 } while (x <= x_max);     
    std::clock_t t2 = std::clock();

    if (fp.is_open())
        fp.close();

    return static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;
}




void save_exact_solution(const double &X0, const double &X_MAX,
                         const double &step_size,
                         const std::valarray<double> &Y0) {
    double x = X0;
    std::valarray<double> y = Y0;

    std::ofstream fp("exact.csv", std::ostream::out);
    if (!fp.is_open()) {
        std::perror("Error! ");
        return;
    }
    std::cout << "Finding exact solution\n";

    std::clock_t t1 = std::clock();
    do {
        fp << x << ",";
        for (int i = 0; i < y.size() - 1; i++) {
            fp << y[i] << ",";
        }
        fp << y[y.size() - 1] << "\n";

        exact_solution(x, &y);

        x += step_size;
    } while (x <= X_MAX);

    std::clock_t t2 = std::clock();
    double total_time = static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;
    std::cout << "\tTime = " << total_time << " ms\n";

    fp.close();
}


int main(int argc, char *argv[]) {
    double X0 = 0.f;                       
    double X_MAX = 10.F;                   
    std::valarray<double> Y0 = {1.f, 0.f}; 
    double step_size;

    if (argc == 1) {
        std::cout << "\nEnter the step size: ";
        std::cin >> step_size;
    } else {
                step_size = std::atof(argv[1]);
    }

        double total_time = midpoint_euler(step_size, X0, X_MAX, &Y0, true);
    std::cout << "\tTime = " << total_time << " ms\n";

    save_exact_solution(X0, X_MAX, step_size, Y0);

    return 0;
}

#include <cassert>   #include <iostream>  #include <vector>    

static double change(double x, double y) { return ((x - y) / 2.0); }


namespace numerical_methods {

namespace runge_kutta {

double rungeKutta(double init_x, const double &init_y, const double &x,
                  const double &h) {
            
            
    auto n = static_cast<uint64_t>((x - init_x) / h);
        std::vector<double> k(4, 0.0);

    
    double y = init_y;
    for (int i = 1; i <= n; ++i) {
                        k[0] = h * change(init_x, y);
        k[1] = h * change(init_x + 0.5 * h, y + 0.5 * k[0]);
        k[2] = h * change(init_x + 0.5 * h, y + 0.5 * k[1]);
        k[3] = h * change(init_x + h, y + k[2]);

        
        y += (1.0 / 6.0) * (k[0] + 2 * k[1] + 2 * k[2] + k[3]);

        
        init_x += h;
    }

    return y;
}
}  }  

static void test() {
    std::cout << "The Runge Kutta function will be tested on the basis of "
                 "precomputed values\n";

    std::cout << "Test 1...."
              << "\n";
    double valfirst = numerical_methods::runge_kutta::rungeKutta(
        2, 3, 4, 0.2);      assert(valfirst == 3.10363932323749570);
    std::cout << "Passed Test 1\n";

    std::cout << "Test 2...."
              << "\n";
    double valsec = numerical_methods::runge_kutta::rungeKutta(
        1, 2, 5, 0.1);      assert(valsec == 3.40600589380261409);
    std::cout << "Passed Test 2\n";

    std::cout << "Test 3...."
              << "\n";
    double valthird = numerical_methods::runge_kutta::rungeKutta(
        -1, 3, 4, 0.1);      assert(valthird == 2.49251005860244268);
    std::cout << "Passed Test 3\n";
}


int main() {
    test();      return 0;
}

#include <cmath>
#include <iostream>


static float eq(float y) { return (3 * y) - cos(y) - 2; }


static float eqd(float y) { return 0.5 * (cos(y) + 2); }


int main() {
    float y, x1, x2, x3, sum, s, a, f1, f2, gd;
    int i, n;

    for (i = 0; i < 10; i++) {
        sum = eq(y);
        std::cout << "value of equation at " << i << " " << sum << "\n";
        y++;
    }
    std::cout << "enter the x1->";
    std::cin >> x1;
    std::cout << "enter the no iteration to perform->\n";
    std::cin >> n;

    for (i = 0; i <= n; i++) {
        x2 = eqd(x1);
        std::cout << "\nenter the x2->" << x2;
        x1 = x2;
    }
    return 0;
}


#include <cassert>  #include <cmath>
#include <iostream>  


namespace numerical_methods {



double babylonian_method(double radicand) {
    int i = 1;  
    while (i * i <= radicand) {
        i++;
    }

    i--;  
    double x0 = i;      double x1 =
        (radicand / x0 + x0) / 2;      double temp = NAN;             
    while (std::max(x0, x1) - std::min(x0, x1) < 0.0001) {
        temp = (radicand / x1 + x1) / 2;          x0 = x1;
        x1 = temp;
    }

    return x1;  }

}  

static void test() {

    auto testcase1 = 125348;      auto testcase2 = 752080;  
    auto real_output1 = 354.045194855;      auto real_output2 = 867.225460881;  
    auto test_result1 = numerical_methods::babylonian_method(testcase1);
        auto test_result2 = numerical_methods::babylonian_method(testcase2);
    
    assert(std::max(test_result1, real_output1) -
               std::min(test_result1, real_output1) <
           0.0001);
        assert(std::max(test_result2, real_output2) -
               std::min(test_result2, real_output2) <
           0.0001);
    
    std::cout << "All tests have successfully passed!\n";
}



int main(int argc, char const *argv[]) {
    test();                   return 0;
}

#include <cassert>
#include <ctime>
#include <iomanip>
#include <iostream>

#include "./lu_decomposition.h"


template <typename T>
std::ostream &operator<<(std::ostream &out, matrix<T> const &v) {
    const int width = 10;
    const char separator = ' ';

    for (size_t row = 0; row < v.size(); row++) {
        for (size_t col = 0; col < v[row].size(); col++)
            out << std::left << std::setw(width) << std::setfill(separator)
                << v[row][col];
        out << std::endl;
    }

    return out;
}


void test1() {
    int mat_size = 3;      const int range = 50;
    const int range2 = range >> 1;

    matrix<double> A(mat_size, std::valarray<double>(mat_size));
    matrix<double> L(mat_size, std::valarray<double>(mat_size));      matrix<double> U(mat_size, std::valarray<double>(mat_size));      for (int i = 0; i < mat_size; i++) {
                for (int j = 0; j < mat_size; j++)
            A[i][j] = static_cast<double>(std::rand() % range - range2);
    }

    std::clock_t start_t = std::clock();
    lu_decomposition(A, &L, &U);
    std::clock_t end_t = std::clock();
    std::cout << "Time taken: "
              << static_cast<double>(end_t - start_t) / CLOCKS_PER_SEC << "\n";

    std::cout << "A = \n" << A << "\n";
    std::cout << "L = \n" << L << "\n";
    std::cout << "U = \n" << U << "\n";
}


void test2() {
    std::cout << "Determinant test 1...";
    matrix<int> A1({{1, 2, 3}, {4, 9, 6}, {7, 8, 9}});
    assert(determinant_lu(A1) == -48);
    std::cout << "passed\n";

    std::cout << "Determinant test 2...";
    matrix<int> A2({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});
    assert(determinant_lu(A2) == 0);
    std::cout << "passed\n";

    std::cout << "Determinant test 3...";
    matrix<float> A3({{1.2, 2.3, 3.4}, {4.5, 5.6, 6.7}, {7.8, 8.9, 9.0}});
    assert(determinant_lu(A3) == 3.63);
    std::cout << "passed\n";
}


int main(int argc, char **argv) {
    std::srand(std::time(NULL));  
    test1();
    test2();
    return 0;
}

#include <cassert>     #include <cmath>       #include <cstdint>     #include <cstdlib>     #include <functional>  #include <iostream>    #include <map>         

namespace numerical_methods {

namespace midpoint_rule {

double midpoint(const std::int32_t N, const double h, const double a,
                const std::function<double(double)>& func) {
    std::map<int, double>
        data_table;      double xi = a;   
            double temp = NAN;
    for (std::int32_t i = 0; i < N; i++) {
        temp = func(xi + h / 2);          data_table.insert(
            std::pair<std::int32_t, double>(i, temp));          xi += h;      }

            double evaluate_integral = 0;
    for (std::int32_t i = 0; i < N; i++) evaluate_integral += data_table.at(i);

        evaluate_integral *= h;

            assert(!std::isnan(evaluate_integral) &&
           "The definite integral can't be evaluated. Check the validity of "
           "your input.\n");
        return evaluate_integral;
}


double f(double x) { return std::sqrt(x) + std::log(x); }

double g(double x) { return std::exp(-x) * (4 - std::pow(x, 2)); }

double k(double x) { return std::sqrt(2 * std::pow(x, 3) + 3); }

double l(double x) { return x + std::log(2 * x + 1); }

}  }  

static void test(std::int32_t N, double h, double a, double b,
                 bool used_argv_parameters) {
            double result_f = numerical_methods::midpoint_rule::midpoint(
        N, h, a, numerical_methods::midpoint_rule::f);
    assert((used_argv_parameters || (result_f >= 4.09 && result_f <= 4.10)) &&
           "The result of f(x) is wrong");
    std::cout << "The result of integral f(x) on interval [" << a << ", " << b
              << "] is equal to: " << result_f << std::endl;

    double result_g = numerical_methods::midpoint_rule::midpoint(
        N, h, a, numerical_methods::midpoint_rule::g);
    assert((used_argv_parameters || (result_g >= 0.27 && result_g <= 0.28)) &&
           "The result of g(x) is wrong");
    std::cout << "The result of integral g(x) on interval [" << a << ", " << b
              << "] is equal to: " << result_g << std::endl;

    double result_k = numerical_methods::midpoint_rule::midpoint(
        N, h, a, numerical_methods::midpoint_rule::k);
    assert((used_argv_parameters || (result_k >= 9.06 && result_k <= 9.07)) &&
           "The result of k(x) is wrong");
    std::cout << "The result of integral k(x) on interval [" << a << ", " << b
              << "] is equal to: " << result_k << std::endl;

    double result_l = numerical_methods::midpoint_rule::midpoint(
        N, h, a, numerical_methods::midpoint_rule::l);
    assert((used_argv_parameters || (result_l >= 7.16 && result_l <= 7.17)) &&
           "The result of l(x) is wrong");
    std::cout << "The result of integral l(x) on interval [" << a << ", " << b
              << "] is equal to: " << result_l << std::endl;
}


int main(int argc, char** argv) {
    std::int32_t N =
        16;          double a = 1, b = 3;          double h = NAN;  
    bool used_argv_parameters =
        false;      
            if (argc == 4) {
        N = std::atoi(argv[1]);
        a = std::atof(argv[2]);
        b = std::atof(argv[3]);
                assert(a < b && "a has to be less than b");
        assert(N > 0 && "N has to be > 0");
        if (N < 4 || a != 1 || b != 3) {
            used_argv_parameters = true;
        }
        std::cout << "You selected N=" << N << ", a=" << a << ", b=" << b
                  << std::endl;
    } else {
        std::cout << "Default N=" << N << ", a=" << a << ", b=" << b
                  << std::endl;
    }

        h = (b - a) / N;

    test(N, h, a, b, used_argv_parameters);  
    return 0;
}

#include <cmath>     #include <iostream>  

namespace numerical_methods {

namespace false_position {

static float eq(float x) {
    return (x * x - x);  }


static float regula_falsi(float x1, float x2, float y1, float y2) {
    float diff = x1 - x2;
    if (diff < 0) {
        diff = (-1) * diff;
    }
    if (diff < 0.00001) {
        if (y1 < 0) {
            y1 = -y1;
        }
        if (y2 < 0) {
            y2 = -y2;
        }
        if (y1 < y2) {
            return x1;
        } else {
            return x2;
        }
    }
    float x3 = 0, y3 = 0;
    x3 = x1 - (x1 - x2) * (y1) / (y1 - y2);
    y3 = eq(x3);
    return regula_falsi(x2, x3, y2, y3);
}


void printRoot(float root, const int16_t &count) {
    if (count == 1) {
        std::cout << "Your 1st root is : " << root << std::endl;
    } else if (count == 2) {
        std::cout << "Your 2nd root is : " << root << std::endl;
    } else if (count == 3) {
        std::cout << "Your 3rd root is : " << root << std::endl;
    } else {
        std::cout << "Your " << count << "th root is : " << root << std::endl;
    }
}
}  }  

int main() {
    float a = 0, b = 0, i = 0, root = 0;
    int16_t count = 0;
    float range =
        100000;           float gap = 0.5;      a = numerical_methods::false_position::eq((-1) * range);
    i = ((-1) * range + gap);
            while (i <= range) {
        b = numerical_methods::false_position::eq(i);
        if (b == 0) {
            count++;
            numerical_methods::false_position::printRoot(i, count);
        }
        if (a * b < 0) {
            root = numerical_methods::false_position::regula_falsi(i - gap, i,
                                                                   a, b);
            count++;
            numerical_methods::false_position::printRoot(root, count);
        }
        a = b;
        i += gap;
    }
    return 0;
}


#include <cmath>
#include <ctime>
#include <fstream>
#include <iostream>
#include <valarray>


void problem(const double &x, std::valarray<double> *y,
             std::valarray<double> *dy) {
    const double omega = 1.F;                 dy[0][0] = y[0][1];                       dy[0][1] = -omega * omega * y[0][0];  }


void exact_solution(const double &x, std::valarray<double> *y) {
    y[0][0] = std::cos(x);
    y[0][1] = -std::sin(x);
}



void semi_implicit_euler_step(const double dx, const double &x,
                              std::valarray<double> *y,
                              std::valarray<double> *dy) {
    problem(x, y, dy);             y[0][0] += dx * dy[0][0];      problem(x, y, dy);         
    dy[0][0] = 0.f;          y[0] += dy[0] * dx;  }


double semi_implicit_euler(double dx, double x0, double x_max,
                           std::valarray<double> *y,
                           bool save_to_file = false) {
    std::valarray<double> dy = y[0];

    std::ofstream fp;
    if (save_to_file) {
        fp.open("semi_implicit_euler.csv", std::ofstream::out);
        if (!fp.is_open()) {
            std::perror("Error! ");
        }
    }

    std::size_t L = y->size();

    std::clock_t t1 = std::clock();
    double x = x0;
    do {          if (save_to_file && fp.is_open()) {
                        fp << x << ",";
            for (int i = 0; i < L - 1; i++) {
                fp << y[0][i] << ",";
            }
            fp << y[0][L - 1] << "\n";
        }

        semi_implicit_euler_step(dx, x, y, &dy);          x += dx;                                      } while (x <= x_max);
    std::clock_t t2 = std::clock();

    if (fp.is_open())
        fp.close();

    return static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;
}




void save_exact_solution(const double &X0, const double &X_MAX,
                         const double &step_size,
                         const std::valarray<double> &Y0) {
    double x = X0;
    std::valarray<double> y = Y0;

    std::ofstream fp("exact.csv", std::ostream::out);
    if (!fp.is_open()) {
        std::perror("Error! ");
        return;
    }
    std::cout << "Finding exact solution\n";

    std::clock_t t1 = std::clock();
    do {
        fp << x << ",";
        for (int i = 0; i < y.size() - 1; i++) {
            fp << y[i] << ",";
        }
        fp << y[y.size() - 1] << "\n";

        exact_solution(x, &y);

        x += step_size;
    } while (x <= X_MAX);

    std::clock_t t2 = std::clock();
    double total_time = static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;
    std::cout << "\tTime = " << total_time << " ms\n";

    fp.close();
}


int main(int argc, char *argv[]) {
    double X0 = 0.f;
    double X_MAX = 10.F;
    std::valarray<double> Y0 = {1.f, 0.f};
    double step_size;

    if (argc == 1) {
        std::cout << "\nEnter the step size: ";
        std::cin >> step_size;
    } else {
                step_size = std::atof(argv[1]);
    }

        double total_time = semi_implicit_euler(step_size, X0, X_MAX, &Y0, true);
    std::cout << "\tTime = " << total_time << " ms\n";

    save_exact_solution(X0, X_MAX, step_size, Y0);

    return 0;
}


#include <cmath>
#include <ctime>
#include <fstream>
#include <iostream>
#include <valarray>


void problem(const double &x, std::valarray<double> *y,
             std::valarray<double> *dy) {
    const double omega = 1.F;                 (*dy)[0] = (*y)[1];                       (*dy)[1] = -omega * omega * (*y)[0];  }


void exact_solution(const double &x, std::valarray<double> *y) {
    y[0][0] = std::cos(x);
    y[0][1] = -std::sin(x);
}



void forward_euler_step(const double dx, const double x,
                        std::valarray<double> *y, std::valarray<double> *dy) {
    problem(x, y, dy);
    *y += *dy * dx;
}


double forward_euler(double dx, double x0, double x_max,
                     std::valarray<double> *y, bool save_to_file = false) {
    std::valarray<double> dy = *y;

    std::ofstream fp;
    if (save_to_file) {
        fp.open("forward_euler.csv", std::ofstream::out);
        if (!fp.is_open()) {
            std::perror("Error! ");
        }
    }

    std::size_t L = y->size();

    std::clock_t t1 = std::clock();
    double x = x0;

    do {          if (save_to_file && fp.is_open()) {
                        fp << x << ",";
            for (int i = 0; i < L - 1; i++) {
                fp << y[0][i] << ",";              }
            fp << y[0][L - 1] << "\n";          }

        forward_euler_step(dx, x, y, &dy);          x += dx;                                } while (x <= x_max);      
    std::clock_t t2 = std::clock();

    if (fp.is_open()) {
        fp.close();
    }

    return static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;
}




void save_exact_solution(const double &X0, const double &X_MAX,
                         const double &step_size,
                         const std::valarray<double> &Y0) {
    double x = X0;
    std::valarray<double> y(Y0);

    std::ofstream fp("exact.csv", std::ostream::out);
    if (!fp.is_open()) {
        std::perror("Error! ");
        return;
    }
    std::cout << "Finding exact solution\n";

    std::clock_t t1 = std::clock();
    do {
        fp << x << ",";
        for (int i = 0; i < y.size() - 1; i++) {
            fp << y[i] << ",";          }
        fp << y[y.size() - 1] << "\n";  
        exact_solution(x, &y);

        x += step_size;
    } while (x <= X_MAX);

    std::clock_t t2 = std::clock();
    double total_time = static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;
    std::cout << "\tTime = " << total_time << " ms\n";

    fp.close();
}


int main(int argc, char *argv[]) {
    double X0 = 0.f;
    double X_MAX = 10.F;
    std::valarray<double> Y0{1.f, 0.f};
    double step_size = NAN;

    if (argc == 1) {
        std::cout << "\nEnter the step size: ";
        std::cin >> step_size;
    } else {
                step_size = std::atof(argv[1]);
    }

        double total_time = forward_euler(step_size, X0, X_MAX, &Y0, true);
    std::cout << "\tTime = " << total_time << " ms\n";

    save_exact_solution(X0, X_MAX, step_size, Y0);

    return 0;
}


#include <algorithm>
#include <cassert>
#include <cmath>
#include <complex>
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <iostream>
#include <valarray>
#ifdef _OPENMP
#include <omp.h>
#endif

#define ACCURACY 1e-10 


std::complex<double> poly_function(const std::valarray<double> &coeffs,
                                   std::complex<double> x) {
    double real = 0.f, imag = 0.f;
    int n;

                for (n = 0; n < coeffs.size(); n++) {
        std::complex<double> tmp =
            coeffs[n] * std::pow(x, coeffs.size() - n - 1);
        real += tmp.real();
        imag += tmp.imag();
    }

    return std::complex<double>(real, imag);
}


const char *complex_str(const std::complex<double> &x) {
#define MAX_BUFF_SIZE 50
    static char msg[MAX_BUFF_SIZE];

    std::snprintf(msg, MAX_BUFF_SIZE, "% 7.04g%+7.04gj", x.real(), x.imag());

    return msg;
}


bool check_termination(long double delta) {
    static long double past_delta = INFINITY;
    if (std::abs(past_delta - delta) <= ACCURACY || delta < ACCURACY)
        return true;
    past_delta = delta;
    return false;
}


std::pair<uint32_t, double> durand_kerner_algo(
    const std::valarray<double> &coeffs,
    std::valarray<std::complex<double>> *roots, bool write_log = false) {
    long double tol_condition = 1;
    uint32_t iter = 0;
    int n;
    std::ofstream log_file;

    if (write_log) {

        log_file.open("durand_kerner.log.csv");
        if (!log_file.is_open()) {
            perror("Unable to create a storage log file!");
            std::exit(EXIT_FAILURE);
        }
        log_file << "iter#,";

        for (n = 0; n < roots->size(); n++) log_file << "root_" << n << ",";

        log_file << "avg. correction";
        log_file << "\n0,";
        for (n = 0; n < roots->size(); n++)
            log_file << complex_str((*roots)[n]) << ",";
    }

    bool break_loop = false;
    while (!check_termination(tol_condition) && iter < INT16_MAX &&
           !break_loop) {
        tol_condition = 0;
        iter++;
        break_loop = false;

        if (log_file.is_open())
            log_file << "\n" << iter << ",";

#ifdef _OPENMP
#pragma omp parallel for shared(break_loop, tol_condition)
#endif
        for (n = 0; n < roots->size(); n++) {
            if (break_loop)
                continue;

            std::complex<double> numerator, denominator;
            numerator = poly_function(coeffs, (*roots)[n]);
            denominator = 1.0;
            for (int i = 0; i < roots->size(); i++)
                if (i != n)
                    denominator *= (*roots)[n] - (*roots)[i];

            std::complex<long double> delta = numerator / denominator;

            if (std::isnan(std::abs(delta)) || std::isinf(std::abs(delta))) {
                std::cerr << "\n\nOverflow/underrun error - got value = "
                          << std::abs(delta) << "\n";
                                break_loop = true;
            }

            (*roots)[n] -= delta;

#ifdef _OPENMP
#pragma omp critical
#endif
            tol_condition = std::max(tol_condition, std::abs(std::abs(delta)));
        }
        
        if (break_loop)
            break;

        if (log_file.is_open()) {
            for (n = 0; n < roots->size(); n++)
                log_file << complex_str((*roots)[n]) << ",";
        }

#if defined(DEBUG) || !defined(NDEBUG)
        if (iter % 500 == 0) {
            std::cout << "Iter: " << iter << "\t";
            for (n = 0; n < roots->size(); n++)
                std::cout << "\t" << complex_str((*roots)[n]);
            std::cout << "\t\tabsolute average change: " << tol_condition
                      << "\n";
        }
#endif

        if (log_file.is_open())
            log_file << tol_condition;
    }

    return std::pair<uint32_t, long double>(iter, tol_condition);
}


void test1() {
    const std::valarray<double> coeffs = {1, 0, 4};      std::valarray<std::complex<double>> roots(2);
    std::valarray<std::complex<double>> expected = {
        std::complex<double>(0., 2.),
        std::complex<double>(0., -2.)      };

    for (int n = 0; n < roots.size(); n++) {
        roots[n] = std::complex<double>(std::rand() % 100, std::rand() % 100);
        roots[n] -= 50.f;
        roots[n] /= 25.f;
    }

    auto result = durand_kerner_algo(coeffs, &roots, false);

    for (int i = 0; i < roots.size(); i++) {
                        bool err1 = false;
        for (int j = 0; j < roots.size(); j++)
            err1 |= std::abs(std::abs(roots[i] - expected[j])) < 1e-3;
        assert(err1);
    }

    std::cout << "Test 1 passed! - " << result.first << " iterations, "
              << result.second << " accuracy"
              << "\n";
}


void test2() {
    const std::valarray<double> coeffs = {                                          1. / 64., 0., 0., -1.};
    std::valarray<std::complex<double>> roots(3);
    const std::valarray<std::complex<double>> expected = {
        std::complex<double>(4., 0.), std::complex<double>(-2., 3.46410162),
        std::complex<double>(-2., -3.46410162)      };

    for (int n = 0; n < roots.size(); n++) {
        roots[n] = std::complex<double>(std::rand() % 100, std::rand() % 100);
        roots[n] -= 50.f;
        roots[n] /= 25.f;
    }

    auto result = durand_kerner_algo(coeffs, &roots, false);

    for (int i = 0; i < roots.size(); i++) {
                        bool err1 = false;
        for (int j = 0; j < roots.size(); j++)
            err1 |= std::abs(std::abs(roots[i] - expected[j])) < 1e-3;
        assert(err1);
    }

    std::cout << "Test 2 passed! - " << result.first << " iterations, "
              << result.second << " accuracy"
              << "\n";
}


int main(int argc, char **argv) {
    std::srand(std::time(nullptr));

    if (argc < 2) {
        test1();          test2();          std::cout << "Please pass the coefficients of the polynomial as "
                     "commandline "
                     "arguments.\n";
        return 0;
    }

    int n, degree = argc - 1;                  std::valarray<double> coeffs(degree);  
        std::valarray<std::complex<double>> s0(degree - 1);

    std::cout << "Computing the roots for:\n\t";
    for (n = 0; n < degree; n++) {
        coeffs[n] = strtod(argv[n + 1], nullptr);
        if (n < degree - 1 && coeffs[n] != 0)
            std::cout << "(" << coeffs[n] << ") x^" << degree - n - 1 << " + ";
        else if (coeffs[n] != 0)
            std::cout << "(" << coeffs[n] << ") x^" << degree - n - 1
                      << " = 0\n";

        if (n < degree - 1) {
            s0[n] = std::complex<double>(std::rand() % 100, std::rand() % 100);
            s0[n] -= 50.f;
            s0[n] /= 50.f;
        }
    }

            {
        double tmp = coeffs[0];
        coeffs /= tmp;
    }

    clock_t end_time, start_time = clock();
    auto result = durand_kerner_algo(coeffs, &s0, true);
    end_time = clock();

    std::cout << "\nIterations: " << result.first << "\n";
    for (n = 0; n < degree - 1; n++)
        std::cout << "\t" << complex_str(s0[n]) << "\n";
    std::cout << "absolute average change: " << result.second << "\n";
    std::cout << "Time taken: "
              << static_cast<double>(end_time - start_time) / CLOCKS_PER_SEC
              << " sec\n";

    return 0;
}

#include <cmath>
#include <iostream>
#include <limits>

#define EPSILON \
    1e-6  #define MAX_ITERATIONS 50000  

static double eq(double i) {
    return (std::pow(i, 3) - (4 * i) - 9);  }


template <typename T>
int sgn(T val) {
    return (T(0) < val) - (val < T(0));
}


int main() {
    double a = -1, b = 1, x, z;
    int i;

        for (int i = 0; i < MAX_ITERATIONS; i++) {
        z = eq(a);
        x = eq(b);
        if (sgn(z) == sgn(x)) {              b++;
            a--;
        } else {              break;
        }
    }

    std::cout << "\nFirst initial: " << a;
    std::cout << "\nSecond initial: " << b;

        for (i = 0; i < MAX_ITERATIONS; i++) {
        x = (a + b) / 2;
        z = eq(x);
        std::cout << "\n\nz: " << z << "\t[" << a << " , " << b
                  << " | Bisect: " << x << "]";

        if (z < 0) {
            a = x;
        } else {
            b = x;
        }

        if (std::abs(z) < EPSILON)              break;
    }

    std::cout << "\n\nRoot: " << x << "\t\tSteps: " << i << std::endl;
    return 0;
}

#include <cmath>
#include <ctime>
#include <iostream>
#include <limits>

constexpr double EPSILON = 1e-10;              constexpr int16_t MAX_ITERATIONS = INT16_MAX;  

static double eq(double i) {
    return (std::pow(i, 3) - (4 * i) - 9);  }


static double eq_der(double i) {
    return ((3 * std::pow(i, 2)) - 4);  }


int main() {
    std::srand(std::time(nullptr));  
    double z = NAN, c = std::rand() % 100, m = NAN, n = NAN;
    int i = 0;

    std::cout << "\nInitial approximation: " << c;

        for (i = 0; i < MAX_ITERATIONS; i++) {
        m = eq(c);
        n = eq_der(c);

        z = c - (m / n);
        c = z;

        if (std::abs(m) < EPSILON) {              break;
        }
    }

    std::cout << "\n\nRoot: " << z << "\t\tSteps: " << i << std::endl;
    return 0;
}


#include <cassert>   #include <cmath>     #include <complex>   #include <iostream>  #include <vector>    

namespace numerical_methods {

std::complex<double> *FastFourierTransform(std::complex<double> *p, uint8_t n) {
    if (n == 1) {
        return p;      }

    double pi = 2 * asin(1.0);  
    std::complex<double> om = std::complex<double>(
        cos(2 * pi / n), sin(2 * pi / n));  
    auto *pe = new std::complex<double>[n / 2];  
    auto *po = new std::complex<double>[n / 2];  
    int k1 = 0, k2 = 0;
    for (int j = 0; j < n; j++) {
        if (j % 2 == 0) {
            pe[k1++] = p[j];  
        } else {
            po[k2++] = p[j];          }
    }

    std::complex<double> *ye =
        FastFourierTransform(pe, n / 2);  
    std::complex<double> *yo =
        FastFourierTransform(po, n / 2);  
    auto *y = new std::complex<double>[n];  
    k1 = 0, k2 = 0;

    for (int i = 0; i < n / 2; i++) {
        y[i] =
            ye[k1] + pow(om, i) * yo[k2];          y[i + n / 2] =
            ye[k1] - pow(om, i) * yo[k2];  
        k1++;
        k2++;
    }

    if (n != 2) {
        delete[] pe;
        delete[] po;
    }

    delete[] ye;      delete[] yo;      return y;
}

}  

static void test() {

    auto *t1 = new std::complex<double>[2];      auto *t2 = new std::complex<double>[4];  
    t1[0] = {1, 0};
    t1[1] = {2, 0};
    t2[0] = {1, 0};
    t2[1] = {2, 0};
    t2[2] = {3, 0};
    t2[3] = {4, 0};

    uint8_t n1 = 2;
    uint8_t n2 = 4;
    std::vector<std::complex<double>> r1 = {
        {3, 0}, {-1, 0}};  
    std::vector<std::complex<double>> r2 = {
        {10, 0}, {-2, -2}, {-2, 0}, {-2, 2}};  
    std::complex<double> *o1 = numerical_methods::FastFourierTransform(t1, n1);
    std::complex<double> *t3 =
        o1;      std::complex<double> *o2 = numerical_methods::FastFourierTransform(t2, n2);
    std::complex<double> *t4 =
        o2;      for (uint8_t i = 0; i < n1; i++) {
        assert((r1[i].real() - o1->real() < 0.000000000001) &&
               (r1[i].imag() - o1->imag() <
                0.000000000001));                                             o1++;
    }

    for (uint8_t i = 0; i < n2; i++) {
        assert((r2[i].real() - o2->real() < 0.000000000001) &&
               (r2[i].imag() - o2->imag() <
                0.000000000001));                                             o2++;
    }

    delete[] t1;
    delete[] t2;
    delete[] t3;
    delete[] t4;
    std::cout << "All tests have successfully passed!\n";
}



int main(int argc, char const *argv[]) {
    test();                   return 0;
}


#include <array>     #include <cassert>   #include <cmath>     #include <iostream>  
#include "math.h"


namespace numerical_methods {

namespace gram_schmidt {

double dot_product(const std::array<double, 10>& x,
                   const std::array<double, 10>& y, const int& c) {
    double sum = 0;
    for (int i = 0; i < c; ++i) {
        sum += x[i] * y[i];
    }
    return sum;
}


double projection(const std::array<double, 10>& x,
                  const std::array<double, 10>& y, const int& c) {
    double dot =
        dot_product(x, y, c);      double anorm =
        dot_product(y, y, c);      double factor =
        dot /
        anorm;                      return factor;
}


void display(const int& r, const int& c,
             const std::array<std::array<double, 10>, 20>& B) {
    for (int i = 0; i < r; ++i) {
        std::cout << "Vector " << i + 1 << ": ";
        for (int j = 0; j < c; ++j) {
            std::cout << B[i][j] << " ";
        }
        std::cout << '\n';
    }
}


void gram_schmidt(int r, const int& c,
                  const std::array<std::array<double, 10>, 20>& A,
                  std::array<std::array<double, 10>, 20> B) {
    if (c < r) {          std::cout << "Dimension of vector is less than number of vector, hence "
                     "\n first "
                  << c << " vectors are orthogonalised\n";
        r = c;
    }

    int k = 1;

    while (k <= r) {
        if (k == 1) {
            for (int j = 0; j < c; j++)
                B[0][j] = A[0][j];          }

        else {
            std::array<double, 10>
                all_projection{};              for (int i = 0; i < c; ++i) {
                all_projection[i] = 0;              }

            int l = 1;
            while (l < k) {
                std::array<double, 10>
                    temp{};                           double factor = NAN;                                                        factor = projection(A[k - 1], B[l - 1], c);
                for (int i = 0; i < c; ++i) {
                    temp[i] = B[l - 1][i] * factor;                  }
                for (int j = 0; j < c; ++j) {
                    all_projection[j] =
                        all_projection[j] +
                        temp[j];                                                    }
                l++;
            }
            for (int i = 0; i < c; ++i) {
                B[k - 1][i] =
                    A[k - 1][i] -
                    all_projection[i];                                                      }
        }
        k++;
    }
    display(r, c, B);  }
}  }  
static void test() {
    std::array<std::array<double, 10>, 20> a1 = {
        {{1, 0, 1, 0}, {1, 1, 1, 1}, {0, 1, 2, 1}}};
    std::array<std::array<double, 10>, 20> b1 = {{0}};
    double dot1 = 0;
    numerical_methods::gram_schmidt::gram_schmidt(3, 4, a1, b1);
    int flag = 1;
    for (int i = 0; i < 2; ++i) {
        for (int j = i + 1; j < 3; ++j) {
            dot1 = fabs(
                numerical_methods::gram_schmidt::dot_product(b1[i], b1[j], 4));
            if (dot1 > 0.1) {
                flag = 0;
                break;
            }
        }
    }
    if (flag == 0)
        std::cout << "Vectors are linearly dependent\n";
    assert(flag == 1);
    std::cout << "Passed Test Case 1\n ";

    std::array<std::array<double, 10>, 20> a2 = {{{3, 1}, {2, 2}}};
    std::array<std::array<double, 10>, 20> b2 = {{0}};
    double dot2 = 0;
    numerical_methods::gram_schmidt::gram_schmidt(2, 2, a2, b2);
    flag = 1;
    for (int i = 0; i < 1; ++i) {
        for (int j = i + 1; j < 2; ++j) {
            dot2 = fabs(
                numerical_methods::gram_schmidt::dot_product(b2[i], b2[j], 2));
            if (dot2 > 0.1) {
                flag = 0;
                break;
            }
        }
    }
    if (flag == 0)
        std::cout << "Vectors are linearly dependent\n";
    assert(flag == 1);
    std::cout << "Passed Test Case 2\n";

    std::array<std::array<double, 10>, 20> a3 = {{{1, 2, 2}, {-4, 3, 2}}};
    std::array<std::array<double, 10>, 20> b3 = {{0}};
    double dot3 = 0;
    numerical_methods::gram_schmidt::gram_schmidt(2, 3, a3, b3);
    flag = 1;
    for (int i = 0; i < 1; ++i) {
        for (int j = i + 1; j < 2; ++j) {
            dot3 = fabs(
                numerical_methods::gram_schmidt::dot_product(b3[i], b3[j], 3));
            if (dot3 > 0.1) {
                flag = 0;
                break;
            }
        }
    }
    if (flag == 0)
        std::cout << "Vectors are linearly dependent\n";
    assert(flag == 1);
    std::cout << "Passed Test Case 3\n";
}


int main() {
    int r = 0, c = 0;
    test();      std::cout << "Enter the dimension of your vectors\n";
    std::cin >> c;
    std::cout << "Enter the number of vectors you will enter\n";
    std::cin >> r;

    std::array<std::array<double, 10>, 20>
        A{};      std::array<std::array<double, 10>, 20> B = {
        {0}};          for (int i = 0; i < r; ++i) {
        std::cout << "Enter vector " << i + 1
                  << '\n';          for (int j = 0; j < c; ++j) {
            std::cout << "Value " << j + 1 << "th of vector: ";
            std::cin >> A[i][j];
        }
        std::cout << '\n';
    }

    numerical_methods::gram_schmidt::gram_schmidt(r, c, A, B);

    double dot = 0;
    int flag = 1;      for (int i = 0; i < r - 1; ++i) {
        for (int j = i + 1; j < r; ++j) {
            dot = fabs(
                numerical_methods::gram_schmidt::dot_product(B[i], B[j], c));
            if (dot > 0.1)                                          {
                flag = 0;
                break;
            }
        }
    }
    if (flag == 0)
        std::cout << "Vectors are linearly dependent\n";
    return 0;
}

#include <cassert>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <iostream>
#ifdef _OPENMP
#include <omp.h>
#endif

#include "./qr_decompose.h"
using qr_algorithm::operator<<;

#define LIMS 9 


void create_matrix(std::valarray<std::valarray<double>> *A) {
    int i, j, tmp, lim2 = LIMS >> 1;
    int N = A->size();

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++) {
        A[0][i][i] = (std::rand() % LIMS) - lim2;
        for (j = i + 1; j < N; j++) {
            tmp = (std::rand() % LIMS) - lim2;
            A[0][i][j] = tmp;              A[0][j][i] = tmp;
        }
    }
}


void mat_mul(const std::valarray<std::valarray<double>> &A,
             const std::valarray<std::valarray<double>> &B,
             std::valarray<std::valarray<double>> *OUT) {
    int R1 = A.size();
    int C1 = A[0].size();
    int R2 = B.size();
    int C2 = B[0].size();
    if (C1 != R2) {
        perror("Matrix dimensions mismatch!");
        return;
    }

    for (int i = 0; i < R1; i++) {
        for (int j = 0; j < C2; j++) {
            OUT[0][i][j] = 0.f;
            for (int k = 0; k < C1; k++) {
                OUT[0][i][j] += A[i][k] * B[k][j];
            }
        }
    }
}

namespace qr_algorithm {

std::valarray<double> eigen_values(std::valarray<std::valarray<double>> *A,
                                   bool print_intermediates = false) {
    int rows = A->size();
    int columns = rows;
    int counter = 0, num_eigs = rows - 1;
    double last_eig = 0;

    std::valarray<std::valarray<double>> Q(rows);
    std::valarray<std::valarray<double>> R(columns);

    std::valarray<double> eigen_vals(rows);
    for (int i = 0; i < rows; i++) {
        Q[i] = std::valarray<double>(columns);
        R[i] = std::valarray<double>(columns);
    }

    while (num_eigs > 0) {
        while (std::abs(A[0][num_eigs][num_eigs - 1]) >
               std::numeric_limits<double>::epsilon()) {
                        last_eig = A[0][num_eigs][num_eigs];
            for (int i = 0; i < rows; i++) {
                A[0][i][i] -= last_eig;
            }

            qr_decompose(*A, &Q, &R);

            if (print_intermediates) {
                std::cout << *A << "\n";
                std::cout << Q << "\n";
                std::cout << R << "\n";
                printf("-------------------- %d ---------------------\n",
                       ++counter);
            }

                        mat_mul(R, Q, A);

            for (int i = 0; i < rows; i++) {
                A[0][i][i] += last_eig;
            }
        }

        eigen_vals[num_eigs] = last_eig;
                if (print_intermediates) {
            std::cout << "========================\n";
            std::cout << "Eigen value: " << last_eig << ",\n";
            std::cout << "========================\n";
        }

        num_eigs--;
        rows--;
        columns--;
    }
    eigen_vals[0] = A[0][0][0];

    if (print_intermediates) {
        std::cout << Q << "\n";
        std::cout << R << "\n";
    }

    return eigen_vals;
}

}  

void test1() {
    std::valarray<std::valarray<double>> X = {{5, 7}, {7, 11}};
    double y[] = {15.56158, 0.384227};  
    std::cout << "------- Test 1 -------" << std::endl;
    std::valarray<double> eig_vals = qr_algorithm::eigen_values(&X);

    for (int i = 0; i < 2; i++) {
        std::cout << i + 1 << "/2 Checking for " << y[i] << " --> ";
        bool result = false;
        for (int j = 0; j < 2 && !result; j++) {
            if (std::abs(y[i] - eig_vals[j]) < 0.1) {
                result = true;
                std::cout << "(" << eig_vals[j] << ") ";
            }
        }
        assert(result);          std::cout << "found\n";
    }
    std::cout << "Test 1 Passed\n\n";
}


void test2() {
    std::valarray<std::valarray<double>> X = {{-4, 4, 2, 0, -3},
                                              {4, -4, 4, -3, -1},
                                              {2, 4, 4, 3, -3},
                                              {0, -3, 3, -1, -3},
                                              {-3, -1, -3, -3, 0}};
    double y[] = {9.27648, -9.26948, 2.0181, -1.03516,
                  -5.98994};  
    std::cout << "------- Test 2 -------" << std::endl;
    std::valarray<double> eig_vals = qr_algorithm::eigen_values(&X);

    std::cout << X << "\n"
              << "Eigen values: " << eig_vals << "\n";

    for (int i = 0; i < 5; i++) {
        std::cout << i + 1 << "/5 Checking for " << y[i] << " --> ";
        bool result = false;
        for (int j = 0; j < 5 && !result; j++) {
            if (std::abs(y[i] - eig_vals[j]) < 0.1) {
                result = true;
                std::cout << "(" << eig_vals[j] << ") ";
            }
        }
        assert(result);          std::cout << "found\n";
    }
    std::cout << "Test 2 Passed\n\n";
}


int main(int argc, char **argv) {
    int mat_size = 5;
    if (argc == 2) {
        mat_size = atoi(argv[1]);
    } else {          test1();
        test2();
        std::cout << "Usage: ./qr_eigen_values [mat_size]\n";
        return 0;
    }

    if (mat_size < 2) {
        fprintf(stderr, "Matrix size should be > 2\n");
        return -1;
    }

        std::srand(std::time(nullptr));

    int i, rows = mat_size, columns = mat_size;

    std::valarray<std::valarray<double>> A(rows);

    for (int i = 0; i < rows; i++) {
        A[i] = std::valarray<double>(columns);
    }

    create_matrix(&A);

    std::cout << A << "\n";

    clock_t t1 = clock();
    std::valarray<double> eigen_vals = qr_algorithm::eigen_values(&A);
    double dtime = static_cast<double>(clock() - t1) / CLOCKS_PER_SEC;

    std::cout << "Eigen vals: ";
    for (i = 0; i < mat_size; i++) std::cout << eigen_vals[i] << "\t";
    std::cout << "\nTime taken to compute: " << dtime << " sec\n";

    return 0;
}


#include <array>
#include <iostream>


namespace backtracking {

namespace n_queens_optimized {

template <size_t n>
void PrintSol(const std::array<std::array<int, n>, n> &board) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << board[i][j] << " ";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
    if (n % 2 == 0 || (n % 2 == 1 && board[n / 2 + 1][0] != 1)) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                std::cout << board[j][i] << " ";
            }
            std::cout << std::endl;
        }
        std::cout << std::endl;
    }
}


template <size_t n>
bool CanIMove(const std::array<std::array<int, n>, n> &board, int row,
              int col) {
        for (int i = 0; i <= col; i++) {
        if (board[row][i] == 1) {
            return false;
        }
    }
        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 1) {
            return false;
        }
    }
        for (int i = row, j = col; i <= n - 1 && j >= 0; i++, j--) {
        if (board[i][j] == 1) {
            return false;
        }
    }
    return true;
}


template <size_t n>
void NQueenSol(std::array<std::array<int, n>, n> board, int col) {
    if (col >= n) {
        PrintSol<n>(board);
        return;
    }
    for (int i = 0; i < n; i++) {
        if (CanIMove<n>(board, i, col)) {
            board[i][col] = 1;
            NQueenSol<n>(board, col + 1);
            board[i][col] = 0;
        }
    }
}
}  }  

int main() {
    const int n = 4;
    std::array<std::array<int, n>, n> board{};

    if (n % 2 == 0) {
        for (int i = 0; i <= n / 2 - 1; i++) {
            if (backtracking::n_queens_optimized::CanIMove(board, i, 0)) {
                board[i][0] = 1;
                backtracking::n_queens_optimized::NQueenSol(board, 1);
                board[i][0] = 0;
            }
        }
    } else {
        for (int i = 0; i <= n / 2; i++) {
            if (backtracking::n_queens_optimized::CanIMove(board, i, 0)) {
                board[i][0] = 1;
                backtracking::n_queens_optimized::NQueenSol(board, 1);
                board[i][0] = 0;
            }
        }
    }
    return 0;
}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <list>       #include <numeric>    #include <vector>     

namespace backtracking {

namespace magic_sequence {
using sequence_t =
    std::vector<unsigned int>;  
void print(const sequence_t& s) {
    for (const auto& item : s) std::cout << item << " ";
    std::cout << std::endl;
}


bool is_magic(const sequence_t& s) {
    for (unsigned int i = 0; i < s.size(); i++) {
        if (std::count(s.cbegin(), s.cend(), i) != s[i]) {
            return false;
        }
    }
    return true;
}


bool filtering(const sequence_t& s, unsigned int depth) {
    return std::accumulate(s.cbegin(), s.cbegin() + depth,
                           static_cast<unsigned int>(0)) <= s.size();
}


void solve(sequence_t* s, std::list<sequence_t>* ret, unsigned int depth = 0) {
    if (depth == s->size()) {
        if (is_magic(*s)) {
            ret->push_back(*s);
        }
    } else {
        for (unsigned int i = 0; i < s->size(); i++) {
            (*s)[depth] = i;
            if (filtering(*s, depth + 1)) {
                solve(s, ret, depth + 1);
            }
        }
    }
}

}  }  

static void test() {
        backtracking::magic_sequence::sequence_t s_magic = {6, 2, 1, 0, 0,
                                                        0, 1, 0, 0, 0};
    assert(backtracking::magic_sequence::is_magic(s_magic));

        backtracking::magic_sequence::sequence_t s_not_magic = {5, 2, 1, 0, 0,
                                                            0, 1, 0, 0, 0};
    assert(!backtracking::magic_sequence::is_magic(s_not_magic));
}


int main() {
    test();  
        for (unsigned int i = 2; i < 12; i++) {
        std::cout << "Solution for n = " << i << std::endl;
                std::list<backtracking::magic_sequence::sequence_t> list_of_solutions;
                backtracking::magic_sequence::sequence_t s1(i, i);
                backtracking::magic_sequence::solve(&s1, &list_of_solutions);
                for (const auto& item : list_of_solutions) {
            backtracking::magic_sequence::print(item);
        }
    }
    return 0;
}

#include <algorithm>  #include <array>      #include <cmath>      #include <iostream>   

namespace backtracking {

template <size_t T>
int minimax(int depth, int node_index, bool is_max,
            const std::array<int, T> &scores, double height) {
    if (depth == height) {
        return scores[node_index];
    }

    int v1 = minimax(depth + 1, node_index * 2, !is_max, scores, height);
    int v2 = minimax(depth + 1, node_index * 2 + 1, !is_max, scores, height);

    return is_max ? std::max(v1, v2) : std::min(v1, v2);
}
}  

int main() {
    std::array<int, 8> scores = {90, 23, 6, 33, 21, 65, 123, 34423};
    double height = log2(scores.size());

    std::cout << "Optimal value: "
              << backtracking::minimax(0, 0, true, scores, height) << std::endl;
    return 0;
}


#include <array>     #include <cassert>   #include <iostream>  

namespace backtracking {

namespace rat_maze {

template <size_t size>
bool solveMaze(int currposrow, int currposcol,
               const std::array<std::array<int, size>, size> &maze,
               std::array<std::array<int, size>, size> soln) {
    if ((currposrow == size - 1) && (currposcol == size - 1)) {
        soln[currposrow][currposcol] = 1;
        for (int i = 0; i < size; ++i) {
            for (int j = 0; j < size; ++j) {
                std::cout << soln[i][j] << " ";
            }
            std::cout << std::endl;
        }
        return true;
    } else {
        soln[currposrow][currposcol] = 1;

                if ((currposcol < size - 1) && maze[currposrow][currposcol + 1] == 1 &&
            solveMaze(currposrow, currposcol + 1, maze, soln)) {
            return true;
        }

                if ((currposrow < size - 1) && maze[currposrow + 1][currposcol] == 1 &&
            solveMaze(currposrow + 1, currposcol, maze, soln)) {
            return true;
        }

                soln[currposrow][currposcol] = 0;
        return false;
    }
}
}  }  

static void test() {
    const int size = 4;
    std::array<std::array<int, size>, size> maze = {
        std::array<int, size>{1, 0, 1, 0}, std::array<int, size>{1, 0, 1, 1},
        std::array<int, size>{1, 0, 0, 1}, std::array<int, size>{1, 1, 1, 1}};

    std::array<std::array<int, size>, size> soln{};

        for (int i = 0; i < size; ++i) {
        for (int j = 0; j < size; ++j) {
            soln[i][j] = 0;
        }
    }

    int currposrow = 0;      int currposcol = 0;  
    assert(backtracking::rat_maze::solveMaze<size>(currposrow, currposcol, maze,
                                                   soln) == 1);
}


int main() {
    test();      return 0;
}


#include <cassert>   #include <iostream>  #include <vector>    

namespace backtracking {

namespace wildcard_matching {

std::vector<std::vector<int64_t>> dpTable(1000, std::vector<int64_t>(1000, -1));
bool wildcard_matching(std::string s, std::string p, uint32_t pos1,
                       uint32_t pos2) {
    uint32_t n = s.length();
    uint32_t m = p.length();
        if (pos1 == n && pos2 == m) {
        return true;
    }

            if (pos1 != n && pos2 == m) {
        return false;
    }

            if (pos1 == n && pos2 != m) {
        while (pos2 < m && p[pos2] == '*') {
            pos2++;
        }

        return pos2 == m;
    }

        if (dpTable[pos1][pos2] != -1) {
        return dpTable[pos1][pos2];
    }

        if (s[pos1] == p[pos2]) {
        return dpTable[pos1][pos2] =
                   wildcard_matching(s, p, pos1 + 1, pos2 + 1);
    }

    else {
                if (p[pos2] == '?') {
            return dpTable[pos1][pos2] =
                       wildcard_matching(s, p, pos1 + 1, pos2 + 1);
        }
                else if (p[pos2] == '*') {
            return dpTable[pos1][pos2] =
                       wildcard_matching(s, p, pos1, pos2 + 1) ||
                       wildcard_matching(s, p, pos1 + 1, pos2);
        }
                else {
            return dpTable[pos1][pos2] = 0;
        }
    }
}

}  }  

static void test() {
        std::cout << "1st test ";
    std::string matching1 = "baaabab";
    std::string pattern1 = "*****ba*****ab";
    assert(backtracking::wildcard_matching::wildcard_matching(matching1,
                                                              pattern1, 0, 0) ==
           1);      std::cout << "passed" << std::endl;

        std::cout << "2nd test ";
    std::string matching2 = "baaabab";
    std::string pattern2 = "ba*****ab";
    assert(backtracking::wildcard_matching::wildcard_matching(matching2,
                                                              pattern2, 0, 0) ==
           1);      std::cout << "passed" << std::endl;

        std::cout << "3rd test ";
    std::string matching3 = "baaabab";
    std::string pattern3 = "ba*ab";
    assert(backtracking::wildcard_matching::wildcard_matching(matching3,
                                                              pattern3, 0, 0) ==
           1);      std::cout << "passed" << std::endl;

        std::cout << "4th test ";
    std::string matching4 = "baaabab";
    std::string pattern4 = "a*ab";
    assert(backtracking::wildcard_matching::wildcard_matching(matching4,
                                                              pattern4, 0, 0) ==
           1);      std::cout << "passed" << std::endl;

        std::cout << "5th test ";
    std::string matching5 = "baaabab";
    std::string pattern5 = "aa?ab";
    assert(backtracking::wildcard_matching::wildcard_matching(matching5,
                                                              pattern5, 0, 0) ==
           1);      std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}

#include <array>     #include <iostream>  

namespace backtracking {

namespace sudoku_solver {

template <size_t V>
bool isPossible(const std::array<std::array<int, V>, V> &mat, int i, int j,
                int no, int n) {
        for (int x = 0; x < n; x++) {
        if (mat[x][j] == no || mat[i][x] == no) {
            return false;
        }
    }

        int sx = (i / 3) * 3;
    int sy = (j / 3) * 3;

    for (int x = sx; x < sx + 3; x++) {
        for (int y = sy; y < sy + 3; y++) {
            if (mat[x][y] == no) {
                return false;
            }
        }
    }

    return true;
}

template <size_t V>
void printMat(const std::array<std::array<int, V>, V> &mat,
              const std::array<std::array<int, V>, V> &starting_mat, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (starting_mat[i][j] != mat[i][j]) {
                std::cout << "\033[93m" << mat[i][j] << "\033[0m"
                          << " ";
            } else {
                std::cout << mat[i][j] << " ";
            }
            if ((j + 1) % 3 == 0) {
                std::cout << '\t';
            }
        }
        if ((i + 1) % 3 == 0) {
            std::cout << std::endl;
        }
        std::cout << std::endl;
    }
}


template <size_t V>
bool solveSudoku(std::array<std::array<int, V>, V> &mat,
                 const std::array<std::array<int, V>, V> &starting_mat, int i,
                 int j) {
        if (i == 9) {
                printMat<V>(mat, starting_mat, 9);
        return true;
    }

        if (j == 9) {
        return solveSudoku<V>(mat, starting_mat, i + 1, 0);
    }

        if (mat[i][j] != 0) {
        return solveSudoku<V>(mat, starting_mat, i, j + 1);
    }
            for (int no = 1; no <= 9; no++) {
        if (isPossible<V>(mat, i, j, no, 9)) {
                        mat[i][j] = no;
            bool solution_found = solveSudoku<V>(mat, starting_mat, i, j + 1);
            if (solution_found) {
                return true;
            }
                                }
    }
        mat[i][j] = 0;
    return false;
}
}  }  

int main() {
    const int V = 9;
    std::array<std::array<int, V>, V> mat = {
        std::array<int, V>{5, 3, 0, 0, 7, 0, 0, 0, 0},
        std::array<int, V>{6, 0, 0, 1, 9, 5, 0, 0, 0},
        std::array<int, V>{0, 9, 8, 0, 0, 0, 0, 6, 0},
        std::array<int, V>{8, 0, 0, 0, 6, 0, 0, 0, 3},
        std::array<int, V>{4, 0, 0, 8, 0, 3, 0, 0, 1},
        std::array<int, V>{7, 0, 0, 0, 2, 0, 0, 0, 6},
        std::array<int, V>{0, 6, 0, 0, 0, 0, 2, 8, 0},
        std::array<int, V>{0, 0, 0, 4, 1, 9, 0, 0, 5},
        std::array<int, V>{0, 0, 0, 0, 8, 0, 0, 7, 9}};

    backtracking::sudoku_solver::printMat<V>(mat, mat, 9);
    std::cout << "Solution " << std::endl;
    std::array<std::array<int, V>, V> starting_mat = mat;
    backtracking::sudoku_solver::solveSudoku<V>(mat, starting_mat, 0, 0);

    return 0;
}


#include <cassert>   #include <iostream>  #include <vector>    

namespace backtracking {

namespace subset_sum {

uint64_t number_of_subsets(int32_t sum, const std::vector<int32_t> &in_arr) {
    int32_t nelement = in_arr.size();
    uint64_t count_of_subset = 0;

    for (int32_t i = 0; i < (1 << (nelement)); i++) {
        int32_t check = 0;
        for (int32_t j = 0; j < nelement; j++) {
            if (i & (1 << j)) {
                check += (in_arr[j]);
            }
        }
        if (check == sum) {
            count_of_subset++;
        }
    }
    return count_of_subset;
}
}  }  

static void test() {
        std::cout << "1st test ";
    std::vector<int32_t> array1 = {-7, -3, -2, 5, 8};      assert(backtracking::subset_sum::number_of_subsets(0, array1) ==
           2);                      std::cout << "passed" << std::endl;

        std::cout << "2nd test ";
    std::vector<int32_t> array2 = {1, 2, 3, 3};
    assert(backtracking::subset_sum::number_of_subsets(6, array2) ==
           3);                      std::cout << "passed" << std::endl;

        std::cout << "3rd test ";
    std::vector<int32_t> array3 = {1, 1, 1, 1};
    assert(backtracking::subset_sum::number_of_subsets(1, array3) ==
           4);                      std::cout << "passed" << std::endl;

        std::cout << "4th test ";
    std::vector<int32_t> array4 = {3, 3, 3, 3};
    assert(backtracking::subset_sum::number_of_subsets(6, array4) ==
           6);                      std::cout << "passed" << std::endl;

        std::cout << "5th test ";
    std::vector<int32_t> array5 = {};
    assert(backtracking::subset_sum::number_of_subsets(6, array5) ==
           0);                      std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}

#include <array>     #include <iostream>  

namespace backtracking {

namespace knight_tour {

template <size_t V>
bool issafe(int x, int y, const std::array<std::array<int, V>, V> &sol) {
    return (x < V && x >= 0 && y < V && y >= 0 && sol[x][y] == -1);
}


template <size_t V>
bool solve(int x, int y, int mov, std::array<std::array<int, V>, V> &sol,
           const std::array<int, V> &xmov, std::array<int, V> &ymov) {
    int k = 0, xnext = 0, ynext = 0;

    if (mov == V * V) {
        return true;
    }

    for (k = 0; k < V; k++) {
        xnext = x + xmov[k];
        ynext = y + ymov[k];

        if (issafe<V>(xnext, ynext, sol)) {
            sol[xnext][ynext] = mov;

            if (solve<V>(xnext, ynext, mov + 1, sol, xmov, ymov) == true) {
                return true;
            } else {
                sol[xnext][ynext] = -1;
            }
        }
    }
    return false;
}
}  }  

int main() {
    const int n = 8;
    std::array<std::array<int, n>, n> sol = {0};

    int i = 0, j = 0;
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            sol[i][j] = -1;
        }
    }

    std::array<int, n> xmov = {2, 1, -1, -2, -2, -1, 1, 2};
    std::array<int, n> ymov = {1, 2, 2, 1, -1, -2, -2, -1};

    sol[0][0] = 0;

    bool flag = backtracking::knight_tour::solve<n>(0, 0, 1, sol, xmov, ymov);
    if (flag == false) {
        std::cout << "Error: Solution does not exist\n";
    } else {
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                std::cout << sol[i][j] << "  ";
            }
            std::cout << "\n";
        }
    }
    return 0;
}

#include <array>
#include <iostream>


namespace backtracking {

namespace n_queens {

template <size_t n>
void printSolution(const std::array<std::array<int, n>, n> &board) {
    std::cout << "\n";
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << "" << board[i][j] << " ";
        }
        std::cout << "\n";
    }
}


template <size_t n>
bool isSafe(const std::array<std::array<int, n>, n> &board, const int &row,
            const int &col) {
    int i = 0, j = 0;

        for (i = 0; i < col; i++) {
        if (board[row][i]) {
            return false;
        }
    }

        for (i = row, j = col; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j]) {
            return false;
        }
    }
        for (i = row, j = col; j >= 0 && i < n; i++, j--) {
        if (board[i][j]) {
            return false;
        }
    }
    return true;
}


template <size_t n>
void solveNQ(std::array<std::array<int, n>, n> board, const int &col) {
    if (col >= n) {
        printSolution<n>(board);
        return;
    }

            for (int i = 0; i < n; i++) {
                        if (isSafe<n>(board, i, col)) {
                        board[i][col] = 1;

                        solveNQ<n>(board, col + 1);

            board[i][col] = 0;          }
    }
}
}  }  

int main() {
    const int n = 4;
    std::array<std::array<int, n>, n> board = {
        std::array<int, n>({0, 0, 0, 0}), std::array<int, n>({0, 0, 0, 0}),
        std::array<int, n>({0, 0, 0, 0}), std::array<int, n>({0, 0, 0, 0})};

    backtracking::n_queens::solveNQ<n>(board, 0);
    return 0;
}


#include <cassert>        #include <iostream>       #include <unordered_map>  #include <vector>         

namespace backtracking {

namespace subarray_sum {

uint64_t subarray_sum(int64_t sum, const std::vector<int64_t> &in_arr) {
    int64_t nelement = in_arr.size();
    int64_t count_of_subset = 0;
    int64_t current_sum = 0;
    std::unordered_map<int64_t, int64_t>
        sumarray;                     
    for (int64_t i = 0; i < nelement; i++) {
        current_sum += in_arr[i];

        if (current_sum == sum) {
            count_of_subset++;
        }
                if (sumarray.find(current_sum - sum) != sumarray.end()) {
            count_of_subset += (sumarray[current_sum - sum]);
        }
        sumarray[current_sum]++;
    }
    return count_of_subset;
}
}  }  

static void test() {
        std::cout << "1st test ";
    std::vector<int64_t> array1 = {-7, -3, -2, 5, 8};      assert(
        backtracking::subarray_sum::subarray_sum(0, array1) ==
        1);                   std::cout << "passed" << std::endl;

        std::cout << "2nd test ";
    std::vector<int64_t> array2 = {1, 2, 3, 3};
    assert(backtracking::subarray_sum::subarray_sum(6, array2) ==
           2);                      std::cout << "passed" << std::endl;

        std::cout << "3rd test ";
    std::vector<int64_t> array3 = {1, 1, 1, 1};
    assert(backtracking::subarray_sum::subarray_sum(1, array3) ==
           4);                      std::cout << "passed" << std::endl;

        std::cout << "4th test ";
    std::vector<int64_t> array4 = {3, 3, 3, 3};
    assert(backtracking::subarray_sum::subarray_sum(6, array4) ==
           3);                      std::cout << "passed" << std::endl;

        std::cout << "5th test ";
    std::vector<int64_t> array5 = {};
    assert(backtracking::subarray_sum::subarray_sum(6, array5) ==
           0);                      std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}


#include <array>     #include <iostream>  #include <vector>    

namespace backtracking {

namespace graph_coloring {

template <size_t V>
void printSolution(const std::array<int, V>& color) {
    std::cout << "Following are the assigned colors\n";
    for (auto& col : color) {
        std::cout << col;
    }
    std::cout << "\n";
}


template <size_t V>
bool isSafe(int v, const std::array<std::array<int, V>, V>& graph,
            const std::array<int, V>& color, int c) {
    for (int i = 0; i < V; i++) {
        if (graph[v][i] && c == color[i]) {
            return false;
        }
    }
    return true;
}


template <size_t V>
void graphColoring(const std::array<std::array<int, V>, V>& graph, int m,
                   std::array<int, V> color, int v) {
            if (v == V) {
        printSolution<V>(color);
        return;
    }

        for (int c = 1; c <= m; c++) {
                if (isSafe<V>(v, graph, color, c)) {
            color[v] = c;

                        graphColoring<V>(graph, m, color, v + 1);

                        color[v] = 0;
        }
    }
}
}  }  

int main() {
                        
    const int V = 4;      std::array<std::array<int, V>, V> graph = {
        std::array<int, V>({0, 1, 1, 1}), std::array<int, V>({1, 0, 1, 0}),
        std::array<int, V>({1, 1, 0, 1}), std::array<int, V>({1, 0, 1, 0})};

    int m = 3;      std::array<int, V> color{};

    backtracking::graph_coloring::graphColoring<V>(graph, m, color, 0);
    return 0;
}

#include <array>     #include <iostream>  

namespace backtracking {

namespace n_queens_all_solutions {

template <size_t n>
void PrintSol(const std::array<std::array<int, n>, n>& board) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << board[i][j] << " ";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
}


template <size_t n>
bool CanIMove(const std::array<std::array<int, n>, n>& board, int row,
              int col) {
        for (int i = 0; i < col; i++) {
        if (board[row][i] == 1) {
            return false;
        }
    }
        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j] == 1) {
            return false;
        }
    }
        for (int i = row, j = col; i <= n - 1 && j >= 0; i++, j--) {
        if (board[i][j] == 1) {
            return false;
        }
    }
    return true;
}


template <size_t n>
void NQueenSol(std::array<std::array<int, n>, n> board, int col) {
    if (col >= n) {
        PrintSol(board);
        return;
    }
    for (int i = 0; i < n; i++) {
        if (CanIMove(board, i, col)) {
            board[i][col] = 1;
            NQueenSol(board, col + 1);
            board[i][col] = 0;
        }
    }
}
}  }  

int main() {
    const int n = 4;
    std::array<std::array<int, n>, n> board{0};

    backtracking::n_queens_all_solutions::NQueenSol(board, 0);
}

#include <cassert>
#include <iostream>
#include <limits>
#include <memory>
#include <queue>
#include <utility>
#include <vector>

constexpr int64_t INF = std::numeric_limits<int64_t>::max();



namespace graph {

void addEdge(std::vector<std::vector<std::pair<int, int>>> *adj, int u, int v,
             int w) {
    (*adj)[u - 1].push_back(std::make_pair(v - 1, w));
    }


int dijkstra(std::vector<std::vector<std::pair<int, int>>> *adj, int s, int t) {
        int n = adj->size();

        std::vector<int64_t> dist(n, INF);

                std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>,
                        std::greater<std::pair<int, int>>>
        pq;

        pq.push(std::make_pair(0, s));

        dist[s] = 0;

    while (!pq.empty()) {
                int currentNode = pq.top().second;

                int currentDist = pq.top().first;

        pq.pop();

                        for (std::pair<int, int> edge : (*adj)[currentNode]) {
                        if (currentDist + edge.second < dist[edge.first]) {
                dist[edge.first] = currentDist + edge.second;
                pq.push(std::make_pair(dist[edge.first], edge.first));
            }
        }
    }
    if (dist[t] != INF) {
        return dist[t];
    }
    return -1;
}
}  

void tests() {
    std::cout << "Initiatinig Predefined Tests..." << std::endl;
    std::cout << "Initiating Test 1..." << std::endl;
    std::vector<std::vector<std::pair<int, int>>> adj1(
        4, std::vector<std::pair<int, int>>());
    graph::addEdge(&adj1, 1, 2, 1);
    graph::addEdge(&adj1, 4, 1, 2);
    graph::addEdge(&adj1, 2, 3, 2);
    graph::addEdge(&adj1, 1, 3, 5);

    int s = 1, t = 3;
    assert(graph::dijkstra(&adj1, s - 1, t - 1) == 3);
    std::cout << "Test 1 Passed..." << std::endl;

    s = 4, t = 3;
    std::cout << "Initiating Test 2..." << std::endl;
    assert(graph::dijkstra(&adj1, s - 1, t - 1) == 5);
    std::cout << "Test 2 Passed..." << std::endl;

    std::vector<std::vector<std::pair<int, int>>> adj2(
        5, std::vector<std::pair<int, int>>());
    graph::addEdge(&adj2, 1, 2, 4);
    graph::addEdge(&adj2, 1, 3, 2);
    graph::addEdge(&adj2, 2, 3, 2);
    graph::addEdge(&adj2, 3, 2, 1);
    graph::addEdge(&adj2, 2, 4, 2);
    graph::addEdge(&adj2, 3, 5, 4);
    graph::addEdge(&adj2, 5, 4, 1);
    graph::addEdge(&adj2, 2, 5, 3);
    graph::addEdge(&adj2, 3, 4, 4);

    s = 1, t = 5;
    std::cout << "Initiating Test 3..." << std::endl;
    assert(graph::dijkstra(&adj2, s - 1, t - 1) == 6);
    std::cout << "Test 3 Passed..." << std::endl;
    std::cout << "All Test Passed..." << std::endl << std::endl;
}


int main() {
        tests();

    int vertices = int(), edges = int();
    std::cout << "Enter the number of vertices : ";
    std::cin >> vertices;
    std::cout << "Enter the number of edges : ";
    std::cin >> edges;

    std::vector<std::vector<std::pair<int, int>>> adj(
        vertices, std::vector<std::pair<int, int>>());

    int u = int(), v = int(), w = int();
    while (edges--) {
        std::cin >> u >> v >> w;
        graph::addEdge(&adj, u, v, w);
    }

    int s = int(), t = int();
    std::cin >> s >> t;
    int dist = graph::dijkstra(&adj, s - 1, t - 1);
    if (dist == -1) {
        std::cout << "Target not reachable from source" << std::endl;
    } else {
        std::cout << "Shortest Path Distance : " << dist << std::endl;
    }
    return 0;
}

#include <iostream> #include <set>    #include <vector> 

namespace graph {

namespace disjoint_union {
uint32_t number_of_nodes = 0;                std::vector<int64_t> parent{};               std::vector<uint32_t> connected_set_size{};  
void make_set() {
    for (uint32_t i = 1; i <= number_of_nodes; i++) {
        parent[i] = i;
        connected_set_size[i] = 1;
    }
}

int64_t find_set(int64_t val) {
    while (parent[val] != val) {
        parent[val] = parent[parent[val]];
        val = parent[val];
    }
    return val;
}

void union_sets(int64_t node1, int64_t node2) {
    node1 = find_set(node1);      node2 = find_set(node2);  
        if (node1 != node2) {
        if (connected_set_size[node1] < connected_set_size[node2]) {
            std::swap(node1, node2);          }
        parent[node2] = node1;          connected_set_size[node1] +=
            connected_set_size[node2];      }
}

uint32_t no_of_connected_components() {
    std::set<int64_t> temp;      for (uint32_t i = 1; i <= number_of_nodes; i++) temp.insert(find_set(i));
    return temp.size();  }
}  }  

static void test() {
    namespace dsu = graph::disjoint_union;
    std::cin >> dsu::number_of_nodes;
    dsu::parent.resize(dsu::number_of_nodes + 1);
    dsu::connected_set_size.resize(dsu::number_of_nodes + 1);
    dsu::make_set();
    uint32_t edges = 0;
    std::cin >> edges;      while (edges--) {
        int64_t node_a = 0, node_b = 0;
        std::cin >> node_a >> node_b;
        dsu::union_sets(node_a, node_b);
    }
    std::cout << dsu::no_of_connected_components() << std::endl;
}


int main() {
    test();      return 0;
}

#include <cassert>
#include <iostream>
#include <vector>


bool hamilton_cycle(const std::vector<std::vector<bool>> &routes) {
    const size_t n = routes.size();
        const size_t height = 1 << n;
    std::vector<std::vector<bool>> dp(height, std::vector<bool>(n, false));

        for (size_t i = 0; i < n; ++i) {
        dp[1 << i][i] = true;
    }
    for (size_t i = 1; i < height; i++) {
        std::vector<size_t> zeros, ones;
                for (size_t pos = 0; pos < n; ++pos) {
            if ((1 << pos) & i) {
                ones.push_back(pos);
            } else {
                zeros.push_back(pos);
            }
        }

        for (auto &o : ones) {
            if (!dp[i][o]) {
                continue;
            }

            for (auto &z : zeros) {
                if (!routes[o][z]) {
                    continue;
                }
                dp[i + (1 << z)][z] = true;
            }
        }
    }

    bool is_cycle = false;
    for (size_t i = 0; i < n; i++) {
        is_cycle |= dp[height - 1][i];
        if (is_cycle) {                                       break;
        }
    }
    return is_cycle;
}


static void test1() {
    std::vector<std::vector<bool>> arr{
        std::vector<bool>({true, true, false, false}),
        std::vector<bool>({false, true, true, false}),
        std::vector<bool>({false, false, true, true}),
        std::vector<bool>({false, false, false, true})};

    bool ans = hamilton_cycle(arr);
    std::cout << "Test 1... ";
    assert(ans);
    std::cout << "passed\n";
}


static void test2() {
    std::vector<std::vector<bool>> arr{
        std::vector<bool>({true, true, false, false}),
        std::vector<bool>({false, true, true, true}),
        std::vector<bool>({false, false, true, false}),
        std::vector<bool>({false, false, false, true})};

    bool ans = hamilton_cycle(arr);

    std::cout << "Test 2... ";
    assert(!ans);      std::cout << "passed\n";
}


static void test3() {
    std::vector<std::vector<bool>> arr{
        std::vector<bool>({true, true, true, true}),
        std::vector<bool>({true, true, true, true}),
        std::vector<bool>({true, true, true, true}),
        std::vector<bool>({true, true, true, true})};

    bool ans = hamilton_cycle(arr);

    std::cout << "Test 3... ";
    assert(ans);
    std::cout << "passed\n";
}


int main(int argc, char **argv) {
    test1();
    test2();
    test3();
    return 0;
}


#include <cassert>   #include <iostream>  #include <limits>    #include <queue>     #include <utility>   #include <vector>    
constexpr int64_t INF = std::numeric_limits<int64_t>::max();


namespace graph {

namespace bidirectional_dijkstra {

void addEdge(std::vector<std::vector<std::pair<uint64_t, uint64_t>>> *adj1,
             std::vector<std::vector<std::pair<uint64_t, uint64_t>>> *adj2,
             uint64_t u, uint64_t v, uint64_t w) {
    (*adj1)[u - 1].push_back(std::make_pair(v - 1, w));
    (*adj2)[v - 1].push_back(std::make_pair(u - 1, w));
    }

uint64_t Shortest_Path_Distance(
    const std::vector<uint64_t> &workset_,
    const std::vector<std::vector<uint64_t>> &distance_) {
    int64_t distance = INF;
    for (uint64_t i : workset_) {
        if (distance_[0][i] + distance_[1][i] < distance) {
            distance = distance_[0][i] + distance_[1][i];
        }
    }
    return distance;
}


int Bidijkstra(std::vector<std::vector<std::pair<uint64_t, uint64_t>>> *adj1,
               std::vector<std::vector<std::pair<uint64_t, uint64_t>>> *adj2,
               uint64_t s, uint64_t t) {
        uint64_t n = adj1->size();

        std::vector<std::vector<uint64_t>> dist(2, std::vector<uint64_t>(n, INF));

            
            std::vector<
        std::priority_queue<std::pair<uint64_t, uint64_t>,
                            std::vector<std::pair<uint64_t, uint64_t>>,
                            std::greater<std::pair<uint64_t, uint64_t>>>>
        pq(2);
        std::vector<uint64_t> workset(n);
        std::vector<bool> visited(n);

        pq[0].push(std::make_pair(0, s));

        dist[0][s] = 0;

        pq[1].push(std::make_pair(0, t));

        dist[1][t] = 0;

    while (true) {
        
                        if (pq[0].size() == 0) {
            break;
        }
                uint64_t currentNode = pq[0].top().second;

                uint64_t currentDist = pq[0].top().first;

        pq[0].pop();

                        for (std::pair<int, int> edge : (*adj1)[currentNode]) {
                        if (currentDist + edge.second < dist[0][edge.first]) {
                dist[0][edge.first] = currentDist + edge.second;
                pq[0].push(std::make_pair(dist[0][edge.first], edge.first));
            }
        }
                workset.push_back(currentNode);

                if (visited[currentNode] == 1) {
            return Shortest_Path_Distance(workset, dist);
        }
        visited[currentNode] = true;
        
                        if (pq[1].size() == 0) {
            break;
        }
                currentNode = pq[1].top().second;

                currentDist = pq[1].top().first;

        pq[1].pop();

                        for (std::pair<int, int> edge : (*adj2)[currentNode]) {
                        if (currentDist + edge.second < dist[1][edge.first]) {
                dist[1][edge.first] = currentDist + edge.second;
                pq[1].push(std::make_pair(dist[1][edge.first], edge.first));
            }
        }
                workset.push_back(currentNode);

                if (visited[currentNode] == 1) {
            return Shortest_Path_Distance(workset, dist);
        }
        visited[currentNode] = true;
    }
    return -1;
}
}  }  

static void tests() {
    std::cout << "Initiatinig Predefined Tests..." << std::endl;
    std::cout << "Initiating Test 1..." << std::endl;
    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj1_1(
        4, std::vector<std::pair<uint64_t, uint64_t>>());
    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj1_2(
        4, std::vector<std::pair<uint64_t, uint64_t>>());
    graph::bidirectional_dijkstra::addEdge(&adj1_1, &adj1_2, 1, 2, 1);
    graph::bidirectional_dijkstra::addEdge(&adj1_1, &adj1_2, 4, 1, 2);
    graph::bidirectional_dijkstra::addEdge(&adj1_1, &adj1_2, 2, 3, 2);
    graph::bidirectional_dijkstra::addEdge(&adj1_1, &adj1_2, 1, 3, 5);

    uint64_t s = 1, t = 3;
    assert(graph::bidirectional_dijkstra::Bidijkstra(&adj1_1, &adj1_2, s - 1,
                                                     t - 1) == 3);
    std::cout << "Test 1 Passed..." << std::endl;

    s = 4, t = 3;
    std::cout << "Initiating Test 2..." << std::endl;
    assert(graph::bidirectional_dijkstra::Bidijkstra(&adj1_1, &adj1_2, s - 1,
                                                     t - 1) == 5);
    std::cout << "Test 2 Passed..." << std::endl;

    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj2_1(
        5, std::vector<std::pair<uint64_t, uint64_t>>());
    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj2_2(
        5, std::vector<std::pair<uint64_t, uint64_t>>());
    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 1, 2, 4);
    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 1, 3, 2);
    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 2, 3, 2);
    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 3, 2, 1);
    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 2, 4, 2);
    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 3, 5, 4);
    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 5, 4, 1);
    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 2, 5, 3);
    graph::bidirectional_dijkstra::addEdge(&adj2_1, &adj2_2, 3, 4, 4);

    s = 1, t = 5;
    std::cout << "Initiating Test 3..." << std::endl;
    assert(graph::bidirectional_dijkstra::Bidijkstra(&adj2_1, &adj2_2, s - 1,
                                                     t - 1) == 6);
    std::cout << "Test 3 Passed..." << std::endl;
    std::cout << "All Test Passed..." << std::endl << std::endl;
}


int main() {
    tests();      uint64_t vertices = uint64_t();
    uint64_t edges = uint64_t();
    std::cout << "Enter the number of vertices : ";
    std::cin >> vertices;
    std::cout << "Enter the number of edges : ";
    std::cin >> edges;

    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj1(
        vertices, std::vector<std::pair<uint64_t, uint64_t>>());
    std::vector<std::vector<std::pair<uint64_t, uint64_t>>> adj2(
        vertices, std::vector<std::pair<uint64_t, uint64_t>>());

    uint64_t u = uint64_t(), v = uint64_t(), w = uint64_t();
    std::cout << "Enter the edges by three integers in this form: u v w "
              << std::endl;
    std::cout << "Example: if there is and edge between node 1 and node 4 with "
                 "weight 7 enter: 1 4 7, and then press enter"
              << std::endl;
    while (edges--) {
        std::cin >> u >> v >> w;
        graph::bidirectional_dijkstra::addEdge(&adj1, &adj2, u, v, w);
        if (edges != 0) {
            std::cout << "Enter the next edge" << std::endl;
        }
    }

    uint64_t s = uint64_t(), t = uint64_t();
    std::cout
        << "Enter the source node and the target node separated by a space"
        << std::endl;
    std::cout << "Example: If the source node is 5 and the target node is 6 "
                 "enter: 5 6 and press enter"
              << std::endl;
    std::cin >> s >> t;
    int dist =
        graph::bidirectional_dijkstra::Bidijkstra(&adj1, &adj2, s - 1, t - 1);
    if (dist == -1) {
        std::cout << "Target not reachable from source" << std::endl;
    } else {
        std::cout << "Shortest Path Distance : " << dist << std::endl;
    }

    return 0;
}


#include <iostream>
#include <stack>
#include <vector>


void print(const std::vector<std::vector<int> > &a, int V) {
    for (int i = 0; i < V; i++) {
        if (!a[i].empty()) {
            std::cout << "i=" << i << "-->";
        }
        for (int j : a[i]) {
            std::cout << j << " ";
        }
        if (!a[i].empty()) {
            std::cout << std::endl;
        }
    }
}


void push_vertex(int v, std::stack<int> *st, std::vector<bool> *vis,
                 const std::vector<std::vector<int> > &adj) {
    (*vis)[v] = true;
    for (auto i = adj[v].begin(); i != adj[v].end(); i++) {
        if ((*vis)[*i] == false) {
            push_vertex(*i, st, vis, adj);
        }
    }
    st->push(v);
}


void dfs(int v, std::vector<bool> *vis,
         const std::vector<std::vector<int> > &grev) {
    (*vis)[v] = true;
        for (auto i = grev[v].begin(); i != grev[v].end(); i++) {
        if ((*vis)[*i] == false) {
            dfs(*i, vis, grev);
        }
    }
}


int kosaraju(int V, const std::vector<std::vector<int> > &adj) {
    std::vector<bool> vis(V, false);
    std::stack<int> st;
    for (int v = 0; v < V; v++) {
        if (vis[v] == false) {
            push_vertex(v, &st, &vis, adj);
        }
    }
        std::vector<std::vector<int> > grev(V);
    for (int i = 0; i < V + 1; i++) {
        for (auto j = adj[i].begin(); j != adj[i].end(); j++) {
            grev[*j].push_back(i);
        }
    }
                for (int i = 0; i < V; i++) vis[i] = false;
    int count_scc = 0;
    while (!st.empty()) {
        int t = st.top();
        st.pop();
        if (vis[t] == false) {
            dfs(t, &vis, grev);
            count_scc++;
        }
    }
            return count_scc;
}

int main() {
    int t = 0;
    std::cin >> t;
    while (t--) {
        int a = 0, b = 0;          std::cin >> a >> b;
        int m = 0, n = 0;
        std::vector<std::vector<int> > adj(a + 1);
        for (int i = 0; i < b; i++)                                               {
            std::cin >> m >> n;              adj[m].push_back(n);
        }
                std::cout << kosaraju(a, adj) << std::endl;
    }
    return 0;
}
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
#include <vector>

std::vector<int> topoSortKahn(int N, const std::vector<std::vector<int> > &adj);

int main() {
    int nodes = 0, edges = 0;
    std::cin >> edges >> nodes;
    if (edges == 0 || nodes == 0) {
        return 0;
    }
    int u = 0, v = 0;

    std::vector<std::vector<int> > graph(nodes);
                
    for (int i = 0; i < edges; i++) {
        std::cin >> u >> v;
        graph[u].push_back(v);
    }

    std::vector<int> topo = topoSortKahn(nodes, graph);
        for (int i = 0; i < nodes; i++) {
        std::cout << topo[i] << " ";
    }
}

std::vector<int> topoSortKahn(int V,
                              const std::vector<std::vector<int> > &adj) {
    std::vector<bool> vis(V + 1, false);
    std::vector<int> deg(V + 1, 0);
    for (int i = 0; i < V; i++) {
        for (int j : adj[i]) {
            deg[j]++;
        }
    }
    std::queue<int> q;
    for (int i = 0; i < V; i++) {
        if (deg[i] == 0) {
            q.push(i);
            vis[i] = true;
        }
    }
    std::vector<int> arr(V + 1, 0);
    int count = 0;
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        arr[count++] = cur;
        for (int i : adj[cur]) {
            if (!vis[i]) {
                deg[i]--;
                if (deg[i] == 0) {
                    q.push(i);
                    vis[i] = true;
                }
            }
        }
    }
    return arr;
}
#include <algorithm>
#include <iostream>
#include <vector>

int number_of_vertices,
    number_of_edges;  std::vector<std::vector<int>> graph;
std::vector<bool> visited;
std::vector<int> topological_order;

void dfs(int v) {
    visited[v] = true;
    for (int u : graph[v]) {
        if (!visited[u]) {
            dfs(u);
        }
    }
    topological_order.push_back(v);
}

void topological_sort() {
    visited.assign(number_of_vertices, false);
    topological_order.clear();
    for (int i = 0; i < number_of_vertices; ++i) {
        if (!visited[i]) {
            dfs(i);
        }
    }
    reverse(topological_order.begin(), topological_order.end());
}
int main() {
    std::cout
        << "Enter the number of vertices and the number of directed edges\n";
    std::cin >> number_of_vertices >> number_of_edges;
    int x = 0, y = 0;
    graph.resize(number_of_vertices, std::vector<int>());
    for (int i = 0; i < number_of_edges; ++i) {
        std::cin >> x >> y;
        x--, y--;          graph[x].push_back(y);
    }
    topological_sort();
    std::cout << "Topological Order : \n";
    for (int v : topological_order) {
        std::cout << v + 1
                  << ' ';      }
    std::cout << '\n';
    return 0;
}

#include <iostream>
#include <queue>
#include <vector>


namespace graph {

namespace is_graph_bipartite {

class Graph {
 private:
    int n;  
    std::vector<std::vector<int> >
        adj;  
    std::vector<int> side;  
 public:
    
    explicit Graph(int size) {
        n = size;
        adj.resize(n);
        side.resize(n, -1);
    }

    void addEdge(int u, int v);  
    bool
    is_bipartite();  };


void Graph::addEdge(int u, int v) {
    adj[u - 1].push_back(v - 1);
    adj[v - 1].push_back(u - 1);
}


bool Graph::is_bipartite() {
    bool check = true;
    std::queue<int> q;
    for (int current_edge = 0; current_edge < n; ++current_edge) {
        if (side[current_edge] == -1) {
            q.push(current_edge);
            side[current_edge] = 0;
            while (q.size()) {
                int current = q.front();
                q.pop();
                for (auto neighbour : adj[current]) {
                    if (side[neighbour] == -1) {
                        side[neighbour] = (1 ^ side[current]);
                        q.push(neighbour);
                    } else {
                        check &= (side[neighbour] != side[current]);
                    }
                }
            }
        }
    }
    return check;
}
}  }  

static void test() {
    graph::is_graph_bipartite::Graph G1(
        5);          G1.addEdge(1, 2);
    G1.addEdge(1, 3);
    G1.addEdge(3, 4);
    G1.addEdge(4, 5);

    graph::is_graph_bipartite::Graph G2(
        3);          G2.addEdge(1, 2);
    G2.addEdge(1, 3);
    G2.addEdge(2, 3);

        if (G1.is_bipartite()) {
        std::cout << "The given graph G1 is a bipartite graph\n";
    } else {
        std::cout << "The given graph G1 is not a bipartite graph\n";
    }
    if (G2.is_bipartite()) {
        std::cout << "The given graph G2 is a bipartite graph\n";
    } else {
        std::cout << "The given graph G2 is not a bipartite graph\n";
    }
}


int main() {
    test();      return 0;
}

#include <algorithm>
#include <bitset>
#include <cstring>
#include <iostream>
#include <limits>
#include <queue>
#include <tuple>
#include <utility>
#include <vector>
const int MAXN = 505;
class Graph {
    std::vector<std::vector<int> > residual_capacity, capacity;
    int total_nodes = 0;
    int total_edges = 0, source = 0, sink = 0;
    std::vector<int> parent;
    std::vector<std::tuple<int, int, int> > edge_participated;
    std::bitset<MAXN> visited;
    int max_flow = 0;
    bool bfs(int source, int sink) {          visited.reset();
        std::queue<int> q;
        q.push(source);
        bool is_path_found = false;
        while (q.empty() == false && is_path_found == false) {
            int current_node = q.front();
            visited.set(current_node);
            q.pop();
            for (int i = 0; i < total_nodes; ++i) {
                if (residual_capacity[current_node][i] > 0 && !visited[i]) {
                    visited.set(i);
                    parent[i] = current_node;
                    if (i == sink) {
                        return true;
                    }
                    q.push(i);
                }
            }
        }
        return false;
    }

 public:
    void set_graph() {
        std::cin >> total_nodes >> total_edges >> source >> sink;
        parent = std::vector<int>(total_nodes, -1);
        capacity = residual_capacity = std::vector<std::vector<int> >(
            total_nodes, std::vector<int>(total_nodes));
        for (int start = 0, destination = 0, capacity_ = 0, i = 0;
             i < total_edges; ++i) {
            std::cin >> start >> destination >> capacity_;
            residual_capacity[start][destination] = capacity_;
            capacity[start][destination] = capacity_;
        }
    }
    void ford_fulkerson() {
        while (bfs(source, sink)) {
            int current_node = sink;
            int flow = std::numeric_limits<int>::max();
            while (current_node != source) {
                int parent_ = parent[current_node];
                flow = std::min(flow, residual_capacity[parent_][current_node]);
                current_node = parent_;
            }
            current_node = sink;
            max_flow += flow;
            while (current_node != source) {
                int parent_ = parent[current_node];
                residual_capacity[parent_][current_node] -= flow;
                residual_capacity[current_node][parent_] += flow;
                current_node = parent_;
            }
        }
    }
    void print_flow_info() {
        for (int i = 0; i < total_nodes; ++i) {
            for (int j = 0; j < total_nodes; ++j) {
                if (capacity[i][j] &&
                    residual_capacity[i][j] < capacity[i][j]) {
                    edge_participated.emplace_back(std::make_tuple(
                        i, j, capacity[i][j] - residual_capacity[i][j]));
                }
            }
        }
        std::cout << "\nNodes : " << total_nodes << "\nMax flow: " << max_flow
                  << "\nEdge present in flow: " << edge_participated.size()
                  << '\n';
        std::cout << "\nSource\tDestination\tCapacity\total_nodes";
        for (auto& edge_data : edge_participated) {
            int source = 0, destination = 0, capacity_ = 0;
            std::tie(source, destination, capacity_) = edge_data;
            std::cout << source << "\t" << destination << "\t\t" << capacity_
                      << '\t';
        }
    }
};
int main() {

    Graph graph;
    graph.set_graph();
    graph.ford_fulkerson();
    graph.print_flow_info();
    return 0;
}
#include <algorithm>
#include <array>
#include <iostream>
#include <vector>
const int mx = 1e6 + 5;
using ll = int64_t;

std::array<ll, mx> parent;
ll node, edge;
std::vector<std::pair<ll, std::pair<ll, ll>>> edges;
void initial() {
    for (int i = 0; i < node + edge; ++i) {
        parent[i] = i;
    }
}

int root(int i) {
    while (parent[i] != i) {
        parent[i] = parent[parent[i]];
        i = parent[i];
    }
    return i;
}

void join(int x, int y) {
    int root_x = root(x);      int root_y = root(y);
    parent[root_x] = root_y;
}

ll kruskal() {
    ll mincost = 0;
    for (int i = 0; i < edge; ++i) {
        ll x = edges[i].second.first;
        ll y = edges[i].second.second;
        if (root(x) != root(y)) {
            mincost += edges[i].first;
            join(x, y);
        }
    }
    return mincost;
}

int main() {
    while (true) {
        int from = 0, to = 0, cost = 0, totalcost = 0;
        std::cin >> node >> edge;          if (node == 0 && edge == 0) {
            break;          }
        initial();          for (int i = 0; i < edge; ++i) {
            std::cin >> from >> to >> cost;
            edges.emplace_back(make_pair(cost, std::make_pair(from, to)));
            totalcost += cost;
        }
        sort(edges.begin(), edges.end());
        std::cout << kruskal() << std::endl;
        edges.clear();
    }
    return 0;
}



#include <iostream>
#include <cstdlib> 
#include <queue>
#include <list>
#include <climits>
#include <memory>
#include <cassert>


 namespace graph { 


class HKGraph
{
    int m{};      int n{};      const int NIL{0};
    const int INF{INT_MAX};

    std::vector<std::list<int> >adj;  
    std::vector<int> pair_u;     std::vector<int> pair_v;     std::vector<int> dist;   
public:
    HKGraph();		           HKGraph(int m, int n);         void addEdge(int u, int v);     
    bool bfs();     bool dfs(int u); 	
    int hopcroftKarpAlgorithm();  };



int HKGraph::hopcroftKarpAlgorithm()
{

            pair_u = std::vector<int>(m + 1,NIL); 

            pair_v = std::vector<int>(n + 1,NIL); 

    dist = std::vector<int>(m + 1);  
    int result = 0;  
        while (bfs())
    {
                for (int u = 1; u <= m; u++){

                                                if (pair_u[u] == NIL && dfs(u)){
                result++;
	    }
	}
    }
    return result;
}



bool HKGraph::bfs()
{
    std::queue<int> q; 
        for (int u = 1; u <= m; u++)
    {
                if (pair_u[u] == NIL){
            
            dist[u] = 0;             q.push(u);
        }

        else{
            dist[u] = INF; 	}
    }

    
    dist[NIL] = INF; 
        while (!q.empty())
    {
        int u = q.front();          q.pop();

                if (dist[u] < dist[NIL])
        {
                        std::list<int>::iterator it;
            for (it = adj[u].begin(); it != adj[u].end(); ++it)
            {
                int v = *it;

                                if (dist[pair_v[v]] == INF)
                {
                    dist[pair_v[v]] = dist[u] + 1; 
                    q.push(pair_v[v]);                    }
            }
        }
    }

   
   
    return (dist[NIL] != INF);   }


bool HKGraph::dfs(int u)
{
    if (u != NIL)
    {
        std::list<int>::iterator it;
        for (it = adj[u].begin(); it != adj[u].end(); ++it)
        {
            
            int v = *it; 
                        if (dist[pair_v[v]] == dist[u] + 1)
            {
                                if (dfs(pair_v[v]) == true)
                {   
                    pair_v[v] = u;
                    pair_u[u] = v;
                    return true;
                }
            }
        }

        
        dist[u] = INF;         return false;
    }
    return true;
}


HKGraph::HKGraph() = default;


HKGraph::HKGraph(int m, int n) {
    this->m = m;
    this->n = n;
    adj = std::vector<std::list<int> >(m + 1);
}


void HKGraph::addEdge(int u, int v)
{
    adj[u].push_back(v); }

} 
using graph::HKGraph;


void tests(){
     	     int v1a = 3, v1b = 5, e1 = 2;  	     HKGraph g1(v1a, v1b); 
	     g1.addEdge(0,1);
	     g1.addEdge(1,4);

	     int expected_res1 = 0; 	     int res1 = g1.hopcroftKarpAlgorithm();

	     assert(res1 == expected_res1); 	
          	     int v2a = 4, v2b = 4, e2 = 6;  	     HKGraph g2(v2a, v2b); 
             g2.addEdge(1,1);
	     g2.addEdge(1,3);
	     g2.addEdge(2,3);
	     g2.addEdge(3,4);
	     g2.addEdge(4,3);
             g2.addEdge(4,2);
	
	     int expected_res2 = 0; 	     int res2 = g2.hopcroftKarpAlgorithm();

	     assert(res2 == expected_res2); 	
           	     int v3a = 6, v3b = 6, e3 = 4;  	     HKGraph g3(v3a, v3b); 
             g3.addEdge(0,1);
	     g3.addEdge(1,4);
	     g3.addEdge(1,5);
	     g3.addEdge(5,0);

	     int expected_res3 = 0; 	     int res3 = g3.hopcroftKarpAlgorithm();

	     assert(res3 == expected_res3); 	
	
    	
}


int main()
{
    tests();  
    int v1 = 0, v2 = 0, e = 0;
    std::cin >> v1 >> v2 >> e;     HKGraph g(v1, v2);  
    int u = 0, v = 0;
    for (int i = 0; i < e; ++i)
    {
        std::cin >> u >> v;
        g.addEdge(u, v);
    }
  
    int res = g.hopcroftKarpAlgorithm();
    std::cout << "Maximum matching is " << res <<"\n";

    return 0;

}


#include <iostream> 	 #include <stack>    	 #include <vector>   	 #include <cassert>  	 #include <limits>   	 
constexpr int WHITE = 0; constexpr int GREY = 1;	 constexpr int BLACK = 2; constexpr int64_t INF = std::numeric_limits<int16_t>::max();



namespace graph {

namespace depth_first_search {

void addEdge(std::vector<std::vector<size_t>> *adj, size_t u, size_t v) {

	(*adj)[u - 1].push_back(v - 1);
}


std::vector<size_t> dfs(const std::vector<std::vector<size_t> > &graph, size_t start) {
        std::vector<size_t> checked(graph.size(), WHITE), traversed_path;

    checked[start] = GREY;
    std::stack<size_t> stack;
    stack.push(start);

        while (!stack.empty()) {
        int act = stack.top();
        stack.pop();

        if (checked[act] == GREY) {
                        traversed_path.push_back(act + 1);

                        for (auto it : graph[act]) {
                stack.push(it);
                if (checked[it] != BLACK) {
                    checked[it] = GREY;
                }
            }
            checked[act] = BLACK;          }
    }
    return traversed_path;
}
}  }  

static void tests() {
	size_t start_pos;

		std::cout << "Case 1: " << std::endl;
	start_pos = 1;
	std::vector<std::vector<size_t> > g1(3, std::vector<size_t>());

	graph::depth_first_search::addEdge(&g1, 1, 2);
	graph::depth_first_search::addEdge(&g1, 2, 3);
	graph::depth_first_search::addEdge(&g1, 3, 1);

	std::vector<size_t> expected1 {1, 2, 3}; 	assert(graph::depth_first_search::dfs(g1, start_pos - 1) == expected1);
	std::cout << "Passed" << std::endl;

		std::cout << "Case 2: " << std::endl;
	start_pos = 1;
	std::vector<std::vector<size_t> > g2(4, std::vector<size_t>());

	graph::depth_first_search::addEdge(&g2, 1, 2);
	graph::depth_first_search::addEdge(&g2, 1, 3);
	graph::depth_first_search::addEdge(&g2, 2, 4);
	graph::depth_first_search::addEdge(&g2, 4, 1);

	std::vector<size_t> expected2 {1, 3, 2, 4}; 	assert(graph::depth_first_search::dfs(g2, start_pos - 1) == expected2);
	std::cout << "Passed" << std::endl;

		std::cout << "Case 3: " << std::endl;
	start_pos = 2;
	std::vector<std::vector<size_t> > g3(4, std::vector<size_t>());

	graph::depth_first_search::addEdge(&g3, 1, 2);
	graph::depth_first_search::addEdge(&g3, 1, 3);
	graph::depth_first_search::addEdge(&g3, 2, 4);
	graph::depth_first_search::addEdge(&g3, 4, 1);

	std::vector<size_t> expected3 {2, 4, 1, 3}; 	assert(graph::depth_first_search::dfs(g3, start_pos - 1) == expected3);
	std::cout << "Passed" << std::endl;

}


int main() {
    tests();  
    size_t vertices = 0, edges = 0, start_pos = 1;
	std::vector<size_t> traversal;

    std::cout << "Enter the Vertices : ";
	std::cin >> vertices;
	std::cout << "Enter the Edges : ";
	std::cin >> edges;

        std::vector<std::vector<size_t> > adj(vertices, std::vector<size_t>());

        std::cout << "Enter the vertices which have edges between them : " << std::endl;
	while (edges--) {
		size_t u = 0, v = 0;
		std::cin >> u >> v;
		graph::depth_first_search::addEdge(&adj, u, v);
	}

        std::cout << "Enter the starting vertex [1,n]: " << std::endl;
	std::cin >> start_pos;
	start_pos -= 1;
	traversal = graph::depth_first_search::dfs(adj, start_pos);

        for (auto x : traversal) {
		std::cout << x << ' ';
	}

    return 0;
}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <limits>     #include <vector>     

namespace graph {

int TravellingSalesmanProblem(std::vector<std::vector<uint32_t>> *cities,
                              int32_t src, uint32_t V) {
        std::vector<uint32_t> vtx;
    for (uint32_t i = 0; i < V; i++) {
        if (i != src) {
            vtx.push_back(i);
        }
    }

        int32_t min_path = 2147483647;
    do {
                int32_t curr_weight = 0;

                int k = src;
        for (int i : vtx) {
            curr_weight += (*cities)[k][i];
            k = i;
        }
        curr_weight += (*cities)[k][src];

                min_path = std::min(min_path, curr_weight);

    } while (next_permutation(vtx.begin(), vtx.end()));

    return min_path;
}
}  

static void tests() {
    std::cout << "Initiatinig Predefined Tests..." << std::endl;
    std::cout << "Initiating Test 1..." << std::endl;
    std::vector<std::vector<uint32_t>> cities = {
        {0, 20, 42, 35}, {20, 0, 30, 34}, {42, 30, 0, 12}, {35, 34, 12, 0}};
    uint32_t V = cities.size();
    assert(graph::TravellingSalesmanProblem(&cities, 0, V) == 97);
    std::cout << "1st test passed..." << std::endl;

    std::cout << "Initiating Test 2..." << std::endl;
    cities = {{0, 5, 10, 15}, {5, 0, 20, 30}, {10, 20, 0, 35}, {15, 30, 35, 0}};
    V = cities.size();
    assert(graph::TravellingSalesmanProblem(&cities, 0, V) == 75);
    std::cout << "2nd test passed..." << std::endl;

    std::cout << "Initiating Test 3..." << std::endl;
    cities = {
        {0, 10, 15, 20}, {10, 0, 35, 25}, {15, 35, 0, 30}, {20, 25, 30, 0}};
    V = cities.size();
    assert(graph::TravellingSalesmanProblem(&cities, 0, V) == 80);
    std::cout << "3rd test passed..." << std::endl;
}


int main() {
    tests();      std::vector<std::vector<uint32_t>> cities = {
        {0, 5, 10, 15}, {5, 0, 20, 30}, {10, 20, 0, 35}, {15, 30, 35, 0}};
    uint32_t V = cities.size();
    std::cout << graph::TravellingSalesmanProblem(&cities, 0, V) << std::endl;
    return 0;
}


#include <algorithm>
#include <iostream>
#include <vector>


namespace graph {

void addEdge(std::vector<std::vector<size_t>> *adj, size_t u, size_t v) {

    (*adj)[u - 1].push_back(v - 1);
    (*adj)[v - 1].push_back(u - 1);
}


void explore(const std::vector<std::vector<size_t>> &adj, size_t v,
             std::vector<bool> *visited) {
    std::cout << v + 1 << " ";
    (*visited)[v] = true;
    for (auto x : adj[v]) {
        if (!(*visited)[x]) {
            explore(adj, x, visited);
        }
    }
}


void depth_first_search(const std::vector<std::vector<size_t>> &adj,
                        size_t start) {
    size_t vertices = adj.size();

    std::vector<bool> visited(vertices, false);
    explore(adj, start, &visited);
}
}  

int main() {
    size_t vertices = 0, edges = 0;
    std::cout << "Enter the Vertices : ";
    std::cin >> vertices;
    std::cout << "Enter the Edges : ";
    std::cin >> edges;

        std::vector<std::vector<size_t>> adj(vertices, std::vector<size_t>());

        std::cout << "Enter the vertices which have edges between them : "
              << std::endl;
    while (edges--) {
        size_t u = 0, v = 0;
        std::cin >> u >> v;
        graph::addEdge(&adj, u, v);
    }

        graph::depth_first_search(adj, 2);

    std::cout << std::endl;
    return 0;
}

#include <algorithm>  #include <iostream>   #include <vector>     
class Solution {
    std::vector<std::vector<int>> graph;
    std::vector<int> in_time, out_time;
    int timer = 0;
    std::vector<std::vector<int>> bridge;
    std::vector<bool> visited;
    void dfs(int current_node, int parent) {
        visited.at(current_node) = true;
        in_time[current_node] = out_time[current_node] = timer++;
        for (auto& itr : graph[current_node]) {
            if (itr == parent) {
                continue;
            }
            if (!visited[itr]) {
                dfs(itr, current_node);
                if (out_time[itr] > in_time[current_node]) {
                    bridge.push_back({itr, current_node});
                }
            }
            out_time[current_node] =
                std::min(out_time[current_node], out_time[itr]);
        }
    }

 public:
    std::vector<std::vector<int>> search_bridges(
        int n, const std::vector<std::vector<int>>& connections) {
        timer = 0;
        graph.resize(n);
        in_time.assign(n, 0);
        visited.assign(n, false);
        out_time.assign(n, 0);
        for (auto& itr : connections) {
            graph.at(itr[0]).push_back(itr[1]);
            graph.at(itr[1]).push_back(itr[0]);
        }
        dfs(0, -1);
        return bridge;
    }
};


int main() {
    Solution s1;
    int number_of_node = 5;
    std::vector<std::vector<int>> node;
    node.push_back({0, 1});
    node.push_back({1, 3});
    node.push_back({1, 2});
    node.push_back({2, 4});

    std::vector<std::vector<int>> bridges =
        s1.search_bridges(number_of_node, node);
    std::cout << bridges.size() << " bridges found!\n";
    for (auto& itr : bridges) {
        std::cout << itr[0] << " --> " << itr[1] << '\n';
    }
    return 0;
}

#include <cassert>   #include <iostream>  #include <queue>     #include <vector>    

namespace graph {

bool checkBipartite(const std::vector<std::vector<int64_t>> &graph,
                    int64_t index, std::vector<int64_t> *visited) {
    std::queue<int64_t> q;                                  q.push(index);              (*visited)[index] = 1;      while (q.size()) {
        int64_t u = q.front();
        q.pop();
        for (uint64_t i = 0; i < graph[u].size(); i++) {
            int64_t v =
                graph[u][i];                 if (!(*visited)[v])                                               {
                (*visited)[v] =
                    ((*visited)[u] == 1)
                        ? -1
                        : 1;                                                q.push(v);                } else if ((*visited)[v] ==
                       (*visited)[u])                                                                                            {
                return false;
            }
        }
    }
    return true;                    }

bool isBipartite(const std::vector<std::vector<int64_t>> &graph) {
    std::vector<int64_t> visited(
        graph.size());                                                  
    for (uint64_t i = 0; i < graph.size(); i++) {
        if (!visited[i])                                                              {
            if (!checkBipartite(graph, i, &visited)) {
                return false;
            }
        }
    }
    return true;
}
}  

static void test() {
    std::vector<std::vector<int64_t>> graph = {{1, 3}, {0, 2}, {1, 3}, {0, 2}};

    assert(graph::isBipartite(graph) ==
           true);                     
    std::vector<std::vector<int64_t>> graph_not_bipartite = {
        {1, 2, 3}, {0, 2}, {0, 1, 3}, {0, 2}};

    assert(graph::isBipartite(graph_not_bipartite) ==
           false);                          std::cout << "All tests have successfully passed!\n";
}

int main() {
    test();      return 0;
}
#include <iostream>
#include <queue>
#include <vector>

using PII = std::pair<int, int>;

int prim(int x, const std::vector<std::vector<PII> > &graph) {
        std::priority_queue<PII, std::vector<PII>, std::greater<PII> > Q;
    std::vector<bool> marked(graph.size(), false);
    int minimum_cost = 0;

    Q.push(std::make_pair(0, x));
    while (!Q.empty()) {
                PII p = Q.top();
        Q.pop();
        x = p.second;
                if (marked[x] == true) {
            continue;
        }
        minimum_cost += p.first;
        marked[x] = true;
        for (const PII &neighbor : graph[x]) {
            int y = neighbor.second;
            if (marked[y] == false) {
                Q.push(neighbor);
            }
        }
    }
    return minimum_cost;
}

int main() {
    int nodes = 0, edges = 0;
    std::cin >> nodes >> edges;      if (nodes == 0 || edges == 0) {
        return 0;
    }

    std::vector<std::vector<PII> > graph(nodes);

        for (int i = 0; i < edges; ++i) {
        int x = 0, y = 0, weight = 0;
        std::cin >> x >> y >> weight;
        graph[x].push_back(std::make_pair(weight, y));
        graph[y].push_back(std::make_pair(weight, x));
    }

        int minimum_cost = prim(1, graph);
    std::cout << minimum_cost << std::endl;
    return 0;
}


#include <cassert>
#include <iostream>
#include <queue>
#include <utility>
#include <vector>


namespace graph {

class Graph {
 public:
    
    Graph(size_t N, const std::vector<std::pair<int, int> > &undirected_edges) {
        neighbors.resize(N);
        for (auto &edge : undirected_edges) {
            neighbors[edge.first].push_back(edge.second);
            neighbors[edge.second].push_back(edge.first);
        }
    }

    
    int number_of_vertices() const { return neighbors.size(); }

    
    std::vector<std::vector<int> > neighbors;
};


class RootedTree : public Graph {
 public:
    
    RootedTree(const std::vector<std::pair<int, int> > &undirected_edges,
               int root_)
        : Graph(undirected_edges.size() + 1, undirected_edges), root(root_) {
        populate_parents();
    }

    
    std::vector<int> parent;
    
    std::vector<int> level;
    
    int root;

 protected:
    
    void populate_parents() {
                        parent = std::vector<int>(number_of_vertices(), -1);
        level = std::vector<int>(number_of_vertices());
        parent[root] = root;
        level[root] = 0;
        std::queue<int> queue_of_vertices;
        queue_of_vertices.push(root);
        while (!queue_of_vertices.empty()) {
            int vertex = queue_of_vertices.front();
            queue_of_vertices.pop();
            for (int neighbor : neighbors[vertex]) {
                                if (parent[neighbor] == -1) {
                    parent[neighbor] = vertex;
                    level[neighbor] = level[vertex] + 1;
                    queue_of_vertices.push(neighbor);
                }
            }
        }
    }
};


class LowestCommonAncestor {
 public:
    
    explicit LowestCommonAncestor(const RootedTree &tree_) : tree(tree_) {
        populate_up();
    }

    
    int lowest_common_ancestor(int u, int v) const {
                if (tree.level[v] > tree.level[u]) {
            std::swap(u, v);
        }

                int level_diff = tree.level[u] - tree.level[v];
        for (int i = 0; (1 << i) <= level_diff; ++i) {
            if (level_diff & (1 << i)) {
                u = up[u][i];
            }
        }
        assert(tree.level[u] == tree.level[v]);

        if (u == v) {
            return u;
        }

                for (int i = static_cast<int>(up[u].size()) - 1; i >= 0; --i) {
            if (up[u][i] != up[v][i]) {
                u = up[u][i];
                v = up[v][i];
            }
        }

                                assert(up[u][0] == up[v][0]);
        return up[u][0];
    }

    const RootedTree &tree;
    
    std::vector<std::vector<int> > up;

 protected:
    
    void populate_up() {
        up.resize(tree.number_of_vertices());
        for (int vertex = 0; vertex < tree.number_of_vertices(); ++vertex) {
            up[vertex].push_back(tree.parent[vertex]);
        }
        for (int level = 0; (1 << level) < tree.number_of_vertices(); ++level) {
            for (int vertex = 0; vertex < tree.number_of_vertices(); ++vertex) {
                                                                up[vertex].push_back(up[up[vertex][level]][level]);
            }
        }
    }
};

}  

static void tests() {
    
    std::vector<std::pair<int, int> > edges = {
        {7, 1}, {1, 5}, {1, 3}, {3, 6}, {6, 2}, {2, 9}, {6, 8}, {4, 3}, {0, 4}};
    graph::RootedTree t(edges, 3);
    graph::LowestCommonAncestor lca(t);
    assert(lca.lowest_common_ancestor(7, 4) == 3);
    assert(lca.lowest_common_ancestor(9, 6) == 6);
    assert(lca.lowest_common_ancestor(0, 0) == 0);
    assert(lca.lowest_common_ancestor(8, 2) == 6);
}


int main() {
    tests();
    return 0;
}


#include <iostream>     #include <map>          #include <queue>        #include <stdexcept>    #include <type_traits>  #include <utility>      #include <vector>       

struct Edge {
    unsigned int src;
    unsigned int dest;

    Edge() = delete;
    ~Edge() = default;
    Edge(Edge&&) = default;
    Edge& operator=(Edge&&) = default;
    Edge(Edge const&) = default;
    Edge& operator=(Edge const&) = default;

    
    Edge(unsigned int source, unsigned int destination)
        : src(source), dest(destination) {}
};

using AdjList = std::map<unsigned int, std::vector<unsigned int>>;


class Graph {
 public:
    Graph() : m_adjList({}) {}
    ~Graph() = default;
    Graph(Graph&&) = default;
    Graph& operator=(Graph&&) = default;
    Graph(Graph const&) = default;
    Graph& operator=(Graph const&) = default;

    
    Graph(unsigned int vertices, AdjList adjList)
        : m_vertices(vertices), m_adjList(std::move(adjList)) {}

    
    Graph(unsigned int vertices, AdjList&& adjList)
        : m_vertices(vertices), m_adjList(std::move(adjList)) {}

    
    Graph(unsigned int vertices, std::vector<Edge> const& edges)
        : m_vertices(vertices) {
        for (auto const& edge : edges) {
            if (edge.src >= vertices || edge.dest >= vertices) {
                throw std::range_error(
                    "Either src or dest of edge out of range");
            }
            m_adjList[edge.src].emplace_back(edge.dest);
        }
    }

    
    std::remove_reference<AdjList>::type const& getAdjList() const {
        return m_adjList;
    }

    
    unsigned int getVertices() const { return m_vertices; }

    
    void addVertices(unsigned int num = 1) { m_vertices += num; }

    
    void addEdge(Edge const& edge) {
        if (edge.src >= m_vertices || edge.dest >= m_vertices) {
            throw std::range_error("Either src or dest of edge out of range");
        }
        m_adjList[edge.src].emplace_back(edge.dest);
    }

    
    void addEdge(unsigned int source, unsigned int destination) {
        if (source >= m_vertices || destination >= m_vertices) {
            throw std::range_error(
                "Either source or destination of edge out of range");
        }
        m_adjList[source].emplace_back(destination);
    }

 private:
    unsigned int m_vertices = 0;
    AdjList m_adjList;
};


class CycleCheck {
 private:
    enum nodeStates : uint8_t { not_visited = 0, in_stack, visited };

    
    static bool isCyclicDFSHelper(AdjList const& adjList,
                                  std::vector<nodeStates>* state,
                                  unsigned int node) {
                (*state)[node] = in_stack;

                        auto const it = adjList.find(node);
        if (it != adjList.end()) {
            for (auto child : it->second) {
                                                auto state_of_child = (*state)[child];
                if (state_of_child == not_visited) {
                    if (isCyclicDFSHelper(adjList, state, child)) {
                        return true;
                    }
                } else if (state_of_child == in_stack) {
                                                                                return true;
                }
            }
        }

                        (*state)[node] = visited;
                return false;
    }

 public:
    
    static bool isCyclicDFS(Graph const& graph) {
        auto vertices = graph.getVertices();

        
        std::vector<nodeStates> state(vertices, not_visited);

                for (unsigned int node = 0; node < vertices; node++) {
                                                if (state[node] == not_visited) {
                                if (isCyclicDFSHelper(graph.getAdjList(), &state, node)) {
                    return true;
                }
            }
        }

                        return false;
    }

    
    static bool isCyclicBFS(Graph const& graph) {
        auto graphAjdList = graph.getAdjList();
        auto vertices = graph.getVertices();

        std::vector<unsigned int> indegree(vertices, 0);
                for (auto const& list : graphAjdList) {
            auto children = list.second;
            for (auto const& child : children) {
                indegree[child]++;
            }
        }

        std::queue<unsigned int> can_be_solved;
        for (unsigned int node = 0; node < vertices; node++) {
                                    if (!indegree[node]) {
                can_be_solved.emplace(node);
            }
        }

                auto remain = vertices;
                while (!can_be_solved.empty()) {
            auto solved = can_be_solved.front();
                        can_be_solved.pop();
                        remain--;

                        auto it = graphAjdList.find(solved);
            if (it != graphAjdList.end()) {
                for (auto child : it->second) {
                                        if (--indegree[child] == 0) {
                                                                        can_be_solved.emplace(child);
                    }
                }
            }
        }

                        return !(remain == 0);
    }
};


int main() {
        Graph g(7, std::vector<Edge>{{0, 1}, {1, 2}, {2, 0}, {2, 5}, {3, 5}});
        std::cout << CycleCheck::isCyclicBFS(g) << '\n';

        std::cout << CycleCheck::isCyclicDFS(g) << '\n';
    return 0;
}


#include <algorithm>
#include <cassert>
#include <iostream>
#include <vector>



namespace graph {

void addEdge(std::vector<std::vector<int>> *adj, int u, int v) {
    (*adj)[u - 1].push_back(v - 1);
    (*adj)[v - 1].push_back(u - 1);
}


void explore(const std::vector<std::vector<int>> *adj, int u,
             std::vector<bool> *visited) {
    (*visited)[u] = true;
    for (auto v : (*adj)[u]) {
        if (!(*visited)[v]) {
            explore(adj, v, visited);
        }
    }
}


int getConnectedComponents(const std::vector<std::vector<int>> *adj) {
    int n = adj->size();
    int connected_components = 0;
    std::vector<bool> visited(n, false);

    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            explore(adj, i, &visited);
            connected_components++;
        }
    }
    return connected_components;
}
}  

void tests() {
    std::cout << "Running predefined tests..." << std::endl;
    std::cout << "Initiating Test 1..." << std::endl;
    std::vector<std::vector<int>> adj1(9, std::vector<int>());
    graph::addEdge(&adj1, 1, 2);
    graph::addEdge(&adj1, 1, 3);
    graph::addEdge(&adj1, 3, 4);
    graph::addEdge(&adj1, 5, 7);
    graph::addEdge(&adj1, 5, 6);
    graph::addEdge(&adj1, 8, 9);

    assert(graph::getConnectedComponents(&adj1) == 3);
    std::cout << "Test 1 Passed..." << std::endl;

    std::cout << "Innitiating Test 2..." << std::endl;
    std::vector<std::vector<int>> adj2(10, std::vector<int>());
    graph::addEdge(&adj2, 1, 2);
    graph::addEdge(&adj2, 1, 3);
    graph::addEdge(&adj2, 1, 4);
    graph::addEdge(&adj2, 2, 3);
    graph::addEdge(&adj2, 3, 4);
    graph::addEdge(&adj2, 4, 8);
    graph::addEdge(&adj2, 4, 10);
    graph::addEdge(&adj2, 8, 10);
    graph::addEdge(&adj2, 8, 9);
    graph::addEdge(&adj2, 5, 7);
    graph::addEdge(&adj2, 5, 6);
    graph::addEdge(&adj2, 6, 7);

    assert(graph::getConnectedComponents(&adj2) == 2);
    std::cout << "Test 2 Passed..." << std::endl;
}


int main() {
        tests();

    int vertices = int(), edges = int();
    std::cout << "Enter the number of vertices : ";
    std::cin >> vertices;
    std::cout << "Enter the number of edges : ";
    std::cin >> edges;

    std::vector<std::vector<int>> adj(vertices, std::vector<int>());

    int u = int(), v = int();
    while (edges--) {
        std::cin >> u >> v;
        graph::addEdge(&adj, u, v);
    }

    int cc = graph::getConnectedComponents(&adj);
    std::cout << cc << std::endl;
    return 0;
}

#include <algorithm>
#include <cassert>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <string>
#include <vector>


namespace graph {
template <typename T>
class Graph {
    
    std::map<T, std::list<T> > adjacency_list;

 public:
    Graph() = default;
    ;
    void add_edge(T u, T v, bool bidir = true) {
        
        adjacency_list[u].push_back(v);          if (bidir == true) {
                        adjacency_list[v].push_back(u);          }
    }

    
    std::map<T, bool> breadth_first_search(T src) {
                std::map<T, bool> visited;
                        for (auto const &adjlist : adjacency_list) {
            visited[adjlist.first] = false;
            for (auto const &node : adjacency_list[adjlist.first]) {
                visited[node] = false;
            }
        }

                std::queue<T> tracker;

                tracker.push(src);
                visited[src] = true;
        while (!tracker.empty()) {
                                    T node = tracker.front();
                        tracker.pop();
            for (T const &neighbour : adjacency_list[node]) {
                                                if (!visited[neighbour]) {
                                        tracker.push(neighbour);
                                        visited[neighbour] = true;
                }
            }
        }
        return visited;
    }
};
}  

static void tests() {
        graph::Graph<int> g;
    std::map<int, bool> correct_result;
    g.add_edge(0, 1);
    g.add_edge(1, 2);
    g.add_edge(2, 3);
    correct_result[0] = true;
    correct_result[1] = true;
    correct_result[2] = true;
    correct_result[3] = true;

    std::map<int, bool> returned_result = g.breadth_first_search(2);

    assert(returned_result == correct_result);
    std::cout << "Test 1 Passed..." << std::endl;

        returned_result = g.breadth_first_search(0);

    assert(returned_result == correct_result);
    std::cout << "Test 2 Passed..." << std::endl;

        graph::Graph<std::string> g2;

    g2.add_edge("Gorakhpur", "Lucknow", false);
    g2.add_edge("Gorakhpur", "Kanpur", false);
    g2.add_edge("Lucknow", "Agra", false);
    g2.add_edge("Kanpur", "Agra", false);
    g2.add_edge("Lucknow", "Prayagraj", false);
    g2.add_edge("Agra", "Noida", false);

    std::map<std::string, bool> correct_res;
    std::map<std::string, bool> returned_res =
        g2.breadth_first_search("Kanpur");
    correct_res["Gorakhpur"] = false;
    correct_res["Lucknow"] = false;
    correct_res["Kanpur"] = true;
    correct_res["Agra"] = true;
    correct_res["Prayagraj"] = false;
    correct_res["Noida"] = true;
    assert(correct_res == returned_res);
    std::cout << "Test 3 Passed..." << std::endl;
}


int main() {
    tests();
    size_t edges = 0;
    std::cout << "Enter the number of edges: ";
    std::cin >> edges;

    graph::Graph<int> g;

    std::cout << "Enter space-separated pairs of vertices that form edges: "
              << std::endl;
    while (edges--) {
        int u = 0, v = 0;
        std::cin >> u >> v;
        g.add_edge(u, v);
    }

    g.breadth_first_search(0);
    return 0;
}


#include <array>     #include <cassert>   #include <climits>   #include <iostream>  

template <std::size_t SIZE>
int max_subarray_sum(std::array<int64_t, SIZE> arr, uint64_t length) {
    int64_t current_max = INT_MIN, current_sum = 0;
    for (int i = 0; i < length; i++) {
        current_sum = current_sum + arr[i];
        if (current_max < current_sum) {
            current_max = current_sum;
        }

        if (current_sum < 0) {
            current_sum = 0;
        }
    }
    return current_max;
}


static void test() {
    std::array<int64_t, 4> arr = {1, 2, 3, 4};
    std::array<int64_t, 5> arr1 = {-1, -2, -4, -6, 7};
    assert(max_subarray_sum(arr, 4) == 10);
    assert(max_subarray_sum(arr1, 5) == 7);
    std::cout << "All test cases have passed!\n";
}


int main() {
                    
                                                
            
    test();      return 0;
}

#include <iostream>
#ifdef _MSC_VER
#include <string>  #else
#include <cstring>
#endif


#define MAX 100

char stack[MAX];

int stack_idx = -1;

void push(char ch) { stack[++stack_idx] = ch; }

char pop() { return stack[stack_idx--]; }



char opening(char ch) {
    switch (ch) {
    case '}':
        return '{';
    case ']':
        return '[';
    case ')':
        return '(';
    case '>':
        return '<';
    }
    return '\0';
}

int main() {
    std::string exp;
    int valid = 1, i = 0;
    std::cout << "Enter The Expression : ";
    std::cin >> exp;

    while (valid == 1 && i < exp.length()) {
        if (exp[i] == '(' || exp[i] == '{' || exp[i] == '[' || exp[i] == '<') {
            push(exp[i]);
        } else if (stack_idx >= 0 && stack[stack_idx] == opening(exp[i])) {
            pop();
        } else {
            valid = 0;
        }
        i++;
    }

        if (valid == 1 && stack_idx == -1) {
        std::cout << "\nCorrect Expression";
    } else {
        std::cout << "\nWrong Expression";
    }

    return 0;
}


#include <cassert>   #include <iostream>  

class EasterYearMonthDay {
 public:
    uint64_t year;       uint64_t month;      uint64_t day;    
    EasterYearMonthDay(uint64_t newYear, uint64_t newMonth, uint64_t newDay) {
        year = newYear;          month = newMonth;
        day = newDay;
    }
};


EasterYearMonthDay findEaster(uint64_t y) {
    if (y > 1582) {
        uint64_t a = y % 19;           uint64_t b = y / 100;          uint64_t c = y % 100;
        uint64_t d = b / 4;
        uint64_t e = b % 4;          uint64_t f = (b + 8) / 25;
        uint64_t g = (b - f + 1) / 3;
        uint64_t h = (19 * a + b - d - g + 15) %
                     30;          uint64_t i = c / 4;
        uint64_t k = c % 4;
        uint64_t r =
            (32 + 2 * e + 2 * i - h - k) %
            7;          uint64_t m = (a + 11 * h + 22 * r) / 451;
        uint64_t n = (h + r - 7 * m + 114) / 31;          uint64_t p = (h + r - 7 * m + 114) % 31;  
                EasterYearMonthDay date(
            y, n, p + 1);  
                return date;
    } else {
        EasterYearMonthDay date(0, 0, 0);

                return date;
    }
}


static void test() {
        assert(findEaster(2003).month == 4);      assert(findEaster(2003).day == 20);   
        assert(findEaster(1910).month == 3);      assert(findEaster(1910).day == 27);   
        assert(findEaster(1877).month != 3);      assert(findEaster(1877).day != 22);   
        assert(findEaster(1400).month == 0);      assert(findEaster(1400).day == 0);    }


int main() {
    test();      return 0;
}

#include <algorithm>
#include <iostream>
#include <numeric>  #include <vector>


int main() {
        int arr[] = {10, 20, 5, 23, 42, 15};
    int n = sizeof(arr) / sizeof(arr[0]);
    std::vector<int> vect(arr, arr + n);

    std::cout << "Vector is: ";
    for (int i = 0; i < n; i++) std::cout << vect[i] << " ";

        std::sort(vect.begin(), vect.end());

    std::cout << "\nVector after sorting is: ";
    for (int i = 0; i < n; i++) std::cout << vect[i] << " ";

        std::reverse(vect.begin(), vect.end());

    std::cout << "\nVector after reversing is: ";
    for (int i = 0; i < 6; i++) std::cout << vect[i] << " ";

    std::cout << "\nMaximum element of vector is: ";
    std::cout << *max_element(vect.begin(), vect.end());

    std::cout << "\nMinimum element of vector is: ";
    std::cout << *min_element(vect.begin(), vect.end());

        std::cout << "\nThe summation of vector elements is: ";
    std::cout << accumulate(vect.begin(), vect.end(), 0);

    return 0;
}

#include <iostream>


bool IsPrime(int number) {
    if (((!(number & 1)) && number != 2) || (number < 2) ||
        (number % 3 == 0 && number != 3))
        return false;

    for (int k = 1; 36 * k * k - 12 * k < number; ++k) {
        if ((number % (6 * k + 1) == 0) || (number % (6 * k - 1) == 0))
            return false;
    }
    return true;
}


int main() {
        std::cout << "Enter the value of n to check if Prime\n";
    int n;
    std::cin >> n;
    if (IsPrime(n))
        std::cout << n << " is Prime" << std::endl;
    else
        std::cout << n << " is not Prime" << std::endl;

    return 0;
}

#include <iostream>


int main() {
    int l, st = 2, x, r, z, n, sp;
    std::cout << "enter Index ";
    std::cin >> x;
    z = x;
    for (r = 1; r <= x; r++) {
        z = z - 1;
        for (n = 1; n <= 2; n++) {
            for (sp = 1; sp <= z; sp++) {
                std::cout << " ";
            }
            for (l = 1; l <= st; l++) {
                std::cout << "*";
            }
            std::cout << std::endl;
        }
        st = st + 2;
    }
}


#include <cassert>        #include <iostream>       #include <list>           #include <unordered_map>  

namespace others {

namespace lru_cache {

class LRUCache {
    uint64_t pageFrame;             std::list<uint64_t> cache;      std::unordered_map<uint64_t, std::list<uint64_t>::iterator>
        pageMap;  
    uint64_t hits =
        0;          uint64_t pageFault = 0;                               
 public:
    
    explicit LRUCache(uint64_t pf) { pageFrame = pf; }

    
    void refer(uint64_t page) {
                if (pageMap.find(page) == pageMap.end()) {
            pageFault++;  
                        if (cache.size() == pageFrame) {
                                uint64_t lastPage = cache.back();
                cache.pop_back();
                pageMap.erase(lastPage);
            }
        }
                else {
            hits++;
                        cache.erase(pageMap[page]);
        }
                        cache.push_front(page);
        pageMap[page] = cache.begin();
    }

    
    void display() {
        for (uint64_t &it : cache) {
            std::cout << it << " ";
        }
        std::cout << std::endl;
    }
    
    uint64_t getHits() const { return hits; }
    
    uint64_t getPageFault() const { return pageFault; }
};

}  }  
namespace lru_tests {

template <typename T>
void log(T msg) {
        std::cout << "[TESTS] : ---> " << msg << std::endl;
}


static void test_1() {
    uint64_t expected_hits = 2;
    uint64_t expected_pageFault = 4;

    log("Running Test-1...");

    others::lru_cache::LRUCache cache(4);
    cache.refer(1);
    cache.refer(2);
    cache.refer(5);
    cache.refer(1);
    cache.refer(4);
    cache.refer(5);

    log("Checking assert statement...");
    assert(cache.getHits() == expected_hits &&
           cache.getPageFault() == expected_pageFault);
    log("Assert successful!");
    log("Test-1 complete!");
}


static void test_2() {
    uint64_t expected_hits = 4;
    uint64_t expected_pageFault = 2;

    log("Running Test-2...");

    others::lru_cache::LRUCache cache(4);
    cache.refer(1);
    cache.refer(1);
    cache.refer(1);
    cache.refer(1);
    cache.refer(1);
    cache.refer(5);

    log("Checking assert statement...");
    assert(cache.getHits() == expected_hits &&
           cache.getPageFault() == expected_pageFault);
    log("Assert successful!");
    log("Test-2 complete!");
}


static void test_3() {
    uint64_t expected_hits = 1;
    uint64_t expected_pageFault = 5;

    log("Running Test-3...");

    others::lru_cache::LRUCache cache(4);
    cache.refer(1);
    cache.refer(2);
    cache.refer(3);
    cache.refer(4);
    cache.refer(5);
    cache.refer(5);

    log("Checking assert statement...");
    assert(cache.getHits() == expected_hits &&
           cache.getPageFault() == expected_pageFault);
    log("Assert successful!");
    log("Test-3 complete!");
}


static void run_tests() {
    test_1();
    test_2();
    test_3();
    log("");
    log("TESTS COMPLETED!");
}
}  

int main() {
    lru_tests::run_tests();

        others::lru_cache::LRUCache cache(4);
    cache.refer(1);
    cache.refer(2);
    cache.refer(3);
    cache.refer(4);
    cache.refer(5);
    cache.refer(5);

    cache.display();

    std::cout << "Hits: " << cache.getHits()
              << " Miss: " << cache.getPageFault() << std::endl;
    return 0;
}


#include <cassert>   #include <iostream>  #include <vector>    

namespace others {


namespace recursive_tree_traversals {


struct Node {
    uint64_t data = 0;         struct Node *left{};       struct Node *right{};  };

class BT {
 public:
    std::vector<uint64_t>
        inorder_result;      std::vector<uint64_t>
        preorder_result;      std::vector<uint64_t> postorder_result;                                               
    Node *createNewNode(
        uint64_t);  
    std::vector<uint64_t> inorder(
        Node *);                        std::vector<uint64_t> preorder(
        Node *);                        std::vector<uint64_t> postorder(
        Node *);                    };


Node *BT::createNewNode(uint64_t data) {
    Node *node = new Node();
    node->data = data;
    node->left = node->right = nullptr;
    return node;
}


std::vector<uint64_t> BT::inorder(Node *root) {
    if (root == nullptr) {          return {};
    }

    inorder(root->left);      BT::inorder_result.push_back(
        root->data);      inorder(root->right);  
    return inorder_result;
}


std::vector<uint64_t> BT::preorder(Node *root) {
    if (root == nullptr) {          return {};
    }

    BT::preorder_result.push_back(
        root->data);      preorder(root->left);       preorder(root->right);  
    return preorder_result;
}


std::vector<uint64_t> BT::postorder(Node *root) {
    if (root == nullptr) {          return {};
    }

    postorder(root->left);       postorder(root->right);      BT::postorder_result.push_back(
        root->data);  
    return postorder_result;
}

}  
}  

void test1() {
    others::recursive_tree_traversals::BT obj1;
    others::recursive_tree_traversals::Node *root = obj1.createNewNode(2);
    root->left = obj1.createNewNode(7);
    root->right = obj1.createNewNode(5);
    root->left->left = obj1.createNewNode(2);
    root->left->right = obj1.createNewNode(6);
    root->right->right = obj1.createNewNode(9);
    root->left->right->left = obj1.createNewNode(5);
    root->left->right->right = obj1.createNewNode(11);
    root->right->right->left = obj1.createNewNode(4);

    std::vector<uint64_t> actual_result_inorder{2, 7, 5, 6, 11, 2, 5, 4, 9};
    std::vector<uint64_t> actual_result_preorder{2, 7, 2, 6, 5, 11, 5, 9, 4};
    std::vector<uint64_t> actual_result_postorder{2, 5, 11, 6, 7, 4, 9, 5, 2};
    std::vector<uint64_t> result_inorder;                                                     std::vector<uint64_t> result_preorder;                                                    std::vector<uint64_t> result_postorder;                                               
    uint64_t size = actual_result_inorder.size();

            result_inorder = obj1.inorder(root);
    std::cout << "Testcase #1: Inorder Traversal...";
    for (auto i = 0; i < size; ++i) {
        assert(actual_result_inorder[i] == result_inorder[i]);
    }
    std::cout << "Passed!" << std::endl;

            result_preorder = obj1.preorder(root);
    std::cout << "Testcase #1: Preorder Traversal...";
    for (auto i = 0; i < size; ++i) {
        assert(actual_result_preorder[i] == result_preorder[i]);
    }
    std::cout << "Passed!" << std::endl;

            result_postorder = obj1.postorder(root);
    std::cout << "Testcase #1: Postorder Traversal...";
    for (auto i = 0; i < size; ++i) {
        assert(actual_result_postorder[i] == result_postorder[i]);
    }
    std::cout << "Passed!" << std::endl;

    std::cout << std::endl;
}


void test2() {
    others::recursive_tree_traversals::BT obj2;
    others::recursive_tree_traversals::Node *root = obj2.createNewNode(1);
    root->left = obj2.createNewNode(2);
    root->right = obj2.createNewNode(3);
    root->left->left = obj2.createNewNode(4);
    root->right->left = obj2.createNewNode(5);
    root->right->right = obj2.createNewNode(6);
    root->right->left->left = obj2.createNewNode(7);
    root->right->left->right = obj2.createNewNode(8);

    std::vector<uint64_t> actual_result_inorder{4, 2, 1, 7, 5, 8, 3, 6};
    std::vector<uint64_t> actual_result_preorder{1, 2, 4, 3, 5, 7, 8, 6};
    std::vector<uint64_t> actual_result_postorder{4, 2, 7, 8, 5, 6, 3, 1};
    std::vector<uint64_t> result_inorder;                                                     std::vector<uint64_t> result_preorder;                                                    std::vector<uint64_t> result_postorder;                                               
    uint64_t size = actual_result_inorder.size();

            result_inorder = obj2.inorder(root);
    std::cout << "Testcase #2: Inorder Traversal...";
    for (auto i = 0; i < size; ++i) {
        assert(actual_result_inorder[i] == result_inorder[i]);
    }
    std::cout << "Passed!" << std::endl;

            result_preorder = obj2.preorder(root);
    std::cout << "Testcase #2: Preorder Traversal...";
    for (auto i = 0; i < size; ++i) {
        assert(actual_result_preorder[i] == result_preorder[i]);
    }
    std::cout << "Passed!" << std::endl;

            result_postorder = obj2.postorder(root);
    std::cout << "Testcase #2: Postorder Traversal...";
    for (auto i = 0; i < size; ++i) {
        assert(actual_result_postorder[i] == result_postorder[i]);
    }
    std::cout << "Passed!" << std::endl;

    std::cout << std::endl;
}


void test3() {
    others::recursive_tree_traversals::BT obj3;
    others::recursive_tree_traversals::Node *root = obj3.createNewNode(1);
    root->left = obj3.createNewNode(2);
    root->right = obj3.createNewNode(3);
    root->left->left = obj3.createNewNode(4);
    root->left->right = obj3.createNewNode(5);

    std::vector<uint64_t> actual_result_inorder{4, 2, 5, 1, 3};
    std::vector<uint64_t> actual_result_preorder{1, 2, 4, 5, 3};
    std::vector<uint64_t> actual_result_postorder{4, 5, 2, 3, 1};
    std::vector<uint64_t> result_inorder;                                                     std::vector<uint64_t> result_preorder;                                                    std::vector<uint64_t> result_postorder;                                               
    uint64_t size = actual_result_inorder.size();

        
    result_inorder = obj3.inorder(root);
    std::cout << "Testcase #3: Inorder Traversal...";
    for (auto i = 0; i < size; ++i) {
        assert(actual_result_inorder[i] == result_inorder[i]);
    }
    std::cout << "Passed!" << std::endl;

            result_preorder = obj3.preorder(root);
    std::cout << "Testcase #3: Preorder Traversal...";
    for (auto i = 0; i < size; ++i) {
        assert(actual_result_preorder[i] == result_preorder[i]);
    }
    std::cout << "Passed!" << std::endl;

            result_postorder = obj3.postorder(root);
    std::cout << "Testcase #3: Postorder Traversal...";
    for (auto i = 0; i < size; ++i) {
        assert(actual_result_postorder[i] == result_postorder[i]);
    }
    std::cout << "Passed!" << std::endl;

    std::cout << std::endl;
}


static void tests() {
    std::cout << "1st test-case" << std::endl;
    test1();      std::cout << "2nd test-case" << std::endl;
    test2();      std::cout << "3rd test-case" << std::endl;
    test3();  }

int main() {
    tests();      return 0;
}

#include <algorithm>  #include <array>      #include <cassert>    #include <iostream>   #include <string>     

namespace others {

namespace postfix_expression {
 
class Stack {
 public:
    std::array<float, 20> stack{};     int stackTop = -1;            };


void push(float operand, Stack *stack) {
    stack->stackTop++;
    stack->stack[stack->stackTop] = operand;
}


float pop(Stack *stack) {
    float operand = stack->stack[stack->stackTop];
    stack->stackTop--;
    return operand;
}


bool is_number(const std::string &s) {
    return !s.empty() && std::all_of(s.begin(), s.end(), ::isdigit);
}


void evaluate(float a, float b, const std::string &operation, Stack *stack) {
    float c = 0;
    const char *op = operation.c_str();
    switch (*op) {
        case '+':
            c = a + b;             others::postfix_expression::push(c, stack);
            break;

        case '-':
            c = a - b;             others::postfix_expression::push(c, stack);
            break;

        case '*':
            c = a * b;             others::postfix_expression::push(c, stack);
            break;

        case '/':
            c = a / b;             others::postfix_expression::push(c, stack);
            break;

        default:
            std::cout << "Operator not defined\n";
            break;
    }
}


template <std::size_t N>
float postfix_evaluation(std::array<std::string, N> input) {
    Stack stack;
    int j = 0;

    while (j < N) {
        std::string scan = input[j];
        if (is_number(scan)) {
            push(std::stof(scan), &stack);

        } else {
            float op2 = pop(&stack);
            float op1 = pop(&stack);

            evaluate(op1, op2, scan, &stack);
        }
        j++;
    }

    std::cout << stack.stack[stack.stackTop] << "\n";

    return stack.stack[stack.stackTop];
}
}  }  


static void test_function_1() {
    std::array<std::string, 7> input = {"2", "3", "1", "*", "+", "9", "-"};

    float answer = others::postfix_expression::postfix_evaluation(input);

    assert(answer == -4);
}


static void test_function_2() {
    std::array<std::string, 9> input = {"100", "200", "+", "2", "/",
                                        "5",   "*",   "7", "+"};
    float answer = others::postfix_expression::postfix_evaluation(input);

    assert(answer == 757);
}


int main() {
    test_function_1();
    test_function_2();

    std::cout << "\nTest implementations passed!\n";

    return 0;
}

#include <iostream>


void method1(int number) {
    int remainder, binary = 0, var = 1;

    do {
        remainder = number % 2;
        number = number / 2;
        binary = binary + (remainder * var);
        var = var * 10;
    } while (number > 0);
    std::cout << "Method 1 : " << binary << std::endl;
}


void method2(int number) {
    int num_bits = 0;
    char bit_string[50];

    do {
        bool bit = number & 0x01;          if (bit)
            bit_string[num_bits++] = '1';
        else
            bit_string[num_bits++] = '0';
        number >>= 1;      } while (number > 0);

    std::cout << "Method 2 : ";
    while (num_bits >= 0)
        std::cout << bit_string[num_bits--];      std::cout << std::endl;
}

int main() {
    int number;
    std::cout << "Enter a number:";
    std::cin >> number;

    method1(number);
    method2(number);

    return 0;
}


#include <iostream>


int main() {
    int m, n;
    int counterZeros = 0;

    std::cout << "Enter dimensions of matrix (seperated with space): ";
    std::cin >> m;
    std::cin >> n;

    int **a = new int *[m];
    for (int i = 0; i < m; i++) a[i] = new int[n];

    std::cout << "Enter matrix elements:";
    std::cout << "\n";

        for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << "element? ";
            std::cin >> a[i][j];
        }
    }

        for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (a[i][j] == 0)
                counterZeros++;          }
    }

        if (counterZeros > ((m * n) / 2))          std::cout << "Sparse matrix";
    else
        std::cout << "Not a sparse matrix";

    for (int i = 0; i < m; i++) delete[] a[i];
    delete[] a;
    return 0;
}

#include <cmath>
#include <iostream>
#include <vector>


struct Point {
    double x, 
        y;    

    
    explicit Point(double a = 0.f, double b = 0.f) {
        x = a;
        y = b;
    }
};


double LenghtLine(const Point &A, const Point &B) {
    double dx = B.x - A.x;
    double dy = B.y - A.y;
    return std::sqrt((dx * dx) + (dy * dy));
}


double TriangleArea(const Point &A, const Point &B, const Point &C) {
    double a = LenghtLine(A, B);
    double b = LenghtLine(B, C);
    double c = LenghtLine(C, A);
    double p = (a + b + c) / 2;
    return std::sqrt(p * (p - a) * (p - b) * (p - c));
}


bool PointInCircle(const std::vector<Point> &P, const Point &Center, double R) {
    for (size_t i = 0; i < P.size(); i++) {
        if (LenghtLine(P[i], Center) > R)
            return false;
    }
    return true;
}


double circle(const std::vector<Point> &P) {
    double minR = INFINITY;
    double R;
    Point C;
    Point minC;

        for (size_t i = 0; i < P.size() - 2; i++)
                for (size_t j = i + 1; j < P.size(); j++)
                        for (size_t k = j + 1; k < P.size(); k++) {
                                                                C.x = -0.5 * ((P[i].y * (P[j].x * P[j].x + P[j].y * P[j].y -
                                         P[k].x * P[k].x - P[k].y * P[k].y) +
                               P[j].y * (P[k].x * P[k].x + P[k].y * P[k].y -
                                         P[i].x * P[i].x - P[i].y * P[i].y) +
                               P[k].y * (P[i].x * P[i].x + P[i].y * P[i].y -
                                         P[j].x * P[j].x - P[j].y * P[j].y)) /
                              (P[i].x * (P[j].y - P[k].y) +
                               P[j].x * (P[k].y - P[i].y) +
                               P[k].x * (P[i].y - P[j].y)));
                C.y = 0.5 * ((P[i].x * (P[j].x * P[j].x + P[j].y * P[j].y -
                                        P[k].x * P[k].x - P[k].y * P[k].y) +
                              P[j].x * (P[k].x * P[k].x + P[k].y * P[k].y -
                                        P[i].x * P[i].x - P[i].y * P[i].y) +
                              P[k].x * (P[i].x * P[i].x + P[i].y * P[i].y -
                                        P[j].x * P[j].x - P[j].y * P[j].y)) /
                             (P[i].x * (P[j].y - P[k].y) +
                              P[j].x * (P[k].y - P[i].y) +
                              P[k].x * (P[i].y - P[j].y)));
                R = (LenghtLine(P[i], P[j]) * LenghtLine(P[j], P[k]) *
                     LenghtLine(P[k], P[i])) /
                    (4 * TriangleArea(P[i], P[j], P[k]));
                if (!PointInCircle(P, C, R)) {
                    continue;
                }
                if (R <= minR) {
                    minR = R;
                    minC = C;
                }
            }

        for (size_t i = 0; i < P.size() - 1; i++)
                for (size_t j = i + 1; j < P.size(); j++) {
                        C.x = (P[i].x + P[j].x) / 2;
            C.y = (P[i].y + P[j].y) / 2;
            R = LenghtLine(C, P[i]);
            if (!PointInCircle(P, C, R)) {
                continue;
            }
            if (R <= minR) {
                minR = R;
                minC = C;
            }
        }
    std::cout << minC.x << " " << minC.y << std::endl;
    return minR;
}


void test() {
    std::vector<Point> Pv;
    Pv.push_back(Point(0, 0));
    Pv.push_back(Point(5, 4));
    Pv.push_back(Point(1, 3));
    Pv.push_back(Point(4, 1));
    Pv.push_back(Point(3, -2));
    std::cout << circle(Pv) << std::endl;
}


void test2() {
    std::vector<Point> Pv;
    Pv.push_back(Point(0, 0));
    Pv.push_back(Point(0, 2));
    Pv.push_back(Point(2, 2));
    Pv.push_back(Point(2, 0));
    std::cout << circle(Pv) << std::endl;
}


void test3() {
    std::vector<Point> Pv;
    Pv.push_back(Point(0.5, 1));
    Pv.push_back(Point(3.5, 3));
    Pv.push_back(Point(2.5, 0));
    Pv.push_back(Point(2, 1.5));
    std::cout << circle(Pv) << std::endl;
}


int main() {
    test();
    std::cout << std::endl;
    test2();
    std::cout << std::endl;
    test3();
    return 0;
}


#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>


std::string fill(char c, int n) {
    std::string s = "";
    while (n--) s += c;
    return s;
}


std::string tolowerRoman(int n) {
    if (n < 4)
        return fill('i', n);
    if (n < 6)
        return fill('i', 5 - n) + "v";
    if (n < 9)
        return std::string("v") + fill('i', n - 5);
    if (n < 11)
        return fill('i', 10 - n) + "x";
    if (n < 40)
        return fill('x', n / 10) + tolowerRoman(n % 10);
    if (n < 60)
        return fill('x', 5 - n / 10) + 'l' + tolowerRoman(n % 10);
    if (n < 90)
        return std::string("l") + fill('x', n / 10 - 5) + tolowerRoman(n % 10);
    if (n < 110)
        return fill('x', 10 - n / 10) + "c" + tolowerRoman(n % 10);
    if (n < 400)
        return fill('c', n / 100) + tolowerRoman(n % 100);
    if (n < 600)
        return fill('c', 5 - n / 100) + 'd' + tolowerRoman(n % 100);
    if (n < 900)
        return std::string("d") + fill('c', n / 100 - 5) +
               tolowerRoman(n % 100);
    if (n < 1100)
        return fill('c', 10 - n / 100) + "m" + tolowerRoman(n % 100);
    if (n < 4000)
        return fill('m', n / 1000) + tolowerRoman(n % 1000);
    return "?";
}


std::string toupperRoman(int n) {
    if (n < 4)
        return fill('I', n);
    if (n < 6)
        return fill('I', 5 - n) + "V";
    if (n < 9)
        return std::string("V") + fill('I', n - 5);
    if (n < 11)
        return fill('I', 10 - n) + "X";
    if (n < 40)
        return fill('X', n / 10) + toupperRoman(n % 10);
    if (n < 60)
        return fill('X', 5 - n / 10) + 'L' + toupperRoman(n % 10);
    if (n < 90)
        return std::string("L") + fill('X', n / 10 - 5) + toupperRoman(n % 10);
    if (n < 110)
        return fill('X', 10 - n / 10) + "C" + toupperRoman(n % 10);
    if (n < 400)
        return fill('C', n / 100) + toupperRoman(n % 100);
    if (n < 600)
        return fill('C', 5 - n / 100) + 'D' + toupperRoman(n % 100);
    if (n < 900)
        return std::string("D") + fill('C', n / 100 - 5) +
               toupperRoman(n % 100);
    if (n < 1100)
        return fill('C', 10 - n / 100) + "M" + toupperRoman(n % 100);
    if (n < 4000)
        return fill('M', n / 1000) + toupperRoman(n % 1000);
    return "?";
}


int main() {
    int n;
    std::cout << "\t\tRoman numbers converter\n\n";
    std::cout << "Type in decimal number between 0 up to 4000 (exclusive): ";
    std::cin >> n;
    std::cout << n << " in Upper Roman Numerals is " << toupperRoman(n) << "\n";
    std::cout << n << " in Lower Roman Numerals is " << tolowerRoman(n) << "\n";
    return 0;
}


#include <iostream>


template <typename T>
bool is_happy(T n) {
    T s = 0;                  while (n > 9) {               while (n != 0) {              T d = n % 10;
            s += d;
            n /= 10;
        }
        n = s;
        s = 0;
    }
    return (n == 1) ? true : false;  }


int main() {
    int n;
    std::cout << "Enter a number:";
    std::cin >> n;

    if (is_happy(n))
        std::cout << n << " is a happy number" << std::endl;
    else
        std::cout << n << " is not a happy number" << std::endl;
    return 0;
}

#include <iostream>


int main() {
    int n, t;
    std::cin >> t;
    while (t--) {
        std::cin >> n;
        if ((n % 7 == 0) || (n % 10 == 7))
            std::cout << n << " is a buzz number" << std::endl;
        else
            std::cout << n << " is not a buzz number" << std::endl;
    }
    return 0;
}


#include <iostream>
#include <vector>

using std::cin;
using std::cout;
using std::vector;

#define ll int64_t

#define endl std::endl

#define pb push_back
#define MOD 1000000007


ll mat_size;


vector<ll> fib_b, fib_c;


vector<vector<ll>> multiply(const vector<vector<ll>> &A,
                            const vector<vector<ll>> &B) {
    vector<vector<ll>> C(mat_size + 1, vector<ll>(mat_size + 1));
    for (ll i = 1; i <= mat_size; i++) {
        for (ll j = 1; j <= mat_size; j++) {
            for (ll z = 1; z <= mat_size; z++) {
                C[i][j] = (C[i][j] + (A[i][z] * B[z][j]) % MOD) % MOD;
            }
        }
    }
    return C;
}


vector<vector<ll>> power(const vector<vector<ll>> &A, ll p) {
    if (p == 1)
        return A;
    if (p % 2 == 1) {
        return multiply(A, power(A, p - 1));
    } else {
        vector<vector<ll>> X = power(A, p / 2);
        return multiply(X, X);
    }
}

ll ans(ll n) {
    if (n == 0)
        return 0;
    if (n <= mat_size)
        return fib_b[n - 1];
        vector<ll> F1(mat_size + 1);
    for (ll i = 1; i <= mat_size; i++) F1[i] = fib_b[i - 1];

        vector<vector<ll>> T(mat_size + 1, vector<ll>(mat_size + 1));
    for (ll i = 1; i <= mat_size; i++) {
        for (ll j = 1; j <= mat_size; j++) {
            if (i < mat_size) {
                if (j == i + 1)
                    T[i][j] = 1;
                else
                    T[i][j] = 0;
                continue;
            }
            T[i][j] = fib_c[mat_size - j];
        }
    }
        T = power(T, n - 1);

        ll res = 0;
    for (ll i = 1; i <= mat_size; i++) {
        res = (res + (T[1][i] * F1[i]) % MOD) % MOD;
    }
    return res;
}


int main() {
    cin.tie(0);
    cout.tie(0);
    ll t;
    cin >> t;
    ll i, j, x;
    while (t--) {
        cin >> mat_size;
        for (i = 0; i < mat_size; i++) {
            cin >> x;
            fib_b.pb(x);
        }
        for (i = 0; i < mat_size; i++) {
            cin >> x;
            fib_c.pb(x);
        }
        cin >> x;
        cout << ans(x) << endl;
        fib_b.clear();
        fib_c.clear();
    }
    return 0;
}

#include <iostream>


struct tower {
        int values[10];
        int top;
};


void show(const struct tower *const F, const struct tower *const T,
          const struct tower *const U) {
    std::cout << "\n\n\tF : ";
    for (int i = 0; i < F->top; i++) {
        std::cout << F->values[i] << "\t";
    }
    std::cout << "\n\tU : ";
    for (int i = 0; i < U->top; i++) {
        std::cout << U->values[i] << "\t";
    }
    std::cout << "\n\tT : ";
    for (int i = 0; i < T->top; i++) {
        std::cout << T->values[i] << "\t";
    }
}


void mov(tower *From, tower *To) {
    --From->top;
    To->values[To->top] = From->values[From->top];
    ++To->top;
}


void TH(int n, tower *From, tower *Using, tower *To) {
    if (n == 1) {
        mov(From, To);
        show(From, To, Using);
    } else {
        TH(n - 1, From, To, Using);
        mov(From, To);
        show(From, To, Using);
        TH(n - 1, Using, From, To);
    }
}


int main() {
    struct tower F, U, T;

    F.top = 0;
    U.top = 0;
    T.top = 0;

    int no;

    std::cout << "\nEnter number of discs : ";
    std::cin >> no;

    for (int i = no; i > 0; i--) {
        F.values[F.top++] = i;
    }

    show(&F, &T, &U);
    TH(no, &F, &U, &T);

    return 0;
}

#include <iostream>


void genArray(int **a, int r, int c) {
    int value = 1;
    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            a[i][j] = value;
            std::cout << a[i][j] << " ";
            value++;
        }
        std::cout << std::endl;
    }
}


void spiralPrint(int **a, int r, int c) {
    int startRow = 0, endRow = r - 1;
    int startCol = 0, endCol = c - 1;
    int cnt = 0;

    while (startRow <= endRow && startCol <= endCol) {
                for (int i = startCol; i <= endCol; i++, cnt++) {
            std::cout << a[startRow][i] << " ";
        }
        startRow++;

                for (int i = startRow; i <= endRow; i++, cnt++) {
            std::cout << a[i][endCol] << " ";
        }
        endCol--;

                if (cnt == r * c) {
            break;
        }

        for (int i = endCol; i >= startCol; i--, cnt++) {
            std::cout << a[endRow][i] << " ";
        }
        endRow--;

                if (cnt == r * c) {
            break;
        }
        for (int i = endRow; i >= startRow; i--, cnt++) {
            std::cout << a[i][startCol] << " ";
        }
        startCol++;
    }
}


int main() {
    int r, c;
    std::cin >> r >> c;
    int **a = new int *[r];
    for (int i = 0; i < r; i++) a[i] = new int[c];

    genArray(a, r, c);
    spiralPrint(a, r, c);

    for (int i = 0; i < r; i++) delete[] a[i];
    delete[] a;
    return 0;
}

#ifdef _MSC_VER
#include <string>  #else
#include <cstring>
#endif
#include <iomanip>
#include <iostream>


void show_pascal(int **arr, int n) {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n + i; ++j) {
            if (arr[i][j] == 0)
                std::cout << std::setw(4) << " ";
            else
                std::cout << std::setw(4) << arr[i][j];
        }
        std::cout << std::endl;
    }
}


int **pascal_triangle(int **arr, int n) {
    for (int i = 0; i < n; ++i) {
        for (int j = n - i - 1; j < n + i; ++j) {
            if (j == n - i - 1 || j == n + i - 1)
                arr[i][j] = 1;              else
                arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j + 1];
        }
    }

    return arr;
}


int main() {
    int n = 0;

    std::cout << "Set Pascal's Triangle Height" << std::endl;
    std::cin >> n;

        int **arr = new int *[n];
    for (int i = 0; i < n; ++i) {
        arr[i] = new int[2 * n - 1];
        memset(arr[i], 0, sizeof(int) * (2 * n - 1));
    }

    pascal_triangle(arr, n);
    show_pascal(arr, n);

        for (int i = 0; i < n; ++i) {
        delete[] arr[i];
    }
    delete[] arr;

    return 0;
}

#include <algorithm>  #include <cassert>    #include <iostream>   #include <stack>      #include <vector>     

namespace others {

namespace iterative_tree_traversals {

struct Node {
    int64_t data = 0;          struct Node *left{};       struct Node *right{};  };


class BinaryTree {
 public:
    Node *createNewNode(
        int64_t);      std::vector<int64_t> preOrderIterative(
        Node *);                        std::vector<int64_t> postOrderIterative(
        Node *);                        std::vector<int64_t> inOrderIterative(
        Node *);                    };


Node *BinaryTree::createNewNode(int64_t data) {
    Node *node = new Node();
    node->data = data;
    node->left = node->right = nullptr;
    return node;
}


std::vector<int64_t> BinaryTree::preOrderIterative(Node *root) {
    std::stack<Node *>
        stack;      std::vector<int64_t> result;  
    stack.push(root);

    while (!stack.empty()) {
        result.push_back(stack.top()->data);
        Node *current = stack.top();
        stack.pop();

        if (current->right) {
            stack.push(current->right);
        }
        if (current->left) {
            stack.push(current->left);
        }
    }

    return result;
}


std::vector<int64_t> BinaryTree::postOrderIterative(Node *root) {
    std::stack<Node *>
        stack;      std::vector<int64_t> result;  
    stack.push(root);

    while (!stack.empty()) {
        result.push_back(stack.top()->data);
        Node *current = stack.top();
        stack.pop();

        if (current->left) {
            stack.push(current->left);
        }
        if (current->right) {
            stack.push(current->right);
        }
    }

    reverse(result.begin(), result.end());

    return result;
}


std::vector<int64_t> BinaryTree::inOrderIterative(Node *root) {
    std::stack<Node *>
        stack;      std::vector<int64_t> result;  
    Node *current = root;

    while (!stack.empty() || current) {
        while (current) {
            stack.push(current);
            current = current->left;
        }
        current = stack.top();
        stack.pop();
        result.push_back(current->data);
        current = current->right;
    }
    return result;
}
}  }  

static void test1(others::iterative_tree_traversals::BinaryTree binaryTree,
                  others::iterative_tree_traversals::Node *root) {
    std::vector<int64_t> actual_result{1, 2, 4, 5, 3};
    std::vector<int64_t>
        result;  
            result = binaryTree.preOrderIterative(root);

        for (int i = 0; i < result.size(); i++) {
        assert(actual_result[i] == result[i]);
    }

        std::cout << "\nPreOrder Traversal Is : " << std::endl;
    for (auto i : result) {
        std::cout << i << "  ";
    }
}


static void test2(others::iterative_tree_traversals::BinaryTree binaryTree,
                  others::iterative_tree_traversals::Node *root) {
    std::vector<int64_t> actual_result{4, 5, 2, 3, 1};
    std::vector<int64_t>
        result;  
            result = binaryTree.postOrderIterative(root);

        for (int i = 0; i < result.size(); i++) {
        assert(actual_result[i] == result[i]);
    }

        std::cout << "\nPostOrder Traversal Is : " << std::endl;
    for (auto i : result) {
        std::cout << i << "  ";
    }
}


static void test3(others::iterative_tree_traversals::BinaryTree binaryTree,
                  others::iterative_tree_traversals::Node *root) {
    std::vector<int64_t> actual_result{4, 2, 5, 1, 3};
    std::vector<int64_t>
        result;  
            result = binaryTree.inOrderIterative(root);

        for (int i = 0; i < result.size(); i++) {
        assert(actual_result[i] == result[i]);
    }

        std::cout << "\nInOrder Traversal Is : " << std::endl;
    for (auto i : result) {
        std::cout << i << "  ";
    }
}


static void test4(others::iterative_tree_traversals::BinaryTree binaryTree,
                  others::iterative_tree_traversals::Node *root) {
    std::vector<int64_t> actual_result{-1, -2, -4, -5, -3};
    std::vector<int64_t>
        result;  
            result = binaryTree.preOrderIterative(root);

        for (int i = 0; i < result.size(); i++) {
        assert(actual_result[i] == result[i]);
    }

        std::cout << "\nPreOrder Traversal Is : " << std::endl;
    for (auto i : result) {
        std::cout << i << "  ";
    }
}


static void test5(others::iterative_tree_traversals::BinaryTree binaryTree,
                  others::iterative_tree_traversals::Node *root) {
    std::vector<int64_t> actual_result{-4, -5, -2, -3, -1};
    std::vector<int64_t>
        result;  
            result = binaryTree.postOrderIterative(root);

        for (int i = 0; i < result.size(); i++) {
        assert(actual_result[i] == result[i]);
    }

        std::cout << "\nPostOrder Traversal Is : " << std::endl;
    for (auto i : result) {
        std::cout << i << "  ";
    }
}


static void test6(others::iterative_tree_traversals::BinaryTree binaryTree,
                  others::iterative_tree_traversals::Node *root) {
    std::vector<int64_t> actual_result{-4, -2, -5, -1, -3};
    std::vector<int64_t>
        result;  
            result = binaryTree.inOrderIterative(root);

        for (int i = 0; i < result.size(); i++) {
        assert(actual_result[i] == result[i]);
    }

        std::cout << "\nInOrder Traversal Is : " << std::endl;
    for (auto i : result) {
        std::cout << i << "  ";
    }
}


int main() {


    others::iterative_tree_traversals::BinaryTree
        binaryTree;                           others::iterative_tree_traversals::Node *root = binaryTree.createNewNode(1);
    root->left = binaryTree.createNewNode(2);
    root->right = binaryTree.createNewNode(3);
    root->left->left = binaryTree.createNewNode(4);
    root->left->right = binaryTree.createNewNode(5);

    std::cout << "\n| Tests for positive data value |" << std::endl;
    test1(binaryTree, root);      std::cout << "\nPre-order test Passed!" << std::endl;

    test2(binaryTree, root);      std::cout << "\nPost-order test Passed!" << std::endl;

    test3(binaryTree, root);      std::cout << "\nIn-order test Passed!" << std::endl;

        root->data = -1;
    root->left->data = -2;
    root->right->data = -3;
    root->left->left->data = -4;
    root->left->right->data = -5;

    std::cout << "\n| Tests for negative data values |" << std::endl;
    test4(binaryTree, root);      std::cout << "\nPre-order test on-negative value Passed!" << std::endl;

    test5(binaryTree, root);      std::cout << "\nPost-order test on-negative value Passed!" << std::endl;

    test6(binaryTree, root);      std::cout << "\nIn-order test on-negative value Passed!" << std::endl;

    return 0;
}


#include <iostream>


int main(void) {
    int valueToConvert = 0;      int hexArray[8];             int i = 0;                   char HexValues[] = "0123456789ABCDEF";

    std::cout << "Enter a Decimal Value"
              << std::endl;      std::cin >>
        valueToConvert;  
    while (valueToConvert > 15) {                     hexArray[i++] = valueToConvert % 16;          valueToConvert /= 16;
            }
    hexArray[i] = valueToConvert;  
    std::cout << "Hex Value: ";
    while (i >= 0) std::cout << HexValues[hexArray[i--]];

    std::cout << std::endl;
    return 0;
}

#include <iostream>


void fastinput(int *number) {
        bool negative = false;
    register int c;
    *number = 0;

        c = std::getchar();
    if (c == '-') {
                negative = true;

                c = std::getchar();
    }

            for (; (c > 47 && c < 58); c = std::getchar())
        *number = *number * 10 + c - 48;

            if (negative)
        *(number) *= -1;
}


int main() {
    int number;
    fastinput(&number);
    std::cout << number << std::endl;
    return 0;
}

#include <algorithm>
#include <iostream>

#ifdef _MSC_VER
#include <string>
#else
#include <cstring>
#endif


int main() {
    int num;
    std::cout << "Enter number = ";
    std::cin >> num;

    std::string s1 = std::to_string(num);      std::string s2 = s1;

    std::reverse(s1.begin(), s1.end());  
    if (s1 == s2)          std::cout << "true";
    else
        std::cout << "false";

    return 0;
}
#include <iosrteam>
using namespace std;

int max(int a, int b) { return (a > b) ? a : b; }

int main() {
    char str1[] = "DEFBCD";
    char str2[] = "ABDEFJ";
    int i, j, k;
    int n = strlen(str1) + 1;
    int m = strlen(str2) + 1;
        int a[m][n];

    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (i == 0 || j == 0)
                a[i][j] = 0;

            else if (str1[i - 1] == str2[j - 1])
                a[i][j] = a[i - 1][j - 1] + 1;

            else
                a[i][j] = 0;
        }
    }

    
    for(i=0;i<m;i++)
        {
            for(j=0;j<n;j++)
                cout<<a[i][j]<<" ";
            cout<<"\n";
        }*/

    int ma = -1;
    int indi, indj;
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (a[i][j] > ma) {
                ma = a[i][j];
                indi = i;
                indj = j;
            }
        }
    }

    cout << str1 << "\n";
    cout << str2 << "\n";

    cout << "longest string size = " << ma << "\n";
    for (i = indi - 3; i < indi; i++) cout << str1[i];
    cout << "\n";
}
#include <climits>
#include <iostream>
#include <string>

using std::cin;
using std::cout;
using std::endl;

class Graph {
 public:
    int vertexNum;
    int **edges;

        Graph(int V) {
        this->vertexNum = V;
        this->edges = new int *[V];
        for (int i = 0; i < V; i++) {
            this->edges[i] = new int[V];
            for (int j = 0; j < V; j++) this->edges[i][j] = INT_MAX;
            this->edges[i][i] = 0;
        }
    }

    ~Graph() {
        for (int i = 0; i < vertexNum; i++) delete[] edges[i];
        delete[] edges;
    }

        void addEdge(int src, int dst, int weight) {
        this->edges[src][dst] = weight;
    }
};

void print(int dist[], int V) {
    cout << "\nThe Distance matrix for Floyd - Warshall" << endl;
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            if (dist[i * V + j] != INT_MAX)
                cout << dist[i * V + j] << "\t";
            else
                cout << "INF"
                     << "\t";
        }
        cout << endl;
    }
}

void FloydWarshall(Graph graph) {
    int V = graph.vertexNum;
    int dist[V][V];

        for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++) dist[i][j] = graph.edges[i][j];

        for (int k = 0; k < V; k++)
        
        for (int i = 0; i < V; i++)
            
            for (int j = 0; j < V; j++)
                
                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX &&
                    dist[i][k] + dist[k][j] < dist[i][j])
                                                            dist[i][j] = dist[i][k] + dist[k][j];

        int dist1d[V * V];
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++) dist1d[i * V + j] = dist[i][j];

    print(dist1d, V);
}

int main() {
    int V, E;
    int src, dst, weight;
    cout << "Enter number of vertices: ";
    cin >> V;
    cout << "Enter number of edges: ";
    cin >> E;
    Graph G(V);
    for (int i = 0; i < E; i++) {
        cout << "\nEdge " << i + 1 << "\nEnter source: ";
        cin >> src;
        cout << "Enter destination: ";
        cin >> dst;
        cout << "Enter weight: ";
        cin >> weight;
        G.addEdge(src, dst, weight);
    }
    FloydWarshall(G);

    return 0;
}

#include <iostream>
#include <string>
using namespace std;

int min(int x, int y, int z) { return min(min(x, y), z); }


int editDist(string str1, string str2, int m, int n) {
    if (m == 0)
        return n;
    if (n == 0)
        return m;

            if (str1[m - 1] == str2[n - 1])
        return editDist(str1, str2, m - 1, n - 1);

                return 1 + min(editDist(str1, str2, m, n - 1),
                   editDist(str1, str2, m - 1, n),
                   editDist(str1, str2, m - 1, n - 1));
}

int editDistDP(string str1, string str2, int m, int n) {
        int dp[m + 1][n + 1];

        for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
                        if (i == 0)
                dp[i][j] = j;

                        else if (j == 0)
                dp[i][j] = i;

                        else if (str1[i - 1] == str2[j - 1])
                dp[i][j] = dp[i - 1][j - 1];

            else
                dp[i][j] = 1 + min(dp[i][j - 1],                                        dp[i - 1][j],                                        dp[i - 1][j - 1]                                 );
        }
    }

    return dp[m][n];
}

int main() {
    string str1 = "sunday";
    string str2 = "saturday";

    cout << editDist(str1, str2, str1.length(), str2.length()) << endl;
    cout << editDistDP(str1, str2, str1.length(), str2.length()) << endl;

    return 0;
}
#include <cmath>
#include <iostream>
using std::cin;
using std::cout;

int main() {
    int n = 0, temp = 0, rem = 0, count = 0, sum = 0;
    cout << "Enter a number: ";
    cin >> n;

    temp = n;

    while (temp != 0) {
        temp /= 10;
        count++;
    }


    temp = n;
    while (temp != 0) {
        rem = temp % 10;
        sum += static_cast<int>(pow(rem, count));
        temp /= 10;
    }

    if (sum == n) {
        cout << n << " is an armstrong number";
    } else {
        cout << n << " is not an armstrong number";
    }

    return 0;
}


#include <iostream>
using namespace std;

int *cat;  
unsigned long int catalan_dp(int n) {
    

        cat[0] = cat[1] = 1;

        for (int i = 2; i <= n; i++) {
        cat[i] = 0;
        for (int j = 0; j < i; j++)
            cat[i] += cat[j] * cat[i - j - 1];      }

        return cat[n];
}

int main(int argc, char *argv[]) {
    int n;
    cout << "Enter n: ";
    cin >> n;

    cat = new int[n + 1];

    cout << "Catalan numbers from 0 to " << n << " are:\n";
    for (int i = 0; i <= n; i++) {
        cout << "catalan (" << i << ") = " << catalan_dp(i) << endl;
                                    }

    return 0;
}




#include <array>
#include <cassert>
#include <iostream>
#include <vector>


namespace dynamic_programming {

namespace knapsack {

template <size_t n>
int maxKnapsackValue(const int capacity, const std::array<int, n> &weight,
                     const std::array<int, n> &value) {
    std::vector<std::vector<int> > maxValue(n + 1,
                                            std::vector<int>(capacity + 1, 0));
            int items = sizeof(weight) / sizeof(weight[0]);
    for (size_t i = 0; i < items + 1; ++i) {
        for (size_t j = 0; j < capacity + 1; ++j) {
            if (i == 0 || j == 0) {
                                                maxValue[i][j] = 0;
            } else if (weight[i - 1] <= j) {
                                                                                
                                int profit1 = value[i - 1] + maxValue[i - 1][j - weight[i - 1]];

                                int profit2 = maxValue[i - 1][j];

                maxValue[i][j] = std::max(profit1, profit2);
            } else {
                                                maxValue[i][j] = maxValue[i - 1][j];
            }
        }
    }

        return maxValue[items][capacity];
}
}  }  

static void test() {
        const int n1 = 3;                                 std::array<int, n1> weight1 = {10, 20, 30};       std::array<int, n1> value1 = {60, 100, 120};      const int capacity1 = 50;                         const int max_value1 = dynamic_programming::knapsack::maxKnapsackValue(
        capacity1, weight1, value1);
    const int expected_max_value1 = 220;
    assert(max_value1 == expected_max_value1);
    std::cout << "Maximum Knapsack value with " << n1 << " items is "
              << max_value1 << std::endl;

        const int n2 = 4;                                   std::array<int, n2> weight2 = {24, 10, 10, 7};      std::array<int, n2> value2 = {24, 18, 18, 10};      const int capacity2 = 25;                           const int max_value2 = dynamic_programming::knapsack::maxKnapsackValue(
        capacity2, weight2, value2);
    const int expected_max_value2 = 36;
    assert(max_value2 == expected_max_value2);
    std::cout << "Maximum Knapsack value with " << n2 << " items is "
              << max_value2 << std::endl;
}


int main() {
        test();
    return 0;
}

#include <iostream>

int main() {
    int64_t r, mr = 0, x, q, i, z;
    std::cout << "Enter Number of array you want to Store :";
    std::cin >> x;
    std::cout << "Enter Number of ";
    std::cout << "Question or Quary you ";
    std::cout << "want to do Related to Array :";
    std::cin >> q;
                int** ar = new int*[x]();
            for (r = 0; r < x; r++) {
        std::cout << "Enter number of element in " << r + 1 << " rows :";
        std::cin >> mr;
                int* ac = new int[mr]();
        std::cout << "Enter the element of Array ";
                        for (i = 0; i < mr; i++) {
                        std::cin >> ac[i];
        }
                ar[r] = ac;
    }
            for (z = 0; z < q; z++) {
        int64_t r1 = 0, q1 = 0;
        std::cout << "enter the number of row which element you want to find :";
        std::cin >> r1;
        r1 = r1 - 1;
        std::cout << "enter the position of element which you want to find :";
        std::cin >> q1;
        q1 = q1 - 1;
                std::cout << "The element is " << ar[r1][q1] << std::endl;
    }
}
#include <iostream>
using namespace std;

void Print(int trace[20][20], int m, int n, string a) {
    if (m == 0 || n == 0) {
        return;
    }
    if (trace[m][n] == 1) {
        Print(trace, m - 1, n - 1, a);
        cout << a[m - 1];
    } else if (trace[m][n] == 2) {
        Print(trace, m - 1, n, a);
    } else if (trace[m][n] == 3) {
        Print(trace, m, n - 1, a);
    }
}

int lcs(string a, string b) {
    int m = a.length(), n = b.length();
    int res[m + 1][n + 1];
    int trace[20][20];

        for (int i = 0; i < m + 1; i++) {
        for (int j = 0; j < n + 1; j++) {
            res[i][j] = 0;
            trace[i][j] = 0;
        }
    }

    for (int i = 0; i < m + 1; ++i) {
        for (int j = 0; j < n + 1; ++j) {
            if (i == 0 || j == 0) {
                res[i][j] = 0;
                trace[i][j] = 0;
            }

            else if (a[i - 1] == b[j - 1]) {
                res[i][j] = 1 + res[i - 1][j - 1];
                trace[i][j] = 1;                                                } else {
                if (res[i - 1][j] > res[i][j - 1]) {
                    res[i][j] = res[i - 1][j];
                    trace[i][j] =
                        2;                  } else {
                    res[i][j] = res[i][j - 1];
                    trace[i][j] =
                        3;                  }
            }
        }
    }
    Print(trace, m, n, a);
    return res[m][n];
}

int main() {
    string a, b;
    cin >> a >> b;
    cout << lcs(a, b);
    return 0;
}


#include <cassert>   #include <climits>   #include <iostream>  #include <vector>    

namespace dynamic_programming {

namespace mincoins_topdown {

template <typename T>
int64_t mincoins(const T &n, const std::vector<T> &coins, const int16_t &t,
                 std::vector<T> dp) {
    if (n == 0) {
        return 0;
    }
    if (dp[n] != 0) {
        return dp[n];
    }
    int ans = INT_MAX;      for (int i = 0; i < t; i++) {
        if (n - coins[i] >= 0) {                                                int sub = mincoins(n - coins[i], coins, t, dp);
            ans = std::min(ans, sub + 1);
        }
    }
    dp[n] = ans;
    return dp[n];  }

}  }  

static void test() {
        const int64_t n1 = 15;
    const int8_t t1 = 3, a1 = 0;
    std::cout << "\nTest 1...";
    std::vector<int64_t> arr1{1, 7, 10};
    std::vector<int64_t> dp1(n1 + 1);
    fill(dp1.begin(), dp1.end(), a1);
    assert(dynamic_programming::mincoins_topdown::mincoins(n1, arr1, t1, dp1) ==
           3);
    std::cout << "Passed\n";
}


int main() {
    test();      return 0;
}

#include <cassert>   #include <iostream>  #include <numeric>   #include <vector>    

namespace dp {


namespace partitionProblem {


bool findPartiion(const std::vector<uint64_t> &arr, uint64_t size) {
    uint64_t sum = std::accumulate(arr.begin(), arr.end(),
                                   0);  
    if (sum % 2 != 0) {
        return false;      }
    std::vector<bool> part;
    
        for (uint64_t it = 0; it <= sum / 2; ++it) {
        part.push_back(false);
    }

        for (uint64_t it = 0; it < size; ++it) {
                for (uint64_t it2 = sum / 2; it2 >= arr[it];
             --it2) {                          if (part[it2 - arr[it]] == 1 || it2 == arr[it]) {
                part[it2] = true;
            }
        }
    }
    return part[sum / 2];
}
}  }  

static void test() {
    std::vector<uint64_t> arr = {{1, 3, 3, 2, 3, 2}};
    uint64_t n = arr.size();
    bool expected_result = true;
    bool derived_result = dp::partitionProblem::findPartiion(arr, n);
    std::cout << "1st test: ";
    assert(expected_result == derived_result);
    std::cout << "Passed!" << std::endl;
}


int main() {
    test();      return 0;
}


#include <cassert>
#include <climits>
#include <iostream>
#include <string>
#include <unordered_set>
#include <vector>


namespace dynamic_programming {


namespace word_break {


bool exists(const std::string &str,
            const std::unordered_set<std::string> &strSet) {
    return strSet.find(str) != strSet.end();
}


bool check(const std::string &s, const std::unordered_set<std::string> &strSet,
           int pos, std::vector<int> *dp) {
    if (pos == s.length()) {
                                return true;
    }

    if (dp->at(pos) != INT_MAX) {
                                return dp->at(pos) == 1;
    }

    std::string wordTillNow =
        "";  
    for (int i = pos; i < s.length(); i++) {
                        wordTillNow +=
            std::string(1, s[i]);  
                                if (exists(wordTillNow, strSet) and check(s, strSet, i + 1, dp)) {
            dp->at(pos) = 1;
            return true;
        }
    }
            dp->at(pos) = 0;      return false;     }


bool wordBreak(const std::string &s, const std::vector<std::string> &wordDict) {
            std::unordered_set<std::string> strSet;
    for (const auto &s : wordDict) {
        strSet.insert(s);
    }
                std::vector<int> dp(s.length(), INT_MAX);

                return check(s, strSet, 0, &dp);
}

}  }  

static void test() {
        const std::string s = "applepenapple";
        const std::vector<std::string> wordDict = {"apple", "pen"};

    assert(dynamic_programming::word_break::wordBreak(s, wordDict));

            std::cout << dynamic_programming::word_break::wordBreak(s, wordDict)
              << std::endl;
    std::cout << "Test implementation passed!\n";
}

int main() {
    test();  
        const std::string s = "applepenapple";
        const std::vector<std::string> wordDict = {"apple", "pen"};

            std::cout << dynamic_programming::word_break::wordBreak(s, wordDict)
              << std::endl;
}


#include <iostream>
#include <vector>

const int MAX = 1e5;
std::vector<int> adj[MAX];
std::vector<bool> visited;
std::vector<int> dp;

void depth_first_search(int u) {
    visited[u] = true;
    int child_height = 1;
    for (int v : adj[u]) {
        if (!visited[v]) {
            depth_first_search(v);

                        child_height = std::max(child_height, dp[v] + 1);
        }
    }
        dp[u] = child_height;
}

int main() {
        int number_of_nodes;
    std::cout << "Enter number of nodes of the tree : " << std::endl;
    std::cin >> number_of_nodes;

        int u, v;
        std::cout << "Enter edges of the tree : " << std::endl;
    for (int i = 0; i < number_of_nodes - 1; i++) {
        std::cin >> u >> v;
                adj[u].push_back(v);
        adj[v].push_back(u);
    }
        visited.assign(number_of_nodes + 1, false);
        dp.assign(number_of_nodes + 1, 0);
        depth_first_search(1);
    std::cout << "Height of the Tree : " << dp[1] << std::endl;
}

#include <array>
#include <climits>
#include <iostream>

namespace dynamic_programming {

namespace kadane {

template <size_t N>
int maxSubArray(const std::array<int, N> &n) {
    int curr_sum =
        0;      int max_sum = INT_MIN;      for (int i : n) {          curr_sum += n[i];
        max_sum = std::max(max_sum, curr_sum);          curr_sum = std::max(curr_sum, 0);      }
    return max_sum;  }
}  }  

int main() {
    const int N = 5;
    std::array<int, N> n{};                                   for (int i = 0; i < n.size(); i++) {
        std::cout << "Enter value of n[" << i << "]"
                  << "\n";
        std::cin >> n[i];
    }
    int max_sum = dynamic_programming::kadane::maxSubArray<N>(
        n);      std::cout << "Maximum subarray sum is " << max_sum;  
    return 0;
}


#include <cassert>   #include <climits>   #include <iostream>  #include <vector>    

namespace dynamic_programming {

uint64_t LIS(const std::vector<uint64_t> &a, const uint32_t &n) {
    std::vector<int> lis(n);
    for (int i = 0; i < n; ++i) {
        lis[i] = 1;
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (a[i] > a[j] && lis[i] < lis[j] + 1) {
                lis[i] = lis[j] + 1;
            }
        }
    }
    int res = 0;
    for (int i = 0; i < n; ++i) {
        res = std::max(res, lis[i]);
    }
    return res;
}
}  

static void test() {
    std::vector<uint64_t> a = {15, 21, 2, 3, 4, 5, 8, 4, 1, 1};
    uint32_t n = a.size();

    uint32_t result = dynamic_programming::LIS(a, n);
    assert(result ==
           5);  
    std::cout << "Self-test implementations passed!" << std::endl;
}


int main(int argc, char const *argv[]) {
    uint32_t n = 0;

    std::cout << "Enter size of array: ";
    std::cin >> n;

    std::vector<uint64_t> a(n);

    std::cout << "Enter array elements: ";
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
    }

    std::cout << "\nThe result is: " << dynamic_programming::LIS(a, n)
              << std::endl;
    test();  
    return 0;
}


#include <algorithm>
#include <cassert>
#include <iostream>
#include <vector>


std::string lps(std::string a) {
    std::string b = a;
    reverse(b.begin(), b.end());
    int m = a.length();
    std::vector<std::vector<int> > res(m + 1);

                for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= m; j++) {
            if (i == 0 || j == 0) {
                res[i][j] = 0;
            } else if (a[i - 1] == b[j - 1]) {
                res[i][j] = res[i - 1][j - 1] + 1;
            } else {
                res[i][j] = std::max(res[i - 1][j], res[i][j - 1]);
            }
        }
    }
        int idx = res[m][m];
        std::string ans(idx + 1, '\0');
    int i = m, j = m;

            while (i > 0 && j > 0) {
                        if (a[i - 1] == b[j - 1]) {
            ans[idx - 1] = a[i - 1];
            i--;
            j--;
            idx--;
        }
                        else if (res[i - 1][j] > res[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    return ans;
}


void test() {
        assert(lps("radar") == "radar");
        assert(lps("abbcbaa") == "abcba");
        assert(lps("bbbab") == "bbbb");
}


int main() {
    test();      return 0;
}
#include <climits>
#include <iostream>
using namespace std;

int findMinCoins(int arr[], int n, int N) {
        int dp[N + 1];

    
    dp[0] = 0;

    for (int i = 1; i <= N; i++) {
                dp[i] = INT_MAX;
        int res = INT_MAX;

                for (int c = 0; c < n; c++) {
            if (i - arr[c] >=
                0)                  res = dp[i - arr[c]];

                                    if (res != INT_MAX)
                dp[i] = min(dp[i], res + 1);
        }
    }

        return dp[N];
}

int main() {
        int arr[] = {1, 2, 3, 4};
    int n = sizeof(arr) / sizeof(arr[0]);

        int N = 15;

    cout << "Minimum Number of Coins Required " << findMinCoins(arr, n, N)
         << "\n";

    return 0;
}

#include <cassert>   #include <climits>   #include <iostream>  #include <vector>    

namespace dynamic_programming {

namespace house_robber {

std::uint32_t houseRobber(const std::vector<uint32_t> &money,
                          const uint32_t &n) {
    if (n == 0) {          return 0;
    }
    if (n == 1) {          return money[0];
    }
    if (n == 2) {                             return std::max(money[0], money[1]);
    }
    uint32_t max_value = 0;      uint32_t value1 = money[0];
    uint32_t value2 = std::max(money[0], money[1]);
    for (uint32_t i = 2; i < n; i++) {
        max_value = std::max(money[i] + value1, value2);
        value1 = value2;
        value2 = max_value;
    }

    return max_value;
}
}  }  

static void test() {
            std::vector<uint32_t> array1 = {1, 2, 3, 1};
    std::cout << "Test 1... ";
    assert(
        dynamic_programming::house_robber::houseRobber(array1, array1.size()) ==
        4);                   std::cout << "passed" << std::endl;

            std::vector<uint32_t> array2 = {6, 7, 1, 3, 8, 2, 4};
    std::cout << "Test 2... ";
    assert(
        dynamic_programming::house_robber::houseRobber(array2, array2.size()) ==
        19);                    std::cout << "passed" << std::endl;

            std::vector<uint32_t> array3 = {};
    std::cout << "Test 3... ";
    assert(
        dynamic_programming::house_robber::houseRobber(array3, array3.size()) ==
        0);      std::cout << "passed" << std::endl;

            std::vector<uint32_t> array4 = {2, 7, 9, 3, 1};
    std::cout << "Test 4... ";
    assert(
        dynamic_programming::house_robber::houseRobber(array4, array4.size()) ==
        12);                    std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}


#include <array>
#include <cassert>
#include <climits>
#include <iostream>

namespace dynamic_programming {

namespace cut_rod {

template <size_t T>
int maxProfitByCuttingRod(const std::array<int, T> &price, const uint64_t &n) {
    int *profit =
        new int[n + 1];  
    profit[0] = 0;  
                for (size_t i = 1; i <= n; i++) {
        int q = INT_MIN;
        for (size_t j = 1; j <= i; j++) {
            q = std::max(q, price[j - 1] + profit[i - j]);
        }
        profit[i] = q;
    }
    const int16_t ans = profit[n];
    delete[] profit;
    return ans;  }
}  }  

static void test() {
        const int16_t n1 = 8;                                            std::array<int32_t, n1> price1 = {1,2,4,6,8,45,21,9};      const int64_t max_profit1 =
        dynamic_programming::cut_rod::maxProfitByCuttingRod(price1, n1);
    const int64_t expected_max_profit1 = 47;
    assert(max_profit1 == expected_max_profit1);
    std::cout << "Maximum profit with " << n1 << " inch road is " << max_profit1
              << std::endl;

        const int16_t n2 = 30;      std::array<int32_t, n2> price2 = {
        1,  5,  8,  9,  10, 17, 17, 20, 24, 30,          31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50};

    const int64_t max_profit2=
        dynamic_programming::cut_rod::maxProfitByCuttingRod(price2, n2);
    const int32_t expected_max_profit2 = 90;
    assert(max_profit2 == expected_max_profit2);
    std::cout << "Maximum profit with " << n2 << " inch road is " << max_profit2
              << std::endl;
         const int16_t n3 = 5;                                            std::array<int32_t, n3> price3 = {2,9,17,23,45};      const int64_t max_profit3 =
        dynamic_programming::cut_rod::maxProfitByCuttingRod(price3, n3);
    const int64_t expected_max_profit3 = 45;
    assert(max_profit3 == expected_max_profit3);
    std::cout << "Maximum profit with " << n3 << " inch road is " << max_profit3
              << std::endl;
}


int main() {
        test();
    return 0;
}


#include <algorithm>  #include <cassert>    #include <climits>    #include <iostream>   #include <vector>     

namespace dynamic_programming {


namespace palindrome_partitioning {


int pal_part(const std::string &str) {
    int n = str.size();

        std::vector<std::vector<int> > cuts(n, std::vector<int>(n, 0));

        std::vector<std::vector<bool> > is_palindrome(n,
                                                  std::vector<bool>(n, false));

        for (int i = 0; i < n; i++) {
        is_palindrome[i][i] = true;
        cuts[i][i] = 0;
    }

    for (int len = 2; len <= n; len++) {
        for (int start_index = 0; start_index < n - len + 1; start_index++) {
            int end_index = start_index + len - 1;

            if (len == 2) {
                is_palindrome[start_index][end_index] =
                    (str[start_index] == str[end_index]);
            } else {
                is_palindrome[start_index][end_index] =
                    (str[start_index] == str[end_index]) &&
                    is_palindrome[start_index + 1][end_index - 1];
            }

            if (is_palindrome[start_index][end_index]) {
                cuts[start_index][end_index] = 0;
            } else {
                cuts[start_index][end_index] = INT_MAX;
                for (int partition = start_index; partition <= end_index - 1;
                     partition++) {
                    cuts[start_index][end_index] =
                        std::min(cuts[start_index][end_index],
                                 cuts[start_index][partition] +
                                     cuts[partition + 1][end_index] + 1);
                }
            }
        }
    }

    return cuts[0][n - 1];
}
}  }  

static void test() {
        std::vector<std::string> custom_input{"nitik", "ababbbabbababa", "abdc"};

        std::vector<int> calculated_output(3);

    for (int i = 0; i < 3; i++) {
        calculated_output[i] =
            dynamic_programming::palindrome_partitioning::pal_part(
                custom_input[i]);
    }

        std::vector<int> expected_output{2, 3, 3};

                for (int i = 0; i < 3; i++) {
        assert(expected_output[i] == calculated_output[i]);
    }

    std::cout << "All tests passed successfully!\n";
}


int main() {
    test();      return 0;
}


#include <cassert>     #include <iostream>   #include <vector>    

namespace dynamic_programming {



namespace minimum_edit_distance {


uint64_t min(uint64_t x, uint64_t y, uint64_t z) {
  if (x <= y && x <= z) {
    return x;   }
  if (y <= x && y <= z) {
    return y;   }
  else {
    return z;   }
}


uint64_t editDistDP(std::string str1, std::string str2, uint64_t m, uint64_t n) {
    std::vector<std::vector<uint64_t>>dp(m+1, std::vector<uint64_t>(n+1)); 
    for (uint64_t i = 0; i <= m; i++) {
    for (uint64_t j = 0; j <= n; j++) {
                  if (i == 0) {
        dp[i][j] = j;       }

                  else if (j == 0) {
        dp[i][j] = i;       }

                  else if (str1[i - 1] == str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      }

                  else {
        dp[i][j] = 1 + min(dp[i][j - 1],                                 dp[i - 1][j],                                 dp[i - 1][j - 1]);       }
    }
  }

  return dp[m][n]; }
}  }  

static void test() {
    std::string str1 = "INTENTION";   std::string str2 = "EXECUTION";   uint64_t expected_output1 = 5;   uint64_t output1 = dynamic_programming::minimum_edit_distance::editDistDP(
      str1, str2, str1.length(), str2.length());   assert(output1 == expected_output1);   std::cout << "Minimum Number of Operations Required: " << output1
            << std::endl;

    std::string str3 = "SATURDAY";
  std::string str4 = "SUNDAY";
  uint64_t expected_output2 = 3;
  uint64_t output2 = dynamic_programming::minimum_edit_distance::editDistDP(
      str3, str4, str3.length(), str4.length());
  assert(output2 == expected_output2);
  std::cout << "Minimum Number of Operations Required: " << output2
            << std::endl;
}


int main(int argc, char *argv[]) {
  test();    return 0;
}


#include <cassert>   #include <iostream>  #include <string>    #include <vector>    
namespace dynamic_programming {

namespace abbreviation {

bool abbreviation_recursion(std::vector<std::vector<bool>> *memo,
                            std::vector<std::vector<bool>> *visited,
                            const std::string &str, const std::string &result,
                            uint32_t str_idx = 0, uint32_t result_idx = 0) {
    bool ans = memo->at(str_idx).at(result_idx);
    if (str_idx == str.size() && result_idx == result.size()) {
        return true;
    } else if (str_idx == str.size() && result_idx != result.size()) {
                return false;
    } else if (!visited->at(str_idx).at(result_idx)) {
        
        if (str[str_idx] == result[result_idx]) {
            ans = abbreviation_recursion(memo, visited, str, result,
                                         str_idx + 1, result_idx + 1);
        } else if (str[str_idx] - 32 == result[result_idx]) {
            ans = abbreviation_recursion(memo, visited, str, result,
                                         str_idx + 1, result_idx + 1) ||
                  abbreviation_recursion(memo, visited, str, result,
                                         str_idx + 1, result_idx);
        } else {
                                                            if (str[str_idx] >= 'A' && str[str_idx] <= 'Z') {
                ans = false;
            } else {
                ans = abbreviation_recursion(memo, visited, str, result,
                                             str_idx + 1, result_idx);
            }
        }
    }
    (*memo)[str_idx][result_idx] = ans;
    (*visited)[str_idx][result_idx] = true;
    return (*memo)[str_idx][result_idx];
}

bool abbreviation(const std::string &str, const std::string &result) {
    std::vector<std::vector<bool>> memo(
        str.size() + 1, std::vector<bool>(result.size() + 1, false));

    for (uint32_t i = 0; i <= str.size(); ++i) {
        memo[i][0] = true;
    }
    for (uint32_t i = 1; i <= result.size(); ++i) {
        memo[0][i] = false;
    }
    for (uint32_t i = 1; i <= str.size(); ++i) {
        for (uint32_t j = 1; j <= result.size(); ++j) {
            if (str[i - 1] == result[j - 1]) {
                memo[i][j] = memo[i - 1][j - 1];
            } else if (str[i - 1] - 32 == result[j - 1]) {
                memo[i][j] = (memo[i - 1][j - 1] || memo[i - 1][j]);
            } else {
                if (str[i - 1] >= 'A' && str[i - 1] <= 'Z') {
                    memo[i][j] = false;
                } else {
                    memo[i][j] = memo[i - 1][j];
                }
            }
        }
    }
    return memo.back().back();
}
}  }  

static void test() {
    std::string s = "daBcd", t = "ABC";
    std::vector<std::vector<bool>> memo(s.size() + 1,
                                        std::vector<bool>(t.size() + 1, false)),
        visited(s.size() + 1, std::vector<bool>(t.size() + 1, false));

    assert(dynamic_programming::abbreviation::abbreviation_recursion(
               &memo, &visited, s, t) == true);
    assert(dynamic_programming::abbreviation::abbreviation(s, t) == true);
    s = "XXVVnDEFYgYeMXzWINQYHAQKKOZEYgSRCzLZAmUYGUGILjMDET";
    t = "XXVVDEFYYMXWINQYHAQKKOZEYSRCLZAUYGUGILMDETQVWU";
    memo = std::vector<std::vector<bool>>(
        s.size() + 1, std::vector<bool>(t.size() + 1, false));

    visited = std::vector<std::vector<bool>>(
        s.size() + 1, std::vector<bool>(t.size() + 1, false));

    assert(dynamic_programming::abbreviation::abbreviation_recursion(
               &memo, &visited, s, t) == false);
    assert(dynamic_programming::abbreviation::abbreviation(s, t) == false);

    s = "DRFNLZZVHLPZWIupjwdmqafmgkg";
    t = "DRFNLZZVHLPZWI";

    memo = std::vector<std::vector<bool>>(
        s.size() + 1, std::vector<bool>(t.size() + 1, false));

    visited = std::vector<std::vector<bool>>(
        s.size() + 1, std::vector<bool>(t.size() + 1, false));

    assert(dynamic_programming::abbreviation::abbreviation_recursion(
               &memo, &visited, s, t) == true);
    assert(dynamic_programming::abbreviation::abbreviation(s, t) == true);
}


int main() {
    test();      return 0;
}
#include <climits>
#include <iostream>

int maxSubArraySum(int a[], int size) {
    int max_so_far = INT_MIN, max_ending_here = 0;

    for (int i = 0; i < size; i++) {
        max_ending_here = max_ending_here + a[i];
        if (max_so_far < max_ending_here)
            max_so_far = max_ending_here;

        if (max_ending_here < 0)
            max_ending_here = 0;
    }
    return max_so_far;
}

int main() {
    int n, i;
    std::cout << "Enter the number of elements \n";
    std::cin >> n;
    int a[n];      for (i = 0; i < n; i++) {
        std::cin >> a[i];
    }
    int max_sum = maxSubArraySum(a, n);
    std::cout << "Maximum contiguous sum is " << max_sum;
    return 0;
}
#include <iostream>
using namespace std;
int fib(int n) {
    int res[3];
    res[0] = 0;
    res[1] = 1;
    for (int i = 2; i <= n; i++) {
        res[2] = res[1] + res[0];
        res[0] = res[1];
        res[1] = res[2];
    }
    return res[1];
}
int main(int argc, char const *argv[]) {
    int n;
    cout << "Enter n: ";
    cin >> n;
    cout << "Fibonacci number is ";
    cout << fib(n) << endl;
    return 0;
}
#include <limits.h>
#include <iostream>

using namespace std;

class Edge {
 public:
    int src, dst, weight;
};

class Graph {
 public:
    int vertexNum, edgeNum;
    Edge *edges;

        Graph(int V, int E) {
        this->vertexNum = V;
        this->edgeNum = E;
        this->edges = (Edge *)malloc(E * sizeof(Edge));
    }

        void addEdge(int src, int dst, int weight) {
        static int edgeInd = 0;
        if (edgeInd < this->edgeNum) {
            Edge newEdge;
            newEdge.src = src;
            newEdge.dst = dst;
            newEdge.weight = weight;
            this->edges[edgeInd++] = newEdge;
        }
    }
};

void print(int dist[], int V) {
    cout << "\nVertex  Distance" << endl;
    for (int i = 0; i < V; i++) {
        if (dist[i] != INT_MAX)
            cout << i << "\t" << dist[i] << endl;
        else
            cout << i << "\tINF" << endl;
    }
}

void BellmanFord(Graph graph, int src) {
    int V = graph.vertexNum;
    int E = graph.edgeNum;
    int dist[V];

            for (int i = 0; i < V; i++) dist[i] = INT_MAX;
    dist[src] = 0;

            for (int i = 0; i <= V - 1; i++)
        for (int j = 0; j < E; j++) {
            int u = graph.edges[j].src;
            int v = graph.edges[j].dst;
            int w = graph.edges[j].weight;

            if (dist[u] != INT_MAX && dist[u] + w < dist[v])
                dist[v] = dist[u] + w;
        }

        for (int j = 0; j < E; j++) {
        int u = graph.edges[j].src;
        int v = graph.edges[j].dst;
        int w = graph.edges[j].weight;

        if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
            cout << "Graph contains negative weight cycle. Hence, shortest "
                    "distance not guaranteed."
                 << endl;
            return;
        }
    }

    print(dist, V);

    return;
}

int main() {
    int V, E, gsrc;
    int src, dst, weight;
    cout << "Enter number of vertices: ";
    cin >> V;
    cout << "Enter number of edges: ";
    cin >> E;
    Graph G(V, E);
    for (int i = 0; i < E; i++) {
        cout << "\nEdge " << i + 1 << "\nEnter source: ";
        cin >> src;
        cout << "Enter destination: ";
        cin >> dst;
        cout << "Enter weight: ";
        cin >> weight;
        G.addEdge(src, dst, weight);
    }
    cout << "\nEnter source: ";
    cin >> gsrc;
    BellmanFord(G, gsrc);

    return 0;
}

#include <iostream>

using namespace std;
int LIS(int arr[], int n) {
    set<int> active;      active.insert(arr[0]);
        for (int i = 1; i < n; ++i) {
        auto get = active.lower_bound(arr[i]);
        if (get == active.end()) {
            active.insert(arr[i]);
        }          else {
            int val = *get;                                           if (val > arr[i]) {
                                                active.erase(get);
                active.insert(arr[i]);
            }
        }
    }
    return active.size();  }
int main(int argc, char const* argv[]) {
    int n;
    cout << "Enter size of array: ";
    cin >> n;
    int a[n];
    cout << "Enter array elements: ";
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    cout << LIS(a, n) << endl;
    return 0;
}


#include <climits>
#include <iostream>
using namespace std;

int eggDrop(int n, int k) {
    int eggFloor[n + 1][k + 1];
    int result;

    for (int i = 1; i <= n; i++) {
        eggFloor[i][1] = 1;          eggFloor[i][0] = 0;      }

        for (int j = 1; j <= k; j++) {
        eggFloor[1][j] = j;
    }

    for (int i = 2; i <= n; i++) {
        for (int j = 2; j <= k; j++) {
            eggFloor[i][j] = INT_MAX;
            for (int x = 1; x <= j; x++) {
                                                result = 1 + max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);
                if (result < eggFloor[i][j])
                    eggFloor[i][j] = result;
            }
        }
    }

    return eggFloor[n][k];
}

int main() {
    int n, k;
    cout << "Enter number of eggs and floors: ";
    cin >> n >> k;
    cout << "Minimum number of trials in worst case: " << eggDrop(n, k) << endl;
    return 0;
}
#include <climits>
#include <iostream>
using namespace std;

#define MAX 10

int dp[MAX][MAX];

int MatrixChainMultiplication(int dim[], int i, int j) {
        if (j <= i + 1)
        return 0;

            int min = INT_MAX;

    
    if (dp[i][j] == 0) {
                
        for (int k = i + 1; k <= j - 1; k++) {
                        int cost = MatrixChainMultiplication(dim, i, k);

                        cost += MatrixChainMultiplication(dim, k, j);

                        cost += dim[i] * dim[k] * dim[j];

            if (cost < min)
                min = cost;          }
        dp[i][j] = min;
    }

        return dp[i][j];
}

int main() {
            int dim[] = {10, 30, 5, 60};
    int n = sizeof(dim) / sizeof(dim[0]);

        
    cout << "Minimum cost is " << MatrixChainMultiplication(dim, 0, n - 1)
         << "\n";

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cassert>


namespace dynamic_programming {

    
    namespace shortest_common_supersequence {
        
        
        std::string scs(const std::string &str1, const std::string &str2) {

                                    if(str1.empty() && str2.empty()) {
                return "";
            }
            else if(str1.empty()) {
                return str2;
            }
            else if(str2.empty()) {
                return str1;
            }

                        std::vector <std::vector <int>> lookup(str1.length() + 1, std::vector <int> (str2.length() + 1, 0));
      
            for(int i=1; i <= str1.length(); i++) {
                for(int j=1; j <= str2.length(); j++) {
                    if(str1[i-1] == str2[j-1]) {
                        lookup[i][j] = lookup[i-1][j-1] + 1;
                    }
                    else {
                        lookup[i][j] = std::max(lookup[i-1][j], lookup[i][j-1]);
                    }
                }
            }

                                                int i=str1.length();
            int j=str2.length();
            std::string s;
      
            while(i>0 && j>0) {

                                                if(str1[i-1] == str2[j-1]) {
                    s.push_back(str1[i-1]);
                    i--;
                    j--;
                }
                                else {
                    if(lookup[i-1][j] > lookup[i][j-1]) {
                        s.push_back(str1[i-1]);
                        i--;
                    }
                    else {
                        s.push_back(str2[j-1]);
                        j--;
                    }
                }
            }

                                    while(i > 0) {
                s.push_back(str1[i-1]);
                i--;
            }

                        while(j > 0) {
                s.push_back(str2[j-1]);
                j--;
            }

                                    reverse(s.begin(), s.end());
            return s;
        }
    } } 

static void test() {
        std::vector <std::vector <std::string>> scsStrings {
        {"ABCXYZ", "ABZ"},
        {"ABZ", "ABCXYZ"},
        {"AGGTAB", "GXTXAYB"},
        {"X", "Y"},
    };

        std::vector <std::string> calculatedOutput(4, "");
    int i=0;
    for(auto & scsString : scsStrings) {
        
        calculatedOutput[i] = dynamic_programming::shortest_common_supersequence::scs(
            scsString[0], scsString[1]
        );
        i++;
    }

        std::vector <std::string> expectedOutput {
        "ABCXYZ",
        "ABCXYZ",
        "AGGXTXAYB",
        "XY"
    };

                for(int i=0; i < scsStrings.size(); i++) {
        assert(expectedOutput[i] == calculatedOutput[i]);
    }

    std::cout << "All tests passed successfully!\n";
    return;
}


int main() {
        test();

        std::string s1, s2;
    std::cin >> s1;
    std::cin >> s2;

    std::string ans;

        ans = dynamic_programming::shortest_common_supersequence::scs(s1, s2);
    std::cout << ans;
    return 0;
}

#include <cmath>
#include <iostream>
#include <memory>
#include <vector>


class hash_chain {
 private:
    
    using Node = struct Node {
        int data{};                                 std::shared_ptr<struct Node> next;      };

    std::vector<std::shared_ptr<Node>> head;      int _mod;                                 
 public:
    
    explicit hash_chain(int mod) : _mod(mod) {
        while (mod--) head.push_back(nullptr);
    }

    
    void add(int x, int h) {
        std::shared_ptr<Node> curr;
        std::shared_ptr<Node> temp(new Node);
        temp->data = x;
        temp->next = nullptr;
        if (!head[h]) {
            head[h] = temp;
            curr = head[h];
        } else {
            curr = head[h];
            while (curr->next) curr = curr->next;
            curr->next = temp;
        }
    }

    
    void display() {
        std::shared_ptr<Node> temp = nullptr;
        int i = 0;
        for (i = 0; i < _mod; i++) {
            if (!head[i]) {
                std::cout << "Key " << i << " is empty" << std::endl;
            } else {
                std::cout << "Key " << i << " has values = " << std::endl;
                temp = head[i];
                while (temp->next) {
                    std::cout << temp->data << " " << std::endl;
                    temp = temp->next;
                }
                std::cout << temp->data;
                std::cout << std::endl;
            }
        }
    }

    
    virtual int hash(int x) const { return x % _mod; }

    
    bool find(int x, int h) const {
        std::shared_ptr<Node> temp = head[h];
        if (!head[h]) {
                        std::cout << "Element not found" << std::endl;
            return false;
        }

                while (temp->data != x && temp->next) temp = temp->next;

        if (temp->next) {
            std::cout << "Element found" << std::endl;
            return true;
        }

                        if (temp->data == x) {
            std::cout << "Element found" << std::endl;
            return true;
        }

                std::cout << "Element not found" << std::endl;
        return false;
    }
};


int main() {
    int c = 0, x = 0, mod = 0, h = 0;
    std::cout << "Enter the size of Hash Table. = " << std::endl;
    std::cin >> mod;

    hash_chain mychain(mod);

    bool loop = true;
    while (loop) {
        std::cout << std::endl;
        std::cout << "PLEASE CHOOSE -" << std::endl;
        std::cout << "1. Add element." << std::endl;
        std::cout << "2. Find element." << std::endl;
        std::cout << "3. Generate Hash." << std::endl;
        std::cout << "4. Display Hash table." << std::endl;
        std::cout << "5. Exit." << std::endl;
        std::cin >> c;
        switch (c) {
            case 1:
                std::cout << "Enter element to add = " << std::endl;
                std::cin >> x;
                h = mychain.hash(x);
                h = std::abs(h);
                mychain.add(x, h);
                break;
            case 2:
                std::cout << "Enter element to search = " << std::endl;
                std::cin >> x;
                h = mychain.hash(x);
                mychain.find(x, h);
                break;
            case 3:
                std::cout << "Enter element to generate hash = " << std::endl;
                std::cin >> x;
                std::cout << "Hash of " << x << " is = " << mychain.hash(x)
                          << std::endl;
                break;
            case 4:
                mychain.display();
                break;
            default:
                loop = false;
                break;
        }
        std::cout << std::endl;
    }

    return 0;
}


#include <algorithm>  #include <array>      #include <cassert>    #include <cstring>    #include <iostream>   #include <string>     #include <vector>     

namespace hashing {

namespace md5 {

uint32_t leftRotate32bits(uint32_t n, std::size_t rotate) {
    return (n << rotate) | (n >> (32 - rotate));
}

bool isBigEndian() {
    union {
        uint32_t i;
        std::array<char, 4> c;
    } bint = {0x01020304};

    return bint.c[0] == 1;
}

uint32_t toLittleEndian32(uint32_t n) {
    if (!isBigEndian()) {
        return ((n << 24) & 0xFF000000) | ((n << 8) & 0x00FF0000) |
               ((n >> 8) & 0x0000FF00) | ((n >> 24) & 0x000000FF);
    }
        return n;
}

uint64_t toLittleEndian64(uint64_t n) {
    if (!isBigEndian()) {
        return ((n << 56) & 0xFF00000000000000) |
               ((n << 40) & 0x00FF000000000000) |
               ((n << 24) & 0x0000FF0000000000) |
               ((n << 8) & 0x000000FF00000000) |
               ((n >> 8) & 0x00000000FF000000) |
               ((n >> 24) & 0x0000000000FF0000) |
               ((n >> 40) & 0x000000000000FF00) |
               ((n >> 56) & 0x00000000000000FF);
        ;
    }
        return n;
}

std::string sig2hex(void* sig) {
    const char* hexChars = "0123456789abcdef";
    auto* intsig = static_cast<uint8_t*>(sig);
    std::string hex = "";
    for (uint8_t i = 0; i < 16; i++) {
        hex.push_back(hexChars[(intsig[i] >> 4) & 0xF]);
        hex.push_back(hexChars[(intsig[i]) & 0xF]);
    }
    return hex;
}

void* hash_bs(const void* input_bs, uint64_t input_size) {
    auto* input = static_cast<const uint8_t*>(input_bs);

            std::array<uint32_t, 64> s = {
        7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
        5, 9,  14, 20, 5, 9,  14, 20, 5, 9,  14, 20, 5, 9,  14, 20,
        4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
        6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21};
        
    
    std::array<uint32_t, 64> K = {
        3614090360, 3905402710, 606105819,  3250441966, 4118548399, 1200080426,
        2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134,
        1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664,
        643717713,  3921069994, 3593408605, 38016083,   3634488961, 3889429448,
        568446438,  3275163606, 4107603335, 1163531501, 2850285829, 4243563512,
        1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740,
        2763975236, 1272893353, 4139469664, 3200236656, 681279174,  3936430074,
        3572445317, 76029189,   3654602809, 3873151461, 530742520,  3299628645,
        4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690,
        4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649,
        4149444226, 3174756917, 718787259,  3951481745};

        uint32_t a0 = 0x67452301, A = 0;
    uint32_t b0 = 0xefcdab89, B = 0;
    uint32_t c0 = 0x98badcfe, C = 0;
    uint32_t d0 = 0x10325476, D = 0;

    
            uint64_t padded_message_size = 0;
    if (input_size % 64 < 56) {
        padded_message_size = input_size + 64 - (input_size % 64);
    } else {
        padded_message_size = input_size + 128 - (input_size % 64);
    }

    std::vector<uint8_t> padded_message(padded_message_size);

        std::copy(input, input + input_size, padded_message.begin());

        padded_message[input_size] = 1 << 7;      for (uint64_t i = input_size; i % 64 != 56; i++) {
        if (i == input_size) {
            continue;          }
        padded_message[i] = 0;
    }

                uint64_t input_bitsize_le = toLittleEndian64(input_size * 8);
    for (uint8_t i = 0; i < 8; i++) {
        padded_message[padded_message_size - 8 + i] =
            (input_bitsize_le >> (56 - 8 * i)) & 0xFF;
    }

        std::array<uint32_t, 16> blocks{};

        for (uint64_t chunk = 0; chunk * 64 < padded_message_size; chunk++) {
                for (uint8_t bid = 0; bid < 16; bid++) {
            blocks[bid] = 0;

                                    for (uint8_t cid = 0; cid < 4; cid++) {
                blocks[bid] = (blocks[bid] << 8) +
                              padded_message[chunk * 64 + bid * 4 + cid];
            }
        }

        A = a0;
        B = b0;
        C = c0;
        D = d0;

                for (uint8_t i = 0; i < 64; i++) {
            uint32_t F = 0, g = 0;
            if (i < 16) {
                F = (B & C) | ((~B) & D);
                g = i;
            } else if (i < 32) {
                F = (D & B) | ((~D) & C);
                g = (5 * i + 1) % 16;
            } else if (i < 48) {
                F = B ^ C ^ D;
                g = (3 * i + 5) % 16;
            } else {
                F = C ^ (B | (~D));
                g = (7 * i) % 16;
            }

                        F += A + K[i] + toLittleEndian32(blocks[g]);

            A = D;
            D = C;
            C = B;
            B += leftRotate32bits(F, s[i]);
        }
                a0 += A;
        b0 += B;
        c0 += C;
        d0 += D;
    }

                    auto* sig = new uint8_t[16];
    for (uint8_t i = 0; i < 4; i++) {
        sig[i] = (a0 >> (8 * i)) & 0xFF;
        sig[i + 4] = (b0 >> (8 * i)) & 0xFF;
        sig[i + 8] = (c0 >> (8 * i)) & 0xFF;
        sig[i + 12] = (d0 >> (8 * i)) & 0xFF;
    }

    return sig;
}

void* hash(const std::string& message) {
    return hash_bs(&message[0], message.size());
}
}  }  

static void test() {
        void* sig = hashing::md5::hash("");
    std::cout << "Hashing empty string" << std::endl;
        std::cout << hashing::md5::sig2hex(sig) << std::endl << std::endl;
        assert(hashing::md5::sig2hex(sig).compare(
               "d41d8cd98f00b204e9800998ecf8427e") == 0);

        void* sig2 =
        hashing::md5::hash("The quick brown fox jumps over the lazy dog");
    std::cout << "Hashing The quick brown fox jumps over the lazy dog"
              << std::endl;
        std::cout << hashing::md5::sig2hex(sig2) << std::endl << std::endl;
        assert(hashing::md5::sig2hex(sig2).compare(
               "9e107d9d372bb6826bd81d3542a419d6") == 0);

            void* sig3 =
        hashing::md5::hash("The quick brown fox jumps over the lazy dog.");
    std::cout << "Hashing "
                 "The quick brown fox jumps over the lazy dog."
              << std::endl;
        std::cout << hashing::md5::sig2hex(sig3) << std::endl << std::endl;
        assert(hashing::md5::sig2hex(sig3).compare(
               "e4d909c290d0fb1ca068ffaddf22cbd0") == 0);

            void* sig4 = hashing::md5::hash(
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    std::cout
        << "Hashing "
           "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        << std::endl;
        std::cout << hashing::md5::sig2hex(sig4) << std::endl << std::endl;
        assert(hashing::md5::sig2hex(sig4).compare(
               "d174ab98d277d9f5a5611c2c9f419d9f") == 0);
}


static void interactive() {
    while (true) {
        std::string input;
        std::cout << "Enter a message to be hashed (Ctrl-C to exit): "
                  << std::endl;
        std::getline(std::cin, input);
        void* sig = hashing::md5::hash(input);
        std::cout << "Hash is: " << hashing::md5::sig2hex(sig) << std::endl;

        while (true) {
            std::cout << "Want to enter another message? (y/n) ";
            std::getline(std::cin, input);
            if (input.compare("y") == 0) {
                break;
            } else if (input.compare("n") == 0) {
                return;
            }
        }
    }
}


int main() {
    test();  
            interactive();
    return 0;
}


#include <algorithm>  #include <array>      #include <cassert>    #include <cstring>    #include <iostream>   #include <string>     #include <vector>     

namespace hashing {

namespace sha1 {

uint32_t leftRotate32bits(uint32_t n, std::size_t rotate) {
    return (n << rotate) | (n >> (32 - rotate));
}


std::string sig2hex(void* sig) {
    const char* hexChars = "0123456789abcdef";
    auto* intsig = static_cast<uint8_t*>(sig);
    std::string hex = "";
    for (uint8_t i = 0; i < 20; i++) {
        hex.push_back(hexChars[(intsig[i] >> 4) & 0xF]);
        hex.push_back(hexChars[(intsig[i]) & 0xF]);
    }
    return hex;
}


void* hash_bs(const void* input_bs, uint64_t input_size) {
    auto* input = static_cast<const uint8_t*>(input_bs);

        uint32_t h0 = 0x67452301, a = 0;
    uint32_t h1 = 0xEFCDAB89, b = 0;
    uint32_t h2 = 0x98BADCFE, c = 0;
    uint32_t h3 = 0x10325476, d = 0;
    uint32_t h4 = 0xC3D2E1F0, e = 0;

                uint64_t padded_message_size = 0;
    if (input_size % 64 < 56) {
        padded_message_size = input_size + 64 - (input_size % 64);
    } else {
        padded_message_size = input_size + 128 - (input_size % 64);
    }

        std::vector<uint8_t> padded_message(padded_message_size);

        std::copy(input, input + input_size, padded_message.begin());

        padded_message[input_size] = 1 << 7;      for (uint64_t i = input_size; i % 64 != 56; i++) {
        if (i == input_size) {
            continue;          }
        padded_message[i] = 0;
    }

            uint64_t input_bitsize = input_size * 8;
    for (uint8_t i = 0; i < 8; i++) {
        padded_message[padded_message_size - 8 + i] =
            (input_bitsize >> (56 - 8 * i)) & 0xFF;
    }

        std::array<uint32_t, 80> blocks{};

        for (uint64_t chunk = 0; chunk * 64 < padded_message_size; chunk++) {
                for (uint8_t bid = 0; bid < 16; bid++) {
            blocks[bid] = 0;

                                    for (uint8_t cid = 0; cid < 4; cid++) {
                blocks[bid] = (blocks[bid] << 8) +
                              padded_message[chunk * 64 + bid * 4 + cid];
            }

                        for (uint8_t i = 16; i < 80; i++) {
                blocks[i] =
                    leftRotate32bits(blocks[i - 3] ^ blocks[i - 8] ^
                                         blocks[i - 14] ^ blocks[i - 16],
                                     1);
            }
        }

        a = h0;
        b = h1;
        c = h2;
        d = h3;
        e = h4;

                for (uint8_t i = 0; i < 80; i++) {
            uint32_t F = 0, g = 0;
            if (i < 20) {
                F = (b & c) | ((~b) & d);
                g = 0x5A827999;
            } else if (i < 40) {
                F = b ^ c ^ d;
                g = 0x6ED9EBA1;
            } else if (i < 60) {
                F = (b & c) | (b & d) | (c & d);
                g = 0x8F1BBCDC;
            } else {
                F = b ^ c ^ d;
                g = 0xCA62C1D6;
            }

                        uint32_t temp = leftRotate32bits(a, 5) + F + e + g + blocks[i];
            e = d;
            d = c;
            c = leftRotate32bits(b, 30);
            b = a;
            a = temp;
        }
                h0 += a;
        h1 += b;
        h2 += c;
        h3 += d;
        h4 += e;
    }

                auto* sig = new uint8_t[20];
    for (uint8_t i = 0; i < 4; i++) {
        sig[i] = (h0 >> (24 - 8 * i)) & 0xFF;
        sig[i + 4] = (h1 >> (24 - 8 * i)) & 0xFF;
        sig[i + 8] = (h2 >> (24 - 8 * i)) & 0xFF;
        sig[i + 12] = (h3 >> (24 - 8 * i)) & 0xFF;
        sig[i + 16] = (h4 >> (24 - 8 * i)) & 0xFF;
    }

    return sig;
}


void* hash(const std::string& message) {
    return hash_bs(&message[0], message.size());
}
}  }  

static void test() {
        void* sig = hashing::sha1::hash("");
    std::cout << "Hashing empty string" << std::endl;
        std::cout << hashing::sha1::sig2hex(sig) << std::endl << std::endl;
        assert(hashing::sha1::sig2hex(sig).compare(
               "da39a3ee5e6b4b0d3255bfef95601890afd80709") == 0);

        void* sig2 =
        hashing::sha1::hash("The quick brown fox jumps over the lazy dog");
    std::cout << "Hashing The quick brown fox jumps over the lazy dog"
              << std::endl;
        std::cout << hashing::sha1::sig2hex(sig2) << std::endl << std::endl;
        assert(hashing::sha1::sig2hex(sig2).compare(
               "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12") == 0);

            void* sig3 =
        hashing::sha1::hash("The quick brown fox jumps over the lazy dog.");
    std::cout << "Hashing "
                 "The quick brown fox jumps over the lazy dog."
              << std::endl;
        std::cout << hashing::sha1::sig2hex(sig3) << std::endl << std::endl;
        assert(hashing::sha1::sig2hex(sig3).compare(
               "408d94384216f890ff7a0c3528e8bed1e0b01621") == 0);

            void* sig4 = hashing::sha1::hash(
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    std::cout
        << "Hashing "
           "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        << std::endl;
        std::cout << hashing::sha1::sig2hex(sig4) << std::endl << std::endl;
        assert(hashing::sha1::sig2hex(sig4).compare(
               "761c457bf73b14d27e9e9265c46f4b4dda11f940") == 0);
}


static void interactive() {
    while (true) {
        std::string input;
        std::cout << "Enter a message to be hashed (Ctrl-C to exit): "
                  << std::endl;
        std::getline(std::cin, input);
        void* sig = hashing::sha1::hash(input);
        std::cout << "Hash is: " << hashing::sha1::sig2hex(sig) << std::endl;

        while (true) {
            std::cout << "Want to enter another message? (y/n) ";
            std::getline(std::cin, input);
            if (input.compare("y") == 0) {
                break;
            } else if (input.compare("n") == 0) {
                return;
            }
        }
    }
}


int main() {
    test();  
            interactive();
    return 0;
}

#include <iostream>
#include <memory>
#include <vector>


namespace double_hashing {
using Entry = struct Entry;
bool putProber(const Entry& entry, int key);
bool searchingProber(const Entry& entry, int key);
void add(int key);

int notPresent;
std::vector<Entry> table;
int totalSize;
int tomb = -1;
int size;
bool rehashing;


struct Entry {
    explicit Entry(int key = notPresent) : key(key) {}      int key;                                            };


size_t hashFxn(int key) {
    std::hash<int> hash;
    return hash(key);
}


size_t otherHashFxn(int key) {
    std::hash<int> hash;
    return 1 + (7 - (hash(key) % 7));
}


int doubleHash(int key, bool searching) {
    int hash = static_cast<int>(hashFxn(key));
    int i = 0;
    Entry entry;
    do {
        int index =
            static_cast<int>(hash + (i * otherHashFxn(key))) % totalSize;
        entry = table[index];
        if (searching) {
            if (entry.key == notPresent) {
                return notPresent;
            }
            if (searchingProber(entry, key)) {
                std::cout << "Found key!" << std::endl;
                return index;
            }
            std::cout << "Found tombstone or equal hash, checking next"
                      << std::endl;
            i++;
        } else {
            if (putProber(entry, key)) {
                if (!rehashing) {
                    std::cout << "Spot found!" << std::endl;
                }
                return index;
            }
            if (!rehashing) {
                std::cout << "Spot taken, looking at next (next index:"
                          << " "
                          << static_cast<int>(hash + (i * otherHashFxn(key))) %
                                 totalSize
                          << ")" << std::endl;
            }
            i++;
        }
        if (i == totalSize * 100) {
            std::cout << "DoubleHash probe failed" << std::endl;
            return notPresent;
        }
    } while (entry.key != notPresent);
    return notPresent;
}


bool putProber(const Entry& entry, int key) {
    if (entry.key == notPresent || entry.key == tomb) {
        return true;
    }
    return false;
}


bool searchingProber(const Entry& entry, int key) {
    if (entry.key == key) {
        return true;
    }
    return false;
}


void display() {
    for (int i = 0; i < totalSize; i++) {
        if (table[i].key == notPresent) {
            std::cout << " Empty ";
        } else if (table[i].key == tomb) {
            std::cout << " Tomb ";
        } else {
            std::cout << " ";
            std::cout << table[i].key;
            std::cout << " ";
        }
    }
    std::cout << std::endl;
}


void rehash() {
        rehashing = true;
    int oldSize = totalSize;
    std::vector<Entry> oldTable(table);
        table = std::vector<Entry>(totalSize * 2);
    totalSize *= 2;
    for (int i = 0; i < oldSize; i++) {
        if (oldTable[i].key != -1 && oldTable[i].key != notPresent) {
            size--;              add(oldTable[i].key);
        }
    }
        
    rehashing = false;
    std::cout << "Table was rehashed, new size is: " << totalSize << std::endl;
}


void add(int key) {
            int index = doubleHash(key, false);
    table[index].key = key;
        if (++size / static_cast<double>(totalSize) >= 0.5) {
        rehash();
    }
}


void remove(int key) {
    int index = doubleHash(key, true);
    if (index == notPresent) {
        std::cout << "key not found" << std::endl;
    }
    table[index].key = tomb;
    std::cout << "Removal successful, leaving tombstone" << std::endl;
    size--;
}


void addInfo(int key) {
    std::cout << "Initial table: ";
    display();
    std::cout << std::endl;
    std::cout << "hash of " << key << " is " << hashFxn(key) << " % "
              << totalSize << " == " << hashFxn(key) % totalSize;
    std::cout << std::endl;
    add(key);
    std::cout << "New table: ";
    display();
}


void removalInfo(int key) {
    std::cout << "Initial table: ";
    display();
    std::cout << std::endl;
    std::cout << "hash of " << key << " is " << hashFxn(key) << " % "
              << totalSize << " == " << hashFxn(key) % totalSize;
    std::cout << std::endl;
    remove(key);
    std::cout << "New table: ";
    display();
}
}  

using double_hashing::Entry;
using double_hashing::table;
using double_hashing::totalSize;


int main() {
    int cmd = 0, hash = 0, key = 0;
    std::cout << "Enter the initial size of Hash Table. = ";
    std::cin >> totalSize;
    table = std::vector<Entry>(totalSize);
    bool loop = true;
    while (loop) {
        std::cout << std::endl;
        std::cout << "PLEASE CHOOSE -" << std::endl;
        std::cout << "1. Add key. (Numeric only)" << std::endl;
        std::cout << "2. Remove key." << std::endl;
        std::cout << "3. Find key." << std::endl;
        std::cout << "4. Generate Hash. (Numeric only)" << std::endl;
        std::cout << "5. Display Hash table." << std::endl;
        std::cout << "6. Exit." << std::endl;
        std::cin >> cmd;
        switch (cmd) {
            case 1:
                std::cout << "Enter key to add = ";
                std::cin >> key;
                double_hashing::addInfo(key);
                break;
            case 2:
                std::cout << "Enter key to remove = ";
                std::cin >> key;
                double_hashing::removalInfo(key);
                break;
            case 3: {
                std::cout << "Enter key to search = ";
                std::cin >> key;
                Entry entry = table[double_hashing::doubleHash(key, true)];
                if (entry.key == double_hashing::notPresent) {
                    std::cout << "Key not present";
                }
                break;
            }
            case 4:
                std::cout << "Enter element to generate hash = ";
                std::cin >> key;
                std::cout << "Hash of " << key
                          << " is = " << double_hashing::hashFxn(key);
                break;
            case 5:
                double_hashing::display();
                break;
            default:
                loop = false;
                break;
                        }
        std::cout << std::endl;
    }
    return 0;
}

#include <iostream>
#include <vector>


namespace linear_probing {
using Entry = struct Entry;
bool putProber(const Entry& entry, int key);
bool searchingProber(const Entry& entry, int key);
void add(int key);

int notPresent;
std::vector<Entry> table;
int totalSize;
int tomb = -1;
int size;
bool rehashing;


struct Entry {
    explicit Entry(int key = notPresent) : key(key) {}      int key;                                            };


size_t hashFxn(int key) {
    std::hash<int> hash;
    return hash(key);
}


int linearProbe(int key, bool searching) {
    int hash = static_cast<int>(hashFxn(key));
    int i = 0;
    Entry entry;
    do {
        int index = static_cast<int>((hash + i) % totalSize);
        entry = table[index];
        if (searching) {
            if (entry.key == notPresent) {
                return notPresent;
            }
            if (searchingProber(entry, key)) {
                std::cout << "Found key!" << std::endl;
                return index;
            }
            std::cout << "Found tombstone or equal hash, checking next"
                      << std::endl;
            i++;
        } else {
            if (putProber(entry, key)) {
                if (!rehashing) {
                    std::cout << "Spot found!" << std::endl;
                }
                return index;
            }
            if (!rehashing) {
                std::cout << "Spot taken, looking at next" << std::endl;
            }
            i++;
        }
        if (i == totalSize) {
            std::cout << "Linear probe failed" << std::endl;
            return notPresent;
        }
    } while (entry.key != notPresent);
    return notPresent;
}


bool putProber(const Entry& entry, int key) {
    if (entry.key == notPresent || entry.key == tomb) {
        return true;
    }
    return false;
}


bool searchingProber(const Entry& entry, int key) {
    if (entry.key == key) {
        return true;
    }
    return false;
}


void display() {
    for (int i = 0; i < totalSize; i++) {
        if (table[i].key == notPresent) {
            std::cout << " Empty ";
        } else if (table[i].key == tomb) {
            std::cout << " Tomb ";
        } else {
            std::cout << " ";
            std::cout << table[i].key;
            std::cout << " ";
        }
    }
    std::cout << std::endl;
}


void rehash() {
        rehashing = true;
    int oldSize = totalSize;
    std::vector<Entry> oldTable(table);
            totalSize *= 2;
    table = std::vector<Entry>(totalSize);
    for (int i = 0; i < oldSize; i++) {
        if (oldTable[i].key != -1 && oldTable[i].key != notPresent) {
            size--;              add(oldTable[i].key);
        }
    }
        rehashing = false;
    std::cout << "Table was rehashed, new size is: " << totalSize << std::endl;
}


void add(int key) {
    int index = linearProbe(key, false);
    table[index].key = key;
        if (++size / static_cast<double>(totalSize) >= 0.5) {
        rehash();
    }
}


void remove(int key) {
    int index = linearProbe(key, true);
    if (index == notPresent) {
        std::cout << "key not found" << std::endl;
    }
    std::cout << "Removal Successful, leaving tomb" << std::endl;
    table[index].key = tomb;
    size--;
}


void addInfo(int key) {
    std::cout << "Initial table: ";
    display();
    std::cout << std::endl;
    std::cout << "hash of " << key << " is " << hashFxn(key) << " % "
              << totalSize << " == " << hashFxn(key) % totalSize;
    std::cout << std::endl;
    add(key);
    std::cout << "New table: ";
    display();
}


void removalInfo(int key) {
    std::cout << "Initial table: ";
    display();
    std::cout << std::endl;
    std::cout << "hash of " << key << " is " << hashFxn(key) << " % "
              << totalSize << " == " << hashFxn(key) % totalSize;
    std::cout << std::endl;
    remove(key);
    std::cout << "New table: ";
    display();
}
}  

using linear_probing::Entry;
using linear_probing::table;
using linear_probing::totalSize;


int main() {
    int cmd = 0, hash = 0, key = 0;
    std::cout << "Enter the initial size of Hash Table. = ";
    std::cin >> totalSize;
    table = std::vector<Entry>(totalSize);
    bool loop = true;
    while (loop) {
        std::cout << std::endl;
        std::cout << "PLEASE CHOOSE -" << std::endl;
        std::cout << "1. Add key. (Numeric only)" << std::endl;
        std::cout << "2. Remove key." << std::endl;
        std::cout << "3. Find key." << std::endl;
        std::cout << "4. Generate Hash. (Numeric only)" << std::endl;
        std::cout << "5. Display Hash table." << std::endl;
        std::cout << "6. Exit." << std::endl;
        std::cin >> cmd;
        switch (cmd) {
            case 1:
                std::cout << "Enter key to add = ";
                std::cin >> key;
                linear_probing::addInfo(key);
                break;
            case 2:
                std::cout << "Enter key to remove = ";
                std::cin >> key;
                linear_probing::removalInfo(key);
                break;
            case 3: {
                std::cout << "Enter key to search = ";
                std::cin >> key;
                Entry entry = table[linear_probing::linearProbe(key, true)];
                if (entry.key == linear_probing::notPresent) {
                    std::cout << "Key not present";
                }
                break;
            }
            case 4:
                std::cout << "Enter element to generate hash = ";
                std::cin >> key;
                std::cout << "Hash of " << key
                          << " is = " << linear_probing::hashFxn(key);
                break;
            case 5:
                linear_probing::display();
                break;
            default:
                loop = false;
                break;
                        }
        std::cout << std::endl;
    }
    return 0;
}

#include <cmath>
#include <iostream>
#include <vector>


namespace quadratic_probing {
using Entry = struct Entry;
bool putProber(const Entry& entry, int key);
bool searchingProber(const Entry& entry, int key);
void add(int key);

int notPresent;
std::vector<Entry> table;
int totalSize;
int tomb = -1;
int size;
bool rehashing;


struct Entry {
    explicit Entry(int key = notPresent) : key(key) {}      int key;                                            };


size_t hashFxn(int key) {
    std::hash<int> hash;
    return hash(key);
}


int quadraticProbe(int key, bool searching) {
    int hash = static_cast<int>(hashFxn(key));
    int i = 0;
    Entry entry;
    do {
        size_t index =
            (hash + static_cast<size_t>(std::round(std::pow(i, 2)))) %
            totalSize;
        entry = table[index];
        if (searching) {
            if (entry.key == notPresent) {
                return notPresent;
            }
            if (searchingProber(entry, key)) {
                std::cout << "Found key!" << std::endl;
                return index;
            }
            std::cout << "Found tombstone or equal hash, checking next"
                      << std::endl;
            i++;
        } else {
            if (putProber(entry, key)) {
                if (!rehashing) {
                    std::cout << "Spot found!" << std::endl;
                }
                return index;
            }
            if (!rehashing) {
                std::cout << "Spot taken, looking at next (next index = "
                          << (hash + static_cast<size_t>(
                                         std::round(std::pow(i + 1, 2)))) %
                                 totalSize
                          << std::endl;
            }
            i++;
        }
        if (i == totalSize * 100) {
            std::cout << "Quadratic probe failed (infinite loop)" << std::endl;
            return notPresent;
        }
    } while (entry.key != notPresent);
    return notPresent;
}


bool putProber(const Entry& entry, int key) {
    if (entry.key == notPresent || entry.key == tomb) {
        return true;
    }
    return false;
}


bool searchingProber(const Entry& entry, int key) {
    if (entry.key == key) {
        return true;
    }
    return false;
}


Entry find(int key) {
    int index = quadraticProbe(key, true);
    if (index == notPresent) {
        return Entry();
    }
    return table[index];
}


void display() {
    for (int i = 0; i < totalSize; i++) {
        if (table[i].key == notPresent) {
            std::cout << " Empty ";
        } else if (table[i].key == tomb) {
            std::cout << " Tomb ";
        } else {
            std::cout << " ";
            std::cout << table[i].key;
            std::cout << " ";
        }
    }
    std::cout << std::endl;
}


void rehash() {
        rehashing = true;
    int oldSize = totalSize;
    std::vector<Entry> oldTable(table);
        totalSize *= 2;
    table = std::vector<Entry>(totalSize);
    for (int i = 0; i < oldSize; i++) {
        if (oldTable[i].key != -1 && oldTable[i].key != notPresent) {
            size--;              add(oldTable[i].key);
        }
    }
        rehashing = false;
    std::cout << "Table was rehashed, new size is: " << totalSize << std::endl;
}


void add(int key) {
    int index = quadraticProbe(key, false);
    table[index].key = key;
        if (++size / static_cast<double>(totalSize) >= 0.5) {
        rehash();
    }
}


void remove(int key) {
    int index = quadraticProbe(key, true);
    if (index == notPresent) {
        std::cout << "key not found" << std::endl;
    }
    table[index].key = tomb;
    std::cout << "Removal successful, leaving tombstone" << std::endl;
    size--;
}


void addInfo(int key) {
    std::cout << "Initial table: ";
    display();
    std::cout << std::endl;
    std::cout << "hash of " << key << " is " << hashFxn(key) << " % "
              << totalSize << " == " << hashFxn(key) % totalSize;
    std::cout << std::endl;
    add(key);
    std::cout << "New table: ";
    display();
}


void removalInfo(int key) {
    std::cout << "Initial table: ";
    display();
    std::cout << std::endl;
    std::cout << "hash of " << key << " is " << hashFxn(key) << " % "
              << totalSize << " == " << hashFxn(key) % totalSize;
    std::cout << std::endl;
    remove(key);
    std::cout << "New table: ";
    display();
}

}  

using quadratic_probing::Entry;
using quadratic_probing::table;
using quadratic_probing::totalSize;


int main() {
    int cmd = 0, hash = 0, key = 0;
    std::cout << "Enter the initial size of Hash Table. = ";
    std::cin >> totalSize;
    table = std::vector<Entry>(totalSize);
    bool loop = true;
    while (loop) {
        std::cout << std::endl;
        std::cout << "PLEASE CHOOSE -" << std::endl;
        std::cout << "1. Add key. (Numeric only)" << std::endl;
        std::cout << "2. Remove key." << std::endl;
        std::cout << "3. Find key." << std::endl;
        std::cout << "4. Generate Hash. (Numeric only)" << std::endl;
        std::cout << "5. Display Hash table." << std::endl;
        std::cout << "6. Exit." << std::endl;
        std::cin >> cmd;
        switch (cmd) {
            case 1:
                std::cout << "Enter key to add = ";
                std::cin >> key;
                quadratic_probing::addInfo(key);
                break;
            case 2:
                std::cout << "Enter key to remove = ";
                std::cin >> key;
                quadratic_probing::removalInfo(key);
                break;
            case 3: {
                std::cout << "Enter key to search = ";
                std::cin >> key;
                quadratic_probing::Entry entry =
                    quadratic_probing::table[quadratic_probing::quadraticProbe(
                        key, true)];
                if (entry.key == quadratic_probing::notPresent) {
                    std::cout << "Key not present";
                }
                break;
            }
            case 4:
                std::cout << "Enter element to generate hash = ";
                std::cin >> key;
                std::cout << "Hash of " << key
                          << " is = " << quadratic_probing::hashFxn(key);
                break;
            case 5:
                quadratic_probing::display();
                break;
            default:
                loop = false;
                break;
                        }
        std::cout << std::endl;
    }
    return 0;
}


#include<iostream>
#include<vector>
#include <cassert>


uint64_t fibo(uint64_t n , uint64_t mod )
{
	std::vector<uint64_t> result(2,0);
	std::vector<std::vector<uint64_t>> transition(2,std::vector<uint64_t>(2,0));
	std::vector<std::vector<uint64_t>> Identity(2,std::vector<uint64_t>(2,0));
	n--;
	result[0]=1, result[1]=1;
	Identity[0][0]=1; Identity[0][1]=0;
	Identity[1][0]=0; Identity[1][1]=1;
	 
	transition[0][0]=0;
	transition[1][0]=transition[1][1]=transition[0][1]=1;
	
	while(n)
	{
		if(n%2)
		{
			std::vector<std::vector<uint64_t>> res(2, std::vector<uint64_t>(2,0));
	                for(int i=0;i<2;i++)
			{
				for(int j=0;j<2;j++)
				{
					for(int k=0;k<2;k++)
						{
							res[i][j]=(res[i][j]%mod+((Identity[i][k]%mod*transition[k][j]%mod))%mod)%mod;
						}
				}
			}
		       	for(int i=0;i<2;i++)
			{
				for(int j=0;j<2;j++)
				{
				Identity[i][j]=res[i][j];
				}
	    		}
			n--;
		}
		else{
			std::vector<std::vector<uint64_t>> res1(2, std::vector<uint64_t>(2,0));
			for(int i=0;i<2;i++)
			{
				for(int j=0;j<2;j++)
				{
					for(int k=0;k<2;k++)
					{
						res1[i][j]=(res1[i][j]%mod+((transition[i][k]%mod*transition[k][j]%mod))%mod)%mod;
					}
				}
			}
			for(int i=0;i<2;i++)
			{
				for(int j=0;j<2;j++)
				{
					transition[i][j]=res1[i][j];
				}
			} 
			n=n/2;
			}
	}
	return ((result[0]%mod*Identity[0][0]%mod)%mod+(result[1]%mod*Identity[1][0]%mod)%mod)%mod;
}


void test()
{
    assert(fibo(6, 1000000007 ) == 8);
    std::cout << "test case:1 passed\n";
    assert(fibo(5, 1000000007  ) == 5);
    std::cout << "test case:2 passed\n";
    assert(fibo(10 , 1000000007) == 55);
    std::cout << "test case:3 passed\n";
    assert(fibo(500 , 100) == 25);
    std::cout << "test case:3 passed\n";
    assert(fibo(500 , 10000) == 4125);
    std::cout << "test case:3 passed\n";
    std::cout << "--All tests passed--\n";
}


int main()
{
	test();
	uint64_t mod=1000000007;
	std::cout<<"Enter the value of N: ";
	uint64_t n=0; std::cin>>n; 
	std::cout<<n<<"th Fibonacci number in modulo " << mod << ": "<< fibo( n , mod) << std::endl;
}

#include <cassert>
#include <iostream>


double Sqrt(double a) {
    if (a > 0 && a < 1) {
        return 1 / Sqrt(1 / a);
    }
    double l = 0, r = a;

    double epsilon = 1e-12;
    while (l <= r) {
        double mid = (l + r) / 2;
        if (mid * mid > a) {
            r = mid;
        } else {
            if (a - mid * mid < epsilon) {
                return mid;
            }
            l = mid;
        }
    }
    return -1;
}


int main() {
    double n{};
    std::cin >> n;
    assert(n >= 0);
        std::cout.precision(12);
    std::cout << std::fixed << Sqrt(n);
}

#define _USE_MATH_DEFINES
#include <cassert>   #include <cmath>     #include <cstdint>   #include <iostream>  

namespace math {

template <typename T>
T square_perimeter(T length) {
    return 4 * length;
}


template <typename T>
T rect_perimeter(T length, T width) {
    return 2 * (length + width);
}


template <typename T>
T triangle_perimeter(T base, T height, T hypotenuse) {
    return base + height + hypotenuse;
}


template <typename T>
T circle_perimeter(T radius) {
    return 2 * M_PI * radius;
}


template <typename T>
T parallelogram_perimeter(T base, T height) {
    return 2 * (base + height);
}


template <typename T>
T cube_surface_perimeter(T length) {
    return 12 * length;
}


template <typename T>
T n_polygon_surface_perimeter(T sides, T length) {
    return sides * length;
}


template <typename T>
T cylinder_surface_perimeter(T radius, T height) {
    return (2 * radius) + (2 * height);
}
}  

static void test() {
        uint16_t int_length = 0;          uint16_t int_width = 0;           uint16_t int_base = 0;            uint16_t int_height = 0;          uint16_t int_hypotenuse = 0;      uint16_t int_sides = 0;           uint16_t int_expected = 0;        uint16_t int_perimeter = 0;   
    float float_length = NAN;         float float_expected = NAN;       float float_perimeter = NAN;  
    double double_length = NAN;         double double_width = NAN;          double double_radius = NAN;         double double_height = NAN;         double double_expected = NAN;       double double_perimeter = NAN;  
        int_length = 5;
    int_expected = 20;
    int_perimeter = math::square_perimeter(int_length);

    std::cout << "perimeter OF A SQUARE (int)" << std::endl;
    std::cout << "Input Length: " << int_length << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_perimeter << std::endl;
    assert(int_perimeter == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        float_length = 2.5;
    float_expected = 10;
    float_perimeter = math::square_perimeter(float_length);

    std::cout << "perimeter OF A SQUARE (float)" << std::endl;
    std::cout << "Input Length: " << float_length << std::endl;
    std::cout << "Expected Output: " << float_expected << std::endl;
    std::cout << "Output: " << float_perimeter << std::endl;
    assert(float_perimeter == float_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        int_length = 4;
    int_width = 7;
    int_expected = 22;
    int_perimeter = math::rect_perimeter(int_length, int_width);

    std::cout << "perimeter OF A RECTANGLE (int)" << std::endl;
    std::cout << "Input Length: " << int_length << std::endl;
    std::cout << "Input Width: " << int_width << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_perimeter << std::endl;
    assert(int_perimeter == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_length = 2.5;
    double_width = 5.7;
    double_expected = 16.4;
    double_perimeter = math::rect_perimeter(double_length, double_width);

    std::cout << "perimeter OF A RECTANGLE (double)" << std::endl;
    std::cout << "Input Length: " << double_length << std::endl;
    std::cout << "Input Width: " << double_width << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_perimeter << std::endl;
    assert(double_perimeter == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        int_base = 10;
    int_height = 3;
    int_hypotenuse = 5;
    int_expected = 18;
    int_perimeter =
        math::triangle_perimeter(int_base, int_height, int_hypotenuse);

    std::cout << "perimeter OF A TRIANGLE" << std::endl;
    std::cout << "Input Base: " << int_base << std::endl;
    std::cout << "Input Height: " << int_height << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_perimeter << std::endl;
    assert(int_perimeter == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_radius = 6;
    double_expected =
        37.69911184307752;                                  double_perimeter = math::circle_perimeter(double_radius);

    std::cout << "perimeter OF A CIRCLE" << std::endl;
    std::cout << "Input Radius: " << double_radius << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_perimeter << std::endl;
    assert(double_perimeter == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        int_base = 6;
    int_height = 7;
    int_expected = 26;
    int_perimeter = math::parallelogram_perimeter(int_base, int_height);

    std::cout << "perimeter OF A PARALLELOGRAM" << std::endl;
    std::cout << "Input Base: " << int_base << std::endl;
    std::cout << "Input Height: " << int_height << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_perimeter << std::endl;
    assert(int_perimeter == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_length = 5.5;
    double_expected = 66.0;
    double_perimeter = math::cube_surface_perimeter(double_length);

    std::cout << "SURFACE perimeter OF A CUBE" << std::endl;
    std::cout << "Input Length: " << double_length << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_perimeter << std::endl;
    assert(double_perimeter == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        int_sides = 7;
    int_length = 10;
    int_expected = 70;
    int_perimeter = math::n_polygon_surface_perimeter(int_sides, int_length);

    std::cout << "SURFACE perimeter OF A N-POLYGON" << std::endl;
    std::cout << "Input Sides: " << int_sides << std::endl;
    std::cout << "Input Length: " << int_length << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_perimeter << std::endl;
    assert(int_perimeter == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_radius = 4.0;
    double_height = 7.0;
    double_expected = 22.0;
    double_perimeter =
        math::cylinder_surface_perimeter(double_radius, double_height);

    std::cout << "SURFACE perimeter OF A CYLINDER" << std::endl;
    std::cout << "Input Radius: " << double_radius << std::endl;
    std::cout << "Input Height: " << double_height << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_perimeter << std::endl;
    assert(double_perimeter == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;
}


int main() {
    test();      return 0;
}


#include <cassert>   #include <cstdint>   #include <cstdlib>   #include <iostream>  

namespace math {

namespace binomial {

size_t calculate(int32_t n, int32_t k) {
        if (k > (n / 2))
        k = n - k;
    if (k == 1)
        return n;
    if (k == 0)
        return 1;

    size_t result = 1;
    for (int32_t i = 1; i <= k; ++i) {
        result *= n - k + i;
        result /= i;
    }

    return result;
}
}  }  

static void tests() {
        assert(math::binomial::calculate(1, 1) == 1);
    assert(math::binomial::calculate(57, 57) == 1);
    assert(math::binomial::calculate(6, 3) == 20);
    assert(math::binomial::calculate(10, 5) == 252);
    assert(math::binomial::calculate(20, 10) == 184756);
    assert(math::binomial::calculate(30, 15) == 155117520);
    assert(math::binomial::calculate(40, 20) == 137846528820);
    assert(math::binomial::calculate(50, 25) == 126410606437752);
    assert(math::binomial::calculate(60, 30) == 118264581564861424);
    assert(math::binomial::calculate(62, 31) == 465428353255261088);

    std::cout << "[+] Binomial coefficients calculate test completed"
              << std::endl;
}


int main(int argc, const char* argv[]) {
    tests();  
    if (argc < 3) {
        std::cout << "Usage ./binomial_calculate {n} {k}" << std::endl;
        return 0;
    }

    int32_t n = atoi(argv[1]);
    int32_t k = atoi(argv[2]);

    std::cout << math::binomial::calculate(n, k) << std::endl;
    return 0;
}

#include <cassert>
#include <iostream>


int sum_of_digits(int num) {
        if (num < 0) {
        num = -1 * num;
    }
    int sum = 0;
    while (num > 0) {
        sum = sum + (num % 10);
        num = num / 10;
    }
    return sum;
}


void test1() {
    int test_case_1 = sum_of_digits(119765);
    assert(test_case_1 == 29);
}


void test2() {
    int test_case_2 = sum_of_digits(-12256);
    assert(test_case_2 == 16);
}


void test() {
        test1();
        test2();
}


int main() {
    test();
    std::cout << "Success." << std::endl;
    return 0;
}

#include <iostream>


unsigned int factorial(unsigned int n) {
    if (n == 0)
        return 1;
    return n * factorial(n - 1);
}


int main() {
    int num = 5;
    std::cout << "Factorial of " << num << " is " << factorial(num)
              << std::endl;
    return 0;
}


#include <iostream>
#include <vector>


int64_t binExpo(int64_t a, int64_t b, int64_t m) {
    a %= m;
    int64_t res = 1;
    while (b > 0) {
        if (b % 2) {
            res = res * a % m;
        }
        a = a * a % m;
                b >>= 1;
    }
    return res;
}


bool isPrime(int64_t m) {
    if (m <= 1) {
        return false;
    } else {
        for (int64_t i = 2; i * i <= m; i++) {
            if (m % i == 0) {
                return false;
            }
        }
    }
    return true;
}


int main() {
    int64_t a, m;
        std::cout << "Computing ((a^(-1))%(m)) using Fermat's Little Theorem";
    std::cout << std::endl << std::endl;
    std::cout << "Give input 'a' and 'm' space separated : ";
    std::cin >> a >> m;
    if (isPrime(m)) {
        std::cout << "The modular inverse of a with mod m is (a^(m-2)) : ";
        std::cout << binExpo(a, m - 2, m) << std::endl;
    } else {
        std::cout << "m must be a prime number.";
        std::cout << std::endl;
    }
}


#include <cassert>   #include <iostream>  #include <vector>    

namespace math {

namespace ncr_modulo_p {

class NCRModuloP {
 private:
    std::vector<uint64_t> fac{};      uint64_t p = 0;               
 public:
    
    NCRModuloP(const uint64_t& size, const uint64_t& mod) {
        p = mod;
        fac = std::vector<uint64_t>(size);
        fac[0] = 1;
        for (int i = 1; i <= size; i++) {
            fac[i] = (fac[i - 1] * i) % p;
        }
    }

    
    uint64_t gcdExtended(const uint64_t& a, const uint64_t& b, int64_t* x,
                         int64_t* y) {
        if (a == 0) {
            *x = 0, *y = 1;
            return b;
        }

        int64_t x1 = 0, y1 = 0;
        uint64_t gcd = gcdExtended(b % a, a, &x1, &y1);

        *x = y1 - (b / a) * x1;
        *y = x1;
        return gcd;
    }

    
    int64_t modInverse(const uint64_t& a, const uint64_t& m) {
        int64_t x = 0, y = 0;
        uint64_t g = gcdExtended(a, m, &x, &y);
        if (g != 1) {              return -1;
        } else {
            int64_t res = ((x + m) % m);
            return res;
        }
    }

    
    int64_t ncr(const uint64_t& n, const uint64_t& r, const uint64_t& p) {
                if (r > n) {
            return 0;
        }
        if (r == 1) {
            return n % p;
        }
        if (r == 0 || r == n) {
            return 1;
        }
                int64_t denominator = modInverse(fac[r], p);
        if (denominator < 0) {              return -1;
        }
        denominator = (denominator * modInverse(fac[n - r], p)) % p;
        if (denominator < 0) {              return -1;
        }
        return (fac[n] * denominator) % p;
    }
};
}  }  

static void tests(math::ncr_modulo_p::NCRModuloP ncrObj) {
        assert(ncrObj.ncr(52323, 26161, 1000000007) == 224944353);
        assert(ncrObj.ncr(6, 2, 5) == 0);
        assert(ncrObj.ncr(7, 3, 29) == 6);
}


int main() {
        const uint64_t size = 1e6 + 1;
    const uint64_t p = 1e9 + 7;
    math::ncr_modulo_p::NCRModuloP ncrObj =
        math::ncr_modulo_p::NCRModuloP(size, p);
        for (int i = 0; i <= 7; i++) {
        std::cout << 6 << "C" << i << " = " << ncrObj.ncr(6, i, p) << "\n";
    }
    tests(ncrObj);      std::cout << "Assertions passed\n";
    return 0;
}


#include <cassert>   #include <iostream>  #include <vector>    

namespace math {

uint64_t lcmSum(const uint16_t& num) {
    uint64_t i = 0, j = 0;
    std::vector<uint64_t> eulerTotient(num + 1);
    std::vector<uint64_t> sumOfEulerTotient(num + 1);

        for (i = 1; i <= num; i++) {
        eulerTotient[i] = i;
    }

        for (i = 2; i <= num; i++) {
        if (eulerTotient[i] == i) {
            for (j = i; j <= num; j += i) {
                eulerTotient[j] = eulerTotient[j] / i;
                eulerTotient[j] = eulerTotient[j] * (i - 1);
            }
        }
    }

        for (i = 1; i <= num; i++) {
        for (j = i; j <= num; j += i) {
            sumOfEulerTotient[j] += eulerTotient[i] * i;
        }
    }

    return ((sumOfEulerTotient[num] + 1) * num) / 2;
}
}  

static void test() {
    uint64_t n = 2;
    uint64_t test_1 = math::lcmSum(n);
    assert(test_1 == 4);
    std::cout << "Passed Test 1!" << std::endl;

    n = 5;
    uint64_t test_2 = math::lcmSum(n);
    assert(test_2 == 55);
    std::cout << "Passed Test 2!" << std::endl;

    n = 10;
    uint64_t test_3 = math::lcmSum(n);
    assert(test_3 == 320);
    std::cout << "Passed Test 3!" << std::endl;

    n = 11;
    uint64_t test_4 = math::lcmSum(n);
    assert(test_4 == 616);
    std::cout << "Passed Test 4!" << std::endl;

    n = 15;
    uint64_t test_5 = math::lcmSum(n);
    assert(test_5 == 1110);
    std::cout << "Passed Test 5!" << std::endl;
}


int main() {
    test();      return 0;
}

#include <cassert>   #include <iostream>  

namespace math {


uint64_t binomialCoeffSum(uint64_t n) {
        return (1 << n);
}
}  

static void test() {
    int test_case_1 = math::binomialCoeffSum(2);
    assert(test_case_1 == 4);
    std::cout << "Test_case_1 Passed!" << std::endl;

    int test_case_2 = math::binomialCoeffSum(3);
    assert(test_case_2 == 8);
    std::cout << "Test_case_2 Passed!" << std::endl;

    int test_case_3 = math::binomialCoeffSum(4);
    assert(test_case_3 == 16);
    std::cout << "Test_case_3 Passed!" << std::endl;

    int test_case_4 = math::binomialCoeffSum(5);
    assert(test_case_4 == 32);
    std::cout << "Test_case_4 Passed!" << std::endl;

    int test_case_5 = math::binomialCoeffSum(7);
    assert(test_case_5 == 128);
    std::cout << "Test_case_5 Passed!" << std::endl;
}


int main() {
    test();      return 0;
}

#include <cassert>
#include <cmath>
#include <iostream>


int number_of_digits(int num) {
    int total_digits = 0;
    while (num > 0) {
        num = num / 10;
        ++total_digits;
    }
    return total_digits;
}


bool is_armstrong(int number) {
        if (number < 0) {
        return false;
    }
    int sum = 0;
    int temp = number;
        int total_digits = number_of_digits(number);
    while (temp > 0) {
        int rem = temp % 10;
                        sum = sum + std::pow(rem, total_digits);
        temp = temp / 10;
    }
    return number == sum;
}


void test() {
        assert(is_armstrong(370) == true);
        assert(is_armstrong(225) == false);
        assert(is_armstrong(-23) == false);
        assert(is_armstrong(153) == true);
        assert(is_armstrong(0) == true);
        assert(is_armstrong(12) == false);
}


int main() {
    test();
    return 0;
}

#include <cassert>
#include <iostream>


int sum_of_divisor(int num) {
        int sum = 0;
            for (int div = 2; div * div <= num; ++div) {
                if (num % div == 0) {
                        if (div == (num / div)) {
                sum += div;
            } else {
                                sum += (div + (num / div));
            }
        }
    }
    return sum + 1;
}


bool are_amicable(int x, int y) {
    return (sum_of_divisor(x) == y) && (sum_of_divisor(y) == x);
}


void test() {
        assert(are_amicable(220, 284) == true);
        assert(are_amicable(6368, 6232) == true);
        assert(are_amicable(458, 232) == false);
}


int main() {
    test();
    std::cout << "Assertion Success." << std::endl;
    return 0;
}


#include <iostream>

int binExpo(int a, int b) {
    if (b == 0) {
        return 1;
    }
    int res = binExpo(a, b / 2);
    if (b % 2) {
        return res * res * a;
    } else {
        return res * res;
    }
}

int binExpo_alt(int a, int b) {
    int res = 1;
    while (b > 0) {
        if (b % 2) {
            res = res * a;
        }
        a = a * a;
        b /= 2;
    }
    return res;
}

int main() {
    int a, b;
        std::cin >> a >> b;
    if (a == 0 && b == 0) {
        std::cout << "Math error" << std::endl;
    } else if (b < 0) {
        std::cout << "Exponent must be positive !!" << std::endl;
    } else {
        int resRecurse = binExpo(a, b);
        
                std::cout << resRecurse << std::endl;
            }
}


#include <cassert>   #include <iostream>  

namespace math {

template <class T>
T n_choose_r(T n, T r) {
    if (r > n / 2) {
        r = n - r;      }
    T ans = 1;
    for (int i = 1; i <= r; i++) {
        ans *= n - r + i;
        ans /= i;
    }
    return ans;
}
}  

static void test() {
        uint8_t t = math::n_choose_r(5, 2);
    assert(((void)"10 is the answer but function says otherwise.\n", t == 10));
    std::cout << "First test passes." << std::endl;
        t = math::n_choose_r(5, 3);
    assert(
        ((void)"10 is the answer but the function says otherwise.\n", t == 10));
    std::cout << "Second test passes." << std::endl;
        t = math::n_choose_r(3, 2);
    assert(
        ((void)"3 is the answer but the function says otherwise.\n", t == 3));
    std::cout << "Third test passes." << std::endl;
        t = math::n_choose_r(10, 4);
    assert(((void)"210 is the answer but the function says otherwise.\n",
            t == 210));
    std::cout << "Fourth test passes." << std::endl;
}


int main(int argc, char *argv[]) {
    test();      return 0;
}

#include <iostream>
#include <vector>


std::vector<int> primes(size_t max) {
    std::vector<int> res;
    std::vector<bool> is_not_prime(max + 1, false);
    for (size_t i = 2; i <= max; i++) {
        if (!is_not_prime[i]) {
            res.emplace_back(i);
        }
        for (int p : res) {
            size_t k = i * p;
            if (k > max) {
                break;
            }
            is_not_prime[k] = true;
            if (i % p == 0) {
                break;
            }
        }
    }
    return res;
}


int main() {
    std::cout << "Calculate primes up to:\n>> ";
    int n = 0;
    std::cin >> n;
    std::vector<int> ans = primes(n);
    for (int p : ans) std::cout << p << ' ';
    std::cout << std::endl;
}


#include <iostream>
#include <array>
#include <cmath>
#include <cassert>


namespace math {
	
	namespace vector_cross {
		
		std::array<double, 3> cross(const std::array<double, 3> &A, const std::array<double, 3> &B) {
			std::array<double, 3> product;
						product[0] = (A[1] * B[2]) - (A[2] * B[1]);
			product[1] = -((A[0] * B[2]) - (A[2] * B[0]));
			product[2] = (A[0] * B[1]) - (A[1] * B[0]);
			return product;
		}

		
		double mag(const std::array<double, 3> &vec) {
			double magnitude = sqrt((vec[0] * vec[0]) + (vec[1] * vec[1]) + (vec[2] * vec[2]));
			return magnitude;
		}
	} } 

static void test() {
		std::array<double, 3> t_vec = math::vector_cross::cross({1, 2, 3}, {4, 5, 6});
	assert(t_vec[0] == -3 && t_vec[1] == 6 && t_vec[2] == -3);

		double t_mag = math::vector_cross::mag({6, 8, 0});
	assert(t_mag == 10);
}


int main() {

		test();

	std::array<double, 3> vec1;
	std::array<double, 3> vec2;

		std::cout << "\nPass the first Vector: ";
	std::cin >> vec1[0] >> vec1[1] >> vec1[2];

		std::cout << "\nPass the second Vector: ";
	std::cin >> vec2[0] >> vec2[1] >> vec2[2];

		std::array<double, 3> product = math::vector_cross::cross(vec1, vec2);
	std::cout << "\nThe cross product is: " << product[0] << " " << product[1] << " " << product[2] << std::endl;

		std::cout << "Magnitude: " << math::vector_cross::mag(product) << "\n" << std::endl;

	return 0;
}

#include <cassert>
#include <iostream>


uint64_t fibonacci(uint64_t n) {

    if (n <= 1) {
        return n;
    }

    return fibonacci(n - 1) + fibonacci(n - 2);
}


static void test() {
    uint64_t test_case_1 = fibonacci(0);
    assert(test_case_1 == 0);
    std::cout << "Passed Test 1!" << std::endl;

    uint64_t test_case_2 = fibonacci(1);
    assert(test_case_2 == 1);
    std::cout << "Passed Test 2!" << std::endl;

    uint64_t test_case_3 = fibonacci(2);
    assert(test_case_3 == 1);
    std::cout << "Passed Test 3!" << std::endl;

    uint64_t test_case_4 = fibonacci(3);
    assert(test_case_4 == 2);
    std::cout << "Passed Test 4!" << std::endl;

    uint64_t test_case_5 = fibonacci(4);
    assert(test_case_5 == 3);
    std::cout << "Passed Test 5!" << std::endl;

    uint64_t test_case_6 = fibonacci(15);
    assert(test_case_6 == 610);
    std::cout << "Passed Test 6!" << std::endl << std::endl;
}

int main() {
    test();
    int n = 0;
    std::cin >> n;
    assert(n >= 0);
    std::cout << "F(" << n << ")= " << fibonacci(n) << std::endl;
}


#include <cassert>   #include <iostream>  #include <vector>    

namespace math {

namespace fibonacci_sum {
using matrix = std::vector<std::vector<uint64_t> >;


math::fibonacci_sum::matrix multiply(const math::fibonacci_sum::matrix &T,
                                     const math::fibonacci_sum::matrix &A) {
    math::fibonacci_sum::matrix result(2, std::vector<uint64_t>(2, 0));

        result[0][0] = T[0][0] * A[0][0] + T[0][1] * A[1][0];
    result[0][1] = T[0][0] * A[0][1] + T[0][1] * A[1][1];
    result[1][0] = T[1][0] * A[0][0] + T[1][1] * A[1][0];
    result[1][1] = T[1][0] * A[0][1] + T[1][1] * A[1][1];

    return result;
}


math::fibonacci_sum::matrix power(math::fibonacci_sum::matrix T, uint64_t ex) {
    math::fibonacci_sum::matrix A{{1, 1}, {1, 0}};
    if (ex == 0 || ex == 1) {
        return T;
    }

    T = power(T, ex / 2);
    T = multiply(T, T);
    if (ex & 1) {
        T = multiply(T, A);
    }
    return T;
}


uint64_t result(uint64_t n) {
    math::fibonacci_sum::matrix T{{1, 1}, {1, 0}};
    T = power(T, n);
    uint64_t ans = T[0][1];
    ans = (ans - 1);
    return ans;
}


uint64_t fiboSum(uint64_t n, uint64_t m) {
    return (result(m + 2) - result(n + 1));
}
}  }  

static void test() {
    uint64_t n = 0, m = 3;
    uint64_t test_1 = math::fibonacci_sum::fiboSum(n, m);
    assert(test_1 == 4);
    std::cout << "Passed Test 1!" << std::endl;

    n = 3;
    m = 5;
    uint64_t test_2 = math::fibonacci_sum::fiboSum(n, m);
    assert(test_2 == 10);
    std::cout << "Passed Test 2!" << std::endl;

    n = 5;
    m = 7;
    uint64_t test_3 = math::fibonacci_sum::fiboSum(n, m);
    assert(test_3 == 26);
    std::cout << "Passed Test 3!" << std::endl;

    n = 7;
    m = 10;
    uint64_t test_4 = math::fibonacci_sum::fiboSum(n, m);
    assert(test_4 == 123);
    std::cout << "Passed Test 4!" << std::endl;

    n = 9;
    m = 12;
    uint64_t test_5 = math::fibonacci_sum::fiboSum(n, m);
    assert(test_5 == 322);
    std::cout << "Passed Test 5!" << std::endl;
}


int main() {
    test();      return 0;
}


#include <iostream> #include <cassert>  

namespace math {

	 
    uint64_t largestPower(uint32_t n, const uint16_t& p)  
    {  
                int x = 0;  
  
                while (n)  
        {  
            n /= p;  
            x += n;  
        }  
        return x;  
    }

}  

static void test()
{
	uint8_t test_case_1 = math::largestPower(5,2);
	assert(test_case_1==3);
	std::cout<<"Test 1 Passed!"<<std::endl;
	
	uint16_t test_case_2 = math::largestPower(10,3);
	assert(test_case_2==4);
	std::cout<<"Test 2 Passed!"<<std::endl;
	
	uint32_t test_case_3 = math::largestPower(25,5);
	assert(test_case_3==6);
	std::cout<<"Test 3 Passed!"<<std::endl;
	
	uint32_t test_case_4 = math::largestPower(27,2);
	assert(test_case_4==23);
	std::cout<<"Test 4 Passed!"<<std::endl;
	
	uint16_t test_case_5 = math::largestPower(7,3);
	assert(test_case_5==2);
	std::cout<<"Test 5 Passed!"<<std::endl;
} 


int main() 
{ 
    test();     return 0;
} 

#include <iostream>


int gcd(int *a, int n) {
    int j = 1;      int gcd = a[0];
    while (j < n) {
        if (a[j] % gcd == 0)              j++;                      else
            gcd = a[j] % gcd;      }
    return gcd;
}


int main() {
    int n;
    std::cout << "Enter value of n:" << std::endl;
    std::cin >> n;
    int *a = new int[n];
    int i;
    std::cout << "Enter the n numbers:" << std::endl;
    for (i = 0; i < n; i++) std::cin >> a[i];

    std::cout << "GCD of entered n numbers:" << gcd(a, n) << std::endl;

    delete[] a;
    return 0;
}


#include <cassert>
#include <iostream>


unsigned int gcd(unsigned int x, unsigned int y) {
    if (x == 0) {
        return y;
    }
    if (y == 0) {
        return x;
    }
    if (x == y) {
        return x;
    }
    if (x > y) {
        
        unsigned int temp = x / y;
        return gcd(y, x - temp * y);
    }
    
    unsigned int temp = y / x;
    return gcd(x, y - temp * x);
}


unsigned int lcm(unsigned int x, unsigned int y) {
  return x / gcd(x, y) * y;
}


void tests() {
        assert(((void)"LCM of 5 and 10 is 10 but lcm function gives a different "
                  "result.\n",
            lcm(5, 10) == 10));
    std::cout << "First assertion passes: LCM of 5 and 10 is " << lcm(5, 10)
              << std::endl;

        assert(((void)"LCM of 2 and 3 is 6 but lcm function gives a different "
                  "result.\n",
            lcm(2, 3) == 6));
    std::cout << "Second assertion passes: LCM of 2 and 3 is " << lcm(2, 3)
              << std::endl;

            assert(((void)"LCM of 987654321 and 987654321 is 987654321 but lcm function"
                  " gives a different result.\n",
            lcm(987654321, 987654321) == 987654321));
    std::cout << "Third assertion passes: LCM of 987654321 and 987654321 is "
              << lcm(987654321, 987654321)
              << std::endl;
}


int main() {
    tests();
    return 0;
}


#include <cassert>   #include <cmath>     #include <iostream>  #include <limits>    

template <typename T = double, char iterations = 2>
inline T Fast_InvSqrt(T x) {
    using Tint = typename std::conditional<sizeof(T) == 8, std::int64_t,
                                           std::int32_t>::type;
    T y = x;
    T x2 = y * 0.5;

    Tint i =
        *reinterpret_cast<Tint *>(&y);  
    i = (sizeof(T) == 8 ? 0x5fe6eb50c7b537a9 : 0x5f3759df) -
        (i >> 1);  
    y = *reinterpret_cast<T *>(&i);  
    y = y * (1.5 - (x2 * y * y));      if (iterations == 2) {
        y = y * (1.5 - (x2 * y * y));      }
    return y;
}


template <typename T = double>
T Standard_InvSqrt(T number) {
    T squareRoot = sqrt(number);
    return 1.0f / squareRoot;
}


static void test() {
    const float epsilon = 1e-3f;

    assert(std::fabs(Standard_InvSqrt<float>(100.0f) - 0.0998449f) < epsilon);
    assert(std::fabs(Standard_InvSqrt<double>(36.0f) - 0.166667f) < epsilon);
    assert(std::fabs(Standard_InvSqrt(12.0f) - 0.288423f) < epsilon);
    assert(std::fabs(Standard_InvSqrt<double>(5.0f) - 0.447141f) < epsilon);

    assert(std::fabs(Fast_InvSqrt<float, 1>(100.0f) - 0.0998449f) < epsilon);
    assert(std::fabs(Fast_InvSqrt<double, 1>(36.0f) - 0.166667f) < epsilon);
    assert(std::fabs(Fast_InvSqrt(12.0f) - 0.288423) < epsilon);
    assert(std::fabs(Fast_InvSqrt<double>(5.0f) - 0.447141) < epsilon);
}


int main() {
    test();      std::cout << "The Fast inverse square root of 36 is: "
              << Fast_InvSqrt<float, 1>(36.0f) << std::endl;
    std::cout << "The Fast inverse square root of 36 is: "
              << Fast_InvSqrt<double, 2>(36.0f) << " (2 iterations)"
              << std::endl;
    std::cout << "The Fast inverse square root of 100 is: "
              << Fast_InvSqrt(100.0f)
              << " (With default template type and iterations: double, 2)"
              << std::endl;
    std::cout << "The Standard inverse square root of 36 is: "
              << Standard_InvSqrt<float>(36.0f) << std::endl;
    std::cout << "The Standard inverse square root of 100 is: "
              << Standard_InvSqrt(100.0f)
              << " (With default template type: double)" << std::endl;
}


#include <cassert>   #include <iostream>  

uint64_t imod(uint64_t x, uint64_t y) {
    uint64_t aux = 0;      uint64_t itr = 0;  
    do {          aux = y * itr + 1;
        itr++;
    } while (aux % x);  
    return aux / x;
}


static void test() {
    std::cout << "First case testing... \n";
        assert(imod(3, 11) == 4);
    std::cout << "\nPassed!\n";

    std::cout << "Second case testing... \n";
        assert(imod(3, 26) == 9);
    std::cout << "\nPassed!\n";

    std::cout << "Third case testing... \n";
        assert(imod(7, 26) == 15);
    std::cout << "\nPassed!\n";

    std::cout << "\nAll test cases have successfully passed!\n";
}

int main() {
    test();  };


#include <cassert>   #include <iostream>  

namespace math {

namespace modular_division {

uint64_t power(uint64_t a, uint64_t b, uint64_t c) {
    uint64_t ans = 1;      a = a % c;             if (a == 0) {
        return 0;      }
    while (b > 0) {
                if (b & 1) {
            ans = ((ans % c) * (a % c)) % c;
        }
                b = b >> 1;          a = ((a % c) * (a % c)) % c;
    }
    return ans;
}


uint64_t mod_division(uint64_t a, uint64_t b, uint64_t p) {
    uint64_t inverse = power(b, p - 2, p) % p;      uint64_t result =
        ((a % p) * (inverse % p)) % p;      return result;
}
}  }  

static void test() {
    uint64_t test_case_1 = math::modular_division::mod_division(8, 2, 2);
    assert(test_case_1 == 0);
    std::cout << "Test 1 Passed!" << std::endl;
    uint64_t test_case_2 = math::modular_division::mod_division(15, 3, 7);
    assert(test_case_2 == 5);
    std::cout << "Test 2 Passed!" << std::endl;
    uint64_t test_case_3 = math::modular_division::mod_division(10, 5, 2);
    assert(test_case_3 == 0);
    std::cout << "Test 3 Passed!" << std::endl;
    uint64_t test_case_4 = math::modular_division::mod_division(81, 3, 5);
    assert(test_case_4 == 2);
    std::cout << "Test 4 Passed!" << std::endl;
    uint64_t test_case_5 = math::modular_division::mod_division(12848, 73, 29);
    assert(test_case_5 == 2);
    std::cout << "Test 5 Passed!" << std::endl;
}


int main(int argc, char *argv[]) {
    test();      return 0;
}


#include <cinttypes>
#include <cstdio>
#include <iostream>



#define MAX 93


uint64_t fib(uint64_t n) {
    static uint64_t f1 = 1,
                    f2 = 1;                               
    if (n <= 2)
        return f2;
    if (n >= 93) {
        std::cerr
            << "Cannot compute for n>93 due to limit of 64-bit integers\n";
        return 0;
    }

    uint64_t temp = f2;      f2 += f1;
    f1 = temp;

    return f2;
}


int main() {
        for (uint64_t i = 1; i < 93; i++) {
        std::cout << i << " th fibonacci number is " << fib(i) << std::endl;
    }
    return 0;
}

#include <cstring>
#include <iostream>


char prime[100000000];


void Sieve(int64_t n) {
    memset(prime, '1', sizeof(prime));      prime[0] = '0';                         prime[1] = '0';                         for (int64_t p = 2; p * p <= n; p++) {
        if (prime[p] == '1') {
            for (int64_t i = p * p; i <= n; i += p)
                prime[i] = '0';          }
    }
}


int main() {
    Sieve(100000000);
    int64_t n;
    std::cin >> n;      if (prime[n] == '1')
        std::cout << "YES\n";
    else
        std::cout << "NO\n";

    return 0;
}

#include <cassert>   #include <iostream>  #include <vector>    

namespace math {

namespace linear_recurrence_matrix {

template <typename T = int64_t>
std::vector<std::vector<T>> matrix_multiplication(
    const std::vector<std::vector<T>>& _mat_a,
    const std::vector<std::vector<T>>& _mat_b, const int64_t mod = 1000000007) {
        assert(_mat_a[0].size() == _mat_b.size());
    std::vector<std::vector<T>> _mat_c(_mat_a.size(),
                                       std::vector<T>(_mat_b[0].size(), 0));
    
    for (uint32_t i = 0; i < _mat_a.size(); ++i) {
        for (uint32_t j = 0; j < _mat_b[0].size(); ++j) {
            for (uint32_t k = 0; k < _mat_b.size(); ++k) {
                _mat_c[i][j] =
                    (_mat_c[i][j] % mod +
                     (_mat_a[i][k] % mod * _mat_b[k][j] % mod) % mod) %
                    mod;
            }
        }
    }
    return _mat_c;
}

template <typename T = int64_t>
bool is_zero_matrix(const std::vector<std::vector<T>>& _mat) {
    for (uint32_t i = 0; i < _mat.size(); ++i) {
        for (uint32_t j = 0; j < _mat[i].size(); ++j) {
            if (_mat[i][j] != 0) {
                return false;
            }
        }
    }
    return true;
}


template <typename T = int64_t>
std::vector<std::vector<T>> matrix_exponentiation(
    std::vector<std::vector<T>> _mat, uint64_t power,
    const int64_t mod = 1000000007) {
    
    if (is_zero_matrix(_mat)) {
        return _mat;
    }

    std::vector<std::vector<T>> _mat_answer(_mat.size(),
                                            std::vector<T>(_mat.size(), 0));

    for (uint32_t i = 0; i < _mat.size(); ++i) {
        _mat_answer[i][i] = 1;
    }
        while (power > 0) {
        if (power & 1) {
            _mat_answer = matrix_multiplication(_mat_answer, _mat, mod);
        }
        power >>= 1;
        _mat = matrix_multiplication(_mat, _mat, mod);
    }

    return _mat_answer;
}


template <typename T = int64_t>
T get_nth_term_of_recurrence_series(
    const std::vector<std::vector<T>>& _mat,
    const std::vector<std::vector<T>>& _base_cases, uint64_t nth_term,
    bool constant_or_sum_included = false) {
    assert(_mat.size() == _base_cases.back().size());

    

    if (nth_term < _base_cases.back().size() - constant_or_sum_included) {
        return _base_cases.back()[nth_term - constant_or_sum_included];
    } else {
        
        std::vector<std::vector<T>> _res_matrix =
            matrix_exponentiation(_mat, nth_term - _base_cases.back().size() +
                                            1 + constant_or_sum_included);

        
        std::vector<std::vector<T>> _res =
            matrix_multiplication(_base_cases, _res_matrix);

        return _res.back().back();
    }
}
}  }  

static void test() {

    std::vector<std::vector<int64_t>> fibonacci_matrix = {{0, 1}, {1, 1}},
                                      fib_base_case = {{0, 1}};

    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               fibonacci_matrix, fib_base_case, 11) == 89LL);
    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               fibonacci_matrix, fib_base_case, 39) == 63245986LL);

    std::vector<std::vector<int64_t>> tribonacci = {{0, 0, 1},
                                                    {1, 0, 1},
                                                    {0, 1, 1}},
                                      trib_base_case = {
                                          {0, 0, 1}};  
    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               tribonacci, trib_base_case, 11) == 149LL);
    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               tribonacci, trib_base_case, 36) == 615693474LL);


    std::vector<std::vector<int64_t>> pell_recurrence = {{0, 1}, {1, 2}},
                                      pell_base_case = {
                                          {2, 2}};  
    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               pell_recurrence, pell_base_case, 15) == 551614LL);
    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               pell_recurrence, pell_base_case, 23) == 636562078LL);


    std::vector<std::vector<int64_t>>
        custom_recurrence = {{1, 0, 1}, {0, 0, 1}, {0, 1, 2}},
        custom_base_case = {{7, 2, 2}};  
    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               custom_recurrence, custom_base_case, 10, 1) == 18493LL);
    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               custom_recurrence, custom_base_case, 19, 1) == 51531251LL);



    std::vector<std::vector<int64_t>> sum_fibo_recurrence = {{0, 1, 1},
                                                             {1, 1, 1},
                                                             {0, 0, 1}},
                                      sum_fibo_base_case = {
                                          {0, 1, 1}};  
    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               sum_fibo_recurrence, sum_fibo_base_case, 13, 1) == 609LL);
    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               sum_fibo_recurrence, sum_fibo_base_case, 16, 1) == 2583LL);

    std::vector<std::vector<int64_t>> tribonacci_sum = {{0, 0, 1, 1},
                                                        {1, 0, 1, 1},
                                                        {0, 1, 1, 1},
                                                        {0, 0, 0, 1}},
                                      trib_sum_base_case = {{0, 0, 1, 1}};
    
    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               tribonacci_sum, trib_sum_base_case, 18, 1) == 23249LL);
    assert(math::linear_recurrence_matrix::get_nth_term_of_recurrence_series(
               tribonacci_sum, trib_sum_base_case, 19, 1) == 42762LL);
}


int main() {
    test();      return 0;
}


#include <iostream>  #include <vector>    #include <cstdlib>  

namespace math {

    
    typedef struct {
    double x;
    double y;
    } Point;

    double  approximate_pi(const std::vector<Point> &pts) {
    
        {
            int count =0;                for(Point p:pts)
                if(p.x * p.x + p.y*p.y <= 1)
                    ++count;
            
            return 4.0*count/pts.size();
        }
    }
}  

static void test() {
        std::vector<math::Point> rands;
    for (std::size_t i = 0; i < 100000; i++) {
        math::Point p;
        p.x = rand() / (double)RAND_MAX;         p.y = rand() / (double)RAND_MAX;         rands.push_back(p);
    }
    std::cout << math::approximate_pi(rands) << std::endl;          }


int main(int argc, char *argv[]) {
    test();      return 0;
}

#include <cassert>
#include <iostream>



bool is_factorial(uint64_t n) {
    if (n <= 0) {
        return false;
    }
    for (uint32_t i = 1;; i++) {
        if (n % i != 0) {
            break;
        }
        n = n / i;
    }
    if (n == 1) {
        return true;
    } else {
        return false;
    }
}


void tests() {
    std::cout << "Test 1:\t n=50\n";
    assert(is_factorial(50) == false);
    std::cout << "passed\n";

    std::cout << "Test 2:\t n=720\n";
    assert(is_factorial(720) == true);
    std::cout << "passed\n";

    std::cout << "Test 3:\t n=0\n";
    assert(is_factorial(0) == false);
    std::cout << "passed\n";

    std::cout << "Test 4:\t n=479001600\n";
    assert(is_factorial(479001600) == true);
    std::cout << "passed\n";

    std::cout << "Test 5:\t n=-24\n";
    assert(is_factorial(-24) == false);
    std::cout << "passed\n";
}


int main() {
    tests();
    return 0;
}


#include <cassert>
#include <iostream>
#include <vector>


std::vector<bool> sieve(uint32_t N) {
    std::vector<bool> is_prime(N + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (uint32_t i = 2; i * i <= N; i++) {
        if (is_prime[i]) {
            for (uint32_t j = i * i; j <= N; j += i) {
                is_prime[j] = false;
            }
        }
    }
    return is_prime;
}


void print(uint32_t N, const std::vector<bool> &is_prime) {
    for (uint32_t i = 2; i <= N; i++) {
        if (is_prime[i]) {
            std::cout << i << ' ';
        }
    }
    std::cout << std::endl;
}


void tests() {
    std::vector<bool> ans{false, false, true, true, false, true, false, true, false, false, false};
  assert(sieve(10) == ans);
}


int main() {
    tests();

    uint32_t N = 100;
    std::vector<bool> is_prime = sieve(N);
    print(N, is_prime);
    return 0;
}


#include <cinttypes>
#include <ctime>
#include <iostream>

#include "./large_number.h"


large_number fib(uint64_t n) {
    large_number f0(1);
    large_number f1(1);

    do {
        large_number f2 = f1;
        f1 += f0;
        f0 = f2;
        n--;
    } while (n > 2);  
    return f1;
}

int main(int argc, char *argv[]) {
    uint64_t N;
    if (argc == 2) {
        N = strtoull(argv[1], NULL, 10);
    } else {
        std::cout << "Enter N: ";
        std::cin >> N;
    }

    clock_t start_time = std::clock();
    large_number result = fib(N);
    clock_t end_time = std::clock();
    double time_taken = static_cast<double>(end_time - start_time) /
                        static_cast<double>(CLOCKS_PER_SEC);

    std::cout << std::endl
              << N << "^th Fibonacci number: " << result << std::endl
              << "Number of digits: " << result.num_digits() << std::endl
              << "Time taken: " << std::scientific << time_taken << " s"
              << std::endl;

    N = 5000;
    if (fib(N) ==
        large_number(
            "387896845438832563370191630832590531208212771464624510616059721489"
            "555013904403709701082291646221066947929345285888297381348310200895"
            "498294036143015691147893836421656394410691021450563413370655865623"
            "825465670071252592990385493381392883637834751890876297071203333705"
            "292310769300851809384980180384781399674888176555465378829164426891"
            "298038461377896902150229308247566634622492307188332480328037503913"
            "035290330450584270114763524227021093463769910400671417488329842289"
            "149127310405432875329804427367682297724498774987455569190770388063"
            "704683279481135897373999311010621930814901857081539785437919530561"
            "751076105307568878376603366735544525884488624161921055345749367589"
            "784902798823435102359984466393485325641195222185956306047536464547"
            "076033090242080638258492915645287629157575914234380914230291749108"
            "898415520985443248659407979357131684169286803954530954538869811466"
            "508206686289742063932343848846524098874239587380197699382031717420"
            "893226546887936400263079778005875912967138963421425257911687275560"
            "0360311370547754724604639987588046985178408674382863125"))
        std::cout << "Test for " << N << "^th Fibonacci number passed!"
                  << std::endl;
    else
        std::cerr << "Test for " << N << "^th Fibonacci number failed!"
                  << std::endl;

    return 0;
}


#include <cassert>
#include <iostream>


uint64_t double_factorial_iterative(uint64_t n) {
    uint64_t res = 1;
    for (uint64_t i = n;; i -= 2) {
        if (i == 0 || i == 1)
            return res;
        res *= i;
    }
    return res;
}


uint64_t double_factorial_recursive(uint64_t n) {
    if (n <= 1)
        return 1;
    return n * double_factorial_recursive(n - 2);
}


void test(uint64_t n, uint64_t expected) {
    assert(double_factorial_iterative(n) == expected);
    assert(double_factorial_recursive(n) == expected);
}


void tests() {
    std::cout << "Test 1:\t n=5\t...";
    test(5, 15);
    std::cout << "passed\n";

    std::cout << "Test 2:\t n=15\t...";
    test(15, 2027025);
    std::cout << "passed\n";

    std::cout << "Test 3:\t n=0\t...";
    test(0, 1);
    std::cout << "passed\n";
}


int main() {
    tests();
    return 0;
}

#include <algorithm>
#include <cstring>
#include <iostream>
#include <vector>


bool isprime[1000006];


std::vector<int> prime_numbers;


std::vector<std::pair<int, int>> factors;


void SieveOfEratosthenes(int N) {
        memset(isprime, true, sizeof isprime);

    for (int i = 2; i <= N; i++) {
        if (isprime[i]) {
            for (int j = 2 * i; j <= N; j += i) isprime[j] = false;
        }
    }

    for (int i = 2; i <= N; i++) {
        if (isprime[i])
            prime_numbers.push_back(i);
    }
}


void prime_factorization(int num) {
    int number = num;

    for (int i = 0; prime_numbers[i] <= num; i++) {
        int count = 0;

                if (number == 1) {
            break;
        }

        while (number % prime_numbers[i] == 0) {
            count++;
            number = number / prime_numbers[i];
        }

        if (count)
            factors.push_back(std::make_pair(prime_numbers[i], count));
    }
}


int main() {
    int num;
    std::cout << "\t\tComputes the prime factorization\n\n";
    std::cout << "Type in a number: ";
    std::cin >> num;

    SieveOfEratosthenes(num);

    prime_factorization(num);

        for (auto it : factors) {
        std::cout << it.first << " " << it.second << std::endl;
    }

    return 0;
}


#include <iostream>  #include <cassert>   


namespace math {

int power_of_two(int n) {
            int result = n & (n - 1);
    
    if (result == 0) {
        return 1;
    }

    return 0;
}
}  

static void test() {
    std::cout << "First case testing... \n";     assert(math::power_of_two(32) == 1);
    std::cout << "\nPassed!\n";

    std::cout << "Second case testing... \n";     assert(math::power_of_two(5) == 0);
    std::cout << "\nPassed!\n";

    std::cout << "Third case testing... \n";     assert(math::power_of_two(232) == 0);
    std::cout << "\nPassed!\n";

    std::cout << "\nAll test cases have successfully passed!\n";
}


void user_input_test() {
    int n = 0;     
    std::cout << "Enter a number " << std::endl;
    std::cin >> n; 

        int result = math::power_of_two(n);
    if (result == 1) {
        std::cout << "Yes, the number " << n << " is a power of 2\n";
    }
    else { 
        std::cout << "No, the number " << n << " is not a power of 2\n";
    }
}


int main() {
    test(); 
        
    return 0;
}

#include <iostream>
#include <stdexcept>


int gcd(int num1, int num2) {
    if (num1 <= 0 | num2 <= 0) {
        throw std::domain_error("Euclidean algorithm domain is for ints > 0");
    }

    if (num1 == num2) {
        return num1;
    }

    int base_num = 0;
    int previous_remainder = 1;

    if (num1 > num2) {
        base_num = num1;
        previous_remainder = num2;
    } else {
        base_num = num2;
        previous_remainder = num1;
    }

    while ((base_num % previous_remainder) != 0) {
        int old_base = base_num;
        base_num = previous_remainder;
        previous_remainder = old_base % previous_remainder;
    }

    return previous_remainder;
}


int main() {
    std::cout << "gcd of 120,7 is " << (gcd(120, 7)) << std::endl;
    try {
        std::cout << "gcd of -120,10 is " << gcd(-120, 10) << std::endl;
    } catch (const std::domain_error &e) {
        std::cout << "Error handling was successful" << std::endl;
    }
    std::cout << "gcd of 312,221 is " << (gcd(312, 221)) << std::endl;
    std::cout << "gcd of 289,204 is " << (gcd(289, 204)) << std::endl;

    return 0;
}

#include <cassert>        #include <cmath>         #include <functional>   #include <iostream>    

namespace math {

double integral_approx(double lb, double ub,
                       const std::function<double(double)>& func,
                       double delta = .0001) {
    double result = 0;
    uint64_t numDeltas = static_cast<uint64_t>((ub - lb) / delta);
    for (int i = 0; i < numDeltas; i++) {
        double begin = lb + i * delta;
        double end = lb + (i + 1) * delta;
        result += delta * (func(begin) + func(end)) / 2;
    }
    return result;
}


void test_eval(double approx, double expected, double threshold) {
    assert(approx >= expected * (1 - threshold));
    assert(approx <= expected * (1 + threshold));
}


}  
static void test() {
    double test_1 = math::integral_approx(
        3.24, 7.56, [](const double x) { return log(x) + exp(x) + x; });
    std::cout << "Test Case 1" << std::endl;
    std::cout << "function: log(x) + e^x + x" << std::endl;
    std::cout << "range: [3.24, 7.56]" << std::endl;
    std::cout << "value: " << test_1 << std::endl;
    math::test_eval(test_1, 1924.80384023549, .001);
    std::cout << "Test 1 Passed!" << std::endl;
    std::cout << "=====================" << std::endl;

    double test_2 = math::integral_approx(0.023, 3.69, [](const double x) {
        return x * x + cos(x) + exp(x) + log(x) * log(x);
    });
    std::cout << "Test Case 2" << std::endl;
    std::cout << "function: x^2 + cos(x) + e^x + log^2(x)" << std::endl;
    std::cout << "range: [.023, 3.69]" << std::endl;
    std::cout << "value: " << test_2 << std::endl;
    math::test_eval(test_2, 58.71291345202729, .001);
    std::cout << "Test 2 Passed!" << std::endl;
    std::cout << "=====================" << std::endl;

    double test_3 = math::integral_approx(
        10.78, 24.899, [](const double x) { return x * x * x - x * x + 378; });
    std::cout << "Test Case 3" << std::endl;
    std::cout << "function: x^3 - x^2 + 378" << std::endl;
    std::cout << "range: [10.78, 24.899]" << std::endl;
    std::cout << "value: " << test_3 << std::endl;
    math::test_eval(test_3, 93320.65915078377, .001);
    std::cout << "Test 3 Passed!" << std::endl;
    std::cout << "=====================" << std::endl;

    double test_4 = math::integral_approx(
        .101, .505,
        [](const double x) { return cos(x) * tan(x) * x * x + exp(x); },
        .00001);
    std::cout << "Test Case 4" << std::endl;
    std::cout << "function: cos(x)*tan(x)*x^2 + e^x" << std::endl;
    std::cout << "range: [.101, .505]" << std::endl;
    std::cout << "value: " << test_4 << std::endl;
    math::test_eval(test_4, 0.566485986311631, .001);
    std::cout << "Test 4 Passed!" << std::endl;
    std::cout << "=====================" << std::endl;

    double test_5 = math::integral_approx(
        -1, 1, [](const double x) { return exp(-1 / (x * x)); });
    std::cout << "Test Case 5" << std::endl;
    std::cout << "function: e^(-1/x^2)" << std::endl;
    std::cout << "range: [-1, 1]" << std::endl;
    std::cout << "value: " << test_5 << std::endl;
    math::test_eval(test_5, 0.1781477117815607, .001);
    std::cout << "Test 5 Passed!" << std::endl;
}


int main() {
    test();      return 0;
}

#include <iostream>


#define MAX 100000


int multiply(int x, int res[], int res_size) {
        int carry = 0;

            for (int i = 0; i < res_size; i++) {
        int prod = res[i] * x + carry;

                        res[i] = prod % 10;

                carry = prod / 10;
    }

            while (carry) {
        res[res_size] = carry % 10;
        carry = carry / 10;
        res_size++;
    }
    return res_size;
}


void power(int x, int n) {
        if (n == 0) {
        std::cout << "1";
        return;
    }

    int res[MAX];
    int res_size = 0;
    int temp = x;

        while (temp != 0) {
        res[res_size++] = temp % 10;
        temp = temp / 10;
    }

            for (int i = 2; i <= n; i++) res_size = multiply(x, res, res_size);

    std::cout << x << "^" << n << " = ";
    for (int i = res_size - 1; i >= 0; i--) std::cout << res[i];
}


int main() {
    int exponent, base;
    std::cout << "Enter base ";
    std::cin >> base;
    std::cout << "Enter exponent ";
    std::cin >> exponent;
    power(base, exponent);
    return 0;
}


#define _USE_MATH_DEFINES  #include <cmath>           #include <cstdint>         #include <ctime>           #include <functional>      #include <iostream>        #include <random>          #include <vector>          

namespace math {

namespace monte_carlo {

using Function = std::function<double(
    double&)>;  

std::vector<double> generate_samples(const double& start_point,
                                     const Function& pdf,
                                     const uint32_t& num_samples,
                                     const uint32_t& discard = 100000) {
    std::vector<double> samples;
    samples.reserve(num_samples);

    double x_t = start_point;

    std::default_random_engine generator;
    std::uniform_real_distribution<double> uniform(0.0, 1.0);
    std::normal_distribution<double> normal(0.0, 1.0);
    generator.seed(time(nullptr));

    for (uint32_t t = 0; t < num_samples + discard; ++t) {
                        double x_dash = normal(generator) + x_t;
        double acceptance_probability = std::min(pdf(x_dash) / pdf(x_t), 1.0);
        double u = uniform(generator);

                if (u <= acceptance_probability) {
            x_t = x_dash;
        }

        if (t >= discard) {
            samples.push_back(x_t);
        }
    }

    return samples;
}


double integral_monte_carlo(const double& start_point, const Function& function,
                            const Function& pdf,
                            const uint32_t& num_samples = 1000000) {
    double integral = 0.0;
    std::vector<double> samples =
        generate_samples(start_point, pdf, num_samples);

    for (double sample : samples) {
        integral += function(sample) / pdf(sample);
    }

    return integral / static_cast<double>(samples.size());
}

}  }  

static void test() {
    std::cout << "Disclaimer: Because this is a randomized algorithm,"
              << std::endl;
    std::cout
        << "it may happen that singular samples deviate from the true result."
        << std::endl
        << std::endl;
    ;

    math::monte_carlo::Function f;
    math::monte_carlo::Function pdf;
    double integral = 0;
    double lower_bound = 0, upper_bound = 0;

    f = [&](double& x) { return -x * x + 4.0; };

    lower_bound = -2.0;
    upper_bound = 2.0;
    pdf = [&](double& x) {
        if (x >= lower_bound && x <= -1.0) {
            return 0.1;
        }
        if (x <= upper_bound && x >= 1.0) {
            return 0.1;
        }
        if (x > -1.0 && x < 1.0) {
            return 0.4;
        }
        return 0.0;
    };

    integral = math::monte_carlo::integral_monte_carlo(
        (upper_bound - lower_bound) / 2.0, f, pdf);

    std::cout << "This number should be close to 10.666666: " << integral
              << std::endl;

    f = [&](double& x) { return std::exp(x); };

    lower_bound = 0.0;
    upper_bound = 1.0;
    pdf = [&](double& x) {
        if (x >= lower_bound && x <= 0.2) {
            return 0.1;
        }
        if (x > 0.2 && x <= 0.4) {
            return 0.4;
        }
        if (x > 0.4 && x < upper_bound) {
            return 1.5;
        }
        return 0.0;
    };

    integral = math::monte_carlo::integral_monte_carlo(
        (upper_bound - lower_bound) / 2.0, f, pdf);

    std::cout << "This number should be close to 1.7182818: " << integral
              << std::endl;


    f = [&](double& x) { return std::sin(M_PI * x) / (M_PI * x); };

    pdf = [&](double& x) {
        return 1.0 / std::sqrt(2.0 * M_PI) * std::exp(-x * x / 2.0);
    };

    integral = math::monte_carlo::integral_monte_carlo(0.0, f, pdf, 10000000);

    std::cout << "This number should be close to 1.0: " << integral
              << std::endl;
}


int main() {
    test();      return 0;
}

#include <cstring>
#include <ctime>
#include <iostream>

#include "./large_number.h"


bool test1() {
    std::cout << "---- Check 1\t";
    unsigned int i, number = 10;
    large_number result;
    for (i = 2; i <= number; i++) 
        result *= i;

    const char *known_reslt = "3628800";

    if (strlen(known_reslt) != result.num_digits()) {
        std::cerr << "Result lengths dont match! " << strlen(known_reslt)
                  << " != " << result.num_digits() << std::endl;
        return false;
    }

    const size_t N = result.num_digits();
    for (i = 0; i < N; i++) {
        if (known_reslt[i] != result.digit_char(i)) {
            std::cerr << i << "^th digit mismatch! " << known_reslt[i]
                      << " != " << result.digit_char(i) << std::endl;
            return false;
        }
    }

    std::cout << "Passed!" << std::endl;
    return true;
}


bool test2() {
    std::cout << "---- Check 2\t";
    unsigned int i, number = 100;
    large_number result;
    for (i = 2; i <= number; i++)
        result *= i;

    const char *known_reslt =
        "9332621544394415268169923885626670049071596826438162146859296389521759"
        "9993229915608941463976156518286253697920827223758251185210916864000000"
        "000000000000000000";


    if (strlen(known_reslt) != result.num_digits()) {
        std::cerr << "Result lengths dont match! " << strlen(known_reslt)
                  << " != " << result.num_digits() << std::endl;
        return false;
    }

    const size_t N = result.num_digits();
    for (i = 0; i < N; i++) {
        if (known_reslt[i] != result.digit_char(i)) {
            std::cerr << i << "^th digit mismatch! " << known_reslt[i]
                      << " != " << result.digit_char(i) << std::endl;
            return false;
        }
    }

    std::cout << "Passed!" << std::endl;
    return true;
}


int main(int argc, char *argv[]) {
    int number, i;

    if (argc == 2) {
        number = atoi(argv[1]);
    } else {
        std::cout << "Enter the value of n(n starts from 0 ): ";
        std::cin >> number;
    }

    large_number result;

    std::clock_t start_time = std::clock();
    for (i = 2; i <= number; i++) 
        result *= i;
    std::clock_t end_time = std::clock();
    double time_taken =
        static_cast<double>(end_time - start_time) / CLOCKS_PER_SEC;

    std::cout << number << "! = " << result << std::endl
              << "Number of digits: " << result.num_digits() << std::endl
              << "Time taken: " << std::scientific << time_taken << " s"
              << std::endl;

    test1();
    test2();
    result.test();

    return 0;
}


#include <cassert>   #include <iostream>  

uint64_t finding_number_of_digits_in_a_number(uint64_t n) {
    uint64_t count = 0;  
                while (n != 0) {
                n /= 10;
                ++count;
    }

    return count;
}


static void test() {
    assert(finding_number_of_digits_in_a_number(5492) == 4);
    assert(finding_number_of_digits_in_a_number(-0) == 0);
    assert(finding_number_of_digits_in_a_number(10000) == 5);
    assert(finding_number_of_digits_in_a_number(9) == 1);
    assert(finding_number_of_digits_in_a_number(100000) == 6);
    assert(finding_number_of_digits_in_a_number(13) == 2);
    assert(finding_number_of_digits_in_a_number(564) == 3);

    std::cout << "All tests have successfully passed!\n";
}


int main() {
    test();      return 0;
}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     

namespace math {

namespace n_bonacci {

std::vector<uint64_t> N_bonacci(const uint64_t &n, const uint64_t &m) {
    std::vector<uint64_t> a(m, 0);  
    a[n - 1] = 1;                         a[n] = 1;                     for (uint64_t i = n + 1; i < m; i++) {
                                a[i] = 2 * a[i - 1] - a[i - 1 - n];
    }
    return a;
}
}  }  

static void test() {
        std::cout << "1st test";
    std::vector<uint64_t> arr1 = math::n_bonacci::N_bonacci(
        1, 1);                      std::vector<uint64_t> output_array1 = {
        1, 1};      assert(std::equal(std::begin(arr1), std::end(arr1),
                      std::begin(output_array1)));
    std::cout << "passed" << std::endl;

            std::cout << "2nd test";
    std::vector<uint64_t> arr2 = math::n_bonacci::N_bonacci(
        5, 15);                       std::vector<uint64_t> output_array2 = {
        0, 0,  0,  0,  1,   1,   2,  4,
        8, 16, 31, 61, 120, 236, 464};                                              assert(std::equal(std::begin(arr2), std::end(arr2),
                      std::begin(output_array2)));
    std::cout << "passed" << std::endl;

            std::cout << "3rd test";
    std::vector<uint64_t> arr3 = math::n_bonacci::N_bonacci(
        6, 17);                       std::vector<uint64_t> output_array3 = {
        0, 0,  0,  0,  0,   1,   1,   2,  4,
        8, 16, 32, 63, 125, 248, 492, 976};                                                   assert(std::equal(std::begin(arr3), std::end(arr3),
                      std::begin(output_array3)));
    std::cout << "passed" << std::endl;

        std::cout << "4th test";
    std::vector<uint64_t> arr4 = math::n_bonacci::N_bonacci(
        56, 15);                        std::vector<uint64_t> output_array4 = {
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0};      assert(std::equal(std::begin(arr4), std::end(arr4),
                      std::begin(output_array4)));
    std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}


#include <cassert>
#include <iostream>
#include <random>
#include <vector>


template <typename T>
std::vector<T> reverse_binary(T num) {
    std::vector<T> result;
    T temp = num;
    while (temp > 0) {
        result.push_back(temp % 2);
        temp = temp / 2;
    }
    return result;
}


template <typename T>
T modular_exponentiation(T base, const std::vector<T> &rev_binary_exponent,
                         T mod) {
    if (mod == 1)
        return 0;
    T b = 1;
    if (rev_binary_exponent.size() == 0)
        return b;
    T A = base;
    if (rev_binary_exponent[0] == 1)
        b = base;

    for (typename std::vector<T>::const_iterator it =
             rev_binary_exponent.cbegin() + 1;
         it != rev_binary_exponent.cend(); ++it) {
        A = A * A % mod;
        if (*it == 1)
            b = A * b % mod;
    }
    return b;
}


template <typename T>
bool miller_test(T d, T num) {
        std::random_device rd_seed;
        std::mt19937 gen(rd_seed());
        std::uniform_int_distribution<> distribution(2, num - 2);
        T random = distribution(gen);
        std::vector<T> power = reverse_binary(d);
        T x = modular_exponentiation(random, power, num);
        if (x == 1 || x == num - 1) {
        return true;
    }

    while (d != num - 1) {
        x = (x * x) % num;
        d *= 2;
        if (x == 1) {
            return false;
        }
        if (x == num - 1) {
            return true;
        }
    }
    return false;
}


template <typename T>
bool miller_rabin_primality_test(T num, T repeats) {
    if (num <= 4) {
                if (num == 2 || num == 3) {
            return true;
        } else {
            return false;
        }
    }
        if (num % 2 == 0) {
        return false;
    }
        T d = num - 1, r = 0;
    while (d % 2 == 0) {
        d = d / 2;
        r++;
    }

    for (T i = 0; i < repeats; ++i) {
        if (!miller_test(d, num)) {
            return false;
        }
    }
    return true;
}


void tests() {
        assert(((void)"2 is prime but function says otherwise.\n",
            miller_rabin_primality_test(2, 1) == true));
    std::cout << "First test passes." << std::endl;
        assert(((void)"5 should be prime but the function says otherwise.\n",
            miller_rabin_primality_test(5, 3) == true));
    std::cout << "Second test passes." << std::endl;
        assert(((void)"23 should be prime but the function says otherwise.\n",
            miller_rabin_primality_test(23, 3) == true));
    std::cout << "Third test passes." << std::endl;
        assert(((void)"16 is not a prime but the function says otherwise.\n",
            miller_rabin_primality_test(16, 3) == false));
    std::cout << "Fourth test passes." << std::endl;
        assert(((void)"27 is not a prime but the function says otherwise.\n",
            miller_rabin_primality_test(27, 3) == false));
    std::cout << "Fifth test passes." << std::endl;
}


int main() {
    tests();
    return 0;
}

#include <algorithm>  #include <iostream>


template <typename T, typename T2>
inline void update_step(T *r, T *r0, const T2 quotient) {
    T temp = *r;
    *r = *r0 - (quotient * temp);
    *r0 = temp;
}


template <typename T1, typename T2>
void extendedEuclid_1(T1 A, T1 B, T1 *GCD, T2 *x, T2 *y) {
    if (B > A)
        std::swap(A, B);  
    T2 s = 0, s0 = 1;
    T2 t = 1, t0 = 0;
    T1 r = B, r0 = A;

    while (r != 0) {
        T1 quotient = r0 / r;
        update_step(&r, &r0, quotient);
        update_step(&s, &s0, quotient);
        update_step(&t, &t0, quotient);
    }
    *GCD = r0;
    *x = s0;
    *y = t0;
}


template <typename T, typename T2>
void extendedEuclid(T A, T B, T *GCD, T2 *x, T2 *y) {
    if (B > A)
        std::swap(A, B);  
    if (B == 0) {
        *GCD = A;
        *x = 1;
        *y = 0;
    } else {
        extendedEuclid(B, A % B, GCD, x, y);
        T2 temp = *x;
        *x = *y;
        *y = temp - (A / B) * (*y);
    }
}

int main() {
    uint32_t a, b, gcd;
    int32_t x, y;
    std::cin >> a >> b;
    extendedEuclid(a, b, &gcd, &x, &y);
    std::cout << gcd << " " << x << " " << y << std::endl;
    extendedEuclid_1(a, b, &gcd, &x, &y);
    std::cout << gcd << " " << x << " " << y << std::endl;
    return 0;
}

#include <cassert>   #include <iostream>  

namespace math {

bool magic_number(const uint64_t &n) {
    if (n <= 0) {
        return false;
    }
        uint64_t result = n % 9;
        if (result == 1) {
        return true;
    } else {
        return false;
    }
}
}  

static void tests() {
    std::cout << "Test 1:\t n=60\n";
    assert(math::magic_number(60) == false);
    std::cout << "passed\n";

    std::cout << "Test 2:\t n=730\n";
    assert(math::magic_number(730) == true);
    std::cout << "passed\n";

    std::cout << "Test 3:\t n=0\n";
    assert(math::magic_number(0) == false);
    std::cout << "passed\n";

    std::cout << "Test 4:\t n=479001600\n";
    assert(math::magic_number(479001600) == false);
    std::cout << "passed\n";

    std::cout << "Test 5:\t n=-35\n";
    assert(math::magic_number(-35) == false);
    std::cout << "passed\n";
}


int main() {
    tests();      return 0;
}


#include <cassert>
#include <cmath>
#include <complex>
#include <ctime>
#include <iostream>
#include <stdexcept>


class Complex {
        double re;
        double im;

 public:
    
    explicit Complex(double x = 0.f, double y = 0.f, bool is_polar = false) {
        if (!is_polar) {
            re = x;
            im = y;
            return;
        }

        re = x * std::cos(y);
        im = x * std::sin(y);
    }

    
    Complex(const Complex &other) : re(other.real()), im(other.imag()) {}

    
    double real() const { return this->re; }

    
    double imag() const { return this->im; }

    
    double abs() const {
        return std::sqrt(this->re * this->re + this->im * this->im);
    }

    
    double arg() const { return std::atan2(this->im, this->re); }

    
    Complex operator+(const Complex &other) {
        Complex result(this->re + other.re, this->im + other.im);
        return result;
    }

    
    Complex operator-(const Complex &other) {
        Complex result(this->re - other.re, this->im - other.im);
        return result;
    }

    
    Complex operator*(const Complex &other) {
        Complex result(this->re * other.re - this->im * other.im,
                       this->re * other.im + this->im * other.re);
        return result;
    }

    
    Complex operator~() const {
        Complex result(this->re, -(this->im));
        return result;
    }

    
    Complex operator/(const Complex &other) {
        Complex result = *this * ~other;
        double denominator =
            other.real() * other.real() + other.imag() * other.imag();
        if (denominator != 0) {
            result = Complex(result.real() / denominator,
                             result.imag() / denominator);
            return result;
        } else {
            throw std::invalid_argument("Undefined Value");
        }
    }

    
    const Complex &operator=(const Complex &other) {
        this->re = other.real();
        this->im = other.imag();
        return *this;
    }
};


bool operator==(const Complex &a, const Complex &b) {
    return a.real() == b.real() && a.imag() == b.imag();
}


std::ostream &operator<<(std::ostream &os, const Complex &num) {
    os << "(" << num.real();
    if (num.imag() < 0) {
        os << " - " << -num.imag();
    } else {
        os << " + " << num.imag();
    }
    os << "i)";
    return os;
}


double get_rand() { return (std::rand() % 100 - 50) / 100.f; }


void tests() {
    std::srand(std::time(nullptr));
    double x1 = get_rand(), y1 = get_rand(), x2 = get_rand(), y2 = get_rand();
    Complex num1(x1, y1), num2(x2, y2);
    std::complex<double> cnum1(x1, y1), cnum2(x2, y2);
    Complex result;
    std::complex<double> expected;
        result = num1 + num2;
    expected = cnum1 + cnum2;
    assert(((void)"1 + 1i + 1 + 1i is equal to 2 + 2i but the addition doesn't "
                  "add up \n",
            (result.real() == expected.real() &&
             result.imag() == expected.imag())));
    std::cout << "First test passes." << std::endl;
        result = num1 - num2;
    expected = cnum1 - cnum2;
    assert(((void)"1 + 1i - 1 - 1i is equal to 0 but the program says "
                  "otherwise. \n",
            (result.real() == expected.real() &&
             result.imag() == expected.imag())));
    std::cout << "Second test passes." << std::endl;
        result = num1 * num2;
    expected = cnum1 * cnum2;
    assert(((void)"(1 + 1i) * (1 + 1i) is equal to 2i but the program says "
                  "otherwise. \n",
            (result.real() == expected.real() &&
             result.imag() == expected.imag())));
    std::cout << "Third test passes." << std::endl;
        result = num1 / num2;
    expected = cnum1 / cnum2;
    assert(((void)"(1 + 1i) / (1 + 1i) is equal to 1 but the program says "
                  "otherwise.\n",
            (result.real() == expected.real() &&
             result.imag() == expected.imag())));
    std::cout << "Fourth test passes." << std::endl;
        result = ~num1;
    expected = std::conj(cnum1);
    assert(((void)"(1 + 1i) has a conjugate which is equal to (1 - 1i) but the "
                  "program says otherwise.\n",
            (result.real() == expected.real() &&
             result.imag() == expected.imag())));
    std::cout << "Fifth test passes.\n";
        assert(((void)"(1 + 1i) has argument PI / 4 but the program differs from "
                  "the std::complex result.\n",
            (num1.arg() == std::arg(cnum1))));
    std::cout << "Sixth test passes.\n";
        assert(((void)"(1 + 1i) has absolute value sqrt(2) but the program differs "
                  "from the std::complex result. \n",
            (num1.abs() == std::abs(cnum1))));
    std::cout << "Seventh test passes.\n";
}


int main() {
    tests();
    return 0;
}

#include <cassert>
#include <cmath>
#include <iostream>


namespace statistics {


template <typename T>
class stats_computer1 {
 public:
    
    void new_val(T x) {
        if (n == 0)
            K = x;
        n++;
        T tmp = x - K;
        Ex += tmp;
        Ex2 += static_cast<double>(tmp) * tmp;
    }

    
    double mean() const { return K + Ex / n; }

    
    double variance() const { return (Ex2 - (Ex * Ex) / n) / (n - 1); }

    
    double std() const { return std::sqrt(this->variance()); }

    
    friend std::istream &operator>>(std::istream &input,
                                    stats_computer1 &stat) {
        T val;
        input >> val;
        stat.new_val(val);
        return input;
    }

 private:
    unsigned int n = 0;
    double Ex, Ex2;
    T K;
};


template <typename T>
class stats_computer2 {
 public:
    
    void new_val(T x) {
        n++;
        double delta = x - mu;
        mu += delta / n;
        double delta2 = x - mu;
        M += delta * delta2;
    }

    
    double mean() const { return mu; }

    
    double variance() const { return M / n; }

    
    double std() const { return std::sqrt(this->variance()); }

    
    friend std::istream &operator>>(std::istream &input,
                                    stats_computer2 &stat) {
        T val;
        input >> val;
        stat.new_val(val);
        return input;
    }

 private:
    unsigned int n = 0;
    double mu = 0, var = 0, M = 0;
};

}  
using statistics::stats_computer1;
using statistics::stats_computer2;


void test_function(const float *test_data, const int number_of_samples) {
    float mean = 0.f, variance = 0.f;

    stats_computer1<float> stats01;
    stats_computer2<float> stats02;

    for (int i = 0; i < number_of_samples; i++) {
        stats01.new_val(test_data[i]);
        stats02.new_val(test_data[i]);
        mean += test_data[i];
    }

    mean /= number_of_samples;

    for (int i = 0; i < number_of_samples; i++) {
        float temp = test_data[i] - mean;
        variance += temp * temp;
    }
    variance /= number_of_samples;

    std::cout << "<<<<<<<< Test Function >>>>>>>>" << std::endl
              << "Expected: Mean: " << mean << "\t Variance: " << variance
              << std::endl;
    std::cout << "\tMethod 1:"
              << "\tMean: " << stats01.mean()
              << "\t Variance: " << stats01.variance()
              << "\t Std: " << stats01.std() << std::endl;
    std::cout << "\tMethod 2:"
              << "\tMean: " << stats02.mean()
              << "\t Variance: " << stats02.variance()
              << "\t Std: " << stats02.std() << std::endl;

    assert(std::abs(stats01.mean() - mean) < 0.01);
    assert(std::abs(stats02.mean() - mean) < 0.01);
    assert(std::abs(stats02.variance() - variance) < 0.01);

    std::cout << "(Tests passed)" << std::endl;
}


int main(int argc, char **argv) {
    const float test_data1[] = {3, 4, 5, -1.4, -3.6, 1.9, 1.};
    test_function(test_data1, sizeof(test_data1) / sizeof(test_data1[0]));

    std::cout
        << "Enter data. Any non-numeric data will terminate the data input."
        << std::endl;

    stats_computer1<float> stats1;
    stats_computer2<float> stats2;

    while (1) {
        double val;
        std::cout << "Enter number: ";
        std::cin >> val;

                        if (std::cin.fail())
            break;

        stats1.new_val(val);
        stats2.new_val(val);

        std::cout << "\tMethod 1:"
                  << "\tMean: " << stats1.mean()
                  << "\t Variance: " << stats1.variance()
                  << "\t Std: " << stats1.std() << std::endl;
        std::cout << "\tMethod 2:"
                  << "\tMean: " << stats2.mean()
                  << "\t Variance: " << stats2.variance()
                  << "\t Std: " << stats2.std() << std::endl;
    }

    return 0;
}


#include <cassert>
#include <iostream>


int number_of_positive_divisors(int n) {
    if (n < 0) {
        n = -n;     }

    int number_of_divisors = 1;

    for (int i = 2; i * i <= n; i++) {
                                                                        int prime_exponent = 0;
        while (n % i == 0) {
                                    prime_exponent++;
            n /= i;
        }
        number_of_divisors *= prime_exponent + 1;
    }
    if (n > 1) {
                        number_of_divisors *= 2;
    }

    return number_of_divisors;
}


void tests() {
    assert(number_of_positive_divisors(36) == 9);
    assert(number_of_positive_divisors(-36) == 9);
    assert(number_of_positive_divisors(1) == 1);
    assert(number_of_positive_divisors(2011) == 2);     assert(number_of_positive_divisors(756) == 24); }


int main() {
    tests();
    int n;
    std::cin >> n;
    if (n == 0) {
        std::cout << "All non-zero numbers are divisors of 0 !" << std::endl;
    } else {
        std::cout << "Number of positive divisors is : ";
        std::cout << number_of_positive_divisors(n) << std::endl;
    }
    return 0;
}

#define _USE_MATH_DEFINES
#include <cassert>  #include <cmath>    #include <cmath>
#include <cstdint>   #include <iostream>  

namespace math {

template <typename T>
T square_area(T length) {
    return length * length;
}


template <typename T>
T rect_area(T length, T width) {
    return length * width;
}


template <typename T>
T triangle_area(T base, T height) {
    return base * height / 2;
}


template <typename T>
T circle_area(T radius) {
    return M_PI * pow(radius, 2);
}


template <typename T>
T parallelogram_area(T base, T height) {
    return base * height;
}


template <typename T>
T cube_surface_area(T length) {
    return 6 * length * length;
}


template <typename T>
T sphere_surface_area(T radius) {
    return 4 * M_PI * pow(radius, 2);
}


template <typename T>
T cylinder_surface_area(T radius, T height) {
    return 2 * M_PI * radius * height + 2 * M_PI * pow(radius, 2);
}
}  

static void test() {
        uint16_t int_length = 0;        uint16_t int_width = 0;         uint16_t int_base = 0;          uint16_t int_height = 0;        uint16_t int_expected = 0;      uint16_t int_area = 0;      
    float float_length = NAN;        float float_expected = NAN;      float float_area = NAN;      
    double double_length = NAN;        double double_width = NAN;         double double_radius = NAN;        double double_height = NAN;        double double_expected = NAN;      double double_area = NAN;      
        int_length = 5;
    int_expected = 25;
    int_area = math::square_area(int_length);

    std::cout << "AREA OF A SQUARE (int)" << std::endl;
    std::cout << "Input Length: " << int_length << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_area << std::endl;
    assert(int_area == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        float_length = 2.5;
    float_expected = 6.25;
    float_area = math::square_area(float_length);

    std::cout << "AREA OF A SQUARE (float)" << std::endl;
    std::cout << "Input Length: " << float_length << std::endl;
    std::cout << "Expected Output: " << float_expected << std::endl;
    std::cout << "Output: " << float_area << std::endl;
    assert(float_area == float_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        int_length = 4;
    int_width = 7;
    int_expected = 28;
    int_area = math::rect_area(int_length, int_width);

    std::cout << "AREA OF A RECTANGLE (int)" << std::endl;
    std::cout << "Input Length: " << int_length << std::endl;
    std::cout << "Input Width: " << int_width << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_area << std::endl;
    assert(int_area == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_length = 2.5;
    double_width = 5.7;
    double_expected = 14.25;
    double_area = math::rect_area(double_length, double_width);

    std::cout << "AREA OF A RECTANGLE (double)" << std::endl;
    std::cout << "Input Length: " << double_length << std::endl;
    std::cout << "Input Width: " << double_width << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_area << std::endl;
    assert(double_area == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        int_base = 10;
    int_height = 3;
    int_expected = 15;
    int_area = math::triangle_area(int_base, int_height);

    std::cout << "AREA OF A TRIANGLE" << std::endl;
    std::cout << "Input Base: " << int_base << std::endl;
    std::cout << "Input Height: " << int_height << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_area << std::endl;
    assert(int_area == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_radius = 6;
    double_expected =
        113.09733552923255;                                   double_area = math::circle_area(double_radius);

    std::cout << "AREA OF A CIRCLE" << std::endl;
    std::cout << "Input Radius: " << double_radius << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_area << std::endl;
    assert(double_area == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        int_base = 6;
    int_height = 7;
    int_expected = 42;
    int_area = math::parallelogram_area(int_base, int_height);

    std::cout << "AREA OF A PARALLELOGRAM" << std::endl;
    std::cout << "Input Base: " << int_base << std::endl;
    std::cout << "Input Height: " << int_height << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_area << std::endl;
    assert(int_area == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_length = 5.5;
    double_expected = 181.5;
    double_area = math::cube_surface_area(double_length);

    std::cout << "SURFACE AREA OF A CUBE" << std::endl;
    std::cout << "Input Length: " << double_length << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_area << std::endl;
    assert(double_area == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_radius = 10.0;
    double_expected = 1256.6370614359172;                                                 double_area = math::sphere_surface_area(double_radius);

    std::cout << "SURFACE AREA OF A SPHERE" << std::endl;
    std::cout << "Input Radius: " << double_radius << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_area << std::endl;
    assert(double_area == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_radius = 4.0;
    double_height = 7.0;
    double_expected = 276.46015351590177;
    double_area = math::cylinder_surface_area(double_radius, double_height);

    std::cout << "SURFACE AREA OF A CYLINDER" << std::endl;
    std::cout << "Input Radius: " << double_radius << std::endl;
    std::cout << "Input Height: " << double_height << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_area << std::endl;
    assert(double_area == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;
}


int main() {
    test();      return 0;
}

#include <cassert>   #include <iostream>  

namespace math {

uint64_t power(uint64_t a, uint64_t b, uint64_t c) {
    uint64_t ans = 1;      a = a % c;             if (a == 0) {
        return 0;      }
    while (b > 0) {
                if (b & 1) {
            ans = ((ans % c) * (a % c)) % c;
        }
                b = b >> 1;          a = ((a % c) * (a % c)) % c;
    }
    return ans;
}

}  

static void test() {
    uint32_t test_case_1 = math::power(2, 5, 13);
    assert(test_case_1 == 6);
    std::cout << "Test 1 Passed!" << std::endl;

    uint32_t test_case_2 = math::power(14, 7, 15);
    assert(test_case_2 == 14);
    std::cout << "Test 2 Passed!" << std::endl;

    uint64_t test_case_3 = math::power(8, 15, 41);
    assert(test_case_3 == 32);
    std::cout << "Test 3 Passed!" << std::endl;

    uint64_t test_case_4 = math::power(27, 2, 5);
    assert(test_case_4 == 4);
    std::cout << "Test 4 Passed!" << std::endl;

    uint16_t test_case_5 = math::power(7, 3, 6);
    assert(test_case_5 == 1);
    std::cout << "Test 5 Passed!" << std::endl;
}


int main() {
    test();      return 0;
}


#include <cassert>   #include <iostream>  

template <typename T>
bool is_prime(T num) {
    bool result = true;
    if (num <= 1) {
        return false;
    } else if (num == 2 || num == 3) {
        return true;
    } else if ((num % 2) == 0 || num % 3 == 0) {
        return false;
    } else {
        for (T i = 5; (i * i) <= (num); i = (i + 6)) {
            if ((num % i) == 0 || (num % (i + 2) == 0)) {
                result = false;
                break;
            }
        }
    }
    return (result);
}


int main() {
        assert(is_prime(50) == false);
    assert(is_prime(115249) == true);

    int num = 0;
    std::cout << "Enter the number to check if it is prime or not" << std::endl;
    std::cin >> num;
    bool result = is_prime(num);
    if (result) {
        std::cout << num << " is a prime number" << std::endl;
    } else {
        std::cout << num << " is not a prime number" << std::endl;
    }

    return 0;
}

#include <iostream>


int gcd(int num1, int num2) {
    if (num1 <= 0 | num2 <= 0) {
        throw std::domain_error("Euclidean algorithm domain is for ints > 0");
    }

    if (num1 == num2) {
        return num1;
    }

        if (num1 == 0)
        return num2;
    if (num2 == 0)
        return num1;

        if (num1 == num2)
        return num1;

        if (num1 > num2)
        return gcd(num1 - num2, num2);
    return gcd(num1, num2 - num1);
}


int main() {
    std::cout << "gcd of 120,7 is " << (gcd(120, 7)) << std::endl;
    try {
        std::cout << "gcd of -120,10 is " << gcd(-120, 10) << std::endl;
    } catch (const std::domain_error &e) {
        std::cout << "Error handling was successful" << std::endl;
    }
    std::cout << "gcd of 312,221 is " << (gcd(312, 221)) << std::endl;
    std::cout << "gcd of 289,204 is " << (gcd(289, 204)) << std::endl;
    return 0;
}

#include <cstdlib>
#include <iostream>


uint64_t phiFunction(uint64_t n) {
    uint64_t result = n;
    for (uint64_t i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            while (n % i == 0) {
                n /= i;
            }
            result -= result / i;
        }
    }
    if (n > 1)
        result -= result / n;
    return result;
}

int main(int argc, char *argv[]) {
    uint64_t n;
    if (argc < 2) {
        std::cout << "Enter the number: ";
    } else {
        n = strtoull(argv[1], nullptr, 10);
    }
    std::cin >> n;
    std::cout << phiFunction(n);
    return 0;
}


#include <iostream>
#ifdef _MSC_VER
#include <string>  #else
#include <cstring>  #endif


std::string add(std::string a, std::string b) {
    std::string temp = "";

        int carry = 0;

        while (a.length() < b.length()) {
        a = "0" + a;
    }

        while (b.length() < a.length()) {
        b = "0" + b;
    }

        for (int i = a.length() - 1; i >= 0; i--) {
        char val = static_cast<char>(((a[i] - 48) + (b[i] - 48)) + 48 + carry);
        if (val > 57) {
            carry = 1;
            val -= 10;
        } else {
            carry = 0;
        }
        temp = val + temp;
    }

        if (carry == 1) {
        temp = "1" + temp;
    }

        while (temp[0] == '0' && temp.length() > 1) {
        temp = temp.substr(1);
    }

    return temp;
}


void fib_Accurate(uint64_t n) {
    std::string tmp = "";
    std::string fibMinus1 = "1";
    std::string fibMinus2 = "0";
    for (uint64_t i = 0; i < n; i++) {
        tmp = add(fibMinus1, fibMinus2);
        fibMinus2 = fibMinus1;
        fibMinus1 = tmp;
    }
    std::cout << fibMinus2;
}


int main() {
    int n;
    std::cout << "Enter whatever number N you want to find the fibonacci of\n";
    std::cin >> n;
    std::cout << n << " th Fibonacci is \n";
    fib_Accurate(n);

    return 0;
}


#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <ctime>
#include <iostream>


template <typename T>
double fast_power_recursive(T a, T b) {
        if (b < 0)
        return 1.0 / fast_power_recursive(a, -b);

    if (b == 0)
        return 1;
    T bottom = fast_power_recursive(a, b >> 1);
        
    double result;
    if ((b & 1) == 0)          result = bottom * bottom;
    else          result = bottom * bottom * a;
    return result;
}


template <typename T>
double fast_power_linear(T a, T b) {
        if (b < 0)
        return 1.0 / fast_power_linear(a, -b);

    double result = 1;
    while (b) {
        if (b & 1)
            result = result * a;
        a = a * a;
        b = b >> 1;
    }
    return result;
}


int main() {
    std::srand(std::time(nullptr));
    std::ios_base::sync_with_stdio(false);

    std::cout << "Testing..." << std::endl;
    for (int i = 0; i < 20; i++) {
        int a = std::rand() % 20 - 10;
        int b = std::rand() % 20 - 10;
        std::cout << std::endl << "Calculating " << a << "^" << b << std::endl;
        assert(fast_power_recursive(a, b) == std::pow(a, b));
        assert(fast_power_linear(a, b) == std::pow(a, b));

        std::cout << "------ " << a << "^" << b << " = "
                  << fast_power_recursive(a, b) << std::endl;
    }

    int64_t a, b;
    std::cin >> a >> b;

    std::cout << a << "^" << b << " = " << fast_power_recursive(a, b)
              << std::endl;

    std::cout << a << "^" << b << " = " << fast_power_linear(a, b) << std::endl;

    return 0;
}


#include <cassert>   #include <cmath>     #include <cstdint>   #include <iostream>  

namespace math {

template <typename T>
T cube_volume(T length) {
    return std::pow(length, 3);
}


template <typename T>
T rect_prism_volume(T length, T width, T height) {
    return length * width * height;
}


template <typename T>
T cone_volume(T radius, T height, double PI = 3.14) {
    return std::pow(radius, 2) * PI * height / 3;
}


template <typename T>
T triangle_prism_volume(T base, T height, T depth) {
    return base * height * depth / 2;
}


template <typename T>
T pyramid_volume(T length, T width, T height) {
    return length * width * height / 3;
}


template <typename T>
T sphere_volume(T radius, double PI = 3.14) {
    return PI * std::pow(radius, 3) * 4 / 3;
}


template <typename T>
T cylinder_volume(T radius, T height, double PI = 3.14) {
    return PI * std::pow(radius, 2) * height;
}
}  

static void test() {
        uint32_t int_length = 0;     uint32_t int_width = 0;      uint32_t int_base = 0;       uint32_t int_height = 0;     uint32_t int_depth = 0;  
    double double_radius = NAN;     double double_height = NAN; 
        uint32_t int_expected = 0;     uint32_t int_volume = 0;   
    double double_expected = NAN;     double double_volume = NAN;   
        int_length = 5;
    int_expected = 125;
    int_volume = math::cube_volume(int_length);

    std::cout << "VOLUME OF A CUBE" << std::endl;
    std::cout << "Input Length: " << int_length << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_volume << std::endl;
    assert(int_volume == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        int_length = 4;
    int_width = 3;
    int_height = 5;
    int_expected = 60;
    int_volume = math::rect_prism_volume(int_length, int_width, int_height);

    std::cout << "VOLUME OF A RECTANGULAR PRISM" << std::endl;
    std::cout << "Input Length: " << int_length << std::endl;
    std::cout << "Input Width: " << int_width << std::endl;
    std::cout << "Input Height: " << int_height << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_volume << std::endl;
    assert(int_volume == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_radius = 5;
    double_height = 7;
    double_expected = 183.16666666666666;      double_volume = math::cone_volume(double_radius, double_height);

    std::cout << "VOLUME OF A CONE" << std::endl;
    std::cout << "Input Radius: " << double_radius << std::endl;
    std::cout << "Input Height: " << double_height << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_volume << std::endl;
    assert(double_volume == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        int_base = 3;
    int_height = 4;
    int_depth = 5;
    int_expected = 30;
    int_volume = math::triangle_prism_volume(int_base, int_height, int_depth);

    std::cout << "VOLUME OF A TRIANGULAR PRISM" << std::endl;
    std::cout << "Input Base: " << int_base << std::endl;
    std::cout << "Input Height: " << int_height << std::endl;
    std::cout << "Input Depth: " << int_depth << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_volume << std::endl;
    assert(int_volume == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        int_length = 10;
    int_width = 3;
    int_height = 5;
    int_expected = 50;
    int_volume = math::pyramid_volume(int_length, int_width, int_height);

    std::cout << "VOLUME OF A PYRAMID" << std::endl;
    std::cout << "Input Length: " << int_length << std::endl;
    std::cout << "Input Width: " << int_width << std::endl;
    std::cout << "Input Height: " << int_height << std::endl;
    std::cout << "Expected Output: " << int_expected << std::endl;
    std::cout << "Output: " << int_volume << std::endl;
    assert(int_volume == int_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_radius = 3;
    double_expected = 113.04;
    double_volume = math::sphere_volume(double_radius);

    std::cout << "VOLUME OF A SPHERE" << std::endl;
    std::cout << "Input Radius: " << double_radius << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_volume << std::endl;
    assert(double_volume == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;

        double_radius = 5;
    double_height = 2;
    double_expected = 157;
    double_volume = math::cylinder_volume(double_radius, double_height);

    std::cout << "VOLUME OF A CYLINDER" << std::endl;
    std::cout << "Input Radius: " << double_radius << std::endl;
    std::cout << "Input Height: " << double_height << std::endl;
    std::cout << "Expected Output: " << double_expected << std::endl;
    std::cout << "Output: " << double_volume << std::endl;
    assert(double_volume == double_expected);
    std::cout << "TEST PASSED" << std::endl << std::endl;
}


int main() {
    test();      return 0;
}

#include <iostream>


int InterpolationSearch(int A[], int n, int x) {
    int low = 0;
    int high = n - 1;
    while (low <= high) {
        int mid = low + (((high - 1) * (x - A[low])) / (A[high] - A[low]));
        if (x == A[mid])
            return mid;          else if (x < A[mid])
            high = mid - 1;          else
            low = mid + 1;      }

    return -1;
}


int main() {
    int A[] = {2, 4, 5, 7, 13, 14, 15, 23};
    int x = 17;

        int index = InterpolationSearch(A, 8, x);
    if (index < 0)
        std::cout << "Number " << x << " not found" << std::endl;
    else
        std::cout << "Number " << x << " is at " << index << std::endl;
}



#include <cassert>   #include <iostream>  #include <vector>    

namespace search {

namespace cycle_detection {

template <typename T>
int32_t duplicateNumber(const std::vector<T> &in_arr, const uint32_t &n) {
    if (n == 0 ||
        n == 1) {          return -1;
    }
    uint32_t tortoise = in_arr[0];                                          uint32_t hare =
        in_arr[0];      do {
        tortoise = in_arr[tortoise];
        hare = in_arr[in_arr[hare]];
    } while (tortoise != hare);
    tortoise = in_arr[0];
    while (tortoise != hare) {
        tortoise = in_arr[tortoise];
        hare = in_arr[hare];
    }
    return tortoise;
}
}  }  

static void test() {
            std::vector<uint32_t> array1 = {3, 4, 8, 5, 9, 1, 2, 6, 7, 4};
    std::cout << "Test 1... ";
    assert(search::cycle_detection::duplicateNumber(array1, array1.size()) ==
           4);      std::cout << "passed" << std::endl;

            std::vector<uint32_t> array2 = {1, 2, 3, 4, 2};
    std::cout << "Test 2... ";
    assert(search::cycle_detection::duplicateNumber(array2, array2.size()) ==
           2);      std::cout << "passed" << std::endl;

            std::vector<uint32_t> array3 = {};
    std::cout << "Test 3... ";
    assert(search::cycle_detection::duplicateNumber(array3, array3.size()) ==
           -1);                       std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}

#include <cassert>
#include <cstdlib>
#include <iostream>
#ifdef _MSC_VER
#include <string>  #else
#include <cstring>
#endif


std::string lower(std::string word) {
    int length = word.length();
    std::string lc = "";

    for (int i = 0; i < length; i++) {
        lc += tolower(word[i]);
    }

    return lc;
}


static void test() {
    assert(lower("abcd").compare("abcd") == 0);
    assert(lower("abc").compare("abcd") == -1);
    assert(lower("abcd").compare("abc") == 1);
}


int main() {
    test();      std::string paragraph;
    std::cout << "Please enter your paragraph: \n";
    std::getline(std::cin, paragraph);
    std::cout << "\nHello, your paragraph is:\n " << paragraph << "!\n";
    std::cout << "\nThe size of your paragraph = " << paragraph.size()
              << " characters. \n\n";

    if (paragraph.empty()) {
        std::cout << "\nThe paragraph is empty" << std::endl;
    } else {
        int ch = 0;
        while (true) {
            std::string word;
            std::cout << "Please enter the word you are searching for: ";
            std::getline(std::cin, word);
            std::cout << "Ignore case-sensitive? 1 = Yes, 0 = No" << std::endl;
            std::cin >> ch;
            if (ch == 1) {
                std::string lowerCase = lower(
                    paragraph);                                                   std::string lowerCaseWord =
                    lower(word);                                    
                std::cout << "Hello, your word is " << word << "!\n";
                if (lowerCase.find(lowerCaseWord) == std::string::npos) {
                    std::cout << word << " does not exist in the sentence"
                              << std::endl;
                } else {
                    std::cout << "The word " << word
                              << " is now found at location "
                              << lowerCase.find(lowerCaseWord) << std::endl
                              << std::endl;
                }
            } else {
                std::cout << "Hello, your word is " << word << "!\n";
                if (paragraph.find(word) == std::string::npos) {
                    std::cout << word << " does not exist in the sentence"
                              << std::endl;
                } else {
                    std::cout << "The word " << word
                              << " is now found at location "
                              << paragraph.find(word) << std::endl
                              << std::endl;
                }
            }
            std::cout << "\nPress Ctrl + C to exit the program.\n\n";
            std::cin.get();
        }
    }
    return 0;
}

#include <cstdlib>
#include <iostream>

#define MAX 6      #define HASHMAX 5  
int data[MAX] = {1, 10, 15, 5, 8, 7};  

typedef struct list {
    int key;                struct list* next;  } node,                 
    *link;              
node hashtab[HASHMAX];  


int h(int key) { return key % HASHMAX; }


void create_list(int key) {      link p, n;
    int index;
    n = (link)malloc(sizeof(node));
    n->key = key;
    n->next = NULL;
    index = h(key);
    p = hashtab[index].next;
    if (p != NULL) {
        n->next = p;
        hashtab[index].next = n;
    } else {
        hashtab[index].next = n;
    }
}


int hash_search(int key, int* counter) {      link pointer;
    int index;

    *counter = 0;
    index = h(key);
    pointer = hashtab[index].next;

    std::cout << "data[" << index << "]:";

    while (pointer != NULL) {
        counter[0]++;
        std::cout << "data[" << pointer->key << "]:";
        if (pointer->key == key)
            return 1;
        else
            pointer = pointer->next;
    }

    return 0;
}


int main() {
    link p;
    int key, index, i, counter;      index = 0;

        while (index < MAX) {          create_list(data[index]);
        index++;
    }

    for (i = 0; i < HASHMAX; i++) {          std::cout << "hashtab [" << i << "]\n";

        p = hashtab[i].next;

        while (p != NULL) {
            std::cout << "please int key:";
            if (p->key > 0)
                std::cout << "[" << p->key << "]";
            p = p->next;
        }
        std::cout << std::endl;
    }

    while (key != -1) {
                        key = 10;
        if (hash_search(key, &counter))
            std::cout << "search time = " << counter << std::endl;
        else
            std::cout << "no found!\n";
        key = -1;
    }

    return 0;
}

#include <cassert>
#include <cmath>
#include <iostream>
#ifdef _MSC_VER
#include <string>  #else
#include <cstring>  #endif


template <class Type>
inline Type* binary_s(Type* array, size_t size, Type key) {
    int32_t lower_index(0), upper_index(size - 1), middle_index;

    while (lower_index <= upper_index) {
        middle_index = std::floor((lower_index + upper_index) / 2);

        if (*(array + middle_index) < key)
            lower_index = (middle_index + 1);
        else if (*(array + middle_index) > key)
            upper_index = (middle_index - 1);
        else
            return (array + middle_index);
    }

    return nullptr;
}


template <class Type>
Type* struzik_search(Type* array, size_t size, Type key) {
    uint32_t block_front(0), block_size = size == 0 ? 0 : 1;
    while (block_front != block_size) {
        if (*(array + block_size - 1) < key) {
            block_front = block_size;
            (block_size * 2 - 1 < size) ? (block_size *= 2) : block_size = size;
            continue;
        }
        return binary_s<Type>(array + block_front, (block_size - block_front),
                              key);
    }
    return nullptr;
}


int main() {
        int* sorted_array = new int[7]{7, 10, 15, 23, 70, 105, 203};
    assert(struzik_search<int>(sorted_array, 7, 0) == nullptr);
    assert(struzik_search<int>(sorted_array, 7, 1000) == nullptr);
    assert(struzik_search<int>(sorted_array, 7, 50) == nullptr);
    assert(struzik_search<int>(sorted_array, 7, 7) == sorted_array);
        delete[] sorted_array;
    return 0;
}


#include <iostream>


#define absolutePrecision 10

#define _target 10

#define MAX 10000000  

void get_input() {}


int it_ternary_search(int left, int right, int A[], int target) {
    while (1) {
        if (left < right) {
            if (right - left < absolutePrecision) {
                for (int i = left; i <= right; i++)
                    if (A[i] == target)
                        return i;

                return -1;
            }

            int oneThird = (left + right) / 3 + 1;
            int twoThird = (left + right) * 2 / 3 + 1;

            if (A[oneThird] == target)
                return oneThird;
            else if (A[twoThird] == target)
                return twoThird;

            else if (target > A[twoThird])
                left = twoThird + 1;
            else if (target < A[oneThird])
                right = oneThird - 1;

            else
                left = oneThird + 1, right = twoThird - 1;
        } else {
            return -1;
        }
    }
}


int rec_ternary_search(int left, int right, int A[], int target) {
    if (left < right) {
        if (right - left < absolutePrecision) {
            for (int i = left; i <= right; i++)
                if (A[i] == target)
                    return i;

            return -1;
        }

        int oneThird = (left + right) / 3 + 1;
        int twoThird = (left + right) * 2 / 3 + 1;

        if (A[oneThird] == target)
            return oneThird;
        if (A[twoThird] == target)
            return twoThird;

        if (target < A[oneThird])
            return rec_ternary_search(left, oneThird - 1, A, target);
        if (target > A[twoThird])
            return rec_ternary_search(twoThird + 1, right, A, target);

        return rec_ternary_search(oneThird + 1, twoThird - 1, A, target);
    } else {
        return -1;
    }
}


void ternary_search(int N, int A[], int target) {
    std::cout << it_ternary_search(0, N - 1, A, target) << '\t';
    std::cout << rec_ternary_search(0, N - 1, A, target) << '\t';
    std::cout << std::endl;
}


int main() {
    int N = 21;
    int A[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 10};
    get_input();
    ternary_search(N, A, _target);
    return 0;
}

#include <algorithm>
#include <cmath>
#include <iostream>


int jumpSearch(int arr[], int x, int n) {
        int step = std::sqrt(n);

            int prev = 0;
    while (arr[std::min(step, n) - 1] < x) {
        prev = step;
        step += std::sqrt(n);
        if (prev >= n)
            return -1;
    }

            while (arr[prev] < x) {
        prev++;

                        if (prev == std::min(step, n))
            return -1;
    }
        if (arr[prev] == x)
        return prev;

    return -1;
}

int main() {
    int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610};
    int x = 55;
    int n = sizeof(arr) / sizeof(arr[0]);

        int index = jumpSearch(arr, x, n);

        std::cout << "\nNumber " << x << " is at index " << index;
    return 0;
}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     
namespace search {


namespace binary_search {


uint64_t binarySearch(std::vector<uint64_t> arr, uint64_t val) {
    uint64_t low = 0;                    uint64_t high = arr.size() - 1;  
    while (low <= high) {
        uint64_t m = low + (high - low) / 2;  
        if (val == arr[m]) {
            return m;
        } 
        else if (val < arr[m]) {
            high = m - 1;
        } else {
            low = m + 1;
        }
    }
    return -1;  }

}  
}  

static void test1() {
            
    std::vector<uint64_t> arr = {{1, 3, 5, 7, 9, 8, 6, 4, 2}};
    std::sort(arr.begin(), arr.end());
    uint64_t expected_ans = 3;
    uint64_t derived_ans = search::binary_search::binarySearch(arr, 4);
    std::cout << "Test #1: ";
    assert(derived_ans == expected_ans);
    std::cout << "Passed!" << std::endl;
}


void test2() {
                std::vector<uint64_t> arr = {{1, 23, 25, 4, 2}};
    std::sort(arr.begin(), arr.end());
    uint64_t expected_ans = 4;
    uint64_t derived_ans = search::binary_search::binarySearch(arr, 25);
    std::cout << "Test #2: ";
    assert(derived_ans == expected_ans);
    std::cout << "Passed!" << std::endl;
}


void test3() {
                std::vector<uint64_t> arr = {{1, 31, 231, 12, 2, 5, 51, 21, 23, 12, 3}};
    std::sort(arr.begin(), arr.end());
    uint64_t expected_ans = 8;
    uint64_t derived_ans = search::binary_search::binarySearch(arr, 31);
    std::cout << "Test #3: ";
    assert(derived_ans == expected_ans);
    std::cout << "Passed!" << std::endl;
}


int main() {
    test1();      test2();      test3();  
    return 0;
}


#include <iostream>
#include <algorithm>
#include <vector>
#include <cassert>


namespace search {

namespace median_search {
  
int median_of_medians(const std::vector<int>& A,  const int& idx) {
	int pivot = 0;						std::vector<int> a(A.begin(), A.end());
	std::vector<int> m;
	int r = a.size();
	for(int i = 0; i < r; i += 5){
		std::sort(a.begin() + i, a.begin() + std::min(r, i + 5));
		int mid = (i + std::min(r, i + 5)) / 2;
		m.push_back(a[mid]);
	}
	int sz = int(m.size());
	if(sz <= 5){
		std::sort(m.begin(), m.end());
		pivot = m[(sz- 1) / 2];
	}
	else{
		pivot = median_of_medians(m, idx);
	}
	std::vector<int> low;
	std::vector<int> high;
	for(int i = 0; i < r; i++){
		if(a[i] < pivot){
			low.push_back(a[i]);
		}
		else if(a[i] > pivot){
			high.push_back(a[i]);
		}
	}
	int k = int(low.size());
	if(idx < k){
		return median_of_medians(low, idx);
	}
	else if(idx > k){
		return median_of_medians(high, idx-k-1);
	}
	else{
		return pivot;
	}
}
}  }  

void test(){
	std::vector<int> A{25,21,98,100,76,22,43,60,89,87};
	int i = 3;
	assert(A[6] == search::median_search::median_of_medians(A, i));			std::cout << "test case:1 passed\n";
	
	std::vector<int> B{1,2,3,4,5,6};
	int j = 4;
	assert(B[4] == search::median_search::median_of_medians(B, j));			std::cout << "test case:2 passed\n";
	
	std::vector<int> C{1,2,3,4,5,1000,8,9,99};
	int k = 3;
	assert(C[3] == search::median_search::median_of_medians(C, k)); 		std::cout << "test case:3 passed\n";
	std::cout << "--All tests passed--\n";
}


int main()
{
	test();
	int n = 0;
	std::cout << "Enter Size of Array: ";
	std::cin >> n;
	std::vector<int> a(n);
	std::cout << "Enter Array: ";
	for(int i = 0; i < n; i++){
		std::cin >> a[i];
	}
	std::cout << "Median: ";				int x = search::median_search::median_of_medians(a,  (n - 1) / 2);
	if(n % 2 == 0){
		int y = search::median_search::median_of_medians(a, n / 2);
		std::cout << (float(x) + float(y))/2.0;
	}
	else{
		std::cout << x;
	}
	std::cout << "\nTo find i-th smallest element ";
       	std::cout << "\nEnter i: ";
	int idx = 0;
	std::cin >> idx;
	idx--;
	std::cout << idx + 1<< "-th smallest element: " << search::median_search::median_of_medians(a, idx) << '\n';
	return 0;
}



#include <iostream>
#include <vector> #include <cassert> #include <cstdlib> #include <algorithm> 



int fibonacci_search(const std::vector<int> &arr, int value){
        int last = 0, current = 1;
    int length = arr.size();         int next = last + current; 

        while(next < length){
        last = current;
        current = next;
        next = last + current;
    }

        int offset = -1, index;
                while(next > 1){
                index = std::min(offset + last, length-1);
                if(arr[index] < value){
            next = current;
            current = last;
            last = next - current;
            offset = index;
                } else if(arr[index] > value){
            next = last;
            current = current - last;
            last = next - current;
                } else {
            return index;
        }
    }
        if(current && !arr.empty() && arr[offset+1] == value){
        return offset+1;
    }
        return -1;
}


bool no_occurence_tests(){
    bool passed = true;
    int rand_num, rand_value, index, num_tests = 1000;
    std::vector<int> arr;
    while(num_tests--){
        arr.clear();
        for(int i = 0; i < 100; i++){
            rand_num = std::rand() % 1000;
            arr.push_back(rand_num);
        }
        rand_value = std::rand() % 1000;
        while(std::find(arr.begin(), arr.end(), rand_value) != arr.end()){
            std::remove(arr.begin(), arr.end(), rand_value);
        }
        sort(arr.begin(), arr.end());
        index = fibonacci_search(arr, rand_value);
        passed = passed && (index == -1);
    }
    return passed;
}


bool random_tests(){
    bool passed = true;
    int rand_num, rand_value, index, real_value, num_tests = 10000;
    std::vector<int> arr;
    while(num_tests--){
        arr.clear();
        for(int i = 0; i < 100; i++){
            rand_num = std::rand() % 1000;
            arr.push_back(rand_num);
        }
        rand_value = std::rand() % 1000;
        std::sort(arr.begin(), arr.end());
        index = fibonacci_search(arr, rand_value);
        if(index != -1){
            real_value = arr[index];
            passed = passed && (real_value == rand_value);
        } else {
            passed = passed && (std::find(arr.begin(), arr.end(), rand_value) == arr.end());
        }
    }
    return passed;
}


int main() {
    assert(no_occurence_tests());
    assert(random_tests());
    return 0;
}


#include <cassert>   #include <iostream>  #include <vector>    

namespace search {

namespace sublist_search {

struct Node {
    uint32_t data = 0;      Node *next{};       };


void printLinkedList(Node *start) {
    while (start != nullptr) {
        std::cout << "->" << start->data;
        start = start->next;
    }
    std::cout << std::endl;
}


Node *makeLinkedList(const std::vector<uint64_t> &data) {
            Node *head = nullptr;
    Node *tail = nullptr;
    for (int i : data) {
        Node *node = new Node;
        node->data = i;
        node->next = nullptr;
        if (head == nullptr) {
            head = node;
            tail = node;
        } else {
            tail->next = node;
            tail = tail->next;
        }
    }
    return head;
}


bool sublistSearch(Node *sublist, Node *mainList) {
    if (sublist == nullptr || mainList == nullptr) {
        return false;
    }

        Node *target_ptr = sublist;

    while (mainList != nullptr) {
                Node *main_ptr = mainList;

        while (target_ptr != nullptr) {
            if (main_ptr == nullptr) {
                return false;

            } else if (main_ptr->data == target_ptr->data) {
                                                target_ptr = target_ptr->next;
                main_ptr = main_ptr->next;

            } else {
                break;
            }
        }

        if (target_ptr == nullptr) {
                                                return true;
        }

                target_ptr = sublist;

                        mainList = mainList->next;
    }

            return false;
}

}  }  

class TestCases {
 private:
    
    template <typename T>
    void log(T msg) {
                std::cout << "[TESTS] : ---> " << msg << std::endl;
    }

 public:
    
    void runTests() {
        log("Running Tests...");

        testCase_1();
        testCase_2();
        testCase_3();

        log("Test Cases over!");
        std::cout << std::endl;
    }

    
    void testCase_1() {
        const bool expectedOutput = true;  
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");
        log("This is test case 1 for sublist search Algorithm : ");
        log("Description:");
        log("   EDGE CASE : Only contains one element");

        std::vector<uint64_t> sublistData = {
            6};          std::vector<uint64_t> mainlistData = {
            2, 5, 6, 7,
            8};  
        search::sublist_search::Node *sublistLL =
            search::sublist_search::makeLinkedList(
                sublistData);          search::sublist_search::Node *mainlistLL =
            search::sublist_search::makeLinkedList(
                mainlistData);                                  
        bool exists = search::sublist_search::sublistSearch(
            sublistLL, mainlistLL);  
        log("Checking assert expression...");
        assert(exists == expectedOutput);
        log("Assertion check passed!");

        log("[PASS] : TEST CASE 1 PASS!");
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");

        delete (sublistLL);
        delete (mainlistLL);
    }

    
    void testCase_2() {
        const bool expectedOutput = true;  
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");
        log("This is test case 2 for sublist search Algorithm : ");
        log("Description:");
        log("   contains main list of 100 elements and sublist of 20");

        std::vector<uint64_t> sublistData(
            20);          std::vector<uint64_t> mainlistData(
            100);  
        for (int i = 0; i < 100; i++) {
                        mainlistData[i] = i + 1;
        }

        int temp = 0;
        for (int i = 45; i < 65; i++) {
                        sublistData[temp] = i + 1;
            temp++;
        }

        search::sublist_search::Node *sublistLL =
            search::sublist_search::makeLinkedList(
                sublistData);          search::sublist_search::Node *mainlistLL =
            search::sublist_search::makeLinkedList(
                mainlistData);                                  
        bool exists = search::sublist_search::sublistSearch(
            sublistLL, mainlistLL);  
        log("Checking assert expression...");
        assert(exists == expectedOutput);
        log("Assertion check passed!");

        log("[PASS] : TEST CASE 2 PASS!");
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");
    }

    
    void testCase_3() {
        const bool expectedOutput = false;  
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");
        log("This is test case 3 for sublist search Algorithm : ");
        log("Description:");
        log("   contains main list of 50 elements and sublist of 20");

        std::vector<uint64_t> sublistData(20);          std::vector<uint64_t> mainlistData(
            50);  
        for (int i = 0; i < 50; i++) {
                        mainlistData.push_back(i + 1);
        }

        for (int i = 45; i < 65; i++) {
                        sublistData.push_back(i + 1);
        }

        search::sublist_search::Node *sublistLL =
            search::sublist_search::makeLinkedList(
                sublistData);          search::sublist_search::Node *mainlistLL =
            search::sublist_search::makeLinkedList(
                mainlistData);                                  
        bool exists = search::sublist_search::sublistSearch(
            sublistLL, mainlistLL);  
        log("Checking assert expression...");
        assert(exists == expectedOutput);
        log("Assertion check passed!");

        log("[PASS] : TEST CASE 3 PASS!");
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");
    }
};


static void test() {
    TestCases tc;
    tc.runTests();
}


int main(int argc, char *argv[]) {
    test();  
    std::vector<uint64_t> mainlistData = {
        2, 5, 6, 7, 8};      std::vector<uint64_t> sublistData = {6, 8};  
    search::sublist_search::Node *mainlistLL =
        search::sublist_search::makeLinkedList(mainlistData);
    search::sublist_search::Node *sublistLL =
        search::sublist_search::makeLinkedList(
            sublistData);                             
    bool exists = search::sublist_search::sublistSearch(
        sublistLL,
        mainlistLL);  
    std::cout << "Sublist: " << std::endl;
    search::sublist_search::printLinkedList(sublistLL);

    std::cout << "Main list: " << std::endl;
    search::sublist_search::printLinkedList(mainlistLL);
    std::cout << std::endl;

    if (exists) {
        std::cout << "[TRUE] - sublist found in main list\n";
    } else {
        std::cout << "[FALSE] - sublist NOT found in main list\n";
    }
    return 0;
}

#include <cassert>      #include <iostream>     #include <vector>       

namespace search {

namespace saddleback {

std::pair<uint32_t, uint32_t> saddleback(std::vector<std::vector<int32_t>> matrix,
                               int32_t element) {
    uint32_t left_index = 0;
    uint32_t right_index = matrix[0].size() - 1;      while (left_index < matrix.size()) {          if (element ==
            matrix[left_index]
                  [right_index]) {                                                  return std::make_pair(left_index+1, right_index+1);
        } else if (element >
                   matrix[left_index]
                         [right_index]) {                                                                                                    ++left_index;
        } else if (element <
                   matrix[left_index]
                         [right_index]) {                                                                                                    if(!right_index)
                break;
            else --right_index;
        }
    }
    return std::make_pair(
        0, 0);                    }
}  }  

static void test() {
    std::vector<std::vector<int32_t>> matrix = {{1, 10, 100, 1000, 10000},
                                            {2, 20, 200, 2000, 20000},
                                            {3, 30, 300, 3000, 30000},
                                            {4, 40, 400, 4000, 40000},
                                            {5, 50, 500, 5000, 50000}};

    std::pair<uint32_t, uint32_t> not_found = std::make_pair(0, 0);
    std::pair<uint32_t, uint32_t> test_answer;
        std::pair<uint32_t, uint32_t> answer1 = search::saddleback::saddleback(matrix, 123);
    assert(not_found == answer1);
        answer1 = search::saddleback::saddleback(matrix, 0);
    assert(not_found == answer1);
        answer1 = search::saddleback::saddleback(matrix, 1);
    test_answer = std::make_pair(1, 1);
    assert(test_answer == answer1);
        answer1 = search::saddleback::saddleback(matrix, 50000);
    test_answer = std::make_pair(5, 5);
    assert(test_answer == answer1);
        answer1 = search::saddleback::saddleback(matrix, 300);
    test_answer = std::make_pair(3, 3);
    assert(test_answer == answer1);
}


int main() {
    test();         return 0;
}



#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     

namespace search {


namespace interpolation_search {


uint64_t interpolationSearch(const std::vector<uint64_t> &arr,
                             uint64_t number) {
    uint64_t size = arr.size();
    uint64_t low = 0, high = (size - 1);

            while (low <= high && number >= arr[low] && number <= arr[high]) {
        if (low == high) {
            if (arr[low] == number) {
                return low;
            }
            return -1;
        }
                uint64_t pos =
            low +
            ((static_cast<uint64_t>(high - low) / (arr[high] - arr[low])) *
             (number - arr[low]));

        if (arr[pos] == number) {
            return pos;          }

        if (arr[pos] < number) {
            low = pos + 1;          }

        else {
            high = pos - 1;          }
    }
    return -1;
}

}  
}  

static void tests() {
                std::vector<uint64_t> arr = {{10, 12, 13, 16, 18, 19, 20, 21, 1, 2, 3, 4,
                                  22, 23, 24, 33, 35, 42, 47}};
    sort(arr.begin(), arr.end());
    uint64_t number = 33;      uint64_t expected_answer = 15;
    uint64_t derived_answer =
        search::interpolation_search::interpolationSearch(arr, number);
    std::cout << "Testcase: ";
    assert(derived_answer == expected_answer);
    std::cout << "Passed!\n";
}


int main() {
    tests();      return 0;
}


#include <iostream>   #include <cassert>    

int LinearSearch(int *array, int size, int key) 
{
    for (int i = 0; i < size; ++i) 
    {
        if (array[i] == key) {
            return i;
        }
    }

    return -1;
}


static void tests() {
    int size = 4;
    int *array = new int[size];
    for (int i = 0; i < size; i++) {
        array[i] = i;
    }

    assert(LinearSearch(array, size, 0) == 0);
    assert(LinearSearch(array, size, 1) == 1);
    assert(LinearSearch(array, size, 2) == 2);

    size = 6;
    for (int i = 0; i < size; i++) {
        array[i] = i;
    }

    assert(LinearSearch(array, size, 3) == 3);
    assert(LinearSearch(array, size, 1) == 1);
    assert(LinearSearch(array, size, 5) == 5);

    std::cout << "All tests have successfully passed!\n";
    delete[] array; }


int main() {
    int mode = 0;

    std::cout << "Choose mode\n";
    std::cout << "Self-test mode (1), interactive mode (2): ";

    std::cin >> mode;

    if (mode == 2) {
        int size = 0;
        std::cout << "\nEnter the size of the array: ";
        std::cin >> size;

        while ((size <= 1) || (size >= 30)) {
            std::cout << "Size cannot be less than zero. Please choose another value: ";
            std::cin >> size;
        }

        int *array = new int[size];
        int key = 0;

                std::cout << "Enter the array of " << size << " numbers: ";
        for (int i = 0; i < size; i++) {
            std::cin >> array[i];
        }

        std::cout << "\nEnter the number to be searched: ";
        std::cin >> key;

        int index = LinearSearch(array, size, key);
        if (index != -1)
        {
            std::cout << "Number found at index: " << index << "\n";
        } 
        else
        {
            std::cout << "Array element not found";
        }
        delete[] array;
    }
    else {
        tests();      }
    return 0;
}

#include <cassert>
#include <iostream>
#include <string>
#include <vector>


namespace ciphers {

namespace morse {

std::string char_to_morse(const char &c) {
        switch (c) {
        case 'a':
            return ".-";
        case 'b':
            return "-...";
        case 'c':
            return "-.-.";
        case 'd':
            return "-..";
        case 'e':
            return ".";
        case 'f':
            return "..-.";
        case 'g':
            return "--.";
        case 'h':
            return "....";
        case 'i':
            return "..";
        case 'j':
            return ".---";
        case 'k':
            return "-.-";
        case 'l':
            return ".-..";
        case 'm':
            return "--";
        case 'n':
            return "-.";
        case 'o':
            return "---";
        case 'p':
            return ".--.";
        case 'q':
            return "--.-";
        case 'r':
            return ".-.";
        case 's':
            return "...";
        case 't':
            return "-";
        case 'u':
            return "..-";
        case 'v':
            return "...-";
        case 'w':
            return ".--";
        case 'x':
            return "-..-";
        case 'y':
            return "-.--";
        case 'z':
            return "--..";
        case '1':
            return ".----";
        case '2':
            return "..---";
        case '3':
            return "...--";
        case '4':
            return "....-";
        case '5':
            return ".....";
        case '6':
            return "-....";
        case '7':
            return "--...";
        case '8':
            return "---..";
        case '9':
            return "----.";
        case '0':
            return "-----";
        default:
            std::cerr << "Found invalid character: " << c << ' ' << std::endl;
            std::exit(0);
    }
}

char morse_to_char(const std::string &s) {
        if (s == ".-") {
        return 'a';
    } else if (s == "-...") {
        return 'b';
    } else if (s == "-.-.") {
        return 'c';
    } else if (s == "-..") {
        return 'd';
    } else if (s == ".") {
        return 'e';
    } else if (s == "..-.") {
        return 'f';
    } else if (s == "--.") {
        return 'g';
    } else if (s == "....") {
        return 'h';
    } else if (s == "..") {
        return 'i';
    } else if (s == ".---") {
        return 'j';
    } else if (s == "-.-") {
        return 'k';
    } else if (s == ".-..") {
        return 'l';
    } else if (s == "--") {
        return 'm';
    } else if (s == "-.") {
        return 'n';
    } else if (s == "---") {
        return 'o';
    } else if (s == ".--.") {
        return 'p';
    } else if (s == "--.-") {
        return 'q';
    } else if (s == ".-.") {
        return 'r';
    } else if (s == "...") {
        return 's';
    } else if (s == "-") {
        return 't';
    } else if (s == "..-") {
        return 'u';
    } else if (s == "...-") {
        return 'v';
    } else if (s == ".--") {
        return 'w';
    } else if (s == "-..-") {
        return 'x';
    } else if (s == "-.--") {
        return 'y';
    } else if (s == "--..") {
        return 'z';
    } else if (s == ".----") {
        return '1';
    } else if (s == "..---") {
        return '2';
    } else if (s == "...--") {
        return '3';
    } else if (s == "....-") {
        return '4';
    } else if (s == ".....") {
        return '5';
    } else if (s == "-....") {
        return '6';
    } else if (s == "--...") {
        return '7';
    } else if (s == "---..") {
        return '8';
    } else if (s == "----.") {
        return '9';
    } else if (s == "-----") {
        return '0';
    } else {
        std::cerr << "Found invalid Morse code: " << s << ' ' << std::endl;
        std::exit(0);
    }
}

std::string encrypt(const std::string &text) {
    std::string encrypted_text = "";              for (const char &c : text) {
        encrypted_text += ciphers::morse::char_to_morse(c) + " ";
    }
    return encrypted_text;  }

std::string decrypt(const std::string &text) {
            std::string decrypted_text = "";              std::size_t pos_start = 0, pos_end = 0, delim_len = 1;
    std::vector<std::string> splits;
    while ((pos_end = text.find(' ', pos_start)) != std::string::npos) {
        std::string token = text.substr(pos_start, pos_end - pos_start);
        pos_start = pos_end + delim_len;
        splits.push_back(token);
    }

        for (const std::string &s : splits) {
                decrypted_text += ciphers::morse::morse_to_char(s);
    }

    return decrypted_text;  }
}  }  

static void test() {
        std::string text1 = "01234567890";
    std::string encrypted1 = ciphers::morse::encrypt(text1);
    std::string decrypted1 = ciphers::morse::decrypt(encrypted1);
    assert(text1 == decrypted1);
    std::cout << "Original text : " << text1 << std::endl;
    std::cout << "Encrypted text : " << encrypted1 << std::endl;
    std::cout << "Decrypted text : " << decrypted1 << std::endl;
        std::string text2 = "abcdefghijklmnopqrstuvwxyz";
    std::string encrypted2 = ciphers::morse::encrypt(text2);
    std::string decrypted2 = ciphers::morse::decrypt(encrypted2);
    assert(text2 == decrypted2);
    std::cout << "Original text : " << text2 << std::endl;
    std::cout << "Encrypted text : " << encrypted2 << std::endl;
    std::cout << "Decrypted text : " << decrypted2 << std::endl;
}


int main() {
        test();
    return 0;
}

#include <array>     #include <cassert>   #include <iostream>  

namespace ciphers {

namespace base64_encoding {
const std::string chars =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

std::string base64_encode(const std::string &input) {
    std::string base64_string;              for (uint32_t i = 0; i < input.size(); i += 3) {
        char first_byte = input[i];                          base64_string.push_back(chars[first_byte >> 2]);

        if (i + 1 < input.size()) {
            char second_byte = input[i + 1];                                                              base64_string.push_back(
                chars[(((first_byte & 3) << 4) | ((second_byte & 0xF0) >> 4))]);

            if (i + 2 < input.size()) {
                char third_byte = input[i + 2];                                                                                  base64_string.push_back(chars[((third_byte & 0xC0) >> 6) |
                                              ((second_byte & 0x0F) << 2)]);
                                base64_string.push_back(chars[(third_byte & 0x3F)]);
            } else {
                                base64_string.push_back(chars[((second_byte & 0x0F) << 2)]);
                base64_string.push_back('=');              }
        } else {
                        base64_string.push_back(chars[((first_byte & 3) << 4)]);
            base64_string.push_back('=');              base64_string.push_back('=');          }
    }
    return base64_string;
}

uint8_t find_idx(const char c) {
    if (c >= 'A' && c <= 'Z') {
        return c - 'A';
    } else if (c >= 'a' && c <= 'z') {
        return c - 'a' + 26;
    } else if (c >= '0' && c <= '9') {
        return c - '0' + 52;
    } else if (c == '+') {
        return 62;
    } else if (c == '/') {
        return 63;
    }
    return -1;
}

std::string base64_decode(const std::string &base64_str) {
    std::string
        base64_decoded;      for (uint32_t i = 0; i < base64_str.size(); i += 4) {
                char first_byte = base64_str[i];
                char second_byte = base64_str[i + 1];
                                char first_actual_byte = static_cast<char>(
            (find_idx(first_byte) << 2) | ((find_idx(second_byte)) >> 4));
        base64_decoded.push_back(first_actual_byte);
        if (i + 2 < base64_str.size() && base64_str[i + 2] != '=') {
                        char third_byte = base64_str[i + 2];
                                                char second_actual_byte =
                static_cast<char>(((find_idx(second_byte) & 0x0F) << 4) |
                                  (find_idx(third_byte) >> 2));
            base64_decoded.push_back(second_actual_byte);

            if (i + 3 < base64_str.size() && base64_str[i + 3] != '=') {
                                char fourth_byte = base64_str[i + 3];
                                                char third_actual_byte =
                    static_cast<char>(((find_idx(third_byte) & 0x03) << 6) |
                                      find_idx(fourth_byte));
                base64_decoded.push_back(third_actual_byte);
            }
        }
    }
    return base64_decoded;
}
}  }  

static void test() {
        std::string str =
        "To err is human, but to really foul things up you need a computer.";
    std::string base64_str = ciphers::base64_encoding::base64_encode(str);
    std::string verify =
        "VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZW"
        "VkIGEgY29tcHV0ZXIu";
        assert(base64_str == verify);
    std::string original_str =
        ciphers::base64_encoding::base64_decode(base64_str);
        assert(original_str == str);

        str =
        "Man is distinguished, not only by his reason, but by this singular "
        "passion from other animals, which is a lust of the mind, that by a "
        "perseverance of delight in the continued and indefatigable generation "
        "of knowledge, exceeds the short vehemence of any carnal pleasure.";

    base64_str = ciphers::base64_encoding::base64_encode(str);
    verify =
        "TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieS"
        "B0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBh"
        "IGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodC"
        "BpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25v"
        "d2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbG"
        "Vhc3VyZS4=";
        assert(base64_str == verify);
    original_str = ciphers::base64_encoding::base64_decode(base64_str);
        assert(original_str == str);
}


int main() {
    test();      return 0;
}


#include <algorithm>  #include <cassert>    #include <cstdint>    #include <iostream>   #include <map>        #include <sstream>    #include <string>     #include <vector>     

namespace ciphers {

namespace a1z26 {

std::map<uint8_t, char> a1z26_decrypt_map = {
    {1, 'a'},  {2, 'b'},  {3, 'c'},  {4, 'd'},  {5, 'e'},  {6, 'f'},  {7, 'g'},
    {8, 'h'},  {9, 'i'},  {10, 'j'}, {11, 'k'}, {12, 'l'}, {13, 'm'}, {14, 'n'},
    {15, 'o'}, {16, 'p'}, {17, 'q'}, {18, 'r'}, {19, 's'}, {20, 't'}, {21, 'u'},
    {22, 'v'}, {23, 'w'}, {24, 'x'}, {25, 'y'}, {26, 'z'},
};

std::map<char, uint8_t> a1z26_encrypt_map = {
    {'a', 1},  {'b', 2},  {'c', 3},  {'d', 4},  {'e', 5},  {'f', 6},  {'g', 7},
    {'h', 8},  {'i', 9},  {'j', 10}, {'k', 11}, {'l', 12}, {'m', 13}, {'n', 14},
    {'o', 15}, {'p', 16}, {'q', 17}, {'r', 18}, {'s', 19}, {'t', 20}, {'u', 21},
    {'v', 22}, {'w', 23}, {'x', 24}, {'y', 25}, {'z', 26}};


std::string encrypt(std::string text) {
    std::string result;
    std::transform(text.begin(), text.end(), text.begin(),
                   ::tolower);      std::replace(text.begin(), text.end(), ':', ' ');
    for (char letter : text) {
        if (letter != ' ') {
            result += std::to_string(
                a1z26_encrypt_map[letter]);                                                           result += "-";          } else {
            result.pop_back();
            result += ' ';
        }
    }
    result.pop_back();      return result;
}


std::string decrypt(const std::string& text, bool bReturnUppercase = false) {
    std::string result;

        std::vector<std::string> word_array;
    std::stringstream sstream(text);
    std::string word;
    while (sstream >> word) {
        word_array.push_back(word);
    }

    for (auto& i : word_array) {
        std::replace(i.begin(), i.end(), '-', ' ');
        std::vector<std::string> text_array;

        std::stringstream ss(i);
        std::string res_text;
        while (ss >> res_text) {
            text_array.push_back(res_text);
        }

        for (auto& i : text_array) {
            result += a1z26_decrypt_map[stoi(i)];
        }

        result += ' ';
    }
    result.pop_back();  
    if (bReturnUppercase) {
        std::transform(result.begin(), result.end(), result.begin(), ::toupper);
    }
    return result;
}

}  }  

static void test() {
        std::string input = "Hello World";
    std::string expected = "8-5-12-12-15 23-15-18-12-4";
    std::string output = ciphers::a1z26::encrypt(input);

    std::cout << "Input: " << input << std::endl;
    std::cout << "Expected: " << expected << std::endl;
    std::cout << "Output: " << output << std::endl;
    assert(output == expected);
    std::cout << "TEST PASSED";

        input = "12-15-23-5-18-3-1-19-5";
    expected = "lowercase";
    output = ciphers::a1z26::decrypt(input);

    std::cout << "Input: " << input << std::endl;
    std::cout << "Expected: " << expected << std::endl;
    std::cout << "Output: " << output << std::endl;
    assert(output == expected);
    std::cout << "TEST PASSED";

        input = "21-16-16-5-18-3-1-19-5";
    expected = "UPPERCASE";
    output = ciphers::a1z26::decrypt(input, true);

    std::cout << "Input: " << input << std::endl;
    std::cout << "Expected: " << expected << std::endl;
    std::cout << "Output: " << output << std::endl;
    assert(output == expected);
    std::cout << "TEST PASSED";
}


int main() {
    test();      return 0;
}


#include <cassert>
#include <cmath>
#include <cstring>
#include <ctime>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <string>
#ifdef _OPENMP
#include <omp.h>
#endif

#include "../numerical_methods/lu_decomposition.h"


template <typename T>
static std::ostream &operator<<(std::ostream &out, matrix<T> const &v) {
    const int width = 15;
    const char separator = ' ';

    for (size_t row = 0; row < v.size(); row++) {
        for (size_t col = 0; col < v[row].size(); col++)
            out << std::left << std::setw(width) << std::setfill(separator)
                << v[row][col];
        out << std::endl;
    }

    return out;
}


namespace ciphers {

static const char *STRKEY =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~!@#$%^&"
    "*()_+`-=[]{}|;':\",./<>?\\\r\n \0";


class HillCipher {
 private:
    
    template <typename T1, typename T2>
    static const T2 rand_range(T1 a, T1 b) {
                long double r = static_cast<long double>(std::rand()) / RAND_MAX;

                return static_cast<T2>(r * (b - a) + a);
    }

    
    template <typename T1, typename T2>
    static double rand_range(matrix<T2> *M, T1 a, T1 b) {
        for (size_t i = 0; i < M->size(); i++) {
            for (size_t j = 0; j < M[0][0].size(); j++) {
                M[0][i][j] = rand_range<T1, T2>(a, b);
            }
        }

        return determinant_lu(*M);
    }

    
    template <typename T>
    static const T gcd(T a, T b) {
        if (b > a)              std::swap(a, b);

        while (b != 0) {
            T tmp = b;
            b = a % b;
            a = tmp;
        }

        return a;
    }

    
    static const std::valarray<uint8_t> mat_mul(
        const std::valarray<uint8_t> &vector, const matrix<int> &key) {
        std::valarray<uint8_t> out(vector);  
        size_t L = std::strlen(STRKEY);

        for (size_t i = 0; i < key.size(); i++) {
            int tmp = 0;
            for (size_t j = 0; j < vector.size(); j++) {
                tmp += key[i][j] * vector[j];
            }
            out[i] = static_cast<uint8_t>(tmp % L);
        }

        return out;
    }

    
    static inline char get_idx_char(const uint8_t idx) { return STRKEY[idx]; }

    
    static inline uint8_t get_char_idx(const char ch) {
        size_t L = std::strlen(STRKEY);

        for (size_t idx = 0; idx <= L; idx++)
            if (STRKEY[idx] == ch)
                return idx;

        std::cerr << __func__ << ":" << __LINE__ << ": (" << ch
                  << ") Should not reach here!\n";
        return 0;
    }

    
    static const std::string codec(const std::string &text,
                                   const matrix<int> &key) {
        size_t text_len = text.length();
        size_t key_len = key.size();

                        size_t L2 = text_len % key_len == 0
                        ? text_len
                        : text_len + key_len - (text_len % key_len);
        std::string coded_text(L2, '\0');

                int i;
#ifdef _OPENMP
#pragma parallel omp for private(i)
#endif
        for (i = 0; i < L2 - key_len + 1; i += key_len) {
            std::valarray<uint8_t> batch_int(key_len);
            for (size_t j = 0; j < key_len; j++) {
                batch_int[j] = get_char_idx(text[i + j]);
            }

            batch_int = mat_mul(batch_int, key);

            for (size_t j = 0; j < key_len; j++) {
                coded_text[i + j] =
                    STRKEY[batch_int[j]];              }
        }

        return coded_text;
    }

    
    template <typename T>
    static matrix<double> get_inverse(matrix<T> const &A) {
                size_t N = A.size();

        matrix<double> inverse(N, std::valarray<double>(N));
        for (size_t row = 0; row < N; row++) {
            for (size_t col = 0; col < N; col++) {
                                inverse[row][col] = (row == col) ? 1.f : 0.f;
            }
        }

        if (A.size() != A[0].size()) {
            std::cerr << "A must be a square matrix!" << std::endl;
            return inverse;
        }

                matrix<double> temp(N, std::valarray<double>(N));
        for (size_t row = 0; row < N; row++) {
            for (size_t col = 0; col < N; col++)
                temp[row][col] = static_cast<double>(A[row][col]);
        }

                for (size_t row = 0; row < N; row++) {
            for (size_t row2 = row; row2 < N && temp[row][row] == 0; row2++) {
                                temp[row] = temp[row] + temp[row2];
                inverse[row] = inverse[row] + inverse[row2];
            }

            for (size_t col2 = row; col2 < N && temp[row][row] == 0; col2++) {
                                for (size_t row2 = 0; row2 < N; row2++) {
                    temp[row2][row] = temp[row2][row] + temp[row2][col2];
                    inverse[row2][row] =
                        inverse[row2][row] + inverse[row2][col2];
                }
            }

            if (temp[row][row] == 0) {
                                std::cerr << "Low-rank matrix, no inverse!" << std::endl;
                return inverse;
            }

                        double divisor = temp[row][row];
            temp[row] = temp[row] / divisor;
            inverse[row] = inverse[row] / divisor;
                        for (size_t row2 = 0; row2 < N; row2++) {
                if (row2 == row)
                    continue;
                double factor = temp[row2][row];
                temp[row2] = temp[row2] - factor * temp[row];
                inverse[row2] = inverse[row2] - factor * inverse[row];
            }
        }

        return inverse;
    }

    static int modulo(int a, int b) {
        int ret = a % b;
        if (ret < 0)
            ret += b;
        return ret;
    }

 public:
    
    static matrix<int> generate_encryption_key(size_t size, int limit1 = 0,
                                               int limit2 = 10) {
        matrix<int> encrypt_key(size, std::valarray<int>(size));
        matrix<int> min_mat = encrypt_key;
        int mat_determinant = -1;                                             int L = std::strlen(STRKEY);

        double dd;
        do {
                                    dd = rand_range(&encrypt_key, limit1, limit2);
            mat_determinant = static_cast<int>(dd);

            if (mat_determinant < 0)
                mat_determinant = (mat_determinant % L);
        } while (std::abs(dd) > 1e3 ||                   dd < 0.1 ||                   !std::isfinite(dd) ||                   gcd(mat_determinant, L) != 1);          
        return encrypt_key;
    }

    
    static matrix<int> generate_decryption_key(matrix<int> const &encrypt_key) {
        size_t size = encrypt_key.size();
        int L = std::strlen(STRKEY);

        matrix<int> decrypt_key(size, std::valarray<int>(size));
        int det_encrypt = static_cast<int>(determinant_lu(encrypt_key));

        int mat_determinant = det_encrypt < 0 ? det_encrypt % L : det_encrypt;

        matrix<double> tmp_inverse = get_inverse(encrypt_key);
        double d2 = determinant_lu(decrypt_key);

                int det_inv = -1;
        for (int i = 0; i < L; i++) {
            if (modulo(mat_determinant * i, L) == 1) {
                det_inv = i;
                break;
            }
        }

        if (det_inv == -1) {
            std::cerr << "Could not find a co-prime for inversion\n";
            std::exit(EXIT_FAILURE);
        }

        mat_determinant = det_inv * det_encrypt;

                int i;
#ifdef _OPENMP
#pragma parallel omp for private(i)
#endif
        for (i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                int temp = std::round(tmp_inverse[i][j] * mat_determinant);
                decrypt_key[i][j] = modulo(temp, L);
            }
        }
        return decrypt_key;
    }

    
    static std::pair<matrix<int>, matrix<int>> generate_keys(size_t size,
                                                             int limit1 = 0,
                                                             int limit2 = 10) {
        matrix<int> encrypt_key = generate_encryption_key(size);
        matrix<int> decrypt_key = generate_decryption_key(encrypt_key);
        double det2 = determinant_lu(decrypt_key);
        while (std::abs(det2) < 0.1 || std::abs(det2) > 1e3) {
            encrypt_key = generate_encryption_key(size, limit1, limit2);
            decrypt_key = generate_decryption_key(encrypt_key);
            det2 = determinant_lu(decrypt_key);
        }
        return std::make_pair(encrypt_key, decrypt_key);
    }

    
    static const std::string encrypt_text(const std::string &text,
                                          const matrix<int> &encrypt_key) {
        return codec(text, encrypt_key);
    }

    
    static const std::string decrypt_text(const std::string &text,
                                          const matrix<int> &decrypt_key) {
        return codec(text, decrypt_key);
    }
};

}  

void test1(const std::string &text) {
        std::cout << "======Test 1 (3x3 key) ======\nOriginal text:\n\t" << text
              << std::endl;

    std::pair<matrix<int>, matrix<int>> p =
        ciphers::HillCipher::generate_keys(3, 0, 100);
    matrix<int> ekey = p.first;
    matrix<int> dkey = p.second;

            std::string gibberish = ciphers::HillCipher::encrypt_text(text, ekey);
    std::cout << "Encrypted text:\n\t" << gibberish << std::endl;

            std::string txt_back = ciphers::HillCipher::decrypt_text(gibberish, dkey);
    std::cout << "Reconstruct text:\n\t" << txt_back << std::endl;

    std::ofstream out_file("hill_cipher_test1.txt");
    out_file << "Block size: " << ekey.size() << "\n";
    out_file << "Encryption Key:\n" << ekey;
    out_file << "\nDecryption Key:\n" << dkey;
    out_file.close();

    assert(txt_back == text);
    std::cout << "Passed :)\n";
}


void test2(const std::string &text) {
        std::cout << "======Test 2 (8x8 key) ======\nOriginal text:\n\t" << text
              << std::endl;

    std::pair<matrix<int>, matrix<int>> p =
        ciphers::HillCipher::generate_keys(8, 0, 3);
    matrix<int> ekey = p.first;
    matrix<int> dkey = p.second;

    std::string gibberish = ciphers::HillCipher::encrypt_text(text, ekey);
    std::cout << "Encrypted text:\n\t" << gibberish << std::endl;

    std::string txt_back = ciphers::HillCipher::decrypt_text(gibberish, dkey);
    std::cout << "Reconstruct text:\n\t" << txt_back << std::endl;

    std::ofstream out_file("hill_cipher_test2.txt");
    out_file << "Block size: " << ekey.size() << "\n";
    out_file << "Encryption Key:\n" << ekey;
    out_file << "\nDecryption Key:\n" << dkey;
    out_file.close();

    assert(txt_back.compare(0, text.size(), text) == 0);
    std::cout << "Passed :)\n";
}


int main() {
    std::srand(std::time(nullptr));
    std::cout << "Key dictionary: (" << std::strlen(ciphers::STRKEY) << ")\n\t"
              << ciphers::STRKEY << "\n";

    std::string text = "This is a simple text with numb3r5 and exclamat!0n.";

    test1(text);
    test2(text);

    return 0;
}

#include <cassert>   #include <iostream>  
#include "uint256_t.hpp"  

namespace ciphers {

namespace elliptic_curve_key_exchange {


typedef struct Point {
    uint256_t x, y;  
    
    inline bool operator==(const Point &p) { return x == p.x && y == p.y; }

    
    friend std::ostream &operator<<(std::ostream &op, const Point &p) {
        op << p.x << " " << p.y;
        return op;
    }
} Point;


uint256_t exp(uint256_t number, uint256_t power, const uint256_t &mod) {
    if (!power) {
        return uint256_t(1);
    }
    uint256_t ans(1);
    number = number % mod;
    while (power) {
        if ((power & 1)) {
            ans = (ans * number) % mod;
        }
        power >>= 1;
        if (power) {
            number = (number * number) % mod;
        }
    }
    return ans;
}


Point addition(Point a, Point b, const uint256_t &curve_a_coeff,
               uint256_t mod) {
    uint256_t lambda(0);      uint256_t zero(0);        lambda = zero = 0;
    uint256_t inf = ~zero;
    if (a.x != b.x || a.y != b.y) {
                if (b.x == a.x) {
            return {inf, inf};
        }
        uint256_t num = (b.y - a.y + mod), den = (b.x - a.x + mod);
        lambda = (num * (exp(den, mod - 2, mod))) % mod;
    } else {
        
        
        if (!a.y) {
            return {inf, inf};
        }
        uint256_t axsq = ((a.x * a.x)) % mod;
                axsq += (axsq << 1);
        axsq %= mod;
                uint256_t a_2 = (a.y << 1);
        lambda =
            (((axsq + curve_a_coeff) % mod) * exp(a_2, mod - 2, mod)) % mod;
    }
    Point c;
            c.x = ((lambda * lambda) % mod + (mod << 1) - a.x - b.x) % mod;
    c.y = (((lambda * (a.x + mod - c.x)) % mod) + mod - a.y) % mod;
    return c;
}


Point multiply(const Point &a, const uint256_t &curve_a_coeff, uint256_t p,
               const uint256_t &mod) {
    Point N = a;
    N.x %= mod;
    N.y %= mod;
    uint256_t inf{};
    inf = ~uint256_t(0);
    Point Q = {inf, inf};
    while (p) {
        if ((p & 1)) {
            if (Q.x == inf && Q.y == inf) {
                Q.x = N.x;
                Q.y = N.y;
            } else {
                Q = addition(Q, N, curve_a_coeff, mod);
            }
        }
        p >>= 1;
        if (p) {
            N = addition(N, N, curve_a_coeff, mod);
        }
    }
    return Q;
}
}  }  

static void uint128_t_tests() {
        uint128_t a("122"), b("2312");
    assert(a + b == 2434);
    assert(b - a == 2190);
    assert(a * b == 282064);
    assert(b / a == 18);
    assert(b % a == 116);
    assert((a & b) == 8);
    assert((a | b) == 2426);
    assert((a ^ b) == 2418);
    assert((a << 64) == uint128_t("2250502776992565297152"));
    assert((b >> 7) == 18);

        a = uint128_t("12321421424232142122");
    b = uint128_t("23123212");
    assert(a + b == uint128_t("12321421424255265334"));
    assert(a - b == uint128_t("12321421424209018910"));
    assert(a * b == uint128_t("284910839733861759501135864"));
    assert(a / b == 532859423865LL);
    assert(a % b == 3887742);
    assert((a & b) == 18912520);
    assert((a | b) == uint128_t("12321421424236352814"));
    assert((a ^ b) == uint128_t("12321421424217440294"));
    assert((a << 64) == uint128_t("227290107637132170748078080907806769152"));
}


static void uint256_t_tests() {
        uint256_t a("122"), b("2312");
    assert(a + b == 2434);
    assert(b - a == 2190);
    assert(a * b == 282064);
    assert(b / a == 18);
    assert(b % a == 116);
    assert((a & b) == 8);
    assert((a | b) == 2426);
    assert((a ^ b) == 2418);
    assert((a << 64) == uint256_t("2250502776992565297152"));
    assert((b >> 7) == 18);

        a = uint256_t("12321423124513251424232142122");
    b = uint256_t("23124312431243243215354315132413213212");
    assert(a + b == uint256_t("23124312443564666339867566556645355334"));
        assert(a - b == uint256_t("115792089237316195423570985008687907853246860353"
                              "221642219366742944204948568846"));
    assert(a * b == uint256_t("284924437928789743312147393953938013677909398222"
                              "169728183872115864"));
    assert(b / a == uint256_t("1876756621"));
    assert(b % a == uint256_t("2170491202688962563936723450"));
    assert((a & b) == uint256_t("3553901085693256462344"));
    assert((a | b) == uint256_t("23124312443564662785966480863388892990"));
    assert((a ^ b) == uint256_t("23124312443564659232065395170132430646"));
    assert((a << 128) == uint256_t("4192763024643754272961909047609369343091683"
                                   "376561852756163540549632"));
}


static void test() {
    
        uint256_t a("4451685225093714772084598273548424"),
        b("2061118396808653202902996166388514"),
        mod("4451685225093714772084598273548427");

        ciphers::elliptic_curve_key_exchange::Point ptr = {
        uint256_t("188281465057972534892223778713752"),
        uint256_t("3419875491033170827167861896082688")};

            std::cout << "For alice:\n";
        uint256_t alice_private_key("164330438812053169644452143505618");
    ciphers::elliptic_curve_key_exchange::Point alice_public_key =
        multiply(ptr, a, alice_private_key, mod);
    std::cout << "\tPrivate key: " << alice_private_key << "\n";
    std::cout << "\tPublic Key: " << alice_public_key << std::endl;

        std::cout << "For Bob:\n";
        uint256_t bob_private_key("1959473333748537081510525763478373");
    ciphers::elliptic_curve_key_exchange::Point bob_public_key =
        multiply(ptr, a, bob_private_key, mod);
    std::cout << "\tPrivate key: " << bob_private_key << "\n";
    std::cout << "\tPublic Key: " << bob_public_key << std::endl;

            ciphers::elliptic_curve_key_exchange::Point alice_shared_key = multiply(
                                                    bob_public_key, a,
                                                    alice_private_key, mod),
                                                bob_shared_key = multiply(
                                                    alice_public_key, a,
                                                    bob_private_key, mod);

    std::cout << "Shared keys:\n";
    std::cout << alice_shared_key << std::endl;
    std::cout << bob_shared_key << std::endl;

        assert(alice_shared_key == bob_shared_key);
}


int main() {
    uint128_t_tests();      uint256_t_tests();      test();                 return 0;
}

#include <cassert>   #include <iostream>  #include <map>       #include <string>    

namespace ciphers {

namespace atbash {
std::map<char, char> atbash_cipher_map = {
    {'a', 'z'}, {'b', 'y'}, {'c', 'x'}, {'d', 'w'}, {'e', 'v'}, {'f', 'u'},
    {'g', 't'}, {'h', 's'}, {'i', 'r'}, {'j', 'q'}, {'k', 'p'}, {'l', 'o'},
    {'m', 'n'}, {'n', 'm'}, {'o', 'l'}, {'p', 'k'}, {'q', 'j'}, {'r', 'i'},
    {'s', 'h'}, {'t', 'g'}, {'u', 'f'}, {'v', 'e'}, {'w', 'd'}, {'x', 'c'},
    {'y', 'b'}, {'z', 'a'}, {'A', 'Z'}, {'B', 'Y'}, {'C', 'X'}, {'D', 'W'},
    {'E', 'V'}, {'F', 'U'}, {'G', 'T'}, {'H', 'S'}, {'I', 'R'}, {'J', 'Q'},
    {'K', 'P'}, {'L', 'O'}, {'M', 'N'}, {'N', 'M'}, {'O', 'L'}, {'P', 'K'},
    {'Q', 'J'}, {'R', 'I'}, {'S', 'H'}, {'T', 'G'}, {'U', 'F'}, {'V', 'E'},
    {'W', 'D'}, {'X', 'C'}, {'Y', 'B'}, {'Z', 'A'}, {' ', ' '}

};


std::string atbash_cipher(const std::string& text) {
    std::string result;
    for (char letter : text) {
        result += atbash_cipher_map[letter];
    }
    return result;
}

}  }  

static void test() {
        std::string text = "Hello World";
    std::string expected = "Svool Dliow";
    std::string encrypted_text = ciphers::atbash::atbash_cipher(text);
    std::string decrypted_text = ciphers::atbash::atbash_cipher(encrypted_text);
    assert(expected == encrypted_text);
    assert(text == decrypted_text);
    std::cout << "Original text: " << text << std::endl;
    std::cout << ", Expected text: " << expected << std::endl;
    std::cout << ", Encrypted text: " << encrypted_text << std::endl;
    std::cout << ", Decrypted text: " << decrypted_text << std::endl;
    std::cout << "\nAll tests have successfully passed!\n";
}


int main() {
    test();      return 0;
}

#include <iostream>
#include <string>
#include <cassert>


namespace ciphers {
    
    namespace XOR {   
        
        std::string encrypt (const std::string &text, const int &key) {
            std::string encrypted_text = "";             for (auto &c: text) {                 char encrypted_char = char(c ^ key);                 encrypted_text += encrypted_char;             }
            return encrypted_text;         }
                
        std::string decrypt (const std::string &text, const int &key) {
            std::string decrypted_text = "";             for (auto &c : text) {                 char decrypted_char = char(c ^ key);                 decrypted_text += decrypted_char;             }
            return decrypted_text;         }
    } } 

void test() {
        std::string text1 = "Whipalsh! : Do watch this movie...";
    std::string encrypted1 = ciphers::XOR::encrypt(text1, 17);
    std::string decrypted1 = ciphers::XOR::decrypt(encrypted1, 17);
    assert(text1 == decrypted1);
    std::cout << "Original text : " << text1;
    std::cout << " , Encrypted text (with key = 17) : " << encrypted1;
    std::cout << " , Decrypted text : "<< decrypted1 << std::endl;
        std::string text2 = "->Valar M0rghulis<-";
    std::string encrypted2 = ciphers::XOR::encrypt(text2, 29);
    std::string decrypted2 = ciphers::XOR::decrypt(encrypted2, 29);
    assert(text2 == decrypted2);
    std::cout << "Original text : " << text2;
    std::cout << " , Encrypted text (with key = 29) : " << encrypted2;
    std::cout << " , Decrypted text : "<< decrypted2 << std::endl;
}


int main() {
        test();
    return 0;
}

#include <iostream>
#include <string>
#include <cassert>


namespace ciphers {
    
    namespace caesar {   
        namespace {
                    
            inline char get_char(const int x) {
                                                return char(x + 65); 
            }
              
            inline int get_value(const char c) {
                                                return int(c - 65);
            }
        }         
        std::string encrypt (const std::string &text, const int &shift) {
            std::string encrypted_text = "";             for (char c : text) {                 int place_value = get_value(c);                 place_value = (place_value + shift) % 26;                 char new_char = get_char(place_value);                 encrypted_text += new_char;             }
            return encrypted_text;         }
                
        std::string decrypt (const std::string &text, const int &shift) {
            std::string decrypted_text = "";             for (char c : text) {                 int place_value = get_value(c);                 place_value = (place_value - shift) % 26;                if(place_value < 0) {                     place_value = place_value + 26;
                }
                char new_char = get_char(place_value);                 decrypted_text += new_char;             }
            return decrypted_text;         }
    } } 

void test() {
        std::string text1 = "ALANTURING";
    std::string encrypted1 = ciphers::caesar::encrypt(text1, 17);
    std::string decrypted1 = ciphers::caesar::decrypt(encrypted1, 17);
    assert(text1 == decrypted1);
    std::cout << "Original text : " << text1;
    std::cout << " , Encrypted text (with shift = 21) : " << encrypted1;
    std::cout << " , Decrypted text : "<< decrypted1 << std::endl;
        std::string text2 = "HELLOWORLD";
    std::string encrypted2 = ciphers::caesar::encrypt(text2, 1729);
    std::string decrypted2 = ciphers::caesar::decrypt(encrypted2, 1729);
    assert(text2 == decrypted2);
    std::cout << "Original text : " << text2;
    std::cout << " , Encrypted text (with shift = 1729) : " << encrypted2;
    std::cout << " , Decrypted text : "<< decrypted2 << std::endl;
}


int main() {
        test();
    return 0;
}

#include <iostream>
#include <string>
#include <cassert>


namespace ciphers {
    
    namespace vigenere {   
        namespace {
                    
            inline char get_char(const int x) {
                                                return char(x + 65); 
            }
              
            inline int get_value(const char c) {
                                                return int(c - 65);
            }
        }         
        std::string encrypt (const std::string &text, const std::string &key) {
            std::string encrypted_text = "";                                     for(size_t i = 0, j = 0; i < text.length(); i++, j = (j + 1) % key.length()) {
                int place_value_text = get_value(text[i]);                 int place_value_key = get_value(key[j]);                 place_value_text = (place_value_text + place_value_key) % 26;                 char encrypted_char = get_char(place_value_text);                 encrypted_text += encrypted_char;             }
            return encrypted_text;         }
                
        std::string decrypt (const std::string &text, const std::string &key) {
                                    std::string decrypted_text = "";             for(size_t i = 0, j = 0; i < text.length(); i++, j = (j + 1) % key.length()) {
                int place_value_text = get_value(text[i]);                 int place_value_key = get_value(key[j]);                 place_value_text = (place_value_text - place_value_key + 26) % 26;                 char decrypted_char = get_char(place_value_text);                 decrypted_text += decrypted_char;             }        
            return decrypted_text;         }
    } } 

void test() {
        std::string text1 = "NIKOLATESLA";
    std::string encrypted1 = ciphers::vigenere::encrypt(text1, "TESLA");
    std::string decrypted1 = ciphers::vigenere::decrypt(encrypted1, "TESLA");
    assert(text1 == decrypted1);
    std::cout << "Original text : " << text1;
    std::cout << " , Encrypted text (with key = TESLA) : " << encrypted1;
    std::cout << " , Decrypted text : "<< decrypted1 << std::endl;
        std::string text2 = "GOOGLEIT";
    std::string encrypted2 = ciphers::vigenere::encrypt(text2, "REALLY");
    std::string decrypted2 = ciphers::vigenere::decrypt(encrypted2, "REALLY");
    assert(text2 == decrypted2);
    std::cout << "Original text : " << text2;
    std::cout << " , Encrypted text (with key = REALLY) : " << encrypted2;
    std::cout << " , Decrypted text : "<< decrypted2 << std::endl;
}


int main() {
        test();
    return 0;
}
#include <algorithm>
#include <iostream>
#include <utility>
#include <vector>

int minSwaps(int arr[], int n) {
                std::pair<int, int> *arrPos = new std::pair<int, int>[n];
    for (int i = 0; i < n; i++) {
        arrPos[i].first = arr[i];
        arrPos[i].second = i;
    }

                std::sort(arrPos, arrPos + n);

            std::vector<bool> vis(n, false);

        int ans = 0;

        for (int i = 0; i < n; i++) {
                        if (vis[i] || arrPos[i].second == i)
            continue;

                        int cycle_size = 0;
        int j = i;
        while (!vis[j]) {
            vis[j] = 1;

                        j = arrPos[j].second;
            cycle_size++;
        }

                if (cycle_size > 0) {
            ans += (cycle_size - 1);
        }
    }

    delete[] arrPos;

        return ans;
}

int main() {
    int arr[] = {6, 7, 8, 1, 2, 3, 9, 12};
    int n = (sizeof(arr) / sizeof(int));
    std::cout << minSwaps(arr, n);
    return 0;
}


#include <algorithm>  #include <cassert>  #include <iostream>  #include <vector>    

namespace sorting {

namespace radix_sort {

std::vector<uint64_t> step_ith(
    uint16_t cur_digit,
    const std::vector<uint64_t>& ar) {      int n = ar.size();
    std::vector<uint32_t> position(10, 0);
    for (int i = 0; i < n; ++i) {
        position[(ar[i] / cur_digit) %
                 10]++;      }
    int cur = 0;
    for (int i = 0; i < 10; ++i) {
        int a = position[i];
        position[i] = cur;          cur += a;
    }
    std::vector<uint64_t> temp(n);
    for (int i = 0; i < n; ++i) {
        temp[position[(ar[i] / cur_digit) % 10]] =
            ar[i];                              position[(ar[i] / cur_digit) %
                 10]++;                               }
    return temp;
}

std::vector<uint64_t> radix(const std::vector<uint64_t>& ar) {
    uint64_t max_ele =
        *max_element(ar.begin(), ar.end());      std::vector<uint64_t> temp = ar;
    for (int i = 1; max_ele / i > 0;
         i *= 10) {                               temp = step_ith(i, temp);
    }
    for (uint64_t i : temp) {
        std::cout << i << " ";
    }
    std::cout << "\n";
    return temp;
}
}  }  

static void tests() {
        std::vector<uint64_t> ar1 = {432, 234, 143, 332, 123};
    ar1 = sorting::radix_sort::radix(ar1);
    assert(std::is_sorted(ar1.begin(), ar1.end()));
        std::vector<uint64_t> ar2 = {213, 3214, 123, 111, 112, 142,
                                 133, 132,  32,  12,  113};
    ar2 = sorting::radix_sort::radix(ar2);
    assert(std::is_sorted(ar2.begin(), ar2.end()));
}

int main() {
    tests();      return 0;
}

#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     

namespace sorting {


std::vector<uint64_t> selectionSort(const std::vector<uint64_t> &arr,
                                    uint64_t len) {
    std::vector<uint64_t> array(
        arr.begin(),
        arr.end());      for (uint64_t it = 0; it < len; ++it) {
        uint64_t min = it;          for (uint64_t it2 = it + 1; it2 < len; ++it2) {
            if (array[it2] < array[min]) {                  min = it2;              }
        }

        if (min != it) {              uint64_t tmp = array[min];
            array[min] = array[it];
            array[it] = tmp;
        }
    }

    return array;  }
}  

static void test() {
            std::vector<uint64_t> vector1 = {1, 0, 0, 1, 1, 0, 2, 1};
    uint64_t vector1size = vector1.size();
    std::cout << "1st test... ";
    std::vector<uint64_t> result_test1;
    result_test1 = sorting::selectionSort(vector1, vector1size);
    assert(std::is_sorted(result_test1.begin(), result_test1.end()));
    std::cout << "Passed" << std::endl;

                std::vector<uint64_t> vector2 = {19, 22, 540, 241, 156, 140, 12, 1};
    uint64_t vector2size = vector2.size();
    std::cout << "2nd test... ";
    std::vector<uint64_t> result_test2;
    result_test2 = sorting::selectionSort(vector2, vector2size);
    assert(std::is_sorted(result_test2.begin(), result_test2.end()));
    std::cout << "Passed" << std::endl;

            std::vector<uint64_t> vector3 = {11, 20, 30, 41, 15, 60, 82, 15};
    uint64_t vector3size = vector3.size();
    std::cout << "3rd test... ";
    std::vector<uint64_t> result_test3;
    result_test3 = sorting::selectionSort(vector3, vector3size);
    assert(std::is_sorted(result_test3.begin(), result_test3.end()));
    std::cout << "Passed" << std::endl;

                std::vector<uint64_t> vector4 = {1, 9, 11, 546, 26, 65, 212, 14};
    uint64_t vector4size = vector2.size();
    std::cout << "4th test... ";
    std::vector<uint64_t> result_test4;
    result_test4 = sorting::selectionSort(vector4, vector4size);
    assert(std::is_sorted(result_test4.begin(), result_test4.end()));
    std::cout << "Passed" << std::endl;
}


int main() {
    test();      return 0;
}

#include <algorithm>
#include <cassert>
#include <ctime>
#include <iostream>
#include <vector>

namespace {

template <typename T>
std::ostream &operator<<(std::ostream &out, const std::vector<T> &arr) {
    for (size_t i = 0; i < arr.size(); ++i) {
        out << arr[i];
        if (i < arr.size() - 1) {
            out << ", ";
        }
    }
    return out;
}

}  

namespace sorting {
namespace {               
template <typename T>
void partition3(std::vector<T> *arr, int32_t low, int32_t high, int32_t *i,
                int32_t *j) {
        if (high - low <= 1) {
        if ((*arr)[high] < (*arr)[low]) {
            std::swap((*arr)[high], (*arr)[low]);
        }
        *i = low;
        *j = high;
        return;
    }

    int32_t mid = low;
    T pivot = (*arr)[high];
    while (mid <= high) {
        if ((*arr)[mid] < pivot) {
            std::swap((*arr)[low++], (*arr)[mid++]);
        } else if ((*arr)[mid] == pivot) {
            mid++;
        } else if ((*arr)[mid] > pivot) {
            std::swap((*arr)[mid], (*arr)[high--]);
        }
    }

        *i = low - 1;
    *j = mid;  }
}  

template <typename T>
void quicksort(std::vector<T> *arr, int32_t low, int32_t high) {
    if (low >= high) {          return;
    }

    int32_t i = 0, j = 0;

        partition3(arr, low, high, &i, &j);

        quicksort(arr, low, i);
    quicksort(arr, j, high);
}


template <typename T>
std::vector<T> quicksort(std::vector<T> arr, int32_t low, int32_t high) {
    if (low >= high) {          return arr;
    }

    int32_t i = 0, j = 0;

        partition3(&arr, low, high, &i, &j);

        quicksort(&arr, low, i);
    quicksort(&arr, j, high);

    return arr;
}
}  

static void test_int() {
    std::cout << "\nTesting integer type arrays\n";

    for (int num_tests = 1; num_tests < 21; num_tests++) {
        size_t size = std::rand() % 500;
        std::vector<int> arr(size);
        for (auto &a : arr) {
            a = std::rand() % 500 - 250;          }

        std::cout << "Test " << num_tests << "\t Array size:" << size << "\t ";
        std::vector<int> sorted = sorting::quicksort(arr, 0, size - 1);
        if (size < 20) {
            std::cout << "\t Sorted Array is:\n\t";
            std::cout << sorted << "\n";
        }
        assert(std::is_sorted(std::begin(sorted), std::end(sorted)));
        std::cout << "\t Passed\n";
    }
}


static void test_double() {
    std::cout << "\nTesting Double type arrays\n";
    for (int num_tests = 1; num_tests < 21; num_tests++) {
        size_t size = std::rand() % 500;
        std::vector<double> arr(size);
        for (auto &a : arr) {
            a = double(std::rand() % 500) -
                250.f;               a /= 100.f;          }

        std::cout << "Test " << num_tests << "\t Array size:" << size << "\t ";
        std::vector<double> sorted = sorting::quicksort(arr, 0, size - 1);
        if (size < 20) {
            std::cout << "\t Sorted Array is:\n\t";
            std::cout << sorted << "\n";
        }
        assert(std::is_sorted(std::begin(sorted), std::end(sorted)));
        std::cout << "\t Passed\n";
    }
}


int main() {
    std::srand(std::time(nullptr));
    test_int();
    test_double();
    return 0;
}


#include <algorithm>
#include <cassert>
#include <iostream>
#include <vector>


namespace sorting {

template <typename T>
void insertionSort(T *arr, int n) {
    for (int i = 1; i < n; i++) {
        T temp = arr[i];
        int j = i - 1;
        while (j >= 0 && temp < arr[j]) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = temp;
    }
}


template <typename T>
void insertionSort(std::vector<T> *arr) {
    size_t n = arr->size();

    for (size_t i = 1; i < n; i++) {
        T temp = arr[0][i];
        int32_t j = i - 1;
        while (j >= 0 && temp < arr[0][j]) {
            arr[0][j + 1] = arr[0][j];
            j--;
        }
        arr[0][j + 1] = temp;
    }
}

}  

template <typename T>
static void create_random_array(T *arr, int N) {
    while (N--) {
        double r = (std::rand() % 10000 - 5000) / 100.f;
        arr[N] = static_cast<T>(r);
    }
}


void tests() {
    int arr1[10] = {78, 34, 35, 6, 34, 56, 3, 56, 2, 4};
    std::cout << "Test 1... ";
    sorting::insertionSort(arr1, 10);
    assert(std::is_sorted(arr1, arr1 + 10));
    std::cout << "passed" << std::endl;

    int arr2[5] = {5, -3, 7, -2, 1};
    std::cout << "Test 2... ";
    sorting::insertionSort(arr2, 5);
    assert(std::is_sorted(arr2, arr2 + 5));
    std::cout << "passed" << std::endl;

    float arr3[5] = {5.6, -3.1, -3.0, -2.1, 1.8};
    std::cout << "Test 3... ";
    sorting::insertionSort(arr3, 5);
    assert(std::is_sorted(arr3, arr3 + 5));
    std::cout << "passed" << std::endl;

    std::vector<float> arr4({5.6, -3.1, -3.0, -2.1, 1.8});
    std::cout << "Test 4... ";
    sorting::insertionSort(&arr4);
    assert(std::is_sorted(std::begin(arr4), std::end(arr4)));
    std::cout << "passed" << std::endl;

    int arr5[50];
    std::cout << "Test 5... ";
    create_random_array(arr5, 50);
    sorting::insertionSort(arr5, 50);
    assert(std::is_sorted(arr5, arr5 + 50));
    std::cout << "passed" << std::endl;

    float arr6[50];
    std::cout << "Test 6... ";
    create_random_array(arr6, 50);
    sorting::insertionSort(arr6, 50);
    assert(std::is_sorted(arr6, arr6 + 50));
    std::cout << "passed" << std::endl;
}


int main() {
        tests();

        size_t n;
    std::cout << "Enter the length of your array (0 to exit): ";
    std::cin >> n;
    if (n == 0) {
        return 0;
    }

    int *arr = new int[n];
    std::cout << "Enter any " << n << " Numbers for Unsorted Array : ";

    for (int i = 0; i < n; i++) {
        std::cin >> arr[i];
    }

    sorting::insertionSort(arr, n);

    std::cout << "\nSorted Array : ";
    for (int i = 0; i < n; i++) {
        std::cout << arr[i] << " ";
    }

    std::cout << std::endl;
    delete[] arr;
    return 0;
}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     

namespace sorting {

namespace wave_sort {

template <typename T>
std::vector<T> waveSort(const std::vector<T> &in_arr, int64_t n) {
    std::vector<T> arr(in_arr);

    for (int64_t i = 0; i < n; i++) {
        arr[i] = in_arr[i];
    }
    std::sort(arr.begin(), arr.end());
    for (int64_t i = 0; i < n - 1; i += 2) {          std::swap(arr[i], arr[i + 1]);
    }
    return arr;
}
}  }  

static void test() {
        std::vector<int64_t> array1 = {10, 90, 49, 2, 1, 5, 23};
    std::cout << "Test 1... ";
    std::vector<int64_t> arr1 = sorting::wave_sort::waveSort(array1, 7);
    const std::vector<int64_t> o1 = {2, 1, 10, 5, 49, 23, 90};
    assert(arr1 == o1);
    std::cout << "passed" << std::endl;

        std::vector<int64_t> array2 = {1, 3, 4, 2, 7, 8};
    std::cout << "Test 2... ";
    std::vector<int64_t> arr2 = sorting::wave_sort::waveSort(array2, 6);
    const std::vector<int64_t> o2 = {2, 1, 4, 3, 8, 7};
    assert(arr2 == o2);
    std::cout << "passed" << std::endl;

        std::vector<int64_t> array3 = {3, 3, 3, 3};
    std::cout << "Test 3... ";
    std::vector<int64_t> arr3 = sorting::wave_sort::waveSort(array3, 4);
    const std::vector<int64_t> o3 = {3, 3, 3, 3};
    assert(arr3 == o3);
    std::cout << "passed" << std::endl;

        std::vector<int64_t> array4 = {9, 4, 6, 8, 14, 3};
    std::cout << "Test 4... ";
    std::vector<int64_t> arr4 = sorting::wave_sort::waveSort(array4, 6);
    const std::vector<int64_t> o4 = {4, 3, 8, 6, 14, 9};
    assert(arr4 == o4);
    std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}

#include <iostream>
#include <algorithm>
#include <array>
#include <cassert>



namespace sorting {

template <typename T, size_t N>
std::array <T, N> shuffle (std::array <T, N> arr) {
    for (int i = 0; i < N; i++) {
                std::swap(arr[i], arr[std::rand() % N]);
    }
    return arr;
}

template <typename T, size_t N>
std::array <T, N> randomized_bogosort (std::array <T, N> arr) {
        while (!std::is_sorted(arr.begin(), arr.end())) {
        std::random_shuffle(arr.begin(), arr.end());    }
    return arr;
}

}  

template <typename T, size_t N>
void show_array (const std::array <T, N> &arr) {
    for (int x : arr) {
        std::cout << x << ' ';
    }
    std::cout << '\n';
}


void test() {
        std::array <int, 5> arr1;
    for (int &x : arr1) {
        x = std::rand() % 100;
    }
    std::cout << "Original Array : ";
    show_array(arr1);
    arr1 = sorting::randomized_bogosort(arr1);
    std::cout << "Sorted Array : ";
    show_array(arr1);
    assert(std::is_sorted(arr1.begin(), arr1.end()));
        std::array <int, 5> arr2;
    for (int &x : arr2) {
        x = std::rand() % 100;
    }
    std::cout << "Original Array : ";
    show_array(arr2);
    arr2 = sorting::randomized_bogosort(arr2);
    std::cout << "Sorted Array : ";
    show_array(arr2);
    assert(std::is_sorted(arr2.begin(), arr2.end()));
}


int main() {
        test();
        std::array <int, 5> arr = {3, 7, 10, 4, 1};     std::cout << "Original Array : ";
    show_array(arr);
    arr = sorting::randomized_bogosort(arr);     std::cout << "Sorted Array : ";
    show_array(arr);     return 0;
}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     

namespace sorting {

namespace cycle_sort {

template <typename T>
std::vector<T> cycleSort(const std::vector<T> &in_arr) {
    std::vector<T> arr(in_arr);
    for (int cycle_start = 0; cycle_start <= arr.size() - 1; cycle_start++) {
                T item = arr[cycle_start];

                        int pos = cycle_start;
        for (int i = cycle_start + 1; i < arr.size(); i++) {
            if (arr[i] < item) {
                pos++;
            }
        }

                if (pos == cycle_start) {
            continue;
        }

                while (item == arr[pos]) pos += 1;
        if (pos == cycle_start) {
            continue;
        } else {
            std::swap(item, arr[pos]);
        }
                while (pos != cycle_start) {
            pos = cycle_start;
                        for (size_t i = cycle_start + 1; i < arr.size(); i++) {
                if (arr[i] < item) {
                    pos += 1;
                }
            }
                        while (item == arr[pos]) pos += 1;
            if (item == arr[pos]) {
                continue;
            } else {
                std::swap(item, arr[pos]);
            }
        }
    }
    return arr;
}
}  }  

static void test() {
            std::vector<uint32_t> array1 = {4, 3, 2, 1};
    std::cout << "Test 1... ";
    std::vector<uint32_t> arr1 = sorting::cycle_sort::cycleSort(array1);
    assert(std::is_sorted(std::begin(arr1), std::end(arr1)));
    std::cout << "passed" << std::endl;

        std::vector<double> array2 = {4.3, -6.5, -7.4, 0, 2.7, 1.8};
    std::cout << "Test 2... ";
    std::vector<double> arr2 = sorting::cycle_sort::cycleSort(array2);
    assert(std::is_sorted(std::begin(arr2), std::end(arr2)));
    std::cout << "passed" << std::endl;

            std::vector<uint32_t> array3 = {3, 3, 3, 3};
    std::cout << "Test 3... ";
    std::vector<uint32_t> arr3 = sorting::cycle_sort::cycleSort(array3);
    assert(std::is_sorted(std::begin(arr3), std::end(arr3)));
    std::cout << "passed" << std::endl;

        std::vector<uint32_t> array4 = {3, 4, 6, 8, 9, 14};
    std::cout << "Test 4... ";
    std::vector<uint32_t> arr4 = sorting::cycle_sort::cycleSort(array4);
    assert(std::is_sorted(std::begin(arr4), std::end(arr4)));
    std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}
#include <iostream>

int main() {
    int size = 10;
    int* array = new int[size];
        std::cout << "\nHow many numbers do want to enter in unsorted array : ";
    std::cin >> size;
    std::cout << "\nEnter the numbers for unsorted array : ";
    for (int i = 0; i < size; i++) {
        std::cin >> array[i];
    }

        for (int i = size / 2; i > 0; i = i / 2) {
        for (int j = i; j < size; j++) {
            for (int k = j - i; k >= 0; k = k - i) {
                if (array[k] < array[k + i]) {
                    break;
                } else {
                    int temp = array[k + i];
                    array[k + i] = array[k];
                    array[k] = temp;
                }
            }
        }
    }

        std::cout << "\nSorted array : ";
    for (int i = 0; i < size; ++i) {
        std::cout << array[i] << "\t";
    }

    delete[] array;
    return 0;
}

#include <cstddef>  #include <iostream>
#include <utility>  
namespace sorting {
template <class Iterator>
void merge(Iterator, Iterator, const Iterator, char[]);

template <class Iterator>
void non_recursive_merge_sort(const Iterator first, const Iterator last,
                              const size_t n) {
            char* buffer = new char[n * sizeof(*first)];
                for (size_t length(1); length < n; length <<= 1) {
                Iterator left(first);
        for (size_t counter(n / (length << 1)); counter; --counter) {
            Iterator right(left + length), end(right + length);
            merge(left, right, end, buffer);
            left = end;
        }
                        if ((n & ((length << 1) - 1)) > length)
            merge(left, left + length, last, buffer);
    }
    delete[] buffer;
}

template <class Iterator>
void merge(Iterator l, Iterator r, const Iterator e, char b[]) {
        auto p(reinterpret_cast<std::remove_reference_t<decltype(*l)>*>(b)), c(p);
        for (Iterator t(l); r != t; ++t) *p++ = std::move(*t);
            while (e != r && c != p) *l++ = std::move(*r < *c ? *r++ : *c++);
            while (e != r) *l++ = std::move(*r++);
        while (c != p) *l++ = std::move(*c++);
}

template <class Iterator>
void non_recursive_merge_sort(const Iterator first, const size_t n) {
    non_recursive_merge_sort(first, first + n, n);
}

template <class Iterator>
void non_recursive_merge_sort(const Iterator first, const Iterator last) {
    non_recursive_merge_sort(first, last, last - first);
}

}  
using sorting::non_recursive_merge_sort;

int main(int argc, char** argv) {
    int size;
    std::cout << "Enter the number of elements : ";
    std::cin >> size;
    int* arr = new int[size];
    for (int i = 0; i < size; ++i) {
        std::cout << "arr[" << i << "] = ";
        std::cin >> arr[i];
    }
    non_recursive_merge_sort(arr, size);
    std::cout << "Sorted array\n";
    for (int i = 0; i < size; ++i)
        std::cout << "arr[" << i << "] = " << arr[i] << '\n';
    delete[] arr;
    return 0;
}



#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

bool NumericSort(std::string a, std::string b) {
    while (a[0] == '0') {
        a.erase(a.begin());
    }
    while (b[0] == '0') {
        b.erase(b.begin());
    }
    int n = a.length();
    int m = b.length();
    if (n == m)
        return a < b;
    return n < m;
}

int main() {
    int n;
    std::cout << "Enter number of elements to be sorted Numerically\n";
    std::cin >> n;

    std::vector<std::string> v(n);
    std::cout << "Enter the string of Numbers\n";
    for (int i = 0; i < n; i++) {
        std::cin >> v[i];
    }

    sort(v.begin(), v.end());
    std::cout << "Elements sorted normally \n";
    for (int i = 0; i < n; i++) {
        std::cout << v[i] << " ";
    }
    std::cout << "\n";

    std::sort(v.begin(), v.end(), NumericSort);
    std::cout << "Elements sorted Numerically \n";
    for (int i = 0; i < n; i++) {
        std::cout << v[i] << " ";
    }

    return 0;
}


#include <algorithm>
#include <cassert>
#include <ctime>
#include <iostream>  #include <vector>


namespace sorting {

namespace wiggle_sort {


template <typename T>                                                std::vector<T> wiggleSort(const std::vector<T> &arr) {
    uint32_t size = arr.size();

    std::vector<T> out(
        arr);                 
    for (int i = 0; i < size; i += 2) {
        if (i > 0 && out[i - 1] > out[i]) {
            std::swap(out[i], out[i - 1]);          }

        if (i < size - 1 && out[i] < out[i + 1]) {
            std::swap(out[i], out[i + 1]);          }
    }

    return out;  }
}  }  

template <typename T>
static void displayElements(const std::vector<T> &arr) {
    uint32_t size = arr.size();

    std::cout << "Sorted elements are as follows: ";

    std::cout << "[";

    for (int i = 0; i < size; i++) {
        std::cout << arr[i];
        if (i != size - 1) {
            std::cout << ", ";
        }
    }

    std::cout << "]" << std::endl;
}


static void test() {
    std::srand(std::time(nullptr));  
    std::vector<float> data1(100);
    for (auto &d : data1) {          d = float(std::rand() % 1000 - 500) / 100.f;
    }

    std::vector<float> sorted = sorting::wiggle_sort::wiggleSort<float>(data1);

    displayElements(sorted);

    for (uint32_t j = 0; j < data1.size(); j += 2) {
        assert(data1[j] <= data1[j + 1] &&
               data1[j + 1] >= data1[j + 2]);      }

    std::cout << "Test 1 passed\n";
}


int main() {
    test();
    return 0;
}



#include <algorithm>
#include <cassert>
#include <iostream>


template <typename T>
void printArray(T *arr, int sz) {
    for (int i = 0; i < sz; i++) std::cout << arr[i] << "  ";
    std::cout << "\n";
}


template <typename T>
void heapify(T *arr, int n, int i) {
    int largest = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;

    if (l < n && arr[l] > arr[largest])
        largest = l;

    if (r < n && arr[r] > arr[largest])
        largest = r;

    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}


template <typename T>
void heapSort(T *arr, int n) {
    for (int i = n - 1; i >= 0; i--) heapify(arr, n, i);

    for (int i = n - 1; i >= 0; i--) {
        std::swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}


void test() {
    std::cout << "Test 1\n";
    int arr[] = {-10, 78, -1, -6, 7, 4, 94, 5, 99, 0};
    int sz = sizeof(arr) / sizeof(arr[0]);      printArray(arr, sz);      heapSort(arr, sz);        printArray(arr, sz);      assert(std::is_sorted(arr, arr + sz));
    std::cout << "Test 1 Passed\n========================\n";

    std::cout << "Test 2\n";
    double arr2[] = {4.5, -3.6, 7.6, 0, 12.9};
    sz = sizeof(arr2) / sizeof(arr2[0]);
    printArray(arr2, sz);
    heapSort(arr2, sz);
    printArray(arr2, sz);
    assert(std::is_sorted(arr2, arr2 + sz));
    std::cout << "Test 2 passed\n";
}


int main() {
    test();
    return 0;
}
#include <algorithm>
#include <iostream>

const int RUN = 32;

void insertionSort(int arr[], int left, int right) {
    for (int i = left + 1; i <= right; i++) {
        int temp = arr[i];
        int j = i - 1;
        while (arr[j] > temp && j >= left) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = temp;
    }
}

void merge(int arr[], int l, int m, int r) {
        int len1 = m - l + 1, len2 = r - m;
    int *left = new int[len1], *right = new int[len2];
    for (int i = 0; i < len1; i++) left[i] = arr[l + i];
    for (int i = 0; i < len2; i++) right[i] = arr[m + 1 + i];

    int i = 0;
    int j = 0;
    int k = l;

        while (i < len1 && j < len2) {
        if (left[i] <= right[j]) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }

        while (i < len1) {
        arr[k] = left[i];
        k++;
        i++;
    }

        while (j < len2) {
        arr[k] = right[j];
        k++;
        j++;
    }
    delete[] left;
    delete[] right;
}

void timSort(int arr[], int n) {
        for (int i = 0; i < n; i += RUN)
        insertionSort(arr, i, std::min((i + 31), (n - 1)));

            for (int size = RUN; size < n; size = 2 * size) {
                                for (int left = 0; left < n; left += 2 * size) {
                                    int mid = left + size - 1;
            int right = std::min((left + 2 * size - 1), (n - 1));

                        merge(arr, left, mid, right);
        }
    }
}

void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) printf("%d  ", arr[i]);
    std::cout << std::endl;
}

int main() {
    int arr[] = {5, 21, 7, 23, 19};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf("Given Array is\n");
    printArray(arr, n);

    timSort(arr, n);

    printf("After Sorting Array is\n");
    printArray(arr, n);
    return 0;
}


#include <cstdlib>
#include <iostream>

namespace sorting {


int partition(int arr[], int low, int high) {
    int pivot = arr[high];      int i = (low - 1);      
    for (int j = low; j < high; j++) {
                        if (arr[j] <= pivot) {
            i++;              int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return (i + 1);
}


void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int p = partition(arr, low, high);
        quickSort(arr, low, p - 1);
        quickSort(arr, p + 1, high);
    }
}

}  
using sorting::quickSort;

void show(int arr[], int size) {
    for (int i = 0; i < size; i++) std::cout << arr[i] << " ";
    std::cout << "\n";
}


int main() {
    int size;
    std::cout << "\nEnter the number of elements : ";

    std::cin >> size;

    int *arr = new int[size];

    std::cout << "\nEnter the unsorted elements : ";

    for (int i = 0; i < size; ++i) {
        std::cout << "\n";
        std::cin >> arr[i];
    }
    quickSort(arr, 0, size);
    std::cout << "Sorted array\n";
    show(arr, size);
    delete[] arr;
    return 0;
}

#include <cassert>   #include <cstdint>   #include <iostream>  #include <vector>    

namespace sorting {

namespace inversion {



template <typename T>
uint32_t merge(T* arr, T* temp, uint32_t left, uint32_t mid, uint32_t right) {
    uint32_t i = left;       
    uint32_t j = mid + 1;   
    uint32_t k = left;    
    uint32_t inv_count = 0;  
    while ((i <= mid) && (j <= right)) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
            inv_count +=
                (mid - i +
                 1);          }
    }
        while (i <= mid) {
        temp[k++] = arr[i++];
    }
    while (j <= right) {
        temp[k++] = arr[j++];
    }
        for (k = left; k <= right; k++) {
        arr[k] = temp[k];
    }
    return inv_count;
}


template <typename T>
uint32_t mergeSort(T* arr, T* temp, uint32_t left, uint32_t right) {
    uint32_t mid = 0, inv_count = 0;
    if (right > left) {
                mid = (right + left) / 2;
                inv_count += mergeSort(arr, temp, left, mid);          inv_count += mergeSort(arr, temp, mid + 1, right);

                inv_count += merge(arr, temp, left, mid, right);
    }
    return inv_count;
}


template <class T>
uint32_t countInversion(T* arr, const uint32_t size) {
    std::vector<T> temp;
    temp.reserve(size);
    temp.assign(size, 0);
    return mergeSort(arr, temp.data(), 0, size - 1);
}


template <typename T>
void show(T* arr, const uint32_t array_size) {
    std::cout << "Printing array: \n";
    for (uint32_t i = 0; i < array_size; i++) {
        std::cout << " " << arr[i];
    }
    std::cout << "\n";
}

}  }  

static void test() {
        std::vector<uint64_t> arr1 = {
        100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84,
        83,  82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67,
        66,  65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50,
        49,  48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33,
        32,  31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
        15,  14, 13, 12, 11, 10, 9,  8,  7,  6,  5,  4,  3,  2,  1};
    uint32_t size1 = arr1.size();
    uint32_t inv_count1 = 4950;
    uint32_t result1 = sorting::inversion::countInversion(arr1.data(), size1);
    assert(inv_count1 == result1);
        std::vector<int> arr2 = {22, 66, 75, 23, 11, 87, 2, 44, 98, 43};
    uint32_t size2 = arr2.size();
    uint32_t inv_count2 = 20;
    uint32_t result2 = sorting::inversion::countInversion(arr2.data(), size2);
    assert(inv_count2 == result2);
        std::vector<double> arr3 = {33.1, 45.2, 65.4, 76.5, 1.0,
                                2.9,  5.4,  7.7,  88.9, 12.4};
    uint32_t size3 = arr3.size();
    uint32_t inv_count3 = 21;
    uint32_t result3 = sorting::inversion::countInversion(arr3.data(), size3);
    assert(inv_count3 == result3);
        std::vector<char> arr4 = {'a', 'b', 'c', 'd', 'e'};
    uint32_t size4 = arr4.size();
    uint32_t inv_count4 = 0;
    uint32_t result4 = sorting::inversion::countInversion(arr4.data(), size4);
    assert(inv_count4 == result4);
}



int main() {
    test();          return 0;
}
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <iostream>

void radixsort(int a[], int n) {
    int count[10];
    int* output = new int[n];
    memset(output, 0, n * sizeof(*output));
    memset(count, 0, sizeof(count));
    int max = 0;
    for (int i = 0; i < n; ++i) {
        if (a[i] > max) {
            max = a[i];
        }
    }
    int maxdigits = 0;
    while (max) {
        maxdigits++;
        max /= 10;
    }
    for (int j = 0; j < maxdigits; j++) {
        for (int i = 0; i < n; i++) {
            int t = std::pow(10, j);
            count[(a[i] % (10 * t)) / t]++;
        }
        int k = 0;
        for (int p = 0; p < 10; p++) {
            for (int i = 0; i < n; i++) {
                int t = std::pow(10, j);
                if ((a[i] % (10 * t)) / t == p) {
                    output[k] = a[i];
                    k++;
                }
            }
        }
        memset(count, 0, sizeof(count));
        for (int i = 0; i < n; ++i) {
            a[i] = output[i];
        }
    }
    delete[] output;
}

void print(int a[], int n) {
    for (int i = 0; i < n; ++i) {
        std::cout << a[i] << " ";
    }
    std::cout << std::endl;
}

int main(int argc, char const* argv[]) {
    int a[] = {170, 45, 75, 90, 802, 24, 2, 66};
    int n = sizeof(a) / sizeof(a[0]);
    radixsort(a, n);
    print(a, n);
    return 0;
}
#include <cstdio>
#include <cstring>

#define BEAD(i, j) beads[i * max + j]

void beadSort(int *a, int len) {
        int max = a[0];
    for (int i = 1; i < len; i++)
        if (a[i] > max)
            max = a[i];

        unsigned char *beads = new unsigned char[max * len];
    memset(beads, 0, static_cast<size_t>(max) * len);

        for (int i = 0; i < len; i++)
        for (int j = 0; j < a[i]; j++) BEAD(i, j) = 1;

    for (int j = 0; j < max; j++) {
                int sum = 0;
        for (int i = 0; i < len; i++) {
            sum += BEAD(i, j);
            BEAD(i, j) = 0;
        }

                for (int i = len - sum; i < len; i++) BEAD(i, j) = 1;
    }

        for (int i = 0; i < len; i++) {
        int j;
        for (j = 0; j < max && BEAD(i, j); j++) {
        }

        a[i] = j;
    }
    delete[] beads;
}

int main() {
    int a[] = {5, 3, 1, 7, 4, 1, 1, 20};
    int len = sizeof(a) / sizeof(a[0]);

    beadSort(a, len);

    for (int i = 0; i < len; i++) printf("%d ", a[i]);

    return 0;
}


#include <algorithm>  #include <array>      #include <cassert>    #include <iostream>   

namespace sorting {


template <std::size_t N>
std::array<int, N> pigeonSort(std::array<int, N> arr) {
        auto min = std::min_element(std::begin(arr), std::end(arr));
    auto max = std::max_element(std::begin(arr), std::end(arr));

        int range = *max - *min + 1;
    int *hole = new int[range]();

        for (int i = 0; i < N; i++) {
        hole[arr[i] - *min] = arr[i];
    }

        int count = 0;
    for (int i = 0; i < range; i++) {
        while (hole[i] != '\0') {
            arr[count] = hole[i];
            hole[i] = {};
            count++;
        }
    }
    delete[] hole;

    return arr;
}
}  

static void test_1() {
    const int n = 7;
    std::array<int, n> test_array = {8, 3, 2, 7, 4, 6, 8};

    test_array = sorting::pigeonSort<n>(test_array);

    assert(std::is_sorted(std::begin(test_array), std::end(test_array)));

        for (int i = 0; i < n; i++) {
        std::cout << test_array.at(i) << " ";
    }
    std::cout << "\nPassed\n";
}


static void test_2() {
    const int n = 10;
    std::array<int, n> test_array = {802, 630, 20,  745, 52,
                                     300, 612, 932, 78,  187};

    test_array = sorting::pigeonSort<n>(test_array);

    assert(std::is_sorted(std::begin(test_array), std::end(test_array)));

        for (int i = 0; i < n; i++) {
        std::cout << test_array.at(i) << " ";
    }
    std::cout << "\nPassed\n";
}


static void test_3() {
    const int n = 4;
    std::array<int, n> test_array = {11, 13, 12, 14};

    test_array = sorting::pigeonSort<n>(test_array);

    assert(std::is_sorted(std::begin(test_array), std::end(test_array)));

        for (int i = 0; i < n; i++) {
        std::cout << test_array.at(i) << " ";
    }
    std::cout << "\nPassed\n";
}


int main() {
    test_1();
    test_2();
    test_3();

    return 0;
}
#include <iostream>
using namespace std;

int Max(int Arr[], int N) {
    int max = Arr[0];
    for (int i = 1; i < N; i++)
        if (Arr[i] > max)
            max = Arr[i];
    return max;
}

int Min(int Arr[], int N) {
    int min = Arr[0];
    for (int i = 1; i < N; i++)
        if (Arr[i] < min)
            min = Arr[i];
    return min;
}

void Print(int Arr[], int N) {
    for (int i = 0; i < N; i++) cout << Arr[i] << ", ";
}

int *Counting_Sort(int Arr[], int N) {
    int max = Max(Arr, N);
    int min = Min(Arr, N);
    int *Sorted_Arr = new int[N];

    int *Count = new int[max - min + 1];

    for (int i = 0; i < N; i++) Count[Arr[i] - min]++;

    for (int i = 1; i < (max - min + 1); i++) Count[i] += Count[i - 1];

    for (int i = N - 1; i >= 0; i--) {
        Sorted_Arr[Count[Arr[i] - min] - 1] = Arr[i];
        Count[Arr[i] - min]--;
    }

    return Sorted_Arr;
}

int main() {
    int Arr[] = {47, 65, 20, 66, 25, 53, 64, 69, 72, 22,
                 74, 25, 53, 15, 42, 36, 4,  69, 86, 19},
        N = 20;
    int *Sorted_Arr;

    cout << "\n\tOrignal Array = ";
    Print(Arr, N);
    Sorted_Arr = Counting_Sort(Arr, N);
    cout << "\n\t Sorted Array = ";
    Print(Sorted_Arr, N);
    cout << endl;

    return 0;
}

#include <iostream>


void merge(int *arr, int l, int m, int r) {
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    int *L = new int[n1], *R = new int[n2];

    for (i = 0; i < n1; i++) L[i] = arr[l + i];
    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];

    i = 0;
    j = 0;
    k = l;
    while (i < n1 || j < n2) {
        if (j >= n2 || (i < n1 && L[i] <= R[j])) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    delete[] L;
    delete[] R;
}


void mergeSort(int *arr, int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}


void show(int *arr, int size) {
    for (int i = 0; i < size; i++) std::cout << arr[i] << " ";
    std::cout << "\n";
}


int main() {
    int size;
    std::cout << "Enter the number of elements : ";
    std::cin >> size;
    int *arr = new int[size];
    std::cout << "Enter the unsorted elements : ";
    for (int i = 0; i < size; ++i) {
        std::cin >> arr[i];
    }
    mergeSort(arr, 0, size - 1);
    std::cout << "Sorted array : ";
    show(arr, size);
    delete[] arr;
    return 0;
}


#include <iostream>

void SlowSort(int a[], int i, int j) {
    if (i >= j)
        return;
    int m = i + (j - i) / 2;                                    int temp;
    SlowSort(a, i, m);
    SlowSort(a, m + 1, j);
    if (a[j] < a[m]) {
        temp = a[j];          a[j] = a[m];
        a[m] = temp;
    }
    SlowSort(a, i, j - 1);
}


int main() {
    int size;
    std::cout << "\nEnter the number of elements : ";

    std::cin >> size;

    int *arr = new int[size];

    std::cout << "\nEnter the unsorted elements : ";

    for (int i = 0; i < size; ++i) {
        std::cout << "\n";
        std::cin >> arr[i];
    }

    SlowSort(arr, 0, size);

    std::cout << "Sorted array\n";

    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }

    delete[] arr;
    return 0;
}
#include <algorithm>
#include <iostream>
#include <vector>

void bucketSort(float arr[], int n) {
        std::vector<float> *b = new std::vector<float>[n];

        for (int i = 0; i < n; i++) {
        int bi = n * arr[i];          b[bi].push_back(arr[i]);
    }

        for (int i = 0; i < n; i++) std::sort(b[i].begin(), b[i].end());

        int index = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < b[i].size(); j++) arr[index++] = b[i][j];
    delete[] b;
}

int main() {
    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};
    int n = sizeof(arr) / sizeof(arr[0]);
    bucketSort(arr, n);

    std::cout << "Sorted array is \n";
    for (int i = 0; i < n; i++) std::cout << arr[i] << " ";
    return 0;
}


#include <algorithm>
#include <cassert>
#include <iostream>


int FindNextGap(int gap) {
    gap = (gap * 10) / 13;

    return std::max(1, gap);
}


void CombSort(int *arr, int l, int r) {
    
    int gap = r;

        bool swapped = true;

        while (gap != 1 || swapped) {
                gap = FindNextGap(gap);

        swapped = false;

                for (int i = l; i < r - gap; ++i) {
            if (arr[i] > arr[i + gap]) {
                std::swap(arr[i], arr[i + gap]);
                swapped = true;
            }
        }
    }
}

void tests() {
        int arr1[10] = {34, 56, 6, 23, 76, 34, 76, 343, 4, 76};
    CombSort(arr1, 0, 10);
    assert(std::is_sorted(arr1, arr1 + 10));
    std::cout << "Test 1 passed\n";

        int arr2[8] = {-6, 56, -45, 56, 0, -1, 8, 8};
    CombSort(arr2, 0, 8);
    assert(std::is_sorted(arr2, arr2 + 8));
    std::cout << "Test 2 Passed\n";
}


int main() {
        tests();

        int n;
    std::cin >> n;
    int *arr = new int[n];
    for (int i = 0; i < n; ++i) std::cin >> arr[i];
    CombSort(arr, 0, n);
    for (int i = 0; i < n; ++i) std::cout << arr[i] << ' ';
    delete[] arr;
    return 0;
}

#include <cassert>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <utility>  #include <vector>


template <class T>
void show_data(T *arr, size_t LEN) {
    size_t i;

    for (i = 0; i < LEN; i++) {
        std::cout << arr[i] << ", ";
    }
    std::cout << std::endl;
}


template <typename T, size_t N>
void show_data(T (&arr)[N]) {
    show_data(arr, N);
}


namespace sorting {

template <typename T>
void shell_sort(T *arr, size_t LEN) {
    const unsigned int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};
    const unsigned int gap_len = 8;
    size_t i, j, g;

    for (g = 0; g < gap_len; g++) {
        unsigned int gap = gaps[g];
        for (i = gap; i < LEN; i++) {
            T tmp = arr[i];

            for (j = i; j >= gap && (arr[j - gap] - tmp) > 0; j -= gap) {
                arr[j] = arr[j - gap];
            }

            arr[j] = tmp;
        }
    }
}


template <typename T, size_t N>
void shell_sort(T (&arr)[N]) {
    shell_sort(arr, N);
}


template <typename T>
void shell_sort(std::vector<T> *arr) {
    shell_sort(arr->data(), arr->size());
}

}  
using sorting::shell_sort;


template <typename T>
int compare(const void *a, const void *b) {
    T arg1 = *static_cast<const T *>(a);
    T arg2 = *static_cast<const T *>(b);

    if (arg1 < arg2)
        return -1;
    if (arg1 > arg2)
        return 1;
    return 0;

        }


void test_int(const int NUM_DATA) {
        int *data = new int[NUM_DATA];
    int *data2 = new int[NUM_DATA];
        int range = 1800;

    for (int i = 0; i < NUM_DATA; i++)
        data[i] = data2[i] = (std::rand() % range) - (range >> 1);

    std::clock_t start = std::clock();
    shell_sort(data, NUM_DATA);
    std::clock_t end = std::clock();
    double elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;
    std::cout << "Time spent sorting using shell_sort2: " << elapsed_time
              << "s\n";

    start = std::clock();
    std::qsort(data2, NUM_DATA, sizeof(data2[0]), compare<int>);
    end = std::clock();

    elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;
    std::cout << "Time spent sorting using std::qsort: " << elapsed_time
              << "s\n";

    for (int i = 0; i < NUM_DATA; i++) {
        assert(data[i] == data2[i]);                                            }

    delete[] data;
    delete[] data2;
}


void test_f(const int NUM_DATA) {
        float *data = new float[NUM_DATA];
    float *data2 = new float[NUM_DATA];
        int range = 1000;

    for (int i = 0; i < NUM_DATA; i++) {
        data[i] = data2[i] = ((std::rand() % range) - (range >> 1)) / 100.;
    }

    std::clock_t start = std::clock();
    shell_sort(data, NUM_DATA);
    std::clock_t end = std::clock();
    double elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;
    std::cout << "Time spent sorting using shell_sort2: " << elapsed_time
              << "s\n";

    start = std::clock();
    std::qsort(data2, NUM_DATA, sizeof(data2[0]), compare<float>);
    end = std::clock();

    elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;
    std::cout << "Time spent sorting using std::qsort: " << elapsed_time
              << "s\n";

    for (int i = 0; i < NUM_DATA; i++) {
        assert(data[i] == data2[i]);                                            }

    delete[] data;
    delete[] data2;
}


int main(int argc, char *argv[]) {
        std::srand(std::time(NULL));

    test_int(100);      std::cout << "Test 1 - 100 int values - passed. \n";
    test_int(1000);      std::cout << "Test 2 - 1000 int values - passed.\n";
    test_int(10000);      std::cout << "Test 3 - 10000 int values - passed.\n";

    test_f(100);      std::cout << "Test 1 - 100 float values - passed. \n";
    test_f(1000);      std::cout << "Test 2 - 1000 float values - passed.\n";
    test_f(10000);      std::cout << "Test 3 - 10000 float values - passed.\n";

    int i, NUM_DATA;

    if (argc == 2)
        NUM_DATA = atoi(argv[1]);
    else
        NUM_DATA = 200;

        int *data = new int[NUM_DATA];
        int range = 1800;

    std::srand(time(NULL));
    for (i = 0; i < NUM_DATA; i++) {
                data[i] = (std::rand() % range) - (range >> 1);
    }

    std::cout << "Unsorted original data: " << std::endl;
    show_data(data, NUM_DATA);
    std::clock_t start = std::clock();
    shell_sort(data, NUM_DATA);      std::clock_t end = std::clock();

    std::cout << std::endl
              << "Data Sorted using custom implementation: " << std::endl;
    show_data(data, NUM_DATA);

    double elapsed_time = (end - start) * 1.f / CLOCKS_PER_SEC;
    std::cout << "Time spent sorting: " << elapsed_time << "s\n" << std::endl;

    delete[] data;
    return 0;
}

#include <algorithm>
#include <array>
#include <cassert>
#include <ctime>
#include <iostream>
#include <memory>


namespace sorting {

namespace merge_insertion {


template <typename T, size_t N>
static void InsertionSort(std::array<T, N> *A, size_t start, size_t end) {
    size_t i = 0, j = 0;
    T *ptr = A->data();

    for (i = start; i < end; i++) {
        T temp = ptr[i];
        j = i;
        while (j > start && temp < ptr[j - 1]) {
            ptr[j] = ptr[j - 1];
            j--;
        }
                        
        ptr[j] = temp;
    }
}


template <typename T, size_t N>
static void merge(std::array<T, N> *array, size_t min, size_t max, size_t mid) {
    size_t firstIndex = min;
    size_t secondIndex = mid + 1;

    auto ptr = array->data();
    std::array<T, N + 1> tempArray{0};

        for (size_t index = min; index <= max; index++) {
                if (firstIndex <= mid &&
            (secondIndex > max || ptr[firstIndex] <= ptr[secondIndex])) {
            tempArray[index] = ptr[firstIndex];
            firstIndex++;
        } else {
            tempArray[index] = ptr[secondIndex];
            secondIndex++;
        }
    }

        memcpy(ptr + min, tempArray.data() + min, (max - min) * sizeof(T));
        }


template <typename T, size_t N>
void mergeSort(std::array<T, N> *array, size_t min, size_t max,
               size_t threshold) {
        if ((max - min) <= threshold) {
        InsertionSort(array, min, max);
    } else {
                size_t mid = (max + min) >> 1;

                mergeSort(array, min, mid, threshold);
        mergeSort(array, mid, max, threshold);

                merge(array, min, max, mid);
    }
}

}  }  

static void test() {
    constexpr size_t size = 30;
    std::array<int, size> array{0};
        for (int i = 0; i < size; i++) {
        array[i] = std::rand() % 100 - 50;
        std::cout << array[i] << " ";
    }
    std::cout << std::endl;

    sorting::merge_insertion::InsertionSort(&array, 0, size);
    
        for (int i = 0; i < size; ++i) {
        std::cout << array[i] << " ";
    }
    std::cout << std::endl;

    assert(std::is_sorted(std::begin(array), std::end(array)));
    std::cout << "Test passed\n";
}


int main() {
    std::srand(std::time(nullptr));
    test();
    return 0;
}


#include <algorithm>  #include <array>      #include <cassert>    #include <iostream>   

namespace sorting {

template <typename T>
void gnomeSort(T *arr, int size) {
        if (size <= 1) {
        return;
    }

    int index = 0;      while (index < size) {
                if ((index == 0) || (arr[index] >= arr[index - 1])) {
            index++;
        } else {
            std::swap(arr[index], arr[index - 1]);              index--;
        }
    }
}


template <typename T, size_t size>
std::array<T, size> gnomeSort(std::array<T, size> arr) {
        if (size <= 1) {
        return arr;
    }

    int index = 0;      while (index < size) {
                if ((index == 0) || (arr[index] >= arr[index - 1])) {
            index++;
        } else {
            std::swap(arr[index], arr[index - 1]);              index--;
        }
    }
    return arr;
}
}  

static void test() {
        std::cout << "Test 1 - as a C-array...";
    const int size = 6;
    std::array<int, size> arr = {-22, 100, 150, 35, -10, 99};
    sorting::gnomeSort(arr.data(),
                       size);      assert(std::is_sorted(std::begin(arr), std::end(arr)));
    std::cout << " Passed\n";
    for (int i = 0; i < size; i++) {
        std::cout << arr[i] << ", ";
    }
    std::cout << std::endl;

        std::cout << "\nTest 2 - as a std::array...";
    std::array<double, size> double_arr = {-100.2, 10.2, 20.0, 9.0, 7.5, 7.2};
    std::array<double, size> sorted_arr = sorting::gnomeSort(double_arr);
    assert(std::is_sorted(std::begin(sorted_arr), std::end(sorted_arr)));
    std::cout << " Passed\n";
    for (int i = 0; i < size; i++) {
        std::cout << double_arr[i] << ", ";
    }
    std::cout << std::endl;

        std::cout << "\nTest 3 - 200 random numbers as a std::array...";
    const int size2 = 200;
    std::array<float, size2> rand_arr{};

    for (auto &a : rand_arr) {
                a = float(std::rand() % 1000 - 500) / 100.f;
    }

    std::array<float, size2> float_arr = sorting::gnomeSort(rand_arr);
    assert(std::is_sorted(std::begin(float_arr), std::end(float_arr)));
    std::cout << " Passed\n";
        std::cout << std::endl;
}


int main() {
    test();
    return 0;
}
#include <iostream>
#include <vector>

using namespace std;

void oddEven(vector<int> &arr, int size) {
    bool sorted = false;
    while (!sorted) {
        sorted = true;
        for (int i = 1; i < size - 1; i += 2)          {
            if (arr[i] > arr[i + 1]) {
                swap(arr[i], arr[i + 1]);
                sorted = false;
            }
        }

        for (int i = 0; i < size - 1; i += 2)          {
            if (arr[i] > arr[i + 1]) {
                swap(arr[i], arr[i + 1]);
                sorted = false;
            }
        }
    }
}

void show(vector<int> A, int size) {
    int i;
    for (i = 0; i < size; i++) cout << A[i] << "\n";
}

int main() {
    int size, temp;
    cout << "\nEnter the number of elements : ";
    cin >> size;

    vector<int> arr;

    cout << "\nEnter the unsorted elements : \n";

    for (int i = 0; i < size; ++i) {
        cin >> temp;
        arr.push_back(temp);
    }

    oddEven(arr, size);

    cout << "Sorted array\n";
    show(arr, size);
    return 0;
}



#include <algorithm>
#include <iostream>


void compAndSwap(int a[], int i, int j, int dir) {
    if (dir == (a[i] > a[j]))
        std::swap(a[i], a[j]);
}


void bitonicMerge(int a[], int low, int cnt, int dir) {
    if (cnt > 1) {
        int k = cnt / 2;
        for (int i = low; i < low + k; i++) compAndSwap(a, i, i + k, dir);
        bitonicMerge(a, low, k, dir);
        bitonicMerge(a, low + k, k, dir);
    }
}

void bitonicSort(int a[], int low, int cnt, int dir) {
    if (cnt > 1) {
        int k = cnt / 2;

                bitonicSort(a, low, k, 1);

                bitonicSort(a, low + k, k, 0);

                        bitonicMerge(a, low, cnt, dir);
    }
}


void sort(int a[], int N, int up) { bitonicSort(a, 0, N, up); }

int main() {
    int a[] = {3, 7, 4, 8, 6, 2, 1, 5};
    int N = sizeof(a) / sizeof(a[0]);

    int up = 1;      sort(a, N, up);

    std::cout << "Sorted array: \n";
    for (int i = 0; i < N; i++) std::cout << a[i] << " ";
    return 0;
}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     

namespace sorting {

namespace dnf_sort {

template <typename T>
std::vector<T> dnfSort(const std::vector<T> &in_arr) {
    std::vector<T> arr(in_arr);
    uint64_t lo = 0;
    uint64_t hi = arr.size() - 1;
    uint64_t mid = 0;

            while (mid <= hi) {
        switch (arr[mid]) {
                        case 0:
                std::swap(arr[lo++], arr[mid++]);
                break;

                        case 1:
                mid++;
                break;

                        case 2:
                std::swap(arr[mid], arr[hi--]);
                break;
        }
    }
    return arr;
}
}  }  

static void test() {
            std::vector<uint64_t> array1 = {0, 1, 1, 2};
    std::cout << "Test 1... ";
    std::vector<uint64_t> arr1 = sorting::dnf_sort::dnfSort(array1);
    assert(std::is_sorted(std::begin(arr1), std::end(arr1)));
    std::cout << "passed" << std::endl;
            std::vector<uint64_t> array2 = {1, 0, 0, 1, 1, 0, 2, 1};
    std::cout << "Test 2... ";
    std::vector<uint64_t> arr2 = sorting::dnf_sort::dnfSort(array2);
    assert(std::is_sorted(std::begin(arr2), std::end(arr2)));
    std::cout << "passed" << std::endl;
            std::vector<uint64_t> array3 = {1, 1, 0, 0, 1, 2, 2, 0, 2, 1};
    std::cout << "Test 3... ";
    std::vector<uint64_t> arr3 = sorting::dnf_sort::dnfSort(array3);
    assert(std::is_sorted(std::begin(arr3), std::end(arr3)));
    std::cout << "passed" << std::endl;
            std::vector<uint64_t> array4 = {2, 2, 2, 0, 0, 1, 1};
    std::cout << "Test 4... ";
    std::vector<uint64_t> arr4 = sorting::dnf_sort::dnfSort(array4);
    assert(std::is_sorted(std::begin(arr4), std::end(arr4)));
    std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}


#include <cassert>   #include <iostream>  #include <vector>    #include <array>     #include <algorithm> 

namespace sorting {


template <typename T>
void recursive_bubble_sort(std::vector<T> *nums, uint64_t n) {
    if (n == 1) {          return;
    }

    for (uint64_t i = 0; i < n - 1; i++) {                  if ((*nums)[i] > (*nums)[i + 1]) {
            std::swap((*nums)[i], (*nums)[i + 1]);
        }
    }

        recursive_bubble_sort(nums, n - 1);
}
}  

static void test() {
        std::cout << "1st test using `int`\n";
    const uint64_t size = 6;
    std::vector<int64_t> arr;
        arr.push_back(22);
    arr.push_back(46);
    arr.push_back(94);
    arr.push_back(12);
    arr.push_back(37);
    arr.push_back(63);
    
    sorting::recursive_bubble_sort(&arr, size);
    assert(std::is_sorted(std::begin(arr), std::end(arr)));
    std::cout << " 1st test passed!\n";
        for (uint64_t i = 0; i < size; i++) {
        std::cout << arr[i] << ", ";
    }
    std::cout << std::endl;

        std::cout << "2nd test using doubles\n";
    std::vector<double> double_arr;

        double_arr.push_back(20.4);
    double_arr.push_back(62.7);
    double_arr.push_back(12.2);
    double_arr.push_back(43.6);
    double_arr.push_back(74.1);
    double_arr.push_back(57.9);
    
    sorting::recursive_bubble_sort(&double_arr, size);
    assert(std::is_sorted(std::begin(double_arr), std::end(double_arr)));
    std::cout << " 2nd test passed!\n";
        for (uint64_t i = 0; i < size; i++) {
        std::cout << double_arr[i] << ", ";
    }
    std::cout << std::endl;

}


int main() { 
    test();      return 0;
}
#include <iostream>

using namespace std;

void countSort(string arr) {
    string output;

    int count[256], i;
    for (int i = 0; i < 256; i++) count[i] = 0;

    for (i = 0; arr[i]; ++i) ++count[arr[i]];

    for (i = 1; i < 256; ++i) count[i] += count[i - 1];

    for (i = 0; arr[i]; ++i) {
        output[count[arr[i]] - 1] = arr[i];
        --count[arr[i]];
    }

    for (i = 0; arr[i]; ++i) arr[i] = output[i];

    cout << "Sorted character array is " << arr;
}

int main() {
    string arr;
    cin >> arr;

    countSort(arr);

    return 0;
}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     

namespace sorting {

namespace pancake_sort {

template <typename T>
void reverse(std::vector<T> &arr, int start, int end) {
    T temp;      while (start <= end) {
        temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }
}

template <typename T>
int pancakeSort(std::vector<T> &arr, int size) {
    for (int i = size; i > 1; --i) {
        int max_index = 0, j = 0;          T max_value = 0;
        for (j = 0; j < i; j++) {
            if (arr[j] >= max_value) {
                max_value = arr[j];
                max_index = j;
            }
        }
        if (max_index != i - 1)          {
            reverse(arr, 0, max_index);
            reverse(arr, 0, i - 1);
        }
    }
    return 0;
}
}  }  

static void test() {
        const int size1 = 7;
    std::cout << "\nTest 1- as std::vector<int>...";
    std::vector<int> arr1 = {23, 10, 20, 11, 12, 6, 7};
    sorting::pancake_sort::pancakeSort(arr1, size1);
    assert(std::is_sorted(arr1.begin(), arr1.end()));
    std::cout << "Passed\n";
    for (int i = 0; i < size1; i++) {
        std::cout << arr1[i] << " ,";
    }
    std::cout << std::endl;

        const int size2 = 8;
    std::cout << "\nTest 2- as std::vector<double>...";
    std::vector<double> arr2 = {23.56, 10.62, 200.78, 111.484,
                                3.9,   1.2,   61.77,  79.6};
    sorting::pancake_sort::pancakeSort(arr2, size2);
    assert(std::is_sorted(arr2.begin(), arr2.end()));
    std::cout << "Passed\n";
    for (int i = 0; i < size2; i++) {
        std::cout << arr2[i] << ", ";
    }
    std::cout << std::endl;

        const int size3 = 7;
    std::cout << "\nTest 3- as std::vector<float>...";
    std::vector<float> arr3 = {6.56, 12.62, 200.78, 768.484, 19.27, 68.87, 9.6};
    sorting::pancake_sort::pancakeSort(arr3, size3);
    assert(std::is_sorted(arr3.begin(), arr3.end()));
    std::cout << "Passed\n";
    for (int i = 0; i < size3; i++) {
        std::cout << arr3[i] << ", ";
    }
    std::cout << std::endl;
}

int main() {
    test();
    return 0;
}
#include <algorithm>
#include <iostream>

void librarySort(int *index, int n) {
    int lib_size, index_pos,
        *gaps,                *library[2];  
    bool target_lib, *numbered;

    for (int i = 0; i < 2; i++) library[i] = new int[n];

    gaps = new int[n + 1];
    numbered = new bool[n + 1];

    lib_size = 1;
    index_pos = 1;
    target_lib = 0;
    library[target_lib][0] = index[0];

    while (index_pos < n) {
                int insert = std::distance(
            library[target_lib],
            std::lower_bound(library[target_lib],
                             library[target_lib] + lib_size, index[index_pos]));

        
        if (numbered[insert] == true) {
            int prov_size = 0, next_target_lib = !target_lib;

            
            for (int i = 0; i <= n; i++) {
                if (numbered[i] == true) {
                    library[next_target_lib][prov_size] = gaps[i];
                    prov_size++;
                    numbered[i] = false;
                }

                if (i <= lib_size) {
                    library[next_target_lib][prov_size] =
                        library[target_lib][i];
                    prov_size++;
                }
            }

            target_lib = next_target_lib;
            lib_size = prov_size - 1;
        } else {
            numbered[insert] = true;
            gaps[insert] = index[index_pos];
            index_pos++;
        }
    }

    int index_pos_for_output = 0;
    for (int i = 0; index_pos_for_output < n; i++) {
        if (numbered[i] == true) {
                        index[index_pos_for_output] = gaps[i];
            index_pos_for_output++;
        }

        if (i < lib_size) {
                        index[index_pos_for_output] = library[target_lib][i];
            index_pos_for_output++;
        }
    }
}

int main() {
        int index_ex[] = {-6, 5, 9, 1, 9, 1, 0, 1, -8, 4, -12};
    int n_ex = sizeof(index_ex) / sizeof(index_ex[0]);

    librarySort(index_ex, n_ex);
    std::cout << "sorted array :" << std::endl;
    for (int i = 0; i < n_ex; i++) std::cout << index_ex[i] << " ";
    std::cout << std::endl;


}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     

namespace sorting {


template <class T>
int64_t binary_search(std::vector<T> &arr, T val, int64_t low, int64_t high) {
    if (high <= low) {
        return (val > arr[low]) ? (low + 1) : low;
    }
    int64_t mid = low + (high - low) / 2;
    if (arr[mid] > val) {
        return binary_search(arr, val, low, mid - 1);
    } else if (arr[mid] < val) {
        return binary_search(arr, val, mid + 1, high);
    } else {
        return mid + 1;
    }
}


template <typename T>
void insertionSort_binsrch(std::vector<T> &arr) {
    int64_t n = arr.size();

    for (int64_t i = 1; i < n; i++) {
        T key = arr[i];
        int64_t j = i - 1;
        int64_t loc = sorting::binary_search(arr, key, 0, j);
        while (j >= loc) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
}  

static void test() {

    std::vector<int64_t> arr1({5, -3, -1, -2, 7});
    std::cout << "1st test... ";
    sorting::insertionSort_binsrch(arr1);
    assert(std::is_sorted(std::begin(arr1), std::end(arr1)));
    std::cout << "passed" << std::endl;

   
    std::vector<int64_t> arr2({12, 26, 15, 91, 32, 54, 41});
    std::cout << "2nd test... ";
    sorting::insertionSort_binsrch(arr2);
    assert(std::is_sorted(std::begin(arr2), std::end(arr2)));
    std::cout << "passed" << std::endl;


    std::vector<float> arr3({7.1, -2.5, -4.0, -2.1, 5.7});
    std::cout << "3rd test... ";
    sorting::insertionSort_binsrch(arr3);
    assert(std::is_sorted(std::begin(arr3), std::end(arr3)));
    std::cout << "passed" << std::endl;

   
    std::vector<float> arr4({12.8, -3.7, -20.7, -7.1, 2.2});
    std::cout << "4th test... ";
    sorting::insertionSort_binsrch(arr4);
    assert(std::is_sorted(std::begin(arr4), std::end(arr4)));
    std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}

#include <algorithm>
#include <iostream>
#include <vector>


void CocktailSelectionSort(std::vector<int> *vec, int low, int high) {
    while (low <= high) {
        int minimum = (*vec)[low];
        int minimumindex = low;
        int maximum = (*vec)[high];
        int maximumindex = high;

        for (int i = low; i <= high; i++) {
            if ((*vec)[i] >= maximum) {
                maximum = (*vec)[i];
                maximumindex = i;
            }
            if ((*vec)[i] <= minimum) {
                minimum = (*vec)[i];
                minimumindex = i;
            }
        }
        if (low != maximumindex || high != minimumindex) {
            std::swap((*vec)[low], (*vec)[minimumindex]);
            std::swap((*vec)[high], (*vec)[maximumindex]);
        } else {
            std::swap((*vec)[low], (*vec)[high]);
        }

        low++;
        high--;
    }
}


void CocktailSelectionSort_v2(std::vector<int> *vec, int low, int high) {
    if (low >= high)
        return;

    int minimum = (*vec)[low];
    int minimumindex = low;
    int maximum = (*vec)[high];
    int maximumindex = high;

    for (int i = low; i <= high; i++) {
        if ((*vec)[i] >= maximum) {
            maximum = (*vec)[i];
            maximumindex = i;
        }
        if ((*vec)[i] <= minimum) {
            minimum = (*vec)[i];
            minimumindex = i;
        }
    }
    if (low != maximumindex || high != minimumindex) {
        std::swap((*vec)[low], (*vec)[minimumindex]);
        std::swap((*vec)[high], (*vec)[maximumindex]);
    } else {
        std::swap((*vec)[low], (*vec)[high]);
    }

    CocktailSelectionSort(vec, low + 1, high - 1);
}


int main() {
    int n;
    std::cout << "Enter number of elements\n";
    std::cin >> n;
    std::vector<int> v(n);
    std::cout << "Enter all the elements\n";
    for (int i = 0; i < n; ++i) {
        std::cin >> v[i];
    }

    int method;
    std::cout << "Enter method: \n\t0: iterative\n\t1: recursive:\t";
    std::cin >> method;

    if (method == 0) {
        CocktailSelectionSort(&v, 0, n - 1);
    } else if (method == 1) {
        CocktailSelectionSort_v2(&v, 0, n - 1);
    } else {
        std::cerr << "Unknown method" << std::endl;
        return -1;
    }
    std::cout << "Sorted elements are\n";
    for (int i = 0; i < n; ++i) {
        std::cout << v[i] << " ";
    }

    return 0;
}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     

namespace sorting {

namespace selection_sort_recursive {

template <typename T>
uint64_t findMinIndex(const std::vector<T> &in_arr,
                      uint64_t current_position = 0) {
    if (current_position + 1 == in_arr.size()) {
        return current_position;
    }
    uint64_t answer = findMinIndex(in_arr, current_position + 1);
    if (in_arr[current_position] < in_arr[answer]) {
        answer = current_position;
    }
    return answer;
}


template <typename T>
void selectionSortRecursive(std::vector<T> &in_arr,
                            uint64_t current_position = 0) {
    if (current_position == in_arr.size()) {
        return;
    }
    uint64_t min_element_idx =
        selection_sort_recursive::findMinIndex(in_arr, current_position);
    if (min_element_idx != current_position) {
        std::swap(in_arr[min_element_idx], in_arr[current_position]);
    }
    selectionSortRecursive(in_arr, current_position + 1);
}
}  }  

static void test() {
            std::vector<uint64_t> array1 = {0, 1, 1, 2};
    std::cout << "1st test... ";
    sorting::selection_sort_recursive::selectionSortRecursive(array1);
    assert(std::is_sorted(std::begin(array1), std::end(array1)));
    std::cout << "passed" << std::endl;
            std::vector<uint64_t> array2 = {1, 0, 0, 1, 1, 0, 2, 1};
    std::cout << "2nd test... ";
    sorting::selection_sort_recursive::selectionSortRecursive(array2);
    assert(std::is_sorted(std::begin(array2), std::end(array2)));
    std::cout << "passed" << std::endl;
            std::vector<uint64_t> array3 = {1, 1, 0, 0, 1, 2, 2, 0, 2, 1};
    std::cout << "3rd test... ";
    sorting::selection_sort_recursive::selectionSortRecursive(array3);
    assert(std::is_sorted(std::begin(array3), std::end(array3)));
    std::cout << "passed" << std::endl;
            std::vector<uint64_t> array4 = {2, 2, 2, 0, 0, 1, 1};
    std::cout << "4th test... ";
    sorting::selection_sort_recursive::selectionSortRecursive(array4);
    assert(std::is_sorted(std::begin(array4), std::end(array4)));
    std::cout << "passed" << std::endl;
}


int main() {
    test();      return 0;
}

#include <iostream>
#include <list>


namespace sorting {
    
    namespace strand {
        
        template <typename T>
        std::list<T> strand_sort(std::list<T> lst) {
            if (lst.size() < 2) {                 return lst;             }
            std::list<T> result;             std::list<T> sorted;             while(!lst.empty())  {
                sorted.push_back(lst.front());                 lst.pop_front();                 for (auto it = lst.begin(); it != lst.end(); ) {                     if (sorted.back() <= *it) {                         sorted.push_back(*it);                         it = lst.erase(it);                     } else {
                        it++;                     }
                }
                result.merge(sorted);             }
            return result;         }
    }  }  

static void test() {
    std::list<int> lst = { -333, 525, 1, 0, 94, 52, 33 };

    std::cout << "Before: ";
    for(auto item: lst) {
        std::cout << item << " ";
    }

    lst = sorting::strand::strand_sort(lst); 
    std::cout << "\nAfter: ";
    for(auto item: lst) {
        std::cout << item << " ";
    }
}


int main() {
    test();
    return 0;
}


#include <iostream>
#include <vector>

int main() {
    int n;
    bool swap_check = true;
    std::cout << "Enter the amount of numbers to sort: ";
    std::cin >> n;
    std::vector<int> numbers;
    std::cout << "Enter " << n << " numbers: ";
    int num;

        for (int i = 0; i < n; i++) {
        std::cin >> num;
        numbers.push_back(num);
    }

        for (int i = 0; (i < n) && (swap_check); i++) {
        swap_check = false;
        for (int j = 0; j < n - 1 - i; j++) {
            if (numbers[j] > numbers[j + 1]) {
                swap_check = true;
                std::swap(numbers[j],
                          numbers[j + 1]);                                                                                                                                                  }
        }
    }

        std::cout << "\nSorted Array : ";
    for (int i = 0; i < numbers.size(); i++) {
        if (i != numbers.size() - 1) {
            std::cout << numbers[i] << ", ";
        } else {
            std::cout << numbers[i] << std::endl;
        }
    }
    return 0;
}


#include <algorithm>  #include <array>      #include <cassert>    #include <ctime>      #include <iostream>   #include <tuple>      

namespace sorting {

namespace random_pivot_quick_sort {

template <size_t T>
void showArray(std::array<int64_t, T> arr) {
    for (int64_t i = 0; i < arr.size(); i++) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}


int64_t getRandomIndex(int64_t start, int64_t end) {
    srand(time(nullptr));      int64_t randomPivotIndex = start + rand() % (end - start + 1);
    return randomPivotIndex;
}


template <size_t size>
std::tuple<int64_t, std::array<int64_t, size>> partition(
    std::array<int64_t, size> arr, int64_t start, int64_t end) {
    int64_t pivot = arr[end];                                     int64_t pInd = start;

    for (int64_t i = start; i < end; i++) {
        if (arr[i] <= pivot) {
            std::swap(arr[i], arr[pInd]);                                                         pInd++;
        }
    }
    std::swap(arr[pInd],
              arr[end]);      return std::make_tuple(pInd, arr);
}


template <size_t size>
std::array<int64_t, size> quickSortRP(std::array<int64_t, size> arr,
                                      int64_t start, int64_t end) {
    if (start < end) {
        int64_t randomIndex = getRandomIndex(start, end);

                std::swap(arr[end], arr[randomIndex]);

        int64_t pivotIndex = 0;
                std::tie(pivotIndex, arr) = partition(arr, start, end);

                std::array<int64_t, arr.size()> rightSortingLeft =
            quickSortRP(arr, start, pivotIndex - 1);
        std::array<int64_t, arr.size()> full_sorted =
            quickSortRP(rightSortingLeft, pivotIndex + 1, end);
        arr = full_sorted;
    }
    return arr;
}


template <size_t size>
std::array<int64_t, size> generateUnsortedArray(int64_t from, int64_t to) {
    srand(time(nullptr));
    std::array<int64_t, size> unsortedArray{};
    assert(from < to);
    int64_t i = 0;
    while (i < size) {
        int64_t randomNum = from + rand() % (to - from + 1);
        if (randomNum) {
            unsortedArray[i] = randomNum;
            i++;
        }
    }
    return unsortedArray;
}

}  }  

class TestCases {
 private:
    
    template <typename T>
    void log(T msg) {
                std::cout << "[TESTS] : ---> " << msg << std::endl;
    }

 public:
    
    void runTests() {
        log("Running Tests...");

        testCase_1();
        testCase_2();
        testCase_3();

        log("Test Cases over!");
        std::cout << std::endl;
    }

    
    void testCase_1() {
        const int64_t inputSize = 1;
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");
        log("This is test case 1 for Random Pivot Quick Sort Algorithm : ");
        log("Description:");
        log("   EDGE CASE : Only contains one element");
        std::array<int64_t, inputSize> unsorted_arr{2};

        int64_t start = 0;
        int64_t end = unsorted_arr.size() - 1;  
        log("Running algorithm of data of length 50 ...");
        std::array<int64_t, unsorted_arr.size()> sorted_arr =
            sorting::random_pivot_quick_sort::quickSortRP(unsorted_arr, start,
                                                          end);
        log("Algorithm finished!");

        log("Checking assert expression...");
        assert(std::is_sorted(sorted_arr.begin(), sorted_arr.end()));
        log("Assertion check passed!");

        log("[PASS] : TEST CASE 1 PASS!");
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");
    }

    
    void testCase_2() {
        const int64_t inputSize = 500;
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");
        log("Description:");
        log("   BIG INPUT : Contains 500 elements and repeated elements");
        log("This is test case 2 for Random Pivot Quick Sort Algorithm : ");
        std::array<int64_t, inputSize> unsorted_arr =
            sorting::random_pivot_quick_sort::generateUnsortedArray<inputSize>(
                1, 10000);

        int64_t start = 0;
        int64_t end = unsorted_arr.size() - 1;  
        log("Running algorithm of data of length 500 ...");
        std::array<int64_t, unsorted_arr.size()> sorted_arr =
            sorting::random_pivot_quick_sort::quickSortRP(unsorted_arr, start,
                                                          end);
        log("Algorithm finished!");

        log("Checking assert expression...");
        assert(std::is_sorted(sorted_arr.begin(), sorted_arr.end()));
        log("Assertion check passed!");

        log("[PASS] : TEST CASE 2 PASS!");
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");
    }

    
    void testCase_3() {
        const int64_t inputSize = 1000;
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");
        log("This is test case 3 for Random Pivot Quick Sort Algorithm : ");
        log("Description:");
        log("   LARGE INPUT : Contains 1000 elements and repeated elements");
        std::array<int64_t, inputSize> unsorted_arr =
            sorting::random_pivot_quick_sort::generateUnsortedArray<inputSize>(
                1, 10000);

        int64_t start = 0;
        int64_t end = unsorted_arr.size() - 1;  
        log("Running algorithm...");
        std::array<int64_t, unsorted_arr.size()> sorted_arr =
            sorting::random_pivot_quick_sort::quickSortRP(unsorted_arr, start,
                                                          end);
        log("Algorithm finished!");

        log("Checking assert expression...");
        assert(std::is_sorted(sorted_arr.begin(), sorted_arr.end()));
        log("Assertion check passed!");

        log("[PASS] : TEST CASE 3 PASS!");
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            "~");
    }
};


static void test() {
    TestCases tc = TestCases();
    tc.runTests();
}


int main(int argc, char *argv[]) {
    test();  
    const int64_t inputSize = 10;
    std::array<int64_t, inputSize> unsorted_array =
        sorting::random_pivot_quick_sort::generateUnsortedArray<inputSize>(
            50, 1000);
    std::cout << "Unsorted array is : " << std::endl;
    sorting::random_pivot_quick_sort::showArray(unsorted_array);

    std::array<int64_t, inputSize> sorted_array =
        sorting::random_pivot_quick_sort::quickSortRP(
            unsorted_array, 0, unsorted_array.size() - 1);
    std::cout << "Sorted array is : " << std::endl;
    sorting::random_pivot_quick_sort::showArray(sorted_array);
    return 0;
}

#include <algorithm>
#include <iostream>


struct Point {
    int x;      int y;  };


struct SegmentIntersection {
    inline bool intersect(Point first_point, Point second_point,
                          Point third_point, Point forth_point) {
        int direction1 = direction(third_point, forth_point, first_point);
        int direction2 = direction(third_point, forth_point, second_point);
        int direction3 = direction(first_point, second_point, third_point);
        int direction4 = direction(first_point, second_point, forth_point);

        if ((direction1 < 0 || direction2 > 0) &&
            (direction3 < 0 || direction4 > 0))
            return true;

        else if (direction1 == 0 &&
                 on_segment(third_point, forth_point, first_point))
            return true;

        else if (direction2 == 0 &&
                 on_segment(third_point, forth_point, second_point))
            return true;

        else if (direction3 == 0 &&
                 on_segment(first_point, second_point, third_point))
            return true;

        else if (direction3 == 0 &&
                 on_segment(first_point, second_point, forth_point))
            return true;

        else
            return false;
    }

    
    inline int direction(Point first_point, Point second_point,
                         Point third_point) {
        return ((third_point.x - first_point.x) *
                (second_point.y - first_point.y)) -
               ((second_point.x - first_point.x) *
                (third_point.y - first_point.y));
    }

    
    inline bool on_segment(Point first_point, Point second_point,
                           Point third_point) {
        if (std::min(first_point.x, second_point.x) <= third_point.x &&
            third_point.x <= std::max(first_point.x, second_point.x) &&
            std::min(first_point.y, second_point.y) <= third_point.y &&
            third_point.y <= std::max(first_point.y, second_point.y))
            return true;

        else
            return false;
    }
};


int main() {
    SegmentIntersection segment;
    Point first_point, second_point, third_point, forth_point;

    std::cin >> first_point.x >> first_point.y;
    std::cin >> second_point.x >> second_point.y;
    std::cin >> third_point.x >> third_point.y;
    std::cin >> forth_point.x >> forth_point.y;

    printf("%d", segment.intersect(first_point, second_point, third_point,
                                   forth_point));
    std::cout << std::endl;
}

#include <cassert>   #include <iostream>  #include <vector>    
#include "./graham_scan_functions.hpp"  

static void test() {
    std::vector<geometry::grahamscan::Point> points = {
        {0, 3}, {1, 1}, {2, 2}, {4, 4}, {0, 0}, {1, 2}, {3, 1}, {3, 3}};
    std::vector<geometry::grahamscan::Point> expected_result = {
        {0, 3}, {4, 4}, {3, 1}, {0, 0}};
    std::vector<geometry::grahamscan::Point> derived_result;
    std::vector<geometry::grahamscan::Point> res;

    derived_result = geometry::grahamscan::convexHull(points, points.size());

    std::cout << "1st test: ";
    for (int i = 0; i < expected_result.size(); i++) {
        assert(derived_result[i].x == expected_result[i].x);
        assert(derived_result[i].y == expected_result[i].y);
    }
    std::cout << "passed!" << std::endl;
}


int main() {
    test();      return 0;
}


#include <vector>
#include <cassert>
#include <iostream>


namespace geometry {
    
    namespace jarvis {
        
        struct Point {
            int x, y;
        };

        
        class Convexhull {
            std::vector<Point> points;
            int size;

        public:
            
            explicit Convexhull(const std::vector<Point> &pointList) {
                points = pointList;
                size = points.size();
            }

            
            std::vector<Point> getConvexHull() const {
                                std::vector<Point> hull;

                                int leftmost_point = 0;
                for (int i = 1; i < size; i++) {
                    if (points[i].x < points[leftmost_point].x) {
                        leftmost_point = i;
                    }
                }
                                                                int p = leftmost_point, q = 0;
                do {
                                        hull.push_back(points[p]);

                                                                                                                        q = (p + 1) % size;
                    for (int i = 0; i < size; i++) {
                                                                        if (orientation(points[p], points[i], points[q]) == 2) {
                            q = i;
                        }
                    }

                                                                                p = q;

                } while (p != leftmost_point);        
                return hull;
            }

            
            static int orientation(const Point &p, const Point &q, const Point &r) {
                int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);

                if (val == 0) {
                    return 0;
                }
                return (val > 0) ? 1 : 2;
            }

        };

    } } 

static void test() {
    std::vector<geometry::jarvis::Point> points = {{0, 3},
                                                   {2, 2},
                                                   {1, 1},
                                                   {2, 1},
                                                   {3, 0},
                                                   {0, 0},
                                                   {3, 3}
    };
    geometry::jarvis::Convexhull hull(points);
    std::vector<geometry::jarvis::Point> actualPoint;
    actualPoint = hull.getConvexHull();

    std::vector<geometry::jarvis::Point> expectedPoint = {{0, 3},
                                                          {0, 0},
                                                          {3, 0},
                                                          {3, 3}};
    for (int i = 0; i < expectedPoint.size(); i++) {
        assert(actualPoint[i].x == expectedPoint[i].x);
        assert(actualPoint[i].y == expectedPoint[i].y);
    }
    std::cout << "Test implementations passed!\n";
}


int main() {
    test();
    return 0;
}
#include <iostream>

class Node {
 public:
    int val;
    Node *next;

    Node(int v, Node *n) : val(v), next(n) {}  };

int getSize(Node *root) {
    if (root == NULL) {
        return 0;
    }
        return 1 + getSize(root->next);
}

int main() {
    Node *myList = new Node(0, NULL);      Node *temp = myList;
        for (int i = 1; i < 10; i++) {
        temp->next = new Node(i, NULL);
        temp = temp->next;
    }
        Node *secondList = new Node(0, NULL);      Node *thirdList = NULL;                
    std::cout << getSize(myList) << std::endl
              << getSize(secondList) << std::endl
              << getSize(thirdList) << std::endl;

    return 0;
}


#include <algorithm>  #include <cassert>    #include <cctype>     #include <cstring>    #include <iostream>   #include <queue>      

namespace operations_on_datastructures {

namespace trie_operations {

class Tnode {
 private:
    static constexpr uint8_t ENGLISH_ALPHABET_SIZE = 26;
        std::vector<Tnode *> english;

        bool endOfWord;

        uint32_t frequency;

 public:
    Tnode() {
        english.resize(ENGLISH_ALPHABET_SIZE, nullptr);
        endOfWord = false;
        frequency = 0;
    }
        Tnode(const Tnode &node) {
        english = node.english;
        endOfWord = node.endOfWord;
        frequency = node.frequency;
    }

    Tnode &operator=(const Tnode &node) = default;

    Tnode(Tnode &&) = default;

    Tnode &operator=(Tnode &&) = default;
    
    inline uint8_t numberOfChildren(Tnode *node) {
        return ENGLISH_ALPHABET_SIZE -
               std::count(node->english.begin(), node->english.end(), nullptr);
    }

        void Insert(const std::string &entry);
    void Delete(std::string entry);
    void DeleteFrom(Tnode *delete_from, std::string delete_string,
                    int remove_index);
    bool SearchPresence(const std::string &key);
    void SuggestAutocomplete(Tnode *new_root, const std::string &prefix);
    void SearchSuggestions(const std::string &key);
    void SuggestFreqAutocomplete(
        Tnode *new_root, const std::string &prefix,
        std::priority_queue<std::pair<int, std::string> > *suggestions);
    void SearchFreqSuggestions(const std::string &key);
    void SelectionTop_3(
        std::priority_queue<std::pair<int, std::string> > *suggestions);

        ~Tnode() {
        int i = 0;
        for (i = 0; i < ENGLISH_ALPHABET_SIZE; i++) {
            if (english[i]) {
                delete english[i];
            }
        }
    }
};


void Tnode::Insert(const std::string &entry) {
    Tnode *cur_pos = this;
    int letter_index = 0;

    for (auto &i : entry) {
                letter_index = tolower(i) - 97;

                        if (cur_pos->english[letter_index] == nullptr) {
            cur_pos->english[letter_index] = new Tnode();
        }

        cur_pos = cur_pos->english[letter_index];
    }
        cur_pos->endOfWord = true;
}


void Tnode::DeleteFrom(Tnode *delete_from, std::string delete_string,
                       int remove_index) {
    if (delete_string.size() == remove_index) {
        int letter_index = tolower(delete_string[remove_index]) - 97;

        DeleteFrom(delete_from->english[letter_index], delete_string,
                   remove_index + 1);

        delete delete_from;
    }
}


void Tnode::Delete(std::string entry) {
    Tnode *cur_pos = this,
          *delete_from = this;      int letter_index = 0, delete_from_index = 0, i = 0, n = entry.size();

    for (i = 0; i < n; i++) {
                letter_index = tolower(entry[i]) - 97;

                if (cur_pos->english[letter_index] == nullptr) {
            std::cout << "Entry not Found" << std::endl;
            return;
        }
                                if (numberOfChildren(cur_pos) > 1 || cur_pos->endOfWord) {
            delete_from = cur_pos;                                                          delete_from_index = i - 1;                                                  }

                cur_pos = cur_pos->english[letter_index];
    }

            if (!cur_pos->endOfWord) {
        std::cout << "Entry not Found" << std::endl;
        return;
    }

            if (numberOfChildren(cur_pos)) {
        cur_pos->endOfWord = false;
        cur_pos->frequency = 0;
        return;
    }

        letter_index = tolower(entry[delete_from_index + 1]) - 97;
        cur_pos = delete_from->english[letter_index];
        delete_from->english[letter_index] = nullptr;

            if (n > delete_from_index + 2) {
        DeleteFrom(cur_pos, entry, delete_from_index + 2);
    }
        else {
        delete cur_pos;
    }
}


bool Tnode::SearchPresence(const std::string &key) {
    Tnode *cur_pos = this;
    int letter_index = 0;

    for (auto &i : key) {
        letter_index = tolower(i) - 97;
                if (cur_pos->english[letter_index] == nullptr) {
            return false;
        }
        cur_pos = cur_pos->english[letter_index];
    }
            if (cur_pos->endOfWord) {
        (cur_pos->frequency)++;
        return true;
    } else {
        return false;
    }
}


void Tnode::SuggestAutocomplete(Tnode *new_root, const std::string &prefix) {
            int i = 0;
    for (i = 0; i < ENGLISH_ALPHABET_SIZE; i++) {
        if (new_root->english[i] != nullptr) {
                                    if (new_root->english[i]->endOfWord) {
                std::cout << prefix + char(i + 97) << std::endl;
            }

            SuggestAutocomplete(new_root->english[i], prefix + char(i + 97));
        }
    }
}


void Tnode::SearchSuggestions(const std::string &key) {
    Tnode *cur_pos = nullptr, *prev_pos = nullptr;
    cur_pos = prev_pos = this;      int letter_index = 0;
    std::string prefix =
        "";  
    for (auto &i : key) {
        letter_index = tolower(i) - 97;
        prev_pos = cur_pos;                               
                        if (cur_pos->english[letter_index] == nullptr) {
            SuggestAutocomplete(prev_pos, prefix);
            std::cout << "- - - - - - - - - - - - - - - - - - - - - - - - - - "
                      << std::endl;
            return;
        }
                prefix += char(tolower(i));
        cur_pos = cur_pos->english[letter_index];
    }
        if (cur_pos->endOfWord) {
        std::cout << key << std::endl;
        (cur_pos->frequency)++;
    }

    (void)prev_pos;  
            SuggestAutocomplete(cur_pos, prefix);
    std::cout << "- - - - - - - - - - - - - - - - - - - - - - - - - - "
              << std::endl;
    return;
}


void Tnode::SelectionTop_3(
    std::priority_queue<std::pair<int, std::string> > *suggestions) {
        int n = suggestions->size(), Top = 0;
    Top = n < 3 ? n : 3;
    while (Top--) {
        std::cout << suggestions->top().second << std::endl;
        suggestions->pop();
    }
}


void Tnode::SuggestFreqAutocomplete(
    Tnode *new_root, const std::string &prefix,
    std::priority_queue<std::pair<int, std::string> > *suggestions) {
    int i = 0;
    for (i = 0; i < ENGLISH_ALPHABET_SIZE; i++) {
        if (new_root->english[i] != nullptr) {
                                    if (new_root->english[i]->endOfWord) {
                suggestions->push(std::make_pair(
                    new_root->english[i]->frequency, prefix + char(i + 97)));
            }

            SuggestFreqAutocomplete(new_root->english[i], prefix + char(i + 97),
                                    suggestions);
        }
    }
}


void Tnode::SearchFreqSuggestions(const std::string &key) {
    Tnode *cur_pos = nullptr, *prev_pos = nullptr;
    cur_pos = prev_pos = this;      int letter_index = 0;
    std::string prefix =
        "";      std::priority_queue<std::pair<int, std::string> >
        suggestions;                        
    std::priority_queue<std::pair<int, std::string> > *Suggestions =
        &suggestions;

    for (auto &i : key) {
        letter_index = tolower(i) - 97;
        prev_pos = cur_pos;                               
                        if (cur_pos->english[letter_index] == nullptr) {
            SuggestFreqAutocomplete(prev_pos, prefix, Suggestions);
                        SelectionTop_3(Suggestions);
            std::cout << "- - - - - - - - - - - - - - - - - - - - - - - - - - "
                      << std::endl;
            return;
        }
                prefix += char(tolower(i));
        cur_pos = cur_pos->english[letter_index];
    }
        if (cur_pos->endOfWord) {
        (cur_pos->frequency)++;
        std::cout << key << std::endl;
    }

    (void)prev_pos;  
            SuggestFreqAutocomplete(cur_pos, prefix, Suggestions);
        SelectionTop_3(Suggestions);

    std::cout << "- - - - - - - - - - - - - - - - - - - - - - - - - - "
              << std::endl;
    return;
}
}  }  

static void test() {
    auto root = new operations_on_datastructures::trie_operations::Tnode();
    std::vector<std::string> inputs = {
        "abcde", "sss",    "ssss",  "ssst", "sssu", "sssv",
        "sst",   "ssts",   "sstt",  "sstu", "tutu", "tutuv",
        "tutuu", "tutuvs", "tutus", "tvst", "tvsu", "vvvv"};

    for (auto &i : inputs) {
        root->Insert(i);
    }
        assert(root->SearchPresence("vvvv"));
    std::cout << root->SearchPresence("vvvv") << std::endl;
        root->Delete("vvvv");
        assert(!root->SearchPresence("vvvv"));
    std::cout << root->SearchPresence("vvvv") << std::endl;

    std::cout << root->SearchPresence("tutu") << std::endl;
    root->SearchSuggestions("tutu");
    std::cout << root->SearchPresence("tutu") << std::endl;

    root->SearchSuggestions("tutuv");
    std::cout << root->SearchPresence("tutuv") << std::endl;

    root->SearchSuggestions("tutuvs");

    root->SearchFreqSuggestions(
        "tu");                      root->SearchSuggestions(
        "");  }


int main(int argc, char const *argv[]) {
    test();      return 0;
}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     

namespace operations_on_datastructures {


void print(const std::vector<int32_t> &array) {
    for (int32_t i : array) {
        std::cout << i << " ";      }
    std::cout << "\n";  }


std::vector<int32_t> get_union(const std::vector<int32_t> &first,
                               const std::vector<int32_t> &second) {
    std::vector<int32_t> res;             size_t f_index = 0;                   size_t s_index = 0;                   size_t f_length = first.size();       size_t s_length = second.size();      int32_t next = 0;  
    while (f_index < f_length && s_index < s_length) {
        if (first[f_index] < second[s_index]) {
            next = first[f_index];              f_index++;                      } else if (first[f_index] > second[s_index]) {
            next = second[s_index];              s_index++;                       } else {
            next = first[f_index];              f_index++;                          s_index++;                      }
        if ((res.size() == 0) || (next != res.back())) {
            res.push_back(next);          }
    }
    while (f_index < f_length) {
        next = first[f_index];          if ((res.size() == 0) || (next != res.back())) {
            res.push_back(next);          }
        f_index++;
    }
    while (s_index < s_length) {
        next = second[s_index];          if ((res.size() == 0) || (next != res.back())) {
            res.push_back(next);          }
        s_index++;
    }
    return res;
}

}  

namespace tests {
using operations_on_datastructures::get_union;
using operations_on_datastructures::print;

void test1() {
    std::cout << "TEST CASE 1\n";
    std::cout << "Intialized a = {} b = {}\n";
    std::cout << "Expected result: {}\n";
    std::vector<int32_t> a = {};
    std::vector<int32_t> b = {};
    std::vector<int32_t> result = get_union(a, b);
    assert(result == a);      print(result);            std::cout << "TEST PASSED!\n\n";
}

void test2() {
    std::cout << "TEST CASE 2\n";
    std::cout << "Intialized a = {} b = {2, 3}\n";
    std::cout << "Expected result: {2, 3}\n";
    std::vector<int32_t> a = {};
    std::vector<int32_t> b = {2, 3};
    std::vector<int32_t> result = get_union(a, b);
    assert(result == b);      print(result);            std::cout << "TEST PASSED!\n\n";
}

void test3() {
    std::cout << "TEST CASE 3\n";
    std::cout << "Intialized a = {4, 6} b = {2, 3}\n";
    std::cout << "Expected result: {2, 3, 4, 6}\n";
    std::vector<int32_t> a = {4, 6};
    std::vector<int32_t> b = {2, 3};
    std::vector<int32_t> result = get_union(a, b);
    std::vector<int32_t> expected = {2, 3, 4, 6};
    assert(result == expected);      print(result);                   std::cout << "TEST PASSED!\n\n";
}

void test4() {
    std::cout << "TEST CASE 4\n";
    std::cout << "Intialized a = {4, 6, 6, 7} b = {2, 3, 4}\n";
    std::cout << "Expected result: {2, 3, 4, 6, 7}\n";
    std::vector<int32_t> a = {4, 6, 6, 7};
    std::vector<int32_t> b = {2, 3, 4};
    std::vector<int32_t> result = get_union(a, b);
    std::vector<int32_t> expected = {2, 3, 4, 6, 7};
    assert(result == expected);      print(result);                   std::cout << "TEST PASSED!\n\n";
}

void test5() {
    std::cout << "TEST CASE 5\n";
    std::cout << "Intialized a = {1, 4, 6, 7, 9} b = {2, 3, 5}\n";
    std::cout << "Expected result: {1, 2, 3, 4, 5, 6, 7, 9}\n";
    std::vector<int32_t> a = {1, 4, 6, 7, 9};
    std::vector<int32_t> b = {2, 3, 5};
    std::vector<int32_t> result = get_union(a, b);
    std::vector<int32_t> expected = {1, 2, 3, 4, 5, 6, 7, 9};
    assert(result == expected);      print(result);                   std::cout << "TEST PASSED!\n\n";
}

void test6() {
    std::cout << "TEST CASE 6\n";
    std::cout << "Intialized a = {1, 3, 3, 2, 5, 9, 4, 3, 2} ";
    std::cout << "b = {11, 3, 7, 8, 6}\n";
    std::cout << "Expected result: {1, 2, 3, 4, 5, 6, 7, 8, 9, 11}\n";
    std::vector<int32_t> a = {1, 3, 3, 2, 5, 9, 4, 3, 2};
    std::vector<int32_t> b = {11, 3, 7, 8, 6};
    std::sort(a.begin(), a.end());      std::sort(b.begin(), b.end());      std::vector<int32_t> result = get_union(a, b);
    std::vector<int32_t> expected = {1, 2, 3, 4, 5, 6, 7, 8, 9, 11};
    assert(result == expected);      print(result);                   std::cout << "TEST PASSED!\n\n";
}
}  

static void test() {
    tests::test1();
    tests::test2();
    tests::test3();
    tests::test4();
    tests::test5();
    tests::test6();
}


int main() {
    test();      return 0;
}


#include <cassert>   #include <iostream>  #include <vector>    

namespace operations_on_datastructures {


namespace inorder_traversal_of_bst {


class Node {
 public:
    int64_t data;      Node *left;        Node *right;   };


Node *makeNode(int64_t data) {
    Node *node = new Node();
    node->data = data;          node->left = nullptr;       node->right = nullptr;      return node;
}


Node *Insert(Node *root, int64_t data) {
    if (root == nullptr) {
        root = makeNode(data);
    } else if (data <= root->data) {
        root->left = Insert(root->left, data);
    } else {
        root->right = Insert(root->right, data);
    }
    return root;
}


Node *getNode(Node *root, int64_t data) {
    if (root == nullptr) {
        return nullptr;
    } else if (root->data == data) {
        return root;      } else if (data > root->data) {
                        return getNode(root->right, data);
    } else {
                        return getNode(root->left, data);
    }
}


Node *findMinNode(Node *root) {
    if (root == nullptr) {
        return root;
    }
    while (root->left != nullptr) {
        root = root->left;
    }
    return root;
}


void printInorder(Node *root) {
    if (root == nullptr) {
        return;
    }

    printInorder(root->left);      std::cout << root->data << " ";
    printInorder(root->right);  }


Node *makeBST(Node *root, const std::vector<int64_t> &data) {
    for (int64_t values : data) {
        root = Insert(root, values);
    }
    return root;
}


Node *getInorderSuccessor(Node *root, int64_t data) {
    Node *current = getNode(root, data);
    if (current == nullptr) {
        return nullptr;
    }

        if (current->right != nullptr) {
        return findMinNode(current->right);
    }
        else {
        Node *successor = nullptr;
        Node *ancestor = root;

        while (ancestor != current && ancestor != nullptr) {
                        if (current->data < ancestor->data) {
                successor = ancestor;
                ancestor = ancestor->left;              } else {
                ancestor = ancestor->right;
            }
        }
        return successor;      }
}


void deallocate(Node *rootNode) {
    if (rootNode == nullptr) {
        return;
    }
    deallocate(rootNode->left);
    deallocate(rootNode->right);
    delete (rootNode);
}

}  }  

class TestCases {
 private:
    
    template <typename T>
    void log(T msg) {
                std::cout << "[TESTS] : ---> " << msg << std::endl;
    }

 public:
    
    void runTests() {
        log("Running Tests...");

        testCase_1();
        testCase_2();
        testCase_3();

        log("Test Cases over!");
        std::cout << std::endl;
    }

    
    void testCase_1() {
        const operations_on_datastructures::inorder_traversal_of_bst::Node
            *expectedOutput = nullptr;  
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        log("This is test case 1 : ");
        log("Description:");
        log("   EDGE CASE : Printing inorder successor for last node in the "
            "BST, Output will be nullptr.");

        operations_on_datastructures::inorder_traversal_of_bst::Node *root =
            nullptr;
        std::vector<int64_t> node_data{
            20, 3, 5, 6, 2, 23, 45, 78, 21};  
        root = operations_on_datastructures::inorder_traversal_of_bst::makeBST(
            root,
            node_data);  
        std::cout << "Inorder sequence is : ";
        operations_on_datastructures::inorder_traversal_of_bst::printInorder(
            root);          std::cout << std::endl;

        operations_on_datastructures::inorder_traversal_of_bst::Node
            *inorderSuccessor = operations_on_datastructures::
                inorder_traversal_of_bst::getInorderSuccessor(
                    root, 78);  
        log("Checking assert expression...");
        assert(inorderSuccessor == expectedOutput);
        log("Assertion check passed!");

        operations_on_datastructures::inorder_traversal_of_bst::deallocate(
            root);  
        log("[PASS] : TEST CASE 1 PASS!");
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
    }

    
    void testCase_2() {
        const int expectedOutput = 21;  
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        log("This is test case 2 : ");

        operations_on_datastructures::inorder_traversal_of_bst::Node *root =
            nullptr;
        std::vector<int64_t> node_data{
            20, 3, 5, 6, 2, 23, 45, 78, 21};  
        root = operations_on_datastructures::inorder_traversal_of_bst::makeBST(
            root,
            node_data);  
        std::cout << "Inorder sequence is : ";
        operations_on_datastructures::inorder_traversal_of_bst::printInorder(
            root);          std::cout << std::endl;

        operations_on_datastructures::inorder_traversal_of_bst::Node
            *inorderSuccessor = operations_on_datastructures::
                inorder_traversal_of_bst::getInorderSuccessor(
                    root, 20);  
        log("Checking assert expression...");
        assert(inorderSuccessor->data == expectedOutput);
        log("Assertion check passed!");

        operations_on_datastructures::inorder_traversal_of_bst::deallocate(
            root);  
        log("[PASS] : TEST CASE 2 PASS!");
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
    }

    
    void testCase_3() {
        const int expectedOutput = 110;  
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
        log("This is test case 3 : ");

        operations_on_datastructures::inorder_traversal_of_bst::Node *root =
            nullptr;
        std::vector<int64_t> node_data{
            89,  67,  32, 56, 90, 123, 120,
            110, 115, 6,  78, 7,  10};  
        root = operations_on_datastructures::inorder_traversal_of_bst::makeBST(
            root,
            node_data);  
        std::cout << "Inorder sequence is : ";
        operations_on_datastructures::inorder_traversal_of_bst::printInorder(
            root);          std::cout << std::endl;

        operations_on_datastructures::inorder_traversal_of_bst::Node
            *inorderSuccessor = operations_on_datastructures::
                inorder_traversal_of_bst::getInorderSuccessor(
                    root, 90);  
        log("Checking assert expression...");
        assert(inorderSuccessor->data == expectedOutput);
        log("Assertion check passed!");

        operations_on_datastructures::inorder_traversal_of_bst::deallocate(
            root);  
        log("[PASS] : TEST CASE 3 PASS!");
        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
    }
};


static void test() {
    TestCases tc;
    tc.runTests();
}


int main(int argc, char *argv[]) {
    test();  
    operations_on_datastructures::inorder_traversal_of_bst::Node *root =
        nullptr;      std::vector<int64_t> node_data{3,  4, 5,
                                   89, 1, 2};  
    int64_t targetElement = 4;      root = operations_on_datastructures::inorder_traversal_of_bst::makeBST(
        root, node_data);  
    operations_on_datastructures::inorder_traversal_of_bst::Node
        *inorderSuccessor = operations_on_datastructures::
            inorder_traversal_of_bst::getInorderSuccessor(root, targetElement);

    std::cout << "In-order sequence is : ";
    operations_on_datastructures::inorder_traversal_of_bst::printInorder(root);
    std::cout << std::endl;

    if (inorderSuccessor == nullptr) {
        std::cout << "Inorder successor for last node is NULL" << std::endl;
    } else {
        std::cout << "Target element is : " << targetElement << std::endl;
        std::cout << "Inorder successor for target element is : "
                  << inorderSuccessor->data << std::endl;
    }

    deallocate(root);  
    return 0;
}


#include <algorithm>  #include <cassert>    #include <iostream>   #include <vector>     

namespace operations_on_datastructures {


void print(const std::vector<int32_t> &array) {
    for (int32_t i : array) {
        std::cout << i << " ";      }
    std::cout << "\n";  }


std::vector<int32_t> get_intersection(const std::vector<int32_t> &first,
                                      const std::vector<int32_t> &second) {
    std::vector<int32_t> res;             size_t f_index = 0;                   size_t s_index = 0;                   size_t f_length = first.size();       size_t s_length = second.size();  
    while (f_index < f_length && s_index < s_length) {
        if (first[f_index] < second[s_index]) {
            f_index++;          } else if (first[f_index] > second[s_index]) {
            s_index++;          } else {
            if ((res.size() == 0) || (first[f_index] != res.back())) {
                res.push_back(
                    first[f_index]);              }
            f_index++;              s_index++;          }
    }
    return res;
}

}  

namespace tests {
using operations_on_datastructures::get_intersection;
using operations_on_datastructures::print;

void test1() {
    std::cout << "TEST CASE 1\n";
    std::cout << "Intialized a = {} b = {}\n";
    std::cout << "Expected result: {}\n";
    std::vector<int32_t> a = {};
    std::vector<int32_t> b = {};
    std::vector<int32_t> result = get_intersection(a, b);
    assert(result == a);      print(result);            std::cout << "TEST PASSED!\n\n";
}

void test2() {
    std::cout << "TEST CASE 2\n";
    std::cout << "Intialized a = {} b = {2, 3}\n";
    std::cout << "Expected result: {}\n";
    std::vector<int32_t> a = {};
    std::vector<int32_t> b = {2, 3};
    std::vector<int32_t> result = get_intersection(a, b);
    assert(result == a);      print(result);            std::cout << "TEST PASSED!\n\n";
}

void test3() {
    std::cout << "TEST CASE 3\n";
    std::cout << "Intialized a = {4, 6} b = {3, 6}\n";
    std::cout << "Expected result: {6}\n";
    std::vector<int32_t> a = {4, 6};
    std::vector<int32_t> b = {3, 6};
    std::vector<int32_t> result = get_intersection(a, b);
    std::vector<int32_t> expected = {6};
    assert(result == expected);      print(result);                   std::cout << "TEST PASSED!\n\n";
}

void test4() {
    std::cout << "TEST CASE 4\n";
    std::cout << "Intialized a = {4, 6, 6, 6} b = {2, 4, 4, 6}\n";
    std::cout << "Expected result: {4, 6}\n";
    std::vector<int32_t> a = {4, 6, 6, 6};
    std::vector<int32_t> b = {2, 4, 4, 6};
    std::vector<int32_t> result = get_intersection(a, b);
    std::vector<int32_t> expected = {4, 6};
    assert(result == expected);      print(result);                   std::cout << "TEST PASSED!\n\n";
}

void test5() {
    std::cout << "TEST CASE 5\n";
    std::cout << "Intialized a = {1, 2, 3, 4, 6, 7, 9} b = {2, 3, 4, 5}\n";
    std::cout << "Expected result: {2, 3, 4}\n";
    std::vector<int32_t> a = {1, 2, 3, 4, 6, 7, 9};
    std::vector<int32_t> b = {2, 3, 4, 5};
    std::vector<int32_t> result = get_intersection(a, b);
    std::vector<int32_t> expected = {2, 3, 4};
    assert(result == expected);      print(result);                   std::cout << "TEST PASSED!\n\n";
}

void test6() {
    std::cout << "TEST CASE 6\n";
    std::cout << "Intialized a = {1, 3, 3, 2, 5, 9, 4, 7, 3, 2} ";
    std::cout << "b = {11, 3, 7, 8, 6}\n";
    std::cout << "Expected result: {3, 7}\n";
    std::vector<int32_t> a = {1, 3, 3, 2, 5, 9, 4, 7, 3, 2};
    std::vector<int32_t> b = {11, 3, 7, 8, 6};
    std::sort(a.begin(), a.end());      std::sort(b.begin(), b.end());      std::vector<int32_t> result = get_intersection(a, b);
    std::vector<int32_t> expected = {3, 7};
    assert(result == expected);      print(result);                   std::cout << "TEST PASSED!\n\n";
}
}  

static void test() {
    tests::test1();
    tests::test2();
    tests::test3();
    tests::test4();
    tests::test5();
    tests::test6();
}


int main() {
    test();      return 0;
}


#include <cassert>   #include <iostream>  #include <vector>    

namespace operations_on_datastructures {


namespace circular_linked_list {


struct Node {
    int64_t data;      Node* next;        
    explicit Node(int64_t _data) {
        data = _data;            next = nullptr;      }
    
    explicit Node(int64_t _data, Node* _next) {
        data = _data;          next = _next;      }
};


class CircularLinkedList {
 private:
    Node* root;       Node* end{};  
 public:
    
    CircularLinkedList() {
        root = nullptr;
        end = nullptr;
    }
    
    CircularLinkedList(const CircularLinkedList& copy) {
        erase();
        root = nullptr;
        Node* node = copy.root;
        while (node != nullptr) {
            insert(node->data);
            node = node->next;
        }
    }
    
    CircularLinkedList(CircularLinkedList&& source) noexcept {
        root = source.root;
        end = source.end;
        source.root = nullptr;
        source.end = nullptr;
    }
    
    CircularLinkedList& operator=(const CircularLinkedList& other) {
        erase();
        root = nullptr;
        Node* node = other.root;
        while (node != nullptr) {
            insert(node->data);
            node = node->next;
        }
        return *this;
    }
    
    CircularLinkedList& operator=(CircularLinkedList&& other) noexcept {
        root = other.root;
        end = other.end;
        other.root = nullptr;
        other.end = nullptr;
        return *this;
    }
    
    ~CircularLinkedList() { erase(); }
    
    void erase() {
        if (root == nullptr) {
            return;
        }
        Node* node = root;
        do {
            Node* temp = node;
            node = node->next;
            delete (temp);
        } while (node != root);
        root = nullptr;
        end = nullptr;
    }
    
    void insert(const std::vector<int64_t>& values) {
        for (int64_t value : values) {
            insert(value);
        }
    }
    
    void insert(int64_t data) {
        Node* node = new Node(data, root);
        insert(node);
    }
    
    void insert(Node* node) {
        if (root == nullptr) {
            root = node;                    node->next = root;              end = root;                 } else {
            end->next = node;               node->next = root;              end = node;                 }
    }
    
    void print() { print(root); }
    
    void print(Node* root) {
        Node* temp = root;
        if (root == nullptr) {
            std::cout << "Empty List!\n";
            return;
        }
        do {
            std::cout << temp->data << " ";
            temp = temp->next;
        } while (temp != root);
        std::cout << "\n";
    }
    
    std::vector<int64_t> values() { return values(root); }
    
    std::vector<int64_t> values(Node* root) {
        std::vector<int64_t> res;
        if (root == nullptr) {
            return res;          }
        Node* temp = root;
        do {
            res.push_back(temp->data);
            temp = temp->next;
        } while (temp != root);
        return res;
    }
};

}  
}  

namespace tests {
using operations_on_datastructures::circular_linked_list::CircularLinkedList;
using operations_on_datastructures::circular_linked_list::Node;

void test1() {
    std::cout << "TEST CASE 1\n";
    std::cout << "Intialized a = {2}\n";
    std::cout << "Expected result: {2}\n";
    CircularLinkedList a;
    std::vector<int64_t> res = {2};
    a.insert(2);
    assert(a.values() == res);
    a.print();
    std::cout << "TEST PASSED!\n\n";
}

void test2() {
    std::cout << "TEST CASE 2\n";
    std::cout << "Intialized a = {2, 5, 6}\n";
    std::cout << "Expected result: {2, 5, 6}\n";
    CircularLinkedList a;
    std::vector<int64_t> res = {2, 5, 6};
    a.insert(2);
    a.insert(5);
    a.insert(6);
    assert(a.values() == res);
    a.print();
    std::cout << "TEST PASSED!\n\n";
}

void test3() {
    std::cout << "TEST CASE 3\n";
    std::cout << "Intialized a = {2, 7, 8, 3, 2, 6}\n";
    std::cout << "Expected result: {2, 7, 8, 3, 2, 6}\n";
    CircularLinkedList a;
    std::vector<int64_t> res = {2, 7, 8, 3, 2, 6};
    a.insert({2, 7, 8, 3, 2, 6});
    a.print();
    assert(a.values() == res);
    std::cout << "TEST PASSED!\n\n";
}

void test4() {
    std::cout << "TEST CASE 4\n";
    std::cout << "Intialized a = {2, 5}\n";
    std::cout << "Expected result: {5, 2}\n";
    CircularLinkedList a;
    std::vector<int64_t> res = {5, 2};
    a.insert(2);
    Node* start = new Node(5);      a.insert(start);
    assert(a.values(start) == res);
    a.print(start);
    std::cout << "TEST PASSED!\n\n";
}


void test5() {
    std::cout << "TEST CASE 5\n";
    std::cout << "Intialized a = {}\n";
    std::cout << "Expected result: Empty List!\n";
    CircularLinkedList a;
    std::vector<int64_t> res = {};
    assert(a.values() == res);
    a.print();
    std::cout << "TEST PASSED!\n\n";
}
}  

static void test() {
    tests::test1();
    tests::test2();
    tests::test3();
    tests::test4();
    tests::test5();
}


int main() {
    test();      return 0;
}
#include <iostream>
using namespace std;

int queue[10];
int front = 0;
int rear = 0;
int count = 0;

void Enque(int x) {
    if (count == 10) {
        cout << "\nOverflow";
    } else {
        queue[rear] = x;
        rear = (rear + 1) % 10;
        count++;
    }
}

void Deque() {
    if (front == rear) {
        cout << "\nUnderflow";
    }

    else {
        cout << "\n" << queue[front] << " deleted";
        front = (front + 1) % 10;
        count--;
    }
}

void show() {
    for (int i = 0; i < count; i++) {
        cout << queue[(i + front) % 10] << "\t";
    }
}

int main() {
    int ch, x;
    do {
        cout << "\n1. Enque";
        cout << "\n2. Deque";
        cout << "\n3. Print";
        cout << "\nEnter Your Choice : ";
        cin >> ch;
        if (ch == 1) {
            cout << "\nInsert : ";
            cin >> x;
            Enque(x);
        } else if (ch == 2) {
            Deque();
        } else if (ch == 3) {
            show();
        }
    } while (ch != 0);

    return 0;
}
#include <iostream>
using namespace std;

class node {
 public:
    int data;
    node *link;
    node(int d) {
        data = d;
        link = NULL;
    }
};

void print(node *head) {
    node *current = head;
    while (current != NULL) {
        cout << current->data << " ";
        current = current->link;
    }
    cout << endl;
}

node *createlist(int n) {
    node *head = NULL;
    node *t = NULL;
    for (int i = 0; i < n; i++) {
        node *temp = NULL;
        int num;
        cin >> num;
        temp = new node(num);
        if (head == NULL) {
            head = temp;
            t = temp;
            continue;
        }
        if (t->link == NULL)
            t->link = temp;
        t = temp;
    }
    return head;
}

void my_selection_sort_linked_list(node *&head) {
    node *min = head;                                                                                                  node *current =
        min->link;      node *previous = min;                                 node *temp =
        NULL;                                                                                                                                         
    while (
        min->link !=
        NULL)      {
                
        while (current != NULL)                                                                            {
            if (current->data < min->data)                                                          {
                if (temp == NULL)                                                                                        {
                    if (previous ==
                        min)                      {
                                                head = current;                                                                   min->link = current->link;
                        current->link = previous;
                        min = current;
                        current = previous->link;
                    } else                                                  {
                                                head = current;                                                                   previous->link = current->link;
                        current->link = min;
                        min = current;
                        current = previous->link;
                    }
                } else                                          {
                    temp->link = current;
                    previous->link = current->link;
                    current->link = min;
                    min = current;
                    current = previous->link;
                }
            } else                                  {
                previous = previous->link;
                current = current->link;
            }
        }

                                temp = min;
        min = min->link;
        previous = min;
        current = min->link;
    }
}






int main() {
    node *head = NULL;
    int n;
    cout << "enter the no. of nodes : ";                                                cin >> n;
    if (n == 0)
        return 0;
    head = createlist(n);      cout << "original list is : ";
    print(head);                              my_selection_sort_linked_list(head);      cout << "sorted list is : ";
    print(head);      return 0;
}

#include <cassert>   #include <iostream>  #include <vector>    

namespace operations_on_datastructures {


void print(const std::vector<int32_t> &array) {
    for (int32_t i : array) {
        std::cout << i << " ";      }
    std::cout << "\n";  }


std::vector<int32_t> shift_right(const std::vector<int32_t> &array,
                                 size_t shift) {
    if (array.size() <= shift) {
        return {};      }
    std::vector<int32_t> res(array.size());      for (size_t i = shift; i < array.size(); i++) {
        res[i] = array[i - shift];      }
    for (size_t i = 0; i < shift; i++) {
        res[i] =
            array[array.size() - shift + i];      }
    return res;
}

}  

namespace tests {
using operations_on_datastructures::print;
using operations_on_datastructures::shift_right;

void test1() {
    std::cout << "TEST CASE 1\n";
    std::cout << "Initialized arr = {1, 2, 3, 4, 5}\n";
    std::cout << "Expected result: {4, 5, 1, 2, 3}\n";
    std::vector<int32_t> arr = {1, 2, 3, 4, 5};
    std::vector<int32_t> res = shift_right(arr, 2);
    std::vector<int32_t> expected = {4, 5, 1, 2, 3};
    assert(res == expected);
    print(res);      std::cout << "TEST PASSED!\n\n";
}

void test2() {
    std::cout << "TEST CASE 2\n";
    std::cout << "Initialized arr = {}\n";
    std::cout << "Expected result: {}\n";
    std::vector<int32_t> arr = {};
    std::vector<int32_t> res = shift_right(arr, 2);
    std::vector<int32_t> expected = {};
    assert(res == expected);
    print(res);      std::cout << "TEST PASSED!\n\n";
}

void test3() {
    std::cout << "TEST CASE 3\n";
    std::cout << "Initialized arr = {1, 2, 3, 4, 5}\n";
    std::cout << "Expected result: {}\n";
    std::vector<int32_t> arr = {1, 2, 3, 4, 5};
    std::vector<int32_t> res = shift_right(arr, 7);      std::vector<int32_t> expected = {};
    assert(res == expected);
    print(res);      std::cout << "TEST PASSED!\n\n";
}

void test4() {
    std::cout << "TEST CASE 4\n";
    std::cout << "Initialized arr = {2, 4, ..., 420}\n";
    std::cout << "Expected result: {420, 2, 4, ..., 418}\n";
    std::vector<int32_t> arr;
    for (int i = 1; i <= 210; i++) {
        arr.push_back(i * 2);
    }
    print(arr);
    std::vector<int32_t> res = shift_right(arr, 1);
    std::vector<int32_t> expected;
    expected.push_back(420);
    for (int i = 0; i < 209; i++) {
        expected.push_back(arr[i]);
    }
    assert(res == expected);
    print(res);      std::cout << "TEST PASSED!\n\n";
}

void test5() {
    std::cout << "TEST CASE 5\n";
    std::cout << "Initialized arr = {1, 2, 3, 4, 5}\n";
    std::cout << "Expected result: {1, 2, 3, 4, 5}\n";
    std::vector<int32_t> arr = {1, 2, 3, 4, 5};
    std::vector<int32_t> res = shift_right(arr, 0);
    assert(res == arr);
    print(res);      std::cout << "TEST PASSED!\n\n";
}
}  

static void test() {
    tests::test1();
    tests::test2();
    tests::test3();
    tests::test4();
    tests::test5();
}


int main() {
    test();      return 0;
}


#include <cassert>   #include <iostream>  #include <vector>    

namespace operations_on_datastructures {


void print(const std::vector<int32_t> &array) {
    for (int32_t i : array) {
        std::cout << i << " ";      }
    std::cout << "\n";  }


std::vector<int32_t> shift_left(const std::vector<int32_t> &array,
                                size_t shift) {
    if (array.size() <= shift) {
        return {};      }
    std::vector<int32_t> res(array.size());      for (size_t i = shift; i < array.size(); i++) {
        res[i - shift] = array[i];      }
    for (size_t i = 0; i < shift; i++) {
        res[array.size() - shift + i] =
            array[i];      }
    return res;
}

}  

namespace tests {
using operations_on_datastructures::print;
using operations_on_datastructures::shift_left;

void test1() {
    std::cout << "TEST CASE 1\n";
    std::cout << "Initialized arr = {1, 2, 3, 4, 5}\n";
    std::cout << "Expected result: {3, 4, 5, 1, 2}\n";
    std::vector<int32_t> arr = {1, 2, 3, 4, 5};
    std::vector<int32_t> res = shift_left(arr, 2);
    std::vector<int32_t> expected = {3, 4, 5, 1, 2};
    assert(res == expected);
    print(res);      std::cout << "TEST PASSED!\n\n";
}

void test2() {
    std::cout << "TEST CASE 2\n";
    std::cout << "Initialized arr = {}\n";
    std::cout << "Expected result: {}\n";
    std::vector<int32_t> arr = {};
    std::vector<int32_t> res = shift_left(arr, 2);
    std::vector<int32_t> expected = {};
    assert(res == expected);
    print(res);      std::cout << "TEST PASSED!\n\n";
}

void test3() {
    std::cout << "TEST CASE 3\n";
    std::cout << "Initialized arr = {1, 2, 3, 4, 5}\n";
    std::cout << "Expected result: {}\n";
    std::vector<int32_t> arr = {1, 2, 3, 4, 5};
    std::vector<int32_t> res = shift_left(arr, 7);      std::vector<int32_t> expected = {};
    assert(res == expected);
    print(res);      std::cout << "TEST PASSED!\n\n";
}

void test4() {
    std::cout << "TEST CASE 4\n";
    std::cout << "Initialized arr = {2, 4, ..., 420}\n";
    std::cout << "Expected result: {4, 6, ..., 420, 2}\n";
    std::vector<int32_t> arr;
    for (int i = 1; i <= 210; i++) {
        arr.push_back(i * 2);
    }
    print(arr);
    std::vector<int32_t> res = shift_left(arr, 1);
    std::vector<int32_t> expected;
    for (int i = 1; i < 210; i++) {
        expected.push_back(arr[i]);
    }
    expected.push_back(2);
    assert(res == expected);
    print(res);      std::cout << "TEST PASSED!\n\n";
}

void test5() {
    std::cout << "TEST CASE 5\n";
    std::cout << "Initialized arr = {1, 2, 3, 4, 5}\n";
    std::cout << "Expected result: {1, 2, 3, 4, 5}\n";
    std::vector<int32_t> arr = {1, 2, 3, 4, 5};
    std::vector<int32_t> res = shift_left(arr, 0);
    assert(res == arr);
    print(res);      std::cout << "TEST PASSED!\n\n";
}
}  

static void test() {
    tests::test1();
    tests::test2();
    tests::test3();
    tests::test4();
    tests::test5();
}


int main() {
    test();      return 0;
}


#include <cassert>   #include <iostream>  #include <queue>     #include <vector>    

namespace operations_on_datastructures {


namespace reverse_binary_tree {


struct Node {
    int64_t data;      Node* left;        Node* right;       
    explicit Node(int64_t _data) {
        data = _data;             left = nullptr;           right = nullptr;      }
};


class BinaryTree {
 private:
    Node* root;      
    Node* insert(int64_t data, Node* pivot) {
        if (pivot == nullptr) {
            return new Node(data);          }
        if (data <= pivot->data) {
            pivot->left =
                insert(data, pivot->left);          } else {
            pivot->right =
                insert(data, pivot->right);          }
        return pivot;
    }
    
    Node* reverseBinaryTree(Node* pivot) {
        if (pivot == nullptr) {
            return pivot;          }
        Node* temp = pivot->left;          pivot->left = reverseBinaryTree(pivot->right);          pivot->right = reverseBinaryTree(temp);                 return pivot;
    }

 public:
    
    BinaryTree() { root = nullptr; }
    
    explicit BinaryTree(int64_t data) { root = new Node(data); }
    
    void add(int64_t data) { root = insert(data, root); }
    
    void reverse() { root = reverseBinaryTree(root); }
    
    std::vector<int64_t> get_level_order() {
        std::vector<int64_t> data;          if (root == nullptr) {
            return data;          }
        std::queue<Node*> nodes;          nodes.push(root);                 while (!nodes.empty()) {
            Node* temp = nodes.front();              data.push_back(temp->data);              nodes.pop();                             if (temp->left != nullptr) {
                nodes.push(temp->left);              }
            if (temp->right != nullptr) {
                nodes.push(temp->right);              }
        }          return data;
    }
    
    void print() {
        for (int i : get_level_order()) {
            std::cout << i << " ";          }
        std::cout << "\n";      }
};

}  }  

namespace tests {
using operations_on_datastructures::reverse_binary_tree::
    BinaryTree;  
void test1() {
    BinaryTree bst;
    std::vector<int64_t> pre_reversal, post_reversal;
    std::cout << "TEST CASE 1\n";
    std::cout << "Initializing tree with a single element (5)\n";
    bst.add(5);
    pre_reversal = bst.get_level_order();
    std::cout << "Before reversal: ";
    bst.print();
    std::cout << "After reversal: ";
    bst.reverse();
    post_reversal = bst.get_level_order();
    assert(pre_reversal.size() ==
           post_reversal.size());      assert(pre_reversal.size() ==
           1);      assert(pre_reversal[0] ==
           post_reversal[0]);      bst.print();
    std::cout << "TEST PASSED!\n\n";
}

void test2() {
    BinaryTree bst;
    std::vector<int64_t> pre_reversal, post_reversal;
    std::cout << "TEST CASE 2\n";
    std::cout << "Creating empty tree (root points to NULL)\n";
    pre_reversal = bst.get_level_order();
    std::cout << "Before reversal: ";
    bst.print();
    std::cout << "After reversal: ";
    bst.reverse();
    post_reversal = bst.get_level_order();
    assert(pre_reversal.size() ==
           post_reversal.size());      assert(pre_reversal.size() ==
           0);      bst.print();
    std::cout << "TEST PASSED!\n\n";
}

void test3() {
    BinaryTree bst;
    std::vector<int64_t> pre_reversal, post_reversal;
    std::vector<int64_t> pre_res = {4, 3, 6, 2, 5, 7, 1};
    std::vector<int64_t> post_res = {4, 6, 3, 7, 5, 2, 1};
    std::cout << "TEST CASE 3\n";
    std::cout << "Creating tree with elements (4, 6, 3, 2, 5, 7, 1)\n";
    bst.add(4);
    bst.add(6);
    bst.add(3);
    bst.add(2);
    bst.add(5);
    bst.add(7);
    bst.add(1);
    pre_reversal = bst.get_level_order();
    assert(pre_reversal == pre_res);      std::cout << "Before reversal: ";
    bst.print();
    std::cout << "After reversal: ";
    bst.reverse();
    post_reversal = bst.get_level_order();
    assert(post_reversal == post_res);      bst.print();
    std::cout << "TEST PASSED!\n\n";
}
}  

static void test() {
    tests::test1();      tests::test2();      tests::test3();  }


int main() {
    test();      return 0;
}
#include <iostream>
using namespace std;

struct node {
    int val;
    node *next;
};

node *start;

void insert(int x) {
    node *t = start;
    if (start != NULL) {
        while (t->next != NULL) {
            t = t->next;
        }
        node *n = new node;
        t->next = n;
        n->val = x;
        n->next = NULL;
    } else {
        node *n = new node;
        n->val = x;
        n->next = NULL;
        start = n;
    }
}

void reverse(node *p, node *q) {
    if (q->next == NULL) {
        q->next = p;
        p->next = NULL;
        start = q;
        return;
    } else {
        reverse(q, q->next);
        q->next = p;
        p->next = NULL;
    }
}

void show() {
    node *t = start;
    while (t != NULL) {
        cout << t->val << "\t";
        t = t->next;
    }
}

int main() {
    insert(1);
    insert(2);
    insert(3);
    insert(4);
    insert(5);
    insert(6);

    reverse(start, start->next);

    show();

    return 0;
}

#ifdef USE_GLUT
#ifdef __APPLE__
#include <GLUT/glut.h>  #else
#include <GL/glut.h>
#endif  #endif
#define _USE_MATH_DEFINES 
#include <array>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#ifdef _OPENMP
#include <omp.h>
#endif


namespace spirograph {

template <std::size_t N>
void spirograph(std::array<std::pair<double, double>, N> *points, double l,
                double k, double rot) {
    double dt = rot * 2.f * M_PI / N;
    double R = 1.f;
    const double k1 = 1.f - k;
    int32_t step = 0;

#ifdef _OPENMP
#pragma omp for
#endif
    for (step = 0; step < N; step++) {
        double t = dt * step;
        double first = R * (k1 * std::cos(t) + l * k * std::cos(k1 * t / k));
        double second = R * (k1 * std::sin(t) - l * k * std::sin(k1 * t / k));
        points[0][step].first = first;
        points[0][step].second = second;
    }
}


void test() {
    const size_t N = 500;
    double l = 0.3, k = 0.75, rot = 10.;
    std::stringstream fname;
    fname << std::setw(3) << "spirograph_" << l << "_" << k << "_" << rot
          << ".csv";
    std::ofstream fp(fname.str());
    if (!fp.is_open()) {
        perror(fname.str().c_str());
        exit(EXIT_FAILURE);
    }

    std::array<std::pair<double, double>, N> points;

    spirograph(&points, l, k, rot);

    for (size_t i = 0; i < N; i++) {
        fp << points[i].first << "," << points[i].first;
        if (i < N - 1) {
            fp << '\n';
        }
    }

    fp.close();
}

#ifdef USE_GLUT
static bool paused = 0; 
static const int animation_speed = 25; 

static const double step = 0.01;   
static double l_ratio = step * 10; 
static double k_ratio = step;      
static const double num_rot = 20.; 


static inline void glutBitmapString(void *font, char *message) {
    for (char *ch = message; *ch != '\0'; ch++) glutBitmapCharacter(font, *ch);
}


template <size_t N>
void display_graph(const std::array<std::pair<double, double>, N> &points,
                   double l, double k) {
    glClearColor(1.0f, 1.0f, 1.0f,
                 0.0f);                glClear(GL_COLOR_BUFFER_BIT);  
    glBegin(GL_LINES);             glColor3f(0.f, 0.f, 1.f);      glPointSize(2.f);          
    for (size_t i = 1; i < N; i++) {
        glVertex2f(points[i - 1].first, points[i - 1].second);          glVertex2f(points[i].first, points[i].second);              }
    glEnd();

    glColor3f(0.f, 0.f, 0.f);
    std::stringstream buffer;
    buffer << std::setw(3) << "l = " << l;
    glRasterPos2f(-.85, .85);
    glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24,
                     const_cast<char *>(buffer.str().c_str()));
    buffer.str("");
    buffer.clear();
    buffer << std::setw(3) << "k = " << k;
    glRasterPos2f(-.85, .70);
    glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24,
                     const_cast<char *>(buffer.str().c_str()));

    glutSwapBuffers();
}


void test2() {
    const size_t N = 5000;  
    static bool direction1 = true;      static bool direction2 = true;  
    std::array<std::pair<double, double>, N> points;

    spirograph(&points, l_ratio, k_ratio, num_rot);
    display_graph(points, l_ratio, k_ratio);

    if (paused)
                return;

    if (direction1) {                         if (k_ratio >= (1.f - step))              direction1 = false;               else
            k_ratio += step;
    } else {                            if (k_ratio <= step) {              direction1 = true;  
            if (direction2) {                                 if (l_ratio >= (1.f - step))                      direction2 = false;                       else
                    l_ratio += step;
            } else {                                    if (l_ratio <= step)                        direction2 = true;                  else
                    l_ratio -= step;
            }
        } else {              k_ratio -= step;
        }
    }
}


void timer_cb(int t) {
    glutTimerFunc(animation_speed, timer_cb, 0);
    glutPostRedisplay();
}


void keyboard_cb(unsigned char key, int x, int y) {
    switch (key) {
        case ' ':                          paused = !paused;              break;
        case GLUT_KEY_UP:
        case '+':              k_ratio += step;
            break;
        case GLUT_KEY_DOWN:
        case '_':              k_ratio -= step;
            break;
        case GLUT_KEY_RIGHT:
        case '=':              l_ratio += step;
            break;
        case GLUT_KEY_LEFT:
        case '-':              l_ratio -= step;
            break;
        case 0x1B:              exit(EXIT_SUCCESS);
        default:
            return;
    }
}
#endif
}  

int main(int argc, char **argv) {
    spirograph::test();

#ifdef USE_GLUT
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
    glutCreateWindow("Spirograph");
    glutInitWindowSize(400, 400);
        glutTimerFunc(spirograph::animation_speed, spirograph::timer_cb, 0);
    glutKeyboardFunc(spirograph::keyboard_cb);
    glutDisplayFunc(spirograph::test2);
    glutMainLoop();
#endif

    return 0;
}
