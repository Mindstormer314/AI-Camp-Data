package com.thealgorithms.misc;

import java.util.Stack;
import com.thealgorithms.datastructures.lists.SinglyLinkedList;


public class PalindromeSinglyLinkedList {

    public static void main(String[] args) {
        SinglyLinkedList linkedList = new SinglyLinkedList();

        linkedList.insertHead(3);
        linkedList.insertNth(2, 1);
        linkedList.insertNth(1, 2);
        linkedList.insertNth(2, 3);
        linkedList.insertNth(3, 4);

        if (isPalindrome(linkedList)) {
            System.out.println("It's a palindrome list");
        } else {
            System.out.println("It's NOT a palindrome list");
        }
    }

    public static boolean isPalindrome(SinglyLinkedList linkedList) {
        boolean ret = true;
        Stack<Integer> linkedListValues = new Stack<>();

        for (int i = 0; i < linkedList.size(); i++) {
            linkedListValues.push(linkedList.getNth(i));
        }

        for (int i = 0; i < linkedList.size(); i++) {
            if (linkedList.getNth(i) != linkedListValues.pop()) {
                ret = false;
                break;
            }
        }

        return ret;
    }
}
package com.thealgorithms.misc;

import java.util.*;


public class Sort012D {

    public static void main(String args[]) {
        Scanner np = new Scanner(System.in);
        int n = np.nextInt();
        int a[] = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = np.nextInt();
        }
        sort012(a);
    }

    public static void sort012(int[] a) {
        int l = 0;
        int h = a.length - 1;
        int mid = 0;
        int temp;
        while (mid <= h) {
            switch (a[mid]) {
                case 0: {
                    temp = a[l];
                    a[l] = a[mid];
                    a[mid] = temp;
                    l++;
                    mid++;
                    break;
                }
                case 1:
                    mid++;
                    break;
                case 2: {
                    temp = a[mid];
                    a[mid] = a[h];
                    a[h] = temp;
                    h--;
                    break;
                }
            }
        }
        System.out.println("the Sorted array is ");
        for (int i = 0; i < a.length; i++) {
            System.out.print(+a[i] + " ");
        }
    }
}
package com.thealgorithms.misc;

import java.util.Scanner;

public class PalindromePrime {

    public static void main(String[] args) {         Scanner in = new Scanner(System.in);
        System.out.println("Enter the quantity of First Palindromic Primes you want");
        int n = in.nextInt();         functioning(n);         in.close();
    }

    public static boolean prime(int num) {         for (int divisor = 3; divisor <= Math.sqrt(num); divisor += 2) {
            if (num % divisor == 0) {
                return false;             }
        }
        return true;     }

    public static int reverse(int n) {         int reverse = 0;
        while (n != 0) {
            reverse *= 10;
            reverse += n % 10;
            n /= 10;
        }
        return reverse;
    }

    public static void functioning(int y) {
        if (y == 0) {
            return;
        }
        System.out.print(2 + "\n");         int count = 1;
        int num = 3;
        while (count < y) {
            if (num == reverse(num) && prime(num)) {                 count++;                 System.out.print(num + "\n");             }
            num += 2;         }
    }
}
package com.thealgorithms.misc;

import java.util.*;


class Sparcity {

    static double sparcity(double[][] mat) {
        int zero = 0;
                for (int i = 0; i < mat.length; i++) {
            for (int j = 0; j < mat[i].length; j++) {
                if (mat[i][j] == 0) {
                    zero++;
                }
            }
        }
                return ((double) zero / (mat.length * mat[1].length));
    }

        public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("Enter number of rows in matrix: ");
        int n = in.nextInt();
        System.out.println("Enter number of Columns in matrix: ");
        int m = in.nextInt();

        System.out.println("Enter Matrix elements: ");
        double[][] mat = new double[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                mat[i][j] = in.nextDouble();
            }
        }
        System.out.println("Sparcity of matrix is: " + sparcity(mat));
    }
}
package com.thealgorithms.misc;

import java.util.*;

public class RangeInSortedArray {

    public static void main(String[] args) {
                assert Arrays.equals(sortedRange(new int[]{1, 2, 3, 3, 3, 4, 5}, 3), new int[]{2, 4});
        assert Arrays.equals(sortedRange(new int[]{1, 2, 3, 3, 3, 4, 5}, 4), new int[]{5, 5});
        assert Arrays.equals(sortedRange(new int[]{0, 1, 2}, 3), new int[]{-1, -1});
    }

            public static int[] sortedRange(int[] nums, int key) {
        int[] range = new int[]{-1, -1};
        alteredBinSearchIter(nums, key, 0, nums.length - 1, range, true);
        alteredBinSearchIter(nums, key, 0, nums.length - 1, range, false);
        return range;
    }

            public static void alteredBinSearch(
            int[] nums, int key, int left, int right, int[] range, boolean goLeft) {
        if (left > right) {
            return;
        }
        int mid = (left + right) / 2;
        if (nums[mid] > key) {
            alteredBinSearch(nums, key, left, mid - 1, range, goLeft);
        } else if (nums[mid] < key) {
            alteredBinSearch(nums, key, mid + 1, right, range, goLeft);
        } else {
            if (goLeft) {
                if (mid == 0 || nums[mid - 1] != key) {
                    range[0] = mid;
                } else {
                    alteredBinSearch(nums, key, left, mid - 1, range, goLeft);
                }
            } else {
                if (mid == nums.length - 1 || nums[mid + 1] != key) {
                    range[1] = mid;
                } else {
                    alteredBinSearch(nums, key, mid + 1, right, range, goLeft);
                }
            }
        }
    }

            public static void alteredBinSearchIter(
            int[] nums, int key, int left, int right, int[] range, boolean goLeft) {
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > key) {
                right = mid - 1;
            } else if (nums[mid] < key) {
                left = mid + 1;
            } else {
                if (goLeft) {
                    if (mid == 0 || nums[mid - 1] != key) {
                        range[0] = mid;
                        return;
                    } else {
                        right = mid - 1;
                    }
                } else {
                    if (mid == nums.length - 1 || nums[mid + 1] != key) {
                        range[1] = mid;
                        return;
                    } else {
                        left = mid + 1;
                    }
                }
            }
        }
    }

    public static int getCountLessThan(int[] nums, int key) {
        return getLessThan(nums, key, 0, nums.length - 1);
    }

    public static int getLessThan(int[] nums, int key, int left, int right) {
        int count = 0;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > key) {
                right = mid - 1;
            } else if (nums[mid] <= key) {
                count = mid + 1;                 left = mid + 1;
            }
        }
        return count;
    }
}
package com.thealgorithms.misc;

import java.util.Scanner;

public class InverseOfMatrix {

    public static void main(String argv[]) {
        Scanner input = new Scanner(System.in);
        System.out.println("Enter the matrix size (Square matrix only): ");
        int n = input.nextInt();
        double a[][] = new double[n][n];
        System.out.println("Enter the elements of matrix: ");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = input.nextDouble();
            }
        }

        double d[][] = invert(a);
        System.out.println();
        System.out.println("The inverse is: ");
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                System.out.print(d[i][j] + "  ");
            }
            System.out.println();
        }
        input.close();
    }

    public static double[][] invert(double a[][]) {
        int n = a.length;
        double x[][] = new double[n][n];
        double b[][] = new double[n][n];
        int index[] = new int[n];
        for (int i = 0; i < n; ++i) {
            b[i][i] = 1;
        }

                gaussian(a, index);

                for (int i = 0; i < n - 1; ++i) {
            for (int j = i + 1; j < n; ++j) {
                for (int k = 0; k < n; ++k) {
                    b[index[j]][k]
                            -= a[index[j]][i] * b[index[i]][k];
                }
            }
        }

                for (int i = 0; i < n; ++i) {
            x[n - 1][i] = b[index[n - 1]][i] / a[index[n - 1]][n - 1];
            for (int j = n - 2; j >= 0; --j) {
                x[j][i] = b[index[j]][i];
                for (int k = j + 1; k < n; ++k) {
                    x[j][i] -= a[index[j]][k] * x[k][i];
                }
                x[j][i] /= a[index[j]][j];
            }
        }
        return x;
    }

    public static void gaussian(double a[][], int index[]) {
        int n = index.length;
        double c[] = new double[n];

                for (int i = 0; i < n; ++i) {
            index[i] = i;
        }

                for (int i = 0; i < n; ++i) {
            double c1 = 0;
            for (int j = 0; j < n; ++j) {
                double c0 = Math.abs(a[i][j]);
                if (c0 > c1) {
                    c1 = c0;
                }
            }
            c[i] = c1;
        }

                int k = 0;
        for (int j = 0; j < n - 1; ++j) {
            double pi1 = 0;
            for (int i = j; i < n; ++i) {
                double pi0 = Math.abs(a[index[i]][j]);
                pi0 /= c[index[i]];
                if (pi0 > pi1) {
                    pi1 = pi0;
                    k = i;
                }
            }
                        int itmp = index[j];
            index[j] = index[k];
            index[k] = itmp;
            for (int i = j + 1; i < n; ++i) {
                double pj = a[index[i]][j] / a[index[j]][j];

                                a[index[i]][j] = pj;

                                for (int l = j + 1; l < n; ++l) {
                    a[index[i]][l] -= pj * a[index[j]][l];
                }
            }
        }
    }
}
package com.thealgorithms.misc;

import java.util.*;
import java.util.stream.Collectors;

public class TwoSumProblem {

    public static void main(String args[]) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter the target sum ");
        int ts = scan.nextInt();
        System.out.print("Enter the number of elements in the array ");
        int n = scan.nextInt();
        System.out.println("Enter all your array elements:");
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }
        TwoSumProblem t = new TwoSumProblem();
        System.out.println("Brute Force Approach\n" + Arrays.toString(t.BruteForce(arr, ts)) + "\n");
        System.out.println("Two Pointer Approach\n" + Arrays.toString(t.TwoPointer(arr, ts)) + "\n");
        System.out.println("Hashmap Approach\n" + Arrays.toString(t.HashMap(arr, ts)));

    }

    public int[] BruteForce(int[] nums, int target) {
                int ans[] = new int[2];
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    ans[0] = i;
                    ans[1] = j;

                    break;
                }

            }
        }

        return ans;
    }

    public int[] TwoPointer(int[] nums, int target) {
                int ans[] = new int[2];
        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
            hm.put(i, nums[i]);
        }
        HashMap<Integer, Integer> temp
                = hm.entrySet()
                        .stream()
                        .sorted((i1, i2)
                                -> i1.getValue().compareTo(
                                i2.getValue()))
                        .collect(Collectors.toMap(
                                Map.Entry::getKey,
                                Map.Entry::getValue,
                                (e1, e2) -> e1, LinkedHashMap::new));

        int start = 0;
        int end = nums.length - 1;
        while (start < end) {
            int currSum = (Integer) temp.values().toArray()[start] + (Integer) temp.values().toArray()[end];

            if (currSum == target) {
                ans[0] = (Integer) temp.keySet().toArray()[start];
                ans[1] = (Integer) temp.keySet().toArray()[end];
                break;
            } else if (currSum > target) {
                end -= 1;
            } else if (currSum < target) {
                start += 1;
            }

        }
        return ans;

    }

    public int[] HashMap(int[] nums, int target) {
                int ans[] = new int[2];
        HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
            hm.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int t = target - nums[i];
            if (hm.containsKey(t) && hm.get(t) != i) {
                ans[0] = i;
                ans[1] = hm.get(t);
                break;
            }
        }

        return ans;
    }

}
package com.thealgorithms.misc;

import java.util.Scanner;


public class matrixTranspose {

    public static void main(String[] args) {
       
        Scanner sc = new Scanner(System.in);
        int i, j, row, column;
        System.out.println("Enter the number of rows in the 2D matrix:");

        row = sc.nextInt();

        System.out.println("Enter the number of columns in the 2D matrix:");

        column = sc.nextInt();
        int[][] arr = new int[row][column];
        System.out.println("Enter the elements");
        for (i = 0; i < row; i++) {
            for (j = 0; j < column; j++) {
                arr[i][j] = sc.nextInt();
            }
        }

        System.out.println("The matrix is:");
        for (i = 0; i < row; i++) {
            for (j = 0; j < column; j++) {
                System.out.print(arr[i][j] + "\t");
            }
            System.out.print("\n");
        }

      
        System.out.println("The Transpose of the given matrix is:");
        for (i = 0; i < column; i++) {
            for (j = 0; j < row; j++) {
                System.out.print(arr[j][i] + "\t");
            }
            System.out.print("\n");
        }
    }
}
package com.thealgorithms.misc;

import java.awt.Color;


public class ColorContrastRatio {

    
    public double getContrastRatio(Color a, Color b) {
        final double aColorLuminance = getRelativeLuminance(a);
        final double bColorLuminance = getRelativeLuminance(b);

        if (aColorLuminance > bColorLuminance) {
            return (aColorLuminance + 0.05) / (bColorLuminance + 0.05);
        }

        return (bColorLuminance + 0.05) / (aColorLuminance + 0.05);
    }

    
    public double getRelativeLuminance(Color color) {
        final double red = getColor(color.getRed());
        final double green = getColor(color.getGreen());
        final double blue = getColor(color.getBlue());

        return 0.2126 * red + 0.7152 * green + 0.0722 * blue;
    }

    
    public double getColor(int color8Bit) {
        final double sRgb = getColorSRgb(color8Bit);
        return (sRgb <= 0.03928) ? sRgb / 12.92 : Math.pow((sRgb + 0.055) / 1.055, 2.4);
    }

    
    private double getColorSRgb(double color8Bit) {
        return color8Bit / 255.0;
    }

    
    private static void test() {
        final ColorContrastRatio algImpl = new ColorContrastRatio();

        final Color black = Color.BLACK;
        final double blackLuminance = algImpl.getRelativeLuminance(black);
        assert blackLuminance == 0 : "Test 1 Failed - Incorrect relative luminance.";

        final Color white = Color.WHITE;
        final double whiteLuminance = algImpl.getRelativeLuminance(white);
        assert whiteLuminance == 1 : "Test 2 Failed - Incorrect relative luminance.";

        final double highestColorRatio = algImpl.getContrastRatio(black, white);
        assert highestColorRatio == 21 : "Test 3 Failed - Incorrect contrast ratio.";

        final Color foreground = new Color(23, 103, 154);
        final double foregroundLuminance = algImpl.getRelativeLuminance(foreground);
        assert foregroundLuminance == 0.12215748057375966 : "Test 4 Failed - Incorrect relative luminance.";

        final Color background = new Color(226, 229, 248);
        final double backgroundLuminance = algImpl.getRelativeLuminance(background);
        assert backgroundLuminance == 0.7898468477881603 : "Test 5 Failed - Incorrect relative luminance.";

        final double contrastRatio = algImpl.getContrastRatio(foreground, background);
        assert contrastRatio == 4.878363954846178 : "Test 6 Failed - Incorrect contrast ratio.";
    }

    public static void main(String args[]) {
        test();
    }
}
package com.thealgorithms.misc;

import java.util.Collections;
import java.util.PriorityQueue;


public class MedianOfRunningArray {

    private PriorityQueue<Integer> p1;
    private PriorityQueue<Integer> p2;

        public MedianOfRunningArray() {
        this.p1 = new PriorityQueue<>(Collections.reverseOrder());         this.p2 = new PriorityQueue<>();     }

    public void insert(Integer e) {
        p2.add(e);
        if (p2.size() - p1.size() > 1) {
            p1.add(p2.remove());
        }
    }

    public Integer median() {
        if (p1.size() == p2.size()) {
            return (p1.peek() + p2.peek()) / 2;
        }
        return p1.size() > p2.size() ? p1.peek() : p2.peek();
    }

    public static void main(String[] args) {

        MedianOfRunningArray p = new MedianOfRunningArray();
        int arr[] = {10, 7, 4, 9, 2, 3, 11, 17, 14};
        for (int i = 0; i < 9; i++) {
            p.insert(arr[i]);
            System.out.print(p.median() + " ");
        }
    }
}
package com.thealgorithms.misc;

import java.util.*;

public class WordBoggle {

    
    public static List<String> boggleBoard(char[][] board, String[] words) {
        Trie trie = new Trie();
        for (String word : words) {
            trie.add(word);
        }
        Set<String> finalWords = new HashSet<>();
        boolean[][] visited = new boolean[board.length][board.length];
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                explore(i, j, board, trie.root, visited, finalWords);
            }
        }
        return new ArrayList<>(finalWords);
    }

    public static void main(String[] args) {
                List<String> ans
                = new ArrayList<>(
                        Arrays.asList("a", "boggle", "this", "NOTRE_PEATED", "is", "simple", "board"));
        assert (boggleBoard(
                new char[][]{
                    {'t', 'h', 'i', 's', 'i', 's', 'a'},
                    {'s', 'i', 'm', 'p', 'l', 'e', 'x'},
                    {'b', 'x', 'x', 'x', 'x', 'e', 'b'},
                    {'x', 'o', 'g', 'g', 'l', 'x', 'o'},
                    {'x', 'x', 'x', 'D', 'T', 'r', 'a'},
                    {'R', 'E', 'P', 'E', 'A', 'd', 'x'},
                    {'x', 'x', 'x', 'x', 'x', 'x', 'x'},
                    {'N', 'O', 'T', 'R', 'E', '_', 'P'},
                    {'x', 'x', 'D', 'E', 'T', 'A', 'E'},},
                new String[]{
                    "this",
                    "is",
                    "not",
                    "a",
                    "simple",
                    "test",
                    "boggle",
                    "board",
                    "REPEATED",
                    "NOTRE_PEATED",})
                .equals(ans));
    }

    public static void explore(
            int i,
            int j,
            char[][] board,
            TrieNode trieNode,
            boolean[][] visited,
            Set<String> finalWords) {
        if (visited[i][j]) {
            return;
        }

        char letter = board[i][j];
        if (!trieNode.children.containsKey(letter)) {
            return;
        }
        visited[i][j] = true;
        trieNode = trieNode.children.get(letter);
        if (trieNode.children.containsKey('*')) {
            finalWords.add(trieNode.word);
        }

        List<Integer[]> neighbors = getNeighbors(i, j, board);
        for (Integer[] neighbor : neighbors) {
            explore(neighbor[0], neighbor[1], board, trieNode, visited, finalWords);
        }

        visited[i][j] = false;
    }

    public static List<Integer[]> getNeighbors(int i, int j, char[][] board) {
        List<Integer[]> neighbors = new ArrayList<>();
        if (i > 0 && j > 0) {
            neighbors.add(new Integer[]{i - 1, j - 1});
        }

        if (i > 0 && j < board[0].length - 1) {
            neighbors.add(new Integer[]{i - 1, j + 1});
        }

        if (i < board.length - 1 && j < board[0].length - 1) {
            neighbors.add(new Integer[]{i + 1, j + 1});
        }

        if (i < board.length - 1 && j > 0) {
            neighbors.add(new Integer[]{i + 1, j - 1});
        }

        if (i > 0) {
            neighbors.add(new Integer[]{i - 1, j});
        }

        if (i < board.length - 1) {
            neighbors.add(new Integer[]{i + 1, j});
        }

        if (j > 0) {
            neighbors.add(new Integer[]{i, j - 1});
        }

        if (j < board[0].length - 1) {
            neighbors.add(new Integer[]{i, j + 1});
        }

        return neighbors;
    }
}

class TrieNode {

    Map<Character, TrieNode> children = new HashMap<>();
    String word = "";
}

class Trie {

    TrieNode root;
    char endSymbol;

    public Trie() {
        this.root = new TrieNode();
        this.endSymbol = '*';
    }

    public void add(String str) {
        TrieNode node = this.root;
        for (int i = 0; i < str.length(); i++) {
            char letter = str.charAt(i);
            if (!node.children.containsKey(letter)) {
                TrieNode newNode = new TrieNode();
                node.children.put(letter, newNode);
            }
            node = node.children.get(letter);
        }
        node.children.put(this.endSymbol, null);
        node.word = str;
    }
}
package com.thealgorithms.misc;

import java.util.*;

public class ThreeSumProblem {

    public static void main(String args[]) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter the target sum ");
        int ts = scan.nextInt();
        System.out.print("Enter the number of elements in the array ");
        int n = scan.nextInt();
        System.out.println("Enter all your array elements:");
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scan.nextInt();
        }
        ThreeSumProblem th = new ThreeSumProblem();
        System.out.println("Brute Force Approach\n" + (th.BruteForce(arr, ts)) + "\n");
        System.out.println("Two Pointer Approach\n" + (th.TwoPointer(arr, ts)) + "\n");
        System.out.println("Hashmap Approach\n" + (th.Hashmap(arr, ts)));

    }

    public List<List<Integer>> BruteForce(int[] nums, int target) {
        List<List<Integer>> arr = new ArrayList<List<Integer>>();

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                for (int k = j + 1; k < nums.length; k++) {
                    if (nums[i] + nums[j] + nums[k] == target) {
                        List<Integer> temp = new ArrayList<>();
                        temp.add(nums[i]);
                        temp.add(nums[j]);
                        temp.add(nums[k]);
                        Collections.sort(temp);
                        arr.add(temp);
                    }

                }
            }
        }
        arr = new ArrayList<List<Integer>>(new LinkedHashSet<List<Integer>>(arr));
        return arr;
    }

    public List<List<Integer>> TwoPointer(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> arr = new ArrayList<List<Integer>>();
        int start = 0;
        int end = 0;
        int i = 0;
        while (i < nums.length - 1) {
            start = i + 1;
            end = nums.length - 1;
            while (start < end) {
                if (nums[start] + nums[end] + nums[i] == target) {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums[i]);
                    temp.add(nums[start]);
                    temp.add(nums[end]);
                    arr.add(temp);
                    start++;
                    end--;
                } else if (nums[start] + nums[end] + nums[i] < target) {
                    start += 1;
                } else {
                    end -= 1;
                }

            }
            i++;
        }
        Set<List<Integer>> set = new LinkedHashSet<List<Integer>>(arr);
        return new ArrayList<List<Integer>>(set);
    }

    public List<List<Integer>> Hashmap(int[] nums, int target) {
        Arrays.sort(nums);
        Set<List<Integer>> ts = new HashSet();
        HashMap<Integer, Integer> hm = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            hm.put(nums[i], i);
        }

        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                int t = target - nums[i] - nums[j];
                if (hm.containsKey(t) && hm.get(t) > j) {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums[i]);
                    temp.add(nums[j]);
                    temp.add(t);
                    ts.add(temp);
                }
            }
        }
        return new ArrayList(ts);
    }

}
package com.thealgorithms.searches;

import java.util.Scanner;

public class LinearSearchThread {
    public static void main(String[] args) {
        int[] list = new int[200];
        for (int j = 0; j < list.length; j++) {
            list[j] = (int) (Math.random() * 100);
        }
        for (int y : list) {
            System.out.print(y + " ");
        }
        System.out.println();
        System.out.print("Enter number to search for: ");
        Scanner in = new Scanner(System.in);
        int x = in.nextInt();
        Searcher t = new Searcher(list, 0, 50, x);
        Searcher t1 = new Searcher(list, 50, 100, x);
        Searcher t2 = new Searcher(list, 100, 150, x);
        Searcher t3 = new Searcher(list, 150, 200, x);
        t.start();
        t1.start();
        t2.start();
        t3.start();
        try {
            t.join();
            t1.join();
            t2.join();
            t3.join();
        } catch (InterruptedException e) {
        }
        boolean found = t.getResult() || t1.getResult() || t2.getResult() || t3.getResult();
        System.out.println("Found = " + found);
    }
}

class Searcher extends Thread {
    private final int[] arr;
    private final int left, right;
    private final int x;
    private boolean found;

    Searcher(int[] arr, int left, int right, int x) {
        this.arr = arr;
        this.left = left;
        this.right = right;
        this.x = x;
    }

    @Override
    public void run() {
        int k = left;
        found = false;
        while (k < right && !found) {
            if (arr[k++] == x) {
                found = true;
            }
        }
    }

    boolean getResult() {
        return found;
    }
}
package com.thealgorithms.searches;

import java.util.*;

public class UnionFind {

    private int[] p;
    private int[] r;

    public UnionFind(int n) {
        p = new int[n];
        r = new int[n];

        for (int i = 0; i < n; i++) {
            p[i] = i;
        }
    }

    public int find(int i) {
        int parent = p[i];

        if (i == parent) {
            return i;
        }

        return p[i] = find(parent);
    }

    public void union(int x, int y) {
        int r0 = find(x);
        int r1 = find(y);

        if (r1 == r0) {
            return;
        }

        if (r[r0] > r[r1]) {
            p[r1] = r0;
        } else if (r[r1] > r[r0]) {
            p[r0] = r1;
        } else {
            p[r1] = r0;
            r[r0]++;
        }
    }

    public int count() {
        List parents = new ArrayList();
        for (int i = 0; i < p.length; i++) {
            if (!parents.contains(find(i))) {
                parents.add(find(i));
            }
        }
        return parents.size();
    }

    public String toString() {
        return "p " + Arrays.toString(p) + " r " + Arrays.toString(r) + "\n";
    }

        public static void main(String[] args) {
        UnionFind uf = new UnionFind(5);
        System.out.println("init /w 5 (should print 'p [0, 1, 2, 3, 4] r [0, 0, 0, 0, 0]'):");
        System.out.println(uf);

        uf.union(1, 2);
        System.out.println("union 1 2 (should print 'p [0, 1, 1, 3, 4] r [0, 1, 0, 0, 0]'):");
        System.out.println(uf);

        uf.union(3, 4);
        System.out.println("union 3 4 (should print 'p [0, 1, 1, 3, 3] r [0, 1, 0, 1, 0]'):");
        System.out.println(uf);

        uf.find(4);
        System.out.println("find 4 (should print 'p [0, 1, 1, 3, 3] r [0, 1, 0, 1, 0]'):");
        System.out.println(uf);

        System.out.println("count (should print '3'):");
        System.out.println(uf.count());
    }
}
package com.thealgorithms.searches;

import java.util.Scanner;


public class SquareRootBinarySearch {

    
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a number you want to calculate square root of : ");
        int num = sc.nextInt();
        long ans = squareRoot(num);
        System.out.println("The square root is : " + ans);
    }

    
    private static long squareRoot(long num) {
        if (num == 0 || num == 1) {
            return num;
        }
        long l = 1;
        long r = num;
        long ans = 0;
        while (l <= r) {
            long mid = l + (r - l) / 2;
            if (mid == num / mid) {
                return mid;
            } else if (mid < num / mid) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Arrays;
import java.util.Random;
import java.util.stream.Stream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;


public final class IterativeBinarySearch implements SearchAlgorithm {

    
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        int l, r, k, cmp;

        l = 0;
        r = array.length - 1;

        while (l <= r) {
            k = (l + r) >>> 1;
            cmp = key.compareTo(array[k]);

            if (cmp == 0) {
                return k;
            } else if (cmp < 0) {
                r = --k;
            } else {
                l = ++k;
            }
        }

        return -1;
    }

        public static void main(String[] args) {
        Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        Integer[] integers
                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);

                Integer shouldBeFound = integers[r.nextInt(size - 1)];

        IterativeBinarySearch search = new IterativeBinarySearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                String.format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));
    }
}
package com.thealgorithms.searches;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;


public class DepthFirstSearch {

    static class Node {

        private final String name;
        private final List<Node> subNodes;

        public Node(final String name) {
            this.name = name;
            this.subNodes = new ArrayList<>();
        }

        public Node(final String name, final List<Node> subNodes) {
            this.name = name;
            this.subNodes = subNodes;
        }

        public String getName() {
            return name;
        }

        public List<Node> getSubNodes() {
            return subNodes;
        }
    }

    public static Optional<Node> search(final Node node, final String name) {
        if (node.getName().equals(name)) {
            return Optional.of(node);
        }

        return node.getSubNodes()
                .stream()
                .map(value -> search(value, name))
                .flatMap(Optional::stream)
                .findAny();
    }

    public static void assertThat(final Object actual, final Object expected) {
        if (!Objects.equals(actual, expected)) {
            throw new AssertionError(String.format("expected=%s but was actual=%s", expected, actual));
        }
    }

    public static void main(final String[] args) {
        final Node rootNode = new Node("A", List.of(
                new Node("B", List.of(new Node("D"), new Node("F", List.of(
                        new Node("H"), new Node("I")
                )))),
                new Node("C", List.of(new Node("G"))),
                new Node("E")
        ));

        {
            final String expected = "I";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }

        {
            final String expected = "G";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }

        {
            final String expected = "E";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }
    }
}
package com.thealgorithms.searches;

import java.util.Random;
import java.util.stream.Stream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;


public class LinearSearch implements SearchAlgorithm {

    
    @Override
    public <T extends Comparable<T>> int find(T[] array, T value) {
        for (int i = 0; i < array.length; i++) {
            if (array[i].compareTo(value) == 0) {
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
                Random r = new Random();
        int size = 200;
        int maxElement = 100;
        Integer[] integers
                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).toArray(Integer[]::new);

                Integer shouldBeFound = integers[r.nextInt(size - 1)];

        LinearSearch search = new LinearSearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                String.format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;


class UpperBound implements SearchAlgorithm {

        public static void main(String[] args) {
                Random r = ThreadLocalRandom.current();

        int size = 100;
        int maxElement = 100000;

        Integer[] integers
                = IntStream.generate(() -> r.nextInt(maxElement))
                        .limit(size)
                        .sorted()
                        .boxed()
                        .toArray(Integer[]::new);

                int val = integers[r.nextInt(size - 1)] + 1;

        UpperBound search = new UpperBound();
        int atIndex = search.find(integers, val);

        System.out.println(
                format(
                        "Val: %d. Upper Bound Found %d at index %d. An array length %d",
                        val, integers[atIndex], atIndex, size));

        boolean toCheck = integers[atIndex] > val || integers[size - 1] < val;
        System.out.println(
                format(
                        "Upper Bound found at an index: %d. Is greater or max element: %b", atIndex, toCheck));
    }

    
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        return search(array, key, 0, array.length - 1);
    }

    
    private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) {
        if (right <= left) {
            return left;
        }

                int median = (left + right) >>> 1;
        int comp = key.compareTo(array[median]);

        if (comp < 0) {
                        return search(array, key, left, median);
        } else {
                        return search(array, key, median + 1, right);
        }
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Arrays;
import java.util.Random;
import java.util.stream.Stream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;


public class IterativeTernarySearch implements SearchAlgorithm {

    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        int left = 0;
        int right = array.length - 1;

        while (right > left) {

            int leftCmp = array[left].compareTo(key);
            int rightCmp = array[right].compareTo(key);
            if (leftCmp == 0) {
                return left;
            }
            if (rightCmp == 0) {
                return right;
            }

            int leftThird = left + (right - left) / 3 + 1;
            int rightThird = right - (right - left) / 3 - 1;

            if (array[leftThird].compareTo(key) <= 0) {
                left = leftThird;
            } else {
                right = rightThird;
            }
        }

        return -1;
    }

    public static void main(String[] args) {
                Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        Integer[] integers
                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);

                Integer shouldBeFound = integers[r.nextInt(size - 1)];

        IterativeTernarySearch search = new IterativeTernarySearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));
    }
}
package com.thealgorithms.searches;

import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;

import static java.lang.String.format;

class ExponentialSearch implements SearchAlgorithm {

    public static void main(String[] args) {
        Random r = ThreadLocalRandom.current();

        int size = 100;
        int maxElement = 100000;

        Integer[] integers
                = IntStream.generate(() -> r.nextInt(maxElement))
                        .limit(size)
                        .sorted()
                        .boxed()
                        .toArray(Integer[]::new);

                int shouldBeFound = integers[r.nextInt(size - 1)];

        ExponentialSearch search = new ExponentialSearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));

    }

    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        if (array[0] == key) {
            return 0;
        }
        if (array[array.length - 1] == key) {
            return array.length;
        }

        int range = 1;

        while (range < array.length && array[range].compareTo(key) <= -1) {
            range = range * 2;
        }

        return Arrays.binarySearch(array, range / 2, Math.min(range, array.length), key);
    }
}
package com.thealgorithms.searches;

import com.thealgorithms.searches.DepthFirstSearch.Node;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;


public class BreadthFirstSearch {

    public static Optional<Node> search(final Node node, final String name) {
        if (node.getName().equals(name)) {
            return Optional.of(node);
        }

        List<Node> queue = new ArrayList<>(node.getSubNodes());

        while (!queue.isEmpty()) {
            final Node current = queue.get(0);

            if (current.getName().equals(name)) {
                return Optional.of(current);
            }

            queue.addAll(current.getSubNodes());

            queue.remove(0);
        }

        return Optional.empty();
    }

    public static void assertThat(final Object actual, final Object expected) {
        if (!Objects.equals(actual, expected)) {
            throw new AssertionError(String.format("expected=%s but was actual=%s", expected, actual));
        }
    }

    public static void main(final String[] args) {
        final Node rootNode = new Node("A", List.of(
                new Node("B", List.of(new Node("D"), new Node("F", List.of(
                        new Node("H"), new Node("I")
                )))),
                new Node("C", List.of(new Node("G"))),
                new Node("E")
        ));

        {
            final String expected = "I";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }

        {
            final String expected = "G";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }

        {
            final String expected = "E";

            final Node result = search(rootNode, expected)
                    .orElseThrow(() -> new AssertionError("Node not found!"));

            assertThat(result.getName(), expected);
        }
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Arrays;
import java.util.Random;
import java.util.stream.IntStream;


class InterpolationSearch {

    
    public int find(int array[], int key) {
                int start = 0, end = (array.length - 1);

                        while (start <= end && key >= array[start] && key <= array[end]) {
                                    int pos = start + (((end - start) / (array[end] - array[start])) * (key - array[start]));

                        if (array[pos] == key) {
                return pos;
            }

                        if (array[pos] < key) {
                start = pos + 1;
            }             else {
                end = pos - 1;
            }
        }
        return -1;
    }

        public static void main(String[] args) {
        Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        int[] integers = IntStream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray();

                Integer shouldBeFound = integers[r.nextInt(size - 1)];

        InterpolationSearch search = new InterpolationSearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                String.format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));
    }
}
package com.thealgorithms.searches;

import java.util.Scanner;


public class SaddlebackSearch {

    
    private static int[] find(int arr[][], int row, int col, int key) {

                int ans[] = {-1, -1};
        if (row < 0 || col >= arr[row].length) {
            return ans;
        }
        if (arr[row][col] == key) {
            ans[0] = row;
            ans[1] = col;
            return ans;
        }         else if (arr[row][col] > key) {
            return find(arr, row - 1, col, key);
        }
                return find(arr, row, col + 1, key);
    }

    
    public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
        int arr[][];
        int i, j, rows = sc.nextInt(), col = sc.nextInt();
        arr = new int[rows][col];
        for (i = 0; i < rows; i++) {
            for (j = 0; j < col; j++) {
                arr[i][j] = sc.nextInt();
            }
        }
        int ele = sc.nextInt();
                int ans[] = find(arr, rows - 1, 0, ele);
        System.out.println(ans[0] + " " + ans[1]);
        sc.close();
    }
}
package com.thealgorithms.searches;

class PerfectBinarySearch {

    static int binarySearch(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;

        while (low <= high) {
            int mid = (low + high) / 2;

            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        PerfectBinarySearch BinarySearch = new PerfectBinarySearch();
        int[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        assert BinarySearch.binarySearch(array, -1) == -1;
        assert BinarySearch.binarySearch(array, 11) == -1;
    }
}
package com.thealgorithms.searches;

import java.util.*;


public final class QuickSelect {

    
    public static <T extends Comparable<T>> T select(List<T> list, int n) {
        Objects.requireNonNull(list, "The list of elements must not be null.");

        if (list.size() == 0) {
            String msg = "The list of elements must not be empty.";
            throw new IllegalArgumentException(msg);
        }

        if (n < 0) {
            String msg = "The index must not be negative.";
            throw new IndexOutOfBoundsException(msg);
        }

        if (n >= list.size()) {
            String msg = "The index must be less than the number of elements.";
            throw new IndexOutOfBoundsException(msg);
        }

        int index = selectIndex(list, n);
        return list.get(index);
    }

    private static <T extends Comparable<T>> int selectIndex(List<T> list, int n) {
        return selectIndex(list, 0, list.size() - 1, n);
    }

    private static <T extends Comparable<T>> int selectIndex(
            List<T> list,
            int left,
            int right,
            int n
    ) {
        while (true) {
            if (left == right)
                return left;
            int pivotIndex = pivot(list, left, right);
            pivotIndex = partition(list, left, right, pivotIndex, n);
            if (n == pivotIndex) {
                return n;
            } else if (n < pivotIndex) {
                right = pivotIndex - 1;
            } else {
                left = pivotIndex + 1;
            }
        }
    }

    private static <T extends Comparable<T>> int partition(
            List<T> list,
            int left,
            int right,
            int pivotIndex,
            int n
    ) {
        T pivotValue = list.get(pivotIndex);
        Collections.swap(list, pivotIndex, right);
        int storeIndex = left;

        for (int i = left; i < right; i++) {
            if (list.get(i).compareTo(pivotValue) < 0) {
                Collections.swap(list, storeIndex, i);
                storeIndex++;
            }
        }

        int storeIndexEq = storeIndex;

        for (int i = storeIndex; i < right; i++) {
            if (list.get(i).compareTo(pivotValue) == 0) {
                Collections.swap(list, storeIndexEq, i);
                storeIndexEq++;
            }
        }

        Collections.swap(list, right, storeIndexEq);

        return (n < storeIndex)
                ? storeIndex
                : Math.min(n, storeIndexEq);
    }

    private static <T extends Comparable<T>> int pivot(
            List<T> list,
            int left,
            int right
    ) {
        if (right - left < 5) {
            return partition5(list, left, right);
        }

        for (int i = left; i < right; i += 5) {
            int subRight = i + 4;
            if (subRight > right) {
                subRight = right;
            }
            int median5 = partition5(list, i, subRight);
            int rightIndex = left + (i - left) / 5;
            Collections.swap(list, median5, rightIndex);
        }

        int mid = (right - left) / 10 + left + 1;
        int rightIndex = left + (right - left) / 5;
        return selectIndex(list, left, rightIndex, mid);
    }

    private static <T extends Comparable<T>> int partition5(
            List<T> list,
            int left,
            int right
    ) {
        List<T> ts = list.subList(left, right);
        ts.sort(Comparator.naturalOrder());
        return (left + right) >>> 1;
    }
}
package com.thealgorithms.searches;

import com.thealgorithms.devutils.searches.SearchAlgorithm;

public class FibonacciSearch implements SearchAlgorithm {

    
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        int fibMinus1 = 1;
        int fibMinus2 = 0;
        int fibNumber = fibMinus1 + fibMinus2;
        int n = array.length;

        while (fibNumber < n) {
            fibMinus2 = fibMinus1;
            fibMinus1 = fibNumber;
            fibNumber = fibMinus2 + fibMinus1;
        }

        int offset = -1;

        while (fibNumber > 1) {
            int i = Math.min(offset + fibMinus2, n - 1);

            if (array[i].compareTo(key) < 0) {
                fibNumber = fibMinus1;
                fibMinus1 = fibMinus2;
                fibMinus2 = fibNumber - fibMinus1;
                offset = i;
            } else if (array[i].compareTo(key) > 0) {
                fibNumber = fibMinus2;
                fibMinus1 = fibMinus1 - fibMinus2;
                fibMinus2 = fibNumber - fibMinus1;
            } else {
                return i;
            }
        }

        if (fibMinus1 == 1 && array[offset + 1] == key) {
            return offset + 1;
        }

        return -1;
    }

        public static void main(String[] args) {
        Integer[] integers = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512};

        int size = integers.length;
        Integer shouldBeFound = 128;
        FibonacciSearch fsearch = new FibonacciSearch();
        int atIndex = fsearch.find(integers, shouldBeFound);

        System.out.println(
                "Should be found: " + shouldBeFound + ". Found " + integers[atIndex] + " at index " + atIndex + ". An array length " + size);
    }

}
package com.thealgorithms.searches;

import java.util.Collections;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Random;


public class MonteCarloTreeSearch {

    public class Node {

        Node parent;
        ArrayList<Node> childNodes;
        boolean isPlayersTurn;         boolean playerWon;         int score;
        int visitCount;

        public Node() {
        }

        public Node(Node parent, boolean isPlayersTurn) {
            this.parent = parent;
            childNodes = new ArrayList<>();
            this.isPlayersTurn = isPlayersTurn;
            playerWon = false;
            score = 0;
            visitCount = 0;
        }
    }

    static final int WIN_SCORE = 10;
    static final int TIME_LIMIT = 500; 
    public static void main(String[] args) {
        MonteCarloTreeSearch mcts = new MonteCarloTreeSearch();

        mcts.monteCarloTreeSearch(mcts.new Node(null, true));
    }

    
    public Node monteCarloTreeSearch(Node rootNode) {
        Node winnerNode;
        double timeLimit;

                addChildNodes(rootNode, 10);

        timeLimit = System.currentTimeMillis() + TIME_LIMIT;

                while (System.currentTimeMillis() < timeLimit) {
            Node promisingNode;

                        promisingNode = getPromisingNode(rootNode);

                        if (promisingNode.childNodes.size() == 0) {
                addChildNodes(promisingNode, 10);
            }

            simulateRandomPlay(promisingNode);
        }

        winnerNode = getWinnerNode(rootNode);
        printScores(rootNode);
        System.out.format("\nThe optimal node is: %02d\n", rootNode.childNodes.indexOf(winnerNode) + 1);

        return winnerNode;
    }

    public void addChildNodes(Node node, int childCount) {
        for (int i = 0; i < childCount; i++) {
            node.childNodes.add(new Node(node, !node.isPlayersTurn));
        }
    }

    
    public Node getPromisingNode(Node rootNode) {
        Node promisingNode = rootNode;

                while (promisingNode.childNodes.size() != 0) {
            double uctIndex = Double.MIN_VALUE;
            int nodeIndex = 0;

                                    for (int i = 0; i < promisingNode.childNodes.size(); i++) {
                Node childNode = promisingNode.childNodes.get(i);
                double uctTemp;

                                                if (childNode.visitCount == 0) {
                    nodeIndex = i;
                    break;
                }

                uctTemp = ((double) childNode.score / childNode.visitCount)
                        + 1.41 * Math.sqrt(Math.log(promisingNode.visitCount) / (double) childNode.visitCount);

                if (uctTemp > uctIndex) {
                    uctIndex = uctTemp;
                    nodeIndex = i;
                }
            }

            promisingNode = promisingNode.childNodes.get(nodeIndex);
        }

        return promisingNode;
    }

    
    public void simulateRandomPlay(Node promisingNode) {
        Random rand = new Random();
        Node tempNode = promisingNode;
        boolean isPlayerWinner;

                                                promisingNode.playerWon = (rand.nextInt(6) == 0);

        isPlayerWinner = promisingNode.playerWon;

                while (tempNode != null) {
            tempNode.visitCount++;

                        if ((tempNode.isPlayersTurn && isPlayerWinner)
                    || (!tempNode.isPlayersTurn && !isPlayerWinner)) {
                tempNode.score += WIN_SCORE;
            }

            tempNode = tempNode.parent;
        }
    }

    public Node getWinnerNode(Node rootNode) {
        return Collections.max(rootNode.childNodes, Comparator.comparing(c -> c.score));
    }

    public void printScores(Node rootNode) {
        System.out.println("N.\tScore\t\tVisits");

        for (int i = 0; i < rootNode.childNodes.size(); i++) {
            System.out.println(String.format("%02d\t%d\t\t%d", i + 1,
                    rootNode.childNodes.get(i).score, rootNode.childNodes.get(i).visitCount));
        }
    }
}
package com.thealgorithms.searches;

import java.util.*;

class HowManyTimesRotated {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }

        System.out.println("The array has been rotated " + rotated(a) + " times");
        sc.close();

    }

    public static int rotated(int[] a) {
        int low = 0;
        int high = a.length - 1;
        int mid = 0; 
        while (low <= high) {
            mid = low + (high - low) / 2;

            if (a[mid] < a[mid - 1] && a[mid] < a[mid + 1]) {
                break;
            } else if (a[mid] > a[mid - 1] && a[mid] < a[mid + 1]) {
                high = mid + 1;
            } else if (a[mid] > a[mid - 1] && a[mid] > a[mid + 1]) {
                low = mid - 1;
            }
        }

        return mid;
    }
}
package com.thealgorithms.searches;

import com.thealgorithms.devutils.searches.SearchAlgorithm;

public class JumpSearch implements SearchAlgorithm {

    public static void main(String[] args) {
        JumpSearch jumpSearch = new JumpSearch();
        Integer[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        for (int i = 0; i < array.length; i++) {
            assert jumpSearch.find(array, i) == i;
        }
        assert jumpSearch.find(array, -1) == -1;
        assert jumpSearch.find(array, 11) == -1;
    }

    
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        int length = array.length;
        int blockSize = (int) Math.sqrt(length);

        int limit = blockSize;
        while (key.compareTo(array[limit]) > 0 && limit < array.length - 1) {
            limit = Math.min(limit + blockSize, array.length - 1);
        }

        for (int i = limit - blockSize; i <= limit; i++) {
            if (array[i] == key) {
                return i;
            }
        }
        return -1;
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;


class BinarySearch implements SearchAlgorithm {

    
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        return search(array, key, 0, array.length);
    }

    
    private <T extends Comparable<T>> int search(T array[], T key, int left, int right) {
        if (right < left) {
            return -1;         }
                int median = (left + right) >>> 1;
        int comp = key.compareTo(array[median]);

        if (comp == 0) {
            return median;
        } else if (comp < 0) {
            return search(array, key, left, median - 1);
        } else {
            return search(array, key, median + 1, right);
        }
    }

        public static void main(String[] args) {
                Random r = ThreadLocalRandom.current();

        int size = 100;
        int maxElement = 100000;

        Integer[] integers
                = IntStream.generate(() -> r.nextInt(maxElement))
                        .limit(size)
                        .sorted()
                        .boxed()
                        .toArray(Integer[]::new);

                int shouldBeFound = integers[r.nextInt(size - 1)];

        BinarySearch search = new BinarySearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.IntStream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;


class LowerBound implements SearchAlgorithm {

        public static void main(String[] args) {
                Random r = ThreadLocalRandom.current();

        int size = 100;
        int maxElement = 100000;

        Integer[] integers
                = IntStream.generate(() -> r.nextInt(maxElement))
                        .limit(size)
                        .sorted()
                        .boxed()
                        .toArray(Integer[]::new);

                int val = integers[r.nextInt(size - 1)] + 1;

        LowerBound search = new LowerBound();
        int atIndex = search.find(integers, val);

        System.out.println(
                format(
                        "Val: %d. Lower Bound Found %d at index %d. An array length %d",
                        val, integers[atIndex], atIndex, size));

        boolean toCheck = integers[atIndex] >= val || integers[size - 1] < val;
        System.out.println(
                format(
                        "Lower Bound found at an index: %d. Is greater or max element: %b", atIndex, toCheck));
    }

    
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        return search(array, key, 0, array.length - 1);
    }

    
    private <T extends Comparable<T>> int search(T[] array, T key, int left, int right) {
        if (right <= left) {
            return left;
        }

                int median = (left + right) >>> 1;
        int comp = key.compareTo(array[median]);

        if (comp == 0) {
            return median;
        } else if (comp < 0) {
                        return search(array, key, left, median);
        } else {
                        return search(array, key, median + 1, right);
        }
    }
}
package com.thealgorithms.searches;

import static java.lang.String.format;

import java.util.Arrays;
import java.util.Random;
import java.util.stream.Stream;
import com.thealgorithms.devutils.searches.SearchAlgorithm;


public class TernarySearch implements SearchAlgorithm {

    
    @Override
    public <T extends Comparable<T>> int find(T[] arr, T value) {
        return ternarySearch(arr, value, 0, arr.length - 1);
    }

    
    private <T extends Comparable<T>> int ternarySearch(T[] arr, T key, int start, int end) {
        if (start > end) {
            return -1;
        }
        int mid1 = start + (end - start) / 3;
        int mid2 = start + 2 * (end - start) / 3;

        if (key.compareTo(arr[mid1]) == 0) {
            return mid1;
        } else if (key.compareTo(arr[mid2]) == 0) {
            return mid2;
        } else if (key.compareTo(arr[mid1]) < 0) {
            return ternarySearch(arr, key, start, --mid1);
        } else if (key.compareTo(arr[mid2]) > 0) {
            return ternarySearch(arr, key, ++mid2, end);
        } else {
            return ternarySearch(arr, key, mid1, mid2);
        }
    }

    public static void main(String[] args) {
                Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        Integer[] integers
                = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);

                Integer shouldBeFound = integers[r.nextInt(size - 1)];

        TernarySearch search = new TernarySearch();
        int atIndex = search.find(integers, shouldBeFound);

        System.out.println(
                format(
                        "Should be found: %d. Found %d at index %d. An array length %d",
                        shouldBeFound, integers[atIndex], atIndex, size));

        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(
                format(
                        "Found by system method at an index: %d. Is equal: %b", toCheck, toCheck == atIndex));
    }
}
package com.thealgorithms.matrixexponentiation;

import java.util.Scanner;


public class Fibonacci {

        private static final int[][] fibMatrix = {{1, 1}, {1, 0}};
    private static final int[][] identityMatrix = {{1, 0}, {0, 1}};
        private static final int[][] baseFibNumbers = {{1}, {0}};

    
    private static int[][] matrixMultiplication(int[][] matrix1, int[][] matrix2) {
                int rowsInMatrix1 = matrix1.length;
        int columnsInMatrix1 = matrix1[0].length;

        int rowsInMatrix2 = matrix2.length;
        int columnsInMatrix2 = matrix2[0].length;

        assert columnsInMatrix1 == rowsInMatrix2;
        int[][] product = new int[rowsInMatrix1][columnsInMatrix2];
        for (int rowIndex = 0; rowIndex < rowsInMatrix1; rowIndex++) {
            for (int colIndex = 0; colIndex < columnsInMatrix2; colIndex++) {
                int matrixEntry = 0;
                for (int intermediateIndex = 0; intermediateIndex < columnsInMatrix1; intermediateIndex++) {
                    matrixEntry += matrix1[rowIndex][intermediateIndex] * matrix2[intermediateIndex][colIndex];
                }
                product[rowIndex][colIndex] = matrixEntry;
            }
        }
        return product;
    }

    
    public static int[][] fib(int n) {
        if (n == 0) {
            return Fibonacci.identityMatrix;
        } else {
            int[][] cachedResult = fib(n / 2);
            int[][] matrixExpResult = matrixMultiplication(cachedResult, cachedResult);
            if (n % 2 == 0) {
                return matrixExpResult;
            } else {
                return matrixMultiplication(Fibonacci.fibMatrix, matrixExpResult);
            }
        }
    }

    public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] result = matrixMultiplication(fib(n), baseFibNumbers);
        System.out.println("Fib(" + n + ") = " + result[1][0]);
        sc.close();
    }
}
package com.thealgorithms.strings;

import java.util.Scanner;

class LongestPalindromicSubstring {

    public static void main(String[] args) {
        Solution s = new Solution();
        String str = "";
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the string: ");
        str = sc.nextLine();
        System.out.println("Longest substring is : " + s.longestPalindrome(str));
    }
}

class Solution {

    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }
        int n = s.length();
        String maxStr = "";
        for (int i = 0; i < n; ++i) {
            for (int j = i; j < n; ++j) {
                if (isValid(s, i, j) == true) {
                    if (j - i + 1 > maxStr.length()) {                         maxStr = s.substring(i, j + 1);
                    }
                }
            }
        }
        return maxStr;
    }

    private boolean isValid(String s, int lo, int hi) {
        int n = hi - lo + 1;
        for (int i = 0; i < n / 2; ++i) {
            if (s.charAt(lo + i) != s.charAt(hi - i)) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;

import java.util.HashMap;


public class HorspoolSearch {

    private static HashMap<Character, Integer> shiftValues;     private static Integer patternLength;
    private static int comparisons = 0; 
    
    public static int findFirst(String pattern, String text) {
        return firstOccurrence(pattern, text, true);
    }

    
    public static int findFirstInsensitive(String pattern, String text) {
        return firstOccurrence(pattern, text, false);
    }

    
    public static Integer getLastComparisons() {
        return HorspoolSearch.comparisons;
    }

    
    private static int firstOccurrence(String pattern, String text, boolean caseSensitive) {
        shiftValues = calcShiftValues(pattern);         comparisons = 0; 
        int textIndex
                = pattern.length() - 1; 
                while (textIndex < text.length()) {

                        int i = pattern.length() - 1;
            while (i >= 0) {
                comparisons++;
                char patternChar = pattern.charAt(i);
                char textChar = text.charAt((textIndex + i) - (pattern.length() - 1));
                if (!charEquals(patternChar, textChar, caseSensitive)) {                     textIndex += getShiftValue(text.charAt(textIndex));
                    break;
                }
                i--;
            }

                        if (i == -1) {
                return textIndex - pattern.length() + 1;
            }
        }

                return -1;
    }

    
    private static boolean charEquals(char c1, char c2, boolean caseSensitive) {
        if (caseSensitive) {
            return c1 == c2;
        }
        return Character.toLowerCase(c1) == Character.toLowerCase(c2);
    }

    
    private static HashMap<Character, Integer> calcShiftValues(String pattern) {
        patternLength = pattern.length();
        HashMap<Character, Integer> table = new HashMap<>();

        for (int i = pattern.length() - 2;
                i >= 0;
                i--) {             char c = pattern.charAt(i);
            int finalI = i;
            table.computeIfAbsent(c, k -> pattern.length() - 1 - finalI);
        }

        return table;
    }

    
    private static Integer getShiftValue(char c) {
        if (shiftValues.get(c) != null) {
            return shiftValues.get(c);
        } else {
            return patternLength;
        }
    }
}
package com.thealgorithms.strings;
public class PermuteString {

        public static String swapString(String a, int i, int j) {
        char[] b = a.toCharArray();
        char ch;
        ch = b[i];
        b[i] = b[j];
        b[j] = ch;
        return String.valueOf(b);
    }

    public static void main(String[] args) {
        String str = "ABC";
        int len = str.length();
        System.out.println("All the permutations of the string are: ");
        generatePermutation(str, 0, len);
    }

        public static void generatePermutation(String str, int start, int end) {
                if (start == end - 1) {
            System.out.println(str);
        } else {
            for (int i = start; i < end; i++) {
                                str = swapString(str, start, i);
                                generatePermutation(str, start + 1, end);
                                str = swapString(str, start, i);
            }
        }
    }
}
package com.thealgorithms.strings;

public class CharactersSame {

    
    public static void main(String[] args) {
        assert isAllCharactersSame("");
        assert !isAllCharactersSame("aab");
        assert isAllCharactersSame("aaa");
        assert isAllCharactersSame("11111");
    }

    
    public static boolean isAllCharactersSame(String s) {
        for (int i = 1, length = s.length(); i < length; ++i) {
            if (s.charAt(i) != s.charAt(0)) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;


public class CheckVowels {
    private static final Set<Character> VOWELS = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));

    
    public static boolean hasVowels(String input) {
        return countVowels(input) > 0;
    }

    
    public static int countVowels(String input) {
        if (input == null) {
            return 0;
        }
        int cnt = 0;
        for (char c : input.toLowerCase().toCharArray()) {
            if (VOWELS.contains(c)) {
                ++cnt;
            }
        }
        return cnt;
    }
}
package com.thealgorithms.strings;

import java.util.Arrays;
import java.util.HashMap;



public class Anagrams {
        public static void main(String[] args) {
        String first = "deal";
        String second = "lead";
                Anagrams nm = new Anagrams();
        System.out.println(nm.approach2(first, second)); 
        System.out.println(nm.approach1(first, second)); 
        System.out.println(nm.approach3(first, second)); 
        System.out.println(nm.approach4(first, second));  

        
    }

    boolean approach1(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        } else {
            char c[] = s.toCharArray();
            char d[] = t.toCharArray();
            Arrays.sort(c);
            Arrays.sort(d);    
            if (Arrays.equals(c, d)) {
                return true;
            } else {
                return false;
            }
        }
    }

    boolean approach2(String a, String b) {
        if (a.length() != b.length()) {
            return false;
        } else {
            int m[] = new int[26];
            int n[] = new int[26];
            for (char c : a.toCharArray()) {
                m[c - 'a']++;
            }
                                    for (char c : b.toCharArray()) {
                n[c - 'a']++;
            }
            for (int i = 0; i < 26; i++) {
                if (m[i] != n[i]) {
                    return false;
                }
            }
            return true;
        }
    }

    boolean approach3(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
                else {
            int a[] = new int[26];
            int b[] = new int[26];
            int k = s.length();
            for (int i = 0; i < k; i++) {
                a[s.charAt(i) - 'a']++;
                b[t.charAt(i) - 'a']++;
            }
            for (int i = 0; i < 26; i++) {
                if (a[i] != b[i])
                    return false;
            }
            return true;
        }
    }

    boolean approach4(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
                else {
            HashMap<Character, Integer> nm = new HashMap<>();
            HashMap<Character, Integer> kk = new HashMap<>();
            for (char c : s.toCharArray()) {
                nm.put(c, nm.getOrDefault(c, 0) + 1);
            }
            for (char c : t.toCharArray()) {

                kk.put(c, kk.getOrDefault(c, 0) + 1);
            }
                        for (char c : nm.keySet()) {
                if (!nm.get(c).equals(kk.get(c))) {
                    return false;
                }
            }
            return true;
        }
    }
}
package com.thealgorithms.strings;

import java.util.HashMap;
import java.util.Map;


public class CheckAnagrams {

    public static void main(String[] args) {
        assert isAnagrams("Silent", "Listen");
        assert isAnagrams("This is a string", "Is this a string");
        assert !isAnagrams("There", "Their");
    }

    
    public static boolean isAnagrams(String s1, String s2) {
        int l1 = s1.length();
        int l2 = s2.length();
        s1 = s1.toLowerCase();
        s2 = s2.toLowerCase();
        Map<Character, Integer> charAppearances = new HashMap<>();

        for (int i = 0; i < l1; i++) {
            char c = s1.charAt(i);
            int numOfAppearances = charAppearances.getOrDefault(c, 0);
            charAppearances.put(c, numOfAppearances + 1);
        }

        for (int i = 0; i < l2; i++) {
            char c = s2.charAt(i);
            if (!charAppearances.containsKey(c)) {
                return false;
            }
            charAppearances.put(c, charAppearances.get(c) - 1);
        }

        for (int cnt : charAppearances.values()) {
            if (cnt != 0) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;

public class Lower {

    
    public static void main(String[] args) {
        String[] strings = {"ABC", "ABC123", "abcABC", "abc123ABC"};
        for (String s : strings) {
            assert toLowerCase(s).equals(s.toLowerCase());
        }
    }

    
    public static String toLowerCase(String s) {
        char[] values = s.toCharArray();
        for (int i = 0; i < values.length; ++i) {
            if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {
                values[i] = Character.toLowerCase(values[i]);
            }
        }
        return new String(values);
    }
}
package com.thealgorithms.strings;


class Alphabetical {

    public static void main(String[] args) {
        assert !isAlphabetical("123abc");
        assert isAlphabetical("aBC");
        assert isAlphabetical("abc");
        assert !isAlphabetical("xyzabc");
        assert isAlphabetical("abcxyz");
    }

    
    public static boolean isAlphabetical(String s) {
        s = s.toLowerCase();
        for (int i = 0; i < s.length() - 1; ++i) {
            if (!Character.isLetter(s.charAt(i)) || !(s.charAt(i) <= s.charAt(i + 1))) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;

import java.util.List;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.HashSet;


class WordLadder {

    
    public static void main(String[] args) {

        String beginWord = "hit";
        String endWord = "cog";
        String words[] = {"hot", "dot", "dog", "lot", "log", "cog"};
        List<String> wordList = Arrays.asList(words);

        System.out.println("Ladder Length: " + ladderLength(beginWord, endWord, wordList));
    }

    
    public static int ladderLength(String beginWord, String endWord, List<String> wordList) {
        HashSet<String> set = new HashSet();
        for (String word : wordList) {
            set.add(word);
        }

        if (!set.contains(endWord)) {
            return 0;
        }

        Queue<String> queue = new LinkedList();
        queue.offer(beginWord);
        int level = 1;

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                String curr = queue.poll();
                char[] words_chars = curr.toCharArray();
                for (int j = 0; j < words_chars.length; j++) {
                    char original_chars = words_chars[j];
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (words_chars[j] == c) {
                            continue;
                        }
                        words_chars[j] = c;
                        String new_word = String.valueOf(words_chars);
                        if (new_word.equals(endWord)) {
                            return level + 1;
                        }
                        if (set.contains(new_word)) {
                            set.remove(new_word);
                            queue.offer(new_word);
                        }
                    }
                    words_chars[j] = original_chars;
                }
            }
            level++;
        }
        return 0;
    }
}
package com.thealgorithms.strings;


public class ReverseString {

    public static void main(String[] args) {
        assert reverse("abc123").equals("321cba");
        assert reverse2("abc123").equals("321cba");
    }

    
    public static String reverse(String str) {
        return new StringBuilder(str).reverse().toString();
    }

    
    public static String reverse2(String str) {

        if (str == null || str.isEmpty()) {
            return str;
        }

        char[] value = str.toCharArray();
        for (int i = 0, j = str.length() - 1; i < j; i++, j--) {
            char temp = value[i];
            value[i] = value[j];
            value[j] = temp;
        }
        return new String(value);
    }
}
package com.thealgorithms.strings;


public class Rotation {

    public static void main(String[] args) {
        assert rotation("abcdef", 2).equals("cdefab");

        char[] values = "abcdef".toCharArray();
        rotation(values, 2);
        assert new String(values).equals("cdefab");
    }

    
    public static String rotation(String s, int n) {
        return s.substring(n) + s.substring(0, n);
    }

    
    public static void rotation(char[] values, int n) {
        reverse(values, 0, n - 1);
        reverse(values, n, values.length - 1);
        reverse(values, 0, values.length - 1);
    }

    
    public static void reverse(char[] values, int from, int to) {
        while (from < to) {
            char temp = values[from];
            values[from] = values[to];
            values[to] = temp;
            from++;
            to--;
        }
    }
}
package com.thealgorithms.strings;

public class Upper {

    
    public static void main(String[] args) {
        String[] strings = {"ABC", "ABC123", "abcABC", "abc123ABC"};
        for (String s : strings) {
            assert toUpperCase(s).equals(s.toUpperCase());
        }
    }

    
    public static String toUpperCase(String s) {
        if (s == null || "".equals(s)) {
            return s;
        }
        char[] values = s.toCharArray();
        for (int i = 0; i < values.length; ++i) {
            if (Character.isLetter(values[i]) && Character.isLowerCase(values[i])) {
                values[i] = Character.toUpperCase(values[i]);
            }
        }
        return new String(values);
    }
}
package com.thealgorithms.strings ;
import java.util.HashMap ;
class longestNonRepeativeSubstring {

    public static int lengthOfLongestSubstring(String s) {
    
        int max = 0 , start = 0 , i = 0 ;
        HashMap< Character , Integer > map = new HashMap<>() ;
    
        while ( i < s.length() ) {

            char temp = s.charAt( i ) ;

                        if ( ! map.containsKey( temp ) )
                map.put( temp , 0 ) ;

                        else if ( s.charAt( start ) == temp )
                start++ ;

                        else if ( s.charAt( i - 1 )  == temp ) {
                if ( max < map.size() ) max = map.size() ;
                map = new HashMap<>() ;
                start = i ;
                i-- ;
            }

                        else {
                if ( max < map.size() ) max = map.size() ;
                while ( s.charAt( start ) != temp ) {
                    map.remove( s.charAt( start ) ) ;
                    start++ ;
                }
                start++ ;
            }

            i++ ;

        }
        if ( max < map.size() ) max = map.size() ;
        return max ;
    }

}
package com.thealgorithms.strings;


public class Pangram {

    
    public static void main(String[] args) {
        assert isPangram("The quick brown fox jumps over the lazy dog");
        assert !isPangram("The quick brown fox jumps over the azy dog");

    }

    
    public static boolean isPangram(String s) {
        boolean[] marked = new boolean[26];
      
        char[] values = s.toCharArray();
        for (char value : values) {
            if (Character.isLetter(value)) {
                int index = Character.isUpperCase(value) ? value - 'A' : value - 'a';
                marked[index] = true;
            }
        }

        for (boolean b : marked) {
            if (!b) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;


class Palindrome {

    
    public static void main(String[] args) {
        String[] palindromes = {null, "", "aba", "123321"};
        for (String s : palindromes) {
            assert isPalindrome(s) && isPalindromeRecursion(s) && isPalindrome1(s);
        }

        String[] notPalindromes = {"abb", "abc", "abc123"};
        for (String s : notPalindromes) {
            assert !isPalindrome(s) && !isPalindromeRecursion(s) && !isPalindrome1(s);
        }
    }

    
    public static boolean isPalindrome(String s) {
        return (s == null || s.length() <= 1) || s.equals(new StringBuilder(s).reverse().toString());
    }

    
    public static boolean isPalindromeRecursion(String s) {
        if (s == null || s.length() <= 1) {
            return true;
        }

        if (s.charAt(0) != s.charAt(s.length() - 1)) {
            return false;
        }

        return isPalindrome(s.substring(1, s.length() - 1));
    }

    
    public static boolean isPalindrome1(String s) {
        if (s == null || s.length() <= 1) {
            return true;
        }
        for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.strings;

import java.util.*;

public class List_all_Possible_Words_From_Phone_Digits {

    static Character[][] numberToCharMap;

    private static List<String> printWords(int[] numbers,
            int len,
            int numIndex,
            String s) {
        if (len == numIndex) {
            return new ArrayList<>(Collections.singleton(s));
        }

        List<String> stringList = new ArrayList<>();

        for (int i = 0;
                i < numberToCharMap[numbers[numIndex]].length; i++) {
            String sCopy
                    = String.copyValueOf(s.toCharArray());
            sCopy = sCopy.concat(
                    numberToCharMap[numbers[numIndex]][i].toString());
            stringList.addAll(printWords(numbers, len,
                    numIndex + 1,
                    sCopy));
        }
        return stringList;
    }

    private static void printWords(int[] numbers) {
        generateNumberToCharMap();
        List<String> stringList
                = printWords(numbers, numbers.length, 0, "");
        stringList.stream().forEach(System.out::println);
    }

    private static void generateNumberToCharMap() {
        numberToCharMap = new Character[10][5];
        numberToCharMap[0] = new Character[]{'\0'};
        numberToCharMap[1] = new Character[]{'\0'};
        numberToCharMap[2] = new Character[]{'a', 'b', 'c'};
        numberToCharMap[3] = new Character[]{'d', 'e', 'f'};
        numberToCharMap[4] = new Character[]{'g', 'h', 'i'};
        numberToCharMap[5] = new Character[]{'j', 'k', 'l'};
        numberToCharMap[6] = new Character[]{'m', 'n', 'o'};
        numberToCharMap[7] = new Character[]{'p', 'q', 'r', 's'};
        numberToCharMap[8] = new Character[]{'t', 'u', 'v'};
        numberToCharMap[9] = new Character[]{'w', 'x', 'y', 'z'};
    }

    public static void main(String[] args) {
        int number[] = {2, 3, 4};
        printWords(number);
    }
}
package com.thealgorithms.conversions;


public class AnyBaseToDecimal {

    public static void main(String[] args) {
        assert convertToDecimal("1010", 2) == Integer.valueOf("1010", 2);
        assert convertToDecimal("777", 8) == Integer.valueOf("777", 8);
        assert convertToDecimal("999", 10) == Integer.valueOf("999", 10);
        assert convertToDecimal("ABCDEF", 16) == Integer.valueOf("ABCDEF", 16);
        assert convertToDecimal("XYZ", 36) == Integer.valueOf("XYZ", 36);
    }

    
    public static int convertToDecimal(String s, int radix) {
        int num = 0;
        int pow = 1;

        for (int i = s.length() - 1; i >= 0; i--) {
            int digit = valOfChar(s.charAt(i));
            if (digit >= radix) {
                throw new NumberFormatException("For input string " + s);
            }
            num += valOfChar(s.charAt(i)) * pow;
            pow *= radix;
        }
        return num;
    }

    
    public static int valOfChar(char c) {
        if (!(Character.isUpperCase(c) || Character.isDigit(c))) {
            throw new NumberFormatException("invalid character :" + c);
        }
        return Character.isDigit(c) ? c - '0' : c - 'A' + 10;
    }
}
package com.thealgorithms.conversions;


public class IntegerToRoman {

    private static int[] allArabianRomanNumbers
            = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    private static String[] allRomanNumbers
            = new String[]{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

        public static String integerToRoman(int num) {
        if (num <= 0) {
            return "";
        }

        StringBuilder builder = new StringBuilder();

        for (int a = 0; a < allArabianRomanNumbers.length; a++) {
            int times = num / allArabianRomanNumbers[a];
            for (int b = 0; b < times; b++) {
                builder.append(allRomanNumbers[a]);
            }

            num -= times * allArabianRomanNumbers[a];
        }

        return builder.toString();
    }

    public static void main(String[] args) {
        System.out.println(IntegerToRoman.integerToRoman(2131));
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;


public class BinaryToOctal {

    
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Input the binary number: ");
        int b = sc.nextInt();
        System.out.println("Octal equivalent: " + convertBinaryToOctal(b));
        sc.close();
    }

    
    public static String convertBinaryToOctal(int binary) {
        String octal = "";
        int currBit = 0, j = 1;
        while (binary != 0) {
            int code3 = 0;
            for (int i = 0; i < 3; i++) {
                currBit = binary % 10;
                binary = binary / 10;
                code3 += currBit * j;
                j *= 2;
            }
            octal = code3 + octal;
            j = 1;
        }
        return octal;
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;


class BinaryToDecimal {

    
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int binNum, binCopy, d, s = 0, power = 0;
        System.out.print("Binary number: ");
        binNum = sc.nextInt();
        binCopy = binNum;
        while (binCopy != 0) {
            d = binCopy % 10;
            s += d * (int) Math.pow(2, power++);
            binCopy /= 10;
        }
        System.out.println("Decimal equivalent:" + s);
        sc.close();
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;

public class AnytoAny {

    public static void main(String[] args) {
        Scanner scn = new Scanner(System.in);
        int sn = scn.nextInt();
        int sb = scn.nextInt();
        int db = scn.nextInt();
        int m = 1, dec = 0, dn = 0;
        while (sn != 0) {
            dec = dec + (sn % 10) * m;
            m *= sb;
            sn /= 10;
        }
        m = 1;
        while (dec != 0) {
            dn = dn + (dec % db) * m;
            m *= 10;
            dec /= db;
        }
        System.out.println(dn);
        scn.close();
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;


public class DecimalToOctal {

    

        public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n, k, d, s = 0, c = 0;
        System.out.print("Decimal number: ");
        n = sc.nextInt();
        k = n;
        while (k != 0) {
            d = k % 8;
            s += d * (int) Math.pow(10, c++);
            k /= 8;
        }

        System.out.println("Octal equivalent:" + s);
        sc.close();
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;


public class OctalToDecimal {

    
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Octal Input: ");
        String inputOctal = sc.nextLine();
        int result = convertOctalToDecimal(inputOctal);
        if (result != -1) {
            System.out.println("Result convertOctalToDecimal : " + result);
        }
        sc.close();
    }

    
    public static int convertOctalToDecimal(String inputOctal) {

        try {
                        Integer outputDecimal = Integer.parseInt(inputOctal, 8);
            return outputDecimal;
        } catch (NumberFormatException ne) {
                                    System.out.println("Invalid Input, Expecting octal number 0-7");
            return -1;
        }
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;


public class HexToOct {

    
    public static int hex2decimal(String s) {
        String str = "0123456789ABCDEF";
        s = s.toUpperCase();
        int val = 0;
        for (int i = 0; i < s.length(); i++) {
            char a = s.charAt(i);
            int n = str.indexOf(a);
            val = 16 * val + n;
        }
        return val;
    }

    
    public static int decimal2octal(int q) {
        int now;
        int i = 1;
        int octnum = 0;
        while (q > 0) {
            now = q % 8;
            octnum = (now * (int) (Math.pow(10, i))) + octnum;
            q /= 8;
            i++;
        }
        octnum /= 10;
        return octnum;
    }

    
    public static void main(String args[]) {
        String hexadecnum;
        int decnum, octalnum;
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter Hexadecimal Number : ");
        hexadecnum = scan.nextLine();

                decnum
                = hex2decimal(
                        hexadecnum);         
                octalnum = decimal2octal(decnum);
        System.out.println("Number in octal: " + octalnum);
        scan.close();
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;


class DecimalToBinary {

    
    public static void main(String args[]) {
        conventionalConversion();
        bitwiseConversion();
    }

    
    public static void conventionalConversion() {
        int n, b = 0, c = 0, d;
        Scanner input = new Scanner(System.in);
        System.out.printf("Conventional conversion.%n Enter the decimal number: ");
        n = input.nextInt();
        while (n != 0) {
            d = n % 2;
            b = b + d * (int) Math.pow(10, c++);
            n /= 2;
        }         System.out.println("\tBinary number: " + b);
        input.close();
    }

    
    public static void bitwiseConversion() {
        int n, b = 0, c = 0, d;
        Scanner input = new Scanner(System.in);
        System.out.printf("Bitwise conversion.%n Enter the decimal number: ");
        n = input.nextInt();
        while (n != 0) {
            d = (n & 1);
            b += d * (int) Math.pow(10, c++);
            n >>= 1;
        }
        System.out.println("\tBinary number: " + b);
        input.close();
    }
}
package com.thealgorithms.conversions;

import java.util.Arrays;
import java.util.HashSet;
import java.util.InputMismatchException;
import java.util.Scanner;


public class AnyBaseToAnyBase {

    
    static final int MINIMUM_BASE = 2;

    static final int MAXIMUM_BASE = 36;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String n;
        int b1, b2;
        while (true) {
            try {
                System.out.print("Enter number: ");
                n = in.next();
                System.out.print(
                        "Enter beginning base (between " + MINIMUM_BASE + " and " + MAXIMUM_BASE + "): ");
                b1 = in.nextInt();
                if (b1 > MAXIMUM_BASE || b1 < MINIMUM_BASE) {
                    System.out.println("Invalid base!");
                    continue;
                }
                if (!validForBase(n, b1)) {
                    System.out.println("The number is invalid for this base!");
                    continue;
                }
                System.out.print(
                        "Enter end base (between " + MINIMUM_BASE + " and " + MAXIMUM_BASE + "): ");
                b2 = in.nextInt();
                if (b2 > MAXIMUM_BASE || b2 < MINIMUM_BASE) {
                    System.out.println("Invalid base!");
                    continue;
                }
                break;
            } catch (InputMismatchException e) {
                System.out.println("Invalid input.");
                in.next();
            }
        }
        System.out.println(base2base(n, b1, b2));
        in.close();
    }

    
    public static boolean validForBase(String n, int base) {
        char[] validDigits = {
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
            'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
        };
                char[] digitsForBase = Arrays.copyOfRange(validDigits, 0, base);

                HashSet<Character> digitsList = new HashSet<>();
        for (int i = 0; i < digitsForBase.length; i++) {
            digitsList.add(digitsForBase[i]);
        }

                for (char c : n.toCharArray()) {
            if (!digitsList.contains(c)) {
                return false;
            }
        }

        return true;
    }

    
    public static String base2base(String n, int b1, int b2) {
                                int decimalValue = 0, charB2;
        char charB1;
        String output = "";
                for (int i = 0; i < n.length(); i++) {
                        charB1 = n.charAt(i);
                        if (charB1 >= 'A' && charB1 <= 'Z') {
                charB2 = 10 + (charB1 - 'A');
            }             else {
                charB2 = charB1 - '0';
            }
                                    decimalValue = decimalValue * b1 + charB2;
        }

                                                        if (0 == decimalValue) {
            return "0";
        }
                while (decimalValue != 0) {
                                    if (decimalValue % b2 < 10) {
                output = Integer.toString(decimalValue % b2) + output;
            }                         else {
                output = (char) ((decimalValue % b2) + 55) + output;
            }
                        decimalValue /= b2;
        }
        return output;
    }
}
package com.thealgorithms.conversions;

public class HexaDecimalToBinary {

    private final int LONG_BITS = 8;

    public void convert(String numHex) {
                int conHex = Integer.parseInt(numHex, 16);
                String binary = Integer.toBinaryString(conHex);
                System.out.println(numHex + " = " + completeDigits(binary));
    }

    public String completeDigits(String binNum) {
        for (int i = binNum.length(); i < LONG_BITS; i++) {
            binNum = "0" + binNum;
        }
        return binNum;
    }

    public static void main(String[] args) {

                String[] hexNums = {"1", "A1", "ef", "BA", "AA", "BB", "19", "01", "02", "03", "04"};
        HexaDecimalToBinary objConvert = new HexaDecimalToBinary();

        for (String num : hexNums) {
            objConvert.convert(num);
        }
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;


public class TurkishToLatinConversion {

    
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Input the string: ");
        String b = sc.next();
        System.out.println("Converted: " + convertTurkishToLatin(b));
        sc.close();
    }

    
    public static String convertTurkishToLatin(String param) {
        char[] turkishChars
                = new char[]{0x131, 0x130, 0xFC, 0xDC, 0xF6, 0xD6, 0x15F, 0x15E, 0xE7, 0xC7, 0x11F, 0x11E};
        char[] latinChars = new char[]{'i', 'I', 'u', 'U', 'o', 'O', 's', 'S', 'c', 'C', 'g', 'G'};
        for (int i = 0; i < turkishChars.length; i++) {
            param
                    = param.replaceAll(
                            new String(new char[]{turkishChars[i]}), new String(new char[]{latinChars[i]}));
        }
        return param;
    }
}
package com.thealgorithms.conversions;

import java.util.Arrays;


public class RgbHsvConversion {

    public static void main(String[] args) {
        
                assert Arrays.equals(hsvToRgb(0, 0, 0), new int[]{0, 0, 0});
        assert Arrays.equals(hsvToRgb(0, 0, 1), new int[]{255, 255, 255});
        assert Arrays.equals(hsvToRgb(0, 1, 1), new int[]{255, 0, 0});
        assert Arrays.equals(hsvToRgb(60, 1, 1), new int[]{255, 255, 0});
        assert Arrays.equals(hsvToRgb(120, 1, 1), new int[]{0, 255, 0});
        assert Arrays.equals(hsvToRgb(240, 1, 1), new int[]{0, 0, 255});
        assert Arrays.equals(hsvToRgb(300, 1, 1), new int[]{255, 0, 255});
        assert Arrays.equals(hsvToRgb(180, 0.5, 0.5), new int[]{64, 128, 128});
        assert Arrays.equals(hsvToRgb(234, 0.14, 0.88), new int[]{193, 196, 224});
        assert Arrays.equals(hsvToRgb(330, 0.75, 0.5), new int[]{128, 32, 80});

                                assert approximatelyEqualHsv(rgbToHsv(0, 0, 0), new double[]{0, 0, 0});
        assert approximatelyEqualHsv(rgbToHsv(255, 255, 255), new double[]{0, 0, 1});
        assert approximatelyEqualHsv(rgbToHsv(255, 0, 0), new double[]{0, 1, 1});
        assert approximatelyEqualHsv(rgbToHsv(255, 255, 0), new double[]{60, 1, 1});
        assert approximatelyEqualHsv(rgbToHsv(0, 255, 0), new double[]{120, 1, 1});
        assert approximatelyEqualHsv(rgbToHsv(0, 0, 255), new double[]{240, 1, 1});
        assert approximatelyEqualHsv(rgbToHsv(255, 0, 255), new double[]{300, 1, 1});
        assert approximatelyEqualHsv(rgbToHsv(64, 128, 128), new double[]{180, 0.5, 0.5});
        assert approximatelyEqualHsv(rgbToHsv(193, 196, 224), new double[]{234, 0.14, 0.88});
        assert approximatelyEqualHsv(rgbToHsv(128, 32, 80), new double[]{330, 0.75, 0.5});
    }

    
    public static int[] hsvToRgb(double hue, double saturation, double value) {
        if (hue < 0 || hue > 360) {
            throw new IllegalArgumentException("hue should be between 0 and 360");
        }

        if (saturation < 0 || saturation > 1) {
            throw new IllegalArgumentException("saturation should be between 0 and 1");
        }

        if (value < 0 || value > 1) {
            throw new IllegalArgumentException("value should be between 0 and 1");
        }

        double chroma = value * saturation;
        double hueSection = hue / 60;
        double secondLargestComponent = chroma * (1 - Math.abs(hueSection % 2 - 1));
        double matchValue = value - chroma;

        return getRgbBySection(hueSection, chroma, matchValue, secondLargestComponent);
    }

    
    public static double[] rgbToHsv(int red, int green, int blue) {
        if (red < 0 || red > 255) {
            throw new IllegalArgumentException("red should be between 0 and 255");
        }

        if (green < 0 || green > 255) {
            throw new IllegalArgumentException("green should be between 0 and 255");
        }

        if (blue < 0 || blue > 255) {
            throw new IllegalArgumentException("blue should be between 0 and 255");
        }

        double dRed = (double) red / 255;
        double dGreen = (double) green / 255;
        double dBlue = (double) blue / 255;
        double value = Math.max(Math.max(dRed, dGreen), dBlue);
        double chroma = value - Math.min(Math.min(dRed, dGreen), dBlue);
        double saturation = value == 0 ? 0 : chroma / value;
        double hue;

        if (chroma == 0) {
            hue = 0;
        } else if (value == dRed) {
            hue = 60 * (0 + (dGreen - dBlue) / chroma);
        } else if (value == dGreen) {
            hue = 60 * (2 + (dBlue - dRed) / chroma);
        } else {
            hue = 60 * (4 + (dRed - dGreen) / chroma);
        }

        hue = (hue + 360) % 360;

        return new double[]{hue, saturation, value};
    }

    private static boolean approximatelyEqualHsv(double[] hsv1, double[] hsv2) {
        boolean bHue = Math.abs(hsv1[0] - hsv2[0]) < 0.2;
        boolean bSaturation = Math.abs(hsv1[1] - hsv2[1]) < 0.002;
        boolean bValue = Math.abs(hsv1[2] - hsv2[2]) < 0.002;

        return bHue && bSaturation && bValue;
    }

    private static int[] getRgbBySection(
            double hueSection, double chroma, double matchValue, double secondLargestComponent) {
        int red;
        int green;
        int blue;

        if (hueSection >= 0 && hueSection <= 1) {
            red = convertToInt(chroma + matchValue);
            green = convertToInt(secondLargestComponent + matchValue);
            blue = convertToInt(matchValue);
        } else if (hueSection > 1 && hueSection <= 2) {
            red = convertToInt(secondLargestComponent + matchValue);
            green = convertToInt(chroma + matchValue);
            blue = convertToInt(matchValue);
        } else if (hueSection > 2 && hueSection <= 3) {
            red = convertToInt(matchValue);
            green = convertToInt(chroma + matchValue);
            blue = convertToInt(secondLargestComponent + matchValue);
        } else if (hueSection > 3 && hueSection <= 4) {
            red = convertToInt(matchValue);
            green = convertToInt(secondLargestComponent + matchValue);
            blue = convertToInt(chroma + matchValue);
        } else if (hueSection > 4 && hueSection <= 5) {
            red = convertToInt(secondLargestComponent + matchValue);
            green = convertToInt(matchValue);
            blue = convertToInt(chroma + matchValue);
        } else {
            red = convertToInt(chroma + matchValue);
            green = convertToInt(matchValue);
            blue = convertToInt(secondLargestComponent + matchValue);
        }

        return new int[]{red, green, blue};
    }

    private static int convertToInt(double input) {
        return (int) Math.round(255 * input);
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;


public class OctalToHexadecimal {

    
    public static int octToDec(String s) {
        int i = 0;
        for (int j = 0; j < s.length(); j++) {
            char num = s.charAt(j);
            num -= '0';
            i *= 8;
            i += num;
        }
        return i;
    }

    
    public static String decimalToHex(int d) {
        String digits = "0123456789ABCDEF";
        if (d <= 0) {
            return "0";
        }
        String hex = "";
        while (d > 0) {
            int digit = d % 16;
            hex = digits.charAt(digit) + hex;
            d = d / 16;
        }
        return hex;
    }

    public static void main(String args[]) {

        Scanner input = new Scanner(System.in);
        System.out.print("Enter the Octal number: ");
                String oct = input.next();

                int decimal = octToDec(oct);

                String hex = decimalToHex(decimal);
        System.out.println("The Hexadecimal equivalant is: " + hex);
        input.close();
    }
}
package com.thealgorithms.conversions;

import java.util.*;

public class RomanToInteger {

    private static Map<Character, Integer> map
            = new HashMap<Character, Integer>() {
        
        private static final long serialVersionUID = 87605733047260530L;

        {
            put('I', 1);
            put('V', 5);
            put('X', 10);
            put('L', 50);
            put('C', 100);
            put('D', 500);
            put('M', 1000);
        }
    };
    
    
    public static int romanToInt(String A) {

        A = A.toUpperCase();
        char prev = ' ';

        int sum = 0;

        int newPrev = 0;
        for (int i = A.length() - 1; i >= 0; i--) {
            char c = A.charAt(i);

            if (prev != ' ') {
                                newPrev = map.get(prev) > newPrev ? map.get(prev) : newPrev;
            }

            int currentNum = map.get(c);

                        if (currentNum >= newPrev) {
                sum += currentNum;
            } else {
                                sum -= currentNum;
            }

            prev = c;
        }

        return sum;
    }

    public static void main(String[] args) {
        int sum = romanToInt("MDCCCIV");
        System.out.println(sum);
    }
}
package com.thealgorithms.conversions;

import java.util.Scanner;

public class HexaDecimalToDecimal {

        public static int getHexaToDec(String hex) {
        String digits = "0123456789ABCDEF";
        hex = hex.toUpperCase();
        int val = 0;
        for (int i = 0; i < hex.length(); i++) {
            int d = digits.indexOf(hex.charAt(i));
            val = 16 * val + d;
        }
        return val;
    }

        public static void main(String args[]) {
        String hexa_Input;
        int dec_output;
        Scanner scan = new Scanner(System.in);

        System.out.print("Enter Hexadecimal Number : ");
        hexa_Input = scan.nextLine();

                dec_output = getHexaToDec(hexa_Input);
        System.out.println("Number in Decimal: " + dec_output);
        scan.close();
    }
}
package com.thealgorithms.conversions;

class DecimalToHexaDecimal {

    private static final int sizeOfIntInHalfBytes = 8;
    private static final int numberOfBitsInAHalfByte = 4;
    private static final int halfByte = 0x0F;
    private static final char[] hexDigits = {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
    };

        public static String decToHex(int dec) {
        StringBuilder hexBuilder = new StringBuilder(sizeOfIntInHalfBytes);
        hexBuilder.setLength(sizeOfIntInHalfBytes);
        for (int i = sizeOfIntInHalfBytes - 1; i >= 0; --i) {
            int j = dec & halfByte;
            hexBuilder.setCharAt(i, hexDigits[j]);
            dec >>= numberOfBitsInAHalfByte;
        }
        return hexBuilder.toString().toLowerCase();
    }

        public static void main(String[] args) {
        System.out.println("Test...");
        int dec = 305445566;
        String libraryDecToHex = Integer.toHexString(dec);
        String decToHex = decToHex(dec);
        System.out.println("Result from the library : " + libraryDecToHex);
        System.out.println("Result decToHex method : " + decToHex);
    }
}
package com.thealgorithms.conversions;

import java.util.*;


public class BinaryToHexadecimal {

    
    static String binToHex(int binary) {
                        HashMap<Integer, String> hm = new HashMap<>();
                String hex = "";
        int i;
        for (i = 0; i < 10; i++) {
            hm.put(i, String.valueOf(i));
        }
        for (i = 10; i < 16; i++) {
            hm.put(i, String.valueOf((char) ('A' + i - 10)));
        }
        int currbit;
        while (binary != 0) {
            int code4 = 0;             for (i = 0; i < 4; i++) {
                currbit = binary % 10;
                binary = binary / 10;
                code4 += currbit * Math.pow(2, i);
            }
            hex = hm.get(code4) + hex;
        }
        return hex;
    }

    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter binary number:");
        int binary = sc.nextInt();
        String hex = binToHex(binary);
        System.out.println("Hexadecimal Code:" + hex);
        sc.close();
    }
}
package com.thealgorithms.conversions;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;


public class DecimalToAnyBase {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter the decimal input below: ");
        int decInput = Integer.parseInt(br.readLine());
        System.out.println();

        System.out.println("Enter the base below: ");
        int base = Integer.parseInt(br.readLine());
        System.out.println();

        System.out.println("Decimal Input" + " is: " + decInput);
        System.out.println(
                "Value of " + decInput + " in base " + base + " is: " + convertToAnyBase(decInput, base));

        br.close();
    }

    
    public static String convertToAnyBase(int inp, int base) {
        ArrayList<Character> charArr = new ArrayList<>();

        while (inp > 0) {
            charArr.add(reVal(inp % base));
            inp /= base;
        }

        StringBuilder str = new StringBuilder(charArr.size());

        for (Character ch : charArr) {
            str.append(ch);
        }

        return str.reverse().toString();
    }

    
    public static char reVal(int num) {
        if (num >= 0 && num <= 9) {
            return (char) (num + '0');
        } else {
            return (char) (num - 10 + 'A');
        }
    }
}
package com.thealgorithms.backtracking;

import java.util.*;


public class Combination {
    private static int length;
    
    public static <T> List<TreeSet<T>> combination(T[] arr, int n) {
        if (n == 0) {
            return null;
        }
        length = n;
        T[] array = arr.clone();
        Arrays.sort(array);
        List<TreeSet<T>> result = new LinkedList<>();
        backtracking(array, 0, new TreeSet<T>(), result);
        return result;
    }
    
    private static <T> void backtracking(T[] arr, int index, TreeSet<T> currSet, List<TreeSet<T>> result) {
        if (index + length - currSet.size() > arr.length) return;
        if (length - 1 == currSet.size()) {
            for (int i = index; i < arr.length; i++) {
                currSet.add(arr[i]);
                result.add((TreeSet<T>) currSet.clone());
                currSet.remove(arr[i]);
            }
        }
        for (int i = index; i < arr.length; i++) {
            currSet.add(arr[i]);
            backtracking(arr, i + 1, currSet, result);
            currSet.remove(arr[i]);
        }
    }
}
package com.thealgorithms.backtracking;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;


public class Permutation {
    
    public static <T> List<T[]> permutation(T[] arr) {
        T[] array = arr.clone();
        List<T[]> result = new LinkedList<>();
        backtracking(array, 0, result);
        return result;
    }
    
    private static <T> void backtracking(T[] arr, int index, List<T[]> result) {
        if (index == arr.length) {
            result.add(arr.clone());
        }
        for (int i = index; i < arr.length; i++) {
            swap(index, i, arr);
            backtracking(arr, index + 1, result);
            swap(index, i, arr);
        }
    }
    
    private static <T> void swap(int a, int b, T[] arr) {
        T temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}
package com.thealgorithms.backtracking;

import java.util.Scanner;

public class PowerSum {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the number and the power");
        int N = sc.nextInt();
        int X = sc.nextInt();
        PowerSum ps = new PowerSum();
        int count = ps.powSum(N, X);
                System.out.println("Number of combinations of different natural number's raised to " + X + " having sum " + N + " are : ");
        System.out.println(count);
        sc.close();
    }
    private int count = 0, sum = 0;

    public int powSum(int N, int X) {
        Sum(N, X, 1);
        return count;
    }

        public void Sum(int N, int X, int i) {
                if (sum == N) {
            count++;
            return;
        }         else if (sum + power(i, X) <= N) {
            sum += power(i, X);
            Sum(N, X, i + 1);
                        sum -= power(i, X);
        }
        if (power(i, X) < N) {
                        Sum(N, X, i + 1);
        }
    }

        private int power(int a, int b) {
        return (int) Math.pow(a, b);
    }
}
package com.thealgorithms.backtracking;

import java.util.ArrayList;
import java.util.List;


public class NQueens {

    public static void main(String[] args) {
        placeQueens(1);
        placeQueens(2);
        placeQueens(3);
        placeQueens(4);
        placeQueens(5);
        placeQueens(6);
    }

    public static void placeQueens(final int queens) {
        List<List<String>> arrangements = new ArrayList<List<String>>();
        getSolution(queens, arrangements, new int[queens], 0);
        if (arrangements.isEmpty()) {
            System.out.println("There is no way to place " + queens + " queens on board of size " + queens + "x" + queens);
        } else {
            System.out.println("Arrangement for placing " + queens + " queens");
        }
        arrangements.forEach(arrangement -> {
            arrangement.forEach(row -> System.out.println(row));
            System.out.println();
        });
    }

    
    private static void getSolution(int boardSize, List<List<String>> solutions, int[] columns, int columnIndex) {
        if (columnIndex == boardSize) {
                        List<String> sol = new ArrayList<String>();
            for (int i = 0; i < boardSize; i++) {
                StringBuilder sb = new StringBuilder();
                for (int j = 0; j < boardSize; j++) {
                    sb.append(j == columns[i] ? "Q" : ".");
                }
                sol.add(sb.toString());
            }
            solutions.add(sol);
            return;
        }

                for (int rowIndex = 0; rowIndex < boardSize; rowIndex++) {
            columns[columnIndex] = rowIndex;
            if (isPlacedCorrectly(columns, rowIndex, columnIndex)) {
                                getSolution(boardSize, solutions, columns, columnIndex + 1);
            }
        }
    }

    
    private static boolean isPlacedCorrectly(int[] columns, int rowIndex, int columnIndex) {
        for (int i = 0; i < columnIndex; i++) {
            int diff = Math.abs(columns[i] - rowIndex);
            if (diff == 0 || columnIndex - i == diff) {
                return false;
            }
        }
        return true;
    }
}
package com.thealgorithms.backtracking;


public class FloodFill {

    
	
	public static int getPixel(int[][] image, int x, int y) {
	
		return image[x][y];
	
	}
	
    
	public static void putPixel(int[][] image, int x, int y, int newColor) {
		
		image[x][y] = newColor;
	
	}
	
	
    
	public static void floodFill(int[][] image, int x, int y, int newColor, int oldColor) {

		if(x < 0 || x >= image.length) return;
		if(y < 0 || y >= image[x].length) return;
		if(getPixel(image, x, y) != oldColor) return;

		putPixel(image, x, y, newColor);

		floodFill(image, x + 1, y, newColor, oldColor);
		floodFill(image, x - 1, y, newColor, oldColor);
		floodFill(image, x, y + 1, newColor, oldColor);
		floodFill(image, x, y - 1, newColor, oldColor);

		floodFill(image, x + 1, y - 1, newColor, oldColor);
		floodFill(image, x - 1, y + 1, newColor, oldColor);
		floodFill(image, x + 1, y + 1, newColor, oldColor);
		floodFill(image, x - 1, y - 1, newColor, oldColor);

	}

}package com.thealgorithms.backtracking;

import java.util.*;

public class KnightsTour {

    private final static int base = 12;
    private final static int[][] moves = {{1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}};     private static int[][] grid;        private static int total;   
    public static void main(String[] args) {
        grid = new int[base][base];
        total = (base - 4) * (base - 4);

        for (int r = 0; r < base; r++) {
            for (int c = 0; c < base; c++) {
                if (r < 2 || r > base - 3 || c < 2 || c > base - 3) {
                    grid[r][c] = -1;
                }
            }
        }

        int row = 2 + (int) (Math.random() * (base - 4));
        int col = 2 + (int) (Math.random() * (base - 4));

        grid[row][col] = 1;

        if (solve(row, col, 2)) {
            printResult();
        } else {
            System.out.println("no result");
        }

    }

        private static boolean solve(int row, int column, int count) {
        if (count > total) {
            return true;
        }

        List<int[]> neighbor = neighbors(row, column);

        if (neighbor.isEmpty() && count != total) {
            return false;
        }

        Collections.sort(neighbor, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return a[2] - b[2];
            }
        });

        for (int[] nb : neighbor) {
            row = nb[0];
            column = nb[1];
            grid[row][column] = count;
            if (!orphanDetected(count, row, column) && solve(row, column, count + 1)) {
                return true;
            }
            grid[row][column] = 0;
        }

        return false;
    }

        private static List<int[]> neighbors(int row, int column) {
        List<int[]> neighbour = new ArrayList<>();

        for (int[] m : moves) {
            int x = m[0];
            int y = m[1];
            if (grid[row + y][column + x] == 0) {
                int num = countNeighbors(row + y, column + x);
                neighbour.add(new int[]{row + y, column + x, num});
            }
        }
        return neighbour;
    }

        private static int countNeighbors(int row, int column) {
        int num = 0;
        for (int[] m : moves) {
            if (grid[row + m[1]][column + m[0]] == 0) {
                num++;
            }
        }
        return num;
    }

        private static boolean orphanDetected(int count, int row, int column) {
        if (count < total - 1) {
            List<int[]> neighbor = neighbors(row, column);
            for (int[] nb : neighbor) {
                if (countNeighbors(nb[0], nb[1]) == 0) {
                    return true;
                }
            }
        }
        return false;
    }

        private static void printResult() {
        for (int[] row : grid) {
            for (int i : row) {
                if (i == -1) {
                    continue;
                }
                System.out.printf("%2d ", i);
            }
            System.out.println();
        }
    }
}
package com.thealgorithms.others;


public class GuassLegendre {

    public static void main(String[] args) {
        for (int i = 1; i <= 3; ++i) {
            System.out.println(pi(i));
        }
    }

    static double pi(int l) {

        double a = 1, b = Math.pow(2, -0.5), t = 0.25, p = 1;
        for (int i = 0; i < l; ++i) {
            double temp[] = update(a, b, t, p);
            a = temp[0];
            b = temp[1];
            t = temp[2];
            p = temp[3];
        }

        return Math.pow(a + b, 2) / (4 * t);
    }

    static double[] update(double a, double b, double t, double p) {
        double values[] = new double[4];
        values[0] = (a + b) / 2;
        values[1] = Math.sqrt(a * b);
        values[2] = t - p * Math.pow(a - values[0], 2);
        values[3] = 2 * p;

        return values;
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

public class RootPrecision {

    public static void main(String[] args) {
                Scanner scn = new Scanner(System.in);

                int N = scn.nextInt();

                int P = scn.nextInt();
        System.out.println(squareRoot(N, P));

        scn.close();
    }

    public static double squareRoot(int N, int P) {
                double rv;

        double root = Math.pow(N, 0.5);

                int precision = (int) Math.pow(10, P);
        root = root * precision;

        rv = (int) root;
        return rv / precision;
    }
}
package com.thealgorithms.others;

public class ArrayLeftRotation {
	public static int[] rotateLeft(int[] arr, int n) {
		int size = arr.length;
		int[] dst = new int[size];
		n = n % size;
		for(int i = 0; i < size; i++) {
			dst[i] = arr[n];
			n = (n + 1) % size;
		}
		return dst;
	}

}
package com.thealgorithms.others;

import java.util.*;

public class StackPostfixNotation {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String post = scanner.nextLine();         System.out.println(postfixEvaluate(post));
        scanner.close();
    }

        public static int postfixEvaluate(String exp) {
        Stack<Integer> s = new Stack<Integer>();
        Scanner tokens = new Scanner(exp);

        while (tokens.hasNext()) {
            if (tokens.hasNextInt()) {
                s.push(tokens.nextInt());             } else {                 int num2 = s.pop();
                int num1 = s.pop();
                String op = tokens.next();

                if (op.equals("+")) {
                    s.push(num1 + num2);
                } else if (op.equals("-")) {
                    s.push(num1 - num2);
                } else if (op.equals("*")) {
                    s.push(num1 * num2);
                } else {
                    s.push(num1 / num2);
                }

                            }
        }
        tokens.close();
        return s.pop();
    }
}
package com.thealgorithms.others;

import java.util.Random;
import java.util.Scanner;


public class PerlinNoise {

    
    static float[][] generatePerlinNoise(
            int width, int height, int octaveCount, float persistence, long seed) {
        final float[][] base = new float[width][height];
        final float[][] perlinNoise = new float[width][height];
        final float[][][] noiseLayers = new float[octaveCount][][];

        Random random = new Random(seed);
                for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                base[x][y] = random.nextFloat();
            }
        }

                for (int octave = 0; octave < octaveCount; octave++) {
            noiseLayers[octave] = generatePerlinNoiseLayer(base, width, height, octave);
        }

        float amplitude = 1f;
        float totalAmplitude = 0f;

                for (int octave = octaveCount - 1; octave >= 0; octave--) {
            amplitude *= persistence;
            totalAmplitude += amplitude;

            for (int x = 0; x < width; x++) {
                for (int y = 0; y < height; y++) {
                                                            perlinNoise[x][y] += noiseLayers[octave][x][y] * amplitude;
                }
            }
        }

                for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                perlinNoise[x][y] /= totalAmplitude;
            }
        }

        return perlinNoise;
    }

    
    static float[][] generatePerlinNoiseLayer(float[][] base, int width, int height, int octave) {
        float[][] perlinNoiseLayer = new float[width][height];

                int period = 1 << octave;         float frequency = 1f / period; 
        for (int x = 0; x < width; x++) {
                        int x0 = (x / period) * period;
            int x1 = (x0 + period) % width;
            float horizintalBlend = (x - x0) * frequency;

            for (int y = 0; y < height; y++) {
                                int y0 = (y / period) * period;
                int y1 = (y0 + period) % height;
                float verticalBlend = (y - y0) * frequency;

                                float top = interpolate(base[x0][y0], base[x1][y0], horizintalBlend);

                                float bottom = interpolate(base[x0][y1], base[x1][y1], horizintalBlend);

                                perlinNoiseLayer[x][y] = interpolate(top, bottom, verticalBlend);
            }
        }

        return perlinNoiseLayer;
    }

    
    static float interpolate(float a, float b, float alpha) {
        return a * (1 - alpha) + alpha * b;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        final int width;
        final int height;
        final int octaveCount;
        final float persistence;
        final long seed;
        final String charset;
        final float[][] perlinNoise;

        System.out.println("Width (int): ");
        width = in.nextInt();

        System.out.println("Height (int): ");
        height = in.nextInt();

        System.out.println("Octave count (int): ");
        octaveCount = in.nextInt();

        System.out.println("Persistence (float): ");
        persistence = in.nextFloat();

        System.out.println("Seed (long): ");
        seed = in.nextLong();

        System.out.println("Charset (String): ");
        charset = in.next();

        perlinNoise = generatePerlinNoise(width, height, octaveCount, persistence, seed);
        final char[] chars = charset.toCharArray();
        final int length = chars.length;
        final float step = 1f / length;
                for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                float value = step;
                float noiseValue = perlinNoise[x][y];

                for (char c : chars) {
                    if (noiseValue <= value) {
                        System.out.print(c);
                        break;
                    }

                    value += step;
                }
            }

            System.out.println();
        }
        in.close();
    }
}
package com.thealgorithms.others;

import java.util.Arrays;
import java.util.Scanner;


class ThreeSum {

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); 
        int a[] = new int[n];

        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        System.out.println("Target");
        int n_find = sc.nextInt();

        Arrays.sort(a); 
        for (int i = 0; i < n; i++) {

            int l = i + 1, r = n - 1;

            while (l < r) {
                if (a[i] + a[l] + a[r] == n_find) {
                    System.out.println(a[i] + " " + a[l] + " " + a[r]);
                    break;
                }                 else if (a[i] + a[l] + a[r] < n_find) {
                    l++;
                } else {
                    r--;
                }
            }
        }

        sc.close();
    }
}
package com.thealgorithms.others;

import java.util.Stack;


class QueueWithStack {

        private Stack<Object> inStack;
        private Stack<Object> outStack;

    
    public QueueWithStack() {
        this.inStack = new Stack<>();
        this.outStack = new Stack<>();
    }

    
    public void insert(Object x) {
                this.inStack.push(x);
    }

    
    public Object remove() {
        if (this.outStack.isEmpty()) {
                        while (!this.inStack.isEmpty()) {
                this.outStack.push(this.inStack.pop());
            }
        }
        return this.outStack.pop();
    }

    
    public Object peekFront() {
        if (this.outStack.isEmpty()) {
                        while (!this.inStack.isEmpty()) {
                this.outStack.push(this.inStack.pop());
            }
        }
        return this.outStack.peek();
    }

    
    public Object peekBack() {
        return this.inStack.peek();
    }

    
    public boolean isEmpty() {
        return (this.inStack.isEmpty() && this.outStack.isEmpty());
    }

    
    public boolean isInStackEmpty() {
        return (inStack.size() == 0);
    }

    
    public boolean isOutStackEmpty() {
        return (outStack.size() == 0);
    }
}


public class QueueUsingTwoStacks {

    
    public static void main(String args[]) {
        QueueWithStack myQueue = new QueueWithStack();
        myQueue.insert(1);
        System.out.println(myQueue.peekBack());                         myQueue.insert(2);
        System.out.println(myQueue.peekBack());                         myQueue.insert(3);
        System.out.println(myQueue.peekBack());                         myQueue.insert(4);
        System.out.println(myQueue.peekBack());                 
        System.out.println(myQueue.isEmpty()); 
        System.out.println(myQueue.remove());         System.out.println((myQueue.isInStackEmpty()) ? "null" : myQueue.peekBack());                 
        myQueue.insert(5);
        System.out.println(myQueue.peekFront());                 
        myQueue.remove();
        System.out.println(myQueue.peekFront());                         myQueue.remove();
        System.out.println(myQueue.peekFront());                         myQueue.remove();
                        System.out.println(myQueue.peekFront());                         myQueue.remove();
                
        System.out.println(myQueue.isEmpty());     }
}
package com.thealgorithms.others;


import java.util.*;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Scanner;

class Process {

    public int pid;
    public int arrivalTime;
    public int burstTime;
    public int priority;
    public int turnAroundTime;
    public int waitTime;
    public int remainingTime;
}

class Schedule {

    private int noOfProcess;
    private int timer = 0;
    private ArrayList<Process> processes;
    private ArrayList<Process> remainingProcess;
    private ArrayList<Integer> gantChart;
    private float burstAll;
    private Map<Integer, ArrayList<Process>> arrivals;

    Schedule() {
        Scanner in = new Scanner(System.in);

        processes = new ArrayList<Process>();
        remainingProcess = new ArrayList<Process>();

        gantChart = new ArrayList<>();
        arrivals = new HashMap<>();

        System.out.print("Enter the no. of processes: ");
        noOfProcess = in.nextInt();
        System.out.println("Enter the arrival, burst and priority of processes");
        for (int i = 0; i < noOfProcess; i++) {
            Process p = new Process();
            p.pid = i;
            p.arrivalTime = in.nextInt();
            p.burstTime = in.nextInt();
            p.priority = in.nextInt();
            p.turnAroundTime = 0;
            p.waitTime = 0;
            p.remainingTime = p.burstTime;

            if (arrivals.get(p.arrivalTime) == null) {
                arrivals.put(p.arrivalTime, new ArrayList<Process>());
            }
            arrivals.get(p.arrivalTime).add(p);
            processes.add(p);
            burstAll += p.burstTime;
        }
        in.close();
    }

    void startScheduling() {

        processes.sort(
                new Comparator<Process>() {
            @Override
            public int compare(Process a, Process b) {
                return a.arrivalTime - b.arrivalTime;
            }
        });

        while (!(arrivals.size() == 0 && remainingProcess.size() == 0)) {
            removeFinishedProcess();
            if (arrivals.get(timer) != null) {
                remainingProcess.addAll(arrivals.get(timer));
                arrivals.remove(timer);
            }

            remainingProcess.sort(
                    new Comparator<Process>() {
                private int alpha = 6;
                private int beta = 1;

                @Override
                public int compare(Process a, Process b) {
                    int aRem = a.remainingTime;
                    int bRem = b.remainingTime;
                    int aprior = a.priority;
                    int bprior = b.priority;
                    return (alpha * aRem + beta * aprior) - (alpha * bRem + beta * bprior);
                }
            });

            int k = timeElapsed(timer);
            ageing(k);
            timer++;
        }

        System.out.println("Total time required: " + (timer - 1));
    }

    void removeFinishedProcess() {
        ArrayList<Integer> completed = new ArrayList<Integer>();
        for (int i = 0; i < remainingProcess.size(); i++) {
            if (remainingProcess.get(i).remainingTime == 0) {
                completed.add(i);
            }
        }

        for (int i = 0; i < completed.size(); i++) {
            int pid = remainingProcess.get(completed.get(i)).pid;
            processes.get(pid).waitTime = remainingProcess.get(completed.get(i)).waitTime;
            remainingProcess.remove(remainingProcess.get(completed.get(i)));
        }
    }

    public int timeElapsed(int i) {
        if (!remainingProcess.isEmpty()) {
            gantChart.add(i, remainingProcess.get(0).pid);
            remainingProcess.get(0).remainingTime--;
            return 1;
        }
        return 0;
    }

    public void ageing(int k) {
        for (int i = k; i < remainingProcess.size(); i++) {
            remainingProcess.get(i).waitTime++;
            if (remainingProcess.get(i).waitTime % 7 == 0) {
                remainingProcess.get(i).priority--;
            }
        }
    }

    public void solve() {
        System.out.println("Gant chart ");
        for (int i = 0; i < gantChart.size(); i++) {
            System.out.print(gantChart.get(i) + " ");
        }
        System.out.println();

        float waitTimeTot = 0;
        float tatTime = 0;

        for (int i = 0; i < noOfProcess; i++) {
            processes.get(i).turnAroundTime = processes.get(i).waitTime + processes.get(i).burstTime;

            waitTimeTot += processes.get(i).waitTime;
            tatTime += processes.get(i).turnAroundTime;

            System.out.println(
                    "Process no.: "
                    + i
                    + " Wait time: "
                    + processes.get(i).waitTime
                    + " Turn Around Time: "
                    + processes.get(i).turnAroundTime);
        }

        System.out.println("Average Waiting Time: " + waitTimeTot / noOfProcess);
        System.out.println("Average TAT Time: " + tatTime / noOfProcess);
        System.out.println("Throughput: " + (float) noOfProcess / (timer - 1));
    }
}

public class SJF {

    public static void main(String[] args) {
        Schedule s = new Schedule();
        s.startScheduling();
        s.solve();
    }
}
package com.thealgorithms.others;


public class EulersFunction {
        
    public static int getEuler(int n) {
        int result = n;
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) {
                while (n % i == 0) {
                    n /= i;
                }
                result -= result / i;
            }
        }
        if (n > 1) {
            result -= result / n;
        }
        return result;
    }

    public static void main(String[] args) {
        for (int i = 1; i < 100; i++) {
            System.out.println(getEuler(i));
        }
    }
}
package com.thealgorithms.others;

class Trieac {

        public static final int ALPHABET_SIZE = 26;

        static class TrieNode {

        TrieNode children[] = new TrieNode[ALPHABET_SIZE];

                        boolean isWordEnd;
    };

        static TrieNode getNode() {
        TrieNode pNode = new TrieNode();
        pNode.isWordEnd = false;

        for (int i = 0; i < ALPHABET_SIZE; i++) {
            pNode.children[i] = null;
        }

        return pNode;
    }

            static void insert(TrieNode root, final String key) {
        TrieNode pCrawl = root;

        for (int level = 0; level < key.length(); level++) {
            int index = (key.charAt(level) - 'a');
            if (pCrawl.children[index] == null) {
                pCrawl.children[index] = getNode();
            }
            pCrawl = pCrawl.children[index];
        }

                pCrawl.isWordEnd = true;
    }

        boolean search(TrieNode root, final String key) {
        int length = key.length();
        TrieNode pCrawl = root;

        for (int level = 0; level < length; level++) {
            int index = (key.charAt(level) - 'a');

            if (pCrawl.children[index] == null) {
                pCrawl = pCrawl.children[index];
            }
        }

        return (pCrawl != null && pCrawl.isWordEnd);
    }

            static boolean isLastNode(TrieNode root) {
        for (int i = 0; i < ALPHABET_SIZE; i++) {
            if (root.children[i] != null) {
                return false;
            }
        }
        return true;
    }

            static void suggestionsRec(TrieNode root, String currPrefix) {
                if (root.isWordEnd) {
            System.out.println(currPrefix);
        }

                if (isLastNode(root)) {
            return;
        }

        for (int i = 0; i < ALPHABET_SIZE; i++) {
            if (root.children[i] != null) {
                                currPrefix += (char) (97 + i);

                                suggestionsRec(root.children[i], currPrefix);
            }
        }
    }

            static int printAutoSuggestions(TrieNode root,
            final String query) {
        TrieNode pCrawl = root;

                                int level;
        int n = query.length();

        for (level = 0; level < n; level++) {
            int index = (query.charAt(level) - 'a');

                        if (pCrawl.children[index] == null) {
                return 0;
            }

            pCrawl = pCrawl.children[index];
        }

                boolean isWord = (pCrawl.isWordEnd == true);

                        boolean isLast = isLastNode(pCrawl);

                                if (isWord && isLast) {
            System.out.println(query);
            return -1;
        }

                        if (!isLast) {
            String prefix = query;
            suggestionsRec(pCrawl, prefix);
            return 1;
        }

        return 0;
    }

        public static void main(String[] args) {
        TrieNode root = getNode();
        insert(root, "hello");
        insert(root, "dog");
        insert(root, "hell");
        insert(root, "cat");
        insert(root, "a");
        insert(root, "hel");
        insert(root, "help");
        insert(root, "helps");
        insert(root, "helping");
        int comp = printAutoSuggestions(root, "hel");

        if (comp == -1) {
            System.out.println("No other strings found "
                    + "with this prefix\n");
        } else if (comp == 0) {
            System.out.println("No string found with"
                    + " this prefix\n");
        }
    }
}
package com.thealgorithms.others;


import java.util.Scanner;

public class RabinKarp {

    public static Scanner scanner = null;
    public static final int d = 256;

    public static void main(String[] args) {

        scanner = new Scanner(System.in);
        System.out.println("Enter String");
        String text = scanner.nextLine();
        System.out.println("Enter pattern");
        String pattern = scanner.nextLine();

        int q = 101;
        searchPat(text, pattern, q);
    }

    private static void searchPat(String text, String pattern, int q) {

        int m = pattern.length();
        int n = text.length();
        int t = 0;
        int p = 0;
        int h = 1;
        int j = 0;
        int i = 0;

        h = (int) Math.pow(d, m - 1) % q;

        for (i = 0; i < m; i++) {
                                                p = (d * p + pattern.charAt(i)) % q;
            t = (d * t + text.charAt(i)) % q;
        }

        for (i = 0; i <= n - m; i++) {

                                                                                                if (p == t) {

                                for (j = 0; j < m; j++) {

                                        if (text.charAt(i + j) != pattern.charAt(j)) {
                        break;
                    }
                }

                                if (j == m) {
                    System.out.println("Pattern found at index " + i);
                }
            }

                                                            if (i < n - m) {
                t = (d * (t - text.charAt(i) * h) + text.charAt(i + m)) % q;

                                if (t < 0) {
                    t = (t + q);
                }
            }
        }
    }
}
package com.thealgorithms.others;

import java.util.Scanner;


public class BrianKernighanAlgorithm {

    
    static int countSetBits(int num) {
        int cnt = 0;
        while (num != 0) {
            num = num & (num - 1);
            cnt++;
        }
        return cnt;
    }

    
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        int setBitCount = countSetBits(num);
        System.out.println(setBitCount);
        sc.close();
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

class Krishnamurthy {

    static int fact(int n) {
        int i, p = 1;
        for (i = n; i >= 1; i--) {
            p = p * i;
        }
        return p;
    }

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int a, b, s = 0;
        System.out.print("Enter the number : ");
        a = sc.nextInt();
        int n = a;
        while (a > 0) {
            b = a % 10;
            s = s + fact(b);
            a = a / 10;
        }
        if (s == n) {
            System.out.print(n + " is a krishnamurthy number");
        } else {
            System.out.print(n + " is not a krishnamurthy number");
        }
        sc.close();
    }
}
package com.thealgorithms.others;


import java.util.Scanner;

public class BankersAlgorithm {

    
    static void calculateNeed(int needArray[][], int maxArray[][], int allocationArray[][], int totalProcess, int totalResources) {
        for (int i = 0; i < totalProcess; i++) {
            for (int j = 0; j < totalResources; j++) {
                needArray[i][j] = maxArray[i][j] - allocationArray[i][j];
            }
        }
    }

    
    static boolean checkSafeSystem(int processes[], int availableArray[], int maxArray[][], int allocationArray[][], int totalProcess, int totalResources) {
        int[][] needArray = new int[totalProcess][totalResources];

        calculateNeed(needArray, maxArray, allocationArray, totalProcess, totalResources);

        boolean[] finishProcesses = new boolean[totalProcess];

        int[] safeSequenceArray = new int[totalProcess];

        int[] workArray = new int[totalResources];

        for (int i = 0; i < totalResources; i++) {
            workArray[i] = availableArray[i];
        }

        int count = 0;

                while (count < totalProcess) {
            boolean foundSafeSystem = false;
            for (int m = 0; m < totalProcess; m++) {
                if (finishProcesses[m] == false) {
                    int j;

                    for (j = 0; j < totalResources; j++) {
                        if (needArray[m][j] > workArray[j]) {
                            break;
                        }
                    }

                    if (j == totalResources) {
                        for (int k = 0; k < totalResources; k++) {
                            workArray[k] += allocationArray[m][k];
                        }

                        safeSequenceArray[count++] = m;

                        finishProcesses[m] = true;

                        foundSafeSystem = true;
                    }
                }
            }

                        if (foundSafeSystem == false) {
                System.out.print("The system is not in the safe state because lack of resources");
                return false;
            }
        }

        System.out.print("The system is in safe sequence and the sequence is as follows: ");
        for (int i = 0; i < totalProcess; i++) {
            System.out.print("P" + safeSequenceArray[i] + " ");
        }

        return true;
    }

    
    public static void main(String[] args) {
        int numberOfProcesses, numberOfResources;

        Scanner sc = new Scanner(System.in);

        System.out.println("Enter total number of processes");
        numberOfProcesses = sc.nextInt();

        System.out.println("Enter total number of resources");
        numberOfResources = sc.nextInt();

        int processes[] = new int[numberOfProcesses];
        for (int i = 0; i < numberOfProcesses; i++) {
            processes[i] = i;
        }

        System.out.println("--Enter the availability of--");

        int availableArray[] = new int[numberOfResources];
        for (int i = 0; i < numberOfResources; i++) {
            System.out.println("resource " + i + ": ");
            availableArray[i] = sc.nextInt();
        }

        System.out.println("--Enter the maximum matrix--");

        int maxArray[][] = new int[numberOfProcesses][numberOfResources];
        for (int i = 0; i < numberOfProcesses; i++) {
            System.out.println("For process " + i + ": ");
            for (int j = 0; j < numberOfResources; j++) {
                System.out.println("Enter the maximum instances of resource " + j);
                maxArray[i][j] = sc.nextInt();
            }
        }

        System.out.println("--Enter the allocation matrix--");

        int allocationArray[][] = new int[numberOfProcesses][numberOfResources];
        for (int i = 0; i < numberOfProcesses; i++) {
            System.out.println("For process " + i + ": ");
            for (int j = 0; j < numberOfResources; j++) {
                System.out.println("Allocated instances of resource " + j);
                allocationArray[i][j] = sc.nextInt();
            }
        }

        checkSafeSystem(processes, availableArray, maxArray, allocationArray, numberOfProcesses, numberOfResources);

        sc.close();
    }
}

package com.thealgorithms.others;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Scanner;

public class SkylineProblem {

    Building[] building;
    int count;

    public void run() {
        Scanner sc = new Scanner(System.in);

        int num = sc.nextInt();
        this.building = new Building[num];

        for (int i = 0; i < num; i++) {
            String input = sc.next();
            String[] data = input.split(",");
            this.add(Integer.parseInt(data[0]), Integer.parseInt(data[1]), Integer.parseInt(data[2]));
        }
        this.print(this.findSkyline(0, num - 1));

        sc.close();
    }

    public void add(int left, int height, int right) {
        building[count++] = new Building(left, height, right);
    }

    public void print(ArrayList<Skyline> skyline) {
        Iterator<Skyline> it = skyline.iterator();

        while (it.hasNext()) {
            Skyline temp = it.next();
            System.out.print(temp.coordinates + "," + temp.height);
            if (it.hasNext()) {
                System.out.print(",");
            }
        }
    }

    public ArrayList<Skyline> findSkyline(int start, int end) {
        if (start == end) {
            ArrayList<Skyline> list = new ArrayList<>();
            list.add(new Skyline(building[start].left, building[start].height));
            list.add(new Skyline(building[end].right, 0));

            return list;
        }

        int mid = (start + end) / 2;

        ArrayList<Skyline> sky1 = this.findSkyline(start, mid);
        ArrayList<Skyline> sky2 = this.findSkyline(mid + 1, end);

        return this.mergeSkyline(sky1, sky2);
    }

    public ArrayList<Skyline> mergeSkyline(ArrayList<Skyline> sky1, ArrayList<Skyline> sky2) {
        int currentH1 = 0, currentH2 = 0;
        ArrayList<Skyline> skyline = new ArrayList<>();
        int maxH = 0;

        while (!sky1.isEmpty() && !sky2.isEmpty()) {
            if (sky1.get(0).coordinates < sky2.get(0).coordinates) {
                int currentX = sky1.get(0).coordinates;
                currentH1 = sky1.get(0).height;

                if (currentH1 < currentH2) {
                    sky1.remove(0);
                    if (maxH != currentH2) {
                        skyline.add(new Skyline(currentX, currentH2));
                    }
                } else {
                    maxH = currentH1;
                    sky1.remove(0);
                    skyline.add(new Skyline(currentX, currentH1));
                }
            } else {
                int currentX = sky2.get(0).coordinates;
                currentH2 = sky2.get(0).height;

                if (currentH2 < currentH1) {
                    sky2.remove(0);
                    if (maxH != currentH1) {
                        skyline.add(new Skyline(currentX, currentH1));
                    }
                } else {
                    maxH = currentH2;
                    sky2.remove(0);
                    skyline.add(new Skyline(currentX, currentH2));
                }
            }
        }

        while (!sky1.isEmpty()) {
            skyline.add(sky1.get(0));
            sky1.remove(0);
        }

        while (!sky2.isEmpty()) {
            skyline.add(sky2.get(0));
            sky2.remove(0);
        }

        return skyline;
    }

    public class Skyline {

        public int coordinates;
        public int height;

        public Skyline(int coordinates, int height) {
            this.coordinates = coordinates;
            this.height = height;
        }
    }

    public class Building {

        public int left;
        public int height;
        public int right;

        public Building(int left, int height, int right) {
            this.left = left;
            this.height = height;
            this.right = right;
        }
    }

    public static void main(String[] args) {
        SkylineProblem skylineProblem = new SkylineProblem();
        skylineProblem.run();
    }
}
package com.thealgorithms.others;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;


class PasswordGen {

    public static void main(String args[]) {
        String password = generatePassword(8, 16);
        System.out.print("Password: " + password);
    }

    static String generatePassword(int min_length, int max_length) {
        Random random = new Random();

        String upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        String lower = "abcdefghijklmnopqrstuvwxyz";
        String numbers = "0123456789";
        String specialChars = "!@#$%^&*(){}?";

        String allChars = upper + lower + numbers + specialChars;

        List<Character> letters = new ArrayList<Character>();
        for (char c : allChars.toCharArray()) {
            letters.add(c);
        }

                Collections.shuffle(letters);
        StringBuilder password = new StringBuilder();

                for (int i = random.nextInt(max_length - min_length) + min_length; i > 0; --i) {
            password.append(letters.get(random.nextInt(letters.size())));
        }

        return password.toString();
    }
}
package com.thealgorithms.others;

import java.util.Objects;


public class Damm {

    
    private static final byte[][] DAMM_TABLE = {
        {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},
        {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},
        {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},
        {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},
        {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},
        {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},
        {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},
        {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},
        {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},
        {2, 5, 8, 1, 4, 3, 6, 7, 9, 0}
    };

    
    public static boolean dammCheck(String digits) {
        checkInput(digits);
        int[] numbers = toIntArray(digits);

        int checksum = 0;
        for (int number : numbers) {
            checksum = DAMM_TABLE[checksum][number];
        }

        return checksum == 0;
    }

    
    public static String addDammChecksum(String initialDigits) {
        checkInput(initialDigits);
        int[] numbers = toIntArray(initialDigits);

        int checksum = 0;
        for (int number : numbers) {
            checksum = DAMM_TABLE[checksum][number];
        }

        return initialDigits + checksum;
    }

    public static void main(String[] args) {
        System.out.println("Damm algorithm usage examples:");
        var validInput = "5724";
        var invalidInput = "5824";
        checkAndPrint(validInput);
        checkAndPrint(invalidInput);

        System.out.println("\nCheck digit generation example:");
        var input = "572";
        generateAndPrint(input);
    }

    private static void checkAndPrint(String input) {
        String validationResult = Damm.dammCheck(input)
                ? "valid"
                : "not valid";
        System.out.println("Input '" + input + "' is " + validationResult);
    }

    private static void generateAndPrint(String input) {
        String result = addDammChecksum(input);
        System.out.println("Generate and add checksum to initial value '" + input + "'. Result: '" + result + "'");
    }

    private static void checkInput(String input) {
        Objects.requireNonNull(input);
        if (!input.matches("\\d+")) {
            throw new IllegalArgumentException("Input '" + input + "' contains not only digits");
        }
    }

    private static int[] toIntArray(String string) {
        return string.chars()
                .map(i -> Character.digit(i, 10))
                .toArray();
    }
}
package com.thealgorithms.others;

import java.util.*;

class PageRank {

    public static void main(String args[]) {
        int nodes, i, j;
        Scanner in = new Scanner(System.in);
        System.out.print("Enter the Number of WebPages: ");
        nodes = in.nextInt();
        PageRank p = new PageRank();
        System.out.println("Enter the Adjacency Matrix with 1->PATH & 0->NO PATH Between two WebPages: ");
        for (i = 1; i <= nodes; i++) {
            for (j = 1; j <= nodes; j++) {
                p.path[i][j] = in.nextInt();
                if (j == i) {
                    p.path[i][j] = 0;
                }
            }
        }
        p.calc(nodes);
    }

    public int path[][] = new int[10][10];
    public double pagerank[] = new double[10];

    public void calc(double totalNodes) {

        double InitialPageRank;
        double OutgoingLinks = 0;
        double DampingFactor = 0.85;
        double TempPageRank[] = new double[10];
        int ExternalNodeNumber;
        int InternalNodeNumber;
        int k = 1;         int ITERATION_STEP = 1;
        InitialPageRank = 1 / totalNodes;
        System.out.printf(
                " Total Number of Nodes :" + totalNodes + "\t Initial PageRank  of All Nodes :" + InitialPageRank + "\n");

                for (k = 1; k <= totalNodes; k++) {
            this.pagerank[k] = InitialPageRank;
        }
        System.out.printf("\n Initial PageRank Values , 0th Step \n");

        for (k = 1; k <= totalNodes; k++) {
            System.out.printf(" Page Rank of " + k + " is :\t" + this.pagerank[k] + "\n");
        }

        while (ITERATION_STEP <= 2)         {
                        for (k = 1; k <= totalNodes; k++) {
                TempPageRank[k] = this.pagerank[k];
                this.pagerank[k] = 0;
            }

            for (InternalNodeNumber = 1; InternalNodeNumber <= totalNodes; InternalNodeNumber++) {
                for (ExternalNodeNumber = 1; ExternalNodeNumber <= totalNodes; ExternalNodeNumber++) {
                    if (this.path[ExternalNodeNumber][InternalNodeNumber] == 1) {
                        k = 1;
                        OutgoingLinks = 0;                         while (k <= totalNodes) {
                            if (this.path[ExternalNodeNumber][k] == 1) {
                                OutgoingLinks = OutgoingLinks + 1;                             }
                            k = k + 1;
                        }
                                                this.pagerank[InternalNodeNumber] += TempPageRank[ExternalNodeNumber] * (1 / OutgoingLinks);
                    }
                }
                System.out.printf("\n After " + ITERATION_STEP + "th Step \n");

                for (k = 1; k <= totalNodes; k++) {
                    System.out.printf(" Page Rank of " + k + " is :\t" + this.pagerank[k] + "\n");
                }

                ITERATION_STEP = ITERATION_STEP + 1;
            }

                        for (k = 1; k <= totalNodes; k++) {
                this.pagerank[k] = (1 - DampingFactor) + DampingFactor * this.pagerank[k];
            }

                        System.out.printf("\n Final Page Rank : \n");
            for (k = 1; k <= totalNodes; k++) {
                System.out.printf(" Page Rank of " + k + " is :\t" + this.pagerank[k] + "\n");
            }

        }
    }
}
package com.thealgorithms.others;

import java.util.Objects;


public class Verhoeff {

    
    private static final byte[][] MULTIPLICATION_TABLE = {
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
        {1, 2, 3, 4, 0, 6, 7, 8, 9, 5},
        {2, 3, 4, 0, 1, 7, 8, 9, 5, 6},
        {3, 4, 0, 1, 2, 8, 9, 5, 6, 7},
        {4, 0, 1, 2, 3, 9, 5, 6, 7, 8},
        {5, 9, 8, 7, 6, 0, 4, 3, 2, 1},
        {6, 5, 9, 8, 7, 1, 0, 4, 3, 2},
        {7, 6, 5, 9, 8, 2, 1, 0, 4, 3},
        {8, 7, 6, 5, 9, 3, 2, 1, 0, 4},
        {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
    };

    
    private static final byte[] MULTIPLICATIVE_INVERSE = {0, 4, 3, 2, 1, 5, 6, 7, 8, 9};

    
    private static final byte[][] PERMUTATION_TABLE = {
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9},
        {1, 5, 7, 6, 2, 8, 3, 0, 9, 4},
        {5, 8, 0, 3, 7, 9, 6, 1, 4, 2},
        {8, 9, 1, 6, 0, 4, 3, 5, 2, 7},
        {9, 4, 5, 3, 1, 2, 6, 8, 7, 0},
        {4, 2, 8, 6, 5, 7, 3, 9, 0, 1},
        {2, 7, 9, 3, 8, 0, 6, 4, 1, 5},
        {7, 0, 4, 6, 9, 1, 3, 2, 5, 8}
    };

    
    public static boolean verhoeffCheck(String digits) {
        checkInput(digits);
        int[] numbers = toIntArray(digits);

                int checksum = 0;
        for (int i = 0; i < numbers.length; i++) {
            int index = numbers.length - i - 1;
            byte b = PERMUTATION_TABLE[i % 8][numbers[index]];
            checksum = MULTIPLICATION_TABLE[checksum][b];
        }

        return checksum == 0;
    }

    
    public static String addVerhoeffChecksum(String initialDigits) {
        checkInput(initialDigits);

                var modifiedDigits = initialDigits + "0";

        int[] numbers = toIntArray(modifiedDigits);

        int checksum = 0;
        for (int i = 0; i < numbers.length; i++) {
            int index = numbers.length - i - 1;
            byte b = PERMUTATION_TABLE[i % 8][numbers[index]];
            checksum = MULTIPLICATION_TABLE[checksum][b];
        }
        checksum = MULTIPLICATIVE_INVERSE[checksum];

        return initialDigits + checksum;
    }

    public static void main(String[] args) {
        System.out.println("Verhoeff algorithm usage examples:");
        var validInput = "2363";
        var invalidInput = "2364";
        checkAndPrint(validInput);
        checkAndPrint(invalidInput);

        System.out.println("\nCheck digit generation example:");
        var input = "236";
        generateAndPrint(input);
    }

    private static void checkAndPrint(String input) {
        String validationResult = Verhoeff.verhoeffCheck(input)
                ? "valid"
                : "not valid";
        System.out.println("Input '" + input + "' is " + validationResult);
    }

    private static void generateAndPrint(String input) {
        String result = addVerhoeffChecksum(input);
        System.out.println("Generate and add checksum to initial value '" + input + "'. Result: '" + result + "'");
    }

    private static void checkInput(String input) {
        Objects.requireNonNull(input);
        if (!input.matches("\\d+")) {
            throw new IllegalArgumentException("Input '" + input + "' contains not only digits");
        }
    }

    private static int[] toIntArray(String string) {
        return string.chars()
                .map(i -> Character.digit(i, 10))
                .toArray();
    }
}
package com.thealgorithms.others;

import java.util.Arrays;


class TwoPointers {

    public static void main(String[] args) {
        int[] arr = {10, 20, 35, 50, 75, 80};
        int key = 70;
        assert isPairedSum(arr, key);

        arr = new int[]{1, 2, 3, 4, 5, 6, 7};
        key = 13;
        assert isPairedSum(arr, key);

        key = 14;
        assert !isPairedSum(arr, key);
    }

    
    private static boolean isPairedSum(int[] arr, int key) {
        Arrays.sort(arr);
        int i = 0;
        int j = arr.length - 1;

        while (i < j) {
            if (arr[i] + arr[j] == key) {
                return true;
            } else if (arr[i] + arr[j] < key) {
                i++;
            } else {
                j--;
            }
        }
        return false;
    }
}
package com.thealgorithms.others;

class Sudoku {

    public static boolean isSafe(int[][] board,
            int row, int col,
            int num) {
                for (int d = 0; d < board.length; d++) {

                                                if (board[row][d] == num) {
                return false;
            }
        }

                for (int r = 0; r < board.length; r++) {

                                                            if (board[r][col] == num) {
                return false;
            }
        }

                        int sqrt = (int) Math.sqrt(board.length);
        int boxRowStart = row - row % sqrt;
        int boxColStart = col - col % sqrt;

        for (int r = boxRowStart;
                r < boxRowStart + sqrt; r++) {
            for (int d = boxColStart;
                    d < boxColStart + sqrt; d++) {
                if (board[r][d] == num) {
                    return false;
                }
            }
        }

                return true;
    }

    public static boolean solveSudoku(
            int[][] board, int n) {
        int row = -1;
        int col = -1;
        boolean isEmpty = true;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 0) {
                    row = i;
                    col = j;

                                                            isEmpty = false;
                    break;
                }
            }
            if (!isEmpty) {
                break;
            }
        }

                if (isEmpty) {
            return true;
        }

                for (int num = 1; num <= n; num++) {
            if (isSafe(board, row, col, num)) {
                board[row][col] = num;
                if (solveSudoku(board, n)) {
                                        return true;
                } else {
                                        board[row][col] = 0;
                }
            }
        }
        return false;
    }

    public static void print(
            int[][] board, int N) {

                for (int r = 0; r < N; r++) {
            for (int d = 0; d < N; d++) {
                System.out.print(board[r][d]);
                System.out.print(" ");
            }
            System.out.print("\n");

            if ((r + 1) % (int) Math.sqrt(N) == 0) {
                System.out.print("");
            }
        }
    }

        public static void main(String args[]) {

        int[][] board = new int[][]{
            {3, 0, 6, 5, 0, 8, 4, 0, 0},
            {5, 2, 0, 0, 0, 0, 0, 0, 0},
            {0, 8, 7, 0, 0, 0, 0, 3, 1},
            {0, 0, 3, 0, 1, 0, 0, 8, 0},
            {9, 0, 0, 8, 6, 3, 0, 0, 5},
            {0, 5, 0, 0, 9, 0, 6, 0, 0},
            {1, 3, 0, 0, 0, 0, 2, 5, 0},
            {0, 0, 0, 0, 0, 0, 0, 7, 4},
            {0, 0, 5, 2, 0, 6, 3, 0, 0}
        };
        int N = board.length;

        if (solveSudoku(board, N)) {
                        print(board, N);
        } else {
            System.out.println("No solution");
        }
    }
}
package com.thealgorithms.others;

import java.io.BufferedReader;
import java.io.InputStreamReader;


public class RemoveDuplicateFromString {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String inpStr = br.readLine();

        System.out.println("Actual string is: " + inpStr);
        System.out.println("String after removing duplicates: " + removeDuplicate(inpStr));

        br.close();
    }

    
    public static String removeDuplicate(String s) {
        if (s == null || s.isEmpty()) {
            return s;
        }

        StringBuilder sb = new StringBuilder();
        int n = s.length();

        for (int i = 0; i < n; i++) {
            if (sb.toString().indexOf(s.charAt(i)) == -1) {
                sb.append(String.valueOf(s.charAt(i)));
            }
        }

        return sb.toString();
    }
}
package com.thealgorithms.others;

import java.util.Arrays;
import java.util.Random;


public class MiniMaxAlgorithm {

    
    private int[] scores;
    private int height;

    
    public MiniMaxAlgorithm() {
        scores = getRandomScores(3, 99);
        height = log2(scores.length);
    }

    public static void main(String[] args) {
        MiniMaxAlgorithm miniMaxAlgorith = new MiniMaxAlgorithm();
        boolean isMaximizer = true;         boolean verbose = true;         int bestScore;

        bestScore = miniMaxAlgorith.miniMax(0, isMaximizer, 0, verbose);

        if (verbose) {
            System.out.println();
        }

        System.out.println(Arrays.toString(miniMaxAlgorith.getScores()));
        System.out.println(
                "The best score for " + (isMaximizer ? "Maximizer" : "Minimizer") + " is " + String.valueOf(bestScore));
    }

    
    public int miniMax(int depth, boolean isMaximizer, int index, boolean verbose) {
        int bestScore, score1, score2;

        if (depth == height) {             return scores[index];
        }

        score1 = miniMax(depth + 1, !isMaximizer, index * 2, verbose);
        score2 = miniMax(depth + 1, !isMaximizer, (index * 2) + 1, verbose);

        if (isMaximizer) {
                        bestScore = Math.max(score1, score2);
        } else {
                        bestScore = Math.min(score1, score2);
        }

                                                if (verbose) {
            System.out.println(String.format("From %02d and %02d, %s chooses %02d", score1, score2,
                    (isMaximizer ? "Maximizer" : "Minimizer"), bestScore));
        }

        return bestScore;
    }

    
    public static int[] getRandomScores(int size, int maxScore) {
        int[] randomScores = new int[(int) Math.pow(2, size)];
        Random rand = new Random();

        for (int i = 0; i < randomScores.length; i++) {
            randomScores[i] = rand.nextInt(maxScore) + 1;
        }

        return randomScores;
    }

        private int log2(int n) {
        return (n == 1) ? 0 : log2(n / 2) + 1;
    }

    public void setScores(int[] scores) {
        if (scores.length % 1 == 0) {
            this.scores = scores;
            height = log2(this.scores.length);
        } else {
            System.out.println("The number of scores must be a power of 2.");
        }
    }

    public int[] getScores() {
        return scores;
    }

    public int getHeight() {
        return height;
    }
}
package com.thealgorithms.others;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import javax.imageio.ImageIO;


public class KochSnowflake {

    public static void main(String[] args) {
                ArrayList<Vector2> vectors = new ArrayList<Vector2>();
        vectors.add(new Vector2(0, 0));
        vectors.add(new Vector2(1, 0));
        ArrayList<Vector2> result = Iterate(vectors, 1);

        assert result.get(0).x == 0;
        assert result.get(0).y == 0;

        assert result.get(1).x == 1. / 3;
        assert result.get(1).y == 0;

        assert result.get(2).x == 1. / 2;
        assert result.get(2).y == Math.sin(Math.PI / 3) / 3;

        assert result.get(3).x == 2. / 3;
        assert result.get(3).y == 0;

        assert result.get(4).x == 1;
        assert result.get(4).y == 0;

                int imageWidth = 600;
        double offsetX = imageWidth / 10.;
        double offsetY = imageWidth / 3.7;
        BufferedImage image = GetKochSnowflake(imageWidth, 5);

                assert image.getRGB(0, 0) == new Color(255, 255, 255).getRGB();

                assert image.getRGB((int) offsetX, (int) offsetY) == new Color(0, 0, 0).getRGB();

                try {
            ImageIO.write(image, "png", new File("KochSnowflake.png"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    
    public static ArrayList<Vector2> Iterate(ArrayList<Vector2> initialVectors, int steps) {
        ArrayList<Vector2> vectors = initialVectors;
        for (int i = 0; i < steps; i++) {
            vectors = IterationStep(vectors);
        }

        return vectors;
    }

    
    public static BufferedImage GetKochSnowflake(int imageWidth, int steps) {
        if (imageWidth <= 0) {
            throw new IllegalArgumentException("imageWidth should be greater than zero");
        }

        double offsetX = imageWidth / 10.;
        double offsetY = imageWidth / 3.7;
        Vector2 vector1 = new Vector2(offsetX, offsetY);
        Vector2 vector2
                = new Vector2(imageWidth / 2, Math.sin(Math.PI / 3) * imageWidth * 0.8 + offsetY);
        Vector2 vector3 = new Vector2(imageWidth - offsetX, offsetY);
        ArrayList<Vector2> initialVectors = new ArrayList<Vector2>();
        initialVectors.add(vector1);
        initialVectors.add(vector2);
        initialVectors.add(vector3);
        initialVectors.add(vector1);
        ArrayList<Vector2> vectors = Iterate(initialVectors, steps);
        return GetImage(vectors, imageWidth, imageWidth);
    }

    
    private static ArrayList<Vector2> IterationStep(ArrayList<Vector2> vectors) {
        ArrayList<Vector2> newVectors = new ArrayList<Vector2>();
        for (int i = 0; i < vectors.size() - 1; i++) {
            Vector2 startVector = vectors.get(i);
            Vector2 endVector = vectors.get(i + 1);
            newVectors.add(startVector);
            Vector2 differenceVector = endVector.subtract(startVector).multiply(1. / 3);
            newVectors.add(startVector.add(differenceVector));
            newVectors.add(startVector.add(differenceVector).add(differenceVector.rotate(60)));
            newVectors.add(startVector.add(differenceVector.multiply(2)));
        }

        newVectors.add(vectors.get(vectors.size() - 1));
        return newVectors;
    }

    
    private static BufferedImage GetImage(
            ArrayList<Vector2> vectors, int imageWidth, int imageHeight) {
        BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = image.createGraphics();

                g2d.setBackground(Color.WHITE);
        g2d.fillRect(0, 0, imageWidth, imageHeight);

                g2d.setColor(Color.BLACK);
        BasicStroke bs = new BasicStroke(1);
        g2d.setStroke(bs);
        for (int i = 0; i < vectors.size() - 1; i++) {
            int x1 = (int) vectors.get(i).x;
            int y1 = (int) vectors.get(i).y;
            int x2 = (int) vectors.get(i + 1).x;
            int y2 = (int) vectors.get(i + 1).y;

            g2d.drawLine(x1, y1, x2, y2);
        }

        return image;
    }

    
    private static class Vector2 {

        double x, y;

        public Vector2(double x, double y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public String toString() {
            return String.format("[%f, %f]", this.x, this.y);
        }

        
        public Vector2 add(Vector2 vector) {
            double x = this.x + vector.x;
            double y = this.y + vector.y;
            return new Vector2(x, y);
        }

        
        public Vector2 subtract(Vector2 vector) {
            double x = this.x - vector.x;
            double y = this.y - vector.y;
            return new Vector2(x, y);
        }

        
        public Vector2 multiply(double scalar) {
            double x = this.x * scalar;
            double y = this.y * scalar;
            return new Vector2(x, y);
        }

        
        public Vector2 rotate(double angleInDegrees) {
            double radians = angleInDegrees * Math.PI / 180;
            double ca = Math.cos(radians);
            double sa = Math.sin(radians);
            double x = ca * this.x - sa * this.y;
            double y = sa * this.x + ca * this.y;
            return new Vector2(x, y);
        }
    }
}
package com.thealgorithms.others;

import java.util.Scanner;


public class CountWords {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println("Enter your text: ");
        String str = input.nextLine();

        System.out.println("Your text has " + wordCount(str) + " word(s)");
        System.out.println("Your text has " + secondaryWordCount(str) + " word(s)");
        input.close();
    }

    private static int wordCount(String s) {
        if (s == null || s.isEmpty()) {
            return 0;
        }
        return s.trim().split("[\\s]+").length;
    }

    
    private static int secondaryWordCount(String s) {
        if (s == null || s.isEmpty()) {
            return 0;
        }
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (Character.isLetter(c) || Character.isDigit(c)) {
                sb.append(c);
            }
        }
        s = sb.toString();
        return s.trim().split("[\\s]+").length;
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

class FloydTriangle {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the number of rows which you want in your Floyd Triangle: ");
        int r = sc.nextInt(), n = 0;
        sc.close();
        for (int i = 0; i < r; i++) {
            for (int j = 0; j <= i; j++) {
                System.out.print(++n + " ");
            }
            System.out.println();
        }
    }
}
package com.thealgorithms.others;

import java.util.Arrays;


public class SieveOfEratosthenes {

    
    public static int[] findPrimesTill(int n) {
                        Type[] numbers = new Type[n + 1];

                Arrays.fill(numbers, Type.PRIME);
        numbers[0] = numbers[1] = Type.NOT_PRIME;

        double cap = Math.sqrt(n);
                for (int i = 2; i <= cap; i++) {
            if (numbers[i] == Type.PRIME) {
                for (int j = 2; i * j <= n; j++) {
                    numbers[i * j] = Type.NOT_PRIME;
                }
            }
        }

                int primesCount = (int) Arrays.stream(numbers)
                .filter(element -> element == Type.PRIME)
                .count();
        int[] primes = new int[primesCount];

        int primeIndex = 0;
        for (int i = 0; i < n + 1; i++) {
            if (numbers[i] == Type.PRIME) {
                primes[primeIndex++] = i;
            }
        }

        return primes;
    }

    private enum Type {
        PRIME, NOT_PRIME
    }

    public static void main(String[] args) {
        int n = 100;
        System.out.println("Searching for all primes from zero to " + n);
        int[] primes = findPrimesTill(n);
        System.out.println("Found: " + Arrays.toString(primes));
    }
}
package com.thealgorithms.others;


public class LinearCongruentialGenerator {

    private double a, c, m, previousValue;

    
    public LinearCongruentialGenerator(double multiplier, double increment, double modulo) {
        this(System.currentTimeMillis(), multiplier, increment, modulo);
    }

    
    public LinearCongruentialGenerator(
            double seed, double multiplier, double increment, double modulo) {
        this.previousValue = seed;
        this.a = multiplier;
        this.c = increment;
        this.m = modulo;
    }

    
    public double nextNumber() {
        previousValue = (a * previousValue + c) % m;
        return previousValue;
    }

    public static void main(String[] args) {
                                LinearCongruentialGenerator lcg
                = new LinearCongruentialGenerator(1664525, 1013904223, Math.pow(2.0, 32.0));
        for (int i = 0; i < 512; i++) {
            System.out.println(lcg.nextNumber());
        }
    }
}
package com.thealgorithms.others;

import java.util.Scanner;


public class FibbonaciSeries {

    public static void main(String[] args) {
                Scanner scan = new Scanner(System.in);
        int n = scan.nextInt();
        int first = 0, second = 1;
        scan.close();
        while (first <= n) {
                        System.out.println(first);
            int next = first + second;
            first = second;
            second = next;
        }
    }
}
package com.thealgorithms.others;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class HappyNumbersSeq {
    private static final Set<Integer> CYCLE_NUMS = new HashSet<>(Arrays.asList(4, 16, 20, 37, 58, 145));

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("Enter number: ");
        int n = in.nextInt();
        while (n != 1 && !isSad(n)) {
            System.out.print(n + " ");
            n = sumSquares(n);
        }
        String res = n == 1 ? "1 Happy number" : "Sad number";
        System.out.println(res);
    }

    private static int sumSquares(int n) {
        int s = 0;
        for (; n > 0; n /= 10) {
            int r = n % 10;
            s += r * r;
        }
        return s;
    }

    private static boolean isSad(int n) {
        return CYCLE_NUMS.contains(n);
    }
}
package com.thealgorithms.others;

import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.Comparator;

class HuffmanNode {

    int data;
    char c;

    HuffmanNode left;
    HuffmanNode right;
}

class MyComparator implements Comparator<HuffmanNode> {

    public int compare(HuffmanNode x, HuffmanNode y) {

        return x.data - y.data;
    }
}

public class Huffman {

                public static void printCode(HuffmanNode root, String s) {

                                if (root.left
                == null
                && root.right
                == null
                && Character.isLetter(root.c)) {

                        System.out.println(root.c + ":" + s);

            return;
        }

                                        printCode(root.left, s + "0");
        printCode(root.right, s + "1");
    }

        public static void main(String[] args) {

        Scanner s = new Scanner(System.in);

                int n = 6;
        char[] charArray = {'a', 'b', 'c', 'd', 'e', 'f'};
        int[] charfreq = {5, 9, 12, 13, 16, 45};

                        PriorityQueue<HuffmanNode> q
                = new PriorityQueue<HuffmanNode>(n, new MyComparator());

        for (int i = 0; i < n; i++) {

                                    HuffmanNode hn = new HuffmanNode();

            hn.c = charArray[i];
            hn.data = charfreq[i];

            hn.left = null;
            hn.right = null;

                                    q.add(hn);
        }

                HuffmanNode root = null;

                                        while (q.size() > 1) {

                        HuffmanNode x = q.peek();
            q.poll();

                        HuffmanNode y = q.peek();
            q.poll();

                        HuffmanNode f = new HuffmanNode();

                                    f.data = x.data + y.data;
            f.c = '-';

                        f.left = x;

                        f.right = y;

                        root = f;

                        q.add(f);
        }

                printCode(root, "");
    }
}
package com.thealgorithms.others;


import java.util.Scanner;

public class StringMatchFiniteAutomata {

    public static final int CHARS = 256;
    public static int[][] FA;
    public static Scanner scanner = null;

    public static void main(String[] args) {

        scanner = new Scanner(System.in);
        System.out.println("Enter String");
        String text = scanner.nextLine();
        System.out.println("Enter pattern");
        String pat = scanner.nextLine();

        searchPat(text, pat);

        scanner.close();
    }

    public static void searchPat(String text, String pat) {

        int m = pat.length();
        int n = text.length();

        FA = new int[m + 1][CHARS];

        computeFA(pat, m, FA);

        int state = 0;
        for (int i = 0; i < n; i++) {
            state = FA[state][text.charAt(i)];

            if (state == m) {
                System.out.println("Pattern found at index " + (i - m + 1));
            }
        }
    }

        public static void computeFA(String pat, int m, int[][] FA) {

        for (int state = 0; state <= m; ++state) {
            for (int x = 0; x < CHARS; ++x) {
                FA[state][x] = getNextState(pat, m, state, x);
            }
        }
    }

    public static int getNextState(String pat, int m, int state, int x) {

                                if (state < m && x == pat.charAt(state)) {
            return state + 1;
        }

        for (int ns = state; ns > 0; ns--) {

            if (pat.charAt(ns - 1) == x) {

                for (int i = 0; i < ns - 1; i++) {

                    if (pat.charAt(i) != pat.charAt(state - ns + i + 1)) {
                        break;
                    }

                    if (i == ns - 1) {
                        return ns;
                    }
                }
            }
        }

        return 0;
    }
}
package com.thealgorithms.others;


public class KMP {
    
    public static void main(String[] args) {
        final String haystack = "AAAAABAAABA";         final String needle = "AAAA";         KMPmatcher(haystack, needle);
    }

        public static void KMPmatcher(final String haystack, final String needle) {
        final int m = haystack.length();
        final int n = needle.length();
        final int[] pi = computePrefixFunction(needle);
        int q = 0;
        for (int i = 0; i < m; i++) {
            while (q > 0 && haystack.charAt(i) != needle.charAt(q)) {
                q = pi[q - 1];
            }

            if (haystack.charAt(i) == needle.charAt(q)) {
                q++;
            }

            if (q == n) {
                System.out.println("Pattern starts: " + (i + 1 - n));
                q = pi[q - 1];
            }
        }
    }

        private static int[] computePrefixFunction(final String P) {
        final int n = P.length();
        final int[] pi = new int[n];
        pi[0] = 0;
        int q = 0;
        for (int i = 1; i < n; i++) {
            while (q > 0 && P.charAt(q) != P.charAt(i)) {
                q = pi[q - 1];
            }

            if (P.charAt(q) == P.charAt(i)) {
                q++;
            }

            pi[i] = q;
        }
        return pi;
    }
}
package com.thealgorithms.others;

import java.io.*;
import java.util.*;
public class TopKWords {

    static class CountWords {

        private String fileName;

        public CountWords(String fileName) {
            this.fileName = fileName;
        }

        public Map<String, Integer> getDictionary() {
            Map<String, Integer> dictionary = new HashMap<>();
            FileInputStream fis = null;

            try {

                fis = new FileInputStream(fileName);                 int in = 0;
                String s = "";                 in = fis.read(); 
                while (-1 != in) {
                    if (Character.isLetter((char) in)) {
                        s += (char) in;                     } else {
                                                if (s.length() > 0) {
                                                        if (dictionary.containsKey(s)) {
                                                                dictionary.put(s, dictionary.get(s) + 1);
                            } else {
                                                                dictionary.put(s, 1);
                            }
                        }
                        s = "";                     }
                    in = fis.read();
                }
                return dictionary;
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                                        if (fis != null) {
                        fis.close();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return null;
        }
    }

    public static void main(String[] args) {
                CountWords cw = new CountWords("/Users/lisanaaa/Desktop/words.txt");
        Map<String, Integer> dictionary
                = cw.getDictionary(); 
                List<Map.Entry<String, Integer>> list = new ArrayList<>(dictionary.entrySet());

                list.sort(Comparator.comparing(m -> m.getValue()));

        Scanner input = new Scanner(System.in);
        int k = input.nextInt();
        while (k > list.size()) {
            System.out.println("Retype a number, your number is too large");
            input = new Scanner(System.in);
            k = input.nextInt();
        }
        for (int i = 0; i < k; i++) {
            System.out.println(list.get(list.size() - i - 1));
        }
        input.close();
    }
}
package com.thealgorithms.others;

import java.util.Arrays;
import java.util.Objects;


public class Luhn {

    
    public static boolean luhnCheck(int[] digits) {
        int[] numbers = Arrays.copyOf(digits, digits.length);
        int sum = 0;

        for (int i = numbers.length - 1; i >= 0; i--) {
            if (i % 2 == 0) {
                int temp = numbers[i] * 2;
                if (temp > 9) {
                    temp = temp - 9;
                }
                numbers[i] = temp;
            }
            sum += numbers[i];
        }

        return sum % 10 == 0;
    }

    public static void main(String[] args) {
        System.out.println("Luhn algorithm usage examples:");
        int[] validInput = {4, 5, 6, 1, 2, 6, 1, 2, 1, 2, 3, 4, 5, 4, 6, 7};
        int[] invalidInput = {4, 5, 6, 1, 2, 6, 1, 2, 1, 2, 3, 4, 5, 4, 6, 4};         checkAndPrint(validInput);
        checkAndPrint(invalidInput);

        System.out.println("\nBusiness examples:");
        String validCardNumber = "5265 9251 6151 1412";
        String invalidCardNumber = "4929 3231 3088 1896";
        String illegalCardNumber = "4F15 BC06 3A88 76D5";
        businessExample(validCardNumber);
        businessExample(invalidCardNumber);
        businessExample(illegalCardNumber);
    }

    private static void checkAndPrint(int[] input) {
        String validationResult = Luhn.luhnCheck(input)
                ? "valid"
                : "not valid";
        System.out.println("Input " + Arrays.toString(input) + " is " + validationResult);
    }


    private record CreditCard(int[] digits) {

        private static final int DIGITS_COUNT = 16;

        
        public static CreditCard fromString(String cardNumber) {
            Objects.requireNonNull(cardNumber);
            String trimmedCardNumber = cardNumber.replaceAll(" ", "");
            if (trimmedCardNumber.length() != DIGITS_COUNT || !trimmedCardNumber.matches("\\d+")) {
                throw new IllegalArgumentException("{" + cardNumber + "} - is not a card number");
            }

            int[] cardNumbers = toIntArray(trimmedCardNumber);
            boolean isValid = luhnCheck(cardNumbers);
            if (!isValid) {
                throw new IllegalArgumentException("Credit card number {" + cardNumber + "} - have a typo");
            }

            return new CreditCard(cardNumbers);
        }

        
        public String number() {
            StringBuilder result = new StringBuilder();
            for (int i = 0; i < DIGITS_COUNT; i++) {
                if (i % 4 == 0 && i != 0) {
                    result.append(" ");
                }
                result.append(digits[i]);
            }
            return result.toString();
        }

        @Override
        public String toString() {
            return String.format("%s {%s}", CreditCard.class.getSimpleName(), number());
        }

        private static int[] toIntArray(String string) {
            return string.chars()
                    .map(i -> Character.digit(i, 10))
                    .toArray();
        }
    }

    private static void businessExample(String cardNumber) {
        try {
            System.out.println("Trying to create CreditCard object from valid card number: " + cardNumber);
            CreditCard creditCard = CreditCard.fromString(cardNumber);
            System.out.println("And business object is successfully created: " + creditCard + "\n");
        } catch (IllegalArgumentException e) {
            System.out.println("And fail with exception message: " + e.getMessage() + "\n");
        }
    }
}
package com.thealgorithms.others;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import javax.imageio.ImageIO;


public class Mandelbrot {

    public static void main(String[] args) {
                BufferedImage blackAndWhiteImage = getImage(800, 600, -0.6, 0, 3.2, 50, false);

                assert blackAndWhiteImage.getRGB(0, 0) == new Color(255, 255, 255).getRGB();

                assert blackAndWhiteImage.getRGB(400, 300) == new Color(0, 0, 0).getRGB();

                BufferedImage coloredImage = getImage(800, 600, -0.6, 0, 3.2, 50, true);

                assert coloredImage.getRGB(0, 0) == new Color(255, 0, 0).getRGB();

                assert coloredImage.getRGB(400, 300) == new Color(0, 0, 0).getRGB();

                try {
            ImageIO.write(coloredImage, "png", new File("Mandelbrot.png"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    
    public static BufferedImage getImage(
            int imageWidth,
            int imageHeight,
            double figureCenterX,
            double figureCenterY,
            double figureWidth,
            int maxStep,
            boolean useDistanceColorCoding) {
        if (imageWidth <= 0) {
            throw new IllegalArgumentException("imageWidth should be greater than zero");
        }

        if (imageHeight <= 0) {
            throw new IllegalArgumentException("imageHeight should be greater than zero");
        }

        if (maxStep <= 0) {
            throw new IllegalArgumentException("maxStep should be greater than zero");
        }

        BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB);
        double figureHeight = figureWidth / imageWidth * imageHeight;

                for (int imageX = 0; imageX < imageWidth; imageX++) {
            for (int imageY = 0; imageY < imageHeight; imageY++) {
                                double figureX = figureCenterX + ((double) imageX / imageWidth - 0.5) * figureWidth;
                double figureY = figureCenterY + ((double) imageY / imageHeight - 0.5) * figureHeight;

                double distance = getDistance(figureX, figureY, maxStep);

                                image.setRGB(
                        imageX,
                        imageY,
                        useDistanceColorCoding
                                ? colorCodedColorMap(distance).getRGB()
                                : blackAndWhiteColorMap(distance).getRGB());
            }
        }

        return image;
    }

    
    private static Color blackAndWhiteColorMap(double distance) {
        return distance >= 1 ? new Color(0, 0, 0) : new Color(255, 255, 255);
    }

    
    private static Color colorCodedColorMap(double distance) {
        if (distance >= 1) {
            return new Color(0, 0, 0);
        } else {
                                    double hue = 360 * distance;
            double saturation = 1;
            double val = 255;
            int hi = (int) (Math.floor(hue / 60)) % 6;
            double f = hue / 60 - Math.floor(hue / 60);

            int v = (int) val;
            int p = 0;
            int q = (int) (val * (1 - f * saturation));
            int t = (int) (val * (1 - (1 - f) * saturation));

            switch (hi) {
                case 0:
                    return new Color(v, t, p);
                case 1:
                    return new Color(q, v, p);
                case 2:
                    return new Color(p, v, t);
                case 3:
                    return new Color(p, q, v);
                case 4:
                    return new Color(t, p, v);
                default:
                    return new Color(v, p, q);
            }
        }
    }

    
    private static double getDistance(double figureX, double figureY, int maxStep) {
        double a = figureX;
        double b = figureY;
        int currentStep = 0;
        for (int step = 0; step < maxStep; step++) {
            currentStep = step;
            double aNew = a * a - b * b + figureX;
            b = 2 * a * b + figureY;
            a = aNew;

                                    if (a * a + b * b > 4) {
                break;
            }
        }
        return (double) currentStep / (maxStep - 1);
    }
}
package com.thealgorithms.others;


import java.util.*;

public class Dijkstra {

    private static final Graph.Edge[] GRAPH = {
                                new Graph.Edge("a", "b", 7),
        new Graph.Edge("a", "c", 9),
        new Graph.Edge("a", "f", 14),
        new Graph.Edge("b", "c", 10),
        new Graph.Edge("b", "d", 15),
        new Graph.Edge("c", "d", 11),
        new Graph.Edge("c", "f", 2),
        new Graph.Edge("d", "e", 6),
        new Graph.Edge("e", "f", 9),};
    private static final String START = "a";
    private static final String END = "e";

    
    public static void main(String[] args) {
        Graph g = new Graph(GRAPH);
        g.dijkstra(START);
        g.printPath(END);
            }
}

class Graph {
    
    private final Map<String, Vertex> graph;

    
    public static class Edge {

        public final String v1, v2;
        public final int dist;

        public Edge(String v1, String v2, int dist) {
            this.v1 = v1;
            this.v2 = v2;
            this.dist = dist;
        }
    }

    
    public static class Vertex implements Comparable<Vertex> {

        public final String name;
                public int dist = Integer.MAX_VALUE;
        public Vertex previous = null;
        public final Map<Vertex, Integer> neighbours = new HashMap<>();

        public Vertex(String name) {
            this.name = name;
        }

        private void printPath() {
            if (this == this.previous) {
                System.out.printf("%s", this.name);
            } else if (this.previous == null) {
                System.out.printf("%s(unreached)", this.name);
            } else {
                this.previous.printPath();
                System.out.printf(" -> %s(%d)", this.name, this.dist);
            }
        }

        public int compareTo(Vertex other) {
            if (dist == other.dist) {
                return name.compareTo(other.name);
            }

            return Integer.compare(dist, other.dist);
        }

        @Override
        public boolean equals(Object object) {
            if (this == object) {
                return true;
            }
            if (object == null || getClass() != object.getClass()) {
                return false;
            }
            if (!super.equals(object)) {
                return false;
            }

            Vertex vertex = (Vertex) object;

            if (dist != vertex.dist) {
                return false;
            }
            if (name != null ? !name.equals(vertex.name) : vertex.name != null) {
                return false;
            }
            if (previous != null ? !previous.equals(vertex.previous) : vertex.previous != null) {
                return false;
            }
            if (neighbours != null ? !neighbours.equals(vertex.neighbours) : vertex.neighbours != null) {
                return false;
            }

            return true;
        }

        @Override
        public int hashCode() {
            int result = super.hashCode();
            result = 31 * result + (name != null ? name.hashCode() : 0);
            result = 31 * result + dist;
            result = 31 * result + (previous != null ? previous.hashCode() : 0);
            result = 31 * result + (neighbours != null ? neighbours.hashCode() : 0);
            return result;
        }

        @Override
        public String toString() {
            return "(" + name + ", " + dist + ")";
        }
    }

    
    public Graph(Edge[] edges) {
        graph = new HashMap<>(edges.length);

                for (Edge e : edges) {
            if (!graph.containsKey(e.v1)) {
                graph.put(e.v1, new Vertex(e.v1));
            }
            if (!graph.containsKey(e.v2)) {
                graph.put(e.v2, new Vertex(e.v2));
            }
        }

                for (Edge e : edges) {
            graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);
                                }
    }

    
    public void dijkstra(String startName) {
        if (!graph.containsKey(startName)) {
            System.err.printf("Graph doesn't contain start vertex \"%s\"%n", startName);
            return;
        }
        final Vertex source = graph.get(startName);
        NavigableSet<Vertex> q = new TreeSet<>();

                for (Vertex v : graph.values()) {
            v.previous = v == source ? source : null;
            v.dist = v == source ? 0 : Integer.MAX_VALUE;
            q.add(v);
        }

        dijkstra(q);
    }

    
    private void dijkstra(final NavigableSet<Vertex> q) {
        Vertex u, v;
        while (!q.isEmpty()) {
                        u = q.pollFirst();
            if (u.dist == Integer.MAX_VALUE) {
                break;             }
                        for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {
                v = a.getKey(); 
                final int alternateDist = u.dist + a.getValue();
                if (alternateDist < v.dist) {                     q.remove(v);
                    v.dist = alternateDist;
                    v.previous = u;
                    q.add(v);
                }
            }
        }
    }

    
    public void printPath(String endName) {
        if (!graph.containsKey(endName)) {
            System.err.printf("Graph doesn't contain end vertex \"%s\"%n", endName);
            return;
        }

        graph.get(endName).printPath();
        System.out.println();
    }

    
    public void printAllPaths() {
        for (Vertex v : graph.values()) {
            v.printPath();
            System.out.println();
        }
    }
}
package com.thealgorithms.others;

import java.util.*;

public class InsertDeleteInArray {

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);         System.out.println("Enter the size of the array");
        int size = s.nextInt();
        int a[] = new int[size];
        int i;

                for (i = 0; i < size; i++) {
            System.out.println("Enter the element");
            a[i] = s.nextInt();
        }

                System.out.println("Enter the index at which the element should be inserted");
        int insert_pos = s.nextInt();
        System.out.println("Enter the element to be inserted");
        int ins = s.nextInt();
        int size2 = size + 1;
        int b[] = new int[size2];
        for (i = 0; i < size2; i++) {
            if (i <= insert_pos) {
                b[i] = a[i];
            } else {
                b[i] = a[i - 1];
            }
        }
        b[insert_pos] = ins;
        for (i = 0; i < size2; i++) {
            System.out.println(b[i]);
        }

                System.out.println("Enter the index at which element is to be deleted");
        int del_pos = s.nextInt();
        for (i = del_pos; i < size2 - 1; i++) {
            b[i] = b[i + 1];
        }
        for (i = 0; i < size2 - 1; i++) {
            System.out.println(b[i]);
        }
        s.close();
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

class TowerOfHanoi {

    public static void shift(int n, String startPole, String intermediatePole, String endPole) {
                if (n != 0) {
                                    shift(n - 1, startPole, endPole, intermediatePole);
            System.out.format("Move %d from %s to %s\n", n, startPole, endPole);                                     shift(n - 1, intermediatePole, startPole, endPole);
        }
    }

    public static void main(String[] args) {
        System.out.print("Enter number of discs on Pole 1: ");
        Scanner scanner = new Scanner(System.in);
        int numberOfDiscs = scanner.nextInt();         shift(numberOfDiscs, "Pole1", "Pole2", "Pole3");         scanner.close();
    }
}
package com.thealgorithms.others;

import java.util.ArrayList;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;


public class CRCAlgorithm {

    private int correctMess;

    private int wrongMess;

    private int wrongMessCaught;

    private int wrongMessNotCaught;

    private int messSize;

    private double ber;

    private boolean messageChanged;

    private ArrayList<Integer> message;

    private ArrayList<Integer> dividedMessage;

    private ArrayList<Integer> p;

    private Random randomGenerator;

    
    public CRCAlgorithm(String str, int size, double ber) {
        messageChanged = false;
        message = new ArrayList<>();
        messSize = size;
        dividedMessage = new ArrayList<>();
        p = new ArrayList<>();
        for (int i = 0; i < str.length(); i++) {
            p.add(Character.getNumericValue(str.charAt(i)));
        }
        randomGenerator = new Random();
        correctMess = 0;
        wrongMess = 0;
        wrongMessCaught = 0;
        wrongMessNotCaught = 0;
        this.ber = ber;
    }

    
    public int getWrongMess() {
        return wrongMess;
    }

    
    public int getWrongMessCaught() {
        return wrongMessCaught;
    }

    
    public int getWrongMessNotCaught() {
        return wrongMessNotCaught;
    }

    
    public int getCorrectMess() {
        return correctMess;
    }

    
    public void refactor() {
        messageChanged = false;
        message = new ArrayList<>();
        dividedMessage = new ArrayList<>();
    }

    
    public void generateRandomMess() {
        for (int i = 0; i < messSize; i++) {
            int x = ThreadLocalRandom.current().nextInt(0, 2);
            message.add(x);
        }
    }

    
    public void divideMessageWithP(boolean check) {
        ArrayList<Integer> x = new ArrayList<>();
        ArrayList<Integer> k = (ArrayList<Integer>) message.clone();
        if (!check) {
            for (int i = 0; i < p.size() - 1; i++) {
                k.add(0);
            }
        }
        while (!k.isEmpty()) {
            while (x.size() < p.size() && !k.isEmpty()) {
                x.add(k.get(0));
                k.remove(0);
            }
            if (x.size() == p.size()) {
                for (int i = 0; i < p.size(); i++) {
                    if (x.get(i) == p.get(i)) {
                        x.set(i, 0);
                    } else {
                        x.set(i, 1);
                    }
                }
                for (int i = 0; i < x.size() && x.get(i) != 1; i++) {
                    x.remove(0);
                }
            }
        }
        dividedMessage = (ArrayList<Integer>) x.clone();
        if (!check) {
            for (int z : dividedMessage) {
                message.add(z);
            }
        } else {
            if (dividedMessage.contains(1) && messageChanged) {
                wrongMessCaught++;
            } else if (!dividedMessage.contains(1) && messageChanged) {
                wrongMessNotCaught++;
            } else if (!messageChanged) {
                correctMess++;
            }
        }
    }

    
    public void changeMess() {
        for (int y : message) {
            double x = randomGenerator.nextDouble();
            while (x < 0.0000 || x > 1.00000) {
                x = randomGenerator.nextDouble();
            }
            if (x < ber) {
                messageChanged = true;
                if (y == 1) {
                    message.set(message.indexOf(y), 0);
                } else {
                    message.set(message.indexOf(y), 1);
                }
            }
        }
        if (messageChanged) {
            wrongMess++;
        }
    }
}
package com.thealgorithms.others;

import java.util.Scanner;

public class CountChar {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("Enter your text: ");
        String str = input.nextLine();
        input.close();
        System.out.println("There are " + CountCharacters(str) + " characters.");
    }

    
    private static int CountCharacters(String str) {
        return str.replaceAll("\\s", "").length();
    }
}
package com.thealgorithms.others;


import java.util.ArrayList;

public abstract class MemoryManagementAlgorithms {

    
    public abstract ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses);

}

class BestFitCPU extends MemoryManagementAlgorithms {

    private static final int NO_ALLOCATION
            = -255;     
    
    private static int findMaxElement(int[] array) {
        int max = -1;
        for (int value : array) {
            if (value > max) {
                max = value;
            }
        }
        return max;
    }

    
    private static int findBestFit(int[] blockSizes, int processSize) {
                        int minDiff = findMaxElement(blockSizes);
        int index
                = NO_ALLOCATION;                 for (int i = 0;
             i < blockSizes.length;
             i++) {             if (blockSizes[i] - processSize < minDiff && blockSizes[i] - processSize >= 0) {
                minDiff = blockSizes[i] - processSize;
                index = i;
            }
        }
        return index;
    }

    
    public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) {
                ArrayList<Integer> memAlloc = new ArrayList<>();
                for (int processSize : sizeOfProcesses) {
            int chosenBlockIdx
                    = findBestFit(
                    sizeOfBlocks, processSize);             memAlloc.add(chosenBlockIdx);             if (chosenBlockIdx
                    != NO_ALLOCATION) {                 sizeOfBlocks[chosenBlockIdx] -= processSize;             }
        }
        return memAlloc;
    }

}


class WorstFitCPU extends MemoryManagementAlgorithms {

    private static final int NO_ALLOCATION
            = -255;     
    
    private static int findWorstFit(int[] blockSizes, int processSize) {
        int max = -1;
        int index = -1;
        for (int i = 0;
             i < blockSizes.length;
             i++) {             if (blockSizes[i] > max) {
                max = blockSizes[i];
                index = i;
            }
        }
                if (processSize > blockSizes[index]) {
            return NO_ALLOCATION;
        }
        return index;
    }

    
    public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) {
                ArrayList<Integer> memAlloc = new ArrayList<>();
                for (int processSize : sizeOfProcesses) {
            int chosenBlockIdx
                    = findWorstFit(
                    sizeOfBlocks, processSize);             memAlloc.add(chosenBlockIdx);             if (chosenBlockIdx
                    != NO_ALLOCATION) {                 sizeOfBlocks[chosenBlockIdx] -= processSize;             }
        }
        return memAlloc;
    }

}


class FirstFitCPU extends MemoryManagementAlgorithms {

    private static final int NO_ALLOCATION
            = -255;     
    
    private static int findFirstFit(int[] blockSizes, int processSize) {
        for (int i = 0; i < blockSizes.length; i++) {
            if (blockSizes[i] >= processSize) {
                return i;
            }
        }
                return NO_ALLOCATION;
    }

    
    public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) {
                ArrayList<Integer> memAlloc = new ArrayList<>();
                for (int processSize : sizeOfProcesses) {
            int chosenBlockIdx
                    = findFirstFit(
                    sizeOfBlocks, processSize);             memAlloc.add(chosenBlockIdx);             if (chosenBlockIdx
                    != NO_ALLOCATION) {                 sizeOfBlocks[chosenBlockIdx] -= processSize;             }
        }
        return memAlloc;
    }

}


class NextFit extends MemoryManagementAlgorithms {

    private static final int NO_ALLOCATION
            = -255;         private int counter = 0;     
    private int findNextFit(int[] blockSizes, int processSize) {

        for (int i = 0; i < blockSizes.length; i++) {
            if (counter + i >= blockSizes.length){
                counter = -i;             }
            if (blockSizes[i + counter] >= processSize) {
                counter += i;
                return counter;
            }
        }
                counter += blockSizes.length;         return NO_ALLOCATION;
    }

    
    public ArrayList<Integer> fitProcess(int[] sizeOfBlocks, int[] sizeOfProcesses) {
                ArrayList<Integer> memAlloc = new ArrayList<>();
                for (int processSize : sizeOfProcesses) {
            int chosenBlockIdx
                    = findNextFit(
                    sizeOfBlocks, processSize);             memAlloc.add(chosenBlockIdx);             if (chosenBlockIdx
                    != NO_ALLOCATION) {                 sizeOfBlocks[chosenBlockIdx] -= processSize;             }
        }
        return memAlloc;
    }

}

package com.thealgorithms.others;

import java.util.Stack;

public class ReverseStackUsingRecursion {

        private static Stack<Integer> stack = new Stack<>();

        public static void main(String[] args) {
                for (int i = 0; i < 10; i++) {
            stack.push(i);
        }
        System.out.println("STACK");

                for (int k = 9; k >= 0; k--) {
            System.out.println(k);
        }

                reverseUsingRecursion(stack);

        System.out.println("REVERSED STACK : ");
                while (!stack.isEmpty()) {
            System.out.println(stack.pop());
        }
    }

        private static void reverseUsingRecursion(Stack<Integer> stack) {
        if (stack.isEmpty())         {
            return;
        }

        int temptop = stack.peek();
        stack.pop();
        reverseUsingRecursion(stack);         insertAtEnd(temptop);     }

        private static void insertAtEnd(int temptop) {
        if (stack.isEmpty()) {
            stack.push(temptop);         } else {
            int temp = stack.peek();
            stack.pop();

            insertAtEnd(temptop); 
            stack.push(temp);
        }
    }
}
package com.thealgorithms.others;

import java.util.BitSet;


public class CRC32 {

    public static void main(String[] args) {
        System.out.println(Integer.toHexString(crc32("Hello World")));
    }

    public static int crc32(String str) {
        return crc32(str.getBytes());
    }

    public static int crc32(byte[] data) {
        BitSet bitSet = BitSet.valueOf(data);
        int crc32 = 0xFFFFFFFF;         for (int i = 0; i < data.length * 8; i++) {
            if (((crc32 >>> 31) & 1) != (bitSet.get(i) ? 1 : 0)) {
                crc32 = (crc32 << 1) ^ 0x04C11DB7;             } else {
                crc32 = (crc32 << 1);
            }
        }
        crc32 = Integer.reverse(crc32);         return crc32 ^ 0xFFFFFFFF;     }
}
package com.thealgorithms.others;


import java.util.*;

class Rotate_by_90_degree {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();

        while (t-- > 0) {
            int n = sc.nextInt();
            int[][] arr = new int[n][n];

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    arr[i][j] = sc.nextInt();
                }
            }

            Rotate g = new Rotate();
            g.rotate(arr);
            printMatrix(arr);
        }
        sc.close();
    }

    static void printMatrix(int arr[][]) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println("");
        }
    }
}


class Rotate {

    static void rotate(int a[][]) {
        int n = a.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i > j) {
                    int temp = a[i][j];
                    a[i][j] = a[j][i];
                    a[j][i] = temp;
                }
            }
        }
        int i = 0, k = n - 1;
        while (i < k) {
            for (int j = 0; j < n; j++) {
                int temp = a[i][j];
                a[i][j] = a[k][j];
                a[k][j] = temp;
            }

            i++;
            k--;
        }
    }
}
package com.thealgorithms.others;

import java.util.InputMismatchException;
import java.util.Scanner;


public class LowestBasePalindrome {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = 0;
        while (true) {
            try {
                System.out.print("Enter number: ");
                n = in.nextInt();
                break;
            } catch (InputMismatchException e) {
                System.out.println("Invalid input!");
                in.next();
            }
        }
        System.out.println(n + " is a palindrome in base " + lowestBasePalindrome(n));
        System.out.println(base2base(Integer.toString(n), 10, lowestBasePalindrome(n)));
        in.close();
    }

    
    public static int lowestBasePalindrome(int num) {
        int base, num2 = num;
        int digit;
        char digitC;
        boolean foundBase = false;
        String newNum = "";
        String digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        while (!foundBase) {
                        for (base = 2; base < num2; base++) {
                newNum = "";
                while (num > 0) {
                                                                                                                        digit = (num % base);
                    num /= base;
                                        
                                                                                                                        if (digit >= digits.length()) {
                        digitC = (char) (digit);
                        newNum += digitC;
                        continue;
                    }
                    newNum += digits.charAt(digit);
                }
                                num = num2;
                                String reverse = reverse(newNum);
                                                if (reverse.equals(newNum)) {
                    foundBase = true;
                    return base;
                }
            }
        }
                return num - 1;
    }

    private static String reverse(String str) {
        String reverse = "";
        for (int i = str.length() - 1; i >= 0; i--) {
            reverse += str.charAt(i);
        }
        return reverse;
    }

    private static String base2base(String n, int b1, int b2) {
                                int decimalValue = 0, charB2;
        char charB1;
        String output = "";
                for (int i = 0; i < n.length(); i++) {
                        charB1 = n.charAt(i);
                        if (charB1 >= 'A' && charB1 <= 'Z') {
                charB2 = 10 + (charB1 - 'A');
            }             else {
                charB2 = charB1 - '0';
            }
                                    decimalValue = decimalValue * b1 + charB2;
        }

                                                                while (decimalValue != 0) {
                                    if (decimalValue % b2 < 10) {
                output = Integer.toString(decimalValue % b2) + output;
            }                         else {
                output = (char) ((decimalValue % b2) + 55) + output;
            }
                        decimalValue /= b2;
        }
        return output;
    }
}
package com.thealgorithms.others;

import java.util.Arrays;


public class BFPRT {

    public static int[] getMinKNumsByBFPRT(int[] arr, int k) {
        if (k < 1 || k > arr.length) {
            return null;
        }
        int minKth = getMinKthByBFPRT(arr, k);
        int[] res = new int[k];
        int index = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < minKth) {
                res[index++] = arr[i];
            }
        }
        for (; index != res.length; index++) {
            res[index] = minKth;
        }
        return res;
    }

    public static int getMinKthByBFPRT(int[] arr, int k) {
        int[] copyArr = copyArray(arr);
        return bfprt(copyArr, 0, copyArr.length - 1, k - 1);
    }

    public static int[] copyArray(int[] arr) {
        int[] copyArr = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            copyArr[i] = arr[i];
        }
        return copyArr;
    }

    public static int bfprt(int[] arr, int begin, int end, int i) {
        if (begin == end) {
            return arr[begin];
        }
        int pivot = medianOfMedians(arr, begin, end);
        int[] pivotRange = partition(arr, begin, end, pivot);
        if (i >= pivotRange[0] && i <= pivotRange[1]) {
            return arr[i];
        } else if (i < pivotRange[0]) {
            return bfprt(arr, begin, pivotRange[0] - 1, i);
        } else {
            return bfprt(arr, pivotRange[1] + 1, end, i);
        }
    }

    
    public static int medianOfMedians(int[] arr, int begin, int end) {
        int num = end - begin + 1;
        int offset = num % 5 == 0 ? 0 : 1;
        int[] mArr = new int[num / 5 + offset];
        for (int i = 0; i < mArr.length; i++) {
            mArr[i] = getMedian(arr, begin + i * 5, Math.min(end, begin + i * 5 + 4));
        }
        return bfprt(mArr, 0, mArr.length - 1, mArr.length / 2);
    }

    public static void swap(int[] arr, int i, int j) {
        int swap = arr[i];
        arr[i] = arr[j];
        arr[j] = swap;
    }

    public static int[] partition(int[] arr, int begin, int end, int num) {
        int small = begin - 1;
        int cur = begin;
        int big = end + 1;
        while (cur != big) {
            if (arr[cur] < num) {
                swap(arr, ++small, cur++);
            } else if (arr[cur] > num) {
                swap(arr, --big, cur);
            } else {
                cur++;
            }
        }
        int[] pivotRange = new int[2];
        pivotRange[0] = small + 1;
        pivotRange[1] = big - 1;
        return pivotRange;
    }

    public static int getMedian(int[] arr, int begin, int end) {
        insertionSort(arr, begin, end);
        int sum = begin + end;
        int mid = sum / 2 + (sum % 2);
        return arr[mid];
    }

    public static void insertionSort(int[] arr, int begin, int end) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = begin + 1; i != end + 1; i++) {
            for (int j = i; j != begin; j--) {
                if (arr[j - 1] > arr[j]) {
                    swap(arr, j - 1, j);
                } else {
                    break;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {11, 9, 1, 3, 9, 2, 2, 5, 6, 5, 3, 5, 9, 7, 2, 5, 5, 1, 9};
        int[] minK = getMinKNumsByBFPRT(arr, 5);
        System.out.println(Arrays.toString(minK));
    }
}

package com.thealgorithms.others;

import java.util.*;

public class BoyerMoore {

    public static int findmajor(int[] a) {
        int count = 0;
        int cand = -1;
        for (int i = 0; i < a.length; i++) {
            if (count == 0) {
                cand = a[i];
                count = 1;
            } else {
                if (a[i] == cand) {
                    count++;
                } else {
                    count--;
                }
            }
        }
        for (int i = 0; i < a.length; i++) {
            if (a[i] == cand) {
                count++;
            }
        }
        if (count > (a.length / 2)) {
            return cand;
        }
        return -1;
    }

    public static void main(String args[]) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        int a[] = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = input.nextInt();
        }
        System.out.println("the majority element is " + findmajor(a));

    }
}
package com.thealgorithms.others;

import java.util.Scanner;

public class ReturnSubsequence {

    public static void main(String[] args) {
        System.out.println("Enter String: ");
        Scanner s = new Scanner(System.in);
        String givenString = s.next();         String[] subsequence = returnSubsequence(givenString);         System.out.println("Subsequences : ");
                for (int i = 0; i < subsequence.length; i++) {
            System.out.println(subsequence[i]);
        }
        s.close();
    }

    
    private static String[] returnSubsequence(String givenString) {
        if (givenString.length()
                == 0)                 {
            String[] ans = new String[1];
            ans[0] = "";
            return ans;
        }
        String[] SmallAns
                = returnSubsequence(
                        givenString.substring(
                                1));         
        String[] ans
                = new String[2 * SmallAns.length];         int i = 0;
        for (; i < SmallAns.length; i++) {
            ans[i] = SmallAns[i];         }
        for (int k = 0; k < SmallAns.length; k++) {
            ans[k + SmallAns.length]
                    = givenString.charAt(0)
                    + SmallAns[k];                     }
        return ans;
    }
}
package com.thealgorithms.minimizinglateness;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.StringTokenizer;

public class MinimizingLateness {

    private static class Schedule { 
        int t = 0;         int d = 0;         int s = 0;         int f = 0; 
        public Schedule(int t, int d) {
            this.t = t;
            this.d = d;
        }
    }

    public static void main(String[] args) throws IOException {
        StringTokenizer token;

        BufferedReader in = new BufferedReader(new FileReader("MinimizingLateness/lateness_data.txt"));
        String ch = in.readLine();
        if (ch == null || ch.isEmpty()) {
            in.close();
            return;
        }
        int indexCount = Integer.parseInt(ch);
        System.out.println("Input Data : ");
        System.out.println(indexCount);         Schedule[] array = new Schedule[indexCount];         int i = 0;
        while ((ch = in.readLine()) != null) {
            token = new StringTokenizer(ch, " ");
                                    array[i]
                    = new Schedule(Integer.parseInt(token.nextToken()), Integer.parseInt(token.nextToken()));
            i++;
            System.out.println(array[i - 1].t + " " + array[i - 1].d);
        }

        int tryTime = 0;         int lateness = 0;         for (int j = 0; j < indexCount - 1; j++) {
            array[j].s = tryTime;             array[j].f = tryTime + array[j].t;             tryTime = tryTime + array[j].t;                         lateness = lateness + Math.max(0, tryTime - array[j].d);
        }
        System.out.println();
        System.out.println("Output Data : ");
        System.out.println(lateness);
        in.close();
    }
}
package com.thealgorithms.ciphers;

import java.util.HashMap;
import java.util.Map;


public class SimpleSubstitutionCipher {

    
    public static String encode(String message, String cipherSmall) {
        StringBuilder encoded = new StringBuilder();

                Map<Character, Character> cipherMap = new HashMap<>();

        char beginSmallLetter = 'a';
        char beginCapitalLetter = 'A';

        cipherSmall = cipherSmall.toLowerCase();
        String cipherCapital = cipherSmall.toUpperCase();

                for (int i = 0; i < cipherSmall.length(); i++) {
            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));
            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));
        }

        for (int i = 0; i < message.length(); i++) {
            if (Character.isAlphabetic(message.charAt(i))) {
                encoded.append(cipherMap.get(message.charAt(i)));
            } else {
                encoded.append(message.charAt(i));
            }
        }

        return encoded.toString();
    }

    
    public static String decode(String encryptedMessage, String cipherSmall) {
        StringBuilder decoded = new StringBuilder();

        Map<Character, Character> cipherMap = new HashMap<>();

        char beginSmallLetter = 'a';
        char beginCapitalLetter = 'A';

        cipherSmall = cipherSmall.toLowerCase();
        String cipherCapital = cipherSmall.toUpperCase();

        for (int i = 0; i < cipherSmall.length(); i++) {
            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);
            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);
        }

        for (int i = 0; i < encryptedMessage.length(); i++) {
            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {
                decoded.append(cipherMap.get(encryptedMessage.charAt(i)));
            } else {
                decoded.append(encryptedMessage.charAt(i));
            }
        }

        return decoded.toString();
    }

    
    public static void main(String[] args) {
        String a = encode("defend the east wall of the castle", "phqgiumeaylnofdxjkrcvstzwb");
        String b = decode(a, "phqgiumeaylnofdxjkrcvstzwb");
        System.out.println(b);
    }
}
package com.thealgorithms.ciphers;

import java.util.Objects;


public class ColumnarTranspositionCipher {

    private static String keyword;
    private static Object[][] table;
    private static String abecedarium;
    public static final String ABECEDARIUM
            = "abcdefghijklmnopqrstuvwxyzABCDEFG" + "HIJKLMNOPQRSTUVWXYZ0123456789,.;:-@";
    private static final String ENCRYPTION_FIELD = "";
    private static final char ENCRYPTION_FIELD_CHAR = '';

    
    public static String encrpyter(String word, String keyword) {
        ColumnarTranspositionCipher.keyword = keyword;
        abecedariumBuilder(500);
        table = tableBuilder(word);
        Object[][] sortedTable = sortTable(table);
        StringBuilder wordEncrypted = new StringBuilder();
        for (int i = 0; i < sortedTable[i].length; i++) {
            for (int j = 1; j < sortedTable.length; j++) {
                wordEncrypted.append(sortedTable[j][i]);
            }
        }
        return wordEncrypted.toString();
    }

    
    public static String encrpyter(String word, String keyword, String abecedarium) {
        ColumnarTranspositionCipher.keyword = keyword;
        ColumnarTranspositionCipher.abecedarium = Objects.requireNonNullElse(abecedarium, ABECEDARIUM);
        table = tableBuilder(word);
        Object[][] sortedTable = sortTable(table);
        StringBuilder wordEncrypted = new StringBuilder();
        for (int i = 0; i < sortedTable[0].length; i++) {
            for (int j = 1; j < sortedTable.length; j++) {
                wordEncrypted.append(sortedTable[j][i]);
            }
        }
        return wordEncrypted.toString();
    }

    
    public static String decrypter() {
        StringBuilder wordDecrypted = new StringBuilder();
        for (int i = 1; i < table.length; i++) {
            for (Object item : table[i]) {
                wordDecrypted.append(item);
            }
        }
        return wordDecrypted.toString().replaceAll(ENCRYPTION_FIELD, "");
    }

    
    private static Object[][] tableBuilder(String word) {
        Object[][] table = new Object[numberOfRows(word) + 1][keyword.length()];
        char[] wordInChards = word.toCharArray();
                table[0] = findElements();
        int charElement = 0;
        for (int i = 1; i < table.length; i++) {
            for (int j = 0; j < table[i].length; j++) {
                if (charElement < wordInChards.length) {
                    table[i][j] = wordInChards[charElement];
                    charElement++;
                } else {
                    table[i][j] = ENCRYPTION_FIELD_CHAR;
                }
            }
        }
        return table;
    }

    
    private static int numberOfRows(String word) {
        if (word.length() / keyword.length() > word.length() / keyword.length()) {
            return (word.length() / keyword.length()) + 1;
        } else {
            return word.length() / keyword.length();
        }
    }

    
    private static Object[] findElements() {
        Object[] charValues = new Object[keyword.length()];
        for (int i = 0; i < charValues.length; i++) {
            int charValueIndex = abecedarium.indexOf(keyword.charAt(i));
            charValues[i] = charValueIndex > -1 ? charValueIndex : null;
        }
        return charValues;
    }

    
    private static Object[][] sortTable(Object[][] table) {
        Object[][] tableSorted = new Object[table.length][table[0].length];
        for (int i = 0; i < tableSorted.length; i++) {
            System.arraycopy(table[i], 0, tableSorted[i], 0, tableSorted[i].length);
        }
        for (int i = 0; i < tableSorted[0].length; i++) {
            for (int j = i + 1; j < tableSorted[0].length; j++) {
                if ((int) tableSorted[0][i] > (int) table[0][j]) {
                    Object[] column = getColumn(tableSorted, tableSorted.length, i);
                    switchColumns(tableSorted, j, i, column);
                }
            }
        }
        return tableSorted;
    }

    
    private static Object[] getColumn(Object[][] table, int rows, int column) {
        Object[] columnArray = new Object[rows];
        for (int i = 0; i < rows; i++) {
            columnArray[i] = table[i][column];
        }
        return columnArray;
    }

    private static void switchColumns(
            Object[][] table, int firstColumnIndex, int secondColumnIndex, Object[] columnToSwitch) {
        for (int i = 0; i < table.length; i++) {
            table[i][secondColumnIndex] = table[i][firstColumnIndex];
            table[i][firstColumnIndex] = columnToSwitch[i];
        }
    }

    
    private static void abecedariumBuilder(int value) {
        StringBuilder t = new StringBuilder();
        for (int i = 0; i < value; i++) {
            t.append((char) i);
        }
        abecedarium = t.toString();
    }

    private static void showTable() {
        for (Object[] table1 : table) {
            for (Object item : table1) {
                System.out.print(item + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        String keywordForExample = "asd215";
        String wordBeingEncrypted = "This is a test of the Columnar Transposition Cipher";
        System.out.println("### Example of Columnar Transposition Cipher ###\n");
        System.out.println("Word being encryped ->>> " + wordBeingEncrypted);
        System.out.println(
                "Word encrypted ->>> "
                + ColumnarTranspositionCipher.encrpyter(wordBeingEncrypted, keywordForExample));
        System.out.println("Word decryped ->>> " + ColumnarTranspositionCipher.decrypter());
        System.out.println("\n### Encrypted Table ###");
        showTable();
    }
}
package com.thealgorithms.ciphers;

import java.util.HashMap;
import java.util.Map;


public class SimpleSubCipher {

    
    public static String encode(String message, String cipherSmall) {
        String encoded = "";

                Map<Character, Character> cipherMap = new HashMap<>();

        char beginSmallLetter = 'a';
        char beginCapitalLetter = 'A';

        cipherSmall = cipherSmall.toLowerCase();
        String cipherCapital = cipherSmall.toUpperCase();

                for (int i = 0; i < cipherSmall.length(); i++) {
            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));
            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));
        }

        for (int i = 0; i < message.length(); i++) {
            if (Character.isAlphabetic(message.charAt(i))) {
                encoded += cipherMap.get(message.charAt(i));
            } else {
                encoded += message.charAt(i);
            }
        }

        return encoded;
    }

    
    public static String decode(String encryptedMessage, String cipherSmall) {
        String decoded = "";

        Map<Character, Character> cipherMap = new HashMap<Character, Character>();

        char beginSmallLetter = 'a';
        char beginCapitalLetter = 'A';

        cipherSmall = cipherSmall.toLowerCase();
        String cipherCapital = cipherSmall.toUpperCase();

        for (int i = 0; i < cipherSmall.length(); i++) {
            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);
            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);
        }

        for (int i = 0; i < encryptedMessage.length(); i++) {
            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {
                decoded += cipherMap.get(encryptedMessage.charAt(i));
            } else {
                decoded += encryptedMessage.charAt(i);
            }
        }

        return decoded;
    }

    public static void main(String[] args) {
        String a = encode("defend the east wall of the castle", "phqgiumeaylnofdxjkrcvstzwb");
        String b = decode(a, "phqgiumeaylnofdxjkrcvstzwb");
        System.out.println(b);
    }

}
package com.thealgorithms.ciphers;

import java.util.Scanner;


public class Caesar {

    
    public static String encode(String message, int shift) {
        StringBuilder encoded = new StringBuilder();

        shift %= 26;

        final int length = message.length();
        for (int i = 0; i < length; i++) {

                                    char current = message.charAt(i); 
            if (IsCapitalLatinLetter(current)) {

                current += shift;
                encoded.append((char) (current > 'Z' ? current - 26 : current)); 
            } else if (IsSmallLatinLetter(current)) {

                current += shift;
                encoded.append((char) (current > 'z' ? current - 26 : current)); 
            } else {
                encoded.append(current);
            }
        }
        return encoded.toString();
    }

    
    public static String decode(String encryptedMessage, int shift) {
        StringBuilder decoded = new StringBuilder();

        shift %= 26;

        final int length = encryptedMessage.length();
        for (int i = 0; i < length; i++) {
            char current = encryptedMessage.charAt(i);
            if (IsCapitalLatinLetter(current)) {

                current -= shift;
                decoded.append((char) (current < 'A' ? current + 26 : current)); 
            } else if (IsSmallLatinLetter(current)) {

                current -= shift;
                decoded.append((char) (current < 'a' ? current + 26 : current)); 
            } else {
                decoded.append(current);
            }
        }
        return decoded.toString();
    }

    
    private static boolean IsCapitalLatinLetter(char c) {
        return c >= 'A' && c <= 'Z';
    }

    
    private static boolean IsSmallLatinLetter(char c) {
        return c >= 'a' && c <= 'z';
    }
    
    public static String[] bruteforce(String encryptedMessage) {
        String[] listOfAllTheAnswers = new String[27];
        for (int i=0; i<=26; i++) {
            listOfAllTheAnswers[i] = decode(encryptedMessage, i);
        }

        return listOfAllTheAnswers;
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int shift = 0;
        System.out.println("Please enter the message (Latin Alphabet)");
        String message = input.nextLine();
        System.out.println(message);
        System.out.println("(E)ncode or (D)ecode or (B)ruteforce?");
        char choice = input.next().charAt(0);
        switch (choice) {
            case 'E':
            case 'e':
                System.out.println("Please enter the shift number");
                shift = input.nextInt() % 26;
                System.out.println(
                        "ENCODED MESSAGE IS \n" + encode(message, shift));                 break;
            case 'D':
            case 'd':
                System.out.println("Please enter the shift number");
                shift = input.nextInt() % 26;
                System.out.println("DECODED MESSAGE IS \n" + decode(message, shift));
                break;
            case 'B':
            case 'b':
                String[] listOfAllTheAnswers = bruteforce(message);
                for (int i =0; i<=26; i++) {
                    System.out.println("FOR SHIFT " + String.valueOf(i) + " decoded message is " + listOfAllTheAnswers[i]);
                }
            default:
                System.out.println("default case");
        }
        
        input.close();
    }
}
package com.thealgorithms.ciphers;

import java.util.Scanner;

public class HillCipher {

    static Scanner userInput = new Scanner(System.in);

    static void encrypt(String message) {
        message = message.toUpperCase();
                System.out.println("Enter key matrix size");
        int matrixSize = userInput.nextInt();
        System.out.println("Enter Key/encryptionKey matrix ");
        int keyMatrix[][] = new int[matrixSize][matrixSize];
        for (int i = 0; i < matrixSize; i++) {
            for (int j = 0; j < matrixSize; j++) {
                keyMatrix[i][j] = userInput.nextInt();
            }
        }
                validateDeterminant(keyMatrix,matrixSize);

        int[][] messageVector = new int[matrixSize][1];
        String CipherText = "";
        int cipherMatrix[][] = new int[matrixSize][1];
        int j = 0;
        while (j < message.length()) {
            for (int i = 0; i < matrixSize; i++) {
                if (j >= message.length()) {
                    messageVector[i][0] = 23;
                } else {
                    messageVector[i][0] = (message.charAt(j)) % 65;
                }
                System.out.println(messageVector[i][0]);
                j++;
            }
            int x, i;
            for (i = 0; i < matrixSize; i++) {
                cipherMatrix[i][0] = 0;

                for (x = 0; x < matrixSize; x++) {
                    cipherMatrix[i][0] += keyMatrix[i][x] * messageVector[x][0];
                }
                System.out.println(cipherMatrix[i][0]);
                cipherMatrix[i][0] = cipherMatrix[i][0] % 26;
            }
            for (i = 0; i < matrixSize; i++) {
                CipherText += (char) (cipherMatrix[i][0] + 65);
            }
        }
        System.out.println("Ciphertext: " + CipherText);
    }

        static void decrypt(String message) {
        message = message.toUpperCase();
                System.out.println("Enter key matrix size");
        int n = userInput.nextInt();
        System.out.println("Enter inverseKey/decryptionKey matrix ");
        int keyMatrix[][] = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                keyMatrix[i][j] = userInput.nextInt();
            }
        }
                validateDeterminant(keyMatrix,n);

                int[][] messageVector = new int[n][1];
        String PlainText = "";
        int plainMatrix[][] = new int[n][1];
        int j = 0;
        while (j < message.length()) {
            for (int i = 0; i < n; i++) {
                if (j >= message.length()) {
                    messageVector[i][0] = 23;
                } else {
                    messageVector[i][0] = (message.charAt(j)) % 65;
                }
                System.out.println(messageVector[i][0]);
                j++;
            }
            int x, i;
            for (i = 0; i < n; i++) {
                plainMatrix[i][0] = 0;

                for (x = 0; x < n; x++) {
                    plainMatrix[i][0] += keyMatrix[i][x] * messageVector[x][0];
                }

                plainMatrix[i][0] = plainMatrix[i][0] % 26;
            }
            for (i = 0; i < n; i++) {
                PlainText += (char) (plainMatrix[i][0] + 65);
            }
        }
        System.out.println("Plaintext: " + PlainText);
    }

        public static int determinant(int a[][], int n) {
        int det = 0, sign = 1, p = 0, q = 0;

        if (n == 1) {
            det = a[0][0];
        } else {
            int b[][] = new int[n - 1][n - 1];
            for (int x = 0; x < n; x++) {
                p = 0;
                q = 0;
                for (int i = 1; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        if (j != x) {
                            b[p][q++] = a[i][j];
                            if (q % (n - 1) == 0) {
                                p++;
                                q = 0;
                            }
                        }
                    }
                }
                det = det + a[0][x] * determinant(b, n - 1) * sign;
                sign = -sign;
            }
        }
        return det;
    }

        static void hillCipher(String message) {
        message.toUpperCase();
        System.out.println("What do you want to process from the message?");
        System.out.println("Press 1: To Encrypt");
        System.out.println("Press 2: To Decrypt");
        short sc = userInput.nextShort();
        if (sc == 1) {
            encrypt(message);
        } else if (sc == 2) {
            decrypt(message);
        } else {
            System.out.println("Invalid input, program terminated.");
        }
    }

    static void validateDeterminant(int[][] keyMatrix, int n){
        if (determinant(keyMatrix, n) % 26 == 0) {
            System.out.println("Invalid key, as determinant = 0. Program Terminated");
            return;
        }
    }

        public static void main(String[] args) {
                System.out.println("Enter message");
        String message = userInput.nextLine();
        hillCipher(message);
    }
}package com.thealgorithms.ciphers;

import java.util.Scanner;

class ProductCipher {

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the input to be encrypted: ");
        String substitutionInput = sc.nextLine();
        System.out.println(" ");
        System.out.println("Enter a number: ");
        int n = sc.nextInt();

                StringBuffer substitutionOutput = new StringBuffer();
        for (int i = 0; i < substitutionInput.length(); i++) {
            char c = substitutionInput.charAt(i);
            substitutionOutput.append((char) (c + 5));
        }
        System.out.println(" ");
        System.out.println("Substituted text: ");
        System.out.println(substitutionOutput);

                String transpositionInput = substitutionOutput.toString();
        int modulus;
        if ((modulus = transpositionInput.length() % n) != 0) {
            modulus = n - modulus;

            for (; modulus != 0; modulus--) {
                transpositionInput += "/";
            }
        }
        StringBuffer transpositionOutput = new StringBuffer();
        System.out.println(" ");
        System.out.println("Transposition Matrix: ");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < transpositionInput.length() / n; j++) {
                char c = transpositionInput.charAt(i + (j * n));
                System.out.print(c);
                transpositionOutput.append(c);
            }
            System.out.println();
        }
        System.out.println(" ");
        System.out.println("Final encrypted text: ");
        System.out.println(transpositionOutput);

                n = transpositionOutput.length() / n;
        StringBuffer transpositionPlaintext = new StringBuffer();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < transpositionOutput.length() / n; j++) {
                char c = transpositionOutput.charAt(i + (j * n));
                transpositionPlaintext.append(c);
            }
        }

                StringBuffer plaintext = new StringBuffer();
        for (int i = 0; i < transpositionPlaintext.length(); i++) {
            char c = transpositionPlaintext.charAt(i);
            plaintext.append((char) (c - 5));
        }

        System.out.println("Plaintext: ");
        System.out.println(plaintext);
        sc.close();
    }

}
package com.thealgorithms.ciphers;

public class Blowfish {
	
		String S[][]
			= { { "d1310ba6", "98dfb5ac", "2ffd72db", "d01adfb7", "b8e1afed",
				"6a267e96", "ba7c9045", "f12c7f99", "24a19947", "b3916cf7",
				"0801f2e2", "858efc16", "636920d8", "71574e69", "a458fea3",
				"f4933d7e", "0d95748f", "728eb658", "718bcd58", "82154aee",
				"7b54a41d", "c25a59b5", "9c30d539", "2af26013", "c5d1b023",
				"286085f0", "ca417918", "b8db38ef", "8e79dcb0", "603a180e",
				"6c9e0e8b", "b01e8a3e", "d71577c1", "bd314b27", "78af2fda",
				"55605c60", "e65525f3", "aa55ab94", "57489862", "63e81440",
				"55ca396a", "2aab10b6", "b4cc5c34", "1141e8ce", "a15486af",
				"7c72e993", "b3ee1411", "636fbc2a", "2ba9c55d", "741831f6",
				"ce5c3e16", "9b87931e", "afd6ba33", "6c24cf5c", "7a325381",
				"28958677", "3b8f4898", "6b4bb9af", "c4bfe81b", "66282193",
				"61d809cc", "fb21a991", "487cac60", "5dec8032", "ef845d5d",
				"e98575b1", "dc262302", "eb651b88", "23893e81", "d396acc5",
				"0f6d6ff3", "83f44239", "2e0b4482", "a4842004", "69c8f04a",
				"9e1f9b5e", "21c66842", "f6e96c9a", "670c9c61", "abd388f0",
				"6a51a0d2", "d8542f68", "960fa728", "ab5133a3", "6eef0b6c",
				"137a3be4", "ba3bf050", "7efb2a98", "a1f1651d", "39af0176",
				"66ca593e", "82430e88", "8cee8619", "456f9fb4", "7d84a5c3",
				"3b8b5ebe", "e06f75d8", "85c12073", "401a449f", "56c16aa6",
				"4ed3aa62", "363f7706", "1bfedf72", "429b023d", "37d0d724",
				"d00a1248", "db0fead3", "49f1c09b", "075372c9", "80991b7b",
				"25d479d8", "f6e8def7", "e3fe501a", "b6794c3b", "976ce0bd",
				"04c006ba", "c1a94fb6", "409f60c4", "5e5c9ec2", "196a2463",
				"68fb6faf", "3e6c53b5", "1339b2eb", "3b52ec6f", "6dfc511f",
				"9b30952c", "cc814544", "af5ebd09", "bee3d004", "de334afd",
				"660f2807", "192e4bb3", "c0cba857", "45c8740f", "d20b5f39",
				"b9d3fbdb", "5579c0bd", "1a60320a", "d6a100c6", "402c7279",
				"679f25fe", "fb1fa3cc", "8ea5e9f8", "db3222f8", "3c7516df",
				"fd616b15", "2f501ec8", "ad0552ab", "323db5fa", "fd238760",
				"53317b48", "3e00df82", "9e5c57bb", "ca6f8ca0", "1a87562e",
				"df1769db", "d542a8f6", "287effc3", "ac6732c6", "8c4f5573",
				"695b27b0", "bbca58c8", "e1ffa35d", "b8f011a0", "10fa3d98",
				"fd2183b8", "4afcb56c", "2dd1d35b", "9a53e479", "b6f84565",
				"d28e49bc", "4bfb9790", "e1ddf2da", "a4cb7e33", "62fb1341",
				"cee4c6e8", "ef20cada", "36774c01", "d07e9efe", "2bf11fb4",
				"95dbda4d", "ae909198", "eaad8e71", "6b93d5a0", "d08ed1d0",
				"afc725e0", "8e3c5b2f", "8e7594b7", "8ff6e2fb", "f2122b64",
				"8888b812", "900df01c", "4fad5ea0", "688fc31c", "d1cff191",
				"b3a8c1ad", "2f2f2218", "be0e1777", "ea752dfe", "8b021fa1",
				"e5a0cc0f", "b56f74e8", "18acf3d6", "ce89e299", "b4a84fe0",
				"fd13e0b7", "7cc43b81", "d2ada8d9", "165fa266", "80957705",
				"93cc7314", "211a1477", "e6ad2065", "77b5fa86", "c75442f5",
				"fb9d35cf", "ebcdaf0c", "7b3e89a0", "d6411bd3", "ae1e7e49",
				"00250e2d", "2071b35e", "226800bb", "57b8e0af", "2464369b",
				"f009b91e", "5563911d", "59dfa6aa", "78c14389", "d95a537f",
				"207d5ba2", "02e5b9c5", "83260376", "6295cfa9", "11c81968",
				"4e734a41", "b3472dca", "7b14a94a", "1b510052", "9a532915",
				"d60f573f", "bc9bc6e4", "2b60a476", "81e67400", "08ba6fb5",
				"571be91f", "f296ec6b", "2a0dd915", "b6636521", "e7b9f9b6",
				"ff34052e", "c5855664", "53b02d5d", "a99f8fa1", "08ba4799",
			"6e85076a" },
					{ "4b7a70e9", "b5b32944", "db75092e", "c4192623", "ad6ea6b0",
				"49a7df7d", "9cee60b8", "8fedb266", "ecaa8c71", "699a17ff",
				"5664526c", "c2b19ee1", "193602a5", "75094c29", "a0591340",
				"e4183a3e", "3f54989a", "5b429d65", "6b8fe4d6", "99f73fd6",
				"a1d29c07", "efe830f5", "4d2d38e6", "f0255dc1", "4cdd2086",
				"8470eb26", "6382e9c6", "021ecc5e", "09686b3f", "3ebaefc9",
				"3c971814", "6b6a70a1", "687f3584", "52a0e286", "b79c5305",
				"aa500737", "3e07841c", "7fdeae5c", "8e7d44ec", "5716f2b8",
				"b03ada37", "f0500c0d", "f01c1f04", "0200b3ff", "ae0cf51a",
				"3cb574b2", "25837a58", "dc0921bd", "d19113f9", "7ca92ff6",
				"94324773", "22f54701", "3ae5e581", "37c2dadc", "c8b57634",
				"9af3dda7", "a9446146", "0fd0030e", "ecc8c73e", "a4751e41",
				"e238cd99", "3bea0e2f", "3280bba1", "183eb331", "4e548b38",
				"4f6db908", "6f420d03", "f60a04bf", "2cb81290", "24977c79",
				"5679b072", "bcaf89af", "de9a771f", "d9930810", "b38bae12",
				"dccf3f2e", "5512721f", "2e6b7124", "501adde6", "9f84cd87",
				"7a584718", "7408da17", "bc9f9abc", "e94b7d8c", "ec7aec3a",
				"db851dfa", "63094366", "c464c3d2", "ef1c1847", "3215d908",
				"dd433b37", "24c2ba16", "12a14d43", "2a65c451", "50940002",
				"133ae4dd", "71dff89e", "10314e55", "81ac77d6", "5f11199b",
				"043556f1", "d7a3c76b", "3c11183b", "5924a509", "f28fe6ed",
				"97f1fbfa", "9ebabf2c", "1e153c6e", "86e34570", "eae96fb1",
				"860e5e0a", "5a3e2ab3", "771fe71c", "4e3d06fa", "2965dcb9",
				"99e71d0f", "803e89d6", "5266c825", "2e4cc978", "9c10b36a",
				"c6150eba", "94e2ea78", "a5fc3c53", "1e0a2df4", "f2f74ea7",
				"361d2b3d", "1939260f", "19c27960", "5223a708", "f71312b6",
				"ebadfe6e", "eac31f66", "e3bc4595", "a67bc883", "b17f37d1",
				"018cff28", "c332ddef", "be6c5aa5", "65582185", "68ab9802",
				"eecea50f", "db2f953b", "2aef7dad", "5b6e2f84", "1521b628",
				"29076170", "ecdd4775", "619f1510", "13cca830", "eb61bd96",
				"0334fe1e", "aa0363cf", "b5735c90", "4c70a239", "d59e9e0b",
				"cbaade14", "eecc86bc", "60622ca7", "9cab5cab", "b2f3846e",
				"648b1eaf", "19bdf0ca", "a02369b9", "655abb50", "40685a32",
				"3c2ab4b3", "319ee9d5", "c021b8f7", "9b540b19", "875fa099",
				"95f7997e", "623d7da8", "f837889a", "97e32d77", "11ed935f",
				"16681281", "0e358829", "c7e61fd6", "96dedfa1", "7858ba99",
				"57f584a5", "1b227263", "9b83c3ff", "1ac24696", "cdb30aeb",
				"532e3054", "8fd948e4", "6dbc3128", "58ebf2ef", "34c6ffea",
				"fe28ed61", "ee7c3c73", "5d4a14d9", "e864b7e3", "42105d14",
				"203e13e0", "45eee2b6", "a3aaabea", "db6c4f15", "facb4fd0",
				"c742f442", "ef6abbb5", "654f3b1d", "41cd2105", "d81e799e",
				"86854dc7", "e44b476a", "3d816250", "cf62a1f2", "5b8d2646",
				"fc8883a0", "c1c7b6a3", "7f1524c3", "69cb7492", "47848a0b",
				"5692b285", "095bbf00", "ad19489d", "1462b174", "23820e00",
				"58428d2a", "0c55f5ea", "1dadf43e", "233f7061", "3372f092",
				"8d937e41", "d65fecf1", "6c223bdb", "7cde3759", "cbee7460",
				"4085f2a7", "ce77326e", "a6078084", "19f8509e", "e8efd855",
				"61d99735", "a969a7aa", "c50c06c2", "5a04abfc", "800bcadc",
				"9e447a2e", "c3453484", "fdd56705", "0e1e9ec9", "db73dbd3",
				"105588cd", "675fda79", "e3674340", "c5c43465", "713e38d8",
				"3d28f89e", "f16dff20", "153e21e7", "8fb03d4a", "e6e39f2b",
					"db83adf7" },
					{ "e93d5a68", "948140f7", "f64c261c", "94692934", "411520f7",
						"7602d4f7", "bcf46b2e", "d4a20068", "d4082471", "3320f46a",
						"43b7d4b7", "500061af", "1e39f62e", "97244546", "14214f74",
						"bf8b8840", "4d95fc1d", "96b591af", "70f4ddd3", "66a02f45",
						"bfbc09ec", "03bd9785", "7fac6dd0", "31cb8504", "96eb27b3",
						"55fd3941", "da2547e6", "abca0a9a", "28507825", "530429f4",
						"0a2c86da", "e9b66dfb", "68dc1462", "d7486900", "680ec0a4",
						"27a18dee", "4f3ffea2", "e887ad8c", "b58ce006", "7af4d6b6",
						"aace1e7c", "d3375fec", "ce78a399", "406b2a42", "20fe9e35",
						"d9f385b9", "ee39d7ab", "3b124e8b", "1dc9faf7", "4b6d1856",
						"26a36631", "eae397b2", "3a6efa74", "dd5b4332", "6841e7f7",
						"ca7820fb", "fb0af54e", "d8feb397", "454056ac", "ba489527",
						"55533a3a", "20838d87", "fe6ba9b7", "d096954b", "55a867bc",
						"a1159a58", "cca92963", "99e1db33", "a62a4a56", "3f3125f9",
						"5ef47e1c", "9029317c", "fdf8e802", "04272f70", "80bb155c",
						"05282ce3", "95c11548", "e4c66d22", "48c1133f", "c70f86dc",
						"07f9c9ee", "41041f0f", "404779a4", "5d886e17", "325f51eb",
						"d59bc0d1", "f2bcc18f", "41113564", "257b7834", "602a9c60",
						"dff8e8a3", "1f636c1b", "0e12b4c2", "02e1329e", "af664fd1",
						"cad18115", "6b2395e0", "333e92e1", "3b240b62", "eebeb922",
						"85b2a20e", "e6ba0d99", "de720c8c", "2da2f728", "d0127845",
						"95b794fd", "647d0862", "e7ccf5f0", "5449a36f", "877d48fa",
						"c39dfd27", "f33e8d1e", "0a476341", "992eff74", "3a6f6eab",
						"f4f8fd37", "a812dc60", "a1ebddf8", "991be14c", "db6e6b0d",
						"c67b5510", "6d672c37", "2765d43b", "dcd0e804", "f1290dc7",
						"cc00ffa3", "b5390f92", "690fed0b", "667b9ffb", "cedb7d9c",
						"a091cf0b", "d9155ea3", "bb132f88", "515bad24", "7b9479bf",
						"763bd6eb", "37392eb3", "cc115979", "8026e297", "f42e312d",
						"6842ada7", "c66a2b3b", "12754ccc", "782ef11c", "6a124237",
						"b79251e7", "06a1bbe6", "4bfb6350", "1a6b1018", "11caedfa",
						"3d25bdd8", "e2e1c3c9", "44421659", "0a121386", "d90cec6e",
						"d5abea2a", "64af674e", "da86a85f", "bebfe988", "64e4c3fe",
						"9dbc8057", "f0f7c086", "60787bf8", "6003604d", "d1fd8346",
						"f6381fb0", "7745ae04", "d736fccc", "83426b33", "f01eab71",
						"b0804187", "3c005e5f", "77a057be", "bde8ae24", "55464299",
						"bf582e61", "4e58f48f", "f2ddfda2", "f474ef38", "8789bdc2",
						"5366f9c3", "c8b38e74", "b475f255", "46fcd9b9", "7aeb2661",
						"8b1ddf84", "846a0e79", "915f95e2", "466e598e", "20b45770",
						"8cd55591", "c902de4c", "b90bace1", "bb8205d0", "11a86248",
						"7574a99e", "b77f19b6", "e0a9dc09", "662d09a1", "c4324633",
						"e85a1f02", "09f0be8c", "4a99a025", "1d6efe10", "1ab93d1d",
						"0ba5a4df", "a186f20f", "2868f169", "dcb7da83", "573906fe",
						"a1e2ce9b", "4fcd7f52", "50115e01", "a70683fa", "a002b5c4",
						"0de6d027", "9af88c27", "773f8641", "c3604c06", "61a806b5",
						"f0177a28", "c0f586e0", "006058aa", "30dc7d62", "11e69ed7",
						"2338ea63", "53c2dd94", "c2c21634", "bbcbee56", "90bcb6de",
						"ebfc7da1", "ce591d76", "6f05e409", "4b7c0188", "39720a3d",
						"7c927c24", "86e3725f", "724d9db9", "1ac15bb4", "d39eb8fc",
						"ed545578", "08fca5b5", "d83d7cd3", "4dad0fc4", "1e50ef5e",
						"b161e6f8", "a28514d9", "6c51133c", "6fd5c7e7", "56e14ec4",
						"362abfce", "ddc6c837", "d79a3234", "92638212", "670efa8e",
					"406000e0" },
					{ "3a39ce37", "d3faf5cf", "abc27737", "5ac52d1b", "5cb0679e",
						"4fa33742", "d3822740", "99bc9bbe", "d5118e9d", "bf0f7315",
						"d62d1c7e", "c700c47b", "b78c1b6b", "21a19045", "b26eb1be",
						"6a366eb4", "5748ab2f", "bc946e79", "c6a376d2", "6549c2c8",
						"530ff8ee", "468dde7d", "d5730a1d", "4cd04dc6", "2939bbdb",
						"a9ba4650", "ac9526e8", "be5ee304", "a1fad5f0", "6a2d519a",
						"63ef8ce2", "9a86ee22", "c089c2b8", "43242ef6", "a51e03aa",
						"9cf2d0a4", "83c061ba", "9be96a4d", "8fe51550", "ba645bd6",
						"2826a2f9", "a73a3ae1", "4ba99586", "ef5562e9", "c72fefd3",
						"f752f7da", "3f046f69", "77fa0a59", "80e4a915", "87b08601",
						"9b09e6ad", "3b3ee593", "e990fd5a", "9e34d797", "2cf0b7d9",
						"022b8b51", "96d5ac3a", "017da67d", "d1cf3ed6", "7c7d2d28",
						"1f9f25cf", "adf2b89b", "5ad6b472", "5a88f54c", "e029ac71",
						"e019a5e6", "47b0acfd", "ed93fa9b", "e8d3c48d", "283b57cc",
						"f8d56629", "79132e28", "785f0191", "ed756055", "f7960e44",
						"e3d35e8c", "15056dd4", "88f46dba", "03a16125", "0564f0bd",
						"c3eb9e15", "3c9057a2", "97271aec", "a93a072a", "1b3f6d9b",
						"1e6321f5", "f59c66fb", "26dcf319", "7533d928", "b155fdf5",
						"03563482", "8aba3cbb", "28517711", "c20ad9f8", "abcc5167",
						"ccad925f", "4de81751", "3830dc8e", "379d5862", "9320f991",
						"ea7a90c2", "fb3e7bce", "5121ce64", "774fbe32", "a8b6e37e",
						"c3293d46", "48de5369", "6413e680", "a2ae0810", "dd6db224",
						"69852dfd", "09072166", "b39a460a", "6445c0dd", "586cdecf",
						"1c20c8ae", "5bbef7dd", "1b588d40", "ccd2017f", "6bb4e3bb",
						"dda26a7e", "3a59ff45", "3e350a44", "bcb4cdd5", "72eacea8",
						"fa6484bb", "8d6612ae", "bf3c6f47", "d29be463", "542f5d9e",
						"aec2771b", "f64e6370", "740e0d8d", "e75b1357", "f8721671",
						"af537d5d", "4040cb08", "4eb4e2cc", "34d2466a", "0115af84",
						"e1b00428", "95983a1d", "06b89fb4", "ce6ea048", "6f3f3b82",
						"3520ab82", "011a1d4b", "277227f8", "611560b1", "e7933fdc",
						"bb3a792b", "344525bd", "a08839e1", "51ce794b", "2f32c9b7",
						"a01fbac9", "e01cc87e", "bcc7d1f6", "cf0111c3", "a1e8aac7",
						"1a908749", "d44fbd9a", "d0dadecb", "d50ada38", "0339c32a",
						"c6913667", "8df9317c", "e0b12b4f", "f79e59b7", "43f5bb3a",
						"f2d519ff", "27d9459c", "bf97222c", "15e6fc2a", "0f91fc71",
						"9b941525", "fae59361", "ceb69ceb", "c2a86459", "12baa8d1",
						"b6c1075e", "e3056a0c", "10d25065", "cb03a442", "e0ec6e0e",
						"1698db3b", "4c98a0be", "3278e964", "9f1f9532", "e0d392df",
						"d3a0342b", "8971f21e", "1b0a7441", "4ba3348c", "c5be7120",
						"c37632d8", "df359f8d", "9b992f2e", "e60b6f47", "0fe3f11d",
						"e54cda54", "1edad891", "ce6279cf", "cd3e7e6f", "1618b166",
						"fd2c1d05", "848fd2c5", "f6fb2299", "f523f357", "a6327623",
						"93a83531", "56cccd02", "acf08162", "5a75ebb5", "6e163697",
						"88d273cc", "de966292", "81b949d0", "4c50901b", "71c65614",
						"e6c6c7bd", "327a140a", "45e1d006", "c3f27b9a", "c9aa53fd",
						"62a80f00", "bb25bfe2", "35bdd2f6", "71126905", "b2040222",
						"b6cbcf7c", "cd769c2b", "53113ec0", "1640e3d3", "38abbd60",
						"2547adf0", "ba38209c", "f746ce76", "77afa1c5", "20756060",
						"85cbfe4e", "8ae88dd8", "7aaaf9b0", "4cf9aa7e", "1948c25c",
						"02fb8a8c", "01c36ae4", "d6ebe1f9", "90d4f869", "a65cdea0",
						"3f09252d", "c208e69f", "b74e6132", "ce77e25b", "578fdfe3",
					"3ac372e6" } };

		String P[] = { "243f6a88", "85a308d3", "13198a2e", "03707344", "a4093822",
			"299f31d0", "082efa98", "ec4e6c89", "452821e6", "38d01377",
			"be5466cf", "34e90c6c", "c0ac29b7", "c97c50dd", "3f84d5b5",
			"b5470917", "9216d5d9", "8979fb1b" };

		long modVal = 4294967296L;
	

    
	private String hexToBin(String hex)
	{
		String binary = "";
		Long num;
		String binary4B;
		int n = hex.length();
		for (int i = 0; i < n; i++) {

			num = Long.parseUnsignedLong(
					hex.charAt(i) + "", 16);
			binary4B = Long.toBinaryString(num);

			binary4B = "0000" + binary4B;

			binary4B = binary4B.substring(binary4B.length() - 4);
			binary += binary4B;
		}
		return binary;
	}

    
	private String binToHex(String binary)
	{

		long num = Long.parseUnsignedLong(binary, 2);
		String hex = Long.toHexString(num);
		while (hex.length() < (binary.length() / 4))
			hex = "0" + hex;

		return hex;
	}

    
	private String xor(String a, String b)
	{
		a = hexToBin(a);
		b = hexToBin(b);
		String ans = "";
		for (int i = 0; i < a.length(); i++)
			ans += (char)(((a.charAt(i) - '0')
					^ (b.charAt(i) - '0'))
					+ '0');
		ans = binToHex(ans);
		return ans;
	}

    
	private String addBin(String a, String b)
	{
		String ans = "";
		long n1 = Long.parseUnsignedLong(a, 16);
		long n2 = Long.parseUnsignedLong(b, 16);
		n1 = (n1 + n2) % modVal;
		ans = Long.toHexString(n1);
		ans = "00000000" + ans;
		return ans.substring(ans.length() - 8);
	}

	private String f(String plainText)
	{
		String a[] = new String[4];
		String ans = "";
		for (int i = 0; i < 8; i += 2) {
						long col
			= Long.parseUnsignedLong(
					hexToBin(
							plainText
							.substring(i, i + 2)),
					2);
			a[i / 2] = S[i / 2][(int)col];
		}
		ans = addBin(a[0], a[1]);
		ans = xor(ans, a[2]);
		ans = addBin(ans, a[3]);
		return ans;
	}

		private void keyGenerate(String key)
	{
		int j = 0;
		for (int i = 0; i < P.length; i++) {

						P[i] = xor(P[i], key.substring(j, j + 8));

			j = (j + 8) % key.length();
		}
	}

		private String round(int time, String plainText)
	{
		String left, right;
		left = plainText.substring(0, 8);
		right = plainText.substring(8, 16);
		left = xor(left, P[time]);

				String fOut = f(left);

		right = xor(fOut, right);

				return right + left;
	}

    
	String encrypt(String plainText, String key)
	{
				keyGenerate(key);
		
		for (int i = 0; i < 16; i++)
			plainText = round(i, plainText);

				String right = plainText.substring(0, 8);
		String left = plainText.substring(8, 16);
		right = xor(right, P[16]);
		left = xor(left, P[17]);
		return left + right;
	}
	
    
    String decrypt(String cipherText,String key)
    {
    	    	keyGenerate(key);
    	
        for (int i = 17; i > 1; i--)
            cipherText = round(i, cipherText);
 
                String right = cipherText.substring(0, 8);
        String left = cipherText.substring(8, 16);
        right = xor(right, P[1]);
        left = xor(left, P[0]);
        return left + right;
    }

}
package com.thealgorithms.ciphers;

class AffineCipher {

        static int a = 17;
    static int b = 20;

    static String encryptMessage(char[] msg) {
                String cipher = "";
        for (int i = 0; i < msg.length; i++) {
                       
            if (msg[i] != ' ') {
                cipher = cipher
                        + (char) ((((a * (msg[i] - 'A')) + b) % 26) + 'A');
            } else             {
                cipher += msg[i];
            }
        }
        return cipher;
    }

    static String decryptCipher(String cipher) {
        String msg = "";
        int a_inv = 0;
        int flag = 0;

                        for (int i = 0; i < 26; i++) {
            flag = (a * i) % 26;

                                    if (flag == 1) {
                a_inv = i;
            }
        }
        for (int i = 0; i < cipher.length(); i++) {
            if (cipher.charAt(i) != ' ') {
                msg = msg + (char) (((a_inv
                        * ((cipher.charAt(i) + 'A' - b)) % 26)) + 'A');
            } else             {
                msg += cipher.charAt(i);
            }
        }

        return msg;
    }

        public static void main(String[] args) {
        String msg = "AFFINE CIPHER";

                String cipherText = encryptMessage(msg.toCharArray());
        System.out.println("Encrypted Message is : " + cipherText);

                System.out.println("Decrypted Message is: " + decryptCipher(cipherText));

    }
}
package com.thealgorithms.ciphers;


public class Vigenere {

    public static String encrypt(final String message, final String key) {

        StringBuilder result = new StringBuilder();

        for (int i = 0, j = 0; i < message.length(); i++) {
            char c = message.charAt(i);
            if (Character.isLetter(c)) {
                if (Character.isUpperCase(c)) {
                    result.append((char) ((c + key.toUpperCase().charAt(j) - 2 * 'A') % 26 + 'A'));

                } else {
                    result.append((char) ((c + key.toLowerCase().charAt(j) - 2 * 'a') % 26 + 'a'));
                }
            } else {
                result.append(c);
            }
            j = ++j % key.length();
        }
        return result.toString();
    }

    public static String decrypt(final String message, final String key) {
        StringBuilder result = new StringBuilder();

        for (int i = 0, j = 0; i < message.length(); i++) {

            char c = message.charAt(i);
            if (Character.isLetter(c)) {
                if (Character.isUpperCase(c)) {
                    result.append((char) ('Z' - (25 - (c - key.toUpperCase().charAt(j))) % 26));

                } else {
                    result.append((char) ('z' - (25 - (c - key.toLowerCase().charAt(j))) % 26));
                }
            } else {
                result.append(c);
            }

            j = ++j % key.length();
        }
        return result.toString();
    }

    public static void main(String[] args) {
        String text = "Hello World!";
        String key = "itsakey";
        System.out.println(text);
        String ciphertext = encrypt(text, key);
        System.out.println(ciphertext);
        System.out.println(decrypt(ciphertext, key));
    }
}
package com.thealgorithms.ciphers;

import java.math.BigInteger;
import java.util.Scanner;


public class AES {

    
    private static final int[] RCON = {
        0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
        0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
        0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
        0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
        0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
        0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
        0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
        0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
        0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
        0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
        0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
        0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
        0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
        0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
        0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
        0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
    };

    
    private static final int[] SBOX = {
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
    };

    
    private static final int[] INVERSE_SBOX = {
        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
    };

    
    private static final int[] MULT2 = {
        0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
        0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
        0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
        0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
        0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
        0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
        0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
        0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
        0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
        0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
        0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
        0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
        0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
        0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
        0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
        0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5
    };

    
    private static final int[] MULT3 = {
        0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
        0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
        0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
        0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
        0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
        0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
        0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
        0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
        0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
        0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
        0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
        0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
        0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
        0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
        0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
        0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a
    };

    
    private static final int[] MULT9 = {
        0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
        0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
        0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
        0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
        0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
        0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
        0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
        0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
        0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
        0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
        0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
        0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
        0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
        0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
        0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
        0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46
    };

    
    private static final int[] MULT11 = {
        0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
        0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
        0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
        0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
        0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
        0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
        0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
        0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
        0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
        0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
        0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
        0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
        0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
        0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
        0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
        0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3
    };

    
    private static final int[] MULT13 = {
        0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
        0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
        0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
        0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
        0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
        0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
        0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
        0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
        0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
        0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
        0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
        0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
        0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
        0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
        0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
        0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97
    };

    
    private static final int[] MULT14 = {
        0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
        0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
        0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
        0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
        0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
        0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
        0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
        0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
        0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
        0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
        0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
        0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
        0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
        0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
        0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
        0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d
    };

    
    public static BigInteger scheduleCore(BigInteger t, int rconCounter) {
        StringBuilder rBytes = new StringBuilder(t.toString(16));

                while (rBytes.length() < 8) {
            rBytes.insert(0, "0");
        }

                String rotatingBytes = rBytes.substring(0, 2);
        String fixedBytes = rBytes.substring(2);

        rBytes = new StringBuilder(fixedBytes + rotatingBytes);

                for (int i = 0; i < 4; i++) {
            StringBuilder currentByteBits = new StringBuilder(rBytes.substring(i * 2, (i + 1) * 2));

            int currentByte = Integer.parseInt(currentByteBits.toString(), 16);
            currentByte = SBOX[currentByte];

                        if (i == 0) {
                currentByte = currentByte ^ RCON[rconCounter];
            }

            currentByteBits = new StringBuilder(Integer.toHexString(currentByte));

                        while (currentByteBits.length() < 2) {
                currentByteBits.insert(0, '0');
            }

                        rBytes = new StringBuilder(rBytes.substring(0, i * 2) + currentByteBits + rBytes.substring((i + 1) * 2));
        }

                        return new BigInteger(rBytes.toString(), 16);
    }

    
    public static BigInteger[] keyExpansion(BigInteger initialKey) {
        BigInteger[] roundKeys = {
            initialKey,
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),
            new BigInteger("0"),};

                int rconCounter = 1;

        for (int i = 1; i < 11; i++) {

                        BigInteger t = roundKeys[i - 1].remainder(new BigInteger("100000000", 16));

                        BigInteger[] prevKey = {
                roundKeys[i - 1].remainder(new BigInteger("100000000", 16)),
                roundKeys[i - 1]
                .remainder(new BigInteger("10000000000000000", 16))
                .divide(new BigInteger("100000000", 16)),
                roundKeys[i - 1]
                .remainder(new BigInteger("1000000000000000000000000", 16))
                .divide(new BigInteger("10000000000000000", 16)),
                roundKeys[i - 1].divide(new BigInteger("1000000000000000000000000", 16)),};

                        t = scheduleCore(t, rconCounter);
            rconCounter += 1;

                        BigInteger t0 = t.xor(prevKey[3]);
            BigInteger t1 = t0.xor(prevKey[2]);
            BigInteger t2 = t1.xor(prevKey[1]);
            BigInteger t3 = t2.xor(prevKey[0]);

                        t2 = t2.multiply(new BigInteger("100000000", 16));
            t1 = t1.multiply(new BigInteger("10000000000000000", 16));
            t0 = t0.multiply(new BigInteger("1000000000000000000000000", 16));
            roundKeys[i] = t0.add(t1).add(t2).add(t3);
        }
        return roundKeys;
    }

    
    public static int[] splitBlockIntoCells(BigInteger block) {

        int[] cells = new int[16];
        StringBuilder blockBits = new StringBuilder(block.toString(2));

                while (blockBits.length() < 128) {
            blockBits.insert(0, '0');
        }

                for (int i = 0; i < cells.length; i++) {
            String cellBits = blockBits.substring(8 * i, 8 * (i + 1));
            cells[i] = Integer.parseInt(cellBits, 2);
        }

        return cells;
    }

    
    public static BigInteger mergeCellsIntoBlock(int[] cells) {

        StringBuilder blockBits = new StringBuilder();
        for (int i = 0; i < 16; i++) {
            StringBuilder cellBits = new StringBuilder(Integer.toBinaryString(cells[i]));

                        while (cellBits.length() < 8) {
                cellBits.insert(0, '0');
            }

            blockBits.append(cellBits);
        }

        return new BigInteger(blockBits.toString(), 2);
    }

    
    public static BigInteger addRoundKey(BigInteger ciphertext, BigInteger key) {
        return ciphertext.xor(key);
    }

    
    public static BigInteger subBytes(BigInteger ciphertext) {

        int[] cells = splitBlockIntoCells(ciphertext);

        for (int i = 0; i < 16; i++) {
            cells[i] = SBOX[cells[i]];
        }

        return mergeCellsIntoBlock(cells);
    }

    
    public static BigInteger subBytesDec(BigInteger ciphertext) {

        int[] cells = splitBlockIntoCells(ciphertext);

        for (int i = 0; i < 16; i++) {
            cells[i] = INVERSE_SBOX[cells[i]];
        }

        return mergeCellsIntoBlock(cells);
    }

    
    public static BigInteger shiftRows(BigInteger ciphertext) {
        int[] cells = splitBlockIntoCells(ciphertext);
        int[] output = new int[16];

                output[0] = cells[0];
        output[4] = cells[4];
        output[8] = cells[8];
        output[12] = cells[12];

                output[1] = cells[5];
        output[5] = cells[9];
        output[9] = cells[13];
        output[13] = cells[1];

                output[2] = cells[10];
        output[6] = cells[14];
        output[10] = cells[2];
        output[14] = cells[6];

                output[3] = cells[15];
        output[7] = cells[3];
        output[11] = cells[7];
        output[15] = cells[11];

        return mergeCellsIntoBlock(output);
    }

    
    public static BigInteger shiftRowsDec(BigInteger ciphertext) {
        int[] cells = splitBlockIntoCells(ciphertext);
        int[] output = new int[16];

                output[0] = cells[0];
        output[4] = cells[4];
        output[8] = cells[8];
        output[12] = cells[12];

                output[1] = cells[13];
        output[5] = cells[1];
        output[9] = cells[5];
        output[13] = cells[9];

                output[2] = cells[10];
        output[6] = cells[14];
        output[10] = cells[2];
        output[14] = cells[6];

                output[3] = cells[7];
        output[7] = cells[11];
        output[11] = cells[15];
        output[15] = cells[3];

        return mergeCellsIntoBlock(output);
    }

    
    public static BigInteger mixColumns(BigInteger ciphertext) {

        int[] cells = splitBlockIntoCells(ciphertext);
        int[] outputCells = new int[16];

        for (int i = 0; i < 4; i++) {
            int[] row = {cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3]};

            outputCells[i * 4] = MULT2[row[0]] ^ MULT3[row[1]] ^ row[2] ^ row[3];
            outputCells[i * 4 + 1] = row[0] ^ MULT2[row[1]] ^ MULT3[row[2]] ^ row[3];
            outputCells[i * 4 + 2] = row[0] ^ row[1] ^ MULT2[row[2]] ^ MULT3[row[3]];
            outputCells[i * 4 + 3] = MULT3[row[0]] ^ row[1] ^ row[2] ^ MULT2[row[3]];
        }
        return mergeCellsIntoBlock(outputCells);
    }

    
    public static BigInteger mixColumnsDec(BigInteger ciphertext) {

        int[] cells = splitBlockIntoCells(ciphertext);
        int[] outputCells = new int[16];

        for (int i = 0; i < 4; i++) {
            int[] row = {cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3]};

            outputCells[i * 4] = MULT14[row[0]] ^ MULT11[row[1]] ^ MULT13[row[2]] ^ MULT9[row[3]];
            outputCells[i * 4 + 1] = MULT9[row[0]] ^ MULT14[row[1]] ^ MULT11[row[2]] ^ MULT13[row[3]];
            outputCells[i * 4 + 2] = MULT13[row[0]] ^ MULT9[row[1]] ^ MULT14[row[2]] ^ MULT11[row[3]];
            outputCells[i * 4 + 3] = MULT11[row[0]] ^ MULT13[row[1]] ^ MULT9[row[2]] ^ MULT14[row[3]];
        }
        return mergeCellsIntoBlock(outputCells);
    }

    
    public static BigInteger encrypt(BigInteger plainText, BigInteger key) {
        BigInteger[] roundKeys = keyExpansion(key);

                plainText = addRoundKey(plainText, roundKeys[0]);

                for (int i = 1; i < 10; i++) {
            plainText = subBytes(plainText);
            plainText = shiftRows(plainText);
            plainText = mixColumns(plainText);
            plainText = addRoundKey(plainText, roundKeys[i]);
        }

                plainText = subBytes(plainText);
        plainText = shiftRows(plainText);
        plainText = addRoundKey(plainText, roundKeys[10]);

        return plainText;
    }

    
    public static BigInteger decrypt(BigInteger cipherText, BigInteger key) {

        BigInteger[] roundKeys = keyExpansion(key);

                cipherText = addRoundKey(cipherText, roundKeys[10]);
        cipherText = shiftRowsDec(cipherText);
        cipherText = subBytesDec(cipherText);

                for (int i = 9; i > 0; i--) {
            cipherText = addRoundKey(cipherText, roundKeys[i]);
            cipherText = mixColumnsDec(cipherText);
            cipherText = shiftRowsDec(cipherText);
            cipherText = subBytesDec(cipherText);
        }

                cipherText = addRoundKey(cipherText, roundKeys[0]);

        return cipherText;
    }

    public static void main(String[] args) {

        try (Scanner input = new Scanner(System.in)) {
            System.out.println("Enter (e) letter for encrpyt or (d) letter for decrypt :");
            char choice = input.nextLine().charAt(0);
            String in;
            switch (choice) {
                case 'E', 'e' -> {
                    System.out.println("Choose a plaintext block (128-Bit Integer in base 16):");
                    in = input.nextLine();
                    BigInteger plaintext = new BigInteger(in, 16);
                    System.out.println("Choose a Key (128-Bit Integer in base 16):");
                    in = input.nextLine();
                    BigInteger encryptionKey = new BigInteger(in, 16);
                    System.out.println(
                            "The encrypted message is: \n" + encrypt(plaintext, encryptionKey).toString(16));
                }
                case 'D', 'd' -> {
                    System.out.println("Enter your ciphertext block (128-Bit Integer in base 16):");
                    in = input.nextLine();
                    BigInteger ciphertext = new BigInteger(in, 16);
                    System.out.println("Choose a Key (128-Bit Integer in base 16):");
                    in = input.nextLine();
                    BigInteger decryptionKey = new BigInteger(in, 16);
                    System.out.println(
                            "The deciphered message is:\n" + decrypt(ciphertext, decryptionKey).toString(16));
                }
                default ->
                    System.out.println("** End **");
            }
        }
    }
}
package com.thealgorithms.ciphers;

import javax.swing.*;
import java.math.BigInteger;
import java.security.SecureRandom;


public final class RSA {

    public static void main(String[] args) {

        RSA rsa = new RSA(1024);
        String text1 = JOptionPane.showInputDialog("Enter a message to encrypt :");

        String ciphertext = rsa.encrypt(text1);
        JOptionPane.showMessageDialog(null, "Your encrypted message : " + ciphertext);

        JOptionPane.showMessageDialog(null, "Your message after decrypt : " + rsa.decrypt(ciphertext));
    }

    private BigInteger modulus, privateKey, publicKey;

    public RSA(int bits) {
        generateKeys(bits);
    }

    
    public synchronized String encrypt(String message) {
        return (new BigInteger(message.getBytes())).modPow(publicKey, modulus).toString();
    }

    
    public synchronized BigInteger encrypt(BigInteger message) {
        return message.modPow(publicKey, modulus);
    }

    
    public synchronized String decrypt(String encryptedMessage) {
        return new String((new BigInteger(encryptedMessage)).modPow(privateKey, modulus).toByteArray());
    }

    
    public synchronized BigInteger decrypt(BigInteger encryptedMessage) {
        return encryptedMessage.modPow(privateKey, modulus);
    }

    
    public synchronized void generateKeys(int bits) {
        SecureRandom r = new SecureRandom();
        BigInteger p = new BigInteger(bits / 2, 100, r);
        BigInteger q = new BigInteger(bits / 2, 100, r);
        modulus = p.multiply(q);

        BigInteger m = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));

        publicKey = new BigInteger("3");

        while (m.gcd(publicKey).intValue() > 1) {
            publicKey = publicKey.add(new BigInteger("2"));
        }

        privateKey = publicKey.modInverse(m);
    }
}
package com.thealgorithms.ciphers;

import javax.crypto.*;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;


public class AESEncryption {

    private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();

    
    public static void main(String[] args) throws Exception {
        String plainText = "Hello World";
        SecretKey secKey = getSecretEncryptionKey();
        byte[] cipherText = encryptText(plainText, secKey);
        String decryptedText = decryptText(cipherText, secKey);

        System.out.println("Original Text:" + plainText);
        System.out.println("AES Key (Hex Form):" + bytesToHex(secKey.getEncoded()));
        System.out.println("Encrypted Text (Hex Form):" + bytesToHex(cipherText));
        System.out.println("Descrypted Text:" + decryptedText);
    }

    
    public static SecretKey getSecretEncryptionKey() throws NoSuchAlgorithmException {
        KeyGenerator aesKeyGenerator = KeyGenerator.getInstance("AES");
        aesKeyGenerator.init(128);         return aesKeyGenerator.generateKey();
    }

    
    public static byte[] encryptText(String plainText, SecretKey secKey)
            throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
            IllegalBlockSizeException, BadPaddingException {
                Cipher aesCipher = Cipher.getInstance("AES");
        aesCipher.init(Cipher.ENCRYPT_MODE, secKey);
        return aesCipher.doFinal(plainText.getBytes());
    }

    
    public static String decryptText(byte[] byteCipherText, SecretKey secKey)
            throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
            IllegalBlockSizeException, BadPaddingException {
                Cipher aesCipher = Cipher.getInstance("AES");
        aesCipher.init(Cipher.DECRYPT_MODE, secKey);
        byte[] bytePlainText = aesCipher.doFinal(byteCipherText);
        return new String(bytePlainText);
    }

    
    public static String bytesToHex(byte[] bytes) {
        char[] hexChars = new char[bytes.length * 2];
        for (int j = 0; j < bytes.length; j++) {
            int v = bytes[j] & 0xFF;
            hexChars[j * 2] = HEX_ARRAY[v >>> 4];
            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
        }
        return new String(hexChars);
    }
}
package com.thealgorithms.divideandconquer;

public class BinaryExponentiation {

    public static void main(String args[]) {
        System.out.println(calculatePower(2, 30));
    }

            public static long calculatePower(long x, long y) {
        if (y == 0) {
            return 1;
        }
        long val = calculatePower(x, y / 2);
        val *= val;
        if (y % 2 == 1) {
            val *= x;
        }
        return val;
    }
}
package com.thealgorithms.divideandconquer;


public final class ClosestPair {

    
    int numberPoints;
    
    private Location[] array;
    
    Location point1 = null;
    
    Location point2 = null;
    
    private static double minNum = Double.MAX_VALUE;

    public static void setMinNum(double minNum) {
        ClosestPair.minNum = minNum;
    }

    public static void setSecondCount(int secondCount) {
        ClosestPair.secondCount = secondCount;
    }

    
    private static int secondCount = 0;

    
    ClosestPair(int points) {
        numberPoints = points;
        array = new Location[numberPoints];
    }

    
    public static class Location {

        double x;
        double y;

        
        Location(final double xpar, final double ypar) {             this.x = xpar;
            this.y = ypar;
        }
    }

    public Location[] createLocation(int numberValues) {
        return new Location[numberValues];
    }

    public Location buildLocation(double x, double y) {
        return new Location(x, y);
    }

    
    public int xPartition(final Location[] a, final int first, final int last) {

        Location pivot = a[last];         int i = first - 1;
        Location temp;         for (int j = first; j <= last - 1; j++) {
            if (a[j].x <= pivot.x) {                 i++;
                temp = a[i];                 a[i] = a[j];
                a[j] = temp;
            }
        }
        i++;
        temp = a[i];         a[i] = a[last];
        a[last] = temp;
        return i;     }

    
    public int yPartition(final Location[] a, final int first, final int last) {

        Location pivot = a[last];         int i = first - 1;
        Location temp;         for (int j = first; j <= last - 1; j++) {
            if (a[j].y <= pivot.y) {                 i++;
                temp = a[i];                 a[i] = a[j];
                a[j] = temp;
            }
        }
        i++;
        temp = a[i];         a[i] = a[last];
        a[last] = temp;
        return i;     }

    
    public void xQuickSort(final Location[] a, final int first, final int last) {

        if (first < last) {
            int q = xPartition(a, first, last);             xQuickSort(a, first, q - 1);             xQuickSort(a, q + 1, last);         }
    }

    
    public void yQuickSort(final Location[] a, final int first, final int last) {

        if (first < last) {
            int q = yPartition(a, first, last);             yQuickSort(a, first, q - 1);             yQuickSort(a, q + 1, last);         }
    }

    
    public double closestPair(final Location[] a, final int indexNum) {

        Location[] divideArray = new Location[indexNum];
        System.arraycopy(a, 0, divideArray, 0, indexNum);         int divideX = indexNum / 2;         Location[] leftArray = new Location[divideX];                 Location[] rightArray = new Location[indexNum - divideX];
        if (indexNum <= 3) {             return bruteForce(divideArray);
        }
                System.arraycopy(divideArray, 0, leftArray, 0, divideX);
                System.arraycopy(divideArray, divideX, rightArray, 0, indexNum - divideX);

        double minLeftArea;         double minRightArea;         double minValue; 
        minLeftArea = closestPair(leftArray, divideX);         minRightArea = closestPair(rightArray, indexNum - divideX);
                minValue = Math.min(minLeftArea, minRightArea);

                        for (int i = 0; i < indexNum; i++) {
            double xGap = Math.abs(divideArray[divideX].x - divideArray[i].x);
            if (xGap < minValue) {
                ClosestPair.setSecondCount(secondCount + 1);             } else {
                if (divideArray[i].x > divideArray[divideX].x) {
                    break;
                }
            }
        }
                Location[] firstWindow = new Location[secondCount];
        int k = 0;
        for (int i = 0; i < indexNum; i++) {
            double xGap = Math.abs(divideArray[divideX].x - divideArray[i].x);
            if (xGap < minValue) {                 firstWindow[k] = divideArray[i];                 k++;
            } else {
                if (divideArray[i].x > divideArray[divideX].x) {
                    break;
                }
            }
        }
        yQuickSort(firstWindow, 0, secondCount - 1);
        double length;
                for (int i = 0; i < secondCount - 1; i++) {
            for (int j = (i + 1); j < secondCount; j++) {
                double xGap = Math.abs(firstWindow[i].x - firstWindow[j].x);
                double yGap = Math.abs(firstWindow[i].y - firstWindow[j].y);
                if (yGap < minValue) {
                    length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));
                                        if (length < minValue) {
                                                minValue = length;
                                                if (length < minNum) {
                            ClosestPair.setMinNum(length);
                            point1 = firstWindow[i];
                            point2 = firstWindow[j];
                        }
                    }
                } else {
                    break;
                }
            }
        }
        ClosestPair.setSecondCount(0);
        return minValue;
    }

    
    public double bruteForce(final Location[] arrayParam) {

        double minValue = Double.MAX_VALUE;         double length;
        double xGap;         double yGap;         double result = 0;

        if (arrayParam.length == 2) {
                        xGap = (arrayParam[0].x - arrayParam[1].x);
                        yGap = (arrayParam[0].y - arrayParam[1].y);
                        length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));
                        if (length < minNum) {
                ClosestPair.setMinNum(length);
            }
            point1 = arrayParam[0];
            point2 = arrayParam[1];
            result = length;
        }
        if (arrayParam.length == 3) {
            for (int i = 0; i < arrayParam.length - 1; i++) {
                for (int j = (i + 1); j < arrayParam.length; j++) {
                                        xGap = (arrayParam[i].x - arrayParam[j].x);
                                        yGap = (arrayParam[i].y - arrayParam[j].y);
                                        length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));
                                        if (length < minValue) {
                                                minValue = length;
                        if (length < minNum) {
                                                        ClosestPair.setMinNum(length);
                            point1 = arrayParam[i];
                            point2 = arrayParam[j];
                        }
                    }
                }
            }
            result = minValue;
        }
        return result;     }

    
    public static void main(final String[] args) {

                ClosestPair cp = new ClosestPair(12);
        cp.array[0] = cp.buildLocation(2, 3);
        cp.array[1] = cp.buildLocation(2, 16);
        cp.array[2] = cp.buildLocation(3, 9);
        cp.array[3] = cp.buildLocation(6, 3);
        cp.array[4] = cp.buildLocation(7, 7);
        cp.array[5] = cp.buildLocation(19, 4);
        cp.array[6] = cp.buildLocation(10, 11);
        cp.array[7] = cp.buildLocation(15, 2);
        cp.array[8] = cp.buildLocation(15, 19);
        cp.array[9] = cp.buildLocation(16, 11);
        cp.array[10] = cp.buildLocation(17, 13);
        cp.array[11] = cp.buildLocation(9, 12);

        System.out.println("Input data");
        System.out.println("Number of points: " + cp.array.length);
        for (int i = 0; i < cp.array.length; i++) {
            System.out.println("x: " + cp.array[i].x + ", y: " + cp.array[i].y);
        }

        cp.xQuickSort(cp.array, 0, cp.array.length - 1); 
        double result; 
        result = cp.closestPair(cp.array, cp.array.length);
                        System.out.println("Output Data");
        System.out.println("(" + cp.point1.x + ", " + cp.point1.y + ")");
        System.out.println("(" + cp.point2.x + ", " + cp.point2.y + ")");
        System.out.println("Minimum Distance : " + result);
    }
}
package com.thealgorithms.divideandconquer;

import java.util.ArrayList;
import java.util.Comparator;


public class SkylineAlgorithm {

    private ArrayList<Point> points;

    
    public SkylineAlgorithm() {
        points = new ArrayList<>();
    }

    
    public ArrayList<Point> getPoints() {
        return points;
    }

    
    public ArrayList<Point> produceSubSkyLines(ArrayList<Point> list) {

                int size = list.size();
        if (size == 1) {
            return list;
        } else if (size == 2) {
            if (list.get(0).dominates(list.get(1))) {
                list.remove(1);
            } else {
                if (list.get(1).dominates(list.get(0))) {
                    list.remove(0);
                }
            }
            return list;
        }

                ArrayList<Point> leftHalf = new ArrayList<>();
        ArrayList<Point> rightHalf = new ArrayList<>();
        for (int i = 0; i < list.size(); i++) {
            if (i < list.size() / 2) {
                leftHalf.add(list.get(i));
            } else {
                rightHalf.add(list.get(i));
            }
        }
        ArrayList<Point> leftSubSkyLine = produceSubSkyLines(leftHalf);
        ArrayList<Point> rightSubSkyLine = produceSubSkyLines(rightHalf);

                return produceFinalSkyLine(leftSubSkyLine, rightSubSkyLine);
    }

    
    public ArrayList<Point> produceFinalSkyLine(ArrayList<Point> left, ArrayList<Point> right) {

                for (int i = 0; i < left.size() - 1; i++) {
            if (left.get(i).x == left.get(i + 1).x && left.get(i).y > left.get(i + 1).y) {
                left.remove(i);
                i--;
            }
        }

                int min = left.get(0).y;
        for (int i = 1; i < left.size(); i++) {
            if (min > left.get(i).y) {
                min = left.get(i).y;
                if (min == 1) {
                    i = left.size();
                }
            }
        }

                for (int i = 0; i < right.size(); i++) {
            if (right.get(i).y >= min) {
                right.remove(i);
                i--;
            }
        }

                left.addAll(right);
        return left;
    }

    public static class Point {

        private int x;
        private int y;

        
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        
        public int getX() {
            return x;
        }

        
        public int getY() {
            return y;
        }

        
        public boolean dominates(Point p1) {
                        return (this.x < p1.x && this.y <= p1.y) || (this.x <= p1.x && this.y < p1.y);
        }
    }

    
    class XComparator implements Comparator<Point> {

        @Override
        public int compare(Point a, Point b) {
            return Integer.compare(a.x, b.x);
        }
    }
}
package com.thealgorithms.divideandconquer;

public class StrassenMatrixMultiplication {

            public int[][] multiply(int[][] A, int[][] B) {
        int n = A.length;

        int[][] R = new int[n][n];

        if (n == 1) {
            R[0][0] = A[0][0] * B[0][0];
        } else {
                                    int[][] A11 = new int[n / 2][n / 2];
            int[][] A12 = new int[n / 2][n / 2];
            int[][] A21 = new int[n / 2][n / 2];
            int[][] A22 = new int[n / 2][n / 2];
            int[][] B11 = new int[n / 2][n / 2];
            int[][] B12 = new int[n / 2][n / 2];
            int[][] B21 = new int[n / 2][n / 2];
            int[][] B22 = new int[n / 2][n / 2];

                        split(A, A11, 0, 0);
            split(A, A12, 0, n / 2);
            split(A, A21, n / 2, 0);
            split(A, A22, n / 2, n / 2);

                        split(B, B11, 0, 0);
            split(B, B12, 0, n / 2);
            split(B, B21, n / 2, 0);
            split(B, B22, n / 2, n / 2);

                                    int[][] M1
                    = multiply(add(A11, A22), add(B11, B22));

                        int[][] M2 = multiply(add(A21, A22), B11);

                        int[][] M3 = multiply(A11, sub(B12, B22));

                        int[][] M4 = multiply(A22, sub(B21, B11));

                        int[][] M5 = multiply(add(A11, A12), B22);

                        int[][] M6
                    = multiply(sub(A21, A11), add(B11, B12));

                        int[][] M7
                    = multiply(sub(A12, A22), add(B21, B22));

                        int[][] C11 = add(sub(add(M1, M4), M5), M7);

                        int[][] C12 = add(M3, M5);

                        int[][] C21 = add(M2, M4);

                        int[][] C22 = add(sub(add(M1, M3), M2), M6);

            join(C11, R, 0, 0);
            join(C12, R, 0, n / 2);
            join(C21, R, n / 2, 0);
            join(C22, R, n / 2, n / 2);
        }

        return R;
    }

            public int[][] sub(int[][] A, int[][] B) {
        int n = A.length;

        int[][] C = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                C[i][j] = A[i][j] - B[i][j];
            }
        }

        return C;
    }

            public int[][] add(int[][] A, int[][] B) {

        int n = A.length;

        int[][] C = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                C[i][j] = A[i][j] + B[i][j];
            }
        }

        return C;
    }

                public void split(int[][] P, int[][] C, int iB, int jB) {
        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {
            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {
                C[i1][j1] = P[i2][j2];
            }
        }
    }

                public void join(int[][] C, int[][] P, int iB, int jB) {
        for (int i1 = 0, i2 = iB; i1 < C.length; i1++, i2++) {
            for (int j1 = 0, j2 = jB; j1 < C.length; j1++, j2++) {
                P[i2][j2] = C[i1][j1];
            }
        }
    }

            public static void main(String[] args) {
        System.out.println("Strassen Multiplication Algorithm Implementation For Matrix Multiplication :\n");

        StrassenMatrixMultiplication s = new StrassenMatrixMultiplication();

                        int N = 4;

                        int[][] A = {{1, 2, 5, 4},
        {9, 3, 0, 6},
        {4, 6, 3, 1},
        {0, 2, 0, 6}};

                        int[][] B = {{1, 0, 4, 1},
        {1, 2, 0, 2},
        {0, 3, 1, 3},
        {1, 8, 1, 2}};

                        int[][] C = s.multiply(A, B);

        System.out.println("\nProduct of matrices A and  B : ");

                for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.print(C[i][j] + " ");
            }
            System.out.println();
        }
    }
}
package com.thealgorithms.maths;


public class PerfectNumber {

    public static void main(String[] args) {
        assert isPerfectNumber(6);
        assert !isPerfectNumber(8);
        assert isPerfectNumber(28);
    }

    
    public static boolean isPerfectNumber(int number) {
        int sum = 0;
        for (int i = 1; i < number; ++i) {
            if (number % i == 0) {
                sum += i;
            }
        }
        return sum == number;
    }
}
package com.thealgorithms.maths;

public class PiNilakantha {

                public static void main(String[] args) {
        assert calculatePi(0) == 3.0;
        assert calculatePi(10) > 3.0;
        assert calculatePi(100) < 4.0;

        System.out.println(calculatePi(500));
    }

    
    public static double calculatePi(int iterations) {
        if (iterations < 0 || iterations > 500) {
            throw new IllegalArgumentException("Please input Integer Number between 0 and 500");
        }

        double pi = 3;
        int divCounter = 2;

        for (int i = 0; i < iterations; i++) {

            if (i % 2 == 0) {
                pi = pi + 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2));
            } else {
                pi = pi - 4.0 / (divCounter * (divCounter + 1) * (divCounter + 2));
            }

            divCounter += 2;
        }
        return pi;
    }
}
package com.thealgorithms.maths;

public class LeonardoNumber {

    public static int leonardoNumber(int n) {
        if (n < 0) {
            return 0;
        }
        if (n == 0 || n == 1) {
            return 1;
        }
        return (leonardoNumber(n - 1) + leonardoNumber(n - 2) + 1);
    }

    public static void main(String args[]) {
        for (int i = 0; i < 20; i++) {
            System.out.print(leonardoNumber(i) + " ");
        }

    }
}
package com.thealgorithms.maths;

public class StandardScore {
	public static double zScore(double num, double mean, double stdDev)
	{
		double z = (num - mean)/stdDev;
		return z;
	}
}
package com.thealgorithms.maths;


import java.io.*;

public class KrishnamurthyNumber {
    
    public static boolean isKMurthy(int n) {
                int s = 0;
                int tmp = n;

                if (n <= 0) {
            return false;
        }         else {
            while (n != 0) {
                                int fact = 1;
                                for (int i = 1; i <= n % 10; i++) {
                    fact = fact * i;
                }
                                s = s + fact;
                                n = n / 10;
            }

                        if (tmp == s) {
                return true;
            } else {
                return false;
            }
        }
    }

    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter a number to check if it is a Krishnamurthy number: ");
        int n = Integer.parseInt(br.readLine());
        if (isKMurthy(n)) {
            System.out.println(n + " is a Krishnamurthy number.");
        } else {
            System.out.println(n + " is NOT a Krishnamurthy number.");
        }
    }
}
package com.thealgorithms.maths;

public class ParseInteger {

    public static void main(String[] args) {
        assert parseInt("123") == Integer.parseInt("123");
        assert parseInt("-123") == Integer.parseInt("-123");
        assert parseInt("0123") == Integer.parseInt("0123");
        assert parseInt("+123") == Integer.parseInt("+123");
    }

    
    public static int parseInt(String s) {
        if (s == null || s.length() == 0) {
            throw new NumberFormatException("null");
        }
        boolean isNegative = s.charAt(0) == '-';
        boolean isPositive = s.charAt(0) == '+';
        int number = 0;
        for (int i = isNegative ? 1 : isPositive ? 1 : 0, length = s.length(); i < length; ++i) {
            if (!Character.isDigit(s.charAt(i))) {
                throw new NumberFormatException("s=" + s);
            }
            number = number * 10 + s.charAt(i) - '0';
        }
        return isNegative ? -number : number;
    }
}
package com.thealgorithms.maths;


public class PowerOfTwoOrNot {

    public static void main(String[] args) {
        assert !checkIfPowerOfTwoOrNot(0);
        assert checkIfPowerOfTwoOrNot(1);
        assert checkIfPowerOfTwoOrNot(8);
        assert checkIfPowerOfTwoOrNot(16);
        assert checkIfPowerOfTwoOrNot(1024);
    }

    
    public static boolean checkIfPowerOfTwoOrNot(int number) {
        return number != 0 && ((number & (number - 1)) == 0);
    }
}
package com.thealgorithms.maths;


public class PronicNumber {

	
	static boolean isPronic(int input_number) {
		
				for(int i = 0; i <= input_number; i++) {
			
						if(i * (i+1) == input_number && i != input_number) {
				
								return true;
			}
			
		}
		
				return false;
	}
}
package com.thealgorithms.maths;


public class NumberOfDigits {

    public static void main(String[] args) {
        int[] numbers = {0, 12, 123, 1234, -12345, 123456, 1234567, 12345678, 123456789};
        for (int i = 0; i < numbers.length; ++i) {
            assert numberOfDigits(numbers[i]) == i + 1;
            assert numberOfDigitsFast(numbers[i]) == i + 1;
            assert numberOfDigitsFaster(numbers[i]) == i + 1;
            assert numberOfDigitsRecursion(numbers[i]) == i + 1;
        }
    }

    
    private static int numberOfDigits(int number) {
        int digits = 0;
        do {
            digits++;
            number /= 10;
        } while (number != 0);
        return digits;
    }

    
    private static int numberOfDigitsFast(int number) {
        return number == 0 ? 1 : (int) Math.floor(Math.log10(Math.abs(number)) + 1);
    }

    
    private static int numberOfDigitsFaster(int number) {
        return number < 0 ? (-number + "").length() : (number + "").length();
    }

    
    private static int numberOfDigitsRecursion(int number) {
        return number / 10 == 0 ? 1 : 1 + numberOfDigitsRecursion(number / 10);
    }
}
package com.thealgorithms.maths;

public class PowRecursion {

    public static void main(String[] args) {
        assert Double.compare(pow(2, 0), Math.pow(2, 0)) == 0;
        assert Double.compare(pow(0, 2), Math.pow(0, 2)) == 0;
        assert Double.compare(pow(2, 10), Math.pow(2, 10)) == 0;
        assert Double.compare(pow(10, 2), Math.pow(10, 2)) == 0;
    }

    
    public static long pow(int a, int b) {
        return b == 0 ? 1 : a * pow(a, b - 1);
    }
}
package com.thealgorithms.maths;

public class SumOfDigits {

    public static void main(String[] args) {
        assert sumOfDigits(-123) == 6 && sumOfDigitsRecursion(-123) == 6 && sumOfDigitsFast(-123) == 6;

        assert sumOfDigits(0) == 0 && sumOfDigitsRecursion(0) == 0 && sumOfDigitsFast(0) == 0;

        assert sumOfDigits(12345) == 15
                && sumOfDigitsRecursion(12345) == 15
                && sumOfDigitsFast(12345) == 15;
    }

    
    public static int sumOfDigits(int number) {
        number = number < 0 ? -number : number;
        int sum = 0;
        while (number != 0) {
            sum += number % 10;
            number /= 10;
        }
        return sum;
    }

    
    public static int sumOfDigitsRecursion(int number) {
        number = number < 0 ? -number : number;
        return number < 10 ? number : number % 10 + sumOfDigitsRecursion(number / 10);
    }

    
    public static int sumOfDigitsFast(int number) {
        number = number < 0 ? -number : number;
        char[] digits = (number + "").toCharArray();
        int sum = 0;
        for (int i = 0; i < digits.length; ++i) {
            sum += digits[i] - '0';
        }
        return sum;
    }
}
package com.thealgorithms.maths;


public class LucasSeries {

    public static void main(String[] args) {
        assert lucasSeries(1) == 2 && lucasSeriesIteration(1) == 2;
        assert lucasSeries(2) == 1 && lucasSeriesIteration(2) == 1;
        assert lucasSeries(3) == 3 && lucasSeriesIteration(3) == 3;
        assert lucasSeries(4) == 4 && lucasSeriesIteration(4) == 4;
        assert lucasSeries(5) == 7 && lucasSeriesIteration(5) == 7;
        assert lucasSeries(6) == 11 && lucasSeriesIteration(6) == 11;
        assert lucasSeries(11) == 123 && lucasSeriesIteration(11) == 123;
    }

    
    public static int lucasSeries(int n) {
        return n == 1 ? 2 : n == 2 ? 1 : lucasSeries(n - 1) + lucasSeries(n - 2);
    }

    
    public static int lucasSeriesIteration(int n) {
        int previous = 2;
        int current = 1;
        for (int i = 1; i < n; i++) {
            int next = previous + current;
            previous = current;
            current = next;
        }
        return previous;
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;


public class ConvolutionFFT {

    
    private static void padding(ArrayList<FFT.Complex> x, int newSize) {
        if (x.size() < newSize) {
            int diff = newSize - x.size();
            for (int i = 0; i < diff; i++) {
                x.add(new FFT.Complex());
            }
        }
    }

    
    public static ArrayList<FFT.Complex> convolutionFFT(
            ArrayList<FFT.Complex> a, ArrayList<FFT.Complex> b) {
        int convolvedSize = a.size() + b.size() - 1;         padding(a, convolvedSize);         padding(b, convolvedSize);

        FFT.fft(a, false);
        FFT.fft(b, false);
        ArrayList<FFT.Complex> convolved = new ArrayList<>();

        for (int i = 0; i < a.size(); i++) {
            convolved.add(a.get(i).multiply(b.get(i)));         }
        FFT.fft(convolved, true);         convolved
                .subList(convolvedSize, convolved.size())
                .clear();         
        return convolved;
    }
}
package com.thealgorithms.maths;


public class Average {

    private static final double SMALL_VALUE = 0.00001f;

    public static void main(String[] args) {
        assert Math.abs(average(new double[]{3, 6, 9, 12, 15, 18, 21}) - 12) < SMALL_VALUE;
        assert Math.abs(average(new double[]{5, 10, 15, 20, 25, 30, 35}) - 20) < SMALL_VALUE;
        assert Math.abs(average(new double[]{1, 2, 3, 4, 5, 6, 7, 8}) - 4.5) < SMALL_VALUE;
        int[] array = {2, 4, 10};
        assert average(array) == 5;
    }

    
    public static double average(double[] numbers) {
        double sum = 0;
        for (double number : numbers) {
            sum += number;
        }
        return sum / numbers.length;
    }

    
    public static int average(int[] array) {
        long sum = 0;
        for (int i = 0; i < array.length; ++i) {
            sum += array[i];
        }
        return (int) (sum / array.length);
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;

public class HarshadNumber {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a number : ");
        long a = sc.nextLong();

        checkHarshadNumber(a);
    }

    
    public static void checkHarshadNumber(long a) {

        long b = a;
        int sum = 0;

                int[] each = new int[Long.toString(a).length()];

        int c = 0;

        while (b > 0) {
            sum += b % 10;
            each[c] = (int) (b % 10);
            b /= 10;
            c++;
        }

        if (a % sum == 0) {
            System.out.println(a + " is a Harshad Number");

                        System.out.println("\nExplaination :");

            for (int i = each.length - 1; i >= 0; i--) {
                System.out.print(each[i] + " ");
                if (i != 0) {
                    System.out.print("+ ");
                }
            }

            System.out.println("= " + sum);
            System.out.println(sum + "  " + (a / sum) + " = " + a);
        } else {
            System.out.println(a + " is not a Harshad Number");
        }
    }
}
package com.thealgorithms.maths;

public class PalindromeNumber {

    public static void main(String[] args) {

        assert isPalindrome(12321);
        assert !isPalindrome(1234);
        assert isPalindrome(1);
    }

    
    public static boolean isPalindrome(int number) {
        if (number < 0) {
            throw new IllegalArgumentException(number + "");
        }
        int numberCopy = number;
        int reverseNumber = 0;
        while (numberCopy != 0) {
            int remainder = numberCopy % 10;
            reverseNumber = reverseNumber * 10 + remainder;
            numberCopy /= 10;
        }
        return number == reverseNumber;
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;
import java.util.Collections;


public class FFT {

    
    static class Complex {

        private double real, img;

        
        public Complex() {
            real = 0;
            img = 0;
        }

        
        public Complex(double r, double i) {
            real = r;
            img = i;
        }

        
        public double getReal() {
            return real;
        }

        
        public double getImaginary() {
            return img;
        }

        
        public Complex add(Complex z) {
            Complex temp = new Complex();
            temp.real = this.real + z.real;
            temp.img = this.img + z.img;
            return temp;
        }

        
        public Complex subtract(Complex z) {
            Complex temp = new Complex();
            temp.real = this.real - z.real;
            temp.img = this.img - z.img;
            return temp;
        }

        
        public Complex multiply(Complex z) {
            Complex temp = new Complex();
            temp.real = this.real * z.real - this.img * z.img;
            temp.img = this.real * z.img + this.img * z.real;
            return temp;
        }

        
        public Complex multiply(double n) {
            Complex temp = new Complex();
            temp.real = this.real * n;
            temp.img = this.img * n;
            return temp;
        }

        
        public Complex conjugate() {
            Complex temp = new Complex();
            temp.real = this.real;
            temp.img = -this.img;
            return temp;
        }

        
        public double abs() {
            return Math.hypot(this.real, this.img);
        }

        
        public Complex divide(Complex z) {
            Complex temp = new Complex();
            double d = z.abs() * z.abs();
            d = (double)Math.round(d * 1000000000d) / 1000000000d;
            temp.real = (this.real * z.real + this.img * z.img) / (d);
            temp.img = (this.img * z.real - this.real * z.img) / (d);
            return temp;
        }

        
        public Complex divide(double n) {
            Complex temp = new Complex();
            temp.real = this.real / n;
            temp.img = this.img / n;
            return temp;
        }
    }

    
    public static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {
        paddingPowerOfTwo(x);
        int N = x.size();
        int log2N = findLog2(N);
        x = fftBitReversal(N,log2N,x);
        int direction = inverse ? -1 : 1;

        for (int len = 2; len <= N; len *= 2) {
            double angle = -2 * Math.PI / len * direction;
            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));
            for (int i = 0; i < N; i += len) {
                Complex w = new Complex(1, 0);
                for (int j = 0; j < len / 2; j++) {
                    Complex u = x.get(i + j);
                    Complex v = w.multiply(x.get(i + j + len / 2));
                    x.set(i + j, u.add(v));
                    x.set(i + j + len / 2, u.subtract(v));
                    w = w.multiply(wlen);
                }
            }
        }
        x = inverseFFT(N,inverse,x);
        return x;
    }

    public static int findLog2(int N){
        int log2N = 0;
        while ((1 << log2N) < N) {
            log2N++;
        }
        return log2N;
    }

    public static ArrayList<Complex> fftBitReversal(int N, int log2N, ArrayList<Complex> x){
        int reverse;
        for (int i = 0; i < N; i++) {
            reverse = reverseBits(i, log2N);
            if (i < reverse) {
                Collections.swap(x, i, reverse);
            }
        }
        return x;
    }

    public static ArrayList<Complex> inverseFFT(int N, boolean inverse, ArrayList<Complex> x ){
        if (inverse) {
            for (int i = 0; i < x.size(); i++) {
                Complex z = x.get(i);
                x.set(i, z.divide(N));
            }
        }
        return x;
    }

    
    private static int reverseBits(int num, int log2N) {
        int reversed = 0;
        for (int i = 0; i < log2N; i++) {
            if ((num & (1 << i)) != 0) {
                reversed |= 1 << (log2N - 1 - i);
            }
        }
        return reversed;
    }

    
    private static void paddingPowerOfTwo(ArrayList<Complex> x) {
        int n = 1;
        int oldSize = x.size();
        while (n < oldSize) {
            n *= 2;
        }
        for (int i = 0; i < n - oldSize; i++) {
            x.add(new Complex());
        }
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;
import java.util.Collections;


public class VampireNumber {

    public static void main(String[] args) {

        test(10, 1000);
    }

    static void test(int startValue, int stopValue) {
        int countofRes = 1;
        StringBuilder res = new StringBuilder();

        for (int i = startValue; i <= stopValue; i++) {
            for (int j = i; j <= stopValue; j++) {
                                if (isVampireNumber(i, j, true)) {
                    countofRes++;
                    res.append("" + countofRes + ": = ( " + i + "," + j + " = " + i * j + ")" + "\n");
                }
            }
        }
        System.out.println(res);
    }

    static boolean isVampireNumber(int a, int b, boolean noPseudoVamireNumbers) {

                                if (noPseudoVamireNumbers) {
            if (a * 10 <= b || b * 10 <= a) {
                return false;
            }
        }

        String mulDigits = splitIntoDigits(a * b, 0);
        String faktorDigits = splitIntoDigits(a, b);

        return mulDigits.equals(faktorDigits);
    }

        static String splitIntoDigits(int num, int num2) {

        StringBuilder res = new StringBuilder();

        ArrayList<Integer> digits = new ArrayList<>();
        while (num > 0) {
            digits.add(num % 10);
            num /= 10;
        }
        while (num2 > 0) {
            digits.add(num2 % 10);
            num2 /= 10;
        }
        Collections.sort(digits);
        for (int i : digits) {
            res.append(i);
        }

        return res.toString();
    }
}

package com.thealgorithms.maths;

import java.io.*;

public class DudeneyNumber {

        public static boolean isDudeney(int n) {
                int cube_root = (int) (Math.round((Math.pow(n, 1.0 / 3.0))));
                if (cube_root * cube_root * cube_root != n) {
            return false;
        }
        int sum_of_digits = 0;        int temp = n;                while (temp > 0) {

                        int rem = temp % 10;

                        sum_of_digits += rem;

                        temp /= 10;
        }

                if (cube_root != sum_of_digits) {
            return false;
        }

        return true;
    }

    
    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter a Number: ");
        int n = Integer.parseInt(br.readLine());
        if (isDudeney(n)) {
            System.out.println("It is a Dudeney Number.");
        } else {
            System.out.println("It is not a Dudeney Number.");
        }
    }
}



package com.thealgorithms.maths;

import java.util.*;

class DigitalRoot {

    public static int digitalRoot(int n) {
        if (single(n) <= 9)         {
            return single(n);
        } else {
            return digitalRoot(single(n));
        }
    }

        public static int single(int n) {
        if (n <= 9)         {
            return n;
        } else {
            return (n % 10) + single(n / 10);                             }
    }                                                                 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the number : ");
        int n = sc.nextInt();                                             System.out.println("Digital Root : " + digitalRoot(n));         }
}


package com.thealgorithms.maths;



public class HeronsFormula {
	
	public static double Herons(int s1, int s2, int s3)
	{
		double a = s1;
		double b = s2;
		double c = s3;
		double s = (a + b + c)/2.0;
		double area = 0;
		area = Math.sqrt((s)*(s-a)*(s-b)*(s-c));
		return area;
	}
}
package com.thealgorithms.maths;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;

public class Mode {

    public static void main(String[] args) {

        assert (mode(new int[]{})) == null;
        assert Arrays.equals(mode(new int[]{5}), new int[]{5});
        assert Arrays.equals(mode(new int[]{1, 2, 3, 4, 5}), new int[]{1, 2, 3, 4, 5});
        assert Arrays.equals(mode(new int[]{7, 9, 9, 4, 5, 6, 7, 7, 8}), new int[]{7});
        assert Arrays.equals(mode(new int[]{7, 9, 9, 4, 5, 6, 7, 7, 9}), new int[]{7, 9});
    }
    public static int[] mode(int[] numbers) {

        if (numbers.length == 0) {
            return null;
        }

        HashMap<Integer, Integer> count = new HashMap<>();

        for (int num : numbers) {
            if (count.containsKey(num)) {

                count.put(num, count.get(num) + 1);

            } else {

                count.put(num, 1);
            }
        }

        int max = Collections.max(count.values());
        ArrayList<Integer> modes = new ArrayList<>();

        for (int num : count.keySet()) {
            if (count.get(num) == max) {
                modes.add(num);
            }
        }
        return modes.stream().mapToInt(n -> n).toArray();
    }
}
package com.thealgorithms.maths;

public class BinomialCoefficient {
	
	
	
	static int binomialCoefficient(int total_objects, int no_of_objects) {
		
				if(no_of_objects > total_objects) {
			return 0;
		}
		
				if(no_of_objects == 0 || no_of_objects == total_objects) {
			return 1;
		}
		
				return binomialCoefficient(total_objects - 1, no_of_objects - 1)
				+ binomialCoefficient(total_objects - 1, no_of_objects);
	}
	
	public static void main(String[] args) {
		System.out.println(binomialCoefficient(20,2));
		
			}

}
package com.thealgorithms.maths;


public class Convolution {

    
    public static double[] convolution(double[] A, double[] B) {
        double[] convolved = new double[A.length + B.length - 1];

        for (int i = 0; i < convolved.length; i++) {
            convolved[i] = 0;
            int k = Math.max(i - B.length + 1, 0);

            while (k < i + 1 && k < A.length) {
                convolved[i] += A[k] * B[i - k];
                k++;
            }
        }

        return convolved;
    }
}
package com.thealgorithms.maths;

public class StandardDeviation {
	
  public static double stdDev(double[] data)
	{
		double var = 0;
		double avg = 0;
		for (int i = 0; i < data.length; i++)
		{
			avg += data[i];
		}
		avg /= data.length;
		for (int j = 0; j < data.length; j++)
		{
			var += Math.pow((data[j] - avg), 2);
		}
		var /= data.length;
		return Math.sqrt(var);
	}
  
}
package com.thealgorithms.maths;


public class Combinations {

    public static void main(String[] args) {
        assert combinations(1, 1) == 1;
        assert combinations(10, 5) == 252;
        assert combinations(6, 3) == 20;
        assert combinations(20, 5) == 15504;

                                assert combinationsOptimized(100, 0) == 1;
        assert combinationsOptimized(1, 1) == 1;
        assert combinationsOptimized(10, 5) == 252;
        assert combinationsOptimized(6, 3) == 20;
        assert combinationsOptimized(20, 5) == 15504;
        assert combinationsOptimized(200, 5) == 2535650040l;
    }

    
    public static long factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("number is negative");
        }
        return n == 0 || n == 1 ? 1 : n * factorial(n - 1);
    }

    
    public static long combinations(int n, int k) {
        return factorial(n) / (factorial(k) * factorial(n - k));
    }

    
    public static long combinationsOptimized(int n, int k) {
        if (n < 0 || k < 0) {
            throw new IllegalArgumentException("n or k can't be negative");
        }
        if (n < k) {
            throw new IllegalArgumentException("n can't be smaller than k");
        }
                long solution = 1;
        for (int i = 0; i < k; i++) {
            long next = (n - i) * solution / (i + 1);
            solution = next;
        }
        return solution;
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;
import java.util.Random;


public class FindKthNumber {
    private static final Random random = new Random();

    public static void main(String[] args) {
        int[] nums = generateArray(100);

        int kth = 3;
        int kthMaxIndex = nums.length - kth;
        int targetMax = findKthMax(nums, kthMaxIndex);

        int kthMinIndex = kth - 1;
        int targetMin = findKthMax(nums, kthMinIndex);

        Arrays.sort(nums);
        assert nums[kthMaxIndex] == targetMax;
        assert nums[kthMinIndex] == targetMin;
    }

    private static int[] generateArray(int capacity) {
        int size = random.nextInt(capacity) + 1;
        int[] array = new int[size];

        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt() % 100;
        }
        return array;
    }

    private static int findKthMax(int[] nums, int k) {
        int start = 0, end = nums.length;
        while (start < end) {
            int pivot = partition(nums, start, end);
            if (k == pivot) {
                return nums[pivot];
            } else if (k > pivot) {
                start = pivot + 1;
            } else {
                end = pivot;
            }
        }
        return -1;
    }

    private static int partition(int[] nums, int start, int end) {
        int pivot = nums[start];
        int j = start;
        for (int i = start + 1; i < end; i++) {
            if (nums[i] < pivot) {
                j++;
                swap(nums, i, j);
            }
        }
        swap(nums, start, j);
        return j;
    }

    private static void swap(int[] nums, int a, int b) {
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}
package com.thealgorithms.maths;

import java.util.*;

class KeithNumber {

        static boolean isKeith(int x) {
                ArrayList<Integer> terms = new ArrayList<Integer>();
                int temp = x, n = 0;
                while (temp > 0) {
                        terms.add(temp % 10);
                        temp = temp / 10;
                        n++;
        }
                Collections.reverse(terms);
        int next_term = 0, i = n;
                        while (next_term < x) {
            next_term = 0;
                        for (int j = 1; j <= n; j++) {
                next_term = next_term + terms.get(i - j);
            }
            terms.add(next_term);
            i++;
        }
                                return (next_term == x);
    }

        public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        if (isKeith(n)) {
            System.out.println("Yes, the given number is a Keith number.");
        } else {
            System.out.println("No, the given number is not a Keith number.");
        }
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;

public class Gaussian {

    public static ArrayList<Double> gaussian(int mat_size, ArrayList<Double> matrix) {
        ArrayList<Double> answerArray = new ArrayList<Double>();
        int i, j = 0;

        double[][] mat = new double[mat_size + 1][mat_size + 1];
        double[][] x = new double[mat_size][mat_size + 1];

                for (i = 0; i < mat_size; i++) {
            for (j = 0; j <= mat_size; j++) {
                mat[i][j] = matrix.get(i);
            }
        }

        mat = gaussianElimination(mat_size, i, mat);
        answerArray = valueOfGaussian(mat_size, x, mat);
        return answerArray;
    }

        public static double[][] gaussianElimination(int mat_size, int i, double[][] mat) {
        int step = 0;
        for (step = 0; step < mat_size - 1; step++) {
            for (i = step; i < mat_size - 1; i++) {
                double a = (mat[i + 1][step] / mat[step][step]);

                for (int j = step; j <= mat_size; j++) {
                    mat[i + 1][j] = mat[i + 1][j] - (a * mat[step][j]);
                }
            }
        }
        return mat;
    }

        public static ArrayList<Double> valueOfGaussian(int mat_size, double[][] x, double[][] mat) {
        ArrayList<Double> answerArray = new ArrayList<Double>();
        int i, j;

        for (i = 0; i < mat_size; i++) {
            for (j = 0; j <= mat_size; j++) {
                x[i][j] = mat[i][j];
            }
        }

        for (i = mat_size - 1; i >= 0; i--) {
            double sum = 0;
            for (j = mat_size - 1; j > i; j--) {
                x[i][j] = x[j][j] * x[i][j];
                sum = x[i][j] + sum;
            }
            if (x[i][i] == 0) {
                x[i][i] = 0;
            } else {
                x[i][i] = (x[i][mat_size] - sum) / (x[i][i]);
            }
            answerArray.add(x[i][j]);
        }
        return answerArray;
    }
}package com.thealgorithms.maths;

public class Pow {

    public static void main(String[] args) {
        assert pow(2, 0) == Math.pow(2, 0);         assert pow(0, 2) == Math.pow(0, 2);         assert pow(2, 10) == Math.pow(2, 10);         assert pow(10, 2) == Math.pow(10, 2);     }

    
    public static long pow(int a, int b) {
        long result = 1;
        for (int i = 1; i <= b; i++) {
            result *= a;
        }
        return result;
    }
}
package com.thealgorithms.maths;


public class PerfectSquare {

    public static void main(String[] args) {
        assert !isPerfectSquare(-1);
        assert !isPerfectSquare(3);
        assert !isPerfectSquare(5);
        assert isPerfectSquare(9);
        assert isPerfectSquare(100);
    }

    
    public static boolean isPerfectSquare(int number) {
        int sqrt = (int) Math.sqrt(number);
        return sqrt * sqrt == number;
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;


public class FFTBluestein {

    
    public static void fftBluestein(ArrayList<FFT.Complex> x, boolean inverse) {
        int N = x.size();
        int bnSize = 2 * N - 1;
        int direction = inverse ? -1 : 1;
        ArrayList<FFT.Complex> an = new ArrayList<>();
        ArrayList<FFT.Complex> bn = new ArrayList<>();

        for (int i = 0; i < bnSize; i++) {
            bn.add(new FFT.Complex());
        }

        for (int i = 0; i < N; i++) {
            double angle = (i - N + 1) * (i - N + 1) * Math.PI / N * direction;
            bn.set(i, new FFT.Complex(Math.cos(angle), Math.sin(angle)));
            bn.set(bnSize - i - 1, new FFT.Complex(Math.cos(angle), Math.sin(angle)));
        }

        for (int i = 0; i < N; i++) {
            double angle = -i * i * Math.PI / N * direction;
            an.add(x.get(i).multiply(new FFT.Complex(Math.cos(angle), Math.sin(angle))));
        }

        ArrayList<FFT.Complex> convolution = ConvolutionFFT.convolutionFFT(an, bn);

        for (int i = 0; i < N; i++) {
            double angle = -1 * i * i * Math.PI / N * direction;
            FFT.Complex bk = new FFT.Complex(Math.cos(angle), Math.sin(angle));
            x.set(i, bk.multiply(convolution.get(i + N - 1)));
        }

        if (inverse) {
            for (int i = 0; i < N; i++) {
                FFT.Complex z = x.get(i);
                x.set(i, z.divide(N));
            }
        }
    }
}
package com.thealgorithms.maths;


public class GCD {

    
    public static int gcd(int num1, int num2) {
        if (num1 < 0 || num2 < 0) {
            throw new ArithmeticException();
        }

        if (num1 == 0 || num2 == 0) {
            return Math.abs(num1 - num2);
        }

        while (num1 % num2 != 0) {
            int remainder = num1 % num2;
            num1 = num2;
            num2 = remainder;
        }
        return num2;
    }

    
    public static int gcd(int[] number) {
        int result = number[0];
        for (int i = 1; i < number.length; i++)         {
            result = gcd(result, number[i]);
        }

        return result;
    }

    public static void main(String[] args) {
        int[] myIntArray = {4, 16, 32};

                System.out.println(gcd(myIntArray));         System.out.printf("gcd(40,24)=%d gcd(24,40)=%d%n", gcd(40, 24), gcd(24, 40));     }
}
package com.thealgorithms.maths;

import java.util.Scanner;
public class PascalTriangle {
    

        public static int[][] pascal(int n)
    {
        
        int[][] arr = new int[n][n];
        
        for (int line = 0; line < n; line++)
        {
            
            for (int i = 0; i <= line; i++)
            {
                                if (line == i || i == 0)
                    arr[line][i] = 1;
                                    else
                    arr[line][i] = arr[line-1][i-1] + arr[line-1][i];
            }
        }
        
        return arr;
    }
}
package com.thealgorithms.maths;


public class PerfectCube {

    public static void main(String[] args) {
        assert !isPerfectCube(-1);
        assert isPerfectCube(0);
        assert isPerfectCube(1);
        assert !isPerfectCube(4);
        assert isPerfectCube(8);
        assert isPerfectCube(27);
    }

    
    public static boolean isPerfectCube(int number) {
        int a = (int) Math.pow(number, 1.0 / 3);
        return a * a * a == number;
    }
}
package com.thealgorithms.maths;

import java.util.Random;

public class MaxValue {

    
    public static void main(String[] args) {
        Random rand = new Random();

        for (int i = 1; i <= 100; ++i) {
            int a = rand.nextInt(100) - 50;
            int b = rand.nextInt(100) - 50;
            assert max(a, b) == Math.max(a, b);
        }
    }

    
    public static int max(int a, int b) {
        return a >= b ? a : b;
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;

public class PrimeFactorization {

    public static void main(String[] args) {
        System.out.println("## all prime factors ##");
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int n = scanner.nextInt();
        System.out.print(("printing factors of " + n + " : "));
        pfactors(n);
        scanner.close();
    }

    public static void pfactors(int n) {

        while (n % 2 == 0) {
            System.out.print(2 + " ");
            n /= 2;
        }

        for (int i = 3; i <= Math.sqrt(n); i += 2) {
            while (n % i == 0) {
                System.out.print(i + " ");
                n /= i;
            }
        }

        if (n > 2) {
            System.out.print(n);
        }
    }
}
package com.thealgorithms.maths;


public class Armstrong {

    
    public boolean isArmstrong(int number) {
        long sum = 0;
        long number2 = number;
        while (number2 > 0) {
            long mod = number2 % 10;
            sum += Math.pow(mod, 3);
            number2 /= 10;
        }
        return sum == number;
    }
}package com.thealgorithms.maths;


public class TrinomialTriangle {

    public static int TrinomialValue(int n, int k) {
        if (n == 0 && k == 0) {
            return 1;
        }

        if (k < -n || k > n) {
            return 0;
        }

        return TrinomialValue(n - 1, k - 1) + TrinomialValue(n - 1, k) + TrinomialValue(n - 1, k + 1);
    }

    public static void printTrinomial(int n) {
        for (int i = 0; i < n; i++) {
            for (int j = -i; j <= 0; j++) {
                System.out.print(TrinomialValue(i, j) + " ");
            }

            for (int j = 1; j <= i; j++) {
                System.out.print(TrinomialValue(i, j) + " ");
            }

            System.out.println();
        }
    }

    public static void main(String argc[]) {
        int n = 6;
        printTrinomial(n);
    }
}
package com.thealgorithms.maths;


public class AmicableNumber {

    public static void main(String[] args) {

        AmicableNumber.findAllInRange(1, 3000);

    }

    
    static void findAllInRange(int startValue, int stopValue) {

        StringBuilder res = new StringBuilder();
        int countofRes = 0;

        for (int i = startValue; i < stopValue; i++) {
            for (int j = i + 1; j <= stopValue; j++) {
                if (isAmicableNumber(i, j)) {
                    countofRes++;
                    res.append("" + countofRes + ": = ( " + i + "," + j + ")" + "\t");
                }
            }
        }
        res.insert(
                0,
                "Int Range of "
                + startValue
                + " till "
                + stopValue
                + " there are "
                + countofRes
                + " Amicable_numbers.These are \n ");
        System.out.println(res.toString());
    }

    
    static boolean isAmicableNumber(int numberOne, int numberTwo) {

        return ((recursiveCalcOfDividerSum(numberOne, numberOne) == numberTwo
                && numberOne == recursiveCalcOfDividerSum(numberTwo, numberTwo)));
    }

    
    static int recursiveCalcOfDividerSum(int number, int div) {

        if (div == 1) {
            return 0;
        } else if (number % --div == 0) {
            return recursiveCalcOfDividerSum(number, div) + div;
        } else {
            return recursiveCalcOfDividerSum(number, div);
        }
    }
}
package com.thealgorithms.maths;

import java.math.BigDecimal;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;


public class FibonacciJavaStreams {

    public static Optional<BigDecimal> calculate(final BigDecimal index) {
        if (index == null || index.compareTo(BigDecimal.ZERO) < 0) {
            return Optional.empty();
        }

        if (index.compareTo(BigDecimal.ONE) < 0) {
            return Optional.of(BigDecimal.ZERO);
        }

        if (index.compareTo(new BigDecimal(2)) < 0) {
            return Optional.of(BigDecimal.ONE);
        }

        final List<BigDecimal> results = Stream.iterate(
                index,
                x -> x.compareTo(BigDecimal.ZERO) > 0,
                x -> x.subtract(BigDecimal.ONE)
        )
                .reduce(
                        List.of(),
                        (list, current)
                        -> list.isEmpty() || list.size() < 2
                        ? List.of(BigDecimal.ZERO, BigDecimal.ONE)
                        : List.of(list.get(1), list.get(0).add(list.get(1))),
                        (list1, list2) -> list1
                );

        return results.isEmpty()
                ? Optional.empty()
                : Optional.of(results.get(results.size() - 1));
    }

    public static void assertThat(final Object actual, final Object expected) {
        if (!Objects.equals(actual, expected)) {
            throw new AssertionError(String.format("expected=%s but was actual=%s", expected, actual));
        }
    }

    public static void main(final String[] args) {
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(-1));
            assertThat(result.isEmpty(), true);
        }
        {
            final Optional<BigDecimal> result = calculate(BigDecimal.ZERO);
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, BigDecimal.ZERO));
        }
        {
            final Optional<BigDecimal> result = calculate(BigDecimal.ONE);
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, BigDecimal.ONE));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(2));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, BigDecimal.ONE));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(3));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(2)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(10));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(55)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(20));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(6765)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(30));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(832040)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(40));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(102334155)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(50));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal(12586269025L)));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(100));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal("354224848179261915075")));
        }
        {
            final Optional<BigDecimal> result = calculate(new BigDecimal(200));
            assertThat(result.isPresent(), true);
            result.ifPresent(value -> assertThat(value, new BigDecimal("280571172992510140037611932413038677189525")));
        }
    }
}
package com.thealgorithms.maths;

import java.util.*;

class NthUglyNumber {

    public long getNthUglyNo(int n) {
        long[] ugly = new long[n];
        int two = 0, three = 0, five = 0;
        long nm2 = 2, nm3 = 3, nm5 = 5;
        long next = 1;

        ugly[0] = 1;

        for (int i = 1; i < n; i++) {
            next = Math.min(nm2, Math.min(nm3, nm5));

            ugly[i] = next;
            if (next == nm2) {
                two = two + 1;
                nm2 = ugly[two] * 2;
            }
            if (next == nm3) {
                three = three + 1;
                nm3 = ugly[three] * 3;
            }
            if (next == nm5) {
                five = five + 1;
                nm5 = ugly[five] * 5;
            }
        }
        return next;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the value of n : ");
        int n = sc.nextInt();
        NthUglyNumber ob = new NthUglyNumber();
        long ugly = ob.getNthUglyNo(n);
        System.out.println("nth Ugly number is : " + ugly);
    }
}
package com.thealgorithms.maths;


public class GCDRecursion {

    public static void main(String[] args) {
        System.out.println(gcd(20, 15));
        System.out.println(gcd(10, 8));
        System.out.println(gcd(gcd(10, 5), gcd(5, 10)));
    }

    
    public static int gcd(int a, int b) {

        if (a < 0 || b < 0) {
            throw new ArithmeticException();
        }

        if (a == 0 || b == 0) {
            return Math.abs(a - b);
        }

        if (a % b == 0) {
            return b;
        } else {
            return gcd(b, a % b);
        }
    }
}
package com.thealgorithms.maths;

public record ADTFraction(int numerator, int denominator) {

    
    public ADTFraction {
        if (denominator == 0) {
            throw new IllegalArgumentException("Denominator cannot be 0");
        }
    }

    
    public ADTFraction plus(ADTFraction fraction) {
        var numerator = this.denominator * fraction.numerator + this.numerator * fraction.denominator;
        var denominator = this.denominator * fraction.denominator;
        return new ADTFraction(numerator, denominator);

    }

    
    public ADTFraction times(int number) {
        return times(new ADTFraction(number, 1));
    }

    
    public ADTFraction times(ADTFraction fraction) {
        var numerator = this.numerator * fraction.numerator;
        var denominator = this.denominator * fraction.denominator;
        return new ADTFraction(numerator, denominator);
    }

    
    public ADTFraction reciprocal() {
        return new ADTFraction(this.denominator, this.numerator);
    }

    
    public float value() {
        return (float) this.numerator / this.denominator;
    }

    
    @Override
    public String toString() {
        return String.format("%d/%d", this.numerator, this.denominator);
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;


public class CircularConvolutionFFT {

    
    private static void padding(ArrayList<FFT.Complex> x, int newSize) {
        if (x.size() < newSize) {
            int diff = newSize - x.size();
            for (int i = 0; i < diff; i++) {
                x.add(new FFT.Complex());
            }
        }
    }

    
    public static ArrayList<FFT.Complex> fftCircularConvolution(
            ArrayList<FFT.Complex> a, ArrayList<FFT.Complex> b) {
        int convolvedSize
                = Math.max(
                        a.size(), b.size());         padding(a, convolvedSize);         padding(b, convolvedSize);

        FFTBluestein.fftBluestein(a, false);
        FFTBluestein.fftBluestein(b, false);
        ArrayList<FFT.Complex> convolved = new ArrayList<>();

        for (int i = 0; i < a.size(); i++) {
            convolved.add(a.get(i).multiply(b.get(i)));         }
        FFTBluestein.fftBluestein(convolved, true); 
        return convolved;
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;
import java.util.NoSuchElementException;
import java.lang.IllegalStateException;

public class ReverseNumber {

    public static void main(String[] args) {
        int number;
        int reverse = 0;

        try (Scanner sc = new Scanner(System.in)) {
            System.out.println("Enter a number:");
            number = sc.nextInt();
        } catch (NoSuchElementException | IllegalStateException e) {
            System.out.println("ERROR: Invalid input");
            return;
        }

        while (number != 0) {
            int remainder = number % 10;

            reverse = reverse * 10 + remainder;
            number = number / 10;
        }

        System.out.println("The reverse of the given number is: " + reverse);
    }
}
package com.thealgorithms.maths;

public class DistanceFormula {
	public static double distance(double x1, double y1, double x2, double y2)
	{
		double dX = Math.pow(x2-x1, 2);
		double dY = Math.pow(y2-x1, 2);
		double d = Math.sqrt(dX+dY);
		return d;
	}
}
package com.thealgorithms.maths;

import java.util.Random;

public class Ceil {

    public static void main(String[] args) {
        Random random = new Random();
        for (int i = 1; i <= 1000; ++i) {
            double randomNumber = random.nextDouble();
            assert ceil(randomNumber) == Math.ceil(randomNumber);
        }
    }

    
    public static double ceil(double number) {
        if (number - (int) number == 0) {
            return number;
        } else if (number - (int) number > 0) {
            return (int) (number + 1);
        } else {
            return (int) number;
        }
    }
}
package com.thealgorithms.maths;

public class BinaryPow {

    
    public static int binPow(int a, int p) {
        int res = 1;
        while (p > 0) {
            if ((p & 1) == 1) {
                res = res * a;
            }
            a = a * a;
            p >>>= 1;
        }
        return res;
    }

    
    public static void test(int a, int p) {
        int res = binPow(a, p);
        assert res == (int) Math.pow(a, p) : "Incorrect Implementation";
        System.out.println(a + "^" + p + ": " + res);
    }

    
    public static void main(String[] args) {
                test(2, 15);

                test(3, 9);
    }
}
package com.thealgorithms.maths;


public class FibonacciNumber {

    public static void main(String[] args) {
        assert isFibonacciNumber(1);
        assert isFibonacciNumber(2);
        assert isFibonacciNumber(21);
        assert !isFibonacciNumber(9);
        assert !isFibonacciNumber(10);
    }

    
    public static boolean isPerfectSquare(int number) {
        int sqrt = (int) Math.sqrt(number);
        return sqrt * sqrt == number;
    }

    
    public static boolean isFibonacciNumber(int number) {
        return isPerfectSquare(5 * number * number + 4) || isPerfectSquare(5 * number * number - 4);
    }
}
package com.thealgorithms.maths;

import java.util.Random;

public class MinValue {

    
    public static void main(String[] args) {
        Random rand = new Random();

        for (int i = 1; i <= 100; ++i) {
            int a = rand.nextInt(100) - 50;
            int b = rand.nextInt(100) - 50;
            assert min(a, b) == Math.min(a, b);
        }
    }

    
    public static int min(int a, int b) {
        return a <= b ? a : b;
    }
}
package com.thealgorithms.maths;

public class AbsoluteValue {

    
    public static int getAbsValue(int number) {
        return number < 0 ? -number : number;
    }
}
package com.thealgorithms.maths;

import java.math.BigDecimal;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.stream.IntStream;


public class MatrixUtil {

    public static boolean isValid(final BigDecimal[][] matrix) {
        return matrix != null && matrix.length > 0 && matrix[0].length > 0;
    }

    public static boolean hasEqualSizes(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {
        return isValid(matrix1) && isValid(matrix2)
                && matrix1.length == matrix2.length
                && matrix1[0].length == matrix2[0].length;
    }

    public static boolean canMultiply(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {
        return isValid(matrix1) && isValid(matrix2)
                && matrix1[0].length == matrix2.length;
    }

    public static Optional<BigDecimal[][]> operate(final BigDecimal[][] matrix1,
            final BigDecimal[][] matrix2,
            final BiFunction<BigDecimal, BigDecimal, BigDecimal> operation) {
        if (!hasEqualSizes(matrix1, matrix2)) {
            return Optional.empty();
        }

        final int rowSize = matrix1.length;
        final int columnSize = matrix1[0].length;

        final BigDecimal[][] result = new BigDecimal[rowSize][columnSize];

        IntStream.range(0, rowSize).forEach(rowIndex
                -> IntStream.range(0, columnSize).forEach(columnIndex -> {
                    final BigDecimal value1 = matrix1[rowIndex][columnIndex];
                    final BigDecimal value2 = matrix2[rowIndex][columnIndex];

                    result[rowIndex][columnIndex] = operation.apply(value1, value2);
                }));

        return Optional.of(result);
    }

    public static Optional<BigDecimal[][]> add(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {
        return operate(matrix1, matrix2, BigDecimal::add);
    }

    public static Optional<BigDecimal[][]> subtract(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {
        return operate(matrix1, matrix2, BigDecimal::subtract);
    }

    public static Optional<BigDecimal[][]> multiply(final BigDecimal[][] matrix1, final BigDecimal[][] matrix2) {
        if (!canMultiply(matrix1, matrix2)) {
            return Optional.empty();
        }

        final int size = matrix1[0].length;

        final int matrix1RowSize = matrix1.length;
        final int matrix2ColumnSize = matrix2[0].length;

        final BigDecimal[][] result = new BigDecimal[matrix1RowSize][matrix2ColumnSize];

        IntStream.range(0, matrix1RowSize).forEach(rowIndex
                -> IntStream.range(0, matrix2ColumnSize).forEach(columnIndex
                        -> result[rowIndex][columnIndex] = IntStream.range(0, size).mapToObj(index -> {
                    final BigDecimal value1 = matrix1[rowIndex][index];
                    final BigDecimal value2 = matrix2[index][columnIndex];

                    return value1.multiply(value2);
                })
                        .reduce(BigDecimal.ZERO, BigDecimal::add)
                )
        );

        return Optional.of(result);
    }

    public static void assertThat(final BigDecimal[][] actual, final BigDecimal[][] expected) {
        if (!Objects.deepEquals(actual, expected)) {
            throw new AssertionError(String.format(
                    "expected=%s but was actual=%s",
                    Arrays.deepToString(expected),
                    Arrays.deepToString(actual)
            ));
        }
    }

    public static void main(final String[] args) {
        {
            final BigDecimal[][] matrix1 = {
                {new BigDecimal(3), new BigDecimal(2)},
                {new BigDecimal(0), new BigDecimal(1)},};

            final BigDecimal[][] matrix2 = {
                {new BigDecimal(1), new BigDecimal(3)},
                {new BigDecimal(2), new BigDecimal(0)},};

            final BigDecimal[][] actual = add(matrix1, matrix2)
                    .orElseThrow(() -> new AssertionError("Could not compute matrix!"));

            final BigDecimal[][] expected = {
                {new BigDecimal(4), new BigDecimal(5)},
                {new BigDecimal(2), new BigDecimal(1)}
            };

            assertThat(actual, expected);
        }

        {
            final BigDecimal[][] matrix1 = {
                {new BigDecimal(1), new BigDecimal(4)},
                {new BigDecimal(5), new BigDecimal(6)},};

            final BigDecimal[][] matrix2 = {
                {new BigDecimal(2), new BigDecimal(0)},
                {new BigDecimal(-2), new BigDecimal(-3)},};

            final BigDecimal[][] actual = subtract(matrix1, matrix2)
                    .orElseThrow(() -> new AssertionError("Could not compute matrix!"));

            final BigDecimal[][] expected = {
                {new BigDecimal(-1), new BigDecimal(4)},
                {new BigDecimal(7), new BigDecimal(9)}
            };

            assertThat(actual, expected);
        }

        {
            final BigDecimal[][] matrix1 = {
                {new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)},
                {new BigDecimal(4), new BigDecimal(5), new BigDecimal(6)},
                {new BigDecimal(7), new BigDecimal(8), new BigDecimal(9)}
            };

            final BigDecimal[][] matrix2 = {
                {new BigDecimal(1), new BigDecimal(2)},
                {new BigDecimal(3), new BigDecimal(4)},
                {new BigDecimal(5), new BigDecimal(6)}
            };

            final BigDecimal[][] actual = multiply(matrix1, matrix2)
                    .orElseThrow(() -> new AssertionError("Could not compute matrix!"));

            final BigDecimal[][] expected = {
                {new BigDecimal(22), new BigDecimal(28)},
                {new BigDecimal(49), new BigDecimal(64)},
                {new BigDecimal(76), new BigDecimal(100)}
            };

            assertThat(actual, expected);
        }
    }
}
package com.thealgorithms.maths;


public class Area {

    public static void main(String[] args) {

        assert Double.compare(surfaceAreaCube(1), 6.0) == 0;

        assert Double.compare(surfaceAreaSphere(5), 314.1592653589793) == 0;
        assert Double.compare(surfaceAreaSphere(1), 12.566370614359172) == 0;

        assert Double.compare(surfaceAreaRectangle(10, 20), 200.0) == 0;

        assert Double.compare(surfaceAreaSquare(10), 100.0) == 0;

        assert Double.compare(surfaceAreaTriangle(10, 10), 50.0) == 0;

        assert Double.compare(surfaceAreaParallelogram(10, 20), 200.0) == 0;

        assert Double.compare(surfaceAreaTrapezium(10, 20, 30), 450.0) == 0;

        assert Double.compare(surfaceAreaCircle(20), 1256.6370614359173) == 0;

        assert Double.compare(surfaceAreaCylinder(1, 2), 18.84955592153876) == 0;

        assert Double.compare(surfaceAreaHemisphere(5), 235.61944901923448) == 0;
        assert Double.compare(surfaceAreaHemisphere(1), 9.42477796076938) == 0;

        assert Double.compare(surfaceAreaCone(6, 8), 301.59289474462014) == 0;
        assert Double.compare(surfaceAreaCone(10, 24), 1130.9733552923256) == 0;

    }

    
    private static double surfaceAreaCube(double sideLength) {
        return 6 * sideLength * sideLength;
    }

    
    private static double surfaceAreaSphere(double radius) {
        return 4 * Math.PI * radius * radius;
    }

    
    private static double surfaceAreaRectangle(double length, double width) {
        return length * width;
    }

    
    private static double surfaceAreaCylinder(double radius, double height) {
        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);
    }

    
    private static double surfaceAreaSquare(double sideLength) {
        return sideLength * sideLength;
    }

    
    private static double surfaceAreaTriangle(double base, double height) {
        return base * height / 2;
    }

    
    private static double surfaceAreaParallelogram(double base, double height) {
        return base * height;
    }

    
    private static double surfaceAreaTrapezium(double base1, double base2, double height) {
        return (base1 + base2) * height / 2;
    }

    
    private static double surfaceAreaCircle(double radius) {
        return Math.PI * radius * radius;
    }

    
    private static double surfaceAreaHemisphere(double radius) {
        return 3 * Math.PI * radius * radius;
    }

    
    private static double surfaceAreaCone(double radius, double height) {
        return Math.PI * radius * (radius + Math.pow((height * height + radius * radius), 0.5));
    }
}
package com.thealgorithms.maths;

import java.util.TreeMap;

public class SimpsonIntegration {

    public static void main(String[] args) {
        SimpsonIntegration integration = new SimpsonIntegration();

                int N = 16;
        double a = 1;
        double b = 3;

                if (N % 2 != 0) {
            System.out.println("N must be even number for Simpsons method. Aborted");
            System.exit(1);
        }

                double h = (b - a) / (double) N;
        double integralEvaluation = integration.simpsonsMethod(N, h, a);
        System.out.println("The integral is equal to: " + integralEvaluation);
    }

    public double simpsonsMethod(int N, double h, double a) {
        TreeMap<Integer, Double> data = new TreeMap<>();         double temp;
        double xi = a; 
                for (int i = 0; i <= N; i++) {
            temp = f(xi);             data.put(i, temp);
            xi += h;         }

                double integralEvaluation = 0;
        for (int i = 0; i < data.size(); i++) {
            if (i == 0 || i == data.size() - 1) {
                integralEvaluation += data.get(i);
                System.out.println("Multiply f(x" + i + ") by 1");
            } else if (i % 2 == 1) {
                integralEvaluation += (double) 4 * data.get(i);
                System.out.println("Multiply f(x" + i + ") by 4");
            } else {
                integralEvaluation += (double) 2 * data.get(i);
                System.out.println("Multiply f(x" + i + ") by 2");
            }
        }

                integralEvaluation = h / 3 * integralEvaluation;

                return integralEvaluation;
    }

            public double f(double x) {
        return Math.exp(-x) * (4 - Math.pow(x, 2));
    }

}
package com.thealgorithms.maths;

public class FactorialRecursion {

    public static void main(String[] args) {
        assert factorial(0) == 1;
        assert factorial(1) == 1;
        assert factorial(2) == 2;
        assert factorial(3) == 6;
        assert factorial(5) == 120;
    }

    
    public static long factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("number is negative");
        }
        return n == 0 || n == 1 ? 1 : n * factorial(n - 1);
    }
}
package com.thealgorithms.maths;
import java.math.BigInteger;
import java.util.*;

public class KaprekarNumbers {

		public static ArrayList<Long> kaprekarNumberInRange(long start, long end) throws Exception {
		long n = end-start;
		if (n <0) throw new Exception("Invalid range");
		ArrayList<Long> list = new ArrayList<>();

		for (long i = start; i <= end; i++) {
			if (isKaprekarNumber(i)) list.add(i);
		}

		return list;
	}

		public static boolean isKaprekarNumber(long num) {
		String number = Long.toString(num);
		BigInteger originalNumber = new BigInteger(number);
		BigInteger numberSquared = originalNumber.multiply(originalNumber);
		if(number.length() == numberSquared.toString().length()){
			return number.equals(numberSquared.toString());
		}
		else{
			BigInteger leftDigits1 = new BigInteger("0");
			BigInteger leftDigits2;
			if(numberSquared.toString().contains("0")){
				leftDigits1 = new BigInteger(
						numberSquared.toString().
								substring(0, numberSquared.toString().indexOf("0")
								)
				);
			}
			leftDigits2 = new BigInteger(
					numberSquared.toString()
							.substring(0, (numberSquared.toString().length() - number.length()))
			);
			BigInteger rightDigits = new BigInteger(numberSquared.toString().substring(numberSquared.toString().length() - number.length()));
			String x = leftDigits1.add(rightDigits).toString();
			String y = leftDigits2.add(rightDigits).toString();
			return (number.equals(x)) || (number.equals(y));
		}		
	}

}
package com.thealgorithms.maths;


public class SumOfArithmeticSeries {

    public static void main(String[] args) {

        assert Double.compare(55.0, sumOfSeries(1, 1, 10)) == 0;

        assert Double.compare(100.0, sumOfSeries(1, 2, 10)) == 0;

        assert Double.compare(460.0, sumOfSeries(1, 10, 10)) == 0;

        assert Double.compare(5.5, sumOfSeries(0.1, 0.1, 10)) == 0;

        assert Double.compare(49600.0, sumOfSeries(1, 10, 100)) == 0;
    }

    
    private static double sumOfSeries(double firstTerm, double commonDiff, int numOfTerms) {
        return numOfTerms / 2.0 * (2 * firstTerm + (numOfTerms - 1) * commonDiff);
    }
}
package com.thealgorithms.maths;

import java.util.*;

public class MagicSquare {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        System.out.print("Input a number: ");
        int num = sc.nextInt();
        if ((num % 2 == 0) || (num <= 0)) {
            System.out.print("Input number must be odd and >0");
            System.exit(0);
        }

        int[][] magic_square = new int[num][num];

        int row_num = num / 2;
        int col_num = num - 1;
        magic_square[row_num][col_num] = 1;

        for (int i = 2; i <= num * num; i++) {
            if (magic_square[(row_num - 1 + num) % num][(col_num + 1) % num] == 0) {
                row_num = (row_num - 1 + num) % num;
                col_num = (col_num + 1) % num;
            } else {
                col_num = (col_num - 1 + num) % num;
            }
            magic_square[row_num][col_num] = i;
        }

                for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                if (magic_square[i][j] < 10) {
                    System.out.print(" ");
                }
                if (magic_square[i][j] < 100) {
                    System.out.print(" ");
                }
                System.out.print(magic_square[i][j] + " ");
            }
            System.out.println();
        }

    }
}
package com.thealgorithms.maths;

public class Factorial {

    public static void main(String[] args) {
        assert factorial(0) == 1;
        assert factorial(1) == 1;
        assert factorial(5) == 120;
        assert factorial(10) == 3628800;
    }

    
    public static long factorial(int n) {
        if (n < 0) {
            throw new IllegalArgumentException("number is negative");
        }
        long factorial = 1;
        for (int i = 1; i <= n; factorial *= i, ++i)
      ;
        return factorial;
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;


public class SquareRootWithBabylonianMethod {
    
    public static float square_Root(float num)
    {
        float a = num;
        float b = 1;
        double e = 0.000001;
        while (a - b > e) {
            a = (a + b) / 2;
            b = num / a;
        }
        return a;
    }

}
package com.thealgorithms.maths;

import java.util.ArrayList;
import java.util.function.BiFunction;


public class EulerMethod {

    
    public static void main(String[] args) {
        System.out.println("example 1:");
        BiFunction<Double, Double, Double> exampleEquation1 = (x, y) -> x;
        ArrayList<double[]> points1 = eulerFull(0, 4, 0.1, 0, exampleEquation1);
        assert points1.get(points1.size() - 1)[1] == 7.800000000000003;
        points1.forEach(
                point -> System.out.println(String.format("x: %1$f; y: %2$f", point[0], point[1])));

                System.out.println("\n\nexample 2:");
        BiFunction<Double, Double, Double> exampleEquation2 = (x, y) -> y;
        ArrayList<double[]> points2 = eulerFull(0, 4, 0.1, 1, exampleEquation2);
        assert points2.get(points2.size() - 1)[1] == 45.25925556817596;
        points2.forEach(
                point -> System.out.println(String.format("x: %1$f; y: %2$f", point[0], point[1])));

                System.out.println("\n\nexample 3:");
        BiFunction<Double, Double, Double> exampleEquation3 = (x, y) -> x + y + x * y;
        ArrayList<double[]> points3 = eulerFull(0, 0.1, 0.025, 1, exampleEquation3);
        assert points3.get(points3.size() - 1)[1] == 1.1116729841674804;
        points3.forEach(
                point -> System.out.println(String.format("x: %1$f; y: %2$f", point[0], point[1])));
    }

    
    public static double eulerStep(
            double xCurrent,
            double stepSize,
            double yCurrent,
            BiFunction<Double, Double, Double> differentialEquation) {
        if (stepSize <= 0) {
            throw new IllegalArgumentException("stepSize should be greater than zero");
        }
        double yNext = yCurrent + stepSize * differentialEquation.apply(xCurrent, yCurrent);
        return yNext;
    }

    
    public static ArrayList<double[]> eulerFull(
            double xStart,
            double xEnd,
            double stepSize,
            double yStart,
            BiFunction<Double, Double, Double> differentialEquation) {
        if (xStart >= xEnd) {
            throw new IllegalArgumentException("xEnd should be greater than xStart");
        }
        if (stepSize <= 0) {
            throw new IllegalArgumentException("stepSize should be greater than zero");
        }

        ArrayList<double[]> points = new ArrayList<double[]>();
        double[] firstPoint = {xStart, yStart};
        points.add(firstPoint);
        double yCurrent = yStart;
        double xCurrent = xStart;

        while (xCurrent < xEnd) {
                        yCurrent = eulerStep(xCurrent, stepSize, yCurrent, differentialEquation);
            xCurrent += stepSize;
            double[] point = {xCurrent, yCurrent};
            points.add(point);
        }

        return points;
    }
}
package com.thealgorithms.maths;


public class VectorCrossProduct {

    int x;
    int y;
    int z;

        VectorCrossProduct() {
        x = 0;
        y = 0;
        z = 0;
    }

    
    VectorCrossProduct(int _x, int _y, int _z) {
        x = _x;
        y = _y;
        z = _z;
    }

    
    double magnitude() {
        return Math.sqrt(x * x + y * y + z * z);
    }

    
    int dotProduct(VectorCrossProduct b) {
        return x * b.x + y * b.y + z * b.z;
    }

    
    VectorCrossProduct crossProduct(VectorCrossProduct b) {
        VectorCrossProduct product = new VectorCrossProduct();
        product.x = (y * b.z) - (z * b.y);
        product.y = -((x * b.z) - (z * b.x));
        product.z = (x * b.y) - (y * b.x);
        return product;
    }

    
    void displayVector() {
        System.out.println("x : " + x + "\ty : " + y + "\tz : " + z);
    }

    public static void main(String[] args) {
        test();
    }

    static void test() {
                VectorCrossProduct A = new VectorCrossProduct(1, -2, 3);
        VectorCrossProduct B = new VectorCrossProduct(2, 0, 3);

                VectorCrossProduct crossProd = A.crossProduct(B);
        crossProd.displayVector();

                int dotProd = A.dotProduct(B);
        System.out.println("Dot Product of A and B: " + dotProd);

    }

}
package com.thealgorithms.maths;

import java.util.Arrays;
import java.util.Random;

public class FindMinRecursion {

    
    public static void main(String[] args) {
        Random rand = new Random();

        int size = rand.nextInt(100) + 1;
        int[] array = new int[size];

        for (int i = 0; i < size; i++) {
            array[i] = rand.nextInt() % 100;
        }

        assert min(array, 0, array.length - 1) == Arrays.stream(array).min().getAsInt();
        assert min(array, array.length) == Arrays.stream(array).min().getAsInt();
    }

    
    public static int min(int[] array, int low, int high) {
        if (low == high) {
            return array[low];         }

        int mid = (low + high) >>> 1;

        int leftMin = min(array, low, mid);         int rightMin = min(array, mid + 1, high); 
        return Math.min(leftMin, rightMin);
    }

    
    public static int min(int[] array, int len) {
        return len == 1 ? array[0] : Math.min(min(array, len - 1), array[len - 1]);
    }
}
package com.thealgorithms.maths;


import java.io.*;

public class AutomorphicNumber {

        public static boolean isAutomorphic(int n) {
        int m, c, r, p, k;
        c = 0;
        
        double s;
        m = n;
        p = m * m;         do {
            k = n / 10;
            c = c + 1;             n = k;
        } while (n != 0);
        s = Math.pow(10, c);
        r = p % (int) s;
        if (m == r)         {
            return true;
        } else {
            return false;
        }
    }

    
    public static void main(String args[]) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter a Number: ");
        int n = Integer.parseInt(br.readLine());
        if (isAutomorphic(n)) {
            System.out.println("It is an Automorphic Number.");
        } else {
            System.out.println("It is not an Automorphic Number.");
        }
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;
import java.util.Random;

public class FindMax {

    
    public static void main(String[] args) {
        Random random = new Random();

        int size = random.nextInt(100) + 1;
        int[] array = new int[size];

        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt() % 100;
        }

        assert Arrays.stream(array).max().getAsInt() == findMax(array);
    }

    
    public static int findMax(int[] array) {
        int max = array[0];
        for (int i = 1; i < array.length; ++i) {
            if (array[i] > max) {
                max = array[i];
            }
        }
        return max;
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;

public class AbsoluteMax {

    
    public static int getMaxValue(int... numbers) {
        if (numbers.length == 0) {
            throw new IllegalArgumentException("Numbers array cannot be empty");
        }

        var absMaxWrapper = new Object() {
            int value = numbers[0];
        };

        Arrays.stream(numbers)
                .skip(1)
                .filter(number -> Math.abs(number) > Math.abs(absMaxWrapper.value))
                .forEach(number -> absMaxWrapper.value = number);

        return absMaxWrapper.value;
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;

public class PrimeCheck {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter a number: ");
        int n = scanner.nextInt();
        if (isPrime(n)) {
            System.out.println("algo1 verify that " + n + " is a prime number");
        } else {
            System.out.println("algo1 verify that " + n + " is not a prime number");
        }

        if (fermatPrimeChecking(n, 20)) {
            System.out.println("algo2 verify that " + n + " is a prime number");
        } else {
            System.out.println("algo2 verify that " + n + " is not a prime number");
        }
        scanner.close();
    }

    
    public static boolean isPrime(int n) {
        if (n == 2) {
            return true;
        }
        if (n < 2 || n % 2 == 0) {
            return false;
        }
        for (int i = 3, limit = (int) Math.sqrt(n); i <= limit; i += 2) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }

    
    public static boolean fermatPrimeChecking(int n, int iteration){
      long a;
      int up = n - 2, down = 2;
      for(int i=0;i<iteration;i++){
        a = (long)Math.floor(Math.random()*(up - down + 1) + down);
        if(modPow(a,n-1,n) != 1){
          return false;
        }
      }
      return true;
    }


    
    private static long modPow(long a, long b, long c){
        long res = 1;
        for (int i = 0; i < b; i++)
        {
            res *= a;
            res %= c;
        }
        return res % c;
    }
}
package com.thealgorithms.maths;


public class RomanNumeralUtil {

    private static final int MIN_VALUE = 1;
    private static final int MAX_VALUE = 5999;
        private static final String[] RN_M = {"", "M", "MM", "MMM", "MMMM", "MMMMM"};
        private static final String[] RN_C = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
        private static final String[] RN_X = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
        private static final String[] RN_I = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};

    public static String generate(int number) {
        if (number < MIN_VALUE || number > MAX_VALUE) {
            throw new IllegalArgumentException(
                    String.format(
                            "The number must be in the range [%d, %d]",
                            MIN_VALUE,
                            MAX_VALUE
                    )
            );
        }

        return RN_M[number / 1000]
                + RN_C[number % 1000 / 100]
                + RN_X[number % 100 / 10]
                + RN_I[number % 10];
    }
}
package com.thealgorithms.maths;

public class GenericRoot {

    public static void main(String[] args) {
        int number1 = 1234;
        int number2 = 12345;
        int result1 = genericRoot(number1);
        int result2 = genericRoot(number2);
        System.out.println("Generic root of " + number1 + " is: " + result1);
        System.out.println("Generic root of " + number2 + " is: " + result2);
    }

    private static int genericRoot(int n) {
        int root = 0;
        while (n > 0 || root > 9) {
            if (n == 0) {
                n = root;
                root = 0;
            }
            root += n % 10;
            n /= 10;
        }
        return root;
    }
}
package com.thealgorithms.maths;

import java.util.Random;

public class Floor {

    public static void main(String[] args) {
        Random random = new Random();
        for (int i = 1; i <= 1000; ++i) {
            double randomNumber = random.nextDouble();
            assert floor(randomNumber) == Math.floor(randomNumber);
        }
    }

    
    public static double floor(double number) {
        if (number - (int) number == 0) {
            return number;
        } else if (number - (int) number > 0) {
            return (int) number;
        } else {
            return (int) number - 1;
        }
    }
}
package com.thealgorithms.maths;

import java.util.Objects;

public final class LinearDiophantineEquationsSolver {

    public static void main(String[] args) {
                final var toSolve = new Equation(3, 4, 7);
        System.out.println(findAnySolution(toSolve));
    }

    public static Solution findAnySolution(final Equation equation) {
        if (equation.a() == 0 && equation.b() == 0 && equation.c() == 0) {
            return Solution.INFINITE_SOLUTIONS;
        }
        final var stub = new GcdSolutionWrapper(0, new Solution(0, 0));
        final var gcdSolution = gcd(equation.a(), equation.b(), stub);
        if (equation.c() % gcdSolution.getGcd() != 0) {
            return Solution.NO_SOLUTION;
        }
        final var toReturn = new Solution(0, 0);
        var xToSet = stub.getSolution().getX() * (equation.c() / stub.getGcd());
        var yToSet = stub.getSolution().getY() * (equation.c() / stub.getGcd());
        toReturn.setX(xToSet);
        toReturn.setY(yToSet);
        return toReturn;
    }

    private static GcdSolutionWrapper gcd(final int a, final int b, final GcdSolutionWrapper previous) {
        if (b == 0) {
            return new GcdSolutionWrapper(a, new Solution(1, 0));
        }
                final var stubWrapper = new GcdSolutionWrapper(0, new Solution(0, 0));
        final var next = gcd(b, a % b, stubWrapper);
        previous.getSolution().setX(next.getSolution().getY());
        previous.getSolution().setY(next.getSolution().getX() - (a / b) * (next.getSolution().getY()));
        previous.setGcd(next.getGcd());
        return new GcdSolutionWrapper(next.getGcd(), previous.getSolution());
    }

    public static final class Solution {

        public static final Solution NO_SOLUTION = new Solution(Integer.MAX_VALUE, Integer.MAX_VALUE);
        public static final Solution INFINITE_SOLUTIONS = new Solution(Integer.MIN_VALUE, Integer.MIN_VALUE);
        private int x;
        private int y;

        public Solution(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public int getX() {
            return x;
        }

        public int getY() {
            return y;
        }

        public void setX(int x) {
            this.x = x;
        }

        public void setY(int y) {
            this.y = y;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (obj == null || obj.getClass() != this.getClass()) {
                return false;
            }
            var that = (Solution) obj;
            return this.x == that.x
                    && this.y == that.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }

        @Override
        public String toString() {
            return "Solution["
                    + "x=" + x + ", "
                    + "y=" + y + ']';
        }

    }

    public record Equation(int a, int b, int c) {

    }

    public static final class GcdSolutionWrapper {

        private int gcd;
        private Solution solution;

        public GcdSolutionWrapper(int gcd, Solution solution) {
            this.gcd = gcd;
            this.solution = solution;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            if (obj == null || obj.getClass() != this.getClass()) {
                return false;
            }
            var that = (GcdSolutionWrapper) obj;
            return this.gcd == that.gcd
                    && Objects.equals(this.solution, that.solution);
        }

        public int getGcd() {
            return gcd;
        }

        public void setGcd(int gcd) {
            this.gcd = gcd;
        }

        public Solution getSolution() {
            return solution;
        }

        public void setSolution(Solution solution) {
            this.solution = solution;
        }

        @Override
        public int hashCode() {
            return Objects.hash(gcd, solution);
        }

        @Override
        public String toString() {
            return "GcdSolutionWrapper["
                    + "gcd=" + gcd + ", "
                    + "solution=" + solution + ']';
        }

    }
}
package com.thealgorithms.maths;

import java.util.Arrays;

public class AbsoluteMin {

    
    public static int getMinValue(int... numbers) {
        if (numbers.length == 0) {
            throw new IllegalArgumentException("Numbers array cannot be empty");
        }

        var absMinWrapper = new Object() {
            int value = numbers[0];
        };

        Arrays.stream(numbers)
                .skip(1)
                .filter(number -> Math.abs(number) < Math.abs(absMinWrapper.value))
                .forEach(number -> absMinWrapper.value = number);

        return absMinWrapper.value;
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;


public class Median {

    public static void main(String[] args) {
        assert median(new int[]{0}) == 0;
        assert median(new int[]{1, 2}) == 1.5;
        assert median(new int[]{4, 1, 3, 2}) == 2.5;
        assert median(new int[]{1, 3, 3, 6, 7, 8, 9}) == 6;
        assert median(new int[]{1, 2, 3, 4, 5, 6, 8, 9}) == 4.5;
    }

    
    public static double median(int[] values) {
        Arrays.sort(values);
        int length = values.length;
        return length % 2 == 0
                ? (values[length / 2] + values[length / 2 - 1]) / 2.0
                : values[length / 2];
    }
}
package com.thealgorithms.maths;


public class Volume {

    public static void main(String[] args) {

        assert Double.compare(volumeCube(7), 343.0) == 0;

        assert Double.compare(volumeCuboid(2, 5, 7), 70.0) == 0;

        assert Double.compare(volumeSphere(5), 523.5987755982989) == 0;

        assert Double.compare(volumeCylinder(1, 2), 12.566370614359172) == 0;

        assert Double.compare(volumeHemisphere(5), 261.79938779914943) == 0;

        assert Double.compare(volumeCone(5, 7), 916.297857297023) == 0;
        
        assert Double.compare(volumePrism(10, 2), 20.0) == 0;
        
        assert Double.compare(volumePyramid(10, 3), 10.0) == 0;

    }

    
    private static double volumeCube(double sidelength) {
        return sidelength * sidelength * sidelength;
    }

    
    private static double volumeCuboid(double width, double height, double length) {
        return width * height * length;
    }

    
    private static double volumeSphere(double radius) {
        return 4 / 3 * Math.PI * radius * radius * radius;
    }

    
    private static double volumeCylinder(double radius, double height) {
        return Math.PI * radius * radius * height;
    }

    
    private static double volumeHemisphere(double radius) {
        return 2 / 3 * Math.PI * radius * radius * radius;
    }

    
    private static double volumeCone(double radius, double height) {
        return Math.PI * radius * radius * height / 3;
    }
    
    
    private static double volumePrism(double basearea, double height) {
        return basearea * height;
    }
    
    
    private static double volumePyramid(double basearea, double height) {
        return basearea * height / 3;
    }
}
package com.thealgorithms.maths;

import java.util.*;

public class DeterminantOfMatrix {

            static int determinant(int a[][], int n) {
        int det = 0, sign = 1, p = 0, q = 0;
        if (n == 1) {
            det = a[0][0];
        } else {
            int b[][] = new int[n - 1][n - 1];
            for (int x = 0; x < n; x++) {
                p = 0;
                q = 0;
                for (int i = 1; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        if (j != x) {
                            b[p][q++] = a[i][j];
                            if (q % (n - 1) == 0) {
                                p++;
                                q = 0;
                            }
                        }
                    }
                }
                det = det + a[0][x] * determinant(b, n - 1) * sign;
                sign = -sign;
            }
        }
        return det;
    }

        public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
                System.out.println("Enter matrix size (Square matrix only)");
        int n = in.nextInt();
        System.out.println("Enter matrix");
        int a[][] = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = in.nextInt();
            }
        }
        System.out.println(determinant(a, n));
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;
import java.util.Random;

public class FindMin {

    
    public static void main(String[] args) {
        Random random = new Random();

        int size = random.nextInt(100) + 1;
        int[] array = new int[size];

        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt() % 100;
        }

        assert Arrays.stream(array).min().getAsInt() == findMin(array);
    }

    
    public static int findMin(int[] array) {
        int min = array[0];
        for (int i = 1; i < array.length; ++i) {
            if (array[i] < min) {
                min = array[i];
            }
        }
        return min;
    }
}
package com.thealgorithms.maths;

import java.util.Arrays;
import java.util.Random;

public class FindMaxRecursion {

    public static void main(String[] args) {
        Random rand = new Random();

        int size = rand.nextInt(100) + 1;
        int[] array = new int[size];

        for (int i = 0; i < size; i++) {
            array[i] = rand.nextInt() % 100;
        }

        assert max(array, array.length) == Arrays.stream(array).max().getAsInt();
        assert max(array, 0, array.length - 1) == Arrays.stream(array).max().getAsInt();
    }

    
    public static int max(int[] array, int low, int high) {
        if (low == high) {
            return array[low];         }

        int mid = (low + high) >>> 1;

        int leftMax = max(array, low, mid);         int rightMax = max(array, mid + 1, high); 
        return Math.max(leftMax, rightMax);
    }

    
    public static int max(int[] array, int len) {
        return len == 1 ? array[0] : Math.max(max(array, len - 1), array[len - 1]);
    }
}
package com.thealgorithms.maths;

import java.util.ArrayList;
import java.util.List;


public class JugglerSequence {
    
    public static void jugglerSequence(int inputNumber) {
                int n = inputNumber;
        List<String> seq = new ArrayList<>();
        seq.add(n + "");
                while (n != 1) {
            int temp;
                                                
                        if (n % 2 == 0) {
                temp = (int) Math.floor(Math.sqrt(n));
            } else {
                temp = (int) Math.floor(Math.sqrt(n) * Math.sqrt(n) * Math.sqrt(n));
            }
            n = temp;
            seq.add(n + "");
        }
        String res = String.join(",", seq);
        System.out.println(res);
    }

        public static void main(String[] args) {
        jugglerSequence(3);
            }
}
package com.thealgorithms.maths;


public class PythagoreanTriple {

    public static void main(String[] args) {
        assert isPythagTriple(3, 4, 5);
        assert isPythagTriple(5, 12, 13);
        assert isPythagTriple(6, 8, 10);
        assert !isPythagTriple(10, 20, 30);
        assert !isPythagTriple(6, 8, 100);
        assert !isPythagTriple(-1, -1, 1);
    }

    
    public static boolean isPythagTriple(int a, int b, int c) {
        if (a <= 0 || b <= 0 || c <= 0) {
            return false;
        } else {
            return (a * a) + (b * b) == (c * c);
        }
    }
}
package com.thealgorithms.maths;

import java.util.Scanner;

public class NonRepeatingElement {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int i, res = 0;
        System.out.println("Enter the number of elements in the array");
        int n = sc.nextInt();
        if ((n & 1) == 1) {
                        System.out.println("Array should contain even number of elements");
            return;
        }
        int arr[] = new int[n];

        System.out.println("Enter " + n + " elements in the array. NOTE: Only 2 elements should not repeat");
        for (i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        try {
            sc.close();
        } catch (Exception e) {
            System.out.println("Unable to close scanner" + e);
        }

                for (i = 0; i < n; i++) {
            res ^= arr[i];
        }

                res = res & (-res);
        int num1 = 0, num2 = 0;

        for (i = 0; i < n; i++) {
            if ((res & arr[i]) > 0)            {
                num1 ^= arr[i];
            } else {
                num2 ^= arr[i];            }
        }

        System.out.println("The two non repeating elements are " + num1 + " and " + num2);

    }
}
package com.thealgorithms.maths;

import java.util.stream.IntStream;


public class AliquotSum {

    
    public static int getAliquotValue(int number) {
        var sumWrapper = new Object() {
            int value = 0;
        };

        IntStream.iterate(1, i -> ++i)
                .limit(number / 2)
                .filter(i -> number % i == 0)
                .forEach(i -> sumWrapper.value += i);

        return sumWrapper.value;
    }
}
package com.thealgorithms.audiofilters;


public class IIRFilter {

    private final int order;
    private final double[] coeffsA;
    private final double[] coeffsB;
    private final double[] historyX;
    private final double[] historyY;

    
    public IIRFilter(int order) throws IllegalArgumentException {
        if (order < 1) {
            throw new IllegalArgumentException("order must be greater than zero");
        }

        this.order = order;
        coeffsA = new double[order + 1];
        coeffsB = new double[order + 1];

                coeffsA[0] = 1.0;
        coeffsB[0] = 1.0;

        historyX = new double[order];
        historyY = new double[order];
    }

    
    public void setCoeffs(double[] aCoeffs, double[] bCoeffs) throws IllegalArgumentException {
        if (aCoeffs.length != order) {
            throw new IllegalArgumentException("aCoeffs must be of size " + order + ", got " + aCoeffs.length);
        }

        if (aCoeffs[0] == 0.0) {
            throw new IllegalArgumentException("aCoeffs.get(0) must not be zero");
        }

        if (bCoeffs.length != order) {
            throw new IllegalArgumentException("bCoeffs must be of size " + order + ", got " + bCoeffs.length);
        }

        for (int i = 0; i <= order; i++) {
            coeffsA[i] = aCoeffs[i];
            coeffsB[i] = bCoeffs[i];
        }
    }

    
    public double process(double sample) {
        double result = 0.0;

                for (int i = 1; i <= order; i++) {
            result += (coeffsB[i] * historyX[i - 1] - coeffsA[i] * historyY[i - 1]);
        }
        result = (result + coeffsB[0] * sample) / coeffsA[0];

                for (int i = order - 1; i > 0; i--) {
            historyX[i] = historyX[i - 1];
            historyY[i] = historyY[i - 1];
        }

        historyX[0] = sample;
        historyY[0] = result;

        return result;
    }
}
package com.thealgorithms.dynamicprogramming;


public class CoinChange {

        public static void main(String[] args) {

        int amount = 12;
        int[] coins = {2, 4, 5};

        System.out.println(
                "Number of combinations of getting change for " + amount + " is: " + change(coins, amount));
        System.out.println(
                "Minimum number of coins required for amount :"
                + amount
                + " is: "
                + minimumCoins(coins, amount));
    }

    
    public static int change(int[] coins, int amount) {

        int[] combinations = new int[amount + 1];
        combinations[0] = 1;

        for (int coin : coins) {
            for (int i = coin; i < amount + 1; i++) {
                combinations[i] += combinations[i - coin];
            }
                                }

        return combinations[amount];
    }

    
    public static int minimumCoins(int[] coins, int amount) {
                int[] minimumCoins = new int[amount + 1];

        minimumCoins[0] = 0;

        for (int i = 1; i <= amount; i++) {
            minimumCoins[i] = Integer.MAX_VALUE;
        }
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (coin <= i) {
                    int sub_res = minimumCoins[i - coin];
                    if (sub_res != Integer.MAX_VALUE && sub_res + 1 < minimumCoins[i]) {
                        minimumCoins[i] = sub_res + 1;
                    }
                }
            }
        }
                        return minimumCoins[amount];
    }

        public static void printAmount(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
package com.thealgorithms.dynamicprogramming;



public class RegexMatching {

            static boolean regexRecursion(String src, String pat) {
        if (src.length() == 0 && pat.length() == 0) {
            return true;
        }
        if (src.length() != 0 && pat.length() == 0) {
            return false;
        }
        if (src.length() == 0 && pat.length() != 0) {
            for (int i = 0; i < pat.length(); i++) {
                if (pat.charAt(i) != '*') {
                    return false;
                }
            }
            return true;
        }
        char chs = src.charAt(0);
        char chp = pat.charAt(0);

        String ros = src.substring(1);
        String rop = pat.substring(1);

        boolean ans;
        if (chs == chp || chp == '?') {
            ans = regexRecursion(ros, rop);
        } else if (chp == '*') {
            boolean blank = regexRecursion(src, rop);
            boolean multiple = regexRecursion(ros, pat);
            ans = blank || multiple;
        } else {
            ans = false;
        }
        return ans;
    }

            static boolean regexRecursion(String src, String pat, int svidx, int pvidx) {
        if (src.length() == svidx && pat.length() == pvidx) {
            return true;
        }
        if (src.length() != svidx && pat.length() == pvidx) {
            return false;
        }
        if (src.length() == svidx && pat.length() != pvidx) {
            for (int i = pvidx; i < pat.length(); i++) {
                if (pat.charAt(i) != '*') {
                    return false;
                }
            }
            return true;
        }
        char chs = src.charAt(svidx);
        char chp = pat.charAt(pvidx);

        boolean ans;
        if (chs == chp || chp == '?') {
            ans = regexRecursion(src, pat, svidx + 1, pvidx + 1);
        } else if (chp == '*') {
            boolean blank = regexRecursion(src, pat, svidx, pvidx + 1);
            boolean multiple = regexRecursion(src, pat, svidx + 1, pvidx);
            ans = blank || multiple;
        } else {
            ans = false;
        }
        return ans;
    }

            static boolean regexRecursion(String src, String pat, int svidx, int pvidx, int[][] strg) {
        if (src.length() == svidx && pat.length() == pvidx) {
            return true;
        }
        if (src.length() != svidx && pat.length() == pvidx) {
            return false;
        }
        if (src.length() == svidx && pat.length() != pvidx) {
            for (int i = pvidx; i < pat.length(); i++) {
                if (pat.charAt(i) != '*') {
                    return false;
                }
            }
            return true;
        }
        if (strg[svidx][pvidx] != 0) {
            return strg[svidx][pvidx] == 1 ? false : true;
        }
        char chs = src.charAt(svidx);
        char chp = pat.charAt(pvidx);

        boolean ans;
        if (chs == chp || chp == '?') {
            ans = regexRecursion(src, pat, svidx + 1, pvidx + 1, strg);
        } else if (chp == '*') {
            boolean blank = regexRecursion(src, pat, svidx, pvidx + 1, strg);
            boolean multiple = regexRecursion(src, pat, svidx + 1, pvidx, strg);
            ans = blank || multiple;
        } else {
            ans = false;
        }
        strg[svidx][pvidx] = ans == false ? 1 : 2;
        return ans;
    }

            static boolean regexBU(String src, String pat) {

        boolean strg[][] = new boolean[src.length() + 1][pat.length() + 1];
        strg[src.length()][pat.length()] = true;
        for (int row = src.length(); row >= 0; row--) {
            for (int col = pat.length() - 1; col >= 0; col--) {
                if (row == src.length()) {
                    if (pat.charAt(col) == '*') {
                        strg[row][col] = strg[row][col + 1];
                    } else {
                        strg[row][col] = false;
                    }
                } else {
                    char chs = src.charAt(row);
                    char chp = pat.charAt(col);

                    boolean ans;
                    if (chs == chp || chp == '?') {
                        ans = strg[row + 1][col + 1];
                    } else if (chp == '*') {
                        boolean blank = strg[row][col + 1];
                        boolean multiple = strg[row + 1][col];
                        ans = blank || multiple;
                    } else {
                        ans = false;
                    }
                    strg[row][col] = ans;
                }
            }
        }
        return strg[0][0];
    }

    public static void main(String[] args) {

        String src = "aa";
        String pat = "*";
        System.out.println("Method 1: " + regexRecursion(src, pat));
        System.out.println("Method 2: " + regexRecursion(src, pat, 0, 0));
        System.out.println("Method 3: " + regexRecursion(src, pat, 0, 0, new int[src.length()][pat.length()]));
        System.out.println("Method 4: " + regexBU(src, pat));

    }

}
package com.thealgorithms.dynamicprogramming;

public class LongestPalindromicSubstring {

    public static void main(String[] args) {
        String a = "babad";
        String b = "cbbd";

        String aLPS = LPS(a);
        String bLPS = LPS(b);

        System.out.println(a + " => " + aLPS);
        System.out.println(b + " => " + bLPS);
    }

    private static String LPS(String input) {
        if (input == null || input.length() == 0) {
            return input;
        }
        boolean arr[][] = new boolean[input.length()][input.length()];
        int start = 0, end = 0;
        for (int g = 0; g < input.length(); g++) {
            for (int i = 0, j = g; j < input.length(); i++, j++) {

                if (g == 0) {
                    arr[i][j] = true;
                } else if (g == 1) {
                    if (input.charAt(i) == input.charAt(j)) {
                        arr[i][j] = true;
                    } else {
                        arr[i][j] = false;
                    }
                } else {

                    if (input.charAt(i) == input.charAt(j) && arr[i + 1][j - 1]) {
                        arr[i][j] = true;
                    } else {
                        arr[i][j] = false;
                    }
                }

                if (arr[i][j]) {
                    start = i;
                    end = j;
                }
            }
        }
        return input.substring(start, end + 1);
    }

}
package com.thealgorithms.dynamicprogramming;


public class LevenshteinDistance {

    private static int minimum(int a, int b, int c) {
        if (a < b && a < c) {
            return a;
        } else if (b < a && b < c) {
            return b;
        } else {
            return c;
        }
    }

    private static int calculate_distance(String a, String b) {
        int len_a = a.length() + 1;
        int len_b = b.length() + 1;
        int[][] distance_mat = new int[len_a][len_b];
        for (int i = 0; i < len_a; i++) {
            distance_mat[i][0] = i;
        }
        for (int j = 0; j < len_b; j++) {
            distance_mat[0][j] = j;
        }
        for (int i = 0; i < len_a; i++) {
            for (int j = 0; j < len_b; j++) {
                int cost;
                if (a.charAt(i) == b.charAt(j)) {
                    cost = 0;
                } else {
                    cost = 1;
                }
                distance_mat[i][j]
                        = minimum(distance_mat[i - 1][j], distance_mat[i - 1][j - 1], distance_mat[i][j - 1])
                        + cost;
            }
        }
        return distance_mat[len_a - 1][len_b - 1];
    }

    public static void main(String[] args) {
        String a = "";         String b = ""; 
        System.out.print("Levenshtein distance between " + a + " and " + b + " is: ");
        System.out.println(calculate_distance(a, b));
    }
}
package com.thealgorithms.dynamicprogramming;


public class BoundaryFill {
	
    
	public static int getPixel(int[][] image, int x_co_ordinate, int y_co_ordinate) {
	
		return image[x_co_ordinate][y_co_ordinate];
	
	}
	
    
	public static void putPixel(int[][] image, int x_co_ordinate, int y_co_ordinate, int new_color) {
		
		image[x_co_ordinate][y_co_ordinate] = new_color;
	
	}
	
    
	public static void boundaryFill(int[][] image, int x_co_ordinate, int y_co_ordinate, int new_color, int boundary_color) {
		if(x_co_ordinate >= 0 && y_co_ordinate >= 0 && getPixel(image, x_co_ordinate, y_co_ordinate) != new_color && getPixel(image, x_co_ordinate, y_co_ordinate) != boundary_color) {
			
			putPixel(image, x_co_ordinate, y_co_ordinate, new_color);
			boundaryFill(image, x_co_ordinate + 1, y_co_ordinate, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate - 1, y_co_ordinate, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate, y_co_ordinate + 1, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate, y_co_ordinate - 1, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate + 1, y_co_ordinate - 1, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate - 1, y_co_ordinate + 1, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate + 1, y_co_ordinate + 1, new_color, boundary_color);
			boundaryFill(image, x_co_ordinate - 1, y_co_ordinate - 1, new_color, boundary_color);
			
			
		}
		
	}
	
    
	public static void printImageArray(int[][] image) {
		
		for(int i=0 ; i<image.length ; i++) {
			for(int j=0 ; j<image[0].length ; j++) {
				
				System.out.print(image[i][j]+"  ");
			}
			
			System.out.println();
		}
		
	}
	
		public static void main(String[] args) {
		
				int[][] image = {
				{0,0,0,0,0,0,0},
				{0,3,3,3,3,0,0},
				{0,3,0,0,3,0,0},
				{0,3,0,0,3,3,3},
				{0,3,3,3,0,0,3},
				{0,0,0,3,0,0,3},
				{0,0,0,3,3,3,3}
		};
		
		
		boundaryFill(image,2,2,5,3);
		
				printImageArray(image);
	}

}package com.thealgorithms.dynamicprogramming;

public class DyanamicProgrammingKnapsack {

    static int max(int a, int b) {
        return (a > b) ? a : b;
    }

            static int knapSack(int W, int wt[], int val[], int n) {
        int i, w;
        int K[][] = new int[n + 1][W + 1];

                for (i = 0; i <= n; i++) {
            for (w = 0; w <= W; w++) {
                if (i == 0 || w == 0) {
                    K[i][w] = 0;
                } else if (wt[i - 1] <= w) {
                    K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]);
                } else {
                    K[i][w] = K[i - 1][w];
                }
            }
        }

        return K[n][W];
    }

        public static void main(String args[]) {
        int val[] = new int[]{60, 100, 120};
        int wt[] = new int[]{10, 20, 30};
        int W = 50;
        int n = val.length;
        System.out.println(knapSack(W, wt, val, n));
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

public class MatrixChainMultiplication {

    private static Scanner scan = new Scanner(System.in);
    private static ArrayList<Matrix> mArray = new ArrayList<>();
    private static int size;
    private static int[][] m;
    private static int[][] s;
    private static int[] p;

    public static void main(String[] args) {
        int count = 1;
        while (true) {
            String[] mSize = input("input size of matrix A(" + count + ") ( ex. 10 20 ) : ");
            int col = Integer.parseInt(mSize[0]);
            if (col == 0) {
                break;
            }
            int row = Integer.parseInt(mSize[1]);

            Matrix matrix = new Matrix(count, col, row);
            mArray.add(matrix);
            count++;
        }
        for (Matrix m : mArray) {
            System.out.format("A(%d)  =  %2d  x  %2d%n", m.count(), m.col(), m.row());
        }

        size = mArray.size();
        m = new int[size + 1][size + 1];
        s = new int[size + 1][size + 1];
        p = new int[size + 1];

        for (int i = 0; i < size + 1; i++) {
            Arrays.fill(m[i], -1);
            Arrays.fill(s[i], -1);
        }

        for (int i = 0; i < p.length; i++) {
            p[i] = i == 0 ? mArray.get(i).col() : mArray.get(i - 1).row();
        }

        matrixChainOrder();
        for (int i = 0; i < size; i++) {
            System.out.print("-------");
        }
        System.out.println();
        printArray(m);
        for (int i = 0; i < size; i++) {
            System.out.print("-------");
        }
        System.out.println();
        printArray(s);
        for (int i = 0; i < size; i++) {
            System.out.print("-------");
        }
        System.out.println();

        System.out.println("Optimal solution : " + m[1][size]);
        System.out.print("Optimal parens : ");
        printOptimalParens(1, size);
    }

    private static void printOptimalParens(int i, int j) {
        if (i == j) {
            System.out.print("A" + i);
        } else {
            System.out.print("(");
            printOptimalParens(i, s[i][j]);
            printOptimalParens(s[i][j] + 1, j);
            System.out.print(")");
        }
    }

    private static void printArray(int[][] array) {
        for (int i = 1; i < size + 1; i++) {
            for (int j = 1; j < size + 1; j++) {
                System.out.print(String.format("%7d", array[i][j]));
            }
            System.out.println();
        }
    }

    private static void matrixChainOrder() {
        for (int i = 1; i < size + 1; i++) {
            m[i][i] = 0;
        }

        for (int l = 2; l < size + 1; l++) {
            for (int i = 1; i < size - l + 2; i++) {
                int j = i + l - 1;
                m[i][j] = Integer.MAX_VALUE;

                for (int k = i; k < j; k++) {
                    int q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
                    if (q < m[i][j]) {
                        m[i][j] = q;
                        s[i][j] = k;
                    }
                }
            }
        }
    }

    private static String[] input(String string) {
        System.out.print(string);
        return (scan.nextLine().split(" "));
    }
}

class Matrix {

    private int count;
    private int col;
    private int row;

    Matrix(int count, int col, int row) {
        this.count = count;
        this.col = col;
        this.row = row;
    }

    int count() {
        return count;
    }

    int col() {
        return col;
    }

    int row() {
        return row;
    }
}
package com.thealgorithms.dynamicprogramming;


public class EggDropping {

        private static int minTrials(int n, int m) {

        int[][] eggFloor = new int[n + 1][m + 1];
        int result, x;

        for (int i = 1; i <= n; i++) {
            eggFloor[i][0] = 0;             eggFloor[i][1] = 1;         }

                for (int j = 1; j <= m; j++) {
            eggFloor[1][j] = j;
        }

                for (int i = 2; i <= n; i++) {
            for (int j = 2; j <= m; j++) {
                eggFloor[i][j] = Integer.MAX_VALUE;
                for (x = 1; x <= j; x++) {
                    result = 1 + Math.max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);

                                        if (result < eggFloor[i][j]) {
                        eggFloor[i][j] = result;
                    }
                }
            }
        }

        return eggFloor[n][m];
    }

    public static void main(String args[]) {
        int n = 2, m = 4;
                int result = minTrials(n, m);
        System.out.println(result);
    }
}
package com.thealgorithms.dynamicprogramming;


public class Knapsack {

    private static int knapSack(int W, int wt[], int val[], int n) throws IllegalArgumentException {
        if (wt == null || val == null) {
            throw new IllegalArgumentException();
        }
        int i, w;
        int rv[][] = new int[n + 1][W + 1]; 
                for (i = 0; i <= n; i++) {
            for (w = 0; w <= W; w++) {
                if (i == 0 || w == 0) {
                    rv[i][w] = 0;
                } else if (wt[i - 1] <= w) {
                    rv[i][w] = Math.max(val[i - 1] + rv[i - 1][w - wt[i - 1]], rv[i - 1][w]);
                } else {
                    rv[i][w] = rv[i - 1][w];
                }
            }
        }

        return rv[n][W];
    }

        public static void main(String args[]) {
        int val[] = new int[]{50, 100, 130};
        int wt[] = new int[]{10, 20, 40};
        int W = 50;
        System.out.println(knapSack(W, wt, val, val.length));
    }
}







package com.thealgorithms.dynamicprogramming;

import java.util.*;

public class UniquePaths {
    public static boolean uniquePaths(int m , int n , int ans) {
        int []dp = new int[n];
        Arrays.fill(dp,1);
        for (int i=1; i<m; i++)
        {
            for (int j=1; j<n; j++)
            {
                dp[j] += dp[j-1];

            }
        }
        return dp[n-1]==ans;
            }
        public static boolean uniquePaths2(int m , int n , int ans) {
        int dp[][] = new int[m][n];
        for (int i=0; i<m; i++)
        {
            dp[i][0] = 1;
        }
        for (int j=0; j<n; j++)
        {
            dp[0][j] = 1;
        }
        for (int i=1; i<m; i++)
        {
            for (int j=1; j<n; j++)
            {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1]==ans;
            }
    }

package com.thealgorithms.dynamicprogramming;

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;


public class Fibonacci {

    private static Map<Integer, Integer> map = new HashMap<>();

    public static void main(String[] args) {

                Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        System.out.println(fibMemo(n));
        System.out.println(fibBotUp(n));
        System.out.println(fibOptimized(n));
        sc.close();
    }

    
    public static int fibMemo(int n) {
        if (map.containsKey(n)) {
            return map.get(n);
        }

        int f;

        if (n <= 1) {
            f = n;
        } else {
            f = fibMemo(n - 1) + fibMemo(n - 2);
            map.put(n, f);
        }
        return f;
    }

    
    public static int fibBotUp(int n) {

        Map<Integer, Integer> fib = new HashMap<>();

        for (int i = 0; i <= n; i++) {
            int f;
            if (i <= 1) {
                f = i;
            } else {
                f = fib.get(i - 1) + fib.get(i - 2);
            }
            fib.put(i, f);
        }

        return fib.get(n);
    }

    
    public static int fibOptimized(int n) {
        if (n == 0) {
            return 0;
        }
        int prev = 0, res = 1, next;
        for (int i = 2; i <= n; i++) {
            next = prev + res;
            prev = res;
            res = next;
        }
        return res;
    }
}







package com.thealgorithms.dynamicprogramming;

public class CountFriendsPairing {
    public static boolean countFriendsPairing(int n, int a[]) {
        int dp[] = new int[n + 1];
                dp[0] = 1;
                for (int i = 1; i < n; i++) {
            dp[i] = 1 + dp[i - dp[dp[i - 1]]];
                    }
        for (int i = 1; i < n; i++) {
            if (a[i - 1] != dp[i]) {
                return false;
                            }
        }
        return true;
            }
}
package com.thealgorithms.dynamicprogramming;


public class RodCutting {

    private static int cutRod(int[] price, int n) {
        int val[] = new int[n + 1];
        val[0] = 0;

        for (int i = 1; i <= n; i++) {
            int max_val = Integer.MIN_VALUE;
            for (int j = 0; j < i; j++) {
                max_val = Math.max(max_val, price[j] + val[i - j - 1]);
            }

            val[i] = max_val;
        }

        return val[n];
    }

        public static void main(String args[]) {
        int[] arr = new int[]{2, 5, 13, 19, 20};
        int result = cutRod(arr, arr.length);
        System.out.println("Maximum Obtainable Value is " + result);
    }
}
package com.thealgorithms.dynamicprogramming;


public class LongestPalindromicSubsequence {

    public static void main(String[] args) {
        String a = "BBABCBCAB";
        String b = "BABCBAB";

        String aLPS = LPS(a);
        String bLPS = LPS(b);

        System.out.println(a + " => " + aLPS);
        System.out.println(b + " => " + bLPS);
    }

    public static String LPS(String original) throws IllegalArgumentException {
        StringBuilder reverse = new StringBuilder(original);
        reverse = reverse.reverse();
        return recursiveLPS(original, reverse.toString());
    }

    private static String recursiveLPS(String original, String reverse) {
        String bestResult = "";

                if (original.length() == 0 || reverse.length() == 0) {
            bestResult = "";
        } else {

                        if (original.charAt(original.length() - 1) == reverse.charAt(reverse.length() - 1)) {
                String bestSubResult
                        = recursiveLPS(
                                original.substring(0, original.length() - 1),
                                reverse.substring(0, reverse.length() - 1));

                bestResult = reverse.charAt(reverse.length() - 1) + bestSubResult;
            } else {
                                                                                
                String bestSubResult1 = recursiveLPS(original, reverse.substring(0, reverse.length() - 1));
                String bestSubResult2 = recursiveLPS(original.substring(0, original.length() - 1), reverse);
                if (bestSubResult1.length() > bestSubResult2.length()) {
                    bestResult = bestSubResult1;
                } else {
                    bestResult = bestSubResult2;
                }
            }
        }

        return bestResult;
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Vector;

public class FordFulkerson {

    static final int INF = 987654321;
        static int V;
    static int[][] capacity, flow;

    public static void main(String[] args) {
        System.out.println("V : 6");
        V = 6;
        capacity = new int[V][V];

        capacity[0][1] = 12;
        capacity[0][3] = 13;
        capacity[1][2] = 10;
        capacity[2][3] = 13;
        capacity[2][4] = 3;
        capacity[2][5] = 15;
        capacity[3][2] = 7;
        capacity[3][4] = 15;
        capacity[4][5] = 17;

        System.out.println("Max capacity in networkFlow : " + networkFlow(0, 5));
    }

    private static int networkFlow(int source, int sink) {
        flow = new int[V][V];
        int totalFlow = 0;
        while (true) {
            Vector<Integer> parent = new Vector<>(V);
            for (int i = 0; i < V; i++) {
                parent.add(-1);
            }
            Queue<Integer> q = new LinkedList<>();
            parent.set(source, source);
            q.add(source);
            while (!q.isEmpty() && parent.get(sink) == -1) {
                int here = q.peek();
                q.poll();
                for (int there = 0; there < V; ++there) {
                    if (capacity[here][there] - flow[here][there] > 0 && parent.get(there) == -1) {
                        q.add(there);
                        parent.set(there, here);
                    }
                }
            }
            if (parent.get(sink) == -1) {
                break;
            }

            int amount = INF;
            String printer = "path : ";
            StringBuilder sb = new StringBuilder();
            for (int p = sink; p != source; p = parent.get(p)) {
                amount = Math.min(capacity[parent.get(p)][p] - flow[parent.get(p)][p], amount);
                sb.append(p + "-");
            }
            sb.append(source);
            for (int p = sink; p != source; p = parent.get(p)) {
                flow[parent.get(p)][p] += amount;
                flow[p][parent.get(p)] -= amount;
            }
            totalFlow += amount;
            printer += sb.reverse() + " / max flow : " + totalFlow;
            System.out.println(printer);
        }

        return totalFlow;
    }
}
package com.thealgorithms.dynamicprogramming;

public class MemoizationTechniqueKnapsack {

            static int max(int a, int b) {
        return (a > b) ? a : b;
    }

        static int knapSackRec(int W, int wt[], int val[], int n, int[][] dp) {

                if (n == 0 || W == 0) {
            return 0;
        }

        if (dp[n][W] != -1) {
            return dp[n][W];
        }

        if (wt[n - 1] > W)                 {
            return dp[n][W] = knapSackRec(W, wt, val, n - 1, dp);
        } else         {
            return dp[n][W]
                    = max(
                            (val[n - 1] + knapSackRec(W - wt[n - 1], wt, val, n - 1, dp)),
                            knapSackRec(W, wt, val, n - 1, dp));
        }
    }

    static int knapSack(int W, int wt[], int val[], int N) {

                int dp[][] = new int[N + 1][W + 1];

                        for (int i = 0; i < N + 1; i++) {
            for (int j = 0; j < W + 1; j++) {
                dp[i][j] = -1;
            }
        }

        return knapSackRec(W, wt, val, N, dp);
    }

        public static void main(String[] args) {
        int val[] = {60, 100, 120};
        int wt[] = {10, 20, 30};

        int W = 50;
        int N = val.length;

        System.out.println(knapSack(W, wt, val, N));
    }
}
package com.thealgorithms.dynamicprogramming;


public class BruteForceKnapsack {

            static int max(int a, int b) {
        return (a > b) ? a : b;
    }

                static int knapSack(int W, int wt[], int val[], int n) {
                if (n == 0 || W == 0) {
            return 0;
        }

                                        if (wt[n - 1] > W) {
            return knapSack(W, wt, val, n - 1);
        }                         else {
            return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1), knapSack(W, wt, val, n - 1));
        }
    }

        public static void main(String args[]) {
        int val[] = new int[]{60, 100, 120};
        int wt[] = new int[]{10, 20, 30};
        int W = 50;
        int n = val.length;
        System.out.println(knapSack(W, wt, val, n));
    }
}
package com.thealgorithms.dynamicprogramming;


import java.util.Scanner;

public class CatalanNumber {

    
    static long findNthCatalan(int n) {

                long catalanArray[] = new long[n + 1];

                catalanArray[0] = 1;
        catalanArray[1] = 1;

        
        for (int i = 2; i <= n; i++) {
            catalanArray[i] = 0;
            for (int j = 0; j < i; j++) {
                catalanArray[i] += catalanArray[j] * catalanArray[i - j - 1];
            }
        }

        return catalanArray[n];
    }

        public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.println("Enter the number n to find nth Catalan number (n <= 50)");
        int n = sc.nextInt();
        System.out.println(n + "th Catalan number is " + findNthCatalan(n));

        sc.close();
    }
}
package com.thealgorithms.dynamicprogramming;

public class BoardPath {

    public static long startTime;
    public static long endTime;

    public static void startAlgo() {
        startTime = System.currentTimeMillis();
    }

    public static long endAlgo() {
        endTime = System.currentTimeMillis();
        return endTime - startTime;
    }

    public static int bpR(int start, int end) {
        if (start == end) {
            return 1;
        } else if (start > end) {
            return 0;
        }
        int count = 0;
        for (int dice = 1; dice <= 6; dice++) {
            count += bpR(start + dice, end);
        }
        return count;
    }

    public static int bpRS(int curr, int end, int strg[]) {
        if (curr == end) {
            return 1;
        } else if (curr > end) {
            return 0;
        }
        if (strg[curr] != 0) {
            return strg[curr];
        }
        int count = 0;
        for (int dice = 1; dice <= 6; dice++) {
            count += bpRS(curr + dice, end, strg);
        }
        strg[curr] = count;
        return count;
    }

    public static int bpIS(int curr, int end, int[] strg) {
        strg[end] = 1;
        for (int i = end - 1; i >= 0; i--) {
            int count = 0;
            for (int dice = 1; dice <= 6 && dice + i < strg.length; dice++) {
                count += strg[i + dice];
            }
            strg[i] = count;
        }
        return strg[0];
    }
}
package com.thealgorithms.dynamicprogramming;


import java.util.Scanner;

public class EditDistance {

    public static int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
                int[][] dp = new int[len1 + 1][len2 + 1];
        for (int i = 0; i <= len1; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= len2; j++) {
            dp[0][j] = j;
        }
                for (int i = 0; i < len1; i++) {
            char c1 = word1.charAt(i);
            for (int j = 0; j < len2; j++) {
                char c2 = word2.charAt(j);
                                if (c1 == c2) {
                                        dp[i + 1][j + 1] = dp[i][j];
                } else {

                    int replace = dp[i][j] + 1;
                    int insert = dp[i][j + 1] + 1;
                    int delete = dp[i + 1][j] + 1;

                    int min = replace > insert ? insert : replace;
                    min = delete > min ? min : delete;
                    dp[i + 1][j + 1] = min;
                }
            }
        }
        return dp[len1][len2];
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        String s1, s2;
        System.out.println("Enter the First String");
        s1 = input.nextLine();
        System.out.println("Enter the Second String");
        s2 = input.nextLine();
                int ans = minDistance(s1, s2);
        System.out.println(
                "The minimum Edit Distance between \"" + s1 + "\" and \"" + s2 + "\" is " + ans);
        input.close();
    }

        public static int editDistance(String s1, String s2) {
        int[][] storage = new int[s1.length() + 1][s2.length() + 1];
        return editDistance(s1, s2, storage);

    }

    public static int editDistance(String s1, String s2, int[][] storage) {
        int m = s1.length();
        int n = s2.length();
        if (storage[m][n] > 0) {
            return storage[m][n];

        }
        if (m == 0) {
            storage[m][n] = n;
            return storage[m][n];

        }
        if (n == 0) {
            storage[m][n] = m;
            return storage[m][n];

        }
        if (s1.charAt(0) == s2.charAt(0)) {
            storage[m][n] = editDistance(s1.substring(1), s2.substring(1), storage);
            return storage[m][n];

        } else {
            int op1 = editDistance(s1, s2.substring(1), storage);
            int op2 = editDistance(s1.substring(1), s2, storage);
            int op3 = editDistance(s1.substring(1), s2.substring(1), storage);
            storage[m][n] = 1 + Math.min(op1, Math.min(op2, op3));
            return storage[m][n];
        }
    }
}
package com.thealgorithms.dynamicprogramming;

class DP {

    public static long findWays(int m, int n, int x) {

        long[][] table = new long[n + 1][x + 1];

        for (int j = 1; j <= m && j <= x; j++) {
            table[1][j] = 1;
        }
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                for (int k = 1; k < j && k <= m; k++) {
                    table[i][j] += table[i - 1][j - k];
                }
            }
        }

        return table[n][x];
    }

    public static void main(String[] args) {
        System.out.println(findWays(4, 2, 1));
        System.out.println(findWays(2, 2, 3));
        System.out.println(findWays(6, 3, 8));
        System.out.println(findWays(4, 2, 5));
        System.out.println(findWays(4, 3, 5));
    }
}

package com.thealgorithms.dynamicprogramming;

public class MatrixChainRecursiveTopDownMemoisation {

    static int Memoized_Matrix_Chain(int p[]) {
        int n = p.length;
        int m[][] = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                m[i][j] = Integer.MAX_VALUE;
            }
        }
        return Lookup_Chain(m, p, 1, n - 1);
    }

    static int Lookup_Chain(int m[][], int p[], int i, int j) {
        if (i == j) {
            m[i][j] = 0;
            return m[i][j];
        }
        if (m[i][j] < Integer.MAX_VALUE) {
            return m[i][j];
        } else {
            for (int k = i; k < j; k++) {
                int q = Lookup_Chain(m, p, i, k) + Lookup_Chain(m, p, k + 1, j) + (p[i - 1] * p[k] * p[j]);
                if (q < m[i][j]) {
                    m[i][j] = q;
                }
            }
        }
        return m[i][j];
    }

            public static void main(String[] args) {

        int arr[] = {1, 2, 3, 4, 5};
        System.out.println("Minimum number of multiplications is " + Memoized_Matrix_Chain(arr));
    }
}





public class WineProblem {

            public static int WPRecursion(int[] arr, int si, int ei) {
        int n = arr.length;
        int year = (n - (ei - si + 1)) + 1;
        if (si == ei) {
            return arr[si] * year;
        }

        int start = WPRecursion(arr, si + 1, ei) + arr[si] * year;
        int end = WPRecursion(arr, si, ei - 1) + arr[ei] * year;

        int ans = Math.max(start, end);

        return ans;
    }

            public static int WPTD(int[] arr, int si, int ei, int[][] strg) {
        int n = arr.length;
        int year = (n - (ei - si + 1)) + 1;
        if (si == ei) {
            return arr[si] * year;
        }

        if (strg[si][ei] != 0) {
            return strg[si][ei];
        }
        int start = WPTD(arr, si + 1, ei, strg) + arr[si] * year;
        int end = WPTD(arr, si, ei - 1, strg) + arr[ei] * year;

        int ans = Math.max(start, end);

        strg[si][ei] = ans;

        return ans;
    }

            public static int WPBU(int[] arr) {
        int n = arr.length;
        int[][] strg = new int[n][n];

        for (int slide = 0; slide <= n - 1; slide++) {
            for (int si = 0; si <= n - slide - 1; si++) {
                int ei = si + slide;
                int year = (n - (ei - si + 1)) + 1;
                if (si == ei) {
                    strg[si][ei] = arr[si] * year;
                } else {
                    int start = strg[si + 1][ei] + arr[si] * year;
                    int end = strg[si][ei - 1] + arr[ei] * year;

                    strg[si][ei] = Math.max(start, end);

                }
            }
        }
        return strg[0][n - 1];
    }

    public static void main(String[] args) {
        int[] arr = {2, 3, 5, 1, 4};
        System.out.println("Method 1: " + WPRecursion(arr, 0, arr.length - 1));
        System.out.println("Method 2: " + WPTD(arr, 0, arr.length - 1, new int[arr.length][arr.length]));
        System.out.println("Method 3: " + WPBU(arr));

    }

}
package com.thealgorithms.dynamicprogramming;

public class LongestAlternatingSubsequence {

    static int AlternatingLength(int arr[], int n) {

		las[i][0] = Length of the longest
			alternating subsequence ending at
			index i and last element is
			greater than its previous element

		las[i][1] = Length of the longest
			alternating subsequence ending at
			index i and last element is
			smaller than its previous
			element 

         */
        int las[][] = new int[n][2]; 
        for (int i = 0; i < n; i++) {
            las[i][0] = las[i][1] = 1;
        }

        int result = 1; 
        for (int i = 1; i < n; i++) {

            for (int j = 0; j < i; j++) {

                if (arr[j] < arr[i] && las[i][0] < las[j][1] + 1) {
                    las[i][0] = las[j][1] + 1;
                }

                if (arr[j] > arr[i] && las[i][1] < las[j][0] + 1) {
                    las[i][1] = las[j][0] + 1;
                }
            }

            if (result < Math.max(las[i][0], las[i][1])) {
                result = Math.max(las[i][0], las[i][1]);
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int arr[] = {10, 22, 9, 33, 49, 50, 31, 60};
        int n = arr.length;
        System.out.println("Length of Longest " + "alternating subsequence is " + AlternatingLength(arr, n));
    }
}
package com.thealgorithms.dynamicprogramming;


public class MinimumSumPartition {

    public static int subSet(int[] arr) {
        int n = arr.length;
        int sum = getSum(arr);
        boolean[][] dp = new boolean[n + 1][sum + 1];
        for (int i = 0; i <= n; i++) {
            dp[i][0] = true;
        }
        for (int j = 0; j <= sum; j++) {
            dp[0][j] = false;
        }

                for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= sum; j++) {
                if (arr[i - 1] < j) {
                    dp[i][j] = dp[i - 1][j - arr[i - 1]] || dp[i - 1][j];
                } else if (arr[i - 1] == j) {
                    dp[i][j] = true;
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

                int[] index = new int[sum];
        int p = 0;
        for (int i = 0; i <= sum / 2; i++) {
            if (dp[n][i]) {
                index[p++] = i;
            }
        }

        return getMin(index, sum);
    }

    
    public static int getSum(int[] arr) {
        int sum = 0;
        for (int temp : arr) {
            sum += temp;
        }
        return sum;
    }

    public static int getMin(int[] arr, int sum) {
        if (arr.length == 0) {
            return 0;
        }
        int min = Integer.MAX_VALUE;
        for (int temp : arr) {
            min = Math.min(min, sum - 2 * temp);
        }
        return min;
    }

    
    public static void main(String[] args) {
        assert subSet(new int[]{1, 6, 11, 5}) == 1;
        assert subSet(new int[]{36, 7, 46, 40}) == 23;
        assert subSet(new int[]{1, 2, 3, 9}) == 3;
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.Scanner;


public class PalindromicPartitioning {

    public static int minimalpartitions(String word) {
        int len = word.length();

        int[] minCuts = new int[len];
        boolean[][] isPalindrome = new boolean[len][len];

        int i, j, L; 
                for (i = 0; i < len; i++) {
            isPalindrome[i][i] = true;
        }

        for (L = 2; L <= len; L++) {
                        for (i = 0; i < len - L + 1; i++) {
                j = i + L - 1;                                                                                 if (L == 2) {
                    isPalindrome[i][j] = (word.charAt(i) == word.charAt(j));
                } else {
                    if ((word.charAt(i) == word.charAt(j)) && isPalindrome[i + 1][j - 1]) {
                        isPalindrome[i][j] = true;
                    } else {
                        isPalindrome[i][j] = false;
                    }

                }
            }
        }

                for (i = 0; i < len; i++) {
            if (isPalindrome[0][i] == true) {
                minCuts[i] = 0;
            } else {
                minCuts[i] = Integer.MAX_VALUE;
                for (j = 0; j < i; j++) {
                    if (isPalindrome[j + 1][i] == true && 1 + minCuts[j] < minCuts[i]) {
                        minCuts[i] = 1 + minCuts[j];
                    }
                }
            }
        }

                        return minCuts[len - 1];
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        String word;
        System.out.println("Enter the First String");
        word = input.nextLine();
                int ans = minimalpartitions(word);
        System.out.println(
                "The minimum cuts needed to partition \"" + word + "\" into palindromes is " + ans);
        input.close();
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.Arrays;


public class KnapsackMemoization {

    private static int[][] t;

            public static int knapsack(int[] wt, int[] value, int W, int n) {
        if (t[n][W] != -1) {
            return t[n][W];
        }
        if (n == 0 || W == 0) {
            return 0;
        }
        if (wt[n - 1] <= W) {
            t[n - 1][W - wt[n - 1]] = knapsack(wt, value, W - wt[n - 1], n - 1);
                        int tmp1 = value[n - 1] + t[n - 1][W - wt[n - 1]];
                        int tmp2 = knapsack(wt, value, W, n - 1);
            t[n - 1][W] = tmp2;
                        int tmp = tmp1 > tmp2 ? tmp1 : tmp2;
            t[n][W] = tmp;
            return tmp;
                                } else if (wt[n - 1] > W) {
            t[n][W] = knapsack(wt, value, W, n - 1);
            return t[n][W];
        }
        return -1;
    }

        public static void main(String args[]) {
        int[] wt = {1, 3, 4, 5};
        int[] value = {1, 4, 5, 7};
        int W = 10;
        t = new int[wt.length + 1][W + 1];
        Arrays.stream(t).forEach(a -> Arrays.fill(a, -1));
        int res = knapsack(wt, value, W, wt.length);
        System.out.println("Maximum knapsack value " + res);
    }
}
package com.thealgorithms.dynamicprogramming;

class LongestCommonSubsequence {

    public static String getLCS(String str1, String str2) {

                if (str1 == null || str2 == null) {
            return null;
        }

                if (str1.length() == 0 || str2.length() == 0) {
            return "";
        }

        String[] arr1 = str1.split("");
        String[] arr2 = str2.split("");

                int[][] lcsMatrix = new int[arr1.length + 1][arr2.length + 1];

        for (int i = 0; i < arr1.length + 1; i++) {
            lcsMatrix[i][0] = 0;
        }
        for (int j = 1; j < arr2.length + 1; j++) {
            lcsMatrix[0][j] = 0;
        }
        for (int i = 1; i < arr1.length + 1; i++) {
            for (int j = 1; j < arr2.length + 1; j++) {
                if (arr1[i - 1].equals(arr2[j - 1])) {
                    lcsMatrix[i][j] = lcsMatrix[i - 1][j - 1] + 1;
                } else {
                    lcsMatrix[i][j]
                            = lcsMatrix[i - 1][j] > lcsMatrix[i][j - 1] ? lcsMatrix[i - 1][j] : lcsMatrix[i][j - 1];
                }
            }
        }
        return lcsString(str1, str2, lcsMatrix);
    }

    public static String lcsString(String str1, String str2, int[][] lcsMatrix) {
        StringBuilder lcs = new StringBuilder();
        int i = str1.length(), j = str2.length();
        while (i > 0 && j > 0) {
            if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                lcs.append(str1.charAt(i - 1));
                i--;
                j--;
            } else if (lcsMatrix[i - 1][j] > lcsMatrix[i][j - 1]) {
                i--;
            } else {
                j--;
            }
        }
        return lcs.reverse().toString();
    }

    public static void main(String[] args) {
        String str1 = "DSGSHSRGSRHTRD";
        String str2 = "DATRGAGTSHS";
        String lcs = getLCS(str1, str2);

                if (lcs != null) {
            System.out.println("String 1: " + str1);
            System.out.println("String 2: " + str2);
            System.out.println("LCS: " + lcs);
            System.out.println("LCS length: " + lcs.length());
        }
    }
}
package com.thealgorithms.dynamicprogramming;

public class SubsetSum {

    
    public static void main(String[] args) {
        int[] arr = new int[]{50, 4, 10, 15, 34};
        assert subsetSum(arr, 64);
        assert subsetSum(arr, 99);
        assert !subsetSum(arr, 5);
        assert !subsetSum(arr, 66);
    }

    
    private static boolean subsetSum(int[] arr, int sum) {
        int n = arr.length;
        boolean[][] isSum = new boolean[n + 2][sum + 1];

        isSum[n + 1][0] = true;
        for (int i = 1; i <= sum; i++) {
            isSum[n + 1][i] = false;
        }

        for (int i = n; i > 0; i--) {
            isSum[i][0] = true;
            for (int j = 1; j <= arr[i - 1] - 1; j++) {
                if (j <= sum) {
                    isSum[i][j] = isSum[i + 1][j];
                }
            }
            for (int j = arr[i - 1]; j <= sum; j++) {
                isSum[i][j] = (isSum[i + 1][j] || isSum[i + 1][j - arr[i - 1]]);
            }
        }

        return isSum[1][sum];
    }
}
package com.thealgorithms.dynamicprogramming;

public class Sum_Of_Subset {

    public static void main(String[] args) {

        int[] arr = {7, 3, 2, 5, 8};
        int Key = 14;

        if (subsetSum(arr, arr.length - 1, Key)) {
            System.out.print("Yes, that sum exists");
        } else {
            System.out.print("Nope, that number does not exist");
        }
    }

    public static boolean subsetSum(int[] arr, int num, int Key) {
        if (Key == 0) {
            return true;
        }
        if (num < 0 || Key < 0) {
            return false;
        }

        boolean include = subsetSum(arr, num - 1, Key - arr[num]);
        boolean exclude = subsetSum(arr, num - 1, Key);

        return include || exclude;
    }
}
package com.thealgorithms.dynamicprogramming;

public class MinimumPathSum {

    public void testRegular() {
        int[][] grid = {
            {1, 3, 1},
            {1, 5, 1},
            {4, 2, 1}
        };
        System.out.println(minimumPathSum(grid));
    }

    public void testLessColumns() {
        int[][] grid = {
            {1, 2},
            {5, 6},
            {1, 1}
        };
        System.out.println(minimumPathSum(grid));
    }

    public void testLessRows() {
        int[][] grid = {
            {2, 3, 3},
            {7, 2, 1}
        };
        System.out.println(minimumPathSum(grid));
    }

    public void testOneRowOneColumn() {
        int[][] grid = {{2}};
        System.out.println(minimumPathSum(grid));
    }

    public static int minimumPathSum(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        if (n == 0) {
            return 0;
        }
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        for (int i = 0; i < n - 1; i++) {
            dp[0][i + 1] = dp[0][i] + grid[0][i + 1];
        }
        for (int i = 0; i < m - 1; i++) {
            dp[i + 1][0] = dp[i][0] + grid[i + 1][0];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[m - 1][n - 1];
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.Scanner;


public class LongestIncreasingSubsequence {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        System.out.println(LIS(arr));
        System.out.println(findLISLen(arr));
        sc.close();
    }

    private static int upperBound(int[] ar, int l, int r, int key) {
        while (l < r - 1) {
            int m = (l + r) >>> 1;
            if (ar[m] >= key) {
                r = m;
            } else {
                l = m;
            }
        }

        return r;
    }

    private static int LIS(int[] array) {
        int N = array.length;
        if (N == 0) {
            return 0;
        }

        int[] tail = new int[N];

                int length = 1;

        tail[0] = array[0];
        for (int i = 1; i < N; i++) {

                        if (array[i] < tail[0]) {
                tail[0] = array[i];
            }             else if (array[i] > tail[length - 1]) {
                tail[length++] = array[i];
            }                                                             else {
                tail[upperBound(tail, -1, length - 1, array[i])] = array[i];
            }
        }

        return length;
    }

    
        public static int findLISLen(int a[]) {
        int size = a.length;
        int arr[] = new int[size];
        arr[0] = a[0];
        int lis = 1;
        for (int i = 1; i < size; i++) {
            int index = binarySearchBetween(arr, lis, a[i]);
            arr[index] = a[i];
            if (index > lis) {
                lis++;
            }
        }
        return lis;
    }
    
    private static int binarySearchBetween(int[] t, int end, int key) {
        int left = 0;
        int right = end;
        if (key < t[0]) {
            return 0;
        }
        if (key > t[end]) {
            return end + 1;
        }
        while (left < right - 1) {
            int middle = (left + right) / 2;
            if (t[middle] < key) {
                left = middle;
            } else {
                right = middle;
            }
        }
        return right;
    }
}
package com.thealgorithms.dynamicprogramming;

import java.util.Scanner;


public class LongestValidParentheses {

    public static int getLongestValidParentheses(String s) {
        if (s == null || s.length() < 2) {
            return 0;
        }
        char[] chars = s.toCharArray();
        int n = chars.length;
        int[] res = new int[n];
        res[0] = 0;
        res[1] = chars[1] == ')' && chars[0] == '(' ? 2 : 0;

        int max = res[1];

        for (int i = 2; i < n; ++i) {
            if (chars[i] == ')') {
                if (chars[i - 1] == '(') {
                    res[i] = res[i - 2] + 2;
                } else {
                    int index = i - res[i - 1] - 1;
                    if (index >= 0 && chars[index] == '(') {
                                                res[i] = res[i - 1] + 2 + (index - 1 >= 0 ? res[index - 1] : 0);
                    }
                }
            }
            max = Math.max(max, res[i]);
        }

        return max;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        while (true) {
            String str = sc.nextLine();
            if ("quit".equals(str)) {
                break;
            }

            System.out.println("Len is: " + getLongestValidParentheses(str));
        }

        sc.close();
    }
}



 package com.thealgorithms.dynamicprogramming;

public class KadaneAlgorithm {
    public static boolean max_Sum(int a[] , int predicted_answer)
    {
        int sum=a[0],running_sum=0;
        for(int k:a)
        {
            running_sum=running_sum+k;
                        sum=Math.max(sum,running_sum);
                        if(running_sum<0)
            running_sum=0;
                    }
                return sum==predicted_answer;
                    }
    
}package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.less;
import static com.thealgorithms.sorts.SortUtils.print;

class InsertionSort implements SortAlgorithm {

    
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        for (int i = 1; i < array.length; i++) {
            T insertValue = array[i];
            int j;
            for (j = i - 1; j >= 0 && less(insertValue, array[j]); j--) {
                array[j + 1] = array[j];
            }
            if (j != i - 1) {
                array[j + 1] = insertValue;
            }
        }
        return array;
    }

    
    public static void main(String[] args) {
        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        InsertionSort sort = new InsertionSort();
        sort.sort(integers);
        print(integers);

        String[] strings = {"c", "a", "e", "b", "d"};
        sort.sort(strings);
        print(strings);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;


public class SwapSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        int LENGTH = array.length;
        int index = 0;

        while (index < LENGTH - 1) {
            int amountSmallerElements = this.getSmallerElementCount(array, index);

            if (amountSmallerElements > 0 && index != amountSmallerElements) {
                T element = array[index];
                array[index] = array[amountSmallerElements];
                array[amountSmallerElements] = element;
            } else {
                index++;
            }
        }

        return array;
    }

    private <T extends Comparable<T>> int getSmallerElementCount(T[] array, int index) {
        int counter = 0;
        for (int i = 0; i < array.length; i++) {
            if (less(array[i], array[index])) {
                counter++;
            }
        }

        return counter;
    }

    public static void main(String[] args) {
                Integer[] a = {3, 7, 45, 1, 33, 5, 2, 9};
        System.out.print("unsorted: ");
        print(a);
        System.out.println();

        new SwapSort().sort(a);
        System.out.print("sorted: ");
        print(a);
        System.out.println();

                String[] b = {"banana", "berry", "orange", "grape", "peach", "cherry", "apple", "pineapple"};
        System.out.print("unsorted: ");
        print(b);
        System.out.println();

        new SwapSort().sort(b);
        System.out.print("sorted: ");
        print(b);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

public class CircleSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        int n = array.length;
        while (doSort(array, 0, n - 1));
        return array;
    }

    private <T extends Comparable<T>> Boolean doSort(T[] array, int left, int right) {
        Boolean swapped = false;

        if (left == right) {
            return false;
        }

        int low = left;
        int high = right;

        while (low < high) {
            if (array[low].compareTo(array[high]) > 0) {
                swap(array, low, high);
                swapped = true;
            }
            low++;
            high--;
        }

        if (low == high && array[low].compareTo(array[high + 1]) > 0) {
            swap(array, low, high + 1);
            swapped = true;
        }

        int mid = left + (right - left) / 2;
        Boolean leftHalf = doSort(array, left, mid);
        Boolean rightHalf = doSort(array, mid + 1, right);

        return swapped || leftHalf || rightHalf;
    }

    public static void main(String[] args) {
        CircleSort CSort = new CircleSort();

        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        CSort.sort(arr);
        for (int i = 0; i < arr.length - 1; ++i) {
            assert arr[i] <= arr[i + 1];
        }

        String[] stringArray = {"c", "a", "e", "b", "d"};
        CSort.sort(stringArray);
        for (int i = 0; i < stringArray.length - 1; ++i) {
            assert arr[i].compareTo(arr[i + 1]) <= 0;
        }
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;

import static com.thealgorithms.maths.Ceil.ceil;
import static com.thealgorithms.maths.Floor.floor;
import static com.thealgorithms.searches.QuickSelect.select;


public class WiggleSort implements SortAlgorithm {
    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        return wiggleSort(unsorted);
    }

    private int mapIndex(int index, int n) {
        return ((2 * index + 1) % (n | 1));
    }

    
    private <T extends Comparable<T>> void triColorSort(T[] sortThis, T median) {
        int n = sortThis.length;
        int i = 0;
        int j = 0;
        int k = n - 1;
        while (j <= k) {
            if (0 < sortThis[mapIndex(j, n)].compareTo(median)) {
                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(i, n));
                i++;
                j++;
            } else if (0 > sortThis[mapIndex(j, n)].compareTo(median)) {
                SortUtils.swap(sortThis, mapIndex(j, n), mapIndex(k, n));
                k--;
            } else {
                j++;
            }
        }
    }

    private <T extends Comparable<T>> T[] wiggleSort(T[] sortThis) {
                T median;

        median = select(Arrays.<T>asList(sortThis), (int) floor(sortThis.length / 2.0));

        int numMedians = 0;

        for (T sortThi : sortThis) {
            if (0 == sortThi.compareTo(median)) {
                numMedians++;
            }
        }
                        if (sortThis.length % 2 == 1 && numMedians == ceil(sortThis.length / 2.0)) {
            T smallestValue = select(Arrays.asList(sortThis), 0);
            if (!(0 == smallestValue.compareTo(median))) {
                throw new IllegalArgumentException("For odd Arrays if the median appears ceil(n/2) times, " +
                        "the median has to be the smallest values in the array.");
            }
        }
        if (numMedians > ceil(sortThis.length / 2.0)) {
            throw new IllegalArgumentException("No more than half the number of values may be the same.");

        }

        triColorSort(sortThis, median);
        return sortThis;
    }
}package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


public class HeapSort implements SortAlgorithm {

    private static class Heap<T extends Comparable<T>> {

        
        private T[] heap;

        
        public Heap(T[] heap) {
            this.heap = heap;
        }

        
        private void heapSubtree(int rootIndex, int lastChild) {
            int leftIndex = rootIndex * 2 + 1;
            int rightIndex = rootIndex * 2 + 2;
            T root = heap[rootIndex];
            if (rightIndex <= lastChild) {                 T left = heap[leftIndex];
                T right = heap[rightIndex];
                if (less(left, right) && less(left, root)) {
                    swap(heap, leftIndex, rootIndex);
                    heapSubtree(leftIndex, lastChild);
                } else if (less(right, root)) {
                    swap(heap, rightIndex, rootIndex);
                    heapSubtree(rightIndex, lastChild);
                }
            } else if (leftIndex <= lastChild) {                 T left = heap[leftIndex];
                if (less(left, root)) {
                    swap(heap, leftIndex, rootIndex);
                    heapSubtree(leftIndex, lastChild);
                }
            }
        }

        
        private void makeMinHeap(int root) {
            int leftIndex = root * 2 + 1;
            int rightIndex = root * 2 + 2;
            boolean hasLeftChild = leftIndex < heap.length;
            boolean hasRightChild = rightIndex < heap.length;
            if (hasRightChild) {                 makeMinHeap(leftIndex);
                makeMinHeap(rightIndex);
                heapSubtree(root, heap.length - 1);
            } else if (hasLeftChild) {
                heapSubtree(root, heap.length - 1);
            }
        }

        
        private T getRoot(int size) {
            swap(heap, 0, size);
            heapSubtree(0, size - 1);
            return heap[size];         }
    }

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        return sort(Arrays.asList(unsorted)).toArray(unsorted);
    }

    @Override
    public <T extends Comparable<T>> List<T> sort(List<T> unsorted) {
        int size = unsorted.size();

        @SuppressWarnings("unchecked")
        Heap<T> heap = new Heap<>(unsorted.toArray((T[]) new Comparable[unsorted.size()]));

        heap.makeMinHeap(0);         List<T> sorted = new ArrayList<>(size);
        while (size > 0) {
            T min = heap.getRoot(--size);
            sorted.add(min);
        }

        return sorted;
    }

    
    public static void main(String[] args) {
        Integer[] heap = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        HeapSort heapSort = new HeapSort();
        print(heapSort.sort(heap));
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

public class ShellSort implements SortAlgorithm {

    
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        int length = array.length;
        int gap = 1;

        while (gap < length / 3) {
            gap = 3 * gap + 1;
        }

        for (; gap > 0; gap /= 3) {
            for (int i = gap; i < length; i++) {
                int j;
                T temp = array[i];
                for (j = i; j >= gap && less(temp, array[j - gap]); j -= gap) {
                    array[j] = array[j - gap];
                }
                array[j] = temp;
            }
        }
        return array;
    }

    public static void main(String[] args) {
        Integer[] toSort = {4, 23, 6, 78, 1, 54, 231, 9, 12};

        ShellSort sort = new ShellSort();
        sort.sort(toSort);
        for (int i = 0; i < toSort.length - 1; ++i) {
            assert toSort[i] <= toSort[i + 1];
        }
        print(toSort);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.less;
import static com.thealgorithms.sorts.SortUtils.print;


class CycleSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] arr) {
        int n = arr.length;

                for (int j = 0; j <= n - 2; j++) {
                        T item = arr[j];

                        int pos = j;
            for (int i = j + 1; i < n; i++) {
                if (less(arr[i], item)) {
                    pos++;
                }
            }

                        if (pos == j) {
                continue;
            }

                        while (item.compareTo(arr[pos]) == 0) {
                pos += 1;
            }

                        if (pos != j) {
                item = replace(arr, pos, item);
            }

                        while (pos != j) {
                pos = j;

                                for (int i = j + 1; i < n; i++) {
                    if (less(arr[i], item)) {
                        pos += 1;
                    }
                }

                                while (item.compareTo(arr[pos]) == 0) {
                    pos += 1;
                }

                                if (item != arr[pos]) {
                    item = replace(arr, pos, item);
                }
            }
        }

        return arr;
    }

    private <T extends Comparable<T>> T replace(T[] arr, int pos, T item) {
        T temp = item;
        item = arr[pos];
        arr[pos] = temp;
        return item;
    }

    public static void main(String[] args) {
        Integer arr[] = {4, 23, 6, 78, 1, 26, 11, 23, 0, -6, 3, 54, 231, 9, 12};
        CycleSort cycleSort = new CycleSort();
        cycleSort.sort(arr);

        System.out.println("After sort : ");
        print(arr);
    }
}
package com.thealgorithms.sorts;

import java.util.Random;


public class BogoSort implements SortAlgorithm {

    private static final Random random = new Random();

    private static <T extends Comparable<T>> boolean isSorted(T[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            if (SortUtils.less(array[i + 1], array[i])) {
                return false;
            }
        }
        return true;
    }

        private static <T> void nextPermutation(T[] array) {
        int length = array.length;

        for (int i = 0; i < array.length; i++) {
            int randomIndex = i + random.nextInt(length - i);
            SortUtils.swap(array, randomIndex, i);
        }
    }

    public <T extends Comparable<T>> T[] sort(T[] array) {
        while (!isSorted(array)) {
            nextPermutation(array);
        }
        return array;
    }

        public static void main(String[] args) {
                Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};

        BogoSort bogoSort = new BogoSort();

                SortUtils.print(bogoSort.sort(integers));

                String[] strings = {"c", "a", "e", "b", "d"};

        SortUtils.print(bogoSort.sort(strings));
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;


class QuickSort implements SortAlgorithm {

    
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        doSort(array, 0, array.length - 1);
        return array;
    }

    
    private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {
        if (left < right) {
            int pivot = randomPartition(array, left, right);
            doSort(array, left, pivot - 1);
            doSort(array, pivot, right);
        }
    }

    
    private static <T extends Comparable<T>> int randomPartition(T[] array, int left, int right) {
        int randomIndex = left + (int) (Math.random() * (right - left + 1));
        swap(array, randomIndex, right);
        return partition(array, left, right);
    }

    
    private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {
        int mid = (left + right) >>> 1;
        T pivot = array[mid];

        while (left <= right) {
            while (less(array[left], pivot)) {
                ++left;
            }
            while (less(pivot, array[right])) {
                --right;
            }
            if (left <= right) {
                swap(array, left, right);
                ++left;
                --right;
            }
        }
        return left;
    }

        public static void main(String[] args) {

                Integer[] array = {3, 4, 1, 32, 0, 1, 5, 12, 2, 5, 7, 8, 9, 2, 44, 111, 5};

        QuickSort quickSort = new QuickSort();
        quickSort.sort(array);

                print(array);

        String[] stringArray = {"c", "a", "e", "b", "d"};
        quickSort.sort(stringArray);

                print(stringArray);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.print;
import com.thealgorithms.datastructures.trees.BSTRecursiveGeneric;

import java.util.List;


public class TreeSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {
        return doTreeSortArray(unsortedArray);
    }

    @Override
    public <T extends Comparable<T>> List<T> sort(List<T> unsortedList) {
        return doTreeSortList(unsortedList);
    }

    private <T extends Comparable<T>> T[] doTreeSortArray(T[] unsortedArray) {
                BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();

                for (T element : unsortedArray) {
            tree.add(element);
        }

                List<T> sortedList = tree.inorderSort();

                int i = 0;
        for (T element : sortedList) {
            unsortedArray[i++] = element;
        }

                return unsortedArray;
    }

    private <T extends Comparable<T>> List<T> doTreeSortList(List<T> unsortedList) {
                BSTRecursiveGeneric<T> tree = new BSTRecursiveGeneric<T>();

                for (T element : unsortedList) {
            tree.add(element);
        }

                return tree.inorderSort();
    }

    public static void main(String[] args) {
        TreeSort treeSort = new TreeSort();

                System.out.println("Testing for Integer Array....");
        Integer[] a = {3, -7, 45, 1, 343, -5, 2, 9};
        System.out.print(String.format("%-10s", "unsorted: "));
        print(a);
        a = treeSort.sort(a);
        System.out.print(String.format("%-10s", "sorted: "));
        print(a);
        System.out.println();

                System.out.println("Testing for Integer List....");
        List<Integer> intList = List.of(3, -7, 45, 1, 343, -5, 2, 9);
        System.out.print(String.format("%-10s", "unsorted: "));
        print(intList);
        intList = treeSort.sort(intList);
        System.out.print(String.format("%-10s", "sorted: "));
        print(intList);
        System.out.println();

                System.out.println("Testing for String Array....");
        String[] b = {"banana", "berry", "orange", "grape", "peach", "cherry", "apple", "pineapple"};
        System.out.print(String.format("%-10s", "unsorted: "));
        print(b);
        b = treeSort.sort(b);
        System.out.print(String.format("%-10s", "sorted: "));
        print(b);
        System.out.println();

                System.out.println("Testing for String List....");
        List<String> stringList = List.of("banana", "berry", "orange", "grape", "peach", "cherry", "apple", "pineapple");
        System.out.print(String.format("%-10s", "unsorted: "));
        print(stringList);
        stringList = treeSort.sort(stringList);
        System.out.print(String.format("%-10s", "sorted: "));
        print(stringList);

    }

}
package com.thealgorithms.sorts;

import java.util.Random;


class TimSort {

    int array[];
    int array_length;
    int RUN = 32;

    
    public TimSort(int[] array) {
        this.array = array;
        this.array_length = array.length;
    }

    
    public TimSort(int array_length) {
        Random rand = new Random();

        this.array_length = array_length;
        this.array = new int[this.array_length];

        for (int i = 0; i < this.array_length; i++) {
            int random_number = rand.nextInt(1000);
            this.array[i] = random_number;
        }
    }

    
    public void change_run(int run) {
        this.RUN = run;
    }

    
    public TimSort() {
        this.array_length = 100;
        this.array = new int[this.array_length];

        Random rand = new Random();
        for (int i = 0; i < this.array_length; i++) {
            int random_number = rand.nextInt(1000);
            this.array[i] = random_number;
        }
    }

    
    public void insertion_sort(int[] array, int start_idx, int end_idx) {
        for (int i = start_idx; i <= end_idx; i++) {
            int current_element = array[i];
            int j = i - 1;
            while (j >= start_idx && array[j] > current_element) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = current_element;
        }
    }

    
    public void merge_runs(int array[], int start, int mid, int end) {

        int first_array_size = mid - start + 1, second_array_size = end - mid;
        int array1[] = new int[first_array_size], array2[] = new int[second_array_size];
        int i = 0, j = 0, k = 0;

                for (i = 0; i < first_array_size; i++) {
            array1[i] = array[start + i];
        }
        for (i = 0; i < second_array_size; i++) {
            array2[i] = array[mid + 1 + i];
        }

        i = 0;
        j = 0;
        k = start;

        while (i < first_array_size && j < second_array_size) {
            if (array1[i] <= array2[j]) {
                array[k] = array1[i];
                i++;
            } else {
                array[k] = array2[j];
                j++;
            }
            k++;
        }

        while (i < first_array_size) {
            array[k] = array1[i];
            k++;
            i++;
        }

        while (j < second_array_size) {
            array[k] = array2[j];
            k++;
            j++;
        }
    }

    
    public void algorithm() {
                System.out.println("Before sorting the array: ");
        this.showArrayElements();
        System.out.println();

                for (int i = 0; i < this.array_length; i += this.RUN) {
            this.insertion_sort(this.array, i, Math.min(i + this.RUN, (this.array_length - 1)));
        }

        for (int split = this.RUN; split < this.array_length; split = 2 * split) {
            for (int start_idx = 0; start_idx < this.array_length; start_idx += 2 * split) {
                int mid = start_idx + split - 1;
                int end_idx = Math.min((start_idx + 2 * split - 1), (this.array_length - 1));

                this.merge_runs(this.array, start_idx, mid, end_idx);
            }
        }
                System.out.println("After sorting the array: ");
        this.showArrayElements();
        System.out.println();
    }

    
    public void showArrayElements() {
        for (int i = 0; i < this.array.length; i++) {
            System.out.print(this.array[i] + " ");
        }
        System.out.println();
    }

    
    static void test() {
        int[] array = {4, 1, 3, 17, 12, 11, 8};
        TimSort sorterObj1 = new TimSort();
        TimSort sorterObj2 = new TimSort(50);
        TimSort sorterObj3 = new TimSort(array);

        sorterObj1.algorithm();
        sorterObj2.algorithm();
        sorterObj3.algorithm();

                for (int i = 0; i < sorterObj1.array_length - 1; i++) {
            assert ((sorterObj1.array[i] <= sorterObj1.array[i + 1])) : "Array is not sorted";
        }

                for (int i = 0; i < sorterObj2.array_length - 1; i++) {
            assert ((sorterObj2.array[i] <= sorterObj2.array[i + 1])) : "Array is not sorted";
        }

                for (int i = 0; i < sorterObj3.array_length - 1; i++) {
            assert ((sorterObj3.array[i] <= sorterObj3.array[i + 1])) : "Array is not sorted";
        }
    }

    public static void main(String[] args) {
        test();
    }
}
package com.thealgorithms.sorts;

import java.util.*;
import static com.thealgorithms.sorts.SortUtils.*;

public class PigeonholeSort {

    void sort(Integer[] array){
        int maxElement = array[0];
        for (int element: array) {
            if (element > maxElement) maxElement = element;
        }

        int numOfPigeonholes = 1 + maxElement;
        ArrayList<Integer>[] pigeonHole =  new ArrayList[numOfPigeonholes];

        for (int k=0; k<numOfPigeonholes; k++) {
            pigeonHole[k] = new ArrayList<>();
        }

        for (int t: array) {
            pigeonHole[t].add(t);
        }

        int k=0;
        for (ArrayList<Integer> ph: pigeonHole) {
            for (int elements: ph) {
                array[k]=elements;
                k=k+1;
            }
        }
    }

    public static void main(String[] args)
    {
        PigeonholeSort pigeonholeSort = new PigeonholeSort();
        Integer[] arr = { 8, 3, 2, 7, 4, 6, 8 };

        System.out.print("Unsorted order is : ");
        print(arr);

        pigeonholeSort.sort(arr);
        
        System.out.print("Sorted order is : ");
        for (int i = 0; i < arr.length; i++) {
            assert (arr[i]) <= (arr[i+1]);
        }
        print(arr);
    }
}
package com.thealgorithms.sorts;


public class StoogeSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {
        sort(unsortedArray, 0, unsortedArray.length);
        return unsortedArray;
    }

    public <T extends Comparable<T>> T[] sort(T[] unsortedArray, int start, int end) {
        if (SortUtils.less(unsortedArray[end - 1], unsortedArray[start])) {
            T temp = unsortedArray[start];
            unsortedArray[start] = unsortedArray[end - 1];
            unsortedArray[end - 1] = temp;
        }

        int len = end - start;
        if (len > 2) {
            int third = len / 3;
            sort(unsortedArray, start, end - third);
            sort(unsortedArray, start + third, end);
            sort(unsortedArray, start, end - third);
        }
        return unsortedArray;
    }

    public static void main(String[] args) {
        StoogeSort stoogeSort = new StoogeSort();

        Integer[] integerArray = {8, 84, 53, 953, 64, 2, 202};
                SortUtils.print(integerArray);

        stoogeSort.sort(integerArray);
                SortUtils.print(integerArray);

        String[] stringArray = {"g", "d", "a", "b", "f", "c", "e"};
                SortUtils.print(stringArray);

        stoogeSort.sort(stringArray);
                SortUtils.print(stringArray);
    }
}
package com.thealgorithms.sorts;

import java.util.Random;


public class BubbleSortRecursion implements SortAlgorithm {

    public static void main(String[] args) {
        Integer[] array = new Integer[10];

        Random random = new Random();
        for (int i = 0; i < array.length; ++i) {
            array[i] = random.nextInt(100) - 50;
        }

        BubbleSortRecursion bubbleSortRecursion = new BubbleSortRecursion();
        bubbleSortRecursion.sort(array);

        for (int i = 0; i < array.length - 1; ++i) {
            assert (array[i].compareTo(array[i + 1]) <= 0);
        }
    }

    
    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        bubbleSort(unsorted, unsorted.length);
        return unsorted;
    }

    
    private static <T extends Comparable<T>> void bubbleSort(T[] unsorted, int len) {
        boolean swapped = false;
        for (int i = 0; i < len - 1; ++i) {
            if (SortUtils.greater(unsorted[i], unsorted[i + 1])) {
                SortUtils.swap(unsorted, i, i + 1);
                swapped = true;
            }
        }
        if (swapped) {
            bubbleSort(unsorted, len - 1);
        }
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;

class RadixSort {

    private static int getMax(int[] arr, int n) {
        int mx = arr[0];
        for (int i = 1; i < n; i++) {
            if (arr[i] > mx) {
                mx = arr[i];
            }
        }
        return mx;
    }

    private static void countSort(int[] arr, int n, int exp) {
        int[] output = new int[n];
        int i;
        int[] count = new int[10];
        Arrays.fill(count, 0);

        for (i = 0; i < n; i++) {
            count[(arr[i] / exp) % 10]++;
        }

        for (i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }

        for (i = n - 1; i >= 0; i--) {
            output[count[(arr[i] / exp) % 10] - 1] = arr[i];
            count[(arr[i] / exp) % 10]--;
        }

        for (i = 0; i < n; i++) {
            arr[i] = output[i];
        }
    }

    private static void radixsort(int[] arr, int n) {

        int m = getMax(arr, n);

        for (int exp = 1; m / exp > 0; exp *= 10) {
            countSort(arr, n, exp);
        }
    }

    static void print(int[] arr, int n) {
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }
    }

    public static void main(String[] args) {
        int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};
        int n = arr.length;
        radixsort(arr, n);
        print(arr, n);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;


class CombSort implements SortAlgorithm {

        private int nextGap(int gap) {
                gap = (gap * 10) / 13;
        return (gap < 1) ? 1 : gap;
    }

    
    @Override
    public <T extends Comparable<T>> T[] sort(T[] arr) {
        int size = arr.length;

                int gap = size;

                boolean swapped = true;

                while (gap != 1 || swapped) {
                        gap = nextGap(gap);

                        swapped = false;

                        for (int i = 0; i < size - gap; i++) {
                if (less(arr[i + gap], arr[i])) {
                                        swapped = swap(arr, i, i + gap);
                }
            }
        }
        return arr;
    }

        public static void main(String[] args) {
        CombSort ob = new CombSort();
        Integer[] arr = {8, 4, 1, 56, 3, -44, -1, 0, 36, 34, 8, 12, -66, -78, 23, -6, 28, 0};
        ob.sort(arr);

        System.out.println("sorted array");
        print(arr);
    }
}
package com.thealgorithms.sorts;


class CocktailShakerSort implements SortAlgorithm {

    
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {

        int length = array.length;
        int left = 0;
        int right = length - 1;
        int swappedLeft, swappedRight;
        while (left < right) {
                        swappedRight = 0;
            for (int i = left; i < right; i++) {
                if (SortUtils.less(array[i + 1], array[i])) {
                    SortUtils.swap(array, i, i + 1);
                    swappedRight = i;
                }
            }
                        right = swappedRight;
            swappedLeft = length - 1;
            for (int j = right; j > left; j--) {
                if (SortUtils.less(array[j], array[j - 1])) {
                    SortUtils.swap(array, j - 1, j);
                    swappedLeft = j;
                }
            }
            left = swappedLeft;
        }
        return array;
    }

        public static void main(String[] args) {
                Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        CocktailShakerSort shakerSort = new CocktailShakerSort();

                SortUtils.print(shakerSort.sort(integers));

                String[] strings = {"c", "a", "e", "b", "d"};
        SortUtils.print(shakerSort.sort(strings));
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;
import java.util.*;

public class MergeSortNoExtraSpace {

    public static void call_merge_sort(int a[], int n) {
        int maxele = Arrays.stream(a).max().getAsInt() + 1;
        merge_sort(a, 0, n - 1, maxele);
    }

    public static void merge_sort(int a[], int start, int end, int maxele) { 
        if (start < end) {
            int mid = (start + end) / 2;
            merge_sort(a, start, mid, maxele);
            merge_sort(a, mid + 1, end, maxele);
            implement_merge_sort(a, start, mid, end, maxele);

        }
    }

    public static void implement_merge_sort(int a[], int start, int mid, int end, int maxele) {          int i = start;
        int j = mid + 1;
        int k = start;
        while (i <= mid && j <= end) {
            if (a[i] % maxele <= a[j] % maxele) {
                a[k] = a[k] + (a[i]
                        % maxele) * maxele;
                k++;
                i++;
            } else {
                a[k] = a[k] + (a[j]
                        % maxele) * maxele;
                k++;
                j++;
            }
        }
        while (i <= mid) {
            a[k] = a[k] + (a[i]
                    % maxele) * maxele;
            k++;
            i++;
        }
        while (j <= end) {
            a[k] = a[k] + (a[j]
                    % maxele) * maxele;
            k++;
            j++;
        }
        for (i = start; i <= end; i++) {
            a[i] = a[i] / maxele;
        }

    }

    public static void main(String args[]) {
        Scanner inp = new Scanner(System.in);
        System.out.println("Enter array size");
        int n = inp.nextInt();
        int a[] = new int[n];
        System.out.println("Enter array elements");
        for (int i = 0; i < n; i++) {
            a[i] = inp.nextInt();
        }
        call_merge_sort(a, n);
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
    }
}
package com.thealgorithms.sorts;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;


public class BucketSort {

    public static void main(String[] args) {
        int[] arr = new int[10];

        Random random = new Random();
        for (int i = 0; i < arr.length; ++i) {
            arr[i] = random.nextInt(100) - 50;
        }

        bucketSort(arr);

        for (int i = 0, limit = arr.length - 1; i < limit; ++i) {
            assert arr[i] <= arr[i + 1];
        }
    }

    
    private static void bucketSort(int[] arr) {
        int max = max(arr);

        int min = min(arr);

        int numberOfBuckets = max - min + 1;

        List<List<Integer>> buckets = new ArrayList<>(numberOfBuckets);

        for (int i = 0; i < numberOfBuckets; ++i) {
            buckets.add(new ArrayList<>());
        }

        for (int value : arr) {
            int hash = hash(value, min, numberOfBuckets);
            buckets.get(hash).add(value);
        }

        for (List<Integer> bucket : buckets) {
            Collections.sort(bucket);
        }

        int index = 0;
        for (List<Integer> bucket : buckets) {
            for (int value : bucket) {
                arr[index++] = value;
            }
        }
    }

    
    private static int hash(int elem, int min, int numberOfBucket) {
        return (elem - min) / numberOfBucket;
    }

    
    public static int max(int[] arr) {
        int max = arr[0];
        for (int value : arr) {
            if (value > max) {
                max = value;
            }
        }
        return max;
    }

    
    public static int min(int[] arr) {
        int min = arr[0];
        for (int value : arr) {
            if (value < min) {
                min = value;
            }
        }
        return min;
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

public class MergeSortRecursive {

    List<Integer> arr;

    public MergeSortRecursive(List<Integer> arr) {
        this.arr = arr;
    }

    public void mergeSort() {
        List<Integer> arrSorted = merge(arr);
        System.out.println(arrSorted);
    }

    private static List<Integer> merge(List<Integer> arr) {

                if (arr.size() <= 1) {
            return arr;
        }

        int arrLength = arr.size();
        int half = arrLength / 2;
        List<Integer> arrA = arr.subList(0, half);
        List<Integer> arrB = arr.subList(half, arr.size());

                arrA = merge(arrA);
        arrB = merge(arrB);

        return sort(arrA, arrB);
    }

    private static List<Integer> sort(List<Integer> unsortedA, List<Integer> unsortedB) {
        if (unsortedA.size() <= 0 && unsortedB.size() <= 0) {
            return new ArrayList<>();
        }
        if (unsortedA.size() <= 0) {
            return unsortedB;
        }
        if (unsortedB.size() <= 0) {
            return unsortedA;
        }
        if (unsortedA.get(0) <= unsortedB.get(0)) {
            List<Integer> newAl = new ArrayList<Integer>() {
                {
                    add(unsortedA.get(0));
                }
            };
            newAl.addAll(sort(unsortedA.subList(1, unsortedA.size()), unsortedB));
            return newAl;
        } else {
            List<Integer> newAl = new ArrayList<Integer>() {
                {
                    add(unsortedB.get(0));
                }
            };
            newAl.addAll(sort(unsortedA, unsortedB.subList(1, unsortedB.size())));
            return newAl;
        }
    }

}

class App {

    public static void main(String[] args) {
        MergeSortRecursive sort = new MergeSortRecursive(new ArrayList<>(Arrays.asList(4, 3, 1, 8, 5, 10, 0, 1, 4, 11, 8, 9)));
        sort.mergeSort();
    }
}
package com.thealgorithms.sorts;


public class SlowSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsortedArray) {
        sort(unsortedArray, 0, unsortedArray.length - 1);
        return unsortedArray;
    }

    private <T extends Comparable<T>> void sort(T[] array, int i, int j) {
        if (SortUtils.greaterOrEqual(i, j)) {
            return;
        }
        int m = (i + j) / 2;
        sort(array, i, m);
        sort(array, m + 1, j);
        if (SortUtils.less(array[j], array[m])) {
            T temp = array[j];
            array[j] = array[m];
            array[m] = temp;
        }
        sort(array, i, j - 1);
    }

    public static void main(String[] args) {
        SlowSort slowSort = new SlowSort();

        Integer[] integerArray = {8, 84, 53, 953, 64, 2, 202, 98};
                SortUtils.print(integerArray);

        slowSort.sort(integerArray);
                SortUtils.print(integerArray);

        String[] stringArray = {"g", "d", "a", "b", "f", "c", "e"};
                SortUtils.print(stringArray);

        slowSort.sort(stringArray);
                SortUtils.print(stringArray);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.print;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

import java.util.*;
import java.util.stream.IntStream;
import java.util.stream.Stream;


class CountingSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        return sort(Arrays.asList(unsorted)).toArray(unsorted);
    }

    
    @Override
    public <T extends Comparable<T>> List<T> sort(List<T> list) {

        Map<T, Integer> frequency = new TreeMap<>();
                List<T> sortedArray = new ArrayList<>(list.size());

                list.forEach(v -> frequency.put(v, frequency.getOrDefault(v, 0) + 1));

                for (Map.Entry<T, Integer> element : frequency.entrySet()) {
            for (int j = 0; j < element.getValue(); j++) {
                sortedArray.add(element.getKey());
            }
        }

        return sortedArray;
    }

    
    private static <T extends Comparable<T>> List<T> streamSort(List<T> list) {
        return list.stream()
                .collect(toMap(k -> k, v -> 1, (v1, v2) -> v1 + v2, TreeMap::new))
                .entrySet()
                .stream()
                .flatMap(entry -> IntStream.rangeClosed(1, entry.getValue()).mapToObj(t -> entry.getKey()))
                .collect(toList());
    }

        public static void main(String[] args) {
                List<Integer> unsortedInts
                = Stream.of(4, 23, 6, 78, 1, 54, 23, 1, 9, 231, 9, 12).collect(toList());
        CountingSort countingSort = new CountingSort();

        System.out.println("Before Sorting:");
        print(unsortedInts);

                System.out.println("After Sorting:");
        print(countingSort.sort(unsortedInts));
        System.out.println("After Sorting By Streams:");
        print(streamSort(unsortedInts));

        System.out.println("\n------------------------------\n");

                List<String> unsortedStrings
                = Stream.of("c", "a", "e", "b", "d", "a", "f", "g", "c").collect(toList());

        System.out.println("Before Sorting:");
        print(unsortedStrings);

                System.out.println("After Sorting:");
        print(countingSort.sort(unsortedStrings));

        System.out.println("After Sorting By Streams:");
        print(streamSort(unsortedStrings));
    }
}
package com.thealgorithms.sorts;


class MergeSort implements SortAlgorithm {

    
    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        doSort(unsorted, 0, unsorted.length - 1);
        return unsorted;
    }

    
    private static <T extends Comparable<T>> void doSort(T[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) >>> 1;
            doSort(arr, left, mid);
            doSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    
    private static <T extends Comparable<T>> void merge(T[] arr, int left, int mid, int right) {
        int length = right - left + 1;
        @SuppressWarnings("unchecked")
        T[] temp = (T[]) new Comparable[length];
        int i = left;
        int j = mid + 1;
        int k = 0;

        while (i <= mid && j <= right) {
            if (arr[i].compareTo(arr[j]) <= 0) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }

        while (i <= mid) {
            temp[k++] = arr[i++];
        }

        while (j <= right) {
            temp[k++] = arr[j++];
        }

        System.arraycopy(temp, 0, arr, left, length);
    }

    
    public static void main(String[] args) {
        MergeSort mergeSort = new MergeSort();

        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        mergeSort.sort(arr);
        for (int i = 0; i < arr.length - 1; ++i) {
            assert arr[i] <= arr[i + 1];
        }

        String[] stringArray = {"c", "a", "e", "b", "d"};
        mergeSort.sort(stringArray);
        for (int i = 0; i < stringArray.length - 1; ++i) {
            assert arr[i].compareTo(arr[i + 1]) <= 0;
        }
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;
import java.util.List;


public interface SortAlgorithm {

    
    <T extends Comparable<T>> T[] sort(T[] unsorted);

    
    @SuppressWarnings("unchecked")
    default <T extends Comparable<T>> List<T> sort(List<T> unsorted) {
        return Arrays.asList(sort(unsorted.toArray((T[]) new Comparable[unsorted.size()])));
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;


public class GnomeSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] arr) {
        int i = 1;
        int j = 2;
        while (i < arr.length) {
            if (less(arr[i - 1], arr[i])) {
                i = j++;
            } else {
                swap(arr, i - 1, i);
                if (--i == 0) {
                    i = j++;
                }
            }
        }

        return null;
    }

    public static void main(String[] args) {
        Integer[] integers = {4, 23, 6, 78, 1, 26, 11, 23, 0, -6, 3, 54, 231, 9, 12};
        String[] strings = {"c", "a", "e", "b", "d", "dd", "da", "zz", "AA", "aa", "aB", "Hb", "Z"};
        GnomeSort gnomeSort = new GnomeSort();

        gnomeSort.sort(integers);
        gnomeSort.sort(strings);

        System.out.println("After sort : ");
        print(integers);
        print(strings);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;


public class PancakeSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        int size = array.length;

        for (int i = 0; i < size; i++) {
            T max = array[0];
            int index = 0;
            for (int j = 0; j < size - i; j++) {
                if (less(max, array[j])) {
                    max = array[j];
                    index = j;
                }
            }
            flip(array, index, array.length - 1 - i);
        }
        return array;
    }

    public static void main(String[] args) {

        Integer[] arr = {
            10, 9, 8, 7, 6, 15, 14, 7, 4, 3, 8, 6, 3, 1, 2, -2, -5, -8, -3, -1, 13, 12, 11, 5, 4, 3, 2, 1
        };
        PancakeSort pancakeSort = new PancakeSort();
        System.out.println("After sorting:");
        pancakeSort.sort(arr);
        print(arr);
    }
}
package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;

public class SimpleSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        final int LENGTH = array.length;

        for (int i = 0; i < LENGTH; i++) {
            for (int j = i + 1; j < LENGTH; j++) {
                if (less(array[j], array[i])) {
                    T element = array[j];
                    array[j] = array[i];
                    array[i] = element;
                }
            }
        }

        return array;
    }

    public static void main(String[] args) {
                Integer[] a = {3, 7, 45, 1, 33, 5, 2, 9};
        System.out.print("unsorted: ");
        print(a);
        System.out.println();

        new SimpleSort().sort(a);
        System.out.print("sorted: ");
        print(a);
        System.out.println();

                String[] b = {"banana", "berry", "orange", "grape", "peach", "cherry", "apple", "pineapple"};
        System.out.print("unsorted: ");
        print(b);
        System.out.println();

        new SimpleSort().sort(b);
        System.out.print("sorted: ");
        print(b);
    }
}
package com.thealgorithms.sorts;

import java.util.Arrays;
import java.util.List;


final class SortUtils {

    
    static <T> boolean swap(T[] array, int idx, int idy) {
        T swap = array[idx];
        array[idx] = array[idy];
        array[idy] = swap;
        return true;
    }

    
    static <T extends Comparable<T>> boolean less(T v, T w) {
        return v.compareTo(w) < 0;
    }

    
    static <T extends Comparable<T>> boolean greater(T v, T w) {
        return v.compareTo(w) > 0;
    }

    
    static <T extends Comparable<T>> boolean greaterOrEqual(T v, T w) {
        return v.compareTo(w) >= 0;
    }

    
    static void print(List<?> toPrint) {
        toPrint.stream().map(Object::toString).map(str -> str + " ").forEach(System.out::print);

        System.out.println();
    }

    
    static void print(Object[] toPrint) {
        System.out.println(Arrays.toString(toPrint));
    }

    
    static <T extends Comparable<T>> void flip(T[] array, int left, int right) {
        while (left <= right) {
            swap(array, left++, right--);
        }
    }
}
package com.thealgorithms.sorts;

public class DNFSort {

            static void sort012(int a[], int arr_size) {
        int low = 0;
        int high = arr_size - 1;
        int mid = 0, temp = 0;
        while (mid <= high) {
            switch (a[mid]) {
                case 0: {
                    temp = a[low];
                    a[low] = a[mid];
                    a[mid] = temp;
                    low++;
                    mid++;
                    break;
                }
                case 1:
                    mid++;
                    break;
                case 2: {
                    temp = a[mid];
                    a[mid] = a[high];
                    a[high] = temp;
                    high--;
                    break;
                }
            }
        }
    }

    static void printArray(int arr[], int arr_size) {
        for (int i = 0; i < arr_size; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println("");
    }

    public static void main(String[] args) {
        int arr[] = {0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1};
        int arr_size = arr.length;
        sort012(arr, arr_size);
        System.out.println("Array after seggregation ");
        printArray(arr, arr_size);
    }
}
package com.thealgorithms.sorts;

public class BitonicSort {

    void compAndSwap(int a[], int i, int j, int dir) {
        if ((a[i] > a[j] && dir == 1) || (a[i] < a[j] && dir == 0)) {
                        int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
    }


    void bitonicMerge(int a[], int low, int cnt, int dir) {
        if (cnt > 1) {
            int k = cnt / 2;
            for (int i = low; i < low + k; i++) {
                compAndSwap(a, i, i + k, dir);
            }
            bitonicMerge(a, low, k, dir);
            bitonicMerge(a, low + k, k, dir);
        }
    }


    void bitonicSort(int a[], int low, int cnt, int dir) {
        if (cnt > 1) {
            int k = cnt / 2;

                        bitonicSort(a, low, k, 1);

                        bitonicSort(a, low + k, k, 0);

                                    bitonicMerge(a, low, cnt, dir);
        }
    }

    void sort(int a[], int N, int up) {
        bitonicSort(a, 0, N, up);
    }

    static void printArray(int arr[]) {
        int n = arr.length;
        for (int i = 0; i < n; ++i) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String args[]) {
        int a[] = {3, 7, 4, 8, 6, 2, 1, 5};
        int up = 1;
        BitonicSort ob = new BitonicSort();
        ob.sort(a, a.length, up);
        System.out.println("\nSorted array");
        printArray(a);
    }
}




package com.thealgorithms.sorts;
import java.util.*;
public class LinkList_Sort {
    public static boolean isSorted(int p[] , int option) {
        try (Scanner sc = new Scanner(System.in)) {
        }
        int a[] = p;
                int b[] = p;
                int ch = option;
                switch (ch) {
            case 1:
                Task nm = new Task();
                Node start = null, prev = null, fresh, ptr;
                for (int i = 0; i < a.length; i++) {
                                        fresh = new Node();                     fresh.val = a[i];                     if (start == null)
                        start = fresh;
                    else
                        prev.next = fresh;
                    prev = fresh;
                }
                start = nm.sort_by_mergesort(start);
                                int i=0;
                for (ptr = start;ptr != null; ptr = ptr.next) {
                    a[i++]=ptr.val;
                                    }
                Arrays.sort(b);
                                LinkList_Sort uu=new LinkList_Sort();
                if(uu.compare(a,b))
                {
                    return true;
                }
                else
                {
                    return false;
                }
                            case 2:
                Node start1 = null, prev1 = null, fresh1, ptr1;
                for (int i1 = 0; i1 < a.length; i1++) {
                                        fresh1 = new Node();                     fresh1.val = a[i1];                     if (start1 == null)
                        start1 = fresh1;
                    else
                        prev1.next = fresh1;
                    prev1 = fresh1;
                }
                Task1 kk = new Task1();
                start1 = kk.sort_by_insertionsort(start1);
                                int i1=0;
                for (ptr1 = start1; ptr1 != null; ptr1 = ptr1.next) {
                    a[i1++]=ptr1.val;
                                    }
                LinkList_Sort uu1=new LinkList_Sort();
                                if(uu1.compare(a,b))
                {
                    return true;
                }
                else
                {
                    return false;
                }
                            case 3:
                Task2 mm = new Task2();
                Node start2 = null, prev2 = null, fresh2, ptr2;
                for (int i2 = 0; i2 < a.length; i2++) {
                                        fresh2 = new Node();                     fresh2.val = a[i2];                     if (start2 == null)
                        start2 = fresh2;
                    else
                        prev2.next = fresh2;
                    prev2 = fresh2;
                }
                start2 = mm.sort_by_heapsort(start2);
                                int i3=0;
                for (ptr2 = start2; ptr2 != null; ptr2 = ptr2.next) {
                    a[i3++]=ptr2.val;
                                    }
                Arrays.sort(b);
                                LinkList_Sort uu2=new LinkList_Sort();
                if(uu2.compare(a,b))
                {
                    return true;
                }
                else
                {
                    return false;
                }
                            default:
                                System.out.println("Wrong choice");
        }
                return false;
    }
    boolean compare(int a[] , int b[])
    {
        for(int i=0;i<a.length;i++)
        {
            if(a[i]!=b[i])
            return false;
        }
        return true;
            }
    
}

class Node {
    int val;
    Node next;
    }

class Task {
    static int a[];

    public Node sort_by_mergesort(Node head) {
        if (head == null || head.next == null)
            return head;
        int c = count(head);
        a = new int[c];
                int i = 0;
        for (Node ptr = head; ptr != null; ptr = ptr.next) {
            a[i++] = ptr.val;
        }
                i = 0;
        task(a, 0, c - 1);
                for (Node ptr = head; ptr != null; ptr = ptr.next) {
            ptr.val = a[i++];
                    }
        return head;
    }

    int count(Node head) {
        int c = 0;
        Node ptr;
        for (ptr = head; ptr != null; ptr = ptr.next) {
            c++;
        }
        return c;
                    }

    void task(int n[], int i, int j) {
        if (i < j) {
            int m = (i + j) / 2;
            task(n, i, m);
            task(n, m + 1, j);
            task1(n, i, m, j);
                    }
    }

    void task1(int n[], int s, int m, int e) {
        int i = s, k = 0, j = m + 1;
        int b[] = new int[e - s + 1];
        while (i <= m && j <= e) {
            if (n[j] >= n[i])
                b[k++] = n[i++];
            else
                b[k++] = n[j++];
        }
                while (i <= m) {
            b[k++] = n[i++];
        }
        while (j <= e) {
            b[k++] = n[j++];
        }
        for (int p = s; p <= e; p++) {
            a[p] = b[p - s];
        }
    }
    }
class Task1 {
    public Node sort_by_insertionsort(Node head) {
        if (head == null || head.next == null)
            return head;
        int c = count(head);
        int a[] = new int[c];
                a[0] = head.val;
        int i;
        Node ptr;
        for (ptr = head.next, i = 1; ptr != null; ptr = ptr.next, i++) {
            int j = i - 1;
            while (j >= 0 && a[j] > ptr.val) {
                                a[j + 1] = a[j];
                j--;
            }
            a[j + 1] = ptr.val;
        }
        i = 0;
        for (ptr = head; ptr != null; ptr = ptr.next) {
            ptr.val = a[i++];
                    }
        return head;
    }

    static int count(Node head) {
        Node ptr;
        int c = 0;
        for (ptr = head; ptr != null; ptr = ptr.next) {
            c++;
        }
        return c;
                    }
    }

class Task2 {
    static int a[];

    public Node sort_by_heapsort(Node head) {
        if (head == null || head.next == null)
            return head;
        int c = count(head);
        a = new int[c];
                int i = 0;
        for (Node ptr = head; ptr != null; ptr = ptr.next) {
            a[i++] = ptr.val;
                    }
        i = 0;
        task(a);
        for (Node ptr = head; ptr != null; ptr = ptr.next) {
            ptr.val = a[i++];
                    }
        return head;
    }

    int count(Node head) {
        int c = 0;
        Node ptr;
        for (ptr = head; ptr != null; ptr = ptr.next) {
            c++;
        }
        return c;
                    }

    void task(int n[]) {
        int k = n.length;
        for (int i = k / 2 - 1; i >= 0; i--) {
            task1(n, k, i);
        }
        for (int i = k - 1; i > 0; i--) {
            int d = n[0];
            n[0] = n[i];
            n[i] = d;
            task1(n, i, 0);
                    }
    }

    void task1(int n[], int k, int i) {
        int p = i;
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        if (l < k && n[l] > n[p])
            p = l;
        if (r < k && n[r] > n[p])
            p = r;
        if (p != i) {
            int d = n[p];
            n[p] = n[i];
            n[i] = d;
            task1(n, k, p);
        }
    }
    }package com.thealgorithms.sorts;

import static com.thealgorithms.sorts.SortUtils.*;


class BubbleSort implements SortAlgorithm {

    
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        for (int i = 1, size = array.length; i < size; ++i) {
            boolean swapped = false;
            for (int j = 0; j < size - i; ++j) {
                if (greater(array[j], array[j + 1])) {
                    swap(array, j, j + 1);
                    swapped = true;
                }
            }
            if (!swapped) {
                break;
            }
        }
        return array;
    }

    
    public static void main(String[] args) {

        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        BubbleSort bubbleSort = new BubbleSort();
        bubbleSort.sort(integers);

        for (int i = 0; i < integers.length - 1; ++i) {
            assert integers[i] <= integers[i + 1];
        }
        print(integers);

        String[] strings = {"c", "a", "e", "b", "d"};
        bubbleSort.sort(strings);
        for (int i = 0; i < strings.length - 1; i++) {
            assert strings[i].compareTo(strings[i + 1]) <= 0;
        }
        print(bubbleSort.sort(strings));
    }
}
package com.thealgorithms.sorts;

import java.util.Random;

public class OddEvenSort {

    public static void main(String[] args) {
        int[] arr = new int[100];

        Random random = new Random();

                for (int i = 0; i < arr.length; ++i) {
            arr[i] = random.nextInt(100) - 50;
            System.out.println(arr[i]);
        }
        System.out.println("--------------");

        oddEvenSort(arr);

                for (int i = 0; i < arr.length - 1; ++i) {
            System.out.println(arr[i]);
            assert arr[i] <= arr[i + 1];
        }
    }

    
    public static void oddEvenSort(int[] arr) {
        boolean sorted = false;
        while (!sorted) {
            sorted = true;

            for (int i = 1; i < arr.length - 1; i += 2) {
                if (arr[i] > arr[i + 1]) {
                    swap(arr, i, i + 1);
                    sorted = false;
                }
            }

            for (int i = 0; i < arr.length - 1; i += 2) {
                if (arr[i] > arr[i + 1]) {
                    swap(arr, i, i + 1);
                    sorted = false;
                }
            }
        }
    }

    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
package com.thealgorithms.sorts;

public class SelectionSort implements SortAlgorithm {

    
    @Override
    public <T extends Comparable<T>> T[] sort(T[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[minIndex].compareTo(arr[j]) > 0) {
                    minIndex = j;
                }
            }
            if (minIndex != i) {
                T temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }
        return arr;
    }

    
    public static void main(String[] args) {

        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        SelectionSort selectionSort = new SelectionSort();
        Integer[] sorted = selectionSort.sort(arr);
        for (int i = 0; i < sorted.length - 1; ++i) {
            assert sorted[i] <= sorted[i + 1];
        }

        String[] strings = {"c", "a", "e", "b", "d"};
        String[] sortedStrings = selectionSort.sort(strings);
        for (int i = 0; i < sortedStrings.length - 1; ++i) {
            assert strings[i].compareTo(strings[i + 1]) <= 0;
        }
    }
}
package com.thealgorithms.sorts;


public class DutchNationalFlagSort implements SortAlgorithm {

    @Override
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        return dutch_national_flag_sort(unsorted, unsorted[(int) Math.ceil((unsorted.length)/2.0) -1]);
    }

    public <T extends Comparable<T>> T[] sort(T[] unsorted, T intendedMiddle) {
        return dutch_national_flag_sort(unsorted, intendedMiddle);
    }

    private <T extends Comparable<T>> T[] dutch_national_flag_sort(T[] arr, T intendedMiddle){
        int i = 0;
        int j = 0;
        int k = arr.length - 1;

        while( j <= k){
            if ( 0 > arr[j].compareTo(intendedMiddle)){
                SortUtils.swap(arr, i, j);
                j++;
                i++;
            } else if (0 < arr[j].compareTo(intendedMiddle)){
                SortUtils.swap(arr, j, k);
                k--;
            } else {
                j++;
            }
        }
       return arr;
    }
}
