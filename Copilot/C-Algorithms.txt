#include <stdio.h>

// Euclid's algorithm
int GCD(int x, int y)
{
    if (y == 0)
        return x;
    return GCD(y, x % y);
}

int main()
{
    int a, b;
    printf("Input two numbers:\n");
    scanf("%d %d", &a, &b);
    printf("Greatest common divisor: %d\n", GCD(a, b));
}
/**
 * @file
 * @brief Implementation of [Addition of two polynomials]
 * (https://en.wikipedia.org/wiki/Polynomial#Addition)
 * @author [Ankita Roy Chowdhury](https://github.com/Ankita19ms0010)
 * @details
 * This code takes two polynomials as input
 * and prints their sum using linked list.
 * The polynomials must be in increasing or decreasing order of degree.
 * Degree must be positive.
 */
#include <stdio.h>  // for io operations
#include <stdlib.h>

/**
 * @brief identifier for single-variable polynomial coefficients as a linked
 * list
 */
struct term
{
    int coef;          /**< coefficient value */
    int pow;           /**< power of the polynomial term */
    struct term *next; /**< pointer to the successive term */
};

/**
 * @brief Frees memory space
 * @param poly first term of polynomial
 * @returns void
 */
void free_poly(struct term *poly)
{
    if (!poly)
    {
        return;  // NULL pointer does not need delete
    }
    else
    {
        while (!poly->next)
        {
            free(poly->next);  // Deletes next term
        }
        free(poly);  // delete the current term
    }
}

/**
 * The function will create a polynomial
 * @param poly stores the address of the polynomial being created
 * @param coef contains the coefficient of the node
 * @param pow contains the degree
 * @returns none
 */
void create_polynomial(struct term **poly, int coef, int pow)
{
    // Creating the polynomial using temporary linked lists
    struct term *temp1, *temp2;
    temp1 = *poly;  // Contains the null pointer

    // Initiating first term
    if (temp1 == NULL)
    {
        temp2 = (struct term *)malloc(
            sizeof(struct term));  // Dynamic node creation
        temp2->coef = coef;
        temp2->pow = pow;
        // Updating the null pointer with the address of the first node of the
        // polynomial just created
        *poly = temp2;
        temp2->next = NULL;  // Increasing the pointer temp2
    }
    // Creating the rest of the nodes
    else
    {
        temp2->next = (struct term *)malloc(
            sizeof(struct term));  // Dynamic node creation
        temp2 = temp2->next;       // Increasing the pointer temp2
        temp2->coef = coef;
        temp2->pow = pow;
        temp2->next = NULL;
    }
}

/**
 * The function will add 2 polynomials
 * @param poly1 first polynomial of the addition
 * @param poly2 second polynomial of the addition
 * @param pol  the resultant polynomial
 */

void poly_add(struct term **pol, struct term *poly1, struct term *poly2)
{
    // Creating a temporary linked list to store the resultant polynomial
    struct term *temp = (struct term *)malloc(sizeof(struct term));
    temp->next = NULL;
    *pol =
        temp;  //*pol always points to the 1st node of the resultant polynomial

    // Comparing the powers of the nodes of both the polynomials
    // until one gets exhausted
    while (poly1 && poly2)
    {
        /* If the power of the first polynomial is greater than the power of the
       second one place the power and coefficient of that node of the first
       polynomial in temp and increase the pointer poly1
       */
        if (poly1->pow > poly2->pow)
        {
            temp->coef = poly1->coef;
            temp->pow = poly1->pow;
            poly1 = poly1->next;
        }
        /* If the power of the second polynomial is greater than the power of
          the first one place the power and coefficient of that node of the
          second polynomial in temp and increase the pointer poly2
        */
        else if (poly1->pow < poly2->pow)
        {
            temp->coef = poly2->coef;
            temp->pow = poly2->pow;
            poly2 = poly2->next;
        }
        /* If both of them have same power then sum the coefficients
          place both the summed coefficient and the power in temp
          increase both the pointers poly1 and poly2
        */
        else
        {
            temp->coef = poly1->coef + poly2->coef;
            temp->pow = poly1->pow;
            poly1 = poly1->next;
            poly2 = poly2->next;
        }
        /* If none of the polynomials are exhausted
         dynamically create a node in temp
         */
        if (poly1 && poly2)
        {
            temp->next = (struct term *)malloc(
                sizeof(struct term));  // Dynamic node creation
            temp = temp->next;         // Increase the pointer temp
            temp->next = NULL;
        }
    }
    /* If one of the polynomials is exhausted
    place the rest of the other polynomial as it is in temp
    by creating nodes dynamically
    */
    while (poly1 || poly2)
    {
        temp->next = (struct term *)malloc(
            sizeof(struct term));  // Dynamic node creation
        temp = temp->next;         // Increasing the pointer
        temp->next = NULL;

        /* If poly1 is not exhausted
        place rest of that polynomial in temp
        */
        if (poly1)
        {
            temp->coef = poly1->coef;
            temp->pow = poly1->pow;
            poly1 = poly1->next;
        }
        /* If poly2 is not exhausted
       place rest of that polynomial in temp
       */
        else if (poly2)
        {
            temp->coef = poly2->coef;
            temp->pow = poly2->pow;
            poly2 = poly2->next;
        }
    }
}

/**
 * The function will display the polynomial
 * @param poly first term of the polynomial to be displayed
 * @returns none
 */
void display_polynomial(struct term *poly)
{
    while (poly != NULL)
    {
        printf("%d x^%d", poly->coef, poly->pow);
        poly = poly->next;
        if (poly != NULL)
        {
            printf(" + ");
        }
    }
}

/**
 * @brief Test function 1
 *
 * @details
 * Polynomial 1 is 5 x^2 + 3 x^1 + 2 x^0
 * Polynomial 2 is 7 x^3 + 9 x^1 + 10 x^0
 * Resultant polynomial is 7 x^3 + 5 x^2 + 12 x^1 + 12 x^0
 * @returns void
 */
static void test1(struct term *poly1, struct term *poly2, struct term *poly3)
{
    printf("\n----Test 1----\n");
    printf("\nFirst Polynomial:\n");  // Defining the 1st polynomial
    create_polynomial(&poly1, 5, 2);
    create_polynomial(&poly1, 3, 1);
    create_polynomial(&poly1, 2, 0);
    display_polynomial(poly1);

    printf("\nSecond Polynomial:\n");  // Defining the 2nd polynomial
    create_polynomial(&poly2, 7, 3);
    create_polynomial(&poly2, 9, 1);
    create_polynomial(&poly2, 10, 0);
    display_polynomial(poly2);

    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials
    printf("\nResultant polynomial:\n");
    display_polynomial(poly3);
    printf("\n");

    // Frees memory space
    free_poly(poly1);
    free_poly(poly2);
    free_poly(poly3);
}

/**
 * @brief Test function 2
 *
 * @details
 * Polynomial 1 is 3 x^5 + 1 x^4 + 2 x^3 + -2 x^1 + 5 x^0
 * Polynomial 2 is 2 x^5 + 3 x^3 + 7 x^1 + 2 x^0
 * Resultant polynomial is 5 x^5 + 1 x^4 + 5 x^3 + 5 x^1 + 7 x^0
 * @returns void
 */
static void test2(struct term *poly1, struct term *poly2, struct term *poly3)
{
    printf("\n----Test 2----\n");
    printf("\nFirst Polynomial:\n");  // Defining the 1st polynomial
    create_polynomial(&poly1, 3, 5);
    create_polynomial(&poly1, 1, 4);
    create_polynomial(&poly1, 2, 3);
    create_polynomial(&poly1, -2, 1);
    create_polynomial(&poly1, 5, 0);

    display_polynomial(poly1);

    printf("\nSecond Polynomial:\n");  // Defining the 2nd polynomial
    create_polynomial(&poly2, 2, 5);
    create_polynomial(&poly2, 3, 3);
    create_polynomial(&poly2, 7, 1);
    create_polynomial(&poly2, 2, 0);

    display_polynomial(poly2);

    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials
    printf("\nResultant polynomial:\n");
    display_polynomial(poly3);
    printf("\n");

    // Frees memory space
    free_poly(poly1);
    free_poly(poly2);
    free_poly(poly3);
}

/**
 * @brief Test function 3
 *
 * @details
 * Polynomial 1 is -12 x^0 + 8 x^1 + 4 x^3
 * Polynomial 2 is 5 x^0 + -13 x^1 + 3 x^3
 * Resultant polynomial is -7 x^0 + -5 x^1 + 7 x^3
 * @returns void
 */
static void test3(struct term *poly1, struct term *poly2, struct term *poly3)
{
    printf("\n----Test 3----\n");
    printf("\nFirst Polynomial:\n");  // Defining the 1st polynomial
    create_polynomial(&poly1, -12, 0);
    create_polynomial(&poly1, 8, 1);
    create_polynomial(&poly1, 4, 3);

    display_polynomial(poly1);

    printf("\nSecond Polynomial:\n");  // Defining the 2nd polynomial
    create_polynomial(&poly2, 5, 0);
    create_polynomial(&poly2, -13, 1);
    create_polynomial(&poly2, 3, 3);

    display_polynomial(poly2);

    poly_add(&poly3, poly1, poly2);  // Adding the two polynomials
    printf("\nResultant polynomial:\n");
    display_polynomial(poly3);
    printf("\n");

    // Frees memory space
    free_poly(poly1);
    free_poly(poly2);
    free_poly(poly3);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main(void)
{
    struct term *poly1 = NULL, *poly2 = NULL, *poly3 = NULL;
    test1(poly1, poly2, poly3);
    test2(poly1, poly2, poly3);
    test3(poly1, poly2, poly3);

    return 0;
}
#include <stdio.h>

int main()
{
    int a[16500], T;
    long long int i, j;

    printf("Enter number of test cases : ");
    scanf("%d", &T);

    while (T--)
    {
        for (i = 0; i < 16500; i++)
        {
            a[i] = 0;
        }

        a[1] = 1;
        int N, carry = 0, count = 0;
        printf("Enter a number : ");
        scanf("%d", &N);

        for (i = 1; i <= N; i++)
        {
            carry = 0;
            for (j = 0; j < 16500; j++)
            {
                a[j] = a[j] * i + carry;
                carry = a[j] / 10;
                a[j] = a[j] % 10;
            }
        }

        for (i = 0; i < 16500; i++)
        {
            if (a[i] != 0)
            {
                count = i;
            }
        }

        for (i = count; i > 0; i--)
        {
            printf("%d", a[i]);
        }
        printf("\n");
    }

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
void swap(int *a, int *b)
{
    int t;
    t = *a;
    *a = *b;
    *b = t;
}
int part(int a[], int l, int r, int n, int pivot, int pindex)
{
    int p1 = l, p2 = r;
    while (p2 > p1)
    {
        if (a[p1] > pivot && a[p2] < pivot)
        {
            swap(&a[p1], &a[p2]);
        }
        else
        {
            if (a[p1] <= pivot)
            {
                p1++;
            }
            if (a[p2] >= pivot)
            {
                p2--;
            }
        }
    }
    swap(&a[pindex], &a[p2]);
    return p2;
}
int rselect(int a[], int l, int r, int n, int o)
{
    int pivot, pindex, pactual;
    if (r > l)
    {
        pindex = rand() % (r - l + 1);
        pivot = a[pindex];
        pactual = part(a, l, r, n, pivot, pindex);

        if (pactual == o)
        {
            return a[pactual];
        }

        if (o < pactual)
        {
            rselect(a, l, pactual - 1, n, o);
        }

        if (o > pactual)
        {
            rselect(a, pactual + 1, r, n, o - pactual);
        }
    }
    if (r == l)
    {
        return a[l];
    }
    return -1;
}
int main()
{
    srand(time(NULL));
    int n, o, i, *a;
    scanf("%d %d", &n, &o);
    a = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", a + i);
    }
    printf("\n\n%d", rselect(a, 0, n - 1, n, o));
    return 0;
}
/**
 * @file
 * @brief [Prime Seive](https://leetcode.com/problems/count-primes/)
 * algorithm implementation.
 * @author [Divyansh Kushwaha](https://github.com/webdesignbydivyansh)
 */
#include <assert.h>	/// for assert
#include <stdio.h>	/// for standard input output
#include <stdlib.h>	/// for general purpose standard library

const unsigned long long MAX_SIZE = 1000000;  /// variable upto which prime numbers are to be found out
/**
 * @addtogroup misc
 * @{
 */
/**
 * @brief Prime Sieve works in O(nlogn) time
 * @param p array to be updated
 * @returns void
 */
void prime(int *p)
{
	for(long long int i=3;i<=MAX_SIZE;i+=2) { p[i]=1; }
	for(long long int i=3;i<=MAX_SIZE;i+=2)
	{
		if(p[i]==1) {
		    for(long long int j=i*i;j<=MAX_SIZE;j+=i) {
			p[j]=0;
		    }
		}
	}
	p[2]=1;
	p[0]=p[1]=0;    
}
/**
 * @brief Count func counts the number of 
 * prime numbers.
 * @param arr contains the prime numbers
 * @param size denotes upto which prime numbers are to be found out
 * @returns count of prime numbers
 */
int count(int *arr, const int size){
  int k=0;
  for(int i=0;i<=size;i++){
    if(arr[i]==1){
      k++;
    }
  }
  return k;
}

/**
 * @brief Test implementations
 * @returns void
 */
static void test()
{
    // Test Case 1
    const int size = 10; /* array size */
    printf("Test Case 1...");
    int arr[1000005]={0};   /* array to store prime numbers */
    prime(arr);
    assert(count(arr,size)==4);
    printf("Passed\n");
}

/** 
 * @brief Main function
 * @param argc commandline argument count (ignored)
 * @param argv commandline array of arguments (ignored)
 * @returns 0 on exit
 */
int main(int argc, const char *argv[])
{
    test();	// execute the tests
    return 0;
}
/**
 * @file
 * @brief Function to convert a Cartesian co-ordinate to polar form.
 */
#define _USE_MATH_DEFINES /**< required for MS Visual C */
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

/**
 * @brief Function to convert cartesian coordinates to polar.
 *\f{eqnarray*}{
 r &=& \sqrt{x^2+y^2}\\
 \theta &=& \atan\frac{y}{x}
 \f}
 * @param [in] x absicca value
 * @param [in] y ordinate value
 * @param [out] r pointer to store polar radius
 * @param [out] theta pointer to store polar angle (in radian)
 */
void to_polar(double x, double y, double *r, double *theta)
{
    double thetaFinal = 0.f;

    *r = sqrt(x * x + y * y);

    if (x != 0)
    {
        if (y != 0)
        {
            *theta = atan(y / x);
            if ((x > 0 && y > 0) || (x == -y))
            {  // Q1
                thetaFinal = *theta;
            }
            else if (x < 0 && y > 0)
            {  // Q2
                thetaFinal = *theta + M_PI;
            }
            else if (x < 0 && y < 0)
            {  // Q3
                thetaFinal = *theta - M_PI;
            }
            else if (x > 0 && y < 0)
            {  // Q4
                thetaFinal = 2 * M_PI - *theta;
            }
            else
            {
                fprintf(stderr, "Should not reach here!\n");
            }
        }
    }
    else
    {  // exceptions when no actual angle is present
        if (y > 0)
        {
            thetaFinal = M_PI / 2;
        }
        else
        {
            thetaFinal = -(M_PI / 2);
        }
    }
    if (y == 0)
    {
        if (x > 0)
        {
            thetaFinal = 0;
        }
        else
        {
            thetaFinal = -M_PI;
        }
    }

    *theta = thetaFinal;
}

/**
 * @brief Generate a random number in the given limits
 *
 * @param lim1 lower limit
 * @param lim2 upper limit
 * @return random number in the given range
 */
double get_rand(double lim1, double lim2)
{
    double r = (double)rand() / RAND_MAX;  // value in [0,1)
    return (lim2 - lim1) * r + lim1;       // scale to range
}

/**
 * @brief Test implementation
 *
 */
void test()
{
    srand(10);
    int NUM_TESTS = 5;

    for (int i = 0; i < NUM_TESTS; i++)
    {
        double r, theta;
        printf("Test %d.... ", i);
        double x = get_rand(-5, 5);
        double y = get_rand(-5, 5);
        printf("(%.2g, %.2g).... ", x, y);
        to_polar(x, y, &r, &theta);
        assert(fabs(r - hypot(x, y)) < 0.01);
        assert(fabs(theta - atan2(y, x)) < 0.01);
        printf("passed\n");
    }
}

/** Main function */
int main()
{
    test();

    return 0;
}
// Recursion problem
// Given the denominations of currencies available in a system, find the number
// of ways an ATM machine can generate notes for an entered amount N.

#include <stdio.h>
#include <stdlib.h>

int ways(int n, int *a, int k)
{
    if (n < 0 || k < 0)
        return 0;
    if (n == 0)
        return 1;
    if (k == 0)
        return 0;
    return ways(n, a, k - 1) + ways(n - a[k - 1], a, k);
}

int main()
{
    int m;
    int t;
    int n;

    printf("Number of coins? ");
    scanf("%d", &m);
    int *coin = (int *)malloc(m * sizeof(int)), i;
    for (i = 0; i < m; i++)
    {
        printf("coin? ");
        scanf("%d", &coin[i]);
    }

    printf("---- your requests --- \n");
    while (1)
    {
        printf("amount? exit(0) ");
        scanf("%d", &n);
        if (!n)
        {
            break;
        }
        printf("%d\n", ways(n, coin, m));
    }

    free(coin);
    return 0;
}
/*
    AUTHOR: Christian Bender
    DATE: 12.02.2019
    DESCRIPTION: This program calculates the prime factoriziation of a positive
   integer > 1
*/

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* initial length of the dynamic array */
#define LEN 10

/* increasing range */
#define STEP 5

/*
    this type is for the representation of the prim factoriziation
    - its series/range of prime factors
    - its length : numbers of prime factors
*/
typedef struct data
{
    int *range;
    int length;
} range;
typedef range *Range;

/* int_fac : calculates the prime factoriziation of positive integers */
Range int_fact(int);

/* print_arr : prints the integer (heap) array*/
void print_arr(Range);

/* increase : increases the dynamic integer array */
int *increase(int *, int);

/* destroy: destroys the range-structure */
void destroy(Range);

/*
    main : simle frame program with a simple UI
*/
int main()
{
    int n = 0; /* for user input */

    printf("\t\tPrim factoriziation\n\n");
    printf("positive integer (> 1) ? ");
    scanf("%d", &n);
    Range r = int_fact(n);
    printf("\nThe factoriziation are: ");
    print_arr(r);
    destroy(r);
    return 0;
}

Range int_fact(int n)
{
    assert(n > 1); /* precondition : n must be greater then 1*/

    int len = LEN;
    int count = 0;
    int i = 0;
    int *range = (int *)malloc(sizeof(int) * len);
    assert(range);
    Range pstr = (Range)malloc(sizeof(range));
    assert(pstr);

    while (n % 2 == 0)
    {
        n /= 2;
        if (i < len)
        {
            range[i] = 2;
            i++;
        }
        else
        {
            range = increase(range, len);
            len += STEP;
            range[i] = 2;
            i++;
        }
        count++;
    }

    int j = 3;
    while (j * j <= n)
    {
        while (n % j == 0)
        {
            n /= j;
            if (i < len)
            {
                range[i] = j;
                i++;
            }
            else
            {
                range = increase(range, len);
                len += STEP;
                range[i] = j;
                i++;
            }
            count++;
        }

        j += 2;
    }

    if (n > 1)
    {
        if (i < len)
        {
            range[i] = n;
            i++;
        }
        else
        {
            range = increase(range, len);
            len += STEP;
            range[i] = n;
            i++;
        }
        count++;
    }

    pstr->range = range;
    pstr->length = count;
    return pstr;
}

void print_arr(Range pStr)
{
    assert(pStr); /* checks whether pStr is a null-pointer */
    int i = 0;
    printf("\n");
    for (i; i < pStr->length; i++)
    {
        if (i == 0)
            printf("%d", pStr->range[0]);
        else
            printf("-%d", pStr->range[i]);
    }
    printf("\n");
}

int *increase(int *arr, int len)
{
    assert(arr); /* checks whether arr is a null-pointer */
    int *tmp = (int *)realloc(arr, sizeof(int) * (len + STEP));
    assert(tmp);
    return tmp;
    //    assert(arr);
}

void destroy(Range r)
{
    free(r->range);
    free(r);
}

#include <stdio.h>
#include <stdlib.h>

// Function for Tower of Hanoi algorithm
void hanoi(int noOfDisks, char where, char to, char extra)
{
    if (noOfDisks != 0)
    {
        hanoi(noOfDisks - 1, where, extra, to);
        printf("Move disk : %d from %c to %c\n", noOfDisks, where, to);
        hanoi(noOfDisks - 1, extra, to, where);
    }
}
int main(void)
{
    int noOfDisks;

    // Asks the number of disks in the tower
    printf("Number of disks: \n");
    scanf("%d", &noOfDisks);

    hanoi(noOfDisks, 'A', 'B', 'C');

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void longestSub(int *ARRAY, int ARRAY_LENGTH, int **RESULT, int *RESULT_LENGTH)
{  // RESULT and RESULT_LENGTH will be modified by their pointers

    if (ARRAY_LENGTH <= 1)
    {
        *RESULT = ARRAY;
        *RESULT_LENGTH = ARRAY_LENGTH;
    }
    else
    {
        int PIVOT = ARRAY[0];
        int *LONGEST_SUB = NULL;
        int i, j, LONGEST_SUB_LENGTH = 0;
        int TEMPORARY_ARRAY_LENGTH = 0, *TEMPORARY_ARRAY = NULL;

        for (i = 1; i < ARRAY_LENGTH; i++)
        {
            if (ARRAY[i] < PIVOT)
            {
                TEMPORARY_ARRAY_LENGTH = 0;
                TEMPORARY_ARRAY = NULL;

                for (j = i + 1; j < ARRAY_LENGTH; j++)
                {
                    if (ARRAY[j] >= ARRAY[i])
                    {
                        TEMPORARY_ARRAY_LENGTH++;
                        TEMPORARY_ARRAY = (int *)realloc(
                            TEMPORARY_ARRAY,
                            TEMPORARY_ARRAY_LENGTH * sizeof(int));
                        TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[j];
                    }
                }

                longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH,
                           &TEMPORARY_ARRAY, &TEMPORARY_ARRAY_LENGTH);
                if (LONGEST_SUB_LENGTH < TEMPORARY_ARRAY_LENGTH + 1)
                {
                    LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;
                    LONGEST_SUB = (int *)realloc(
                        LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));
                    LONGEST_SUB[0] = ARRAY[i];

                    for (i = 1; i < LONGEST_SUB_LENGTH; i++)
                        LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];
                }
            }
        }

        TEMPORARY_ARRAY = NULL;
        TEMPORARY_ARRAY_LENGTH = 0;
        for (i = 1; i < ARRAY_LENGTH; i++)
        {
            if (ARRAY[i] >= PIVOT)
            {
                TEMPORARY_ARRAY_LENGTH++;
                TEMPORARY_ARRAY = (int *)realloc(
                    TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH * sizeof(int));
                TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[i];
            }
        }

        longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH, &TEMPORARY_ARRAY,
                   &TEMPORARY_ARRAY_LENGTH);
        if (TEMPORARY_ARRAY_LENGTH + 1 > LONGEST_SUB_LENGTH)
        {
            LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;
            LONGEST_SUB =
                (int *)realloc(LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));
            LONGEST_SUB[0] = PIVOT;
            for (i = 1; i < LONGEST_SUB_LENGTH; i++)
                LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];
        }
        *RESULT = LONGEST_SUB;
        *RESULT_LENGTH = LONGEST_SUB_LENGTH;
    }
}

int main()
{
    int EXAMPLE_LENGTH = 8;
    int EXAMPLE[] = {18, 2, 15, 4, 30, 0, 11, 12};

    int *RESULT = NULL;
    int RESULT_LENGTH, i;

    longestSub(EXAMPLE, EXAMPLE_LENGTH, &RESULT, &RESULT_LENGTH);

    printf("Longest Sub Sequence length: %d and it's:\n", RESULT_LENGTH);
    for (i = 0; i < RESULT_LENGTH; i++) printf("%d ", RESULT[i]);
    printf("\n");

    return 0;
}/**
 * PID Controller
 *
 * The PID controller is a linear control algorithm that has three terms:
 *  - Proportional: A simple scaling of the error value by a gain kP
 *  - Integral: Integration of the error value over time, then multipled by gain
 * kI
 *  - Derivative: Rate of change of the error value over time, multiplied by
 * gain kD
 *
 * Terms of the controller can be removed by setting their gain to 0, creating a
 * PI (kD = 0) or PD (kI = 0) controller. Depending on the control problem at
 * hand, some terms may not increase the performance of the system, or may have
 * a negative effect.
 *
 * For a more mathematical expanation of the PID Controller, see
 * https://en.wikipedia.org/wiki/PID_controller
 *
 * Limitations of this implementation:
 *  - Since this implementation is just for demonstration, the pid_step function
 * takes the dt as a parameter, and it can be provided by the user in main().
 * This allows deterministic experimentation with the algorithm, rather than
 * using time(NULL) which would make the function non-deterministic.
 *
 * Inputs: e(t) - Current error at time t. For example, how far a servo is off
 * the desired angle Output: u(t) - Controller output at time t.
 */
#include <stdio.h>

struct pid
{
    // Controller gains
    float kP;
    float kI;
    float kD;

    // State variables
    float lastError;
    float integral;
};

float pid_step(struct pid *controller, float dt, float error)
{
    // Calculate p term
    float p = error * controller->kP;

    // Calculate i term
    controller->integral += error * dt * controller->kI;

    // Calculate d term, taking care to not divide by zero
    float d =
        dt == 0 ? 0 : ((error - controller->lastError) / dt) * controller->kD;
    controller->lastError = error;

    return p + controller->integral + d;
}

int main()
{
    printf("PID Controller Example\n");

    struct pid controller = {.lastError = 0, .integral = 0};

    // Take the controller gains from the user
    printf(
        "Please enter controller gains in format kP, kI, KD. For example, "
        "\"1.2 2.1 3.2\"\n> ");
    scanf("%f %f %f", &controller.kP, &controller.kI, &controller.kD);
    printf("Using kP: %f, kI: %f, kD: %f\n", controller.kP, controller.kI,
           controller.kD);

    // How often the pid_step algorithm expects to be called. In a real life
    // scenario this would be provided by calling time(NULL) - last_time, or by
    // calling the function reliably at X Hz (using a timer or RTOS etc) For
    // demonstration of this algorithm though, it is defined below as 1 second,
    // allowing easy testing of integral and derivative terms.
    float time_step = 1;

    float error_value;
    while (1)
    {
        printf("Enter error value\n>");
        scanf("%f", &error_value);

        float output = pid_step(&controller, time_step, error_value);
        printf("Output: %f\n", output);
    }
}
/**
 * \file
 *
 * \brief Implementation of [Collatz'
 * conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture)
 *
 * Collatz conjecture: a series for a number \f$n\f$ in which if \f$n\f$ even
 * then the next number is \f$\frac{n}{2}\f$ ,but if n is odd then the next
 * number is \f$3n+1\f$. This series continues till \f$n\f$ reaches 1
 */

#include <stdio.h>
#include <stdlib.h>

/** Main function */
int main(int argc, char *argv[])
{
    unsigned long long n, curr_no, num_steps = 0;
    if (argc == 2)
        n = strtoull(argv[1], NULL, 10);
    else
    {
        printf("Enter starting number: ");
        scanf("%lu", &n);  // input number
    }

    curr_no = n;          // curr_no stores input number n
    while (curr_no != 1)  // loop till series reaches 1
    {
        num_steps++;
        printf("%llu->", curr_no);
        if (curr_no % 2 == 0)  // condition   for even number
            curr_no = curr_no / 2;
        else
            curr_no = (curr_no * 3) + 1;  // condition for odd number
    }
    printf("1\nNumber of steps: %llu\n", num_steps);
    return 0;
}
/**
 * @file union_find.c
 * @brief [Union
 * find](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) algorithm.
 */
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 1000 /**< maximum number of elements in the set */

/**
 * @brief Find index of or value in an array
 *
 * @param [in,out] p array to search and update
 * @param x value to search
 * @return value at the index `x`
 */
int find(int *p, int x)
{
    if (x >= MAX_SIZE)
    {
        fprintf(stderr, "Out-of bounds value\n");
        exit(EXIT_FAILURE);
    }

    if (p[x] == x)
    {
        return x;
    }
    else
    {
        p[x] = find(p, p[x]);
        return p[x];
    }
}

/**
 * @brief Function to join
 * @param [in,out] p array to join in
 * @param x value or index to join to
 * @param y value or index to join from
 */
void join(int *p, int x, int y) { p[find(p, x)] = find(p, y); }

/** Main function */
int main()
{
    int union_set[MAX_SIZE];

    // Have all array indexes that you need to use reference themselves
    for (int i = 0; i < 10; i++)
    {
        union_set[i] = i;
    }
    // p = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

    join(union_set, 3, 5);
    printf("The array is now: ");
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", union_set[i]);
    }
    printf("\n");
    // Now 3 and 5 are groupped together, that is find(3) = find(5)
    // p = {0, 1, 2, 5, 4, 5, 6, 7, 8, 9}

    join(union_set, 3, 8);
    printf("The array is now: ");
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", union_set[i]);
    }
    printf("\n");

    // Now 3, 5 and are groupped together, find(3) = find(5) = find(8)
    // p = {0, 1, 2, 5, 4, 8, 6, 7, 8, 9}
    join(union_set, 0, 5);
    if (find(union_set, 0) == find(union_set, 3))
    {
        printf("0 and 3 are groupped together\n");
    }
    printf("The array is now: ");
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", union_set[i]);
    }
    printf("\n");

    return 0;
}
// A number is called as Armstrong number if sum of cubes of digits of number is
// equal to the number itself.
// For Example 153 is an Armstrong number because 153 = 1³+5³+3³.
#include <stdio.h>

// Function to calculate x raised to the power y
int power(int x, unsigned int y)
{
    if (y == 0)
        return 1;
    if (y % 2 == 0)
        return power(x, y / 2) * power(x, y / 2);
    return x * power(x, y / 2) * power(x, y / 2);
}

// Function to calculate order of the number
int order(int x)
{
    int n = 0;
    while (x)
    {
        n++;
        x = x / 10;
    }
    return n;
}

// Function to check whether the given number is
// Armstrong number or not
int isArmstrong(int x)
{
    // Calling order function
    int n = order(x);
    int temp = x, sum = 0;
    while (temp)
    {
        int r = temp % 10;
        sum += power(r, n);
        temp = temp / 10;
    }

    // If satisfies Armstrong condition
    if (sum == x)
        return 1;
    else
        return 0;
}

//
int main()
{
    int x = 153;
    if (isArmstrong(x) == 1)
        printf("True\n");
    else
        printf("False\n");

    x = 1253;
    if (isArmstrong(x) == 1)
        printf("True\n");
    else
        printf("False\n");

    return 0;
}
#include <stdio.h>

// Fibonnacci function
int fib(int number)
{
    if (number == 1 || number == 2)
        return 1;
    else
        return fib(number - 1) + fib(number - 2);
}

int main()
{
    int number;

    // Asks for the number that is in n position in Fibonnacci sequence
    printf("Number: ");
    scanf("%d", &number);

    printf("%d \n", fib(number));

    return 0;
}/**
 * @file
 * \brief Compute factorial of arbitrarily large numbers by
 * storing individual digits in a byte.
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * dynamically large number
 */
typedef struct _large_num
{
    char *digits;            /**< array to store individual digits */
    unsigned int num_digits; /**< number of digits in the number */
} large_num;

/**
 * create a new large number
 * \returns pointer to a large number
 */
large_num *new_number(void)
{
    large_num *new_num = (large_num *)malloc(sizeof(large_num));
    new_num->num_digits = 1;
    new_num->digits = (char *)malloc(1 * sizeof(char));
    new_num->digits[0] = 1;
    return new_num;
}

/**
 * delete all memory allocated for large number
 * \param[in] num pointer to large_num to delete
 */
void delete_number(large_num *num)
{
    free(num->digits);
    free(num);
}

/**
 * add a digit to the large number
 * \param[in,out] num
 * \param[in] value value of the digit to insert
 */
void add_digit(large_num *num, unsigned int value)
{
    if (value > 9)
    {
        fprintf(stderr, "digit > 9!!\n");
        delete_number(num);
        exit(EXIT_FAILURE);
    }

    num->num_digits++;
    num->digits = (char *)realloc(num->digits, num->num_digits * sizeof(char));
    num->digits[num->num_digits - 1] = value;
}

/**
 * multiply large number with another integer and
 * store the result in the same large number
 */
void multiply(large_num *num, unsigned long n)
{
    int i;
    unsigned long carry = 0, temp;
    for (i = 0; i < num->num_digits; i++)
    {
        temp = num->digits[i] * n;
        temp += carry;
        if (temp < 10)
            carry = 0;
        else
        {
            carry = temp / 10;
            temp = temp % 10;
        }
        num->digits[i] = temp;
    }

    while (carry != 0)
    {
        add_digit(num, carry % 10);
        carry /= 10;
    }
}

/**
 * main function
 */
int main(int argc, char *argv[])
{
    int number, i;

    // Asks for the number/position of term in Fibonnacci sequence
    if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf("Enter the value of n(n starts from 0 ): ");
        scanf("%d", &number);
    }

    large_num *result = new_number();

    clock_t start_time = clock();
    for (i = 2; i <= number; i++) /* Multiply every number from 2 thru N */
        multiply(result, i);
    double time_taken = (clock() - start_time) * (double)1e3 / CLOCKS_PER_SEC;
    // time_taken = (clock() - start_time) / (double) CLOCKS_PER_SEC;

    printf("%d! = ", number);
    for (i = result->num_digits; i > 0; i--)
        putchar(result->digits[i - 1] + '0');
    printf("\nTime taken: %.4g ms\n", time_taken);

    delete_number(result);
    return 0;
}
/*
programme for computing number of zeroes at the end of factorial of a given
number n
*/
#include <math.h>  //including math.h header file to use pow function
#include <stdio.h>
int main()
{
    int i, n, test = 0, count = 0;
    // taking input number n
    scanf("%d", &n);

    // looping from 1 till loop break
    for (i = 1;; i++)
    {
        test =
            n /
            pow(5,
                i);  // division of n by ith power of 5(storing in integer form)
        if (test !=
            0)  // condition for zeroes at end corresponding individual ith case
        {
            count = count + test;
        }
        else
            break;  // break the loop for if test=0
    }
    printf("%d\n", count);
    return 0;
}
// C program to find LCM of two numbers
/*
    suppose we have two numbers a and b.
    Property: Since product of LCM and GCD of two numbers are equal to product
   of that number itself. i.e, LCM(a,b)*GCD(a,b)=a*b. So,here we first find the
   GCD of two numbers and using above property we find LCM of that two numbers.
*/
#include <stdio.h>

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

// Function to return LCM of two numbers
int lcm(int a, int b) { return (a * b) / gcd(a, b); }

// Driver program
int main()
{
    int a, b;
    printf("Enter two numbers to find their LCM \n");
    scanf("%d%d", &a, &b);
    printf("LCM of %d and %d is %d ", a, b, lcm(a, b));
    return 0;
}
/*
Test Case1:
a=15,b=20
LCM(a,b)=60
Test Case2:
a=12,b=18
LCM(a,b)=36
*/
/**
 * @file
 * @brief Sudoku Solver using recursive implementation of brute-force algorithm
 *
 * @details
 * Given an incomplete N*N Sudoku and asked to solve it using the
 * following recursive algorithm:
 * 1. Scan the Sudoku from left to right row-wise to search for an empty cell.
 * 2. If there are no empty cells, print the Sudoku. Go to step 5.
 * 3. In the empty cell, try putting numbers 1 to N
 * while ensuring that no two numbers in a single row, column, or box are same.
 * Go back to step 1.
 * 4. Declare that the Sudoku is Invalid.
 * 5. Exit.
 *
 * @authors [Anuj Shah](https://github.com/anujms1999)
 * @authors [Krishna Vedala](https://github.com/kvedala)
 */
#include <assert.h>
#include <inttypes.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/** @addtogroup sudoku Sudoku solver
 * @{
 */
/** Structure to hold the matrix and dimensions
 */
struct sudoku
{
    uint8_t *a; /**< matrix as a flattened 1D row-major array */
    uint8_t N;  /**< number of elements */
    uint8_t N2; /**< block of elements */
};

/**
 * Check if `x`^th row is valid
 * @param a ::sudoku to check
 * @param x row to check
 * @param y ignored column
 * @param v value to check if it repeats
 * @returns `true` if valid
 * @returns `false` if in-valid
 */
bool OKrow(const struct sudoku *a, int x, int y, int v)
{
    int offset = x * a->N;
    for (int j = 0; j < a->N; j++)
        if (a->a[offset + j] == v)
            // if the value is found in the row
            return false;
    return true;
}

/**
 * Check if `y`^th column is valid
 * @param a ::sudoku to check
 * @param x ignored row
 * @param y column to check
 * @param v value to check if it repeats
 * @returns `true` if valid
 * @returns `false` if in-valid
 */
bool OKcol(const struct sudoku *a, int x, int y, int v)
{
    for (int i = 0; i < a->N; i++)
        if (a->a[i * a->N + y] == v)
            // if the value is found in the column
            return false;
    return true;
}

/**
 * Check if a 3x3 box is valid
 * @param a matrix to check
 * @param x row index of the element to check
 * @param y column index of the element to check
 * @param v value to check if it repeats
 * @returns `true` if valid
 * @returns `false` if in-valid
 */
bool OKbox(const struct sudoku *a, int x, int y, int v)
{
    /* get start indices of the box that the current (x,y) lies in
       remember that in C/C++, division operation always rounds towards
       -infinity for signed integers and towards 0 for unsigned integers
    */
    int bi = x - x % a->N2, bj = y - y % a->N2;
    // printf("Checking box: (%d,%d)\n", bi, bj);

    for (int i = bi; i < (bi + a->N2); i++)
        for (int j = bj; j < (bj + a->N2); j++)
            if (a->a[i * a->N + j] == v)
                // if the value is found in the box
                return false;
    return true;
}

/**
 * Check if element `v` is valid to place at (x,y) location.
 * @param a ::sudoku to check
 * @param x row to place value
 * @param y column to place value
 * @param v value to check if it is valid
 * @returns `true` if valid
 * @returns `false` if in-valid
 */
bool OK(const struct sudoku *a, int x, int y, int v)
{
    bool result = OKrow(a, x, y, v);
    if (result)
        result = OKcol(a, x, y, v);
    if (result)
        result = OKbox(a, x, y, v);

    return result;
}

/**
 * Print the matrix to stdout
 * @param [in] a array to print
 */
void print(const struct sudoku *a)
{
    int i, j;
    for (i = 0; i < a->N; i++)
        for (j = 0; j < a->N; j++)
            printf("%" SCNu8 "%c", a->a[i * a->N + j],
                   (j == a->N - 1 ? '\n' : ' '));
}

/**
 * @brief Find and get the location for next empty cell.
 *
 * @param [in] a pointer to sudoku instance
 * @param [out] x pointer to row index of next unknown
 * @param [out] y pointer to column index of next unknown
 * @returns `true` if an empty location was found
 * @returns `false` if no more empty locations found
 */
bool get_next_unknown(const struct sudoku *a, int *x, int *y)
{
    for (int i = 0; i < a->N; i++)
    {
        for (int j = 0; j < a->N; j++)
        {
            if (a->a[i * a->N + j] == 0)
            {
                *x = i;
                *y = j;
                return true;
            }
        }
    }

    /* no unknown locations found */
    return false;
}

/**
 * @brief Function to solve a partially filled sudoku matrix. For each unknown
 * value (0), the function fills a possible value and calls the function again
 * to check forvalid solution.
 *
 * @param [in,out] a sudoku matrix to solve
 * @return `true` if solution found
 * @return `false` if no solution found
 */
bool solve(struct sudoku *a)
{
    static uint32_t counter = 0;
    int i, j;
    static char prefix[100] = "";  // enough memory

    if (!get_next_unknown(a, &i, &j))
    {
        /* no more empty location found
           implies all good in the matrix
         */
        return true;
    }

    /* try all possible values for the unknown */
    for (uint8_t v = 1; v <= a->N; v++)
    { /* try all possible values 1 thru N */
        printf("%sTry (%d,%d) = %" SCNu8 "... ", prefix, i, j, v);
        counter++;
        if (OK(a, i, j, v))
        {
            /* if assignment checks satisfy, set the value and
             continue with remaining elements */
            printf("passed (counter=%" SCNu32 ")\n", counter);
            a->a[i * a->N + j] = v;
            strcat(prefix, "  ");
            if (solve(a))
            {
                /* solution found */
                return true;
            }

            printf("%sBacktrack (%d,%d) <- %" SCNu8 " (counter=%" SCNu32 ")\n",
                   prefix, i, j, a->a[i * a->N + j], counter);

            prefix[strlen(prefix) - 2] = '\0';  // truncate the prefix
            a->a[i * a->N + j] = 0;
        }
        else
        {
            printf("\r");
        }
    }

    return false;
}

/** @} */

void test()
{
    printf("Test begin...\n");

    uint8_t test_array[] = {3, 0, 6, 5, 0, 8, 4, 0, 0, 5, 2, 0, 0, 0, 0, 0, 0,
                            0, 0, 8, 7, 0, 0, 0, 0, 3, 1, 0, 0, 3, 0, 1, 0, 0,
                            8, 0, 9, 0, 0, 8, 6, 3, 0, 0, 5, 0, 5, 0, 0, 9, 0,
                            6, 0, 0, 1, 3, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0,
                            0, 0, 7, 4, 0, 0, 5, 2, 0, 6, 3, 0, 0};
    struct sudoku a = {.N = 9, .N2 = 3, .a = test_array};
    assert(solve(&a));  // ensure that solution is obtained

    uint8_t expected[] = {3, 1, 6, 5, 7, 8, 4, 9, 2, 5, 2, 9, 1, 3, 4, 7, 6,
                          8, 4, 8, 7, 6, 2, 9, 5, 3, 1, 2, 6, 3, 4, 1, 5, 9,
                          8, 7, 9, 7, 4, 8, 6, 3, 1, 2, 5, 8, 5, 1, 7, 9, 2,
                          6, 4, 3, 1, 3, 8, 9, 4, 7, 2, 5, 6, 6, 9, 2, 3, 5,
                          1, 8, 7, 4, 7, 4, 5, 2, 8, 6, 3, 1, 9};
    for (int i = 0; i < a.N; i++)
        for (int j = 0; j < a.N; j++)
            assert(a.a[i * a.N + j] == expected[i * a.N + j]);

    printf("Test passed\n");
}

/** \brief Main function */
int main()
{
    test();

    struct sudoku a;  // store the matrix as a 1D array
    scanf("%" SCNu8, &(a.N));
    a.a = (uint8_t *)malloc(a.N * a.N * sizeof(uint8_t));
    a.N2 = (uint8_t)sqrt(a.N);

    for (int i = 0; i < a.N; i++)
        for (int j = 0; j < a.N; j++) scanf("%" SCNu8, &(a.a[i * a.N + j]));

    printf("Entered a %udx%ud matrix with block size: %" SCNu8 "\n", a.N, a.N,
           a.N2);
    // print(&a);
    printf("\n\n");
    if (solve(&a))
        printf("Valid solution found!\n");
    else
        printf("Invalid\n");
    print(&a);

    free(a.a);
    return 0;
}
/**
 * @file
 * @brief Strong number is a number whose sum of all digits’ factorial is equal
 * to the number n For example: 145 = 1!(1) + 4!(24) + 5!(120)
 */
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>

/**
 * Check if given number is strong number or not
 * @param number
 * @return `true` if given number is strong number, otherwise `false`
 */
bool isStrong(int number)
{
    if (number < 0)
    {
        return false;
    }
    int sum = 0;
    int originalNumber = number;
    while (originalNumber != 0)
    {
        int remainder = originalNumber % 10;
        int factorial = remainder == 0 ? 0 : 1; /* 0! == 1 */

        /* calculate factorial of n */
        for (int i = 1; i <= remainder; factorial *= i, i++)
        {
            ;
        }
        sum += factorial;
        originalNumber /= 10;
    }
    return number == sum;
}

/**
 * Test function
 * @return void
 */
void test()
{
    assert(isStrong(145));  /* 145 = 1! + 4! + 5! */
    assert(!isStrong(543)); /* 543 != 5!+ 4! + 3! */
}

/**
 * Driver Code
 * @return None
 */
int main()
{
    test();
    return 0;
}
#include <stdio.h>
int main()
{
    int a[200], n, counter, temp, i;
    a[0] = 1;
    counter = 0;
    printf("Enter a whole number to Find its Factorial: ");
    scanf("%d", &n);
    if (n < 0)
        printf("Cannot Calculate factorials for negative numbers.");
    else
    {
        for (; n >= 2; n--)
        {
            temp = 0;
            for (i = 0; i <= counter; i++)
            {
                temp = (a[i] * n) + temp;
                a[i] = temp % 10;
                temp = temp / 10;
            }
            while (temp > 0)
            {
                a[++counter] = temp % 10;
                temp = temp / 10;
            }
        }
        for (i = counter; i >= 0; i--) printf("%d", a[i]);
    }
    return 0;
}
/**
    @file
    @author [Krishna Vedala](https://github.com/kvedala)
    @date 2 October, 2019
    @brief Compute \f$m^{mth}\f$ Fibonacci number using the formulae:
    \f{eqnarray*}{
        F_{2n-1} &=& F_n^2 + F_{n-1}^2 \\
        F_{2n}   &=& F_n\left(2F_{n-1} + F_n\right)
   \f}
*/

#include <locale.h>
#include <stdio.h>
#include <stdlib.h>

/**
 * Get the \f$n^{th}\f$ and \f$n+1^{th}\f$ Fibonacci number using recursive
 * half-interval decimation.
 * \param [in] n index of Fibonacci number to get
 * \param [out] C left half interval value - end result here. Cannot be NULL
 * \param [out] D right half interval can be discarded at end and can be NULL
 */
void fib(unsigned long n, unsigned long *C, unsigned long *D)
{
    // Out of Range checking
    // commented out since `n` is unsigned integer
    // if (n < 0)
    // {
    //     printf("\nNo Such term !\n");
    //     exit(0);
    // }

    unsigned long a, b, c, d;

    if (n == 0)
    {
        C[0] = 0;
        if (D) /* if D is not NULL */
            D[0] = 1;
        return;
    }

    fib(n >> 1, &c, &d); /* Compute F(n/2) */

    a = c * ((d << 1) - c);
    b = c * c + d * d;
    if (n % 2 == 0) /* If n is even */
    {
        C[0] = a;
        if (D)
            D[0] = b;
        return;
    }

    /**< If n is odd */
    C[0] = b;
    if (D) /* if D is not NULL */
        D[0] = a + b;
    return;
}

/**
 * main function
 */
int main(int argc, char *argv[])
{
    unsigned long number, result;

    setlocale(LC_NUMERIC, "");  // format the printf output

    // Asks for the number/position of term in Fibonnacci sequence
    if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf("Enter the value of n(n starts from 0 ): ");
        scanf("%lu", &number);
    }

    fib(number, &result, NULL);

    printf("The nth term is : %'lu \n", result);

    return 0;
}
/**
 * @file
 * @brief Program to identify if a number is [palindrome
 * number](https://en.wikipedia.org/wiki/Palindrome) or not.
 * @see project_euler/problem_4/sol1.c
 */
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>

bool isPalindrome(int number);

/** Driver Code */
int main()
{
    assert(isPalindrome(0));
    assert(isPalindrome(1));
    assert(isPalindrome(12321));
    assert(!isPalindrome(1234));
    return 0;
}

/**
 * Check given number whether is palindrome number or not
 * @param number number to check
 * @return `true` if given number is palindrome number
 * @return `false` if number is not a palindrome number
 */
bool isPalindrome(int number)
{
    int reversedNumber = 0;
    int originalNumber = number;
    while (number != 0)
    {
        int remainder = number % 10;
        reversedNumber = reversedNumber * 10 + remainder;
        number /= 10;
    }
    return originalNumber == reversedNumber;
}
#include <stdio.h>
#include <string.h>  // we include the library string.h to the use of string

void saisie(
    char *cpointeur);  // Prototypes of the three functions used in the program
int compte(char *s);
char *miroir(char *s);

int main(int argc, char *argv[])
{
    char chaine[20];
    saisie(chaine);
    printf("miroir est %s", miroir(chaine));
}
// this function is used to put a string
void saisie(char *cpointeur)
{
    printf("saisir une chaine\n");
    scanf("%s", cpointeur);
}
/* the function miroir (in french ) it means "mirror" , the major idea is to
permute the first caractere with the last using an auxilary variable (aux) the
the 2nd character with the penultimate one and so on . we made a call to the
function (compte) which counts the length of the string . As you can see clearly
, I substruct 1 from the equation k = compte(s)-1 ; to get rid of the EOF
caractere which is '\0' because it is not a caractere from the string typed */
char *miroir(char *s)
{
    int i;
    char aux;
    int k;
    k = compte(s) - 1;
    i = 0;
    while (i <= k)
    {
        aux = s[i];
        s[i] = s[k];
        s[k] = aux;
        k--;
        i++;
    }

    return s;
}

// compte plays the role of strlen so we can change it by an strlen function if
// you want that
int compte(char *s)
{
    char *p;
    int k;
    p = s;
    k = 0;
    while (*p != '\0')
    {
        p++;
        k++;
    }
    return k;
}
/**
 * @file
 * @brief Program to identify if a number is [prime
 * number](https://en.wikipedia.org/wiki/Prime_number) or not
 */
#include <assert.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>

/**
 * Check if a given number is prime number or not
 * @param x number to check
 * @return `true` if given number is prime number, otherwise `false`
 */
bool isPrime(int x)
{
    if (x == 2)
    {
        return true;
    }
    if (x < 2 || x % 2 == 0)
    {
        return false;
    }

    double squareRoot = sqrt(x);

    for (int i = 3; i <= squareRoot; i += 2)
    {
        if (x % i == 0)
        {
            return false;
        }
    }
    return true;
}

/**
 * Test function
 * @return void
 */
void test()
{
    /* all the prime numbers less than 100 */
    int primers[] = {2,  3,  5,  7,  11, 13, 17, 19, 23, 29, 31, 37, 41,
                     43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};
    for (size_t i = 0, size = sizeof(primers) / sizeof(primers[0]); i < size;
         ++i)
    {
        assert(isPrime(primers[i]));
    }

    /* Example Non-prime numbers */
    int NonPrimers[] = {-1, 0, 1, 4, 6, 8, 9, 10};
    for (size_t i = 0, size = sizeof(NonPrimers) / sizeof(NonPrimers[0]);
         i < size; ++i)
    {
        assert(!isPrime(NonPrimers[i]));
    }
}

/**
 * Driver Code
 * @return None
 */
int main()
{
    test();
    return 0;
}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int a[10], n, i, j, temp;
    float q1, q3, iqr;

    printf("Enter no. for Random Numbers :");
    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
    }
    printf("Random Numbers Generated are :\n");
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }
    printf("\n");
    printf("\nSorted Data:");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            if (a[i] < a[j])
            {
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }
    q1 = a[n / 4];
    printf("\nFirst Quartile : %f", q1);
    q3 = a[(3 * n) / 4];
    printf("\nThird Quartile : %f", q3);
    iqr = q3 - q1;
    printf("\nInterQuartile Range is : %f", iqr);

    return 0;
}/**
 * @file
 * @brief [Postfix evaluation algorithm](https://www.includehelp.com/c/evaluation-of-postfix-expressions-using-stack-with-c-program.aspx) implementation
 * @details
 * The input postfix expression is of type string upto 49 characters (including space delimiters).
 * Supported operations- '+', '-', '/', '*', '%'
 * @author [Kumar Yash](https://github.com/kumaryash18)
 */
 
#include <stdio.h>	/// for IO operations
#include <string.h>	/// for strlen()
#include <ctype.h>	/// for isdigit()
#include <stdlib.h>	/// for exit()
#include <stdint.h>	/// for int8_t
#include <assert.h>	/// for assert

/**
 * @brief array implementation of stack using structure
 */
struct Stack {
	int8_t stack[20];		///< array stack
	int top;		///< stores index of the top element
};
struct Stack st;		///< global declaration of stack st

/**
 * @brief Function to push on the stack
 * @param opd number to be pushed in the stack
 * @returns void
 */
void push(int8_t opd) {
	if(st.top == 19)	{		// overflow condition
		printf("Stack overflow...");
		exit(1);
	}
	st.top++;
	st.stack[st.top] = opd;
}

/**
 * @brief Function to pop from the stack
 * @returns popped number
 */
int8_t pop() {
	int8_t item;				///< to store the popped value to be returned
	if(st.top == -1) {		// underflow condition
		printf("Stack underflow...");
		exit(1);
	}
	item = st.stack[st.top];
	st.top--;
	return item;
}

/**
 * @brief Function to evaluate postfix expression
 * @param post the input postfix expression
 * @returns evaluated answer
 */
int8_t evaluate(char post[]) {
	int8_t it1;
	int8_t it2;
	int8_t temp;
	int8_t number;
    int i;
    for(i = 0; i < strlen(post); i++) {
		if(post[i] == ' ') {
			continue;			// ignore delimiter
		}
		else if(isdigit(post[i])) {
			number = 0;
			do {
				number = number * 10 + (post[i]-'0');
				i++;
			} while(i < strlen(post) && isdigit(post[i]));
			push(number);
		}
		else {
			it2 = pop();
			it1 = pop();
			switch(post[i]) {
				case '+':
				temp = it1 + it2; break;
				case '-':
				temp = it1 - it2; break;
				case '*':
				temp = it1 * it2; break;
				case '/':
				temp = it1 / it2; break;
				case '%':
				temp = it1 % it2; break;
				default:
				printf("Invalid operator"); exit(1);
			}
			push(temp);
		}
	}
	return pop();
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test() {
    /* check sample test case
	   input: "2 10 + 9 6 - /"
	   expected output: 4
	 */
	char temp1[50] = "2 10 + 9 6 - /";
	assert(evaluate(temp1) == 4); 			/// this ensures that the algorithm works as expected
	/* input: "4 2 + 3 5 1 - * +"
	   expected output: 18
	 */
	char temp2[50] = "4 2 + 3 5 1 - * +";
	assert(evaluate(temp2) == 18); 			/// this ensures that the algorithm works as expected
	printf("All tests have successfully passed!\n");
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main() {
	st.top = -1;			/// initialize
	test();				/// run self-test implementations
	return 0;
}
#include <math.h>
#include <stdio.h>

float lerp(float k0, float k1, float t) { return k0 + t * (k1 - k0); }

float lerp_precise(int k0, int k1, float t) { return (1 - t) * k0 + t * k1; }

int main()
{
    float start = 0;
    float finish = 5;
    float steps = 0;

    printf("Input a number, this is the bigger bound of the lerp:\n");
    scanf("%f", &finish);

    printf(
        "Input a number, this is in how many steps you want to divide the "
        "lerp:\n");
    scanf("%f", &steps);

    for (int i = 0; i < steps + 1; i++)
    {
        printf("%f\n", lerp(start, finish, i / steps));
    }

    return 0;
}
// Fibonacci Series using Dynamic Programming

/* Author: Moinak Banerjee(moinak878)
   Date : 1 October ,2019
*/

#include <stdio.h>
#include <stdlib.h>

int fib(int n)
{
    // Out of Range checking
    if (n < 0)
    {
        printf("\nNo Such term !\n");
        exit(0);
    }
    // declaring array to store fibonacci numbers -- memoization
    int *f = (int *)malloc(
        (n + 2) * sizeof(int));  //  one extra to handle edge case, n = 0
    int i;

    /* let 0th and 1st number of the series be 0 and 1*/
    f[0] = 0;
    f[1] = 1;

    for (i = 2; i <= n; i++)
    {
        // Adding the previous 2 terms to make the 3rd term
        f[i] = f[i - 1] + f[i - 2];
    }

    int out = f[n];
    free(f);
    return out;
}

int main(int argc, char *argv[])
{
    int number;

    // Asks for the number/position of term in Fibonnacci sequence
    if (argc == 2)
        number = atoi(argv[1]);
    else
    {
        printf("Enter the value of n(n starts from 0 ): ");
        scanf("%d", &number);
    }

    printf("The nth term is : %d \n", fib(number));

    return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void swap(char *left, char *right)
{
    char temp = *left;
    *left = *right;
    *right = temp;
}

int compare(const void *a, const void *b) { return (*(char *)a - *(char *)b); }

void PrintSortedPermutations(char *str)
{
    int strSize = strlen(str);
    qsort(str, strSize, sizeof(char), compare);

    int largerPermFound = 1;
    do
    {
        // 1. Print permutation
        printf("%s\n", str);
        // 2. Find rightmost char that is smaller than char to its right
        int i;
        for (i = strSize - 2; i >= 0 && str[i] >= str[i + 1]; --i)
        {
        }

        // if we couldn't find one, we're finished, else we can swap
        if (i >= 0)
        {
            // 3. find character at index j such that str[j] = min(str[k]) &&
            // str[k] > str[i] for all k > i
            int j = i + 1, k;
            for (k = j; k < strSize && str[k]; k++)
            {
                if (str[k] > str[i] && str[k] < str[j])
                    j = k;
            }
            // 3. Swap chars at i and j
            swap(&str[i], &str[j]);
            // 4. Sort string to the right of i
            qsort(str + i + 1, strSize - i - 1, sizeof(char), compare);
        }
        else
            largerPermFound = 0;
    } while (largerPermFound);
}

int main()
{
    int n;  // size of string
    scanf("%d\n", &n);
    if (n <= 0 || n >= 1000)
    {
        perror("Input number out of range: >0 and <1000\n");
        return -1;
    }
    char *str = (char *)malloc(n * sizeof(char));
    scanf("%s", str);
    PrintSortedPermutations(str);
    free(str);
    return 0;
}
/*
code for computing nth catalan number
*/
#include <stdio.h>
long int factorial(int x)  // long int for more than 10 factorial
{
    int i;
    long int fac;  // fac stores x factorial
    fac = x;
    for (i = 1; i < x; i++)  // loop to calculate x factorial
    {
        fac = fac * (x - i);
    }
    return fac;  // returning x factorial
}
int main()
{
    long int f1, f2, f3;  // long int for more than 10 factorial
    int n;
    float C;  // C is catalan number for n;
    scanf("%d", &n);
    f1 = factorial(2 * n);
    f2 = factorial(n + 1);
    f3 = factorial(n);
    C = f1 / (f2 * f3);  // formula for catalan number for n
    printf("%0.2f", C);
    return 0;
}
/**
 * @file
 * @brief Program to generate [Cantor ternary
 * set](https://en.wikipedia.org/wiki/Cantor_set)
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/** structure to define Cantor set */
typedef struct _cantor_set
{
    double start;             /**< start of interval */
    double end;               /**< end of interval */
    struct _cantor_set *next; /**< pointer to next set */
} CantorSet;

/** Iterative constructor of all sets in the current level. This function
 * dynamically allocates memory when creating new sets. These are freed by the
 * function ::free_memory.
 * @param head pointer to interval set instance to update
 */
void propagate(CantorSet *head)
{
    // if input is NULL, ignore the process
    if (head == NULL)
        return;

    CantorSet *temp = head;  // local pointer to track propagation

    // create new node for the new set
    CantorSet *newNode = (CantorSet *)malloc(sizeof(CantorSet));

    // get 1/3rd of interval
    double diff = (((temp->end) - (temp->start)) / 3);

    // update interval ranges
    newNode->end = temp->end;
    temp->end = ((temp->start) + diff);
    newNode->start = (newNode->end) - diff;

    // update pointer to next set in this level
    newNode->next = temp->next;

    // point to next set
    temp->next = newNode;

    // create next set
    propagate(temp->next->next);
}

/** Print sets in the current range to `stdout`
 * @param head pointer to first set in the current level
 */
void print(CantorSet *head)
{
    CantorSet *temp = head;
    while (temp != NULL)  // print while a valid set is found
    {
        printf("\t");
        printf("[%lf] -- ", temp->start);
        printf("[%lf]", temp->end);
        temp = temp->next;
    }

    printf("\n");
}

/** Clear memory allocated by ::propagate function.
 * @param head pointer to first allocated instance.
 */
void free_memory(CantorSet *head)
{
    if (!head)
        return;

    if (head->next)
        free_memory(head->next);

    free(head);
}

/** Main function */
int main(int argc, char const *argv[])
{
    int start_num, end_num, levels;

    if (argc < 2)
    {
        printf("Enter 3 arguments: start_num \t end_num \t levels\n");
        scanf("%d %d %d", &start_num, &end_num, &levels);
    }
    else
    {
        start_num = atoi(argv[1]);
        end_num = atoi(argv[2]);
        levels = atoi(argv[3]);
    }

    if (start_num < 0 || end_num < 0 || levels < 0)
    {
        fprintf(stderr, "All numbers must be positive\n");
        return -1;
    }

    CantorSet head = {.start = start_num, .end = end_num, .next = NULL};

    // loop to propagate each level from top to bottom
    for (int i = 0; i < levels; i++)
    {
        printf("Level %d\t", i);
        print(&head);
        propagate(&head);
        printf("\n");
    }
    printf("Level %d\t", levels);
    print(&head);

    // delete all memory allocated
    free_memory(head.next);

    return 0;
}
#include <stdio.h>

int main()
{
    int n, sum = 0, i, num;
    printf("Enter number: ");
    scanf("%d", &n);
    num = n;
    while (n != 0)
    {
        i = n % 10;
        sum = sum + (i * i * i);
        n = n / 10;
    }
    if (sum == num)
    {
        printf("%d is an armstrong number!\n", num);
    }
    else
    {
        printf("%d is not an armstrong number!\n", num);
    }
    return 0;
}
/**
 * @file
 * @author [NVombat](https://github.com/NVombat)
 * @brief Server-side implementation of [TCP Half Duplex
 * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)
 * @see tcp_half_duplex_server.c
 *
 * @details
 * The algorithm is based on the simple TCP client and server model. However,
 * instead of the server only sending and the client only receiving data,
 * The server and client can both send data but only one at a time. This is
 * implemented by using a particular ordering of the `send()` and `recv()`
 * functions. When one of the clients or servers is sending, the other can only
 * receive and vice-versa. In this way, the Half Duplex Form of communication
 * can be represented using the TCP server-client model & socket programming
 */

#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 8100  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t sockfd,
        conn;  ///< socket descriptors - Like file handles but for sockets
    char server_msg[10000],
        client_msg[10000];  ///< character arrays to read and store string data
                            /// for communication
    struct sockaddr_in server_addr,
        client_addr;  ///< asic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses

    /**
     * The TCP socket is created using the socket function
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();  ///< Error if the socket descriptor has a value lower than 0 -
                  /// socket wasnt created
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;    /// Domain/Family to be used
    server_addr.sin_port = htons(PORT);  /// Port to be used
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf("Server is running...\n");

    /**
     * This binds the socket descriptor to the server thus enabling the server
     * to listen for connections and communicate with other clients
     */
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        error();  /// If binding is unsuccessful
    }

    /**
     * This is to listen for clients or connections made to the server
     *
     * The limit is currently at 5 but can be increased to listen for
     * more connections
     *
     * It listens to connections through the socket descriptor
     */
    listen(sockfd, 5);

    printf("Server is listening...\n");

    /**
     * When a connection is found, a socket is created and connection is
     * accepted and established through the socket descriptor
     */
    conn = accept(sockfd, (struct sockaddr *)NULL, NULL);

    printf("Server is connected...\n");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * First the SERVER is prompted to type a message which is read from
     * stdin and then sent over the connection that was established - the socket
     * - to be received by the client (send())
     *
     * The SERVER then waits for the client to reply. It then receives the reply
     * in the string variable and displays it (recv())
     *
     * The server and client can communicate till one of them exits the
     * connection
     *
     * Since the exchange of information between the server and client take
     * place one at a time this represents HALF DUPLEX COMMUNICATION
     */
    while (1)
    {
        bzero(&server_msg, sizeof(server_msg));
        bzero(&client_msg, sizeof(client_msg));

        /// Send message
        printf("\nEnter message here: ");
        fgets(server_msg, 10000, stdin);
        send(conn, server_msg, strlen(server_msg) + 1, 0);

        /// Receive Message
        recv(conn, client_msg, sizeof(client_msg), 0);
        printf("\nClient Message: %s\n", client_msg);
    }

    /// Close socket
    close(sockfd);
    printf("Server is offline...\n");
    return 0;
}
/**
 * @file
 * @author [NVombat](https://github.com/NVombat)
 * @brief Server-side implementation of [Remote Command
 * Execution Using
 * UDP](https://www.imperva.com/learn/ddos/udp-user-datagram-protocol/)
 * @see remote_command_exec_udp_server.c
 *
 * @details
 * The algorithm is based on the simple UDP client and server model. It
 * runs an infinite loop which takes user input and sends it to the server
 * for execution. The server receives the commands and executes them
 * until the user exits the loop. In this way, Remote Command Execution
 * using UDP is shown using the server-client model & socket programming
 */

#include <arpa/inet.h>  /// For the type in_addr_t and in_port_t
#include <errno.h>      /// To indicate what went wrong if an error occurs
#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 10000  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    char recv_msg[1024],
        success_message[] =
            "Command Executed Successfully!\n";  ///< character arrays to read
                                                 /// and store string data
                                                 /// for communication & Success
                                                 /// message

    struct sockaddr_in server_addr,
        client_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    socklen_t clientLength = sizeof(client_addr);  /// size of address

    /**
     * The UDP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_DGRAM (Type) - Indicates UDP Connection - UDP does not require the
     * source and destination to establish a three-way handshake before
     * transmission takes place. Additionally, there is no need for an
     * end-to-end connection
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    /**
     * This binds the socket descriptor to the server thus enabling the server
     * to listen for connections and communicate with other clients
     */
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        error();  /// If binding is unsuccessful
    }

    printf("Server is Connected Successfully...\n");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * The server receives data from the client which is a command. It then
     * executes the command.
     *
     * The client then receives a response from the server when the
     * command has been executed
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * The client sends the server a command which it executes thus showing
     * remote command execution using UDP
     */
    while (1)
    {
        bzero(recv_msg, sizeof(recv_msg));
        recvfrom(sockfd, recv_msg, sizeof(recv_msg), 0,
                 (struct sockaddr *)&client_addr, &clientLength);
        printf("Command Output: \n");
        system(recv_msg);
        printf("Command Executed\n");
        sendto(sockfd, success_message, sizeof(success_message), 0,
               (struct sockaddr *)&client_addr, clientLength);
    }

    /// Close socket
    close(sockfd);
    printf("Server is offline...\n");
    return 0;
}
/**
 * @file
 * @author [TheShubham99](https://github.com/TheShubham99)
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief Server side implementation of UDP client-server model
 * @see client_server/udp_client.c
 */
#ifdef _WIN32                            // if compiling for Windows
#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next
                                         // MSVC compiler versions
#define close closesocket                /**< map BSD name to Winsock */
#include <winsock2.h>
#else  // if not windows platform
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PORT 8080    /**< port number to connect to */
#define MAXLINE 1024 /**< maximum characters per line */

#ifdef _WIN32
/** Cleanup function will be automatically called on program exit */
void cleanup() { WSACleanup(); }
#endif

/** Driver code */
int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror("WSA Startup error: \n");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd;
    char buffer[MAXLINE];
    char *hello = "Hello from server";
    struct sockaddr_in servaddr, cliaddr;

    // Creating socket file descriptor
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));
    memset(&cliaddr, 0, sizeof(cliaddr));

    // Filling server information
    servaddr.sin_family = AF_INET;  // IPv4
    servaddr.sin_addr.s_addr = INADDR_ANY;
    servaddr.sin_port = htons(PORT);

    // Bind the socket with the server address
    if (bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    unsigned int len;
    int n;
    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,
                 (struct sockaddr *)&cliaddr, &len);
    buffer[n] = '\0';
    printf("Client : %s\n", buffer);
    sendto(sockfd, (const char *)hello, strlen(hello), 0,
           (const struct sockaddr *)&cliaddr, len);
    printf("Hello message sent.\n");

    close(sockfd);

    return 0;
}
/**
 * @file
 * @author [NVombat](https://github.com/NVombat)
 * @brief Server-side implementation of [TCP Full Duplex
 * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)
 * @see tcp_full_duplex_server.c
 *
 * @details
 * The algorithm is based on the simple TCP client and server model. However,
 * instead of the server only sending and the client only receiving data,
 * The server and client can both send and receive data simultaneously. This is
 * implemented by using the `fork` function call so that in the server the child
 * process can recieve data and  parent process can send data, and in the client
 * the child process can send data and the parent process can receive data. It
 * runs an infinite loop and can send and receive messages indefinitely until
 * the user exits the loop. In this way, the Full Duplex Form of communication
 * can be represented using the TCP server-client model & socket programming
 */

#include <arpa/inet.h>  /// For the type in_addr_t and in_port_t
#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 10000  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t sockfd,
        conn;  ///< socket descriptors - Like file handles but for sockets
    char recvbuff[1024],
        sendbuff[1024];  ///< character arrays to read and store string data
                         /// for communication

    struct sockaddr_in server_addr,
        client_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    socklen_t ClientLen;  /// size of address

    /**
     * The TCP socket is created using the socket function
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();  ///< Error if the socket descriptor has a value lower than 0 -
                  /// socket wasnt created
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf("Server is running...\n");

    /**
     * This binds the socket descriptor to the server thus enabling the server
     * to listen for connections and communicate with other clients
     */
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        error();  /// If binding is unsuccessful
    }
    /**
     * This is to listen for clients or connections made to the server
     *
     * The limit is currently at 5 but can be increased to listen for
     * more connections
     *
     * It listens to connections through the socket descriptor
     */
    listen(sockfd, 5);

    printf("Server is listening...\n");

    /**
     * When a connection is found, a socket is created and connection is
     * accepted and established through the socket descriptor
     */
    conn = accept(sockfd, (struct sockaddr *)NULL, NULL);

    printf("Server is connected...\n");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * The fork function call is used to create a child and parent process
     * which run and execute code simultaneously
     *
     * The child process is used to receive data and after doing so
     * sleeps for 5 seconds to wait for the parent to send data
     *
     * The parent process is used to send data and after doing so
     * sleeps for 5 seconds to wait for the child to receive data
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * Since the exchange of information between the server and client takes
     * place simultaneously this represents FULL DUPLEX COMMUNICATION
     */
    pid_t pid;
    pid = fork();
    if (pid == 0)  /// Value of 0 is for child process
    {
        while (1)
        {
            bzero(&recvbuff, sizeof(recvbuff));
            recv(conn, recvbuff, sizeof(recvbuff), 0);
            printf("\nCLIENT : %s\n", recvbuff);
            sleep(5);
            // break;
        }
    }
    else  /// Parent process
    {
        while (1)
        {
            bzero(&sendbuff, sizeof(sendbuff));
            printf("\nType message here: ");
            fgets(sendbuff, 1024, stdin);
            send(conn, sendbuff, strlen(sendbuff) + 1, 0);
            printf("\nMessage Sent!\n");
            sleep(5);
            // break;
        }
    }

    /// Close socket
    close(sockfd);
    printf("Server is offline...\n");
    return 0;
}
/**
 * @file
 * @author [Nairit11](https://github.com/Nairit11)
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief Server side implementation of Server-Client system.
 * @see client_server/client.c
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// #ifdef HAS_UNISTD
// #include <unistd.h>
// #endif

#ifdef _WIN32
#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next
                                         // MSVC compiler versions
#include <winsock2.h>
#define bzero(b, len) \
    (memset((b), '\0', (len)), (void)0) /**< BSD name not in windows */
#define read(a, b, c) recv(a, b, c, 0)  /**< map BSD name to Winsock */
#define write(a, b, c) send(a, b, c, 0) /**< map BSD name to Winsock */
#define close closesocket               /**< map BSD name to Winsock */
#else
// if not windows platform
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#endif

#define MAX 80             /**< max. characters per message */
#define PORT 8080          /**< port number to connect to */
#define SA struct sockaddr /**< shortname for sockaddr */

#ifdef _WIN32
/** Cleanup function will be automatically called on program exit */
void cleanup() { WSACleanup(); }
#endif

/**
 * Continuous loop to send and receive over the socket.
 * Exits when "exit" is sent from commandline.
 * @param sockfd socket handle number
 */
void func(int sockfd)
{
    char buff[MAX];
    int n;
    // infinite loop for chat
    for (;;)
    {
        bzero(buff, MAX);

        // read the message from client and copy it in buffer
        read(sockfd, buff, sizeof(buff));
        // print buffer which contains the client contents
        printf("From client: %s\t To client : ", buff);
        bzero(buff, MAX);
        n = 0;
        // copy server message in the buffer
        while ((buff[n++] = getchar()) != '\n')
        {
            ;
        }

        // and send that buffer to client
        write(sockfd, buff, sizeof(buff));

        // if msg contains "Exit" then server exit and chat ended.
        if (strncmp("exit", buff, 4) == 0)
        {
            printf("Server Exit...\n");
            break;
        }
    }
}

/** Driver code */
int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror("WSA Startup error: \n");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd, connfd;
    unsigned int len;
    struct sockaddr_in servaddr, cli;

    // socket create and verification
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1)
    {
        perror("socket creation failed...\n");
        exit(0);
    }
    else
    {
        printf("Socket successfully created..\n");
    }
    bzero(&servaddr, sizeof(servaddr));

    // assign IP, PORT
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(PORT);

    // Binding newly created socket to given IP and verification
    if ((bind(sockfd, (SA *)&servaddr, sizeof(servaddr))) != 0)
    {
        perror("socket bind failed...\n");
        exit(0);
    }
    else
    {
        printf("Socket successfully binded..\n");
    }

    // Now server is ready to listen and verification
    if ((listen(sockfd, 5)) != 0)
    {
        perror("Listen failed...\n");
        exit(0);
    }
    else
    {
        printf("Server listening..\n");
    }
    len = sizeof(cli);

    // Accept the data packet from client and verification
    connfd = accept(sockfd, (SA *)&cli, &len);
    if (connfd < 0)
    {
        perror("server acccept failed...\n");
        exit(0);
    }
    else
    {
        printf("server acccept the client...\n");
    }

    // Function for chatting between client and server
    func(connfd);

    // After chatting close the socket
    close(sockfd);
    return 0;
}
/**
 * @file
 * @author [Nairit11](https://github.com/Nairit11)
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief Client side implementation of Server-Client system.
 * @see client_server/server.c
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32                            // if compiling for Windows
#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next
                                         // MSVC compiler versions
#include <winsock2.h>
#define bzero(b, len) \
    (memset((b), '\0', (len)), (void)0) /**< BSD name not in windows */
#define read(a, b, c) recv(a, b, c, 0)  /**< map BSD name to Winsock */
#define write(a, b, c) send(a, b, c, 0) /**< map BSD name to Winsock */
#define close closesocket               /**< map BSD name to Winsock */
#else                                   // if not windows platform
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#endif

#define MAX 80             /**< max. characters per message */
#define PORT 8080          /**< port number to connect to */
#define SA struct sockaddr /**< shortname for sockaddr */

/**
 * Continuous loop to send and receive over the socket.
 * Exits when "exit" is sent from commandline.
 * @param sockfd socket handle number
 */
void func(int sockfd)
{
    char buff[MAX];
    int n;
    for (;;)
    {
        bzero(buff, sizeof(buff));
        printf("Enter the string : ");
        n = 0;
        while ((buff[n++] = getchar()) != '\n')
        {
            ;
        }
        write(sockfd, buff, sizeof(buff));
        bzero(buff, sizeof(buff));
        read(sockfd, buff, sizeof(buff));
        printf("From Server : %s", buff);
        if ((strncmp(buff, "exit", 4)) == 0)
        {
            printf("Client Exit...\n");
            break;
        }
    }
}

#ifdef _WIN32
/** Cleanup function will be automatically called on program exit */
void cleanup() { WSACleanup(); }
#endif

/**
 * @brief Driver code
 */
int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror("WSA Startup error: \n");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd, connfd;
    struct sockaddr_in servaddr, cli;

    // socket create and verification
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1)
    {
        printf("socket creation failed...\n");
        exit(0);
    }
    else
    {
        printf("Socket successfully created..\n");
    }
    bzero(&servaddr, sizeof(servaddr));

    // assign IP, PORT
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
    servaddr.sin_port = htons(PORT);

    // connect the client socket to server socket
    if (connect(sockfd, (SA *)&servaddr, sizeof(servaddr)) != 0)
    {
        printf("connection with the server failed...\n");
        exit(0);
    }
    else
    {
        printf("connected to the server..\n");
    }

    // function for chat
    func(sockfd);

    // close the socket
    close(sockfd);
    return 0;
}
/**
 * @file
 * @author [NVombat](https://github.com/NVombat)
 * @brief Client-side implementation of [TCP Full Duplex
 * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)
 * @see tcp_full_duplex_server.c
 *
 * @details
 * The algorithm is based on the simple TCP client and server model. However,
 * instead of the server only sending and the client only receiving data,
 * The server and client can both send and receive data simultaneously. This is
 * implemented by using the `fork` function call so that in the server the child
 * process can recieve data and  parent process can send data, and in the client
 * the child process can send data and the parent process can receive data. It
 * runs an infinite loop and can send and receive messages indefinitely until
 * the user exits the loop. In this way, the Full Duplex Form of communication
 * can be represented using the TCP server-client model & socket programming
 */

#include <arpa/inet.h>  /// For the type in_addr_t and in_port_t
#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 10000  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    char sendbuff[1024],
        recvbuff[1024];  ///< character arrays to read and store string data
                         /// for communication

    struct sockaddr_in
        server_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses

    /**
     * The TCP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes.
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf("Client is running...\n");

    /**
     * Connects the client to the server address using the socket descriptor
     * This enables the two to communicate and exchange data
     */
    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));

    printf("Client is connected...\n");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * The fork function call is used to create a child and parent process
     * which run and execute code simultaneously
     *
     * The child process is used to send data and after doing so
     * sleeps for 5 seconds to wait for the parent to receive data
     *
     * The parent process is used to receive data and after doing so
     * sleeps for 5 seconds to wait for the child to send data
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * Since the exchange of information between the server and client takes
     * place simultaneously this represents FULL DUPLEX COMMUNICATION
     */
    pid_t pid;
    pid = fork();
    if (pid == 0)  /// Value of 0 is for child process
    {
        while (1)
        {
            bzero(&sendbuff, sizeof(sendbuff));
            printf("\nType message here: ");
            fgets(sendbuff, 1024, stdin);
            send(sockfd, sendbuff, strlen(sendbuff) + 1, 0);
            printf("\nMessage sent!\n");
            sleep(5);
            // break;
        }
    }
    else  /// Parent Process
    {
        while (1)
        {
            bzero(&recvbuff, sizeof(recvbuff));
            recv(sockfd, recvbuff, sizeof(recvbuff), 0);
            printf("\nSERVER: %s\n", recvbuff);
            sleep(5);
            // break;
        }
    }

    /// Close Socket
    close(sockfd);
    printf("Client is offline...\n");
    return 0;
}
/**
 * @file
 * @author [TheShubham99](https://github.com/TheShubham99)
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief Client side implementation of UDP client-server model
 * @see client_server/udp_server.c
 */
#ifdef _WIN32                            // if compiling for Windows
#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next
                                         // MSVC compiler versions
#include <winsock2.h>
#define close closesocket /**< map BSD name to Winsock */
#else                     // if not windows platform
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PORT 8080    /**< port number to connect to */
#define MAXLINE 1024 /**< maximum characters per line */

#ifdef _WIN32
/** Cleanup function will be automatically called on program exit */
void cleanup() { WSACleanup(); }
#endif

/** Driver code */
int main()
{
#ifdef _WIN32
    // when using winsock2.h, startup required
    WSADATA wsData;
    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)
    {
        perror("WSA Startup error: \n");
        return 0;
    }

    atexit(cleanup);  // register at-exit function
#endif

    int sockfd;
    char buffer[MAXLINE];
    char *hello = "Hello from client";
    struct sockaddr_in servaddr;

    // Creating socket file descriptor
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));

    // Filling server information
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(PORT);
    servaddr.sin_addr.s_addr = INADDR_ANY;

    int n;
    unsigned int len;

    sendto(sockfd, (const char *)hello, strlen(hello), 0,
           (const struct sockaddr *)&servaddr, sizeof(servaddr));
    printf("Hello message sent.\n");

    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,
                 (struct sockaddr *)&servaddr, &len);
    buffer[n] = '\0';
    printf("Server : %s\n", buffer);

    close(sockfd);
    return 0;
}
/**
 * @file
 * @author [NVombat](https://github.com/NVombat)
 * @brief Client-side implementation of [Remote Command
 * Execution Using
 * UDP](https://www.imperva.com/learn/ddos/udp-user-datagram-protocol/)
 * @see remote_command_exec_udp_server.c
 *
 * @details
 * The algorithm is based on the simple UDP client and server model. It
 * runs an infinite loop which takes user input and sends it to the server
 * for execution. The server receives the commands and executes them
 * until the user exits the loop. In this way, Remote Command Execution
 * using UDP is shown using the server-client model & socket programming
 */

#include <arpa/inet.h>  /// For the type in_addr_t and in_port_t
#include <errno.h>      /// To indicate what went wrong if an error occurs
#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 10000  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    char send_msg[1024],
        recv_msg[1024];  ///< character arrays to read and store string data
                         /// for communication

    struct sockaddr_in
        server_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    socklen_t serverLength = sizeof(server_addr);  ///< length of socket

    /**
     * The UDP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_DGRAM (Type) - Indicates UDP Connection - UDP does not require the
     * source and destination to establish a three-way handshake before
     * transmission takes place. Additionally, there is no need for an
     * end-to-end connection
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf("Client is running...\n");

    /**
     * Connects the client to the server address using the socket descriptor
     * This enables the two to communicate and exchange data
     */
    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));

    printf("Client is Connected Successfully...\n");

    /**
     * Communication between client and server
     *
     * The client sends data to the server after taking the input
     * from the user
     *
     * The client then receives a response from the server when the
     * command has been executed
     *
     * The server and client can communicate indefinitely till one of them
     * exits the connection
     *
     * The client sends the server a command which it executes thus showing
     * remote command execution using UDP
     */
    while (1)
    {
        printf("\nEnter Command To Be Executed Remotely: \n");
        fgets(send_msg, sizeof(send_msg), stdin);
        sendto(sockfd, send_msg, sizeof(send_msg), 0,
               (struct sockaddr *)&server_addr, serverLength);
        recvfrom(sockfd, recv_msg, sizeof(recv_msg), 0,
                 (struct sockaddr *)&server_addr, &serverLength);
        printf("Server Reply: %s\n", recv_msg);
    }

    /// Close Socket
    close(sockfd);
    printf("Client is offline...\n");
    return 0;
}
/**
 * @file
 * @author [Nikhill Vombatkere](https://github.com/NVombat)
 * @brief Client-side implementation of [TCP Half Duplex
 * Communication](http://www.tcpipguide.com/free/t_SimplexFullDuplexandHalfDuplexOperation.htm)
 * @see tcp_half_duplex_server.c
 *
 * @details
 * The algorithm is based on the simple TCP client and server model. However,
 * instead of the server only sending and the client only receiving data,
 * the server and client can both send data but only one at a time. This is
 * implemented by using a particular ordering of the `send()` and `recv()`
 * functions. When one of the clients or servers is sending, the other can only
 * receive and vice-versa. In this way, the Half Duplex Form of communication
 * can be represented using the TCP server-client model & socket programming
 */

#include <netdb.h>  /// For structures returned by the network database library - formatted internet addresses and port numbers
#include <netinet/in.h>  /// For in_addr and sockaddr_in structures
#include <stdint.h>      /// For specific bit size values of variables
#include <stdio.h>  /// Variable types, several macros, and various functions for performing input and output
#include <stdlib.h>  /// Variable types, several macros, and various functions for performing general functions
#include <string.h>  /// Various functions for manipulating arrays of characters
#include <sys/socket.h>  /// For macro definitions related to the creation of sockets
#include <sys/types.h>  /// For definitions to allow for the porting of BSD programs
#include <unistd.h>  /// For miscellaneous symbolic constants and types, and miscellaneous functions

#define PORT 8100  /// Define port over which communication will take place

/**
 * @brief Utility function used to print an error message to `stderr`.
 * It prints `str` and an implementation-defined error
 * message corresponding to the global variable `errno`.
 * @returns void
 */
void error()
{
    perror("Socket Creation Failed");
    exit(EXIT_FAILURE);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /** Variable Declarations */
    uint32_t
        sockfd;  ///< socket descriptors - Like file handles but for sockets
    struct sockaddr_in
        server_addr;  ///< basic structures for all syscalls and functions that
                      /// deal with internet addresses. Structures for handling
                      /// internet addresses
    char serverResponse[10000],
        clientResponse[10000];  ///< Character arrays to read and store string
                                /// data for communication

    /**
     * The TCP socket is created using the socket function.
     *
     * AF_INET (Family) - it is an address family that is used to designate the
     * type of addresses that your socket can communicate with
     *
     * SOCK_STREAM (Type) - Indicates TCP Connection - A stream socket provides
     * for the bidirectional, reliable, sequenced, and unduplicated flow of data
     * without record boundaries. Aside from the bidirectionality of data flow,
     * a pair of connected stream sockets provides an interface nearly identical
     * to pipes.
     *
     * 0 (Protocol) - Specifies a particular protocol to be used with the
     * socket. Specifying a protocol of 0 causes socket() to use an unspecified
     * default protocol appropriate for the requested socket type.
     */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        error();
    }

    /**
     * Server Address Information
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area.
     *
     * We bind the server_addr to the internet address and port number thus
     * giving our socket an identity with an address and port where it can
     * listen for connections
     *
     * htons - The htons() function translates a short integer from host byte
     * order to network byte order
     *
     * htonl - The htonl() function translates a long integer from host byte
     * order to network byte order
     *
     * These functions are necessary so that the binding of address and port
     * takes place with data in the correct format
     */
    bzero(&server_addr, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    printf("Client is running...\n");

    /**
     * Connects the client to the server address using the socket descriptor
     * This enables the two to communicate and exchange data
     */
    connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr));

    printf("Client is connected...\n");

    /**
     * Communication between client and server
     *
     * The bzero() function erases the data in the n bytes of the memory
     * starting at the location pointed to, by writing zeros (bytes
     * containing '\0') to that area. The variables are emptied and then
     * ready for use
     *
     * First the CLIENT receives the servers message and displays it (recv())
     *
     * The CLIENT is then prompted to type in a message and send it to the
     * server. (send())
     *
     * The server and client can communicate till one of them exits the
     * connection
     *
     * Since the exchange of information between the server and client take
     * place one at a time this represents HALF DUPLEX COMMUNICATION
     */
    while (1)
    {
        bzero(&serverResponse, sizeof(serverResponse));
        bzero(&clientResponse, sizeof(clientResponse));

        /// Receive Message
        recv(sockfd, serverResponse, sizeof(serverResponse), 0);
        printf("\nServer message: %s \n", serverResponse);

        /// Send Message
        printf("\nEnter message here: ");
        fgets(clientResponse, 10000, stdin);
        send(sockfd, clientResponse, strlen(clientResponse) + 1, 0);
    }

    /// Close Socket
    close(sockfd);
    printf("Client is offline...\n");
    return 0;
}
/**
 * Kyler Smith, 2017
 * Stack data structure implementation.
 */

////////////////////////////////////////////////////////////////////////////////
// INCLUDES
#include <stdio.h>
#include <stdlib.h>

////////////////////////////////////////////////////////////////////////////////
// MACROS: CONSTANTS

////////////////////////////////////////////////////////////////////////////////
// DATA STRUCTURES
/**
 * creating a stucture with 'data'(type:int), two pointers 'next','pre' (type: struct node) .
 */
struct node
{
    int data;
    struct node *next;
    struct node *pre;
} * head, *tmp;

////////////////////////////////////////////////////////////////////////////////
// GLOBAL VARIABLES
int count = 0;

////////////////////////////////////////////////////////////////////////////////
// FUNCTION PROTOTYPES
void create();
void push(int x);
int pop();
int peek();
int size();
int isEmpty();

////////////////////////////////////////////////////////////////////////////////
// MAIN ENTRY POINT

int main(int argc, char const *argv[])
{
    int x, y, z;

    create();
    push(4);
    x = pop();
    // 4. Count: 0. Empty: 1.
    printf("%d.\t\tCount: %d.\tEmpty: %d.\n", x, size(), isEmpty());

    push(1);
    push(2);
    push(3);
    x = pop();
    y = pop();
    // 3, 2. Count: 1. Empty: 0;
    printf("%d, %d.\t\tCount: %d.\tEmpty: %d.\n", x, y, size(), isEmpty());
    pop();  // Empty the stack.

    push(5);
    push(6);
    x = peek();
    push(7);
    y = pop();
    push(8);
    z = pop();
    // 1, 6, 7, 8. Count: 2. Empty: 0.
    printf("%d, %d, %d.\tCount: %d.\tEmpty: %d.\n", x, y, z, size(), isEmpty());

    return 0;
}

/**
 * Initialize the stack to NULL.
 */
void create() { head = NULL; }

/**
 * Push data onto the stack.
 */
void push(int x)
{
    if (head == NULL)
    {
        head = (struct node *)malloc(1 * sizeof(struct node));
        head->next = NULL;
        head->pre = NULL;
        head->data = x;
    }
    else
    {
        tmp = (struct node *)malloc(1 * sizeof(struct node));
        tmp->data = x;
        tmp->next = NULL;
        tmp->pre = head;
        head->next = tmp;
        head = tmp;
    }
    ++count;
}

/**
 * Pop data from the stack
 */
int pop()
{
    int returnData;
    if (head == NULL)
    {
        printf("ERROR: Pop from empty stack.\n");
        exit(1);
    }
    else
    {
        returnData = head->data;

        if (head->pre == NULL)
        {
            free(head);
            head = NULL;
        }
        else
        {
            head = head->pre;
            free(head->next);
        }
    }
    --count;
    return returnData;
}

/**
 * Returns the next value to be popped.
 */
int peek()
{
    if (head != NULL)
        return head->data;
    else
    {
        printf("ERROR: Peeking from empty stack.");
        exit(1);
    }
}

/**
 * Returns the size of the stack.
 */
int size() { return count; }

/**
 * Returns 1 if stack is empty, returns 0 if not empty.
 */
int isEmpty()
{
    if (count == 0)
        return 1;
    return 0;
}
/**
 * @addtogroup hash Hash algorithms
 * @{
 * @file hash_djb2.c
 * @author [Christian Bender](https://github.com/christianbender)
 * @brief [DJB2 hash algorithm](http://www.cse.yorku.ca/~oz/hash.html)
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>

/**
 * @brief DJB2 algorithm implementation
 *
 * @param s NULL terminated string to hash
 * @return 64-bit hash result
 */
uint64_t djb2(const char* s)
{
    uint64_t hash = 5381; /* init value */
    size_t i = 0;
    while (s[i] != '\0')
    {
        hash = ((hash << 5) + hash) + s[i];
        i++;
    }
    return hash;
}

/**
 * Test function for ::djb2
 * \returns none
 */
void test_djb2(void)
{
    assert(djb2("Hello World") == 13827776004929097857);
    assert(djb2("Hello World!") == 13594750393630990530);
    assert(djb2("Hello world") == 13827776004967047329);
    assert(djb2("Hello world!") == 13594750394883323106);
    printf("Tests passed\n");
}

/** @} */

/** Main function */
int main()
{
    test_djb2();
    return 0;
}
/**
 * @addtogroup hash Hash algorithms
 * @{
 * @file hash_xor8.c
 * @author [Christian Bender](https://github.com/christianbender)
 * @brief 8-bit [XOR hash](https://en.wikipedia.org/wiki/XOR_cipher) algorithm
 * for ASCII characters
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>

/**
 * @brief 8-bit XOR algorithm implementation
 *
 * @param s NULL terminated ASCII string to hash
 * @return 8-bit hash result
 */
uint8_t xor8(const char* s)
{
    uint8_t hash = 0;
    size_t i = 0;
    while (s[i] != '\0')
    {
        hash = (hash + s[i]) & 0xff;
        i++;
    }
    return (((hash ^ 0xff) + 1) & 0xff);
}

/**
 * @brief Test function for ::xor8
 * \returns None
 */
void test_xor8()
{
    assert(xor8("Hello World") == 228);
    assert(xor8("Hello World!") == 195);
    assert(xor8("Hello world") == 196);
    assert(xor8("Hello world!") == 163);
    printf("Tests passed\n");
}

/** @} */

/** Main function */
int main()
{
    test_xor8();
    return 0;
}
/**
 * @addtogroup hash Hash algorithms
 * @{
 * @file hash_adler32.c
 * @author [Christian Bender](https://github.com/christianbender)
 * @brief 32-bit [Adler hash](https://en.wikipedia.org/wiki/Adler-32) algorithm
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>

/**
 * @brief 32-bit Adler algorithm implementation
 *
 * @param s NULL terminated ASCII string to hash
 * @return 32-bit hash result
 */
uint32_t adler32(const char* s)
{
    uint32_t a = 1;
    uint32_t b = 0;
    const uint32_t MODADLER = 65521;

    size_t i = 0;
    while (s[i] != '\0')
    {
        a = (a + s[i]) % MODADLER;
        b = (b + a) % MODADLER;
        i++;
    }
    return (b << 16) | a;
}

/**
 * @brief Test function for ::adler32
 * \returns None
 */
void test_adler32()
{
    assert(adler32("Hello World") == 403375133);
    assert(adler32("Hello World!") == 474547262);
    assert(adler32("Hello world") == 413860925);
    assert(adler32("Hello world!") == 487130206);
    printf("Tests passed\n");
}

/** @} */

/** Main function */
int main()
{
    test_adler32();
    return 0;
}
/**
 * @addtogroup hash Hash algorithms
 * @{
 * @file hash_sdbm.c
 * @author [Christian Bender](https://github.com/christianbender)
 * @brief [SDBM hash algorithm](http://www.cse.yorku.ca/~oz/hash.html)
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>

/**
 * @brief SDBM algorithm implementation
 *
 * @param s NULL terminated string to hash
 * @return 64-bit hash result
 */
uint64_t sdbm(const char* s)
{
    uint64_t hash = 0;
    size_t i = 0;
    while (s[i] != '\0')
    {
        hash = s[i] + (hash << 6) + (hash << 16) - hash;
        i++;
    }
    return hash;
}

/**
 * @brief Test function for ::sdbm
 * \returns None
 */
void test_sdbm()
{
    assert(sdbm("Hello World") == 12881824461405877380U);
    assert(sdbm("Hello World!") == 7903571203300273309);
    assert(sdbm("Hello world") == 15154913742888948900U);
    assert(sdbm("Hello world!") == 15254999417003201661U);
    printf("Tests passed\n");
}

/** @} */

/** Main function */
int main()
{
    test_sdbm();
    return 0;
}
/**
 * @addtogroup hash Hash algorithms
 * @{
 * @file hash_crc32.c
 * @author [Christian Bender](https://github.com/christianbender)
 * @brief 32-bit [CRC
 * hash](https://en.wikipedia.org/wiki/Cyclic_redundancy_check#CRC-32_algorithm)
 * algorithm
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>

/**
 * @brief 32-bit CRC algorithm implementation
 *
 * @param s NULL terminated ASCII string to hash
 * @return 32-bit hash result
 */
uint32_t crc32(const char* s)
{
    uint32_t crc = 0xffffffff;
    size_t i = 0;
    while (s[i] != '\0')
    {
        uint8_t byte = s[i];
        crc = crc ^ byte;
        for (uint8_t j = 8; j > 0; --j)
        {
            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));
        }

        i++;
    }
    return crc ^ 0xffffffff;
}

/**
 * @brief Test function for ::crc32
 * \returns None
 */
void test_crc32()
{
    assert(crc32("Hello World") == 1243066710);
    assert(crc32("Hello World!") == 472456355);
    assert(crc32("Hello world") == 2346098258);
    assert(crc32("Hello world!") == 461707669);
    printf("Tests passed\n");
}

/** @} */

/** Main function */
int main()
{
    test_crc32();
    return 0;
}
/**
 * Modified 07/12/2017, Kyler Smith
 *
 */

#include <stdio.h>

int main()
{
    int remainder, number = 0, decimal_number = 0, temp = 1;
    printf("\n Enter any binary number= ");
    scanf("%d", &number);

    // Iterate over the number until the end.
    while (number > 0)
    {
        remainder = number % 10;
        number = number / 10;
        decimal_number += remainder * temp;
        temp = temp * 2;  // used as power of 2
    }

    printf("%d\n", decimal_number);
}
/**
 * @file
 * @brief [Infix to Postfix converter](https://www.includehelp.com/c/infix-to-postfix-conversion-using-stack-with-c-program.aspx) implementation
 * @details
 * The input infix expression is of type string upto 24 characters.
 * Supported operations- '+', '-', '/', '*', '%'
 * @author [Kumar Yash](https://github.com/kumaryash18)
 * @see infix_to_postfix.c
 */
 
#include <stdio.h>	/// for IO operations
#include <string.h>	/// for strlen(), strcmp()
#include <ctype.h>	/// for isalnum()
#include <stdlib.h>	/// for exit()
#include <stdint.h>	/// for uint16_t, int16_t
#include <assert.h>	/// for assert

/**
 * @brief array implementation of stack using structure
 */
struct Stack {
	char stack[10];		///< array stack
	int top;		///< stores index of the top element
};
struct Stack st;		///< global declaration of stack st

/**
 * @brief Function to push on the stack
 * @param opd character to be pushed in the stack
 * @returns void
 */
void push(char opd) {
	if(st.top == 9)	{		// overflow condition
		printf("Stack overflow...");
		exit(1);
	}
	st.top++;
	st.stack[st.top] = opd;
}

/**
 * @brief Function to pop from the stack
 * @returns popped character
 */
char pop() {
	char item;				///< to store the popped value to be returned
	if(st.top == -1) {		// underflow condition
		printf("Stack underflow...");
		exit(1);
	}
	item = st.stack[st.top];
	st.top--;
	return item;
}

/**
 * @brief Function to check whether the stack is empty or not
 * @returns 1 if the stack IS empty
 * @returns 0 if the stack is NOT empty
 */
uint16_t isEmpty() {
	if(st.top == -1) {
		return 1;
	}
	return 0;
}

/**
 * @brief Function to get top of the stack
 * @returns top of stack
 */
char Top() {
	return st.stack[st.top];
}

/**
 * @brief Function to check priority of operators
 * @param opr operator whose priority is to be checked
 * @returns 0 if operator is '+' or '-'
 * @returns 1 if operator is '/' or '*' or '%'
 * @returns -1 otherwise
 */
int16_t priority(char opr) {
	if(opr == '+' || opr == '-') {
		return 0;
	}
	else if(opr == '/' || opr == '*' || opr == '%') {
		return 1;
	}
	else {
		return -1;
	}
}

/**
 * @brief Function to convert infix expression to postfix expression
 * @param inf the input infix expression
 * @returns output postfix expression
 */
char *convert(char inf[]) {
	static char post[25];				///< to store the postfix expression
	int i;								///< loop iterator
	int j = 0;							///< keeps track of end of postfix string
	for(i = 0; i < strlen(inf); i++) {
		if(isalnum(inf[i]))	{			// if scanned element is an alphabet or number
			post[j] = inf[i];			// append in postfix expression
			j++;
		}
		else if(inf[i] == '(') {		// if scanned element is opening parentheses
			push(inf[i]);				// push on stack.
		}
		else if(inf[i] == ')') {		// if scanned element is closing parentheses,
			while(Top() != '(') {		// pop elements from stack and append in postfix expression
				post[j] = pop();		// until opening parentheses becomes top.
				j++;
			}
			pop();						// pop opening parentheses
		}
		else {							// if scanned element is an operator
			while( (!isEmpty()) && (priority(inf[i]) <= priority(Top())) ) {	// pop and append until stack becomes
				post[j] = pop();												// empty or priority of top operator
				j++;															// becomes smaller than scanned operator
			}																	// '(' has priority -1
			push(inf[i]);				// push the scanned operator
		}
	}
	while(!isEmpty()) {					// pop and append residual operators from stack
		post[j] = pop();
		j++;
	}
	post[j] = '\0';						// end postfix string with null character
	return post;
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test() {
    /* check sample test case
	   input- "(A/(B-C)*D+E)"
	   expected output- "ABC-/D*E+"
	 */
	assert(strcmp(convert("(A/(B-C)*D+E)"), "ABC-/D*E+") == 0); 			/// this ensures that the algorithm works as expected
	/* input- "7-(2*3+5)*(8-4/2)"
	   expected output- "723*5+842/-*-"
	 */
	assert(strcmp(convert("7-(2*3+5)*(8-4/2)"), "723*5+842/-*-") == 0); 			/// this ensures that the algorithm works as expected
	printf("All tests have successfully passed!\n");
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main() {
	st.top = -1;			/// initialize
	test();				/// run self-test implementations
	char inf[25];			///< to store input infix expression
	printf("Enter infix: ");
	scanf("%s", inf);
	printf("Postfix: %s", convert(inf));
	return 0;
}
/**
 * @file
 * @brief Convert a positive integer to string (non-standard function)
 * representation.
 */
#include <assert.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/**
 * Converts an integer value to a null-terminated string using the specified
 * base and stores the result in the array given by str parameter.
 * @param value Value to be converted to a string.
 * @param dest pointer to array in memory to store the resulting null-terminated
 * string.
 * @param base Numerical base used to represent the value as a string, between 2
 * and 16, where 10 means decimal base, 16 hexadecimal, 8 octal, and 2 binary.
 * @returns A pointer to the resulting null-terminated string, same as parameter
 * str.
 * @note The destination array must be pre-allocated by the calling function.
 */
char *int_to_string(uint16_t value, char *dest, int base)
{
    const char hex_table[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    int len = 0;
    do
    {
        dest[len++] = hex_table[value % base];
        value /= base;
    } while (value != 0);

    /* reverse characters */
    for (int i = 0, limit = len / 2; i < limit; ++i)
    {
        char t = dest[i];
        dest[i] = dest[len - 1 - i];
        dest[len - 1 - i] = t;
    }
    dest[len] = '\0';
    return dest;
}

/** Test function
 * @returns `void`
 */
static void test()
{
    const int MAX_SIZE = 100;
    char *str1 = (char *)calloc(sizeof(char), MAX_SIZE);
    char *str2 = (char *)calloc(sizeof(char), MAX_SIZE);

    for (int i = 1; i <= 100; ++i) /* test 100 random numbers */
    {
        /* Generate value from 0 to 100 */
        int value = rand() % 100;

        // assert(strcmp(itoa(value, str1, 2), int_to_string(value, str2, 2)) ==
        //        0);
        snprintf(str1, MAX_SIZE, "%o", value);  //* standard C - to octal */
        assert(strcmp(str1, int_to_string(value, str2, 8)) == 0);
        snprintf(str1, MAX_SIZE, "%d", value); /* standard C - to decimal */
        assert(strcmp(str1, int_to_string(value, str2, 10)) == 0);
        snprintf(str1, MAX_SIZE, "%x", value); /* standard C - to hexadecimal */
        assert(strcmp(str1, int_to_string(value, str2, 16)) == 0);
    }

    free(str1);
    free(str2);
}

/** Driver Code */
int main()
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
/*
 * C Program to Convert Binary to Hexadecimal
 */
#include <stdio.h>

int main()
{
    long int binary, hexa = 0, i = 1, remainder;

    printf("Enter the binary number: ");
    scanf("%ld", &binary);
    while (binary != 0)
    {
        remainder = binary % 10;
        hexa = hexa + remainder * i;
        i = i * 2;
        binary = binary / 10;
    }
    printf("The equivalent hexadecimal value: %lX", hexa);
    return 0;
}
/*****Decimal to octal conversion*******************/
#include <stdio.h>
void decimal2Octal(long decimalnum);

int main()
{
    long decimalnum;

    printf("Enter the decimal number: ");
    scanf("%ld", &decimalnum);

    decimal2Octal(decimalnum);

    return 0;
}

/********function for convert decimal numbers to octal numbers************/
void decimal2Octal(long decimalnum)
{
    long remainder, quotient;

    int octalNumber[100], i = 1, j;
    quotient = decimalnum;

    while (quotient != 0)
    {
        octalNumber[i++] = quotient % 8;

        quotient = quotient / 8;
    }

    for (j = i - 1; j > 0; j--) printf("%d", octalNumber[j]);

    printf("\n");
}
// Binary number to octal number conversion
#include <stdio.h>

// Function that returns the last three digits
int three_digits(int n)
{
    int r, d = 0, p = 1;

    for (int i = 0; i < 3; i++)
    {
        r = n % 10;
        d += r * p;
        p *= 10;
        n /= 10;
    }
    return d;
}

int main(void)
{
    int binary_num, d = 0, base = 1, remainder, td, res = 0, ord = 1;

    printf("Enter the binary no: ");
    scanf("%d", &binary_num);

    while (binary_num > 0)
    {
        if (binary_num >
            111)  // Checking if binary number is greater than three digits
            td = three_digits(binary_num);

        else
            td = binary_num;

        binary_num /= 1000;

        d = 0, base = 1;

        // Converting the last three digits to decimal
        while (td > 0)
        {
            remainder = td % 10;
            td /= 10;
            d += (base * remainder);
            base *= 2;
        }

        res += d * ord;  // Calculating the octal value
        ord *= 10;
    }

    printf("\nOctal equivalent is: %d", res);
    return 0;
}
/**
 * @file
 * @brief [Infix to
 * Postfix](https://condor.depaul.edu/ichu/csc415/notes/notes9/Infix.htm)
 * Expression Conversion
 * @details Convert Infixed expressions to Postfix expression.
 * @author [Harsh Karande](https://github.com/harshcut)
 */

// include header files
#include <stdio.h>  /// for printf() and scanf()

/**
 * @brief a globally declared structure with an array and an variable that
 * points to the topmost index of the array
 */
struct Stack
{
    char arr[10];  ///> static array of integers
    int tos;       ///> stores index on topmost element in stack
};

// function headers
void push(struct Stack *p, char ch);  // pust element in stack
char pop(struct Stack *p);            // pop topmost element from the stack
int isOprnd(char ch);                 // check if element is operand or not
int isEmpty(struct Stack s);          // check if stack is empty
int getPrecedence (char op1, char op2);        // check operator precedence
void convert(char infix[],
             char postfix[]);  // convert infix to postfix expression

/**
 * @brief main function
 * @returns 0 on exit
 */
int main()
{
    char infix[20], postfix[20];  // initialize empty infix and postfix array

    printf("Enter infix expression: ");  // example : A+B-C*D/E$F
    scanf("%s", infix);                  // get values for infix array

    convert(infix, postfix);
    printf("Postfix expression is %s", postfix);  // output : AB+CD*EF$/-

    return 0;
}

/**
 * @brief push function
 * @param *p : used as a pointer variable of stack
 * @param x : char to be pushed in stack
 * @returns void
 */
void push(struct Stack *p, char x)
{
    if (p->tos == 9)  // check if stack has reached its max limit
    {
        printf("Stack Overflow!");
        return;
    }

    p->tos += 1;         // increment tos
    p->arr[p->tos] = x;  // assign char x to index of stack pointed by tos
}

/**
 * @brief pop function
 * @param *p : used as a pointer variable of stack
 * @returns x or \0 on exit
 */
char pop(struct Stack *p)
{
    char x;

    if (p->tos == -1)
    {
        printf("Stack Underflow!");
        return '\0';
    }

    x = p->arr[p->tos];  // assign the value of stack at index tos to x
    p->tos -= 1;         // decrement tos

    return x;
}

/**
 * @brief isOprnd function
 * @param ch : this is the element from the infix array
 * @returns 1 or 0 on exit
 */
int isOprnd(char ch)
{
    if ((ch >= 65 && ch <= 90) ||
        (ch >= 97 && ch <= 122) ||  // check if ch is an operator or
        (ch >= 48 && ch <= 57))     // operand using ASCII values
    {
        return 1;  // return for true result
    }
    else
    {
        return 0;  // return for false result
    }
}

/**
 * @brief isEmpty function
 * @param s : it is the object reference of stack
 * @returns 1 or 0 on exit
 */
int isEmpty(struct Stack s)
{
    if (s.tos == -1)  // check if stack is empty
    {
        return 1;  // return for true result
    }
    else
    {
        return 0;  // return for false result
    }
}

/**
 * @brief convert function
 * @param infix[] : infix array provided by user
 * @param postfix[] : empty array to be given to convert()
 * @returns postfixed expresion or \0 on exit
 */
void convert(char infix[], char postfix[])
{
    struct Stack s;  // initialze object reference of stack
    s.tos = -1;      // initalize the tos

    int i, j = 0, pr;
    char ch, temp;

    for (i = 0; infix[i] != '\0'; i++)
    {
        ch = infix[i];

        if (isOprnd(ch) == 1)  // check if char is operand or operator
        {
            postfix[j] = ch;  // assign ch to postfix array with index j
            j++;              // incement j
        }
        else
        {
            if (ch == '(')
            {
                push(&s, ch);
            }
            else
            {
                if (ch == ')')
                {
                    while ((temp = pop(&s)) != '(')
                    {
                        postfix[j] = temp;
                        j++;
                    }
                }
                else
                {
                    while (isEmpty(s) == 0)  // check if stack is empty
                    {
                        pr = getPrecedence (ch,
                                   s.arr[s.tos]);  // check operator precedence

                        if (pr == 1)
                        {
                            break;  // if ch has a greater precedence than
                                    // s.arr[s.top]
                        }

                        postfix[j] = pop(&s);
                        j++;
                    }

                    push(&s, ch);  // push ch to stack
                }
            }
        }
    }

    while (isEmpty(s) == 0)  // check if stack is empty
    {
        postfix[j] = pop(&s);
        j++;
    }

    postfix[j] = '\0';
}

/**
 * @brief getPrecedence function returns the precedence after comparing two operators passed as parameter.
 * @param op1 : first operator
 * @param op2 : second operator
 * @returns 1 or 0 on exit
 */
int getPrecedence (char op1, char op2)
{
    if (op2 == '$')
    {
        return 0;
    }
    else if (op1 == '$')
    {
        return 1;
    }
    else if (op2 == '*' || op2 == '/' || op2 == '%')
    {
        return 0;
    }
    else if (op1 == '*' || op1 == '/' || op1 == '%')
    {
        return 1;
    }
    else if (op2 == '+' || op2 == '-')
    {
        return 0;
    }
    else
    {
        return 1;
    }
}
/**
 * @file
 * @author [jucollet972](https://github.com/jucollet972)
 * @brief [Decimal to any-base](http://codeofthedamned.com/index.php/number-base-conversion) is a C function wich convert positive decimal
 * integer to any positive ascii base with the base's alphabet given in input and return it in a dynamically allocated string(recursive way)
 */

#include <stdio.h>   /// for IO operations
#include <string.h>  /// for strchr and strlen
#include <stdint.h>  /// for CPU arch's optimized int types
#include <stdbool.h> /// for boolean types
#include <assert.h>  /// for assert
#include <stdlib.h>  /// for malloc and free

/**
 * @brief Checking if alphabet is valid
 * @param base alphabet inputed by user
 * @return int64_t as success or not
 */
bool isbad_alphabet(const char* alphabet) {
	uint64_t len = strlen(alphabet);
	
	/* Checking th lenght */	
	if (len < 2) {
		return true;
	}
	/* Browse the alphabet */
	for (int i = 0; i < len ; i++) {
		/* Searching for duplicates */ 
		if (strchr(alphabet + i + 1, alphabet[i]))
			return true;
	}
	return false;
}

/**
 * @brief Calculate the final length of the converted number
 * @param nb to convert
 * @param base calculated from alphabet
 * @return Converted nb string length 
 */
uint64_t converted_len(uint64_t nb, short base) {
	/* Counting the number of characters translated to the base*/
	if (nb > base - 1) {
		return (converted_len(nb/base, base) + 1);
	}
	return 1;
}

/**
 * @brief Convert positive decimal integer into anybase recursively
 * @param nb to convert
 * @param alphabet inputed by user used for base convertion
 * @param base calculated from alphabet
 * @param converted string filled with the convertion's result
 * @return void
 */
void convertion(uint64_t nb, const char* alphabet, short base, char* converted) {
	/* Recursive convertion */
	*(converted) = *(alphabet + nb%base);
	if (nb > base - 1) {
		convertion(nb/base, alphabet, base, --converted);
	}
}

/**
 * @brief decimal_to_anybase ensure the validity of the parameters and convert any unsigned integers into any ascii positive base
 * @param nb to convert
 * @param base's alphabet
 * @returns nb converted on success
 * @returns NULL on error
 */
char* decimal_to_anybase(uint64_t nb, const char* alphabet) {
	char* converted;

	/* Verify that alphabet is valid */
	if (isbad_alphabet(alphabet)) {
		return NULL;
	}
	/* Convertion */
	uint64_t base = strlen(alphabet);
	uint64_t final_len = converted_len(nb, base);
	converted = malloc(sizeof(char) * (final_len + 1));
	converted[final_len] = 0;
	convertion(nb, alphabet, base, converted + final_len - 1);
	return converted;
}


/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
	char* ret = NULL;
	char* reference = NULL;

	/* min dec*/
	reference = "0";
	ret = decimal_to_anybase(0, "0123456789");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* max dec*/
	reference = "18446744073709551615";
	ret = decimal_to_anybase(18446744073709551615, "0123456789");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* negative dec*/
	reference = "18446744073709551615";
	ret = decimal_to_anybase(-1, "0123456789");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}

	/* bin */
	reference = "101010";
	ret = decimal_to_anybase(42, "01");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* octal */
	reference = "52";
	ret = decimal_to_anybase(42, "01234567");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	
	/* hexa */
	reference = "2A";
	ret = decimal_to_anybase(42, "0123456789ABCDEF");
	for (int i = 0; i < strlen(reference) && i < strlen(ret); i++) {
		assert(ret[i] == reference[i]);
	}
	if (ret != NULL) {
		free(ret);
	}
	printf("[+] All tests have successfully passed!\n");
}

/**
 * @brief Main function
 * @returns 0 on exit 
 */
int main()
{
	test(); // run self-test implementations
	return 0;
}
/**
 * @file
 * @brief Convert hexadecimal number to octal number (with decimal intermediary)
 * @details
 * The input is valid from 0 to 0xFFFF_FFFF_FFFF_FFFF.
 *
 * At first, this program converts a hex string to an unsigned long long
 * decimal, and then to an octal string.
 *
 * When there is an invalid character in input string, this program stops
 * parsing and converts the string until that character.
 *
 * @see hexadecimal_to_octal.c
 */

#include <stdio.h>  /// for printf() and fgets()
#include <string.h> /// for memset()

/**
 * @brief Convert a hexadecimal number to octal number.
 * @param hex Hexadecimal number to convert.
 * @returns A pointer to the converted octal string.
 */
const char *hex_to_oct(const char *hex)
{
#define MAX_OCT_STR_LEN 23 /* 17_7777_7777_7777_7777_7777 */
    static char octal[MAX_OCT_STR_LEN];
    memset(octal, '\0', MAX_OCT_STR_LEN); // Initialize as NULL string

    unsigned long long decimal = 0;
    int i = 0;
    int len;

    if (hex == NULL)
    {
        // Return an empty string
        return octal;
    }

    /* Hexadecimal to decimal conversion */
    while (*hex != '\n' && *hex != '\0')
    {
        char ch = *hex;

        if (ch >= '0' && ch <= '9')
        {
            ch -= '0';
        }
        else if (ch >= 'a' && ch <= 'f')
        {
            ch = ch - 'a' + 10;
        }
        else if (ch >= 'A' && ch <= 'F')
        {
            ch = ch - 'A' + 10;
        }
        else
        {
            printf("Invalid hexadecimal input: %c\n", ch);
            break;
        }

        decimal *= 16;
        decimal += ch;
        hex++;
    }

    /* Decimal to octal conversion */
    if (decimal == 0)
    {
        octal[0] = '0';
        len = 1;
    }
    else
    {
        i = 0;
        while (decimal > 0)
        {
            octal[i] = '0' + decimal % 8;
            i++;
            decimal /= 8;
        }

        len = i;
    }

    octal[len] = '\0';

    /* Reverse the octal string */
    for (i = 0; i < len / 2; i++)
    {
        char tmp = octal[i];
        octal[i] = octal[len - i - 1];
        octal[len - i - 1] = tmp;
    }

    return octal;
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
#define MAX_HEX_STR_LEN 17 /* FFFF_FFFF_FFFF_FFFF */
    char hex[MAX_HEX_STR_LEN];

    /* Input hexadecimal number from user */
    printf("Enter any hexadecimal number: ");
    fgets(hex, MAX_HEX_STR_LEN, stdin);

    const char *octal = hex_to_oct(hex);

    printf("Hexadecimal number = %s\n", hex);
    printf("Octal number = %s\n", octal);

    return 0;
}
/*
 * convert from any base to decimal
 */

#include <ctype.h>
#include <stdio.h>

int main(void)
{
    int base, i, j;
    char number[100];
    unsigned long decimal = 0;

    printf("Enter the base: ");
    scanf("%d", &base);
    printf("Enter the number: ");
    scanf("%s", &number[0]);

    for (i = 0; number[i] != '\0'; i++)
    {
        if (isdigit(number[i]))
            number[i] -= '0';
        else if (isupper(number[i]))
            number[i] -= 'A' - 10;
        else if (islower(number[i]))
            number[i] -= 'a' - 10;
        else
            number[i] = base + 1;

        if (number[i] >= base)
        {
            printf("invalid number\n");
            return 0;
        }
    }

    for (j = 0; j < i; j++)
    {
        decimal *= base;
        decimal += number[j];
    }

    printf("%lu\n", decimal);
}
/**
 * \file
 * \brief Recoding the original atoi function in stdlib.h
 * \author [Mohammed YMIK](https://github.com/medymik)W
 * The function convert a string passed to an integer
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * the function take a string and return an integer
 * \param[out] str pointer to a char address
 */
int c_atoi(const char *str)
{
    int i;
    int sign;
    long value;
    long prev;

    i = 0;
    sign = 1;
    value = 0;

    /* skipping the spaces */
    while (((str[i] <= 13 && str[i] >= 9) || str[i] == 32) && str[i] != '\0')
        i++;

    /* store the sign if it is negative sign */
    if (str[i] == '-')
	{
        sign = -1;
	i++;
	}
    else if (str[i] == '+')
	{
        sign = 1;
	i++;
	}

    /* converting char by char to a numeric value */
    while (str[i] >= 48 && str[i] <= 57 && str[i] != '\0')
    {
        prev = value;
        value = value * 10 + sign * (str[i] - '0');

        /* managing the overflow */
        if (sign == 1 && prev > value)
            return (-1);
        else if (sign == -1 && prev < value)
            return (0);
        i++;
    }
    return (value);
}

/**
 * test the function implementation
 */
void test_c_atoi()
{
    printf("<<<< TEST FUNCTION >>>>\n");
    assert(c_atoi("123") == atoi("123"));
    assert(c_atoi("-123") == atoi("-123"));
    assert(c_atoi("") == atoi(""));
    assert(c_atoi("-h23") == atoi("-h23"));
    assert(c_atoi("         23") == atoi("         23"));
    assert(c_atoi("999999999") == atoi("999999999"));
    printf("<<<< TEST DONE >>>>\n");
}

/**
 * the main function take one argument of type char*
 * example : ./program 123
 */
int main(int argc, char **argv)
{
    test_c_atoi();

    if (argc == 2)
    {
        printf("Your number + 5 is %d\n", c_atoi(argv[1]) + 5);
        return (0);
    }
    printf("wrong number of parmeters\n");
    return (1);
}
#include <math.h>
#include <stdio.h>

// Converts octal number to decimal
int convertValue(int num, int i) { return num * pow(8, i); }

long long toDecimal(int octal_value)
{
    int decimal_value = 0, i = 0;

    while (octal_value)
    {
        // Extracts right-most digit and then multiplies by 8^i
        decimal_value += convertValue(octal_value % 10, i++);

        // Shift right in base 10
        octal_value /= 10;
    }

    return decimal_value;
}

int main()
{
    printf("Enter octal value: ");

    int octal_value;

    scanf("%d", &octal_value);

    long long result = toDecimal(octal_value);

    printf("%d in decimal is %lld\n", octal_value, result);

    return 0;
}
/* C program to convert Hexadecimal to Octal number system */

#include <stdio.h>

int main()
{
#define MAX_STR_LEN 17
    char hex[MAX_STR_LEN];
    long long octal, bin, place;
    int i = 0, rem, val;

    /* Input hexadecimal number from user */
    printf("Enter any hexadecimal number: ");
    fgets(hex, MAX_STR_LEN, stdin);

    octal = 0ll;
    bin = 0ll;
    place = 0ll;

    /* Hexadecimal to binary conversion */
    for (i = 0; hex[i] != '\0'; i++)
    {
        bin = bin * place;

        switch (hex[i])
        {
        case '0':
            bin += 0;
            break;
        case '1':
            bin += 1;
            break;
        case '2':
            bin += 10;
            break;
        case '3':
            bin += 11;
            break;
        case '4':
            bin += 100;
            break;
        case '5':
            bin += 101;
            break;
        case '6':
            bin += 110;
            break;
        case '7':
            bin += 111;
            break;
        case '8':
            bin += 1000;
            break;
        case '9':
            bin += 1001;
            break;
        case 'a':
        case 'A':
            bin += 1010;
            break;
        case 'b':
        case 'B':
            bin += 1011;
            break;
        case 'c':
        case 'C':
            bin += 1100;
            break;
        case 'd':
        case 'D':
            bin += 1101;
            break;
        case 'e':
        case 'E':
            bin += 1110;
            break;
        case 'f':
        case 'F':
            bin += 1111;
            break;
        default:
            printf("Invalid hexadecimal input.");
        }

        place = 10000;
    }

    place = 1;

    /* Binary to octal conversion */
    while (bin > 0)
    {
        rem = bin % 1000;

        switch (rem)
        {
        case 0:
            val = 0;
            break;
        case 1:
            val = 1;
            break;
        case 10:
            val = 2;
            break;
        case 11:
            val = 3;
            break;
        case 100:
            val = 4;
            break;
        case 101:
            val = 5;
            break;
        case 110:
            val = 6;
            break;
        case 111:
            val = 7;
            break;
        }

        octal = (val * place) + octal;
        bin /= 1000;

        place *= 10;
    }

    printf("Hexadecimal number = %s\n", hex);
    printf("Octal number = %lld", octal);

    return 0;
}
/*****Decimal to Hexadecimal conversion*******************/
#include <stdio.h>
void decimal2Hexadecimal(long num);

int main()
{
    long decimalnum;

    printf("Enter decimal number: ");
    scanf("%ld", &decimalnum);

    decimal2Hexadecimal(decimalnum);

    return 0;
}

/********function for convert decimal number to hexadecimal
 * number****************/
void decimal2Hexadecimal(long num)
{
    long decimalnum = num;
    long quotient, remainder;
    int i, j = 0;
    char hexadecimalnum[100];

    quotient = decimalnum;

    while (quotient != 0)
    {
        remainder = quotient % 16;
        if (remainder < 10)
            hexadecimalnum[j++] = 48 + remainder;

        else
            hexadecimalnum[j++] = 55 + remainder;

        quotient = quotient / 16;
    }

    // print the hexadecimal number

    for (i = j; i >= 0; i--)
    {
        printf("%c", hexadecimalnum[i]);
    }

    printf("\n");
}
#include <stdio.h>
#include <stdlib.h>

#define MAXBITS 100

int main()
{
    // input of the user
    int inputNumber;

    // for the remainder
    int re;

    // contains the bits 0/1
    int bits[MAXBITS];

    // for the loops
    int j;
    int i = 0;

    printf("\t\tConverter decimal --> binary\n\n");

    // reads a decimal number from the user.
    printf("\nenter a positive integer number: ");
    scanf("%d", &inputNumber);

    // make sure the input number is a positive integer.
    if (inputNumber < 0)
    {
        printf("only positive integers >= 0\n");
        return 1;
    }

    // actual processing
    while (inputNumber > 0)
    {
        // computes the remainder by modulo 2
        re = inputNumber % 2;

        // computes the quotient of division by 2
        inputNumber = inputNumber / 2;

        bits[i] = re;
        i++;
    }

    printf("\n the number in binary is: ");

    // iterates backwards over all bits
    for (j = i - 1; j >= 0; j--)
    {
        printf("%d", bits[j]);
    }

    // for the case the input number is 0
    if (i == 0)
    {
        printf("0");
    }

    return 0;
}
/**
 * @file
 * @brief Convert decimal to binary using recursion algorithm
 */
#include <assert.h>

/**
 * Decimal to binary using recursion algorithm.
 * For example, if number = 5, the function returns the decimal integer 101.
 * @param number positive integer number to convert
 * @returns integer with digits representing binary value representation of
 * number.
 */
int decimal_to_binary(unsigned int number)
{
    return number == 0 ? 0 : number % 2 + 10 * decimal_to_binary(number / 2);
}

/** Test function */
void test()
{
    const int sets[][2] = {
        {0, 0}, {1, 1}, {2, 10}, {3, 11}, {4, 100}, {6, 110}, {7, 111},
        /* add more data sets to test */
    };

    for (int i = 0, size = sizeof(sets) / sizeof(sets[0]); i < size; ++i)
    {
        assert(decimal_to_binary(sets[i][0]) == sets[i][1]);
    }
}

/** Driver Code */
int main()
{
    test();
    return 0;
}
/**
 * @brief Octal to binay conversion by scanning user input
 * @details
 * The octalTobinary function take the octal number as long
 * return a long binary nuber after conversion
 * @author [Vishnu P](https://github.com/vishnu0pothan)
 */
#include <math.h>
#include <stdio.h>

/**
 * @brief Converet  octal number to binary
 * @param octalnum octal value that need to convert
 * @returns A binary number after conversion
 */
long octalToBinary(int octalnum)
{
    int decimalnum = 0, i = 0;
    long binarynum = 0;

    /* This loop converts octal number "octalnum" to the
     * decimal number "decimalnum"
     */
    while (octalnum != 0)
    {
        decimalnum = decimalnum + (octalnum % 10) * pow(8, i);
        i++;
        octalnum = octalnum / 10;
    }

    // i is re-initialized
    i = 1;

    /* This loop converts the decimal number "decimalnum" to the binary
     * number "binarynum"
     */
    while (decimalnum != 0)
    {
        binarynum = binarynum + (long)(decimalnum % 2) * i;
        decimalnum = decimalnum / 2;
        i = i * 10;
    }

    // Returning the binary number that we got from octal number
    return binarynum;
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    int octalnum;

    printf("Enter an octal number: ");
    scanf("%d", &octalnum);

    // Calling the function octaltoBinary
    printf("Equivalent binary number is: %ld", octalToBinary(octalnum));
    return 0;
}
/**
 * @file
 * @brief Octal to hexadecimal conversion by scanning user input
 * @details
 * The octalToHexadecimal function take the octal number as long
 * return a string hexadecimal value after conversion
 * @author [Rachit Bhalla](https://github.com/rachitbhalla)
 */
#include <assert.h> // for assert
#include <math.h> // for pow function
#include <stdio.h> // for scanf and printf functions
#include <stdlib.h> // for malloc and free functions
#include <string.h> // for strcmp function

/**
 * @brief Convert octal number to decimal number
 * @param octalValue is the octal number that needs to be converted
 * @returns a decimal number after conversion
 */
long octalToDecimal(long octalValue){
    long decimalValue = 0;
    int i = 0;
    while (octalValue) {
        // Extracts right-most digit, multiplies it with 8^i, and increment i by 1
        decimalValue += (long)(octalValue % 10) * pow(8, i++);
        // Shift right in base 10
        octalValue /= 10;
    }
    return decimalValue;
}

/**
 * @brief Convert octal number to hexadecimal number
 * dynamically allocated memory needs to be freed by the calling the function free
 * @param octalValue is the octal number that needs to be converted
 * @returns a hexadecimal value as a string after conversion
 */
char *octalToHexadecimal(long octalValue){
    char *hexadecimalValue = malloc(256 * sizeof(char));
    sprintf(hexadecimalValue, "%lX", octalToDecimal(octalValue));
    return hexadecimalValue;
}

/**
 * @brief Test function
 * @returns void
 */
static void test() {
    /* test that hexadecimal value of octal number 213 is 8B */
    assert(strcmp(octalToHexadecimal(213), "8B") == 0);

    /* test that hexadecimal value of octal number 174 is 7C */
    assert(strcmp(octalToHexadecimal(174), "7C") == 0);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    // execute the tests
    test();

    // get the value of octal number as input
    int octalValue;
    printf("Enter an octal number: ");
    scanf("%d", &octalValue);

    // call the function octalToHexadecimal and print the hexadecimal value
    char *hexadecimalValue = octalToHexadecimal(octalValue);
    printf("Equivalent hexadecimal number is: %s", hexadecimalValue);

    // free the memory allocated dynamically in function octalToHexadecimal
    free(hexadecimalValue);

    // return 0 and exit
    return 0;
}
// Program to convert decimal number to octal (Using Reccursion)
// This program only works for integer decimals
// Created by Aromal Anil

#include <stdio.h>
int decimal_to_octal(int decimal)
{
    if ((decimal < 8) && (decimal > 0))
    {
        return decimal;
    }
    else if (decimal == 0)
    {
        return 0;
    }
    else
    {
        return ((decimal_to_octal(decimal / 8) * 10) + decimal % 8);
    }
}
int main()
{
    int octalNumber, decimalNumber;
    printf("\nEnter your decimal number : ");
    scanf("%d", &decimalNumber);
    octalNumber = decimal_to_octal(decimalNumber);
    printf("\nThe octal of %d is : %d", decimalNumber, octalNumber);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#define len 5

int binarySearch(int array[], int leng, int searchX)
{
    int pos = -1, right, left, i = 0;

    left = 0;
    right = leng - 1;

    while (left <= right)
    {
        pos = left + (right - left) / 2;
        if (array[pos] == searchX)
        {
            return pos;
        }
        else if (array[pos] > searchX)
        {
            right = pos - 1;
        }
        else
        {
            left = pos + 1;
        }
    }
    return -1; /* not found */
}

int main(int argc, char *argv[])
{
    int array[len] = {5, 8, 10, 14, 16};

    int position;
    position = binarySearch(array, len, 5);

    if (position < 0)
        printf("The number %d doesnt exist in array\n", 5);
    else
    {
        printf("The number %d exist in array at position : %d \n", 5, position);
    }

    return 0;
}

#include <stdio.h>

// Function to perform Ternary Search
int ternarySearch(int l, int r, int key, int ar[])
{
    if (r >= l)
    {
        // Find the mid1 and mid2
        int mid1 = l + (r - l) / 3;
        int mid2 = r - (r - l) / 3;

        // Check if key is present at any mid
        if (ar[mid1] == key)
        {
            return mid1;
        }
        if (ar[mid2] == key)
        {
            return mid2;
        }

        // Since key is not present at mid,
        // check in which region it is present
        // then repeat the Search operation
        // in that region

        if (key < ar[mid1])
        {
            // The key lies in between l and mid1
            return ternarySearch(l, mid1 - 1, key, ar);
        }
        else if (key > ar[mid2])
        {
            // The key lies in between mid2 and r
            return ternarySearch(mid2 + 1, r, key, ar);
        }
        else
        {
            // The key lies in between mid1 and mid2
            return ternarySearch(mid1 + 1, mid2 - 1, key, ar);
        }
    }

    // Key not found
    return -1;
}

// Driver code
int main()
{
    int l, r, p, key;

    // Get the array
    // Sort the array if not sorted
    int ar[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // Starting index
    l = 0;

    // length of array
    r = 9;

    // Checking for 5

    // Key to be searched in the array
    key = 5;

    // Search the key using ternarySearch
    p = ternarySearch(l, r, key, ar);

    // Print the result
    printf("Index of %d is %d\n", key, p);

    // Checking for 50

    // Key to be searched in the array
    key = 50;

    // Search the key using ternarySearch
    p = ternarySearch(l, r, key, ar);

    // Print the result
    printf("Index of %d is %d", key, p);
}#include <stdio.h>
#include <stdlib.h>

int fibMonaccianSearch(int arr[], int x, int n)
{
    /* Initialize fibonacci numbers */
    int fibMMm2 = 0;               // (m-2)'th Fibonacci No.
    int fibMMm1 = 1;               // (m-1)'th Fibonacci No.
    int fibM = fibMMm2 + fibMMm1;  // m'th Fibonacci

    /* fibM is going to store the smallest Fibonacci
       Number greater than or equal to n */
    while (fibM < n)
    {
        fibMMm2 = fibMMm1;
        fibMMm1 = fibM;
        fibM = fibMMm2 + fibMMm1;
    }

    // Marks the eliminated range from front
    int offset = -1;

    /* while there are elements to be inspected. Note that
       we compare arr[fibMm2] with x. When fibM becomes 1,
       fibMm2 becomes 0 */
    while (fibM > 1)
    {
        // Check if fibMm2 is a valid location

        // sets i to the min. of (offset+fibMMm2) and (n-1)
        int i = ((offset + fibMMm2) < (n - 1)) ? (offset + fibMMm2) : (n - 1);

        /* If x is greater than the value at index fibMm2,
           cut the subarray array from offset to i */
        if (arr[i] < x)
        {
            fibM = fibMMm1;
            fibMMm1 = fibMMm2;
            fibMMm2 = fibM - fibMMm1;
            offset = i;
        }

        /* If x is greater than the value at index fibMm2,
           cut the subarray after i+1  */
        else if (arr[i] > x)
        {
            fibM = fibMMm2;
            fibMMm1 = fibMMm1 - fibMMm2;
            fibMMm2 = fibM - fibMMm1;
        }

        /* element found. return index */
        else
            return i;
    }

    /* comparing the last element with x */
    if (fibMMm1 && arr[offset + 1] == x)
        return offset + 1;

    /*element not found. return -1 */
    return -1;
}

int main(void)
{
    int arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 85;
    printf("Found at index: %d", fibMonaccianSearch(arr, x, n));
    return 0;
}
#include <stdio.h>

/* By comparison, binary search always chooses the middle of the remaining
 * search space, discarding one half or the other, depending on the comparison
 * between the key found at the estimated position and the key sought. The
 * remaining search space is reduced to the part before or after the estimated
 * position. The linear search uses equality only as it compares elements
 * one-by-one from the start, ignoring any sorting. On average the interpolation
 * search makes about log(log(n)) comparisons (if the elements are uniformly
 * distributed), where n is the number of elements to be searched. In the worst
 * case (for instance where the numerical values of the keys increase
 * exponentially) it can make up to O(n) comparisons. In
 * interpolation-sequential search, interpolation is used to find an item near
 * the one being searched for, then linear search is used to find the exact
 * item. */

int interpolationSearch(int arr[], int n, int key)
{
    int low = 0, high = n - 1;
    while (low <= high && key >= arr[low] && key <= arr[high])
    {
        /* Calculate the nearest posible position of key */
        int pos =
            low + ((key - arr[low]) * (high - low)) / (arr[high] - arr[low]);
        if (key > arr[pos])
            low = pos + 1;
        else if (key < arr[pos])
            high = pos - 1;
        else /* Found */
            return pos;
    }
    /* Not found */
    return -1;
}

int main()
{
    int x;
    int arr[] = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\nEnter the number to be searched: ");
    scanf("%d", &x); /* Element to be searched */

    int index = interpolationSearch(arr, n, x);

    /* If element was found */
    if (index != -1)
        printf("Element found at position: %d\n", index);
    else
        printf("Element not found.\n");
    return 0;
}
/**
 * @file jump_search.c
 * @brief Implementation of [jump
 * search](https://en.wikipedia.org/wiki/Jump_search) algorithm.
 */
#include <assert.h>
#include <math.h>
#include <stdio.h>

/**
 * @brief Macro to return the minimum of two values
 */
#define min(X, Y) ((X) < (Y) ? (X) : (Y))

/**
 * @brief Implement Jump-search algorithm
 *
 * @param [in] arr Array to search within
 * @param x value to search for
 * @param n length of array
 * @return index where the value was found
 * @return -1 if value not found
 */
int jump_search(const int *arr, int x, size_t n)
{
    int step = floor(sqrt(n));
    int prev = 0;

    while (arr[min(step, n) - 1] < x)
    {
        prev = step;
        step += floor(sqrt(n));
        if (prev >= n)
        {
            return -1;
        }
    }

    while (arr[prev] < x)
    {
        prev = prev + 1;
        if (prev == min(step, n))
        {
            return -1;
        }
    }
    if (arr[prev] == x)
    {
        return prev;
    }
    return -1;
}

/**
 * @brief Test implementation of the function
 *
 */
void test()
{
    int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610};
    size_t n = sizeof(arr) / sizeof(int);

    int x = 55;
    printf("Test 1.... ");
    int index = jump_search(arr, x, n);
    assert(index == 10);
    printf("passed\nTest 2.... ");
    x = 56;
    index = jump_search(arr, x, n);
    assert(index == -1);
    printf("passed\nTest 3.... ");
    x = 13;
    index = jump_search(arr, x, n);
    assert(index == 7);
    printf("passed\n");
}

/**
 * @brief Main function
 */
int main()
{
    test();
    return 0;
}
/**
 * @file
 * @brief Program to perform [binary
 * search](https://en.wikipedia.org/wiki/Binary_search_algorithm) of a target
 * value in a given *sorted* array.
 * @authors [James McDermott](https://github.com/theycallmemac) - recursive
 * algorithm
 * @authors [Krishna Vedala](https://github.com/kvedala) - iterative algorithm
 */
#include <assert.h>
#include <stdio.h>

/** Recursive implementation
 * \param[in] arr array to search
 * \param l left index of search range
 * \param r right index of search range
 * \param x target value to search for
 * \returns location of x assuming array arr[l..r] is present
 * \returns -1 otherwise
 */
int binarysearch1(const int *arr, int l, int r, int x)
{
    if (r >= l)
    {
        int mid = l + (r - l) / 2;

        // If element is present at middle
        if (arr[mid] == x)
            return mid;

        // If element is smaller than middle
        if (arr[mid] > x)
            return binarysearch1(arr, l, mid - 1, x);

        // Else element is in right subarray
        return binarysearch1(arr, mid + 1, r, x);
    }

    // When element is not present in array
    return -1;
}

/** Iterative implementation
 * \param[in] arr array to search
 * \param l left index of search range
 * \param r right index of search range
 * \param x target value to search for
 * \returns location of x assuming array arr[l..r] is present
 * \returns -1 otherwise
 */
int binarysearch2(const int *arr, int l, int r, int x)
{
    int mid = l + (r - l) / 2;

    while (arr[mid] != x)
    {
        if (r <= l || r < 0)
            return -1;

        if (arr[mid] > x)
            // If element is smaller than middle
            r = mid - 1;
        else
            // Else element is in right subarray
            l = mid + 1;

        mid = l + (r - l) / 2;
    }

    // When element is not present in array
    return mid;
}

/** Test implementations */
void test()
{
    // give function an array to work with
    int arr[] = {2, 3, 4, 10, 40};
    // get size of array
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Test 1.... ");
    // set value to look for
    int x = 10;
    // set result to what is returned from binarysearch
    int result = binarysearch1(arr, 0, n - 1, x);
    assert(result == 3);
    printf("passed recursive... ");
    result = binarysearch2(arr, 0, n - 1, x);
    assert(result == 3);
    printf("passed iterative...\n");

    printf("Test 2.... ");
    x = 5;
    // set result to what is returned from binarysearch
    result = binarysearch1(arr, 0, n - 1, x);
    assert(result == -1);
    printf("passed recursive... ");
    result = binarysearch2(arr, 0, n - 1, x);
    assert(result == -1);
    printf("passed iterative...\n");
}

/** Main function */
int main(void)
{
    test();
    return 0;
}
/**
 * @file
 * @brief [Linear Search with Sentinel](https://en.wikipedia.org/wiki/Linear_search#With_a_sentinel) algorithm implementation
 * @details
 * This algorithm saves the last element of the array, 
 * then replaces it with the value to be found and sets it as the sentinel. 
 * When searching, compares each element with the sentinel. 
 * If the same, returns the index. If the index is the index of the sentinel, it means it was not found. 
 * Of course, if the value to be found is the last element, we return the index of the last element.
 * @author [Regan Yue](https://github.com/ReganYue)
 * Time Complexity: O(N)
 */

#include <stdio.h>   /// for IO operations
#include <assert.h>  /// for assert

/**
 * @brief Utility function to search for an element in the array and return the index of the element
 * @details 
 * The so-called "sentinel" is to use a special value as the boundary key of the array. 
 * One less judgment statement can be used. 
 * The purpose is to avoid checking whether the entire array is searched at each step in the search 
 * process, so as to improve the efficiency of the program.
 * We can use the last value of the array as the "sentinel", the data storage index i 
 * starts from 0 and ends at len-1, then the position where the index of arr is n-1 indicates 
 * that there is no data temporarily, which is the "sentinel" key.
 * If the last element of the array is equal to the key, directly return the index of the last element. 
 * Before setting the last element of the array as the key, we hand over the last element of the array to temp for temporary storage. 
 * Then go to the array to find the key. If the key is found, stop the search, and then compare the found element index with len-1. 
 * If it is equal, it means it was not found. If it is not equal, it is found.
 * @param arr this is an array containing elements
 * @param len this is the number of elements in the array
 * @param key the value we want to search
 * @return i if found, otherwise -1 is returned.
 */
int sentinel_linear_search( int arr[], int len, int key ){
	if(key == arr[len-1]){
		return len-1;
	}
	
	int temp = arr[len-1]; 
	arr[len-1] = key;
	
	int i = 0;
	while (arr[len-1] != arr[i]) {
		i++;
	}
	
	arr[len-1] = temp;
	
	return i != len-1 ? i : -1;
	 
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test(){
	int n,i;
	n = 5;
	/* init array */
	int arr[] = { 1, 2, 2, 6, 99, 100, 999 };

	assert(sentinel_linear_search( arr, n, 1 )==0);
	assert(sentinel_linear_search( arr, n, 2 )==1);
	assert(sentinel_linear_search( arr, n, 6 )==3);
	assert(sentinel_linear_search( arr, n, 101 )==-1);
	printf("All test cases have successfully passed!\n");
} 

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main(){
	test();  // run self-test implementations
	return 0;
}
#include <stdio.h>
#include <stdlib.h>

int linearsearch(int *arr, int size, int val)
{
    int i;
    for (i = 0; i < size; i++)
    {
        if (arr[i] == val)
            return 1;
    }
    return 0;
}

int main()
{
    int n, i, v;
    printf("Enter the size of the array:\n");
    scanf("%d", &n);  // Taking input for the size of Array

    int *a = (int *)malloc(n * sizeof(int));
    printf("Enter the contents for an array of size %d:\n", n);
    for (i = 0; i < n; i++)
        scanf("%d", &a[i]);  // accepts the values of array elements until the
                             // loop terminates//

    printf("Enter the value to be searched:\n");
    scanf("%d", &v);  // Taking input the value to be searched
    if (linearsearch(a, n, v))
        printf("Value %d is in the array.\n", v);
    else
        printf("Value %d is not in the array.\n", v);

    free(a);
    return 0;
}
/**
 *  \file
 *  \brief [Exponential Search](https://github.com/TheAlgorithms/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Exponential%20Search.md)
 *  \author [Alessio Farinelli](https://github.com/faridevnz)
 */
#include <assert.h>  /// for assert
#include <inttypes.h>  /// for int64_t, uint16_t

#define ELEMENT -10

int64_t binary_search(const int64_t* arr, const uint16_t l_index, const uint16_t r_index, const int64_t n); ///< used to perform the binary search over the given array
int64_t exponential_search(const int64_t* arr, const uint16_t length, const int64_t n); ///< used to perform the exponential search over the given array
static void test(); ///< used to run the self-test implementations

/**
 * Function: exponential_search
 * \brief algorithm that search the index of the given item
 * \details recursive function that take an array and quickly find the range 
 * where to apply the binary search algorithm to find the given element
 * ----------------------------
 * \param arr array where search the element
 * \param length the total length of the given array (arr)
 * \param n element to find in the array (arr)
 * 
 * \returns the index of the element (n) in the array (arr)
 * \returns -1 if the element wasn't found
 */
int64_t exponential_search(const int64_t* arr, const uint16_t length, const int64_t n) 
{
    if ( length == 0 ) { return -1; }
    // find the upperbound
    uint32_t upper_bound = 1;
    while ( upper_bound <= length && arr[upper_bound] < n ) { upper_bound = upper_bound * 2; }
    // calculate the range ( between lower_boud and upper_bound )
    uint16_t lower_bound = upper_bound/2;
    if ( upper_bound > length ) { upper_bound = length; }
    // apply the binary search in the range
    return binary_search(arr, lower_bound, upper_bound, n);
}

/**
 * Function: binary_search
 * \brief algorithm that search the index of the given item
 * \details recursive function that search the given element in
 * the array using the [Binary Search](https://github.com/TheAlgorithms/Algorithms-Explanation/blob/master/en/Search%20Algorithms/Binary%20Search.md)
 * ----------------------------
 * \param arr array where search the element
 * \param l_index start index of the array (arr) to apply the algorithm
 * \param r_index end index of the array (arr) to apply the algorithm
 * \param n element to find in the array (arr)
 *
 * \returns the index of the element (n) in the array (arr)
 * \returns -1 if the n element wasn't found
 */
int64_t binary_search(const int64_t* arr, const uint16_t l_index, const uint16_t r_index, const int64_t n) 
{
    // calculate the middle index of the array
    uint16_t middle_index = l_index + ( r_index - l_index ) / 2;
    // base cases
    if ( l_index > r_index ) { return -1; }
    if ( arr[middle_index] == n ) { return middle_index; }
    // recursion
    if ( arr[middle_index] > n ) { return binary_search(arr, l_index, middle_index-1, n); } // left
    return binary_search(arr, middle_index+1, r_index, n); // right
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main() 
{
    test();  // run self-test implementations
    return 0;
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
    // empty array
    int64_t arr_empty[] = {};
    assert(exponential_search(arr_empty, 0, 10) == -1);
    // elent not found
    int64_t arr_found[] = {1, 2, 3};
    assert(exponential_search(arr_found, 3, 10) == -1);
    // element found in an array of length 1
    int64_t arr_one[] = {1};
    assert(exponential_search(arr_found, 1, 1) == 0);
    // find the first element in an array of length 2
    int64_t arr_first_2[] = {1, 2};
    assert(exponential_search(arr_first_2, 2, 1) == 0);
    // find the last element in an array of length 2
    int64_t arr_last_2[] = {1, 2};
    assert(exponential_search(arr_last_2, 2, 2) == 1);
    // find the first element in an array of length n
    int64_t arr_first_n[] = {-1, 2, 4, 6, 8};
    assert(exponential_search(arr_first_n, 5, -1) == 0);
    // find the last element in an array of length n
    int64_t arr_last_n[] = {-1, 2, 4, 6, 8};
    assert(exponential_search(arr_last_n, 5, 8) == 4);
    // find an element in an array of length n
    int64_t arr_middle[] = {-1, 2, 4, 6, 8};
    assert(exponential_search(arr_middle, 5, 6) == 3);
}
/**
 * @file
 * @brief Implementation of [Floyd's Cycle
 * Detection](https://en.wikipedia.org/wiki/Cycle_detection) algorithm
 * @details
 * Given an array of integers containing `n + 1` integers, where each
 * integer is in the range [1, n] inclusive. If there is only one duplicate
 * number in the input array, this algorithm returns the duplicate number in
 * O(1) space and the time complexity is less than O(n^2) without modifying the
 * original array, otherwise, it returns -1.
 * @author [Swastika Gupta](https://github.com/Swastyy)
 */
 
#include <assert.h>   /// for assert
#include <inttypes.h> /// for uint32_t
#include <stdio.h>    /// for IO operations

/**
 * @brief The main function implements the search algorithm
 * @tparam T type of array
 * @param in_arr the input array
 * @param n size of the array
 * @returns the duplicate number
 */
uint32_t duplicateNumber(const uint32_t *in_arr, size_t n)
{
    if (n <= 1) {  // to find duplicate in an array its size should be atleast 2
        return -1;
    }
    uint32_t tortoise = in_arr[0];  ///< variable tortoise is used for the longer
                                    ///< jumps in the array
    uint32_t hare = in_arr[0];  ///< variable hare is used for shorter jumps in the array
    do {                                   // loop to enter the cycle
        tortoise = in_arr[tortoise];       // tortoise is moving by one step
        hare = in_arr[in_arr[hare]];       // hare is moving by two steps
    } while (tortoise != hare);
    tortoise = in_arr[0];
    while (tortoise != hare) {             // loop to find the entry point of cycle
        tortoise = in_arr[tortoise];
        hare = in_arr[hare];
    }
    return tortoise;
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
    uint32_t arr[] = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610}; // input array
    size_t n = sizeof(arr) / sizeof(int);

    printf("1st test... ");
    uint32_t index = duplicateNumber(arr, n); // calling the duplicateNumber function to check which number occurs twice in the array
    assert(index == 1); // the number which occurs twice is 1 or not
    printf("passed\n");
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    test();  // run self-test implementations
    return 0;
}
/**
 * @file
 * @brief [Modified binary search algorithm](https://arxiv.org/abs/1406.1677)
 */
#include <stdio.h>
#include <stdlib.h>

/** This function does Binary search for `x` in `i`-th row from `j_low` to
 * `j_high`.
 * @param mat 2D matrix to search within
 * @param i row to search in
 * @param j_low start column index
 * @param j_high end column index
 * @param x value to search for
 * @return column where `x` was found
 * @return -1 if value not found
 */
int binarySearch(const int **mat, int i, int j_low, int j_high, int x)
{
    while (j_low <= j_high)
    {
        int j_mid = (j_low + j_high) / 2;

        // Element found
        if (mat[i][j_mid] == x)
        {
            printf("Found at (%d,%d)\n", i, j_mid);
            return j_mid;
        }
        else if (mat[i][j_mid] > x)
            j_high = j_mid - 1;
        else
            j_low = j_mid + 1;
    }

    // element not found
    printf("element not found\n");
    return -1;
}

/** Function to perform binary search on the mid values of row to get the
 * desired pair of rows where the element can be found
 * @param [in] mat matrix to search for the value in
 * @param n number of rows in the matrix
 * @param m number of columns in the matrix
 * @param x value to search for
 */
void modifiedBinarySearch(const int **mat, int n, int m, int x)
{  // If Single row matrix
    if (n == 1)
    {
        binarySearch(mat, 0, 0, m - 1, x);
        return;
    }

    // Do binary search in middle column.
    // Condition to terminate the loop when the 2 desired rows are found.
    int i_low = 0, i_high = n - 1, j_mid = m / 2;
    while ((i_low + 1) < i_high)
    {
        int i_mid = (i_low + i_high) / 2;
        // element found
        if (mat[i_mid][j_mid] == x)
        {
            printf("Found at (%d,%d)\n", i_mid, j_mid);
            return;
        }
        else if (mat[i_mid][j_mid] > x)
            i_high = i_mid;
        else
            i_low = i_mid;
    }
    // If element is present on the mid of the two rows
    if (mat[i_low][j_mid] == x)
        printf("Found at (%d,%d)\n", i_low, j_mid);
    else if (mat[i_low + 1][j_mid] == x)
        printf("Found at (%d,%d)\n", i_low + 1, j_mid);

    // Search element on 1st half of 1st row
    else if (x <= mat[i_low][j_mid - 1])
        binarySearch(mat, i_low, 0, j_mid - 1, x);

    // Search element on 2nd half of 1st row
    else if (x >= mat[i_low][j_mid + 1] && x <= mat[i_low][m - 1])
        binarySearch(mat, i_low, j_mid + 1, m - 1, x);

    // Search element on 1st half of 2nd row
    else if (x <= mat[i_low + 1][j_mid - 1])
        binarySearch(mat, i_low + 1, 0, j_mid - 1, x);

    // search element on 2nd half of 2nd row
    else
        binarySearch(mat, i_low + 1, j_mid + 1, m - 1, x);
}

/** Main function */
int main()
{
    int x;     // element to be searched
    int m, n;  // m = columns, n = rows

    scanf("%d %d %d\n", &n, &m, &x);

    int **mat = (int **)malloc(n * sizeof(int *));
    for (int i = 0; i < m; i++) mat[i] = (int *)malloc(m * sizeof(int));

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            scanf("%d", &mat[i][j]);
        }
    }

    modifiedBinarySearch(mat, n, m, x);

    for (int i = 0; i < n; i++) free(mat[i]);
    free(mat);
    return 0;
}
/**
 * @file k_means_clustering.c
 * @brief K Means Clustering Algorithm implemented
 * @details
 * This file has K Means algorithm implemmented
 * It prints test output in eps format
 *
 * Note:
 * Though the code for clustering works for all the
 * 2D data points and can be extended for any size vector
 * by making the required changes, but note that
 * the output method i.e. printEPS is only good for
 * polar data points i.e. in a circle and both test
 * use the same.
 * @author [Lakhan Nad](https://github.com/Lakhan-Nad)
 */

#define _USE_MATH_DEFINES /* required for MS Visual C */
#include <float.h>        /* DBL_MAX, DBL_MIN */
#include <math.h>         /* PI, sin, cos */
#include <stdio.h>        /* printf */
#include <stdlib.h>       /* rand */
#include <string.h>       /* memset */
#include <time.h>         /* time */

/*!
 * @addtogroup machine_learning Machine Learning Algorithms
 * @{
 * @addtogroup k_means K-Means Clustering Algorithm
 * @{
 */

/*! @struct observation
 *  a class to store points in 2d plane
 *  the name observation is used to denote
 *  a random point in plane
 */
typedef struct observation
{
    double x;  /**< abscissa of 2D data point */
    double y;  /**< ordinate of 2D data point */
    int group; /**< the group no in which this observation would go */
} observation;

/*! @struct cluster
 *  this class stores the coordinates
 *  of centroid of all the points
 *  in that cluster it also
 *  stores the count of observations
 *  belonging to this cluster
 */
typedef struct cluster
{
    double x;     /**< abscissa centroid of this cluster */
    double y;     /**< ordinate of centroid of this cluster */
    size_t count; /**< count of observations present in this cluster */
} cluster;

/*!
 * Returns the index of centroid nearest to
 * given observation
 *
 * @param o  observation
 * @param clusters  array of cluster having centroids coordinates
 * @param k  size of clusters array
 *
 * @returns the index of nearest centroid for given observation
 */
int calculateNearst(observation* o, cluster clusters[], int k)
{
    double minD = DBL_MAX;
    double dist = 0;
    int index = -1;
    int i = 0;
    for (; i < k; i++)
    {
        /* Calculate Squared Distance*/
        dist = (clusters[i].x - o->x) * (clusters[i].x - o->x) +
               (clusters[i].y - o->y) * (clusters[i].y - o->y);
        if (dist < minD)
        {
            minD = dist;
            index = i;
        }
    }
    return index;
}

/*!
 * Calculate centoid and assign it to the cluster variable
 *
 * @param observations  an array of observations whose centroid is calculated
 * @param size  size of the observations array
 * @param centroid  a reference to cluster object to store information of
 * centroid
 */
void calculateCentroid(observation observations[], size_t size,
                       cluster* centroid)
{
    size_t i = 0;
    centroid->x = 0;
    centroid->y = 0;
    centroid->count = size;
    for (; i < size; i++)
    {
        centroid->x += observations[i].x;
        centroid->y += observations[i].y;
        observations[i].group = 0;
    }
    centroid->x /= centroid->count;
    centroid->y /= centroid->count;
}

/*!
 *    --K Means Algorithm--
 * 1. Assign each observation to one of k groups
 *    creating a random initial clustering
 * 2. Find the centroid of observations for each
 *    cluster to form new centroids
 * 3. Find the centroid which is nearest for each
 *    observation among the calculated centroids
 * 4. Assign the observation to its nearest centroid
 *    to create a new clustering.
 * 5. Repeat step 2,3,4 until there is no change
 *    the current clustering and is same as last
 *    clustering.
 *
 * @param observations  an array of observations to cluster
 * @param size  size of observations array
 * @param k  no of clusters to be made
 *
 * @returns pointer to cluster object
 */
cluster* kMeans(observation observations[], size_t size, int k)
{
    cluster* clusters = NULL;
    if (k <= 1)
    {
        /*
        If we have to cluster them only in one group
        then calculate centroid of observations and
        that will be a ingle cluster
        */
        clusters = (cluster*)malloc(sizeof(cluster));
        memset(clusters, 0, sizeof(cluster));
        calculateCentroid(observations, size, clusters);
    }
    else if (k < size)
    {
        clusters = malloc(sizeof(cluster) * k);
        memset(clusters, 0, k * sizeof(cluster));
        /* STEP 1 */
        for (size_t j = 0; j < size; j++)
        {
            observations[j].group = rand() % k;
        }
        size_t changed = 0;
        size_t minAcceptedError =
            size /
            10000;  // Do until 99.99 percent points are in correct cluster
        int t = 0;
        do
        {
            /* Initialize clusters */
            for (int i = 0; i < k; i++)
            {
                clusters[i].x = 0;
                clusters[i].y = 0;
                clusters[i].count = 0;
            }
            /* STEP 2*/
            for (size_t j = 0; j < size; j++)
            {
                t = observations[j].group;
                clusters[t].x += observations[j].x;
                clusters[t].y += observations[j].y;
                clusters[t].count++;
            }
            for (int i = 0; i < k; i++)
            {
                clusters[i].x /= clusters[i].count;
                clusters[i].y /= clusters[i].count;
            }
            /* STEP 3 and 4 */
            changed = 0;  // this variable stores change in clustering
            for (size_t j = 0; j < size; j++)
            {
                t = calculateNearst(observations + j, clusters, k);
                if (t != observations[j].group)
                {
                    changed++;
                    observations[j].group = t;
                }
            }
        } while (changed > minAcceptedError);  // Keep on grouping until we have
                                               // got almost best clustering
    }
    else
    {
        /* If no of clusters is more than observations
           each observation can be its own cluster
        */
        clusters = (cluster*)malloc(sizeof(cluster) * k);
        memset(clusters, 0, k * sizeof(cluster));
        for (int j = 0; j < size; j++)
        {
            clusters[j].x = observations[j].x;
            clusters[j].y = observations[j].y;
            clusters[j].count = 1;
            observations[j].group = j;
        }
    }
    return clusters;
}

/**
 * @}
 * @}
 */

/*!
 * A function to print observations and clusters
 * The code is taken from
 * http://rosettacode.org/wiki/K-means%2B%2B_clustering.
 * Even the K Means code is also inspired from it
 *
 * @note To print in a file use pipeline operator
 * ```sh
 * ./k_means_clustering > image.eps
 * ```
 *
 * @param observations  observations array
 * @param len  size of observation array
 * @param cent  clusters centroid's array
 * @param k  size of cent array
 */
void printEPS(observation pts[], size_t len, cluster cent[], int k)
{
    int W = 400, H = 400;
    double min_x = DBL_MAX, max_x = DBL_MIN, min_y = DBL_MAX, max_y = DBL_MIN;
    double scale = 0, cx = 0, cy = 0;
    double* colors = (double*)malloc(sizeof(double) * (k * 3));
    int i;
    size_t j;
    double kd = k * 1.0;
    for (i = 0; i < k; i++)
    {
        *(colors + 3 * i) = (3 * (i + 1) % k) / kd;
        *(colors + 3 * i + 1) = (7 * i % k) / kd;
        *(colors + 3 * i + 2) = (9 * i % k) / kd;
    }

    for (j = 0; j < len; j++)
    {
        if (max_x < pts[j].x)
        {
            max_x = pts[j].x;
        }
        if (min_x > pts[j].x)
        {
            min_x = pts[j].x;
        }
        if (max_y < pts[j].y)
        {
            max_y = pts[j].y;
        }
        if (min_y > pts[j].y)
        {
            min_y = pts[j].y;
        }
    }
    scale = W / (max_x - min_x);
    if (scale > (H / (max_y - min_y)))
    {
        scale = H / (max_y - min_y);
    };
    cx = (max_x + min_x) / 2;
    cy = (max_y + min_y) / 2;

    printf("%%!PS-Adobe-3.0 EPSF-3.0\n%%%%BoundingBox: -5 -5 %d %d\n", W + 10,
           H + 10);
    printf(
        "/l {rlineto} def /m {rmoveto} def\n"
        "/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\n"
        "/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath "
        "	gsave 1 setgray fill grestore gsave 3 setlinewidth"
        " 1 setgray stroke grestore 0 setgray stroke }def\n");
    for (int i = 0; i < k; i++)
    {
        printf("%g %g %g setrgbcolor\n", *(colors + 3 * i),
               *(colors + 3 * i + 1), *(colors + 3 * i + 2));
        for (j = 0; j < len; j++)
        {
            if (pts[j].group != i)
            {
                continue;
            }
            printf("%.3f %.3f c\n", (pts[j].x - cx) * scale + W / 2,
                   (pts[j].y - cy) * scale + H / 2);
        }
        printf("\n0 setgray %g %g s\n", (cent[i].x - cx) * scale + W / 2,
               (cent[i].y - cy) * scale + H / 2);
    }
    printf("\n%%%%EOF");

    // free accquired memory
    free(colors);
}

/*!
 * A function to test the kMeans function
 * Generates 100000 points in a circle of
 * radius 20.0 with center at (0,0)
 * and cluster them into 5 clusters
 *
 * <img alt="Output for 100000 points divided in 5 clusters" src=
 * "https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest1.png"
 * width="400px" heiggt="400px">
 * @returns None
 */
static void test()
{
    size_t size = 100000L;
    observation* observations =
        (observation*)malloc(sizeof(observation) * size);
    double maxRadius = 20.00;
    double radius = 0;
    double ang = 0;
    size_t i = 0;
    for (; i < size; i++)
    {
        radius = maxRadius * ((double)rand() / RAND_MAX);
        ang = 2 * M_PI * ((double)rand() / RAND_MAX);
        observations[i].x = radius * cos(ang);
        observations[i].y = radius * sin(ang);
    }
    int k = 5;  // No of clusters
    cluster* clusters = kMeans(observations, size, k);
    printEPS(observations, size, clusters, k);
    // Free the accquired memory
    free(observations);
    free(clusters);
}

/*!
 * A function to test the kMeans function
 * Generates 1000000 points in a circle of
 * radius 20.0 with center at (0,0)
 * and cluster them into 11 clusters
 *
 * <img alt="Output for 1000000 points divided in 11 clusters" src=
 * "https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest2.png"
 * width="400px" heiggt="400px">
 * @returns None
 */
void test2()
{
    size_t size = 1000000L;
    observation* observations =
        (observation*)malloc(sizeof(observation) * size);
    double maxRadius = 20.00;
    double radius = 0;
    double ang = 0;
    size_t i = 0;
    for (; i < size; i++)
    {
        radius = maxRadius * ((double)rand() / RAND_MAX);
        ang = 2 * M_PI * ((double)rand() / RAND_MAX);
        observations[i].x = radius * cos(ang);
        observations[i].y = radius * sin(ang);
    }
    int k = 11;  // No of clusters
    cluster* clusters = kMeans(observations, size, k);
    printEPS(observations, size, clusters, k);
    // Free the accquired memory
    free(observations);
    free(clusters);
}

/*!
 * This function calls the test
 * function
 */
int main()
{
    srand(time(NULL));
    test();
    /* test2(); */
    return 0;
}
/**
 * \file
 * \brief [Kohonen self organizing
 * map](https://en.wikipedia.org/wiki/Self-organizing_map) (data tracing)
 *
 * \details
 * This example implements a powerful self organizing map algorithm.
 * The algorithm creates a connected network of weights that closely
 * follows the given data points. This this creates a chain of nodes that
 * resembles the given input shape.
 * \author [Krishna Vedala](https://github.com/kvedala)
 * \see kohonen_som_topology.c
 */
#define _USE_MATH_DEFINES /**< required for MS Visual C */
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP  // check if OpenMP based parallelization is available
#include <omp.h>
#endif

/**
 * @addtogroup machine_learning Machine learning algorithms
 * @{
 * @addtogroup kohonen_1d Kohonen SOM trace/chain algorithm
 * @{
 */

#ifndef max
/** shorthand for maximum value */
#define max(a, b) (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
/** shorthand for minimum value */
#define min(a, b) (((a) < (b)) ? (a) : (b))
#endif

/**
 * \brief Helper function to generate a random number in a given interval.
 * \details
 * \n Steps:
 * 1. `r1 = rand() % 100` gets a random number between 0 and 99
 * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99
 * 3. scale and offset the random number to given range of \f$[a,b)\f$
 * \f[
 * y = (b - a) \times \frac{\text{(random number between 0 and RAND_MAX)} \;
 * \text{mod}\; 100}{100} + a \f]
 *
 * \param a lower limit
 * \param b upper limit
 * \returns random number in the range \f$[a,b)\f$
 */
double _random(double a, double b)
{
    int r = rand() % 100;
    return ((b - a) * r / 100.f) + a;
}

/**
 * Save a given n-dimensional data martix to file.
 *
 * \param [in] fname filename to save in (gets overwriten without confirmation)
 * \param [in] X matrix to save
 * \param [in] num_points rows in the matrix = number of points
 * \param [in] num_features columns in the matrix = dimensions of points
 * \returns 0 if all ok
 * \returns -1 if file creation failed
 */
int save_nd_data(const char *fname, double **X, int num_points,
                 int num_features)
{
    FILE *fp = fopen(fname, "wt");
    if (!fp)  // error with fopen
    {
        char msg[120];
        sprintf(msg, "File error (%s): ", fname);
        perror(msg);
        return -1;
    }

    for (int i = 0; i < num_points; i++)  // for each point in the array
    {
        for (int j = 0; j < num_features; j++)  // for each feature in the array
        {
            fprintf(fp, "%.4g", X[i][j]);  // print the feature value
            if (j < num_features - 1)      // if not the last feature
                fprintf(fp, ",");          // suffix comma
        }
        if (i < num_points - 1)  // if not the last row
            fprintf(fp, "\n");   // start a new line
    }
    fclose(fp);
    return 0;
}

/**
 * Get minimum value and index of the value in a vector
 * \param[in] X vector to search
 * \param[in] N number of points in the vector
 * \param[out] val minimum value found
 * \param[out] idx index where minimum value was found
 */
void kohonen_get_min_1d(double const *X, int N, double *val, int *idx)
{
    val[0] = INFINITY;  // initial min value

    for (int i = 0; i < N; i++)  // check each value
    {
        if (X[i] < val[0])  // if a lower value is found
        {                   // save the value and its index
            idx[0] = i;
            val[0] = X[i];
        }
    }
}

/**
 * Update weights of the SOM using Kohonen algorithm
 *
 * \param[in] x data point
 * \param[in,out] W weights matrix
 * \param[in,out] D temporary vector to store distances
 * \param[in] num_out number of output points
 * \param[in] num_features number of features per input sample
 * \param[in] alpha learning rate \f$0<\alpha\le1\f$
 * \param[in] R neighborhood range
 */
void kohonen_update_weights(double const *x, double *const *W, double *D,
                            int num_out, int num_features, double alpha, int R)
{
    int j, k;

#ifdef _OPENMP
#pragma omp for
#endif
    // step 1: for each output point
    for (j = 0; j < num_out; j++)
    {
        D[j] = 0.f;
        // compute Euclidian distance of each output
        // point from the current sample
        for (k = 0; k < num_features; k++)
            D[j] += (W[j][k] - x[k]) * (W[j][k] - x[k]);
    }

    // step 2:  get closest node i.e., node with smallest Euclidian distance to
    // the current pattern
    int d_min_idx;
    double d_min;
    kohonen_get_min_1d(D, num_out, &d_min, &d_min_idx);

    // step 3a: get the neighborhood range
    int from_node = max(0, d_min_idx - R);
    int to_node = min(num_out, d_min_idx + R + 1);

    // step 3b: update the weights of nodes in the
    // neighborhood
#ifdef _OPENMP
#pragma omp for
#endif
    for (j = from_node; j < to_node; j++)
        for (k = 0; k < num_features; k++)
            // update weights of nodes in the neighborhood
            W[j][k] += alpha * (x[k] - W[j][k]);
}

/**
 * Apply incremental algorithm with updating neighborhood and learning rates
 * on all samples in the given datset.
 *
 * \param[in] X data set
 * \param[in,out] W weights matrix
 * \param[in] num_samples number of output points
 * \param[in] num_features number of features per input sample
 * \param[in] num_out number of output points
 * \param[in] alpha_min terminal value of alpha
 */
void kohonen_som_tracer(double **X, double *const *W, int num_samples,
                        int num_features, int num_out, double alpha_min)
{
    int R = num_out >> 2, iter = 0;
    double alpha = 1.f;
    double *D = (double *)malloc(num_out * sizeof(double));

    // Loop alpha from 1 to alpha_min
    for (; alpha > alpha_min; alpha -= 0.01, iter++)
    {
        // Loop for each sample pattern in the data set
        for (int sample = 0; sample < num_samples; sample++)
        {
            const double *x = X[sample];
            // update weights for the current input pattern sample
            kohonen_update_weights(x, W, D, num_out, num_features, alpha, R);
        }

        // every 10th iteration, reduce the neighborhood range
        if (iter % 10 == 0 && R > 1)
            R--;
    }

    free(D);
}

/**
 * @}
 * @}
 */

/** Creates a random set of points distributed *near* the circumference
 * of a circle and trains an SOM that finds that circular pattern. The
 * generating function is
 * \f{eqnarray*}{
 * r &\in& [1-\delta r, 1+\delta r)\\
 * \theta &\in& [0, 2\pi)\\
 * x &=& r\cos\theta\\
 * y &=& r\sin\theta
 * \f}
 *
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_circle(double *const *data, int N)
{
    const double R = 0.75, dr = 0.3;
    double a_t = 0., b_t = 2.f * M_PI;  // theta random between 0 and 2*pi
    double a_r = R - dr, b_r = R + dr;  // radius random between R-dr and R+dr
    int i;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        double r = _random(a_r, b_r);      // random radius
        double theta = _random(a_t, b_t);  // random theta
        data[i][0] = r * cos(theta);       // convert from polar to cartesian
        data[i][1] = r * sin(theta);
    }
}

/** Test that creates a random set of points distributed *near* the
 * circumference of a circle and trains an SOM that finds that circular pattern.
 * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)
 * files are created to validate the execution:
 * * `test1.csv`: random test samples points with a circular pattern
 * * `w11.csv`: initial random map
 * * `w12.csv`: trained SOM map
 *
 * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using
 * the following snippet
 * ```gnuplot
 * set datafile separator ','
 * plot "test1.csv" title "original", \
 *      "w11.csv" title "w1", \
 *      "w12.csv" title "w2"
 * ```
 * ![Sample execution
 * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test1.svg)
 */
void test1()
{
    int j, N = 500;
    int features = 2;
    int num_out = 50;

    // 2D space, hence size = number of rows * 2
    double **X = (double **)malloc(N * sizeof(double *));

    // number of clusters nodes * 2
    double **W = (double **)malloc(num_out * sizeof(double *));

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            W[i] = (double *)malloc(features * sizeof(double));
#ifdef _OPENMP
#pragma omp for
#endif
            // preallocate with random initial weights
            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_circle(X, N);  // create test data around circumference of a circle
    save_nd_data("test1.csv", X, N, features);  // save test data points
    save_nd_data("w11.csv", W, num_out,
                 features);  // save initial random weights
    kohonen_som_tracer(X, W, N, features, num_out, 0.1);  // train the SOM
    save_nd_data("w12.csv", W, num_out,
                 features);  // save the resultant weights

    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
}

/** Creates a random set of points distributed *near* the locus
 * of the [Lamniscate of
 * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono).
 * \f{eqnarray*}{
 * \delta r &=& 0.2\\
 * \delta x &\in& [-\delta r, \delta r)\\
 * \delta y &\in& [-\delta r, \delta r)\\
 * \theta &\in& [0, \pi)\\
 * x &=& \delta x + \cos\theta\\
 * y &=& \delta y + \frac{\sin(2\theta)}{2}
 * \f}
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_lamniscate(double *const *data, int N)
{
    const double dr = 0.2;
    int i;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        double dx = _random(-dr, dr);     // random change in x
        double dy = _random(-dr, dr);     // random change in y
        double theta = _random(0, M_PI);  // random theta
        data[i][0] = dx + cos(theta);     // convert from polar to cartesian
        data[i][1] = dy + sin(2. * theta) / 2.f;
    }
}

/** Test that creates a random set of points distributed *near* the locus
 * of the [Lamniscate of
 * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono) and trains an SOM
 * that finds that circular pattern. The following
 * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created
 * to validate the execution:
 * * `test2.csv`: random test samples points with a lamniscate pattern
 * * `w21.csv`: initial random map
 * * `w22.csv`: trained SOM map
 *
 * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using
 * the following snippet
 * ```gnuplot
 * set datafile separator ','
 * plot "test2.csv" title "original", \
 *      "w21.csv" title "w1", \
 *      "w22.csv" title "w2"
 * ```
 * ![Sample execution
 * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test2.svg)
 */
void test2()
{
    int j, N = 500;
    int features = 2;
    int num_out = 20;
    double **X = (double **)malloc(N * sizeof(double *));
    double **W = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            W[i] = (double *)malloc(features * sizeof(double));

#ifdef _OPENMP
#pragma omp for
#endif
            // preallocate with random initial weights
            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_lamniscate(X, N);  // create test data around the lamniscate
    save_nd_data("test2.csv", X, N, features);  // save test data points
    save_nd_data("w21.csv", W, num_out,
                 features);  // save initial random weights
    kohonen_som_tracer(X, W, N, features, num_out, 0.01);  // train the SOM
    save_nd_data("w22.csv", W, num_out,
                 features);  // save the resultant weights

    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
    free(X);
    free(W);
}

/** Creates a random set of points distributed in four clusters in
 * 3D space with centroids at the points
 * * \f$(0,5, 0.5, 0.5)\f$
 * * \f$(0,5,-0.5, -0.5)\f$
 * * \f$(-0,5, 0.5, 0.5)\f$
 * * \f$(-0,5,-0.5, -0.5)\f$
 *
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_3d_classes(double *const *data, int N)
{
    const double R = 0.1;  // radius of cluster
    int i;
    const int num_classes = 4;
    const double centres[][3] = {
        // centres of each class cluster
        {.5, .5, .5},    // centre of class 1
        {.5, -.5, -.5},  // centre of class 2
        {-.5, .5, .5},   // centre of class 3
        {-.5, -.5 - .5}  // centre of class 4
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        /* The follosing can also be used
        for (int j = 0; j < 3; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}

/** Test that creates a random set of points distributed in six clusters in
 * 3D space. The following
 * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created
 * to validate the execution:
 * * `test3.csv`: random test samples points with a circular pattern
 * * `w31.csv`: initial random map
 * * `w32.csv`: trained SOM map
 *
 * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using
 * the following snippet
 * ```gnuplot
 * set datafile separator ','
 * plot "test3.csv" title "original", \
 *      "w31.csv" title "w1", \
 *      "w32.csv" title "w2"
 * ```
 * ![Sample execution
 * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test3.svg)
 */
void test3()
{
    int j, N = 200;
    int features = 3;
    int num_out = 20;
    double **X = (double **)malloc(N * sizeof(double *));
    double **W = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            W[i] = (double *)malloc(features * sizeof(double));

#ifdef _OPENMP
#pragma omp for
#endif
            // preallocate with random initial weights
            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);
        }
    }

    test_3d_classes(X, N);  // create test data around the lamniscate
    save_nd_data("test3.csv", X, N, features);  // save test data points
    save_nd_data("w31.csv", W, num_out,
                 features);  // save initial random weights
    kohonen_som_tracer(X, W, N, features, num_out, 0.01);  // train the SOM
    save_nd_data("w32.csv", W, num_out,
                 features);  // save the resultant weights

    for (int i = 0; i < max(num_out, N); i++)
    {
        if (i < N)
            free(X[i]);
        if (i < num_out)
            free(W[i]);
    }
    free(X);
    free(W);
}

/**
 * Convert clock cycle difference to time in seconds
 *
 * \param[in] start_t start clock
 * \param[in] end_t end clock
 * \returns time difference in seconds
 */
double get_clock_diff(clock_t start_t, clock_t end_t)
{
    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;
}

/** Main function */
int main(int argc, char **argv)
{
#ifdef _OPENMP
    printf("Using OpenMP based parallelization\n");
#else
    printf("NOT using OpenMP based parallelization\n");
#endif
    clock_t start_clk = clock();
    test1();
    clock_t end_clk = clock();
    printf("Test 1 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));
    start_clk = clock();
    test2();
    end_clk = clock();
    printf("Test 2 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));
    start_clk = clock();
    test3();
    end_clk = clock();
    printf("Test 3 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));
    printf(
        "(Note: Calculated times include: creating test sets, training "
        "model and writing files to disk.)\n\n");
    return 0;
}
/**
 * \file
 * \brief [Kohonen self organizing
 * map](https://en.wikipedia.org/wiki/Self-organizing_map) (topological map)
 *
 * This example implements a powerful unsupervised learning algorithm called as
 * a self organizing map. The algorithm creates a connected network of weights
 * that closely follows the given data points. This thus creates a topological
 * map of the given data i.e., it maintains the relationship between various
 * data points in a much higher dimensional space by creating an equivalent in a
 * 2-dimensional space.
 * <img alt="Trained topological maps for the test cases in the program"
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/2D_Kohonen_SOM.svg"
 * />
 * \author [Krishna Vedala](https://github.com/kvedala)
 * \warning MSVC 2019 compiler generates code that does not execute as expected.
 * However, MinGW, Clang for GCC and Clang for MSVC compilers on windows perform
 * as expected. Any insights and suggestions should be directed to the author.
 * \see kohonen_som_trace.c
 */
#define _USE_MATH_DEFINES /**< required for MS Visual C */
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP  // check if OpenMP based parallellization is available
#include <omp.h>
#endif

/**
 * @addtogroup machine_learning Machine learning algorithms
 * @{
 * @addtogroup kohonen_2d Kohonen SOM topology algorithm
 * @{
 */

#ifndef max
/** shorthand for maximum value */
#define max(a, b) (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
/** shorthand for minimum value */
#define min(a, b) (((a) < (b)) ? (a) : (b))
#endif

/** to store info regarding 3D arrays */
struct kohonen_array_3d
{
    int dim1;     /**< lengths of first dimension */
    int dim2;     /**< lengths of second dimension */
    int dim3;     /**< lengths of thirddimension */
    double *data; /**< pointer to data */
};

/** Function that returns the pointer to (x, y, z) ^th location in the
 * linear 3D array given by:
 * \f[
 * X_{i,j,k} = i\times M\times N + j\times N + k
 * \f]
 * where \f$L\f$, \f$M\f$ and \f$N\f$ are the 3D matrix dimensions.
 * \param[in] arr pointer to ::kohonen_array_3d structure
 * \param[in] x     first index
 * \param[in] y     second index
 * \param[in] z     third index
 * \returns pointer to (x,y,z)^th location of data
 */
double *kohonen_data_3d(const struct kohonen_array_3d *arr, int x, int y, int z)
{
    int offset = (x * arr->dim2 * arr->dim3) + (y * arr->dim3) + z;
    return arr->data + offset;
}

/**
 * Helper function to generate a random number in a given interval.
 * \n Steps:
 * 1. `r1 = rand() % 100` gets a random number between 0 and 99
 * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99
 * 3. scale and offset the random number to given range of \f$[a,b)\f$
 * \f[
 * y = (b - a) \times \frac{\text{(random number between 0 and RAND_MAX)} \;
 * \text{mod}\; 100}{100} + a \f]
 *
 * \param[in] a lower limit
 * \param[in] b upper limit
 * \returns random number in the range \f$[a,b)\f$
 */
double _random(double a, double b)
{
    return ((b - a) * (rand() % 100) / 100.f) + a;
}

/**
 * Save a given n-dimensional data martix to file.
 *
 * \param[in] fname filename to save in (gets overwritten without confirmation)
 * \param[in] X matrix to save
 * \param[in] num_points rows in the matrix = number of points
 * \param[in] num_features columns in the matrix = dimensions of points
 * \returns 0 if all ok
 * \returns -1 if file creation failed
 */
int save_2d_data(const char *fname, double **X, int num_points,
                 int num_features)
{
    FILE *fp = fopen(fname, "wt");
    if (!fp)  // error with fopen
    {
        char msg[120];
        sprintf(msg, "File error (%s): ", fname);
        perror(msg);
        return -1;
    }

    for (int i = 0; i < num_points; i++)  // for each point in the array
    {
        for (int j = 0; j < num_features; j++)  // for each feature in the array
        {
            fprintf(fp, "%.4g", X[i][j]);  // print the feature value
            if (j < num_features - 1)      // if not the last feature
                fputc(',', fp);            // suffix comma
        }
        if (i < num_points - 1)  // if not the last row
            fputc('\n', fp);     // start a new line
    }
    fclose(fp);
    return 0;
}

/**
 * Create the distance matrix or
 * [U-matrix](https://en.wikipedia.org/wiki/U-matrix) from the trained weights
 * and save to disk.
 *
 * \param [in] fname filename to save in (gets overwriten without confirmation)
 * \param [in] W model matrix to save
 * \returns 0 if all ok
 * \returns -1 if file creation failed
 */
int save_u_matrix(const char *fname, struct kohonen_array_3d *W)
{
    FILE *fp = fopen(fname, "wt");
    if (!fp)  // error with fopen
    {
        char msg[120];
        sprintf(msg, "File error (%s): ", fname);
        perror(msg);
        return -1;
    }

    int R = max(W->dim1 >> 3, 2); /* neighborhood range */

    for (int i = 0; i < W->dim1; i++)  // for each x
    {
        for (int j = 0; j < W->dim2; j++)  // for each y
        {
            double distance = 0.f;
            int k;

            int from_x = max(0, i - R);
            int to_x = min(W->dim1, i + R + 1);
            int from_y = max(0, j - R);
            int to_y = min(W->dim2, j + R + 1);
            int l;
#ifdef _OPENMP
#pragma omp parallel for reduction(+ : distance)
#endif
            for (l = from_x; l < to_x; l++)  // scan neighborhoor in x
            {
                for (int m = from_y; m < to_y; m++)  // scan neighborhood in y
                {
                    double d = 0.f;
                    for (k = 0; k < W->dim3; k++)  // for each feature
                    {
                        double *w1 = kohonen_data_3d(W, i, j, k);
                        double *w2 = kohonen_data_3d(W, l, m, k);
                        d += (w1[0] - w2[0]) * (w1[0] - w2[0]);
                        // distance += w1[0] * w1[0];
                    }
                    distance += sqrt(d);
                    // distance += d;
                }
            }

            distance /= R * R;              // mean distance from neighbors
            fprintf(fp, "%.4g", distance);  // print the mean separation
            if (j < W->dim2 - 1)            // if not the last column
                fputc(',', fp);             // suffix comma
        }
        if (i < W->dim1 - 1)  // if not the last row
            fputc('\n', fp);  // start a new line
    }
    fclose(fp);
    return 0;
}

/**
 * Get minimum value and index of the value in a matrix
 * \param[in] X matrix to search
 * \param[in] N number of points in the vector
 * \param[out] val minimum value found
 * \param[out] x_idx x-index where minimum value was found
 * \param[out] y_idx y-index where minimum value was found
 */
void get_min_2d(double **X, int N, double *val, int *x_idx, int *y_idx)
{
    val[0] = INFINITY;  // initial min value

    for (int i = 0; i < N; i++)  // traverse each x-index
    {
        for (int j = 0; j < N; j++)  // traverse each y-index
        {
            if (X[i][j] < val[0])  // if a lower value is found
            {                      // save the value and its index
                x_idx[0] = i;
                y_idx[0] = j;
                val[0] = X[i][j];
            }
        }
    }
}

/**
 * Update weights of the SOM using Kohonen algorithm
 *
 * \param[in] X data point
 * \param[in,out] W weights matrix
 * \param[in,out] D temporary vector to store distances
 * \param[in] num_out number of output points
 * \param[in] num_features number of features per input sample
 * \param[in] alpha learning rate \f$0<\alpha\le1\f$
 * \param[in] R neighborhood range
 * \returns minimum distance of sample and trained weights
 */
double kohonen_update_weights(const double *X, struct kohonen_array_3d *W,
                              double **D, int num_out, int num_features,
                              double alpha, int R)
{
    int x, y, k;
    double d_min = 0.f;

#ifdef _OPENMP
#pragma omp for
#endif
    // step 1: for each 2D output point
    for (x = 0; x < num_out; x++)
    {
        for (y = 0; y < num_out; y++)
        {
            D[x][y] = 0.f;
            // compute Euclidian distance of each output
            // point from the current sample
            for (k = 0; k < num_features; k++)
            {
                double *w = kohonen_data_3d(W, x, y, k);
                D[x][y] += (w[0] - X[k]) * (w[0] - X[k]);
            }
            D[x][y] = sqrt(D[x][y]);
        }
    }

    // step 2:  get closest node i.e., node with smallest Euclidian distance to
    // the current pattern
    int d_min_x, d_min_y;
    get_min_2d(D, num_out, &d_min, &d_min_x, &d_min_y);

    // step 3a: get the neighborhood range
    int from_x = max(0, d_min_x - R);
    int to_x = min(num_out, d_min_x + R + 1);
    int from_y = max(0, d_min_y - R);
    int to_y = min(num_out, d_min_y + R + 1);

    // step 3b: update the weights of nodes in the
    // neighborhood
#ifdef _OPENMP
#pragma omp for
#endif
    for (x = from_x; x < to_x; x++)
    {
        for (y = from_y; y < to_y; y++)
        {
            /* you can enable the following normalization if needed.
               personally, I found it detrimental to convergence */
            // const double s2pi = sqrt(2.f * M_PI);
            // double normalize = 1.f / (alpha * s2pi);

            /* apply scaling inversely proportional to distance from the
               current node */
            double d2 =
                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);
            double scale_factor = exp(-d2 / (2.f * alpha * alpha));

            for (k = 0; k < num_features; k++)
            {
                double *w = kohonen_data_3d(W, x, y, k);
                // update weights of nodes in the neighborhood
                w[0] += alpha * scale_factor * (X[k] - w[0]);
            }
        }
    }
    return d_min;
}

/**
 * Apply incremental algorithm with updating neighborhood and learning rates
 * on all samples in the given datset.
 *
 * \param[in] X data set
 * \param[in,out] W weights matrix
 * \param[in] num_samples number of output points
 * \param[in] num_features number of features per input sample
 * \param[in] num_out number of output points
 * \param[in] alpha_min terminal value of alpha
 */
void kohonen_som(double **X, struct kohonen_array_3d *W, int num_samples,
                 int num_features, int num_out, double alpha_min)
{
    int R = num_out >> 2, iter = 0;
    double **D = (double **)malloc(num_out * sizeof(double *));
    for (int i = 0; i < num_out; i++)
        D[i] = (double *)malloc(num_out * sizeof(double));

    double dmin = 1.f;  // average minimum distance of all samples

    // Loop alpha from 1 to slpha_min
    for (double alpha = 1.f; alpha > alpha_min && dmin > 1e-3;
         alpha -= 0.001, iter++)
    {
        dmin = 0.f;
        // Loop for each sample pattern in the data set
        for (int sample = 0; sample < num_samples; sample++)
        {
            // update weights for the current input pattern sample
            dmin += kohonen_update_weights(X[sample], W, D, num_out,
                                           num_features, alpha, R);
        }

        // every 20th iteration, reduce the neighborhood range
        if (iter % 100 == 0 && R > 1)
            R--;

        dmin /= num_samples;
        printf("iter: %5d\t alpha: %.4g\t R: %d\td_min: %.4g\r", iter, alpha, R,
               dmin);
    }
    putchar('\n');

    for (int i = 0; i < num_out; i++) free(D[i]);
    free(D);
}

/**
 * @}
 * @}
 */

/** Creates a random set of points distributed in four clusters in
 * 3D space with centroids at the points
 * * \f$(0,5, 0.5, 0.5)\f$
 * * \f$(0,5,-0.5, -0.5)\f$
 * * \f$(-0,5, 0.5, 0.5)\f$
 * * \f$(-0,5,-0.5, -0.5)\f$
 *
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_2d_classes(double *const *data, int N)
{
    const double R = 0.3;  // radius of cluster
    int i;
    const int num_classes = 4;
    const double centres[][2] = {
        // centres of each class cluster
        {.5, .5},   // centre of class 1
        {.5, -.5},  // centre of class 2
        {-.5, .5},  // centre of class 3
        {-.5, -.5}  // centre of class 4
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);

        /* The follosing can also be used
        for (int j = 0; j < 2; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}

/** Test that creates a random set of points distributed in four clusters in
 * 2D space and trains an SOM that finds the topological pattern.
 * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)
 * files are created to validate the execution:
 * * `test1.csv`: random test samples points with a circular pattern
 * * `w11.csv`: initial random U-matrix
 * * `w12.csv`: trained SOM U-matrix
 */
void test1()
{
    int j, N = 300;
    int features = 2;
    int num_out = 30;  // image size - N x N

    // 2D space, hence size = number of rows * 2
    double **X = (double **)malloc(N * sizeof(double *));

    // cluster nodex in 'x' * cluster nodes in 'y' * 2
    struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  // assign rows

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                // preallocate with random initial weights
                for (j = 0; j < features; j++)
                {
                    double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_2d_classes(X, N);  // create test data around circumference of a circle
    save_2d_data("test1.csv", X, N, features);  // save test data points
    save_u_matrix("w11.csv", &W);               // save initial random weights
    kohonen_som(X, &W, N, features, num_out, 1e-4);  // train the SOM
    save_u_matrix("w12.csv", &W);  // save the resultant weights

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}

/** Creates a random set of points distributed in four clusters in
 * 3D space with centroids at the points
 * * \f$(0,5, 0.5, 0.5)\f$
 * * \f$(0,5,-0.5, -0.5)\f$
 * * \f$(-0,5, 0.5, 0.5)\f$
 * * \f$(-0,5,-0.5, -0.5)\f$
 *
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_3d_classes1(double *const *data, int N)
{
    const double R = 0.2;  // radius of cluster
    int i;
    const int num_classes = 4;
    const double centres[][3] = {
        // centres of each class cluster
        {.5, .5, .5},    // centre of class 1
        {.5, -.5, -.5},  // centre of class 2
        {-.5, .5, .5},   // centre of class 3
        {-.5, -.5 - .5}  // centre of class 4
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        /* The follosing can also be used
        for (int j = 0; j < 3; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}

/** Test that creates a random set of points distributed in 4 clusters in
 * 3D space and trains an SOM that finds the topological pattern. The following
 * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created
 * to validate the execution:
 * * `test2.csv`: random test samples points
 * * `w21.csv`: initial random U-matrix
 * * `w22.csv`: trained SOM U-matrix
 */
void test2()
{
    int j, N = 500;
    int features = 3;
    int num_out = 30;  // image size - N x N

    // 3D space, hence size = number of rows * 3
    double **X = (double **)malloc(N * sizeof(double *));

    // cluster nodex in 'x' * cluster nodes in 'y' * 2
    struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  // assign rows

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                for (j = 0; j < features; j++)
                {  // preallocate with random initial weights
                    double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_3d_classes1(X, N);                     // create test data
    save_2d_data("test2.csv", X, N, features);  // save test data points
    save_u_matrix("w21.csv", &W);               // save initial random weights
    kohonen_som(X, &W, N, features, num_out, 1e-4);  // train the SOM
    save_u_matrix("w22.csv", &W);  // save the resultant weights

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}

/** Creates a random set of points distributed in four clusters in
 * 3D space with centroids at the points
 * * \f$(0,5, 0.5, 0.5)\f$
 * * \f$(0,5,-0.5, -0.5)\f$
 * * \f$(-0,5, 0.5, 0.5)\f$
 * * \f$(-0,5,-0.5, -0.5)\f$
 *
 * \param[out] data matrix to store data in
 * \param[in] N number of points required
 */
void test_3d_classes2(double *const *data, int N)
{
    const double R = 0.2;  // radius of cluster
    int i;
    const int num_classes = 8;
    const double centres[][3] = {
        // centres of each class cluster
        {.5, .5, .5},    // centre of class 1
        {.5, .5, -.5},   // centre of class 2
        {.5, -.5, .5},   // centre of class 3
        {.5, -.5, -.5},  // centre of class 4
        {-.5, .5, .5},   // centre of class 5
        {-.5, .5, -.5},  // centre of class 6
        {-.5, -.5, .5},  // centre of class 7
        {-.5, -.5, -.5}  // centre of class 8
    };

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        int class =
            rand() % num_classes;  // select a random class for the point

        // create random coordinates (x,y,z) around the centre of the class
        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);
        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);
        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);

        /* The follosing can also be used
        for (int j = 0; j < 3; j++)
            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);
        */
    }
}

/** Test that creates a random set of points distributed in eight clusters in
 * 3D space and trains an SOM that finds the topological pattern. The following
 * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created
 * to validate the execution:
 * * `test3.csv`: random test samples points
 * * `w31.csv`: initial random U-matrix
 * * `w32.csv`: trained SOM U-matrix
 */
void test3()
{
    int j, N = 500;
    int features = 3;
    int num_out = 30;
    double **X = (double **)malloc(N * sizeof(double *));

    // cluster nodex in 'x' * cluster nodes in 'y' * 2
    struct kohonen_array_3d W;
    W.dim1 = num_out;
    W.dim2 = num_out;
    W.dim3 = features;
    W.data = (double *)malloc(num_out * num_out * features *
                              sizeof(double));  // assign rows

    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)
    {
        if (i < N)  // only add new arrays if i < N
            X[i] = (double *)malloc(features * sizeof(double));
        if (i < num_out)  // only add new arrays if i < num_out
        {
            for (int k = 0; k < num_out; k++)
            {
#ifdef _OPENMP
#pragma omp for
#endif
                // preallocate with random initial weights
                for (j = 0; j < features; j++)
                {
                    double *w = kohonen_data_3d(&W, i, k, j);
                    w[0] = _random(-5, 5);
                }
            }
        }
    }

    test_3d_classes2(X, N);  // create test data around the lamniscate
    save_2d_data("test3.csv", X, N, features);  // save test data points
    save_u_matrix("w31.csv", &W);               // save initial random weights
    kohonen_som(X, &W, N, features, num_out, 0.01);  // train the SOM
    save_u_matrix("w32.csv", &W);  // save the resultant weights

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(W.data);
}

/**
 * Convert clock cycle difference to time in seconds
 *
 * \param[in] start_t start clock
 * \param[in] end_t end clock
 * \returns time difference in seconds
 */
double get_clock_diff(clock_t start_t, clock_t end_t)
{
    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;
}

/** Main function */
int main(int argc, char **argv)
{
#ifdef _OPENMP
    printf("Using OpenMP based parallelization\n");
#else
    printf("NOT using OpenMP based parallelization\n");
#endif
    clock_t start_clk, end_clk;

    start_clk = clock();
    test1();
    end_clk = clock();
    printf("Test 1 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));

    start_clk = clock();
    test2();
    end_clk = clock();
    printf("Test 2 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));

    start_clk = clock();
    test3();
    end_clk = clock();
    printf("Test 3 completed in %.4g sec\n",
           get_clock_diff(start_clk, end_clk));

    printf("(Note: Calculated times include: writing files to disk.)\n\n");
    return 0;
}
/**
 * \file
 * \brief [Adaptive Linear Neuron
 * (ADALINE)](https://en.wikipedia.org/wiki/ADALINE) implementation
 * \details
 * <img
 * src="https://upload.wikimedia.org/wikipedia/commons/b/be/Adaline_flow_chart.gif"
 * width="200px">
 * [source](https://commons.wikimedia.org/wiki/File:Adaline_flow_chart.gif)
 * ADALINE is one of the first and simplest single layer artificial neural
 * network. The algorithm essentially implements a linear function
 * \f[ f\left(x_0,x_1,x_2,\ldots\right) =
 * \sum_j x_jw_j+\theta
 * \f]
 * where \f$x_j\f$ are the input features of a sample, \f$w_j\f$ are the
 * coefficients of the linear function and \f$\theta\f$ is a constant. If we
 * know the \f$w_j\f$, then for any given set of features, \f$y\f$ can be
 * computed. Computing the \f$w_j\f$ is a supervised learning algorithm wherein
 * a set of features and their corresponding outputs are given and weights are
 * computed using stochastic gradient descent method.
 * \author [Krishna Vedala](https://github.com/kvedala)
 */

#include <assert.h>
#include <limits.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * @addtogroup machine_learning Machine learning algorithms
 * @{
 * @addtogroup adaline Adaline learning algorithm
 * @{
 */

/** Maximum number of iterations to learn */
#define MAX_ADALINE_ITER 500  // INT_MAX

/** structure to hold adaline model parameters */
struct adaline
{
    double eta;      /**< learning rate of the algorithm */
    double *weights; /**< weights of the neural network */
    int num_weights; /**< number of weights of the neural network */
};

/** convergence accuracy \f$=1\times10^{-5}\f$ */
#define ADALINE_ACCURACY 1e-5

/**
 * Default constructor
 * \param[in] num_features number of features present
 * \param[in] eta learning rate (optional, default=0.1)
 * \returns new adaline model
 */
struct adaline new_adaline(const int num_features, const double eta)
{
    if (eta <= 0.f || eta >= 1.f)
    {
        fprintf(stderr, "learning rate should be > 0 and < 1\n");
        exit(EXIT_FAILURE);
    }

    // additional weight is for the constant bias term
    int num_weights = num_features + 1;
    struct adaline ada;
    ada.eta = eta;
    ada.num_weights = num_weights;
    ada.weights = (double *)malloc(num_weights * sizeof(double));
    if (!ada.weights)
    {
        perror("Unable to allocate error for weights!");
        return ada;
    }

    // initialize with random weights in the range [-50, 49]
    for (int i = 0; i < num_weights; i++) ada.weights[i] = 1.f;
    // ada.weights[i] = (double)(rand() % 100) - 50);

    return ada;
}

/** delete dynamically allocated memory
 * \param[in] ada model from which the memory is to be freed.
 */
void delete_adaline(struct adaline *ada)
{
    if (ada == NULL)
        return;

    free(ada->weights);
};

/** [Heaviside activation
 * function](https://en.wikipedia.org/wiki/Heaviside_step_function) <img
 * src="https://upload.wikimedia.org/wikipedia/commons/d/d9/Dirac_distribution_CDF.svg"
 * width="200px"/>
 * @param x activation function input
 * @returns \f$f(x)= \begin{cases}1 & \forall\; x > 0\\ -1 & \forall\; x \le0
 * \end{cases}\f$
 */
int adaline_activation(double x) { return x > 0 ? 1 : -1; }

/**
 * Operator to print the weights of the model
 * @param ada model for which the values to print
 * @returns pointer to a NULL terminated string of formatted weights
 */
char *adaline_get_weights_str(const struct adaline *ada)
{
    static char out[100];  // static so the value is persistent

    sprintf(out, "<");
    for (int i = 0; i < ada->num_weights; i++)
    {
        sprintf(out, "%s%.4g", out, ada->weights[i]);
        if (i < ada->num_weights - 1)
            sprintf(out, "%s, ", out);
    }
    sprintf(out, "%s>", out);
    return out;
}

/**
 * predict the output of the model for given set of features
 *
 * \param[in] ada adaline model to predict
 * \param[in] x input vector
 * \param[out] out optional argument to return neuron output before applying
 * activation function (`NULL` to ignore)
 * \returns model prediction output
 */
int adaline_predict(struct adaline *ada, const double *x, double *out)
{
    double y = ada->weights[ada->num_weights - 1];  // assign bias value

    for (int i = 0; i < ada->num_weights - 1; i++) y += x[i] * ada->weights[i];

    if (out)  // if out variable is not NULL
        *out = y;

    // quantizer: apply ADALINE threshold function
    return adaline_activation(y);
}

/**
 * Update the weights of the model using supervised learning for one feature
 * vector
 *
 * \param[in] ada adaline model to fit
 * \param[in] x feature vector
 * \param[in] y known output  value
 * \returns correction factor
 */
double adaline_fit_sample(struct adaline *ada, const double *x, const int y)
{
    /* output of the model with current weights */
    int p = adaline_predict(ada, x, NULL);
    int prediction_error = y - p;  // error in estimation
    double correction_factor = ada->eta * prediction_error;

    /* update each weight, the last weight is the bias term */
    for (int i = 0; i < ada->num_weights - 1; i++)
    {
        ada->weights[i] += correction_factor * x[i];
    }
    ada->weights[ada->num_weights - 1] += correction_factor;  // update bias

    return correction_factor;
}

/**
 * Update the weights of the model using supervised learning for an array of
 * vectors.
 *
 * \param[in] ada adaline model to train
 * \param[in] X array of feature vector
 * \param[in] y known output value for each feature vector
 * \param[in] N number of training samples
 */
void adaline_fit(struct adaline *ada, double **X, const int *y, const int N)
{
    double avg_pred_error = 1.f;

    int iter;
    for (iter = 0;
         (iter < MAX_ADALINE_ITER) && (avg_pred_error > ADALINE_ACCURACY);
         iter++)
    {
        avg_pred_error = 0.f;

        // perform fit for each sample
        for (int i = 0; i < N; i++)
        {
            double err = adaline_fit_sample(ada, X[i], y[i]);
            avg_pred_error += fabs(err);
        }
        avg_pred_error /= N;

        // Print updates every 200th iteration
        // if (iter % 100 == 0)
        printf("\tIter %3d: Training weights: %s\tAvg error: %.4f\n", iter,
               adaline_get_weights_str(ada), avg_pred_error);
    }

    if (iter < MAX_ADALINE_ITER)
        printf("Converged after %d iterations.\n", iter);
    else
        printf("Did not converged after %d iterations.\n", iter);
}

/** @}
 *  @}
 */

/**
 * test function to predict points in a 2D coordinate system above the line
 * \f$x=y\f$ as +1 and others as -1.
 * Note that each point is defined by 2 values or 2 features.
 * \param[in] eta learning rate (optional, default=0.01)
 */
void test1(double eta)
{
    struct adaline ada = new_adaline(2, eta);  // 2 features

    const int N = 10;  // number of sample points
    const double saved_X[10][2] = {{0, 1},  {1, -2},   {2, 3},   {3, -1},
                                   {4, 1},  {6, -5},   {-7, -3}, {-8, 5},
                                   {-9, 2}, {-10, -15}};

    double **X = (double **)malloc(N * sizeof(double *));
    const int Y[10] = {1,  -1, 1, -1, -1,
                       -1, 1,  1, 1,  -1};  // corresponding y-values
    for (int i = 0; i < N; i++)
    {
        X[i] = (double *)saved_X[i];
    }

    printf("------- Test 1 -------\n");
    printf("Model before fit: %s\n", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf("Model after fit: %s\n", adaline_get_weights_str(&ada));

    double test_x[] = {5, -3};
    int pred = adaline_predict(&ada, test_x, NULL);
    printf("Predict for x=(5,-3): % d\n", pred);
    assert(pred == -1);
    printf(" ...passed\n");

    double test_x2[] = {5, 8};
    pred = adaline_predict(&ada, test_x2, NULL);
    printf("Predict for x=(5, 8): % d\n", pred);
    assert(pred == 1);
    printf(" ...passed\n");

    // for (int i = 0; i < N; i++)
    //     free(X[i]);
    free(X);
    delete_adaline(&ada);
}

/**
 * test function to predict points in a 2D coordinate system above the line
 * \f$x+3y=-1\f$ as +1 and others as -1.
 * Note that each point is defined by 2 values or 2 features.
 * The function will create random sample points for training and test purposes.
 * \param[in] eta learning rate (optional, default=0.01)
 */
void test2(double eta)
{
    struct adaline ada = new_adaline(2, eta);  // 2 features

    const int N = 50;  // number of sample points

    double **X = (double **)malloc(N * sizeof(double *));
    int *Y = (int *)malloc(N * sizeof(int));  // corresponding y-values
    for (int i = 0; i < N; i++) X[i] = (double *)malloc(2 * sizeof(double));

    // generate sample points in the interval
    // [-range2/100 , (range2-1)/100]
    int range = 500;          // sample points full-range
    int range2 = range >> 1;  // sample points half-range
    for (int i = 0; i < N; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        X[i][0] = x0;
        X[i][1] = x1;
        Y[i] = (x0 + 3. * x1) > -1 ? 1 : -1;
    }

    printf("------- Test 2 -------\n");
    printf("Model before fit: %s\n", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf("Model after fit: %s\n", adaline_get_weights_str(&ada));

    int N_test_cases = 5;
    double test_x[2];
    for (int i = 0; i < N_test_cases; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;

        test_x[0] = x0;
        test_x[1] = x1;
        int pred = adaline_predict(&ada, test_x, NULL);
        printf("Predict for x=(% 3.2f,% 3.2f): % d\n", x0, x1, pred);

        int expected_val = (x0 + 3. * x1) > -1 ? 1 : -1;
        assert(pred == expected_val);
        printf(" ...passed\n");
    }

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(Y);
    delete_adaline(&ada);
}

/**
 * test function to predict points in a 3D coordinate system lying within the
 * sphere of radius 1 and centre at origin as +1 and others as -1. Note that
 * each point is defined by 3 values but we use 6 features. The function will
 * create random sample points for training and test purposes.
 * The sphere centred at origin and radius 1 is defined as:
 * \f$x^2+y^2+z^2=r^2=1\f$ and if the \f$r^2<1\f$, point lies within the sphere
 * else, outside.
 *
 * \param[in] eta learning rate (optional, default=0.01)
 */
void test3(double eta)
{
    struct adaline ada = new_adaline(6, eta);  // 2 features

    const int N = 50;  // number of sample points

    double **X = (double **)malloc(N * sizeof(double *));
    int *Y = (int *)malloc(N * sizeof(int));  // corresponding y-values
    for (int i = 0; i < N; i++) X[i] = (double *)malloc(6 * sizeof(double));

    // generate sample points in the interval
    // [-range2/100 , (range2-1)/100]
    int range = 200;          // sample points full-range
    int range2 = range >> 1;  // sample points half-range
    for (int i = 0; i < N; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        double x2 = ((rand() % range) - range2) / 100.f;
        X[i][0] = x0;
        X[i][1] = x1;
        X[i][2] = x2;
        X[i][3] = x0 * x0;
        X[i][4] = x1 * x1;
        X[i][5] = x2 * x2;
        Y[i] = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;
    }

    printf("------- Test 3 -------\n");
    printf("Model before fit: %s\n", adaline_get_weights_str(&ada));

    adaline_fit(&ada, X, Y, N);
    printf("Model after fit: %s\n", adaline_get_weights_str(&ada));

    int N_test_cases = 5;
    double test_x[6];
    for (int i = 0; i < N_test_cases; i++)
    {
        double x0 = ((rand() % range) - range2) / 100.f;
        double x1 = ((rand() % range) - range2) / 100.f;
        double x2 = ((rand() % range) - range2) / 100.f;
        test_x[0] = x0;
        test_x[1] = x1;
        test_x[2] = x2;
        test_x[3] = x0 * x0;
        test_x[4] = x1 * x1;
        test_x[5] = x2 * x2;
        int pred = adaline_predict(&ada, test_x, NULL);
        printf("Predict for x=(% 3.2f,% 3.2f): % d\n", x0, x1, pred);

        int expected_val = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;
        assert(pred == expected_val);
        printf(" ...passed\n");
    }

    for (int i = 0; i < N; i++) free(X[i]);
    free(X);
    free(Y);
    delete_adaline(&ada);
}

/** Main function */
int main(int argc, char **argv)
{
    srand(time(NULL));  // initialize random number generator

    double eta = 0.1;  // default value of eta
    if (argc == 2)     // read eta value from commandline argument if present
        eta = strtof(argv[1], NULL);

    test1(eta);

    printf("Press ENTER to continue...\n");
    getchar();

    test2(eta);

    printf("Press ENTER to continue...\n");
    getchar();

    test3(eta);

    return 0;
}
/**
 * @file
 * \brief Program to compute the [QR
 * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given
 * matrix.
 * \author [Krishna Vedala](https://github.com/kvedala)
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "qr_decompose.h"

/**
 * main function
 */
int main(void)
{
    double **A;
    unsigned int ROWS, COLUMNS;

    printf("Enter the number of rows and columns: ");
    scanf("%u %u", &ROWS, &COLUMNS);
    if (ROWS < COLUMNS)
    {
        fprintf(stderr,
                "Number of rows must be greater than or equal to "
                "number of columns.\n");
        return -1;
    }

    printf("Enter matrix elements row-wise:\n");

    A = (double **)malloc(ROWS * sizeof(double *));
    for (int i = 0; i < ROWS; i++)
        A[i] = (double *)malloc(COLUMNS * sizeof(double));

    for (int i = 0; i < ROWS; i++)
        for (int j = 0; j < COLUMNS; j++) scanf("%lf", &A[i][j]);

    print_matrix(A, ROWS, COLUMNS);

    double **R = (double **)malloc(sizeof(double *) * ROWS);
    double **Q = (double **)malloc(sizeof(double *) * ROWS);
    if (!Q || !R)
    {
        perror("Unable to allocate memory for Q & R!");
        return -1;
    }
    for (int i = 0; i < ROWS; i++)
    {
        R[i] = (double *)malloc(sizeof(double) * COLUMNS);
        Q[i] = (double *)malloc(sizeof(double) * ROWS);
        if (!Q[i] || !R[i])
        {
            perror("Unable to allocate memory for Q & R.");
            return -1;
        }
    }

    clock_t t1 = clock();
    qr_decompose(A, Q, R, ROWS, COLUMNS);
    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;

    print_matrix(R, ROWS, COLUMNS);
    print_matrix(Q, ROWS, COLUMNS);
    printf("Time taken to compute: %.4g sec\n", dtime);

    for (int i = 0; i < ROWS; i++)
    {
        free(A[i]);
        free(R[i]);
        free(Q[i]);
    }
    free(A);
    free(R);
    free(Q);
    return 0;
}
/**
 * \file
 * \authors [Krishna Vedala](https://github.com/kvedala)
 * \brief Solve a multivariable first order [ordinary differential equation
 * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using
 * [midpoint Euler
 * method](https://en.wikipedia.org/wiki/Midpoint_method)
 *
 * \details
 * The ODE being solved is:
 * \f{eqnarray*}{
 * \dot{u} &=& v\\
 * \dot{v} &=& -\omega^2 u\\
 * \omega &=& 1\\
 * [x_0, u_0, v_0] &=& [0,1,0]\qquad\ldots\text{(initial values)}
 * \f}
 * The exact solution for the above problem is:
 * \f{eqnarray*}{
 * u(x) &=& \cos(x)\\
 * v(x) &=& -\sin(x)\\
 * \f}
 * The computation results are stored to a text file `midpoint_euler.csv` and
 * the exact soltuion results in `exact.csv` for comparison. <img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_midpoint_euler.svg"
 * alt="Implementation solution"/>
 *
 * To implement [Van der Pol
 * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the
 * ::problem function to:
 * ```cpp
 * const double mu = 2.0;
 * dy[0] = y[1];
 * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];
 * ```
 * \see ode_forward_euler.c, ode_semi_implicit_euler.c
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define order 2 /**< number of dependent variables in ::problem */

/**
 * @brief Problem statement for a system with first-order differential
 * equations. Updates the system differential variables.
 * \note This function can be updated to and ode of any order.
 *
 * @param[in] 		x 		independent variable(s)
 * @param[in,out]	y		dependent variable(s)
 * @param[in,out]	dy	    first-derivative of dependent variable(s)
 */
void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;       // some const for the problem
    dy[0] = y[1];                   // x dot
    dy[1] = -omega * omega * y[0];  // y dot
}

/**
 * @brief Exact solution of the problem. Used for solution comparison.
 *
 * @param[in] 		x 		independent variable
 * @param[in,out]	y		dependent variable
 */
void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}

/**
 * @brief Compute next step approximation using the midpoint-Euler
 * method.
 * @f[y_{n+1} = y_n + dx\, f\left(x_n+\frac{1}{2}dx,
 * y_n + \frac{1}{2}dx\,f\left(x_n,y_n\right)\right)@f]
 * @param[in] 		dx	step size
 * @param[in,out] 	x	take @f$x_n@f$ and compute @f$x_{n+1}@f$
 * @param[in,out] 	y	take @f$y_n@f$ and compute @f$y_{n+1}@f$
 * @param[in,out]	dy	compute @f$y_n+\frac{1}{2}dx\,f\left(x_n,y_n\right)@f$
 */
void midpoint_euler_step(double dx, double *x, double *y, double *dy)
{
    problem(x, y, dy);
    double tmp_x = (*x) + 0.5 * dx;
    double tmp_y[order];
    int o;
    for (o = 0; o < order; o++) tmp_y[o] = y[o] + 0.5 * dx * dy[o];

    problem(&tmp_x, tmp_y, dy);

    for (o = 0; o < order; o++) y[o] += dx * dy[o];
}

/**
 * @brief Compute approximation using the midpoint-Euler
 * method in the given limits.
 * @param[in] 		dx  	step size
 * @param[in]   	x0  	initial value of independent variable
 * @param[in] 	    x_max	final value of independent variable
 * @param[in,out] 	y	    take \f$y_n\f$ and compute \f$y_{n+1}\f$
 * @param[in] save_to_file	flag to save results to a CSV file (1) or not (0)
 * @returns time taken for computation in seconds
 */
double midpoint_euler(double dx, double x0, double x_max, double *y,
                      char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen("midpoint_euler.csv", "w+");
        if (fp == NULL)
        {
            perror("Error! ");
            return -1;
        }
    }

    /* start integration */
    clock_t t1 = clock();
    double x = x0;
    do  // iterate for each step of independent variable
    {
        if (save_to_file && fp)
            fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        midpoint_euler_step(dx, &x, y, dy);  // perform integration
        x += dx;                             // update step
    } while (x <= x_max);  // till upper limit of independent variable
    /* end of integration */
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}

/**
    Main Function
*/
int main(int argc, char *argv[])
{
    double X0 = 0.f;          /* initial value of x0 */
    double X_MAX = 10.F;      /* upper limit of integration */
    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */
    double step_size;

    if (argc == 1)
    {
        printf("\nEnter the step size: ");
        scanf("%lg", &step_size);
    }
    else
        // use commandline argument as independent variable step size
        step_size = atof(argv[1]);

    // get approximate solution
    double total_time = midpoint_euler(step_size, X0, X_MAX, Y0, 1);
    printf("\tTime = %.6g ms\n", total_time);

    /* compute exact solution for comparion */
    FILE *fp = fopen("exact.csv", "w+");
    if (fp == NULL)
    {
        perror("Error! ");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf("Finding exact solution\n");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf("\tTime = %.6g ms\n", total_time);
    fclose(fp);

    return 0;
}
#include <math.h>
#include <stdio.h>

#define ARRAY_SIZE 20

void display(float a[ARRAY_SIZE][ARRAY_SIZE], int n)
{
    int i, j;
    for (i = 0; i < n; i++)
    {
        for (j = 0; j <= n; j++)
        {
            printf("%.2f \t", a[i][j]);
        }
        printf("\n");
    }
}

float interchange(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)
{
    float tmp[ARRAY_SIZE][ARRAY_SIZE];
    float max = fabs(m[i][i]);
    int j, k = i;

    for (j = i; j < n; j++)
    {
        if (max < fabs(m[j][i]))
        {
            max = fabs(m[j][i]);
            k = j;
        }
    }
    for (j = 0; j <= n; j++)
    {
        tmp[i][j] = m[i][j];
        m[i][j] = m[k][j];
        m[k][j] = tmp[i][j];
    }
    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];
}
float eliminate(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)
{
    float tmp;
    int k = 1, l, j;
    for (j = i; j < n - 1; j++)
    {
        tmp = -((m[i + k][i]) / (m[i][i]));
        for (l = 0; l <= n; l++)
        {
            m[i + k][l] = (m[i + k][l]) + (m[i][l] * tmp);
        }
        k++;
    }
    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];
}
int main(void)
{
    int i, j, n, k = 0, l;
    float m[ARRAY_SIZE][ARRAY_SIZE], mul, tmp[ARRAY_SIZE][ARRAY_SIZE], val,
        ans[ARRAY_SIZE];

    printf("Total No.of Equations : ");
    scanf("%d", &n);

    printf("\n");
    for (i = 0; i < n; i++)
    {
        printf("Enter Co-efficient Of Equations %d & Total --->>>\n", i + 1);
        for (j = 0; j <= n; j++)
        {
            printf("r%d%d : ", i, j);
            scanf("%f", &m[i][j]);
        }
        printf("\n");
    }
    printf(":::::::::::: Current Matrix ::::::::::::\n\n");
    display(m, n);

    for (i = 0; i < n - 1; i++)
    {
        printf("\n------->>>>>>>>>>>>>>>>>>>>>>>>-------- %d\n", i + 1);
        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = interchange(m, i, n);
        display(m, n);
        printf("\n_______________________________________\n");
        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = eliminate(m, i, n);
        display(m, n);
    }
    printf("\n\n Values are : \n");
    for (i = n - 1; i >= 0; i--)
    {
        l = n - 1;
        mul = 0;
        for (j = 0; j < k; j++)
        {
            mul = mul + m[i][l] * ans[l];
            l--;
        }
        k++;
        ans[i] = (m[i][n] - mul) / m[i][i];
        printf("X%d = %.2f\n", i + 1, ans[i]);
    }

    return 0;
}
/**
 * \file
 * \brief Compute statistics for data entered in rreal-time
 * \author [Krishna Vedala](https://github.com/kvedala)
 *
 * This algorithm is really beneficial to compute statistics on data read in
 * realtime. For example, devices reading biometrics data. The algorithm is
 * simple enough to be easily implemented in an embedded system.
 */
#include <assert.h>
#include <math.h>
#include <stdio.h>

/**
 * continuous mean and variance computance using
 * first value as an approximation for the mean.
 * If the first number is much far form the mean, the algorithm becomes very
 * inaccurate to compute variance and standard deviation.
 * \param[in] x new value added to data set
 * \param[out] mean if not NULL, mean returns mean of data set
 * \param[out] variance if not NULL, mean returns variance of data set
 * \param[out] std if not NULL, mean returns standard deviation of data set
 */
void stats_computer1(float x, float *mean, float *variance, float *std)
{
    /* following variables declared static becuase they need to be remembered
     * when updating for next sample, when received.
     */
    static unsigned int n = 0;
    static float Ex = 0.f, Ex2 = 0.f;
    static float K = 0.f;

    if (n == 0)
        K = x;
    n++;
    float tmp = x - K;
    Ex += tmp;
    Ex2 += tmp * tmp;

    /* return sample mean computed till last sample */
    if (mean != NULL)
        *mean = K + Ex / n;

    /* return data variance computed till last sample */
    if (variance != NULL)
        *variance = (Ex2 - (Ex * Ex) / n) / (n - 1);

    /* return sample standard deviation computed till last sample */
    if (std != NULL)
        *std = sqrtf(*variance);
}

/**
 * continuous mean and variance computance using
 * Welford's algorithm  (very accurate)
 * \param[in] x new value added to data set
 * \param[out] mean if not NULL, mean returns mean of data set
 * \param[out] variance if not NULL, mean returns variance of data set
 * \param[out] std if not NULL, mean returns standard deviation of data set
 */
void stats_computer2(float x, float *mean, float *variance, float *std)
{
    /* following variables declared static becuase they need to be remembered
     * when updating for next sample, when received.
     */
    static unsigned int n = 0;
    static float mu = 0, M = 0;

    n++;
    float delta = x - mu;
    mu += delta / n;
    float delta2 = x - mu;
    M += delta * delta2;

    /* return sample mean computed till last sample */
    if (mean != NULL)
        *mean = mu;

    /* return data variance computed till last sample */
    if (variance != NULL)
        *variance = M / n;

    /* return sample standard deviation computed till last sample */
    if (std != NULL)
        *std = sqrtf(*variance);
}

/** Test the algorithm implementation
 * \param[in] test_data array of data to test the algorithms
 * \param[in] number_of_samples number of samples of data
 */
void test_function(const float *test_data, const int number_of_samples)
{
    float ref_mean = 0.f, ref_variance = 0.f;
    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;
    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;

    for (int i = 0; i < number_of_samples; i++)
    {
        stats_computer1(test_data[i], &s1_mean, &s1_variance, &s1_std);
        stats_computer2(test_data[i], &s2_mean, &s2_variance, &s2_std);
        ref_mean += test_data[i];
    }
    ref_mean /= number_of_samples;

    for (int i = 0; i < number_of_samples; i++)
    {
        float temp = test_data[i] - ref_mean;
        ref_variance += temp * temp;
    }
    ref_variance /= number_of_samples;

    printf("<<<<<<<< Test Function >>>>>>>>\n");
    printf("Expected: Mean: %.4f\t Variance: %.4f\n", ref_mean, ref_variance);
    printf("\tMethod 1:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n", s1_mean,
           s1_variance, s1_std);
    printf("\tMethod 2:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n", s2_mean,
           s2_variance, s2_std);

    assert(fabs(s1_mean - ref_mean) < 0.01);
    assert(fabs(s2_mean - ref_mean) < 0.01);
    assert(fabs(s2_variance - ref_variance) < 0.01);

    printf("(Tests passed)\n\n");
}

/** Main function */
int main(int argc, char **argv)
{
    const float test_data1[] = {3, 4, 5, -1.4, -3.6, 1.9, 1.};
    test_function(test_data1, sizeof(test_data1) / sizeof(test_data1[0]));

    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;
    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;

    printf("Enter data. Any non-numeric data will terminate the data input.\n");

    while (1)
    {
        float val;
        printf("Enter number: ");

        // check for failure to read input. Happens for
        // non-numeric data
        if (!scanf("%f", &val))
            break;

        stats_computer1(val, &s1_mean, &s1_variance, &s1_std);
        stats_computer2(val, &s2_mean, &s2_variance, &s2_std);

        printf("\tMethod 1:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n",
               s1_mean, s1_variance, s1_std);
        printf("\tMethod 2:\tMean: %.4f\t Variance: %.4f\t Std: %.4f\n",
               s2_mean, s2_variance, s2_std);
    }

    return 0;
}
/**
 * \file
 * \authors [Krishna Vedala](https://github.com/kvedala)
 * \brief Solve a multivariable first order [ordinary differential equation
 * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using
 * [forward Euler
 * method](https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations#Euler_method)
 *
 * \details
 * The ODE being solved is:
 * \f{eqnarray*}{
 * \dot{u} &=& v\\
 * \dot{v} &=& -\omega^2 u\\
 * \omega &=& 1\\
 * [x_0, u_0, v_0] &=& [0,1,0]\qquad\ldots\text{(initial values)}
 * \f}
 * The exact solution for the above problem is:
 * \f{eqnarray*}{
 * u(x) &=& \cos(x)\\
 * v(x) &=& -\sin(x)\\
 * \f}
 * The computation results are stored to a text file `forward_euler.csv` and the
 * exact soltuion results in `exact.csv` for comparison.
 * <img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_forward_euler.svg"
 * alt="Implementation solution"/>
 *
 * To implement [Van der Pol
 * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the
 * ::problem function to:
 * ```cpp
 * const double mu = 2.0;
 * dy[0] = y[1];
 * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];
 * ```
 * \see ode_midpoint_euler.c, ode_semi_implicit_euler.c
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define order 2 /**< number of dependent variables in ::problem */

/**
 * @brief Problem statement for a system with first-order differential
 * equations. Updates the system differential variables.
 * \note This function can be updated to and ode of any order.
 *
 * @param[in] 		x 		independent variable(s)
 * @param[in,out]	y		dependent variable(s)
 * @param[in,out]	dy	    first-derivative of dependent variable(s)
 */
void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;       // some const for the problem
    dy[0] = y[1];                   // x dot
    dy[1] = -omega * omega * y[0];  // y dot
}

/**
 * @brief Exact solution of the problem. Used for solution comparison.
 *
 * @param[in] 		x 		independent variable
 * @param[in,out]	y		dependent variable
 */
void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}

/**
 * @brief Compute next step approximation using the forward-Euler
 * method. @f[y_{n+1}=y_n + dx\cdot f\left(x_n,y_n\right)@f]
 * @param[in] 		dx	step size
 * @param[in,out] 	x	take \f$x_n\f$ and compute \f$x_{n+1}\f$
 * @param[in,out] 	y	take \f$y_n\f$ and compute \f$y_{n+1}\f$
 * @param[in,out]	dy	compute \f$f\left(x_n,y_n\right)\f$
 */
void forward_euler_step(const double dx, const double *x, double *y, double *dy)
{
    int o;
    problem(x, y, dy);
    for (o = 0; o < order; o++) y[o] += dx * dy[o];
}

/**
 * @brief Compute approximation using the forward-Euler
 * method in the given limits.
 * @param[in] 		dx  	step size
 * @param[in]   	x0  	initial value of independent variable
 * @param[in] 	    x_max	final value of independent variable
 * @param[in,out] 	y	    take \f$y_n\f$ and compute \f$y_{n+1}\f$
 * @param[in] save_to_file	flag to save results to a CSV file (1) or not (0)
 * @returns time taken for computation in seconds
 */
double forward_euler(double dx, double x0, double x_max, double *y,
                     char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen("forward_euler.csv", "w+");
        if (fp == NULL)
        {
            perror("Error! ");
            return -1;
        }
    }

    /* start integration */
    clock_t t1 = clock();
    double x = x0;
    do  // iterate for each step of independent variable
    {
        if (save_to_file && fp)
            fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        forward_euler_step(dx, &x, y, dy);  // perform integration
        x += dx;                            // update step
    } while (x <= x_max);  // till upper limit of independent variable
    /* end of integration */
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}

/**
    Main Function
*/
int main(int argc, char *argv[])
{
    double X0 = 0.f;          /* initial value of x0 */
    double X_MAX = 10.F;      /* upper limit of integration */
    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */
    double step_size;

    if (argc == 1)
    {
        printf("\nEnter the step size: ");
        scanf("%lg", &step_size);
    }
    else
        // use commandline argument as independent variable step size
        step_size = atof(argv[1]);

    // get approximate solution
    double total_time = forward_euler(step_size, X0, X_MAX, Y0, 1);
    printf("\tTime = %.6g ms\n", total_time);

    /* compute exact solution for comparion */
    FILE *fp = fopen("exact.csv", "w+");
    if (fp == NULL)
    {
        perror("Error! ");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf("Finding exact solution\n");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf("\tTime = %.6g ms\n", total_time);
    fclose(fp);

    return 0;
}
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define MAX_LEN INT_MAX

int main(int argc, char **argv)
{
    int *a, n = 10, i, j, temp, sum = 0;
    float mean;

    if (argc == 2)
    {
        n = atoi(argv[1]);
        if (n >= MAX_LEN)
        {
            fprintf(stderr, "Maximum %d!\n", MAX_LEN);
            return 1;
        }
    }
    
    a = (int *)malloc(n * sizeof(int));

    printf("Random Numbers Generated are: ");
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
        printf("%2d, ", a[i]);
    }
    putchar('\n');

    for (i = 0; i < n; i++) sum = sum + a[i];

    mean = sum / (float)n;
    printf("\nMean: ");
    printf("%f\n", mean);

    free(a);
    return 0;
}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int a[10], n, i, j, temp;
    float mean, median;

    printf("Enter no. for Random Numbers :");
    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        a[i] = rand() % 100;
    }
    printf("Random Numbers Generated are :\n");
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }
    printf("\n");
    printf("\nSorted Data:");
    for (i = 0; i < n; i++)
    {
        for (j = 0; j < n; j++)
        {
            if (a[i] < a[j])
            {
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
    for (i = 0; i < n; i++)
    {
        printf("\n%d", a[i]);
    }

    if (n % 2 == 0)
    {
        median = (a[n / 2] + a[(n / 2) - 1]) / 2;
    }
    else
    {
        median = a[n / 2];
    }
    printf("\nMedian is : %f", median);

    return 0;
}
/**
 * @file
 * \brief Find approximate solution for \f$f(x) = 0\f$ using
 * Newton-Raphson interpolation algorithm.
 *
 * \author [Krishna Vedala](https://github.com/kvedala)
 */

#include <complex.h> /* requires minimum of C99 */
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ACCURACY 1e-10 /**< solution accuracy */

/**
 * Return value of the function to find the root for.
 * \f$f(x)\f$
 */
double complex func(double complex x)
{
    return x * x - 3.; /* x^2 = 3 - solution is sqrt(3) */
    // return x * x - 2.; /* x^2 = 2 - solution is sqrt(2) */
}

/**
 * Return first order derivative of the function.
 * \f$f'(x)\f$
 */
double complex d_func(double complex x) { return 2. * x; }

/**
 * main function
 */
int main(int argc, char **argv)
{
    double delta = 1;
    double complex cdelta = 1;

    /* initialize random seed: */
    srand(time(NULL));

    /* random initial approximation */
    double complex root = (rand() % 100 - 50) + (rand() % 100 - 50) * I;

    unsigned long counter = 0;
    /* iterate till a convergence is reached */
    while (delta > ACCURACY && counter < ULONG_MAX)
    {
        cdelta = func(root) / d_func(root);
        root += -cdelta;
        counter++;
        delta = fabs(cabs(cdelta));

#if defined(DEBUG) || !defined(NDEBUG)
        if (counter % 50 == 0)
        {
            double r = creal(root);
            double c = cimag(root);

            printf("Iter %5lu: Root: %4.4g%c%4.4gi\t\tdelta: %.4g\n", counter,
                   r, c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);
        }
#endif
    }

    double r = creal(root);
    double c = fabs(cimag(root)) < ACCURACY ? 0 : cimag(root);

    printf("Iter %5lu: Root: %4.4g%c%4.4gi\t\tdelta: %.4g\n", counter, r,
           c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);

    return 0;
}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int *ARRAY = NULL, ARRAY_LENGTH, i, TEMPORARY_ELEMENT, isSorted = 0;
    float MEAN = 0, VARIANCE = 0, STAND;

    printf("Enter no. for Random Numbers :");
    scanf("%d", &ARRAY_LENGTH);
    ARRAY = (int *)realloc(
        ARRAY,
        ARRAY_LENGTH * (sizeof(int)));  // We allocate the dedicated memory
    for (i = 0; i < ARRAY_LENGTH; i++)  // We generate the random numbers
        ARRAY[i] = rand() % 100;

    printf("Random Numbers Generated are :\n");  // We display them
    for (i = 0; i < ARRAY_LENGTH; i++) printf("%d ", ARRAY[i]);

    printf("\nSorted Data: ");  // Then we sort it using Bubble Sort..

    while (!isSorted)
    {                  // While our array's not sorted
        isSorted = 1;  // we suppose that it's sorted
        for (i = 0; i < ARRAY_LENGTH - 1; i++)
        {  // then for each element of the array
            if (ARRAY[i] > ARRAY[i + 1])
            {                  // if the two elements aren't sorted
                isSorted = 0;  // it means that the array is not sorted
                TEMPORARY_ELEMENT = ARRAY[i];  // and we switch these elements
                                               // using TEMPORARY_ELEMENT
                ARRAY[i] = ARRAY[i + 1];
                ARRAY[i + 1] = TEMPORARY_ELEMENT;
            }
        }
    }
    for (i = 0; i < ARRAY_LENGTH; i++)
    {
        printf("%d ", ARRAY[i]);
        MEAN = MEAN + ARRAY[i];
    }
    MEAN = MEAN / (float)ARRAY_LENGTH;

    for (i = 0; i < ARRAY_LENGTH; i++)
        VARIANCE = VARIANCE + (pow((ARRAY[i] - MEAN), 2));

    VARIANCE = VARIANCE / (float)ARRAY_LENGTH;
    STAND = sqrt(VARIANCE);

    printf("\n\n- Mean is: %f\n", MEAN);
    printf("- Variance is: %f\n", VARIANCE);
    printf("- Standard Deviation is: %f\n", STAND);
}
/**
 * @file
 * \brief Compute real eigen values and eigen vectors of a symmetric matrix
 * using [QR decomposition](https://en.wikipedia.org/wiki/QR_decomposition)
 * method.
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "qr_decompose.h"
#ifdef _OPENMP
#include <omp.h>
#endif

#define LIMS 9        /**< limit of range of matrix values */
#define EPSILON 1e-10 /**< accuracy tolerance limit */

/**
 * create a square matrix of given size with random elements
 * \param[out] A matrix to create (must be pre-allocated in memory)
 * \param[in] N matrix size
 */
void create_matrix(double **A, int N)
{
    int i, j, tmp, lim2 = LIMS >> 1;

#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < N; i++)
    {
        A[i][i] = (rand() % LIMS) - lim2;
        for (j = i + 1; j < N; j++)
        {
            tmp = (rand() % LIMS) - lim2;
            A[i][j] = tmp;
            A[j][i] = tmp;
        }
    }
}

/**
 * Perform multiplication of two matrices.
 * * R2 must be equal to C1
 * * Resultant matrix size should be R1xC2
 * \param[in] A first matrix to multiply
 * \param[in] B second matrix to multiply
 * \param[out] OUT output matrix (must be pre-allocated)
 * \param[in] R1 number of rows of first matrix
 * \param[in] C1 number of columns of first matrix
 * \param[in] R2 number of rows of second matrix
 * \param[in] C2 number of columns of second matrix
 * \returns pointer to resultant matrix
 */
double **mat_mul(double **A, double **B, double **OUT, int R1, int C1, int R2,
                 int C2)
{
    if (C1 != R2)
    {
        perror("Matrix dimensions mismatch!");
        return OUT;
    }

    int i;
#ifdef _OPENMP
#pragma omp for
#endif
    for (i = 0; i < R1; i++)
    {
        for (int j = 0; j < C2; j++)
        {
            OUT[i][j] = 0.f;
            for (int k = 0; k < C1; k++) OUT[i][j] += A[i][k] * B[k][j];
        }
    }
    return OUT;
}

/** Compute eigen values using iterative shifted QR decomposition algorithm as
 * follows:
 * 1. Use last diagonal element of A as eigen value approximation \f$c\f$
 * 2. Shift diagonals of matrix \f$A' = A - cI\f$
 * 3. Decompose matrix \f$A'=QR\f$
 * 4. Compute next approximation \f$A'_1 = RQ \f$
 * 5. Shift diagonals back \f$A_1 = A'_1 + cI\f$
 * 6. Termination condition check: last element below diagonal is almost 0
 *   1. If not 0, go back to step 1 with the new approximation \f$A_1\f$
 *   2. If 0, continue to step 7
 * 7. Save last known \f$c\f$ as the eigen value.
 * 8. Are all eigen values found?
 *   1. If not, remove last row and column of \f$A_1\f$ and go back to step 1.
 *   2. If yes, stop.
 *
 * \note The matrix \f$A\f$ gets modified
 *
 * \param[in,out] A matrix to compute eigen values for
 * \param[out] eigen_vals resultant vector containing computed eigen values
 * \param[in] mat_size matrix size
 * \param[in] debug_print 1 to print intermediate Q & R matrices, 0 for not to
 * \returns time for computation in seconds
 */
double eigen_values(double **A, double *eigen_vals, int mat_size,
                    char debug_print)
{
    if (!eigen_vals)
    {
        perror("Output eigen value vector cannot be NULL!");
        return -1;
    }
    double **R = (double **)malloc(sizeof(double *) * mat_size);
    double **Q = (double **)malloc(sizeof(double *) * mat_size);
    if (!Q || !R)
    {
        perror("Unable to allocate memory for Q & R!");
        if (Q)
        {
            free(Q);
        }
        if (R)
        {
            free(R);
        }
        return -1;
    }

    /* allocate dynamic memory for matrices */
    for (int i = 0; i < mat_size; i++)
    {
        R[i] = (double *)malloc(sizeof(double) * mat_size);
        Q[i] = (double *)malloc(sizeof(double) * mat_size);
        if (!Q[i] || !R[i])
        {
            perror("Unable to allocate memory for Q & R.");
            for (; i >= 0; i--)
            {
                free(R[i]);
                free(Q[i]);
            }
            free(Q);
            free(R);
            return -1;
        }
    }

    if (debug_print)
    {
        print_matrix(A, mat_size, mat_size);
    }

    int rows = mat_size, columns = mat_size;
    int counter = 0, num_eigs = rows - 1;
    double last_eig = 0;

    clock_t t1 = clock();
    while (num_eigs > 0) /* continue till all eigen values are found */
    {
        /* iterate with QR decomposition */
        while (fabs(A[num_eigs][num_eigs - 1]) > EPSILON)
        {
            last_eig = A[num_eigs][num_eigs];
            for (int i = 0; i < rows; i++) A[i][i] -= last_eig; /* A - cI */
            qr_decompose(A, Q, R, rows, columns);

            if (debug_print)
            {
                print_matrix(A, rows, columns);
                print_matrix(Q, rows, columns);
                print_matrix(R, columns, columns);
                printf("-------------------- %d ---------------------\n",
                       ++counter);
            }

            mat_mul(R, Q, A, columns, columns, rows, columns);
            for (int i = 0; i < rows; i++) A[i][i] += last_eig; /* A + cI */
        }

        /* store the converged eigen value */
        eigen_vals[num_eigs] = last_eig;

        if (debug_print)
        {
            printf("========================\n");
            printf("Eigen value: % g,\n", last_eig);
            printf("========================\n");
        }

        num_eigs--;
        rows--;
        columns--;
    }
    eigen_vals[0] = A[0][0];
    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;

    if (debug_print)
    {
        print_matrix(R, mat_size, mat_size);
        print_matrix(Q, mat_size, mat_size);
    }

    /* cleanup dynamic memory */
    for (int i = 0; i < mat_size; i++)
    {
        free(R[i]);
        free(Q[i]);
    }
    free(R);
    free(Q);

    return dtime;
}

/**
 * test function to compute eigen values of a 2x2 matrix
 * \f[\begin{bmatrix}
 * 5 & 7\\
 * 7 & 11
 * \end{bmatrix}\f]
 * which are approximately, {15.56158, 0.384227}
 */
void test1()
{
    int mat_size = 2;
    double X[][2] = {{5, 7}, {7, 11}};
    double y[] = {15.56158, 0.384227};  // corresponding y-values
    double eig_vals[2] = {0, 0};

    // The following steps are to convert a "double[][]" to "double **"
    double **A = (double **)malloc(mat_size * sizeof(double *));
    for (int i = 0; i < mat_size; i++) A[i] = X[i];

    printf("------- Test 1 -------\n");

    double dtime = eigen_values(A, eig_vals, mat_size, 0);

    for (int i = 0; i < mat_size; i++)
    {
        printf("%d/5 Checking for %.3g --> ", i + 1, y[i]);
        char result = 0;
        for (int j = 0; j < mat_size && !result; j++)
        {
            if (fabs(y[i] - eig_vals[j]) < 0.1)
            {
                result = 1;
                printf("(%.3g) ", eig_vals[j]);
            }
        }

        // ensure that i^th expected eigen value was computed
        assert(result != 0);
        printf("found\n");
    }
    printf("Test 1 Passed in %.3g sec\n\n", dtime);
    free(A);
}

/**
 * test function to compute eigen values of a 2x2 matrix
 * \f[\begin{bmatrix}
 * -4& 4& 2& 0& -3\\
 * 4& -4& 4& -3& -1\\
 * 2& 4& 4& 3& -3\\
 * 0& -3& 3& -1&-1\\
 * -3& -1& -3& -3& 0
 * \end{bmatrix}\f]
 * which are approximately, {9.27648, -9.26948, 2.0181, -1.03516, -5.98994}
 */
void test2()
{
    int mat_size = 5;
    double X[][5] = {{-4, 4, 2, 0, -3},
                     {4, -4, 4, -3, -1},
                     {2, 4, 4, 3, -3},
                     {0, -3, 3, -1, -3},
                     {-3, -1, -3, -3, 0}};
    double y[] = {9.27648, -9.26948, 2.0181, -1.03516,
                  -5.98994};  // corresponding y-values
    double eig_vals[5];

    // The following steps are to convert a "double[][]" to "double **"
    double **A = (double **)malloc(mat_size * sizeof(double *));
    for (int i = 0; i < mat_size; i++) A[i] = X[i];

    printf("------- Test 2 -------\n");

    double dtime = eigen_values(A, eig_vals, mat_size, 0);

    for (int i = 0; i < mat_size; i++)
    {
        printf("%d/5 Checking for %.3g --> ", i + 1, y[i]);
        char result = 0;
        for (int j = 0; j < mat_size && !result; j++)
        {
            if (fabs(y[i] - eig_vals[j]) < 0.1)
            {
                result = 1;
                printf("(%.3g) ", eig_vals[j]);
            }
        }

        // ensure that i^th expected eigen value was computed
        assert(result != 0);
        printf("found\n");
    }
    printf("Test 2 Passed in %.3g sec\n\n", dtime);
    free(A);
}

/**
 * main function
 */
int main(int argc, char **argv)
{
    srand(time(NULL));

    int mat_size = 5;
    if (argc == 2)
    {
        mat_size = atoi(argv[1]);
    }
    else
    {  // if invalid input argument is given run tests
        test1();
        test2();
        printf("Usage: ./qr_eigen_values [mat_size]\n");
        return 0;
    }

    if (mat_size < 2)
    {
        fprintf(stderr, "Matrix size should be > 2\n");
        return -1;
    }

    int i;

    double **A = (double **)malloc(sizeof(double *) * mat_size);
    /* number of eigen values = matrix size */
    double *eigen_vals = (double *)malloc(sizeof(double) * mat_size);
    if (!eigen_vals)
    {
        perror("Unable to allocate memory for eigen values!");
        free(A);
        return -1;
    }
    for (i = 0; i < mat_size; i++)
    {
        A[i] = (double *)malloc(sizeof(double) * mat_size);
        eigen_vals[i] = 0.f;
    }

    /* create a random matrix */
    create_matrix(A, mat_size);

    print_matrix(A, mat_size, mat_size);

    double dtime = eigen_values(A, eigen_vals, mat_size, 0);
    printf("Eigen vals: ");
    for (i = 0; i < mat_size; i++) printf("% 9.4g\t", eigen_vals[i]);
    printf("\nTime taken to compute: % .4g sec\n", dtime);

    for (int i = 0; i < mat_size; i++) free(A[i]);
    free(A);
    free(eigen_vals);
    return 0;
}
#include <math.h>
#include <stdio.h>

int main()
{
    float a, b, c, a1, a2, a3, b1, b2, b3, c1, c2, c3, d1, d2, d3, x1, x2, x3;

    printf("Enter values of eq1:");
    scanf("%f%f%f%f", &a1, &a2, &a3, &d1);
    printf("Enter values of eq2:");
    scanf("%f%f%f%f", &b1, &b2, &b3, &d2);
    printf("Enter values of eq3:");
    scanf("%f%f%f%f", &c1, &c2, &c3, &d3);
    x1 = x2 = x3 = 0.0;
    do
    {
        a = x1;
        b = x2;
        c = x3;
        x1 = (1 / a1) * (d1 - (a2 * x2) - (a3 * x3));
        x2 = (1 / b2) * (d2 - (b1 * x1) - (b3 * x3));
        x3 = (1 / c3) * (d3 - (c1 * x1) - (c2 * x2));
    } while (fabs(x1 - a) > 0.0001 && fabs(x2 - b) > 0.0001 &&
             fabs(x3 - c) > 0.0001);
    printf("x1=%f\nx2=%f\nx3=%f", x1, x2, x3);

    return 0;
}#include <math.h>
#include <stdio.h>

float f(float x)
{
    return 1.0 +
           x * x * x;  // This is the expresion of the function to integrate?
}

int main()
{
    int i, n;
    float a, b, h, x, s2, s3, sum, integral;

    printf("enter the lower limit of the integration:");
    scanf("%f", &a);
    printf("enter the upper limit of the integration:");
    scanf("%f", &b);
    printf("enter the number of intervals:");
    scanf("%d", &n);

    h = (b - a) / n;
    sum = f(a) + f(b);
    s2 = s3 = 0.0;

    for (i = 1; i < n; i += 3)
    {
        x = a + i * h;
        s3 = s3 + f(x) + f(x + h);
    }

    for (i = 3; i < n; i += 3)
    {
        x = a + i * h;
        s2 = s2 + f(x);
    }

    integral = (h / 3.0) * (sum + 2 * s2 + 4 * s3);
    printf("\nValue of the integral = %9.4f\n", integral);

    return 0;
}/**
 * \file
 * \brief [LU decomposition](https://en.wikipedia.org/wiki/LU_decompositon) of a
 * square matrix
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#ifdef _OPENMP
#include <omp.h>
#endif

/** Perform LU decomposition on matrix
 * \param[in] A matrix to decompose
 * \param[out] L output L matrix
 * \param[out] U output U matrix
 * \param[in] mat_size input square matrix size
 */
int lu_decomposition(double **A, double **L, double **U, int mat_size)
{
    int row, col, j;

    // regularize each row
    for (row = 0; row < mat_size; row++)
    {
        // Upper triangular matrix
#ifdef _OPENMP
#pragma omp for
#endif
        for (col = row; col < mat_size; col++)
        {
            // Summation of L[i,j] * U[j,k]
            double lu_sum = 0.;
            for (j = 0; j < row; j++) lu_sum += L[row][j] * U[j][col];

            // Evaluate U[i,k]
            U[row][col] = A[row][col] - lu_sum;
        }

        // Lower triangular matrix
#ifdef _OPENMP
#pragma omp for
#endif
        for (col = row; col < mat_size; col++)
        {
            if (row == col)
            {
                L[row][col] = 1.;
                continue;
            }

            // Summation of L[i,j] * U[j,k]
            double lu_sum = 0.;
            for (j = 0; j < row; j++) lu_sum += L[col][j] * U[j][row];

            // Evaluate U[i,k]
            L[col][row] = (A[col][row] - lu_sum) / U[row][row];
        }
    }

    return 0;
}

/** Function to display square matrix */
void display(double **A, int N)
{
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            printf("% 3.3g \t", A[i][j]);
        }
        putchar('\n');
    }
}

/** Main function */
int main(int argc, char **argv)
{
    int mat_size = 3;  // default matrix size
    const int range = 10;
    const int range2 = range >> 1;

    if (argc == 2)
        mat_size = atoi(argv[1]);

    srand(time(NULL));  // random number initializer

    /* Create a square matrix with random values */
    double **A = (double **)malloc(mat_size * sizeof(double *));
    double **L = (double **)malloc(mat_size * sizeof(double *));  // output
    double **U = (double **)malloc(mat_size * sizeof(double *));  // output
    for (int i = 0; i < mat_size; i++)
    {
        // calloc so that all valeus are '0' by default
        A[i] = (double *)calloc(mat_size, sizeof(double));
        L[i] = (double *)calloc(mat_size, sizeof(double));
        U[i] = (double *)calloc(mat_size, sizeof(double));
        for (int j = 0; j < mat_size; j++)
            /* create random values in the limits [-range2, range-1] */
            A[i][j] = (double)(rand() % range - range2);
    }

    lu_decomposition(A, L, U, mat_size);

    printf("A = \n");
    display(A, mat_size);
    printf("\nL = \n");
    display(L, mat_size);
    printf("\nU = \n");
    display(U, mat_size);

    /* Free dynamically allocated memory */
    for (int i = 0; i < mat_size; i++)
    {
        free(A[i]);
        free(L[i]);
        free(U[i]);
    }
    free(A);
    free(L);
    free(U);

    return 0;
}/**
 * @file
 * \brief Compute all possible approximate roots of any given polynomial using
 * [Durand Kerner
 * algorithm](https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method)
 *
 * \author [Krishna Vedala](https://github.com/kvedala)
 *
 * Test the algorithm online:
 * https://gist.github.com/kvedala/27f1b0b6502af935f6917673ec43bcd7
 *
 * Try the highly unstable Wilkinson's polynomial:
 * ```
 * ./numerical_methods/durand_kerner_roots.c 1 -210 20615 -1256850 53327946
 * -1672280820 40171771630 -756111184500 11310276995381 -135585182899530
 * 1307535010540395 -10142299865511450 63030812099294896 -311333643161390640
 * 1206647803780373360 -3599979517947607200 8037811822645051776
 * -12870931245150988800 13803759753640704000 -8752948036761600000
 * 2432902008176640000
 * ```
 * Sample implementation results to compute approximate roots of the equation
 * \f$x^4-1=0\f$:\n
 * <img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/durand_kerner_error.svg"
 * width="400" alt="Error evolution during root approximations computed every
 * iteration."/> <img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/durand_kerner_roots.svg"
 * width="400" alt="Roots evolution - shows the initial approximation of the
 * roots and their convergence to a final approximation along with the iterative
 * approximations" />
 */

#include <complex.h>
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define ACCURACY 1e-10 /**< maximum accuracy limit */

/**
 * Evaluate the value of a polynomial with given coefficients
 * \param[in] coeffs coefficients of the polynomial
 * \param[in] degree degree of polynomial
 * \param[in] x point at which to evaluate the polynomial
 * \returns \f$f(x)\f$
 */
long double complex poly_function(long double *coeffs, unsigned int degree,
                                  long double complex x)
{
    long double complex out = 0.;
    unsigned int n;

    for (n = 0; n < degree; n++) out += coeffs[n] * cpow(x, degree - n - 1);

    return out;
}

/**
 * create a textual form of complex number
 * \param[in] x point at which to evaluate the polynomial
 * \returns pointer to converted string
 */
const char *complex_str(long double complex x)
{
    static char msg[50];
    double r = creal(x);
    double c = cimag(x);

    sprintf(msg, "% 7.04g%+7.04gj", r, c);

    return msg;
}

/**
 * check for termination condition
 * \param[in] delta point at which to evaluate the polynomial
 * \returns 0 if termination not reached
 * \returns 1 if termination reached
 */
char check_termination(long double delta)
{
    static long double past_delta = INFINITY;
    if (fabsl(past_delta - delta) <= ACCURACY || delta < ACCURACY)
        return 1;
    past_delta = delta;
    return 0;
}

/***
 * the comandline inputs are taken as coeffiecients of a polynomial
 */
int main(int argc, char **argv)
{
    long double *coeffs = NULL;
    long double complex *s0 = NULL;
    unsigned int degree = 0;
    unsigned int n, i;

    if (argc < 2)
    {
        printf(
            "Please pass the coefficients of the polynomial as commandline "
            "arguments.\n");
        return 0;
    }

    degree = argc - 1; /* detected polynomial degree */
    coeffs = (long double *)malloc(
        degree * sizeof(long double)); /* store all input coefficients */
    s0 = (long double complex *)malloc(
        (degree - 1) *
        sizeof(long double complex)); /* number of roots = degree-1 */

    /* initialize random seed: */
    srand(time(NULL));

    if (!coeffs || !s0)
    {
        perror("Unable to allocate memory!");
        if (coeffs)
            free(coeffs);
        if (s0)
            free(s0);
        return EXIT_FAILURE;
    }

#if defined(DEBUG) || !defined(NDEBUG)
    /**
     * store intermediate values to a CSV file
     */
    FILE *log_file = fopen("durand_kerner.log.csv", "wt");
    if (!log_file)
    {
        perror("Unable to create a storage log file!");
        free(coeffs);
        free(s0);
        return EXIT_FAILURE;
    }
    fprintf(log_file, "iter#,");
#endif

    printf("Computing the roots for:\n\t");
    for (n = 0; n < degree; n++)
    {
        coeffs[n] = strtod(argv[n + 1], NULL);
        if (n < degree - 1 && coeffs[n] != 0)
            printf("(%Lg) x^%d + ", coeffs[n], degree - n - 1);
        else if (coeffs[n] != 0)
            printf("(%Lg) x^%d = 0\n", coeffs[n], degree - n - 1);

        double tmp;
        if (n > 0)
            coeffs[n] /= tmp; /* numerical errors less when the first
                                 coefficient is "1" */
        else
        {
            tmp = coeffs[0];
            coeffs[0] = 1;
        }

        /* initialize root approximations with random values */
        if (n < degree - 1)
        {
            s0[n] = (long double)rand() + (long double)rand() * I;
#if defined(DEBUG) || !defined(NDEBUG)
            fprintf(log_file, "root_%d,", n);
#endif
        }
    }

#if defined(DEBUG) || !defined(NDEBUG)
    fprintf(log_file, "avg. correction");
    fprintf(log_file, "\n0,");
    for (n = 0; n < degree - 1; n++)
        fprintf(log_file, "%s,", complex_str(s0[n]));
#endif

    double tol_condition = 1;
    unsigned long iter = 0;

    clock_t end_time, start_time = clock();
    while (!check_termination(tol_condition) && iter < INT_MAX)
    {
        long double complex delta = 0;
        tol_condition = 0;
        iter++;

#if defined(DEBUG) || !defined(NDEBUG)
        fprintf(log_file, "\n%ld,", iter);
#endif

        for (n = 0; n < degree - 1; n++)
        {
            long double complex numerator =
                poly_function(coeffs, degree, s0[n]);
            long double complex denominator = 1.0;
            for (i = 0; i < degree - 1; i++)
                if (i != n)
                    denominator *= s0[n] - s0[i];

            delta = numerator / denominator;

            if (isnan(cabsl(delta)) || isinf(cabsl(delta)))
            {
                printf("\n\nOverflow/underrun error - got value = %Lg",
                       cabsl(delta));
                goto end;
            }

            s0[n] -= delta;

            tol_condition = fmaxl(tol_condition, fabsl(cabsl(delta)));

#if defined(DEBUG) || !defined(NDEBUG)
            fprintf(log_file, "%s,", complex_str(s0[n]));
#endif
        }
        // tol_condition /= (degree - 1);

#if defined(DEBUG) || !defined(NDEBUG)
        if (iter % 500 == 0)
        {
            printf("Iter: %lu\t", iter);
            for (n = 0; n < degree - 1; n++) printf("\t%s", complex_str(s0[n]));
            printf("\t\tabsolute average change: %.4g\n", tol_condition);
        }

        fprintf(log_file, "%.4g", tol_condition);
#endif
    }
end:

    end_time = clock();

#if defined(DEBUG) || !defined(NDEBUG)
    fclose(log_file);
#endif

    printf("\nIterations: %lu\n", iter);
    for (n = 0; n < degree - 1; n++) printf("\t%s\n", complex_str(s0[n]));
    printf("absolute average change: %.4g\n", tol_condition);
    printf("Time taken: %.4g sec\n",
           (end_time - start_time) / (double)CLOCKS_PER_SEC);

    free(coeffs);
    free(s0);

    return 0;
}
/**
 * \file
 * \authors [Krishna Vedala](https://github.com/kvedala)
 * \brief Solve a multivariable first order [ordinary differential equation
 * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using
 * [semi implicit Euler
 * method](https://en.wikipedia.org/wiki/Semi-implicit_Euler_method)
 *
 * \details
 * The ODE being solved is:
 * \f{eqnarray*}{
 * \dot{u} &=& v\\
 * \dot{v} &=& -\omega^2 u\\
 * \omega &=& 1\\
 * [x_0, u_0, v_0] &=& [0,1,0]\qquad\ldots\text{(initial values)}
 * \f}
 * The exact solution for the above problem is:
 * \f{eqnarray*}{
 * u(x) &=& \cos(x)\\
 * v(x) &=& -\sin(x)\\
 * \f}
 * The computation results are stored to a text file `semi_implicit_euler.csv`
 * and the exact soltuion results in `exact.csv` for comparison. <img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_semi_implicit_euler.svg"
 * alt="Implementation solution"/>
 *
 * To implement [Van der Pol
 * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the
 * ::problem function to:
 * ```cpp
 * const double mu = 2.0;
 * dy[0] = y[1];
 * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];
 * ```
 * <a href="https://en.wikipedia.org/wiki/Van_der_Pol_oscillator"><img
 * src="https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/van_der_pol_implicit_euler.svg"
 * alt="Van der Pol Oscillator solution"/></a>
 *
 * \see ode_forward_euler.c, ode_midpoint_euler.c
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define order 2 /**< number of dependent variables in ::problem */

/**
 * @brief Problem statement for a system with first-order differential
 * equations. Updates the system differential variables.
 * \note This function can be updated to and ode of any order.
 *
 * @param[in] 		x 		independent variable(s)
 * @param[in,out]	y		dependent variable(s)
 * @param[in,out]	dy	    first-derivative of dependent variable(s)
 */
void problem(const double *x, double *y, double *dy)
{
    const double omega = 1.F;       // some const for the problem
    dy[0] = y[1];                   // x dot
    dy[1] = -omega * omega * y[0];  // y dot
}

/**
 * @brief Exact solution of the problem. Used for solution comparison.
 *
 * @param[in] 		x 		independent variable
 * @param[in,out]	y		dependent variable
 */
void exact_solution(const double *x, double *y)
{
    y[0] = cos(x[0]);
    y[1] = -sin(x[0]);
}

/**
 * @brief Compute next step approximation using the semi-implicit-Euler
 * method.
 * @param[in] 		dx	step size
 * @param[in,out] 	x	take @f$x_n@f$ and compute @f$x_{n+1}@f$
 * @param[in,out] 	y	take @f$y_n@f$ and compute @f$y_{n+1}@f$
 * @param[in,out]	dy	compute @f$y_n+\frac{1}{2}dx\,f\left(x_n,y_n\right)@f$
 */
void semi_implicit_euler_step(double dx, double *x, double *y, double *dy)
{
    int o;

    problem(x, y, dy);   // update dy once
    y[0] += dx * dy[0];  // update y0

    problem(x, y, dy);  // update dy once more

    for (o = 1; o < order; o++)
        y[o] += dx * dy[o];  // update remaining using new dy
    *x += dx;
}

/**
 * @brief Compute approximation using the semi-implicit-Euler
 * method in the given limits.
 * @param[in] 		dx  	step size
 * @param[in]   	x0  	initial value of independent variable
 * @param[in] 	    x_max	final value of independent variable
 * @param[in,out] 	y	    take \f$y_n\f$ and compute \f$y_{n+1}\f$
 * @param[in] save_to_file	flag to save results to a CSV file (1) or not (0)
 * @returns time taken for computation in seconds
 */
double semi_implicit_euler(double dx, double x0, double x_max, double *y,
                           char save_to_file)
{
    double dy[order];

    FILE *fp = NULL;
    if (save_to_file)
    {
        fp = fopen("semi_implicit_euler.csv", "w+");
        if (fp == NULL)
        {
            perror("Error! ");
            return -1;
        }
    }

    /* start integration */
    clock_t t1 = clock();
    double x = x0;
    do  // iterate for each step of independent variable
    {
        if (save_to_file && fp)
            fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        semi_implicit_euler_step(dx, &x, y, dy);  // perform integration
        x += dx;                                  // update step
    } while (x <= x_max);  // till upper limit of independent variable
    /* end of integration */
    clock_t t2 = clock();

    if (save_to_file && fp)
        fclose(fp);

    return (double)(t2 - t1) / CLOCKS_PER_SEC;
}

/**
    Main Function
*/
int main(int argc, char *argv[])
{
    double X0 = 0.f;          /* initial value of x0 */
    double X_MAX = 10.F;      /* upper limit of integration */
    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */
    double step_size;

    if (argc == 1)
    {
        printf("\nEnter the step size: ");
        scanf("%lg", &step_size);
    }
    else
        // use commandline argument as independent variable step size
        step_size = atof(argv[1]);

    // get approximate solution
    double total_time = semi_implicit_euler(step_size, X0, X_MAX, Y0, 1);
    printf("\tTime = %.6g ms\n", total_time);

    /* compute exact solution for comparion */
    FILE *fp = fopen("exact.csv", "w+");
    if (fp == NULL)
    {
        perror("Error! ");
        return -1;
    }
    double x = X0;
    double *y = &(Y0[0]);
    printf("Finding exact solution\n");
    clock_t t1 = clock();

    do
    {
        fprintf(fp, "%.4g,%.4g,%.4g\n", x, y[0], y[1]);  // write to file
        exact_solution(&x, y);
        x += step_size;
    } while (x <= X_MAX);

    clock_t t2 = clock();
    total_time = (t2 - t1) / CLOCKS_PER_SEC;
    printf("\tTime = %.6g ms\n", total_time);
    fclose(fp);

    return 0;
}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    float x[20], y[20], a, sum, p;
    int n, i, j;

    printf("Enter the no of entry to insert->");
    scanf("%d", &n);

    for (i = 0; i < n; i++)
    {
        printf("enter the value of x%d->", i);
        scanf("%f", &x[i]);
        printf("enter the value of y%d->", i);
        scanf("%f", &y[i]);
    }
    printf("\n X \t\t Y \n");
    printf("----------------------------\n");
    for (i = 0; i < n; i++)
    {
        printf("%f\t", x[i]);
        printf("%f\n", y[i]);
    }
    printf("\nenter the value of x for interpolation:");
    scanf("%f", &a);
    sum = 0;
    for (i = 0; i < n; i++)
    {
        p = 1.0;
        for (j = 0; j < n; j++)
        {
            if (i != j)
            {
                p = p * (a - x[j]) / (x[i] - x[j]);
            }
            sum = sum + y[i] * p;
        }
        printf("ans is->%f", sum);

        return 0;
    }
}/**
 * @file
 * @brief File used to test the malloc_dbg, calloc_dbg and free_dbg functions.
 * @details
 * This file only have a main function that calls malloc, calloc and free.
 * When the program exits, memory leaks must be printed.
 * @author [tinouduart33](https://github.com/tinouduart33)
 * @see malloc_dbg.c, malloc_dbg.h
 */

#include <stdio.h> /// For IO operations if needed.
#include <stdlib.h> /// For the EXIT_SUCCESS macro and the "real" malloc, calloc and free functions.
#include "malloc_dbg.h" /// For the macros malloc, calloc and free and the malloc_dbg, calloc_dbg and free_dbg functions.


/**
 * @brief Main function
 * @param argc number of arguments (not used)
 * @param argv list of arguments (not used)
 * @returns 0 on exit
 */
int main(int argc, char* argv[])
{
	int* iptr = malloc(10 * sizeof(int));
	char* cptr = calloc(256, sizeof(char));

	free(iptr);
	// free(cptr);

	return 0;
}
/**
 * @file
 * @brief File used to test min_printf function.
 * @details
 * The test will be executed by comparing the result of both `min_printf` and `printf` functions
 * @author [Jaskarn7](https://github.com/Jaskarn7)
 * @see min_printf.h
*/

#include "min_printf.h" /// for `min_printf` function
#include <stdio.h> /// for `printf` function

/**
 * @brief Main function
 * @details
 * This function is used to test `min_printf` function.
 * The numbers and string used for the test is generated randomly (The user can also specify their own value for tests)
 * First integers were tested then floats and at last strings
 * After running the program the user will see three pair of lines with each pair followed by an empty line
 * In each pair of lines, the first line will be printed by `min_printf` function and next line by the actual `printf` function
 * In each line user will see number or string covered with two colons, they are used to check from where the printing was started and where it ends
 * @returns 0 on exit
*/
int main()
{
    // print strings using `printf` and `min_printf`
    min_printf(":%d: :%1.6d:\n", 12, 56);
    printf(":%d: :%1.6d:\n", 12, 56);

    printf("\n"); /// Printing an empty new line

    // print floats or doubles using `printf` and `min_printf`
    min_printf(":%f: :%3.6f:\n", 104.5654, 43.766443332);
    printf(":%f: :%3.6f:\n", 104.5654, 43.766443332);

    printf("\n");

    // print integers `printf` and `min_printf`
    min_printf(":%s: :%4.3s:\n", "Hello, World!", "Hello, World!");
    printf(":%s: :%4.3s:\n", "Hello, World!", "Hello, World!");

}
/**
 * @file
 * @brief This file contains malloc_dbg, calloc_dbg, free_dbg and printLeaks implementations.
 * @author [tinouduart33](https://github.com/tinouduart33)
 */

#include <stdlib.h> /// For the malloc, calloc and free functions.
#include <stdio.h> /// For IO operations (printf).
#include <string.h> /// For the memcmp function.
#include "malloc_dbg.h" /// Header file which contains the prototypes of malloc_dbg, calloc_dbg and fre_dbg.

/* We must undef these macros in order to use the real malloc / calloc and free functions */
#undef malloc
#undef calloc
#undef free

/**
 * @brief Structure used to save an allocated pointer
 */
typedef struct MEMORY_INFORMATION
{
	void* ptr; ///< Pointer returned by malloc / calloc
	const char* fileName; ///< File in which malloc or calloc has been called
	const char* functionName; ///< Function in which malloc or calloc has been called
	size_t bytes; ///< Number of bytes allocated
	int line; ///< Line number (in file) corresponding to the malloc / calloc call
	struct MEMORY_INFORMATION* next; ///< Next element in the list
	struct MEMORY_INFORMATION* previous; ///< Previous element in the list
} mem_info;

/** We use a global variable for the list so we can use it at any time.
 * */
mem_info* memoryInformation = NULL;

/** Another global variable. This one is used to know if we already call the atexit function.
 * */
int atexitCalled = 0;


/**
 * @brief addMemInfo function add a memory allocation in the memoryInfo list.
 * @details This function creates a new element and add it on top of the list
 * @param memoryInfo Pointer to the doubly linked list used to store all of the allocations
 * @param ptrToreturn Pointer returned by malloc or calloc
 * @param bytes Size in bytes of the allocation
 * @param line Line where the allocation has been called
 * @param filename File where the allocation has been called
 * @param functionName Name of the function where the allocation has been called
 * @returns mem_info pointer if it succeeds, NULL otherwise
 */
mem_info* addMemInfo(mem_info* memoryInfo, void* ptrToReturn, size_t bytes, int line, const char* filename, const char* functionName)
{
	mem_info* newMemInfo = (mem_info*)malloc(sizeof(mem_info));
	if (!newMemInfo)
	{
		return NULL;
	}

	newMemInfo->ptr = ptrToReturn;
	newMemInfo->bytes = bytes;
	newMemInfo->line = line;
	newMemInfo->fileName = filename;
	newMemInfo->functionName = functionName;
	newMemInfo->next = memoryInfo;
	newMemInfo->previous = NULL;
	if (memoryInformation)
		memoryInformation->previous = newMemInfo;

	return newMemInfo;
}

/**
 * @brief inList function is used to know if an element is already in the memoryInfo list.
 * @details This function is used to know if an allocation in a specific file at a specific line already exists in the list.
 * @param filename File in which malloc or calloc has been called
 * @param line Line number in the file in which malloc or calloc has been called
 * @returns Position of the element in the list if the element is found, -1 otherwise.
 */
int inList(const char* filename, int line)
{
	mem_info* tmp = memoryInformation;
	int counter = 0;
	int len = strlen(filename);

	while (tmp)
	{
		if (len == strlen(tmp->fileName))
		{
			if (!memcmp(filename, tmp->fileName, len) && tmp->line == line)
			{
				return counter;
			}
		}
		tmp = tmp->next;
		counter++;
	}
	return -1;
}

/**
 * @brief editInfo function is used to edit an element in the memoryInfo list.
 * @details This function is used to edit the number of bytes allocated at a specific line.
 * @param elemPos Position of an element in the doubly linked list memoryInfo
 * @param bytes Size of the allocation in bytes
 * @returns Nothing.
 */
void editInfo(int elemPos, size_t bytes)
{
	int counter = 0;
	mem_info* tmp = memoryInformation;

	while (counter != elemPos)
	{
		tmp = tmp->next;
		counter++;
	}
	tmp->bytes += bytes;
}

/**
 * @brief malloc_dbg function is a wrapper around the malloc function.
 * @details This function calls malloc and allocates the number of bytes passed in the parameters.
 * If the allocation succeeds then it add the pointer returned by malloc in the mem_info list.
 * @param bytes Size of the allocation in bytes
 * @param filename Caller file
 * @param functionName Caller function
 * @returns Pointer returned by malloc if it's valid, NULL otherwhise.
 */
void* malloc_dbg(size_t bytes, int line, const char* filename, const char* functionName)
{
	void* ptrToReturn = malloc(bytes);
	int pos = 0;
	if (!ptrToReturn)
	{
		return NULL;
	}

	// We must check atexitCalled value to know if we already called the function
	if (!atexitCalled)
	{
		atexit(printLeaks); // Used to call printLeaks when the program exit
		atexitCalled = 1;
	}

	pos = inList(filename, line);
	if (pos == -1)
	{
		// Add a new element in the mem_info list
		memoryInformation = addMemInfo(memoryInformation, ptrToReturn, bytes, line, filename, functionName);
		if (!memoryInformation)
		{
			free(ptrToReturn);
			return NULL;
		}
	}
	else
	{
		editInfo(pos, bytes);
	}
	return ptrToReturn;
}

/**
 * @brief calloc_dbg function is a wrapper around the calloc function.
 * @details This function calls calloc and allocates the number of bytes passed in the parameters.
 * If the allocation succeeds then it add the pointer returned by malloc in the mem_info list.
 * @param elementCount number of element to allocate
 * @param elementSize Size of each element
 * @param line Line number in the caller file
 * @param filename Caller file
 * @param functionName Caller function
 * @returns Pointer returned by calloc if it's valid, NULL otherwhise.
 */
void* calloc_dbg(size_t elementCount, size_t elementSize, int line, const char* filename, const char* functionName)
{
	void* ptrToReturn = calloc(elementCount, elementSize);
	if (!ptrToReturn)
	{
		return NULL;
	}

	// We must check atexitCalled value to know if we already called the function
	if (!atexitCalled)
	{
		atexit(printLeaks); // Used to call printLeaks when the program exit
		atexitCalled = 1;
	}

	// Add a new element in the mem_info list
	memoryInformation = addMemInfo(memoryInformation, ptrToReturn, elementCount * elementSize, line, filename, functionName);
	if (!memoryInformation)
	{
		free(ptrToReturn);
		return NULL;
	}

	return ptrToReturn;
}

/**
 * @brief free_dbg function is used to free the memory allocated to a pointer.
 * @details This function free the memory pointed by the pointer passed in parameter.
 * To free this pointer, we loop through the mem_info list and check if we find the pointer.
 * Once it's found, the pointer is freed and the element is deleted from the list.
 * @param ptrToFree Pointer that must be freed
 * @returns Nothing.
 */
void free_dbg(void* ptrToFree)
{
	mem_info* tmp = memoryInformation;
	mem_info* toFree = NULL;
	mem_info* previous = NULL;

	// Check if the head contains the pointer to free
	if (tmp->ptr == ptrToFree)
	{
		toFree = tmp;
		memoryInformation = tmp->next;
		free(toFree->ptr);
		free(toFree);
		if (memoryInformation)
		{
			memoryInformation->previous = NULL;
		}
		return;
	}

	// We can loop through the list without any problems, the head is not the pointer
	while (tmp)
	{
		if (tmp->ptr == ptrToFree) // If we found the pointer that must be freed
		{
			toFree = tmp;
			tmp = tmp->next;
			previous = toFree->previous;

			if (previous)
			{
				previous->next = tmp;
			}
			if (tmp)
			{
				tmp->previous = previous;
			}

			free(toFree->ptr);
			if (toFree == memoryInformation)
			{
				memoryInformation = NULL;
			}
			free(toFree);
			return;
		}
		tmp = tmp->next;
	}
}

/**
 * @brief printLeaks function is used to print all the memory leaks.
 * @details This function is called when the program exits. It loop through the mem_info list and if it's not empty,
 * it prints the memory leaks.
 * @returns Nothing.
 */
void printLeaks()
{
	mem_info* tmp = memoryInformation;
	mem_info* previous = NULL;
	size_t sum = 0;
	int nbBlocks = 0;

	if (tmp)
	{
		printf("Memory Leaks detected.\n");
	}

	while (tmp)
	{
		previous = tmp;
		printf("\n%ld bytes lost\n", tmp->bytes);
		printf("address : 0x%p in %s\t%s:%d\n", tmp->ptr, tmp->functionName, tmp->fileName, tmp->line);
		printf("\n====================================\n");
		sum += tmp->bytes;
		tmp = tmp->next;
		free(previous);
		nbBlocks++;
	}

	printf("SUMMARY :\n%ld bytes lost in %d blocks\n", sum, nbBlocks);
}
/**
 * @file
 * @author [sunzhenliang](https://github.com/HiSunzhenliang)
 * @brief A-law algorithm for encoding and decoding (16bit pcm <=> a-law).
 * This is the implementation of [G.711](https://en.wikipedia.org/wiki/G.711)
 * in C.
 **/

/**
 * Linear input code | Compressed code | Linear output code
 * ------------------+-----------------+-------------------
 * s0000000abcdx     | s000abcd        | s0000000abcd1
 * s0000001abcdx     | s001abcd        | s0000001abcd1
 * s000001abcdxx     | s010abcd        | s000001abcd10
 * s00001abcdxxx     | s011abcd        | s00001abcd100
 * s0001abcdxxxx     | s100abcd        | s0001abcd1000
 * s001abcdxxxxx     | s101abcd        | s001abcd10000
 * s01abcdxxxxxx     | s110abcd        | s01abcd100000
 * s1abcdxxxxxxx     | s111abcd        | s1abcd1000000
 *
 * Compressed code: (s | eee | abcd)
 **/
#include <assert.h>    /// for assert
#include <inttypes.h>  /// for appropriate size int types
#include <stdio.h>     /// for IO operations

/* length of test inputs */
#define LEN ((size_t)8)

/* input pcm for test */
int16_t pcm[LEN] = {1000, -1000, 1234, 3200, -1314, 0, 32767, -32768};

/* result coded alaw for test */
uint8_t r_coded[LEN] = {250, 122, 230, 156, 97, 213, 170, 42};

/* result decoded for test */
int16_t r_decoded[LEN] = {1008, -1008, 1248, 3264, -1312, 8, 32256, -32256};

/**
 * @brief 16bit pcm to 8bit alaw
 * @param out unsigned 8bit alaw array
 * @param in  signed 16bit pcm array
 * @param len length of pcm array
 * @returns void
 */
void encode(uint8_t *out, int16_t *in, size_t len)
{
    uint8_t alaw = 0;
    int16_t pcm = 0;
    int32_t sign = 0;
    int32_t abcd = 0;
    int32_t eee = 0;
    int32_t mask = 0;
    for (size_t i = 0; i < len; i++)
    {
        pcm = *in++;
        /* 0-7 kinds of quantization level from the table above */
        eee = 7;
        mask = 0x4000; /* 0x4000: '0b0100 0000 0000 0000' */

        /* Get sign bit */
        sign = (pcm & 0x8000) >> 8;

        /* Turn negative pcm to positive */
        /* The absolute value of a negative number may be larger than the size
         * of the corresponding positive number, so here needs `-pcm -1` after
         * taking the opposite number. */
        pcm = sign ? (-pcm - 1) : pcm;

        /* Get eee and abcd bit */
        /* Use mask to locate the first `1` bit and quantization level at the
         * same time */
        while ((pcm & mask) == 0 && eee > 0)
        {
            eee--;
            mask >>= 1;
        }

        /* The location of abcd bits is related with quantization level. Check
         * the table above to determine how many bits to `>>` to get abcd */
        abcd = (pcm >> (eee ? (eee + 3) : 4)) & 0x0f;

        /* Put the quantization level number at right bit location to get eee
         * bits */
        eee <<= 4;

        /* Splice results */
        alaw = (sign | eee | abcd);

        /* The standard specifies that all resulting even bits (LSB
         * is even) are inverted before the octet is transmitted. This is to
         * provide plenty of 0/1 transitions to facilitate the clock recovery
         * process in the PCM receivers. Thus, a silent A-law encoded PCM
         * channel has the 8 bit samples coded 0xD5 instead of 0x80 in the
         * octets. (Reference from wiki above) */
        *out++ = alaw ^ 0xD5;
    }
}

/**
 * @brief 8bit alaw to 16bit pcm
 * @param out signed 16bit pcm array
 * @param in  unsigned 8bit alaw array
 * @param len length of alaw array
 * @returns void
 */
void decode(int16_t *out, uint8_t *in, size_t len)
{
    uint8_t alaw = 0;
    int32_t pcm = 0;
    int32_t sign = 0;
    int32_t eee = 0;
    for (size_t i = 0; i < len; i++)
    {
        alaw = *in++;

        /* Re-toggle toggled bits */
        alaw ^= 0xD5;

        /* Get sign bit */
        sign = alaw & 0x80;

        /* Get eee bits */
        eee = (alaw & 0x70) >> 4;

        /* Get abcd bits and add 1/2 quantization step */
        pcm = (alaw & 0x0f) << 4 | 8;

        /* If quantization level > 0, there need `1` bit before abcd bits */
        pcm += eee ? 0x100 : 0x0;

        /* Left shift according quantization level */
        pcm <<= eee > 1 ? (eee - 1) : 0;

        /* Use the right sign */
        *out++ = sign ? -pcm : pcm;
    }
}

/**
 * @brief Self-test implementations
 * @param pcm signed 16bit pcm array
 * @param coded unsigned 8bit alaw array
 * @param decoded signed 16bit pcm array
 * @param len length of test array
 * @returns void
 */
static void test(int16_t *pcm, uint8_t *coded, int16_t *decoded, size_t len)
{
    /* run encode */
    encode(coded, pcm, len);

    /* check encode result */
    for (size_t i = 0; i < len; i++)
    {
        assert(coded[i] == r_coded[i]);
    }

    /* run decode */
    decode(decoded, coded, len);

    /* check decode result */
    for (size_t i = 0; i < len; i++)
    {
        assert(decoded[i] == r_decoded[i]);
    }
}

/**
 * @brief Main function
 * @param argc commandline argument count (ignored)
 * @param argv commandline array of arguments (ignored)
 * @returns 0 on exit
 */
int main(int argc, char *argv[])
{
    /* output alaw encoded by encode() */
    uint8_t coded[LEN];

    /* output pcm decoded by decode() from coded[LEN] */
    int16_t decoded[LEN];

    test(pcm, coded, decoded, LEN);  // run self-test implementations

    /* print test pcm inputs */
    printf("inputs: ");
    for (size_t i = 0; i < LEN; i++)
    {
        printf("%d ", pcm[i]);
    }
    printf("\n");

    /* print encoded alaw */
    printf("encode: ");
    for (size_t i = 0; i < LEN; i++)
    {
        printf("%u ", coded[i]);
    }
    printf("\n");

    /* print decoded pcm */
    printf("decode: ");
    for (size_t i = 0; i < LEN; i++)
    {
        printf("%d ", decoded[i]);
    }
    printf("\n");

    /* It can be seen that the encoded alaw is smaller than the input PCM, so
     * the purpose of compression is achieved. And the decoded PCM is almost the
     * same as the original input PCM, which verifies the correctness of the
     * decoding. The reason why it is not exactly the same is that there is
     * precision loss during encode / decode.  */

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int partition(int arr[], int low, int high)
{
    int pivot = arr[low];
    int i = low - 1, j = high + 1;

    while (1)
    {
        /* Find leftmost element >= pivot */
        do
        {
            i++;
        } while (arr[i] < pivot);

        /* Find rightmost element <= pivot */
        do
        {
            j--;
        } while (arr[j] > pivot);

        /* if two pointers met */
        if (i >= j)
            return j;

        swap(&arr[i], &arr[j]);
    }
}

void partitionSort(int arr[], int low, int high)
{
    if (low < high)
    {
        int value = partition(arr, low, high);
        partitionSort(arr, low, value);
        partitionSort(arr, value + 1, high);
    }
}

void printArray(int arr[], int n)
{
    int i;
    for (i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");
}

int main()
{
    int arr[20];
    int i, range = 100;
    for (i = 0; i < 20; i++)
    {
        arr[i] = rand() % range + 1;
    }
    int size = sizeof arr / sizeof arr[0];
    printf("Array: \n");
    printArray(arr, size);
    partitionSort(arr, 0, size - 1);
    printf("Sorted Array: \n");
    printArray(arr, size);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

void cocktailSort(int arr[], int size)
{
    int i, changed = TRUE, temp, start = 0, end = size - 1;

    while (changed)
    {
        changed = FALSE;
        for (i = start; i < end; i++)
        {
            if (arr[i] > arr[i + 1])
            {
                temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                changed = TRUE;
            }
        }
        end--;

        if (changed == FALSE)
        {
            break;
        }
        changed = FALSE;

        for (i = end - 1; i >= start; i--)
        {
            if (arr[i + 1] < arr[i])
            {
                temp = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = temp;
                changed = TRUE;
            }
        }
        start++;
    }
}

int main()
{
    int i, n;

    printf("Enter the size of the array: ");
    scanf("%d", &n);
    int *arr = (int *)malloc(sizeof(int) * n);

    for (i = 0; i < n; i++)
    {
        printf("Number #%d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("You entered:  ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    cocktailSort(arr, n);
    printf("\nSorted array: ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr);
    return 0;
}/**
 * @file
 * @brief [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm
 * implementation
 */
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * Display elements of array
 * @param arr array to be display
 * @param n length of array
 */
void display(const int *arr, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

/**
 * Swap two values by using pointer
 * @param first first pointer of first number
 * @param second second pointer of second number
 */
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * Bubble sort algorithm implementation
 * @param arr array to be sorted
 * @param size size of array
 */
void bubbleSort(int *arr, int size)
{
    for (int i = 0; i < size - 1; i++)
    {                         /* for each array index */
        bool swapped = false; /* flag to check if any changes had to be made */
        /* perform iterations until no more changes were made or outer loop
            executed for all array indices */
        for (int j = 0; j < size - 1 - i; j++)
        { /* for each element in the array */
            if (arr[j] > arr[j + 1])
            { /* if the order of successive elements needs update */
                swap(&arr[j], &arr[j + 1]);
                swapped = true; /* set flag */
            }
        }
        if (!swapped)
        {
            /* since no more updates we made, the array is already sorted
                this is an optimization for early termination */
            break;
        }
    }
}

/**
 * Test function
 */
void test()
{
    const int size = 10;
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from 0 to 100 */
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    bubbleSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/** Driver Code */
int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
/**
 * @file
 * @brief Implementation of [merge
 * sort](https://en.wikipedia.org/wiki/Merge_sort) algorithm
 */
#include <stdio.h>
#include <stdlib.h>

/**
 * @addtogroup sorting Sorting algorithms
 * @{
 */
/** Swap two integer variables
 * @param [in,out] a pointer to first variable
 * @param [in,out] b pointer to second variable
 */
void swap(int *a, int *b)
{
    int t;
    t = *a;
    *a = *b;
    *b = t;
}

/**
 * @brief Perform merge of segments.
 *
 * @param a array to sort
 * @param l left index for merge
 * @param r right index for merge
 * @param n total number of elements in the array
 */
void merge(int *a, int l, int r, int n)
{
    int *b = (int *)malloc(n * sizeof(int)); /* dynamic memory must be freed */
    int c = l;
    int p1, p2;
    p1 = l;
    p2 = ((l + r) / 2) + 1;
    while ((p1 < ((l + r) / 2) + 1) && (p2 < r + 1))
    {
        if (a[p1] <= a[p2])
        {
            b[c++] = a[p1];
            p1++;
        }
        else
        {
            b[c++] = a[p2];
            p2++;
        }
    }

    if (p2 == r + 1)
    {
        while ((p1 < ((l + r) / 2) + 1))
        {
            b[c++] = a[p1];
            p1++;
        }
    }
    else
    {
        while ((p2 < r + 1))
        {
            b[c++] = a[p2];
            p2++;
        }
    }

    for (c = l; c < r + 1; c++) a[c] = b[c];

    free(b);
}

/** Merge sort algorithm implementation
 * @param a array to sort
 * @param n number of elements in the array
 * @param l index to sort from
 * @param r index to sort till
 */
void merge_sort(int *a, int n, int l, int r)
{
    if (r - l == 1)
    {
        if (a[l] > a[r])
            swap(&a[l], &a[r]);
    }
    else if (l != r)
    {
        merge_sort(a, n, l, (l + r) / 2);
        merge_sort(a, n, ((l + r) / 2) + 1, r);
        merge(a, l, r, n);
    }

    /* no change if l == r */
}
/** @} */

/** Main function */
int main(void)
{
    int *a, n, i;
    scanf("%d", &n);
    a = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
    }

    merge_sort(a, n, 0, n - 1);
    for (i = 0; i < n; i++)
    {
        printf(" %d", a[i]);
    }

    free(a);

    return 0;
}
/*
 * Algorithm : Bucket Sort
 * Time-Complexity : O(n)
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#define NARRAY 8    /* array size */
#define NBUCKET 5   /* bucket size */
#define INTERVAL 10 /* bucket range */

struct Node
{
    int data;
    struct Node *next;
};

void BucketSort(int arr[]);
struct Node *InsertionSort(struct Node *list);
void print(int arr[]);
void printBuckets(struct Node *list);
int getBucketIndex(int value);

void BucketSort(int arr[])
{
    int i, j;
    struct Node **buckets;

    /* allocate memory for array of pointers to the buckets */
    buckets = (struct Node **)malloc(sizeof(struct Node *) * NBUCKET);

    /* initialize pointers to the buckets */
    for (i = 0; i < NBUCKET; ++i)
    {
        buckets[i] = NULL;
    }

    /* put items into the buckets */
    /* creates a link list in each bucket slot */
    for (i = 0; i < NARRAY; ++i)
    {
        struct Node *current;
        int pos = getBucketIndex(arr[i]);
        current = (struct Node *)malloc(sizeof(struct Node));
        current->data = arr[i];
        current->next = buckets[pos];
        buckets[pos] = current;
    }

    /* check what's in each bucket */
    for (i = 0; i < NBUCKET; i++)
    {
        printf("Bucket[\"%d\"] : ", i);
        printBuckets(buckets[i]);
        printf("\n");
    }

    /* sorting bucket using Insertion Sort */
    for (i = 0; i < NBUCKET; ++i)
    {
        buckets[i] = InsertionSort(buckets[i]);
    }

    /* check what's in each bucket */
    printf("--------------\n");
    printf("Buckets after sorted\n");
    for (i = 0; i < NBUCKET; i++)
    {
        printf("Bucket[\"%d\"] : ", i);
        printBuckets(buckets[i]);
        printf("\n");
    }

    /* put items back to original array */
    for (j = 0, i = 0; i < NBUCKET; ++i)
    {
        struct Node *node;
        node = buckets[i];
        while (node)
        {
            // precondition for avoiding out of bounds by the array
            assert(j < NARRAY);
            arr[j++] = node->data;
            node = node->next;
        }
    }

    /* free memory */
    for (i = 0; i < NBUCKET; ++i)
    {
        struct Node *node;
        node = buckets[i];
        while (node)
        {
            struct Node *tmp;
            tmp = node;
            node = node->next;
            free(tmp);
        }
    }
    free(buckets);
    return;
}

/* Insertion Sort */
struct Node *InsertionSort(struct Node *list)
{
    struct Node *k, *nodeList;
    /* need at least two items to sort */
    if (list == NULL || list->next == NULL)
    {
        return list;
    }

    nodeList = list;
    k = list->next;
    nodeList->next = NULL; /* 1st node is new list */
    while (k != NULL)
    {
        struct Node *ptr;
        /* check if insert before first */
        if (nodeList->data > k->data)
        {
            struct Node *tmp;
            tmp = k;
            k = k->next;  // important for the while
            tmp->next = nodeList;
            nodeList = tmp;
            continue;
        }

        // from begin up to end
        // finds [i] > [i+1]
        for (ptr = nodeList; ptr->next != NULL; ptr = ptr->next)
        {
            if (ptr->next->data > k->data)
                break;
        }

        // if found (above)
        if (ptr->next != NULL)
        {
            struct Node *tmp;
            tmp = k;
            k = k->next;  // important for the while
            tmp->next = ptr->next;
            ptr->next = tmp;
            continue;
        }
        else
        {
            ptr->next = k;
            k = k->next;  // important for the while
            ptr->next->next = NULL;
            continue;
        }
    }
    return nodeList;
}

int getBucketIndex(int value) { return value / INTERVAL; }

void print(int ar[])
{
    int i;
    for (i = 0; i < NARRAY; ++i)
    {
        printf("%d ", ar[i]);
    }
    printf("\n");
}

void printBuckets(struct Node *list)
{
    struct Node *cur = list;
    while (cur)
    {
        printf("%d ", cur->data);
        cur = cur->next;
    }
}

int main(void)
{
    int array[NARRAY] = {29, 25, -1, 49, 9, 37, 21, 43};

    printf("Initial array\n");
    print(array);
    printf("------------\n");

    BucketSort(array);
    printf("------------\n");
    printf("Sorted array\n");
    print(array);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ELEMENT_NR 20000
#define ARRAY_LEN(x) (sizeof(x) / sizeof((x)[0]))
const char *notation =
    "Shell Sort Big O Notation:\
						\n--> Best Case: O(n log(n)) \
						\n--> Average Case: depends on gap sequence \
						\n--> Worst Case: O(n)";

void show_data(int arr[], int len)
{
    int i;

    for (i = 0; i < len; i++) printf("%3d ", arr[i]);
    printf("\n");
}

void swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}

void shellSort(int array[], int len)
{
    int i, j, gap;

    for (gap = len / 2; gap > 0; gap = gap / 2)
        for (i = gap; i < len; i++)
            for (j = i - gap; j >= 0 && array[j] > array[j + gap]; j = j - gap)
                swap(&array[j], &array[j + gap]);
}

int main(int argc, char *argv[])
{
    int i;
    int array[ELEMENT_NR];
    int range = 500;
    int size;
    clock_t start, end;
    double time_spent;

    srand(time(NULL));
    for (i = 0; i < ELEMENT_NR; i++) array[i] = rand() % range + 1;

    size = ARRAY_LEN(array);

    show_data(array, size);
    start = clock();
    shellSort(array, size);
    end = clock();
    time_spent = (double)(end - start) / CLOCKS_PER_SEC;

    printf("Data Sorted\n");
    show_data(array, size);

    printf("%s\n", notation);
    printf("Time spent sorting: %.4g ms\n", time_spent * 1e3);

    return 0;
}
/**
 * @file
 * @brief Sorting of array list using [bead
 * sort](https://en.wikipedia.org/wiki/Bead_sort)
 */
#include <stdio.h>
#include <stdlib.h>

/**
 * @addtogroup sorting Sorting algorithms
 * @{
 */
/** Create easy access of elements from a 2D matrix stored in memory as a 1D
 * array
 */
#define BEAD(i, j) beads[i * max + j]

/**
 * Displays the array, passed to this method
 * @param [in] arr array to display
 * @param [in] n number of elements in the array
 */
void display(const int *arr, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

/** This is where the sorting of the array takes place
 * @param [in,out] a array to be sorted
 * @param [in] len Array Size
 */
void bead_sort(int *a, size_t len)
{
    int i, j, max, sum;
    unsigned char *beads;

    for (i = 1, max = a[0]; i < len; i++)
        if (a[i] > max)
            max = a[i];

    beads = calloc(1, max * len);

    /* mark the beads */
    for (i = 0; i < len; i++)
        for (j = 0; j < a[i]; j++) BEAD(i, j) = 1;

    for (j = 0; j < max; j++)
    {
        /* count how many beads are on each post */
        for (sum = i = 0; i < len; i++)
        {
            sum += BEAD(i, j);
            BEAD(i, j) = 0;
        }
        /* mark bottom sum beads */
        for (i = len - sum; i < len; i++) BEAD(i, j) = 1;
    }

    for (i = 0; i < len; i++)
    {
        for (j = 0; j < max && BEAD(i, j); j++)
            ;
        a[i] = j;
    }
    free(beads);
}
/** @} */

/** Main function */
int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  // E.g. 8 1 2 3

    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);

    bead_sort(arr, n);

    printf("Sorted array: ");
    display(arr, n);

    free(arr);
    return 0;
}
#include <stdio.h>

void max_heapify(int *a, int i, int n);
void heapsort(int *a, int n);
void build_maxheap(int *a, int n);

void max_heapify(int *a, int i, int n)
{
    int j, temp;
    temp = a[i];
    j = 2 * i;
    while (j <= n)
    {
        if (j < n && a[j + 1] > a[j])
            j = j + 1;
        if (temp > a[j])
        {
            break;
        }
        else if (temp <= a[j])
        {
            a[j / 2] = a[j];
            j = 2 * j;
        }
    }
    a[j / 2] = temp;
    return;
}

void heapsort(int *a, int n)
{
    int i, temp;
    for (i = n; i >= 2; i--)
    {
        temp = a[i];
        a[i] = a[1];
        a[1] = temp;
        max_heapify(a, 1, i - 1);
    }
}

void build_maxheap(int *a, int n)
{
    int i;
    for (i = n / 2; i >= 1; i--)
    {
        max_heapify(a, i, n);
    }
}

int main()
{
    int n, i;
    printf("Enter number of elements of array\n");
    scanf("%d", &n);
    int a[20];
    for (i = 1; i <= n; i++)
    {
        printf("Enter Element %d\n", i);
        scanf("%d", a + i);
    }

    build_maxheap(a, n);
    heapsort(a, n);
    printf("Sorted Output\n");
    for (i = 1; i <= n; i++)
    {
        printf("%d\n", a[i]);
    }

    getchar();
}
/**
 * @file
 * @brief implementation of [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm
 * @details
 * worst-case: O(n^2)
 * best-case: O(n)
 * average-complexity: O(n^2)

 * @author Unknown author
 * @author [Gabriel Fioravante](https://github.com/northernSage)
 */

#include <stdlib.h>   /// for rand() calls
#include <assert.h>   /// for assert(<expr>)
#include <stdbool.h>  /// for boolean values: true, false  

#define MAX 20

/**
 * @brief Bubble sort implementation
 * @param array_sort the array to be sorted
 * @returns void
 */
void bubble_sort(int* array_sort)
{
	bool is_sorted = false;

    /* keep iterating over entire array
     * and swaping elements out of order
     * until it is sorted */
    while (!is_sorted)
    {
		is_sorted = true;

        /* iterate over all elements */
        for (int i = 0; i < MAX - 1; i++)
        {
            /* check if adjacent elements are out of order */
            if (array_sort[i] > array_sort[i + 1])
            {
                /* swap elements */
                int change_place = array_sort[i];
                array_sort[i] = array_sort[i + 1];
                array_sort[i + 1] = change_place;
                /* elements out of order were found
                 * so we reset the flag to keep ordering
                 * until no swap operations are executed */
                is_sorted = false;
            }
        }
    }
}

/**
 * @brief Test implementations
 * @returns void
 */
static void test() {
    /* simple int array for testing */
	int array_sort[MAX] = {0};

    /* populate our test array with 
     * random integer numbers */
    for (int i = 0; i < MAX; i++)
    {
        array_sort[i] = rand() % 101;
    }

    /* sort array */
    bubble_sort(array_sort);

    /* check if array ir correctly ordered */	
    for (int i = 0; i < MAX - 1; i++)
    {
        assert(array_sort[i] <= array_sort[i+1]);
    }
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    test();  // run self-test implementations
    return 0;
}
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

bool check_sorted(int *a, int n)
{
    while (--n >= 1)
    {
        if (a[n] < a[n - 1])
            return false;
    }
    return true;
}

void shuffle(int *a, int n)
{
    int i, t, r;
    for (i = 0; i < n; i++)
    {
        t = a[i];
        r = rand() % n;
        a[i] = a[r];
        a[r] = t;
    }
}

void sort(int *a, int n)
{
    while (!check_sorted(a, n)) shuffle(a, n);
}

int main()
{
    int numbers[6];
    int i;
    printf("Enter 6 numbers unsorted \n\n");
    for (i = 0; i < 6; i++)
    {
        scanf("%d", &numbers[i]);
    }
    sort(numbers, 6);
    for (i = 0; i < 6; i++) printf("%d ", numbers[i]);
    printf("\n");
}
// Sorting of array list using pancake sort
#include <stdio.h>
#include <stdlib.h>

/* Reverses the array */
void flip(int arr[], int i)
{
    int temp, start = 0;

    while (start < i)
    {
        temp = arr[start];
        arr[start] = arr[i];
        arr[i] = temp;
        start++;
        i--;
    }
}

// Returns index of the maximum element in arr[0..n-1]
int findMax(int arr[], int n)
{
    int maxElementIdx, i;

    for (maxElementIdx = 0, i = 0; i < n; ++i)
        if (arr[i] > arr[maxElementIdx])
            maxElementIdx = i;

    return maxElementIdx;
}

// Sorts the array using flip operations
void pancakeSort(int *arr, int n)
{
    // Start from the complete array and one by one reduce current size by one
    for (int curr_size = n; curr_size > 1; --curr_size)
    {
        // Find index of the maximum element in arr[0..curr_size-1]
        int maxElementIdx = findMax(arr, curr_size);

        // Move the maximum element to end of current array if it's not already
        // at the end
        if (maxElementIdx != curr_size - 1)
        {
            // To move at the end, first move maximum number to beginning
            flip(arr, maxElementIdx);

            // Now move the maximum number to end by reversing current array
            flip(arr, curr_size - 1);
        }
    }
}

// Displays the array, passed to this method
void display(int arr[], int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

#define N 50

// Driver program to test above function
int main()
{
    int arr[N];
    for (int i = 0; i < N; i++)
        arr[i] = rand() % (N << 1); /* random numbers from 0 to 2N */

    printf("Original array: ");
    display(arr, N);

    pancakeSort(arr, N);
    printf("Sorted array: ");
    display(arr, N);

    return 0;
}/* Sorting of array list using binary insertion sort
 * Using binary search to find the proper location for
 * inserting the selected item at each iteration. */
#include <stdio.h>
#include <stdlib.h>

/*Displays the array, passed to this method*/
void display(int *arr, int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int binarySearch(int *arr, int key, int low, int high)
{
    if (low >= high)
        return (key > arr[low]) ? (low + 1) : low;
    int mid = low + (high - 1) / 2;
    if (arr[mid] == key)
        return mid + 1;
    else if (arr[mid] > key)
        return binarySearch(arr, key, low, mid - 1);
    else
        return binarySearch(arr, key, mid + 1, high);
}
/*This is where the sorting of the array takes place
 arr[] --- Array to be sorted
 size --- Array Size
 */
void insertionSort(int *arr, int size)
{
    int i, j, key, index;
    for (i = 0; i < size; i++)
    {
        j = i - 1;
        key = arr[i];
        /* Use binrary search to find exact key's index */
        index = binarySearch(arr, key, 0, j);
        /* Move all elements greater than key from [index...j]
         * to one position */
        while (j >= index)
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        /* Insert key value in right place */
        arr[j + 1] = key;
    }
}

int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  // E.g. 8

    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);

    insertionSort(arr, n);

    printf("Sorted array: ");
    display(arr, n);

    free(arr);
    return 0;
}
/* demo.c -- Implementations of multikey quicksort and ternary search trees
   Usage
    demo                  Run basic timings on /usr/dict/words
    demo <file>           Run basic timings on <file>
    demo <file> trysearch Interactive pm and nn search on <file>
    demo <file> nncost    Run near neigbhor expers on <file>
    demo <file> pmcost    Interactive partial match expers on <file>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// MULTIKEY QUICKSORT

#ifndef min
#define min(a, b) ((a) <= (b) ? (a) : (b))
#endif

#define swap(a, b)      \
    {                   \
        char *t = x[a]; \
        x[a] = x[b];    \
        x[b] = t;       \
    }
#define i2c(i) x[i][depth]

void vecswap(int i, int j, int n, char *x[])
{
    while (n-- > 0)
    {
        swap(i, j);
        i++;
        j++;
    }
}

void ssort1(char *x[], int n, int depth)
{
    int a, b, c, d, r, v;
    if (n <= 1)
        return;
    a = rand() % n;
    swap(0, a);
    v = i2c(0);
    a = b = 1;
    c = d = n - 1;
    for (;;)
    {
        while (b <= c && (r = i2c(b) - v) <= 0)
        {
            if (r == 0)
            {
                swap(a, b);
                a++;
            }
            b++;
        }
        while (b <= c && (r = i2c(c) - v) >= 0)
        {
            if (r == 0)
            {
                swap(c, d);
                d--;
            }
            c--;
        }
        if (b > c)
            break;
        swap(b, c);
        b++;
        c--;
    }
    r = min(a, b - a);
    vecswap(0, b - r, r, x);
    r = min(d - c, n - d - 1);
    vecswap(b, n - r, r, x);
    r = b - a;
    ssort1(x, r, depth);
    if (i2c(r) != 0)
        ssort1(x + r, a + n - d - 1, depth + 1);
    r = d - c;
    ssort1(x + n - r, r, depth);
}

void ssort1main(char *x[], int n) { ssort1(x, n, 0); }

// ssort2 -- Faster Version of Multikey Quicksort

void vecswap2(char **a, char **b, int n)
{
    while (n-- > 0)
    {
        char *t = *a;
        *a++ = *b;
        *b++ = t;
    }
}

#define swap2(a, b)  \
    {                \
        t = *(a);    \
        *(a) = *(b); \
        *(b) = t;    \
    }
#define ptr2char(i) (*(*(i) + depth))

char **med3func(char **a, char **b, char **c, int depth)
{
    int va, vb, vc;
    if ((va = ptr2char(a)) == (vb = ptr2char(b)))
        return a;
    if ((vc = ptr2char(c)) == va || vc == vb)
        return c;
    return va < vb ? (vb < vc ? b : (va < vc ? c : a))
                   : (vb > vc ? b : (va < vc ? a : c));
}
#define med3(a, b, c) med3func(a, b, c, depth)

void inssort(char **a, int n, int d)
{
    char **pi, **pj, *s, *t;
    for (pi = a + 1; --n > 0; pi++)
        for (pj = pi; pj > a; pj--)
        {
            // Inline strcmp: break if *(pj-1) <= *pj
            for (s = *(pj - 1) + d, t = *pj + d; *s == *t && *s != 0; s++, t++)
                ;
            if (*s <= *t)
                break;
            swap2(pj, pj - 1);
        }
}

void ssort2(char **a, int n, int depth)
{
    int d, r, partval;
    char **pa, **pb, **pc, **pd, **pl, **pm, **pn, *t;
    if (n < 10)
    {
        inssort(a, n, depth);
        return;
    }
    pl = a;
    pm = a + (n / 2);
    pn = a + (n - 1);
    if (n > 30)
    {  // On big arrays, pseudomedian of 9
        d = (n / 8);
        pl = med3(pl, pl + d, pl + 2 * d);
        pm = med3(pm - d, pm, pm + d);
        pn = med3(pn - 2 * d, pn - d, pn);
    }
    pm = med3(pl, pm, pn);
    swap2(a, pm);
    partval = ptr2char(a);
    pa = pb = a + 1;
    pc = pd = a + n - 1;
    for (;;)
    {
        while (pb <= pc && (r = ptr2char(pb) - partval) <= 0)
        {
            if (r == 0)
            {
                swap2(pa, pb);
                pa++;
            }
            pb++;
        }
        while (pb <= pc && (r = ptr2char(pc) - partval) >= 0)
        {
            if (r == 0)
            {
                swap2(pc, pd);
                pd--;
            }
            pc--;
        }
        if (pb > pc)
            break;
        swap2(pb, pc);
        pb++;
        pc--;
    }
    pn = a + n;
    r = min(pa - a, pb - pa);
    vecswap2(a, pb - r, r);
    r = min(pd - pc, pn - pd - 1);
    vecswap2(pb, pn - r, r);
    if ((r = pb - pa) > 1)
        ssort2(a, r, depth);
    if (ptr2char(a + r) != 0)
        ssort2(a + r, pa - a + pn - pd - 1, depth + 1);
    if ((r = pd - pc) > 1)
        ssort2(a + n - r, r, depth);
}

void ssort2main(char **a, int n) { ssort2(a, n, 0); }

// TERNARY SEARCH TREE ALGS

typedef struct tnode *Tptr;
typedef struct tnode
{
    char splitchar;
    Tptr lokid, eqkid, hikid;
} Tnode;
Tptr root;

// Insert 1 -- Simple Insertion Algorithm

Tptr insert1(Tptr p, char *s)
{
    if (p == 0)
    {
        p = (Tptr)malloc(sizeof(Tnode));
        p->splitchar = *s;
        p->lokid = p->eqkid = p->hikid = 0;
    }
    if (*s < p->splitchar)
        p->lokid = insert1(p->lokid, s);
    else if (*s == p->splitchar)
    {
        if (*s != 0)
            p->eqkid = insert1(p->eqkid, ++s);
    }
    else
        p->hikid = insert1(p->hikid, s);
    return p;
}

void cleanup1(Tptr p)
{
    if (p)
    {
        cleanup1(p->lokid);
        cleanup1(p->eqkid);
        cleanup1(p->hikid);
        free(p);
    }
}

// Insert 2 -- Faster version of Insert

#define BUFSIZE 1000
Tptr buffer;
int bufn, freen;
void *freearr[10000];
int storestring = 0;

void insert2(char *s)
{
    int d;
    char *instr = s;

    Tptr pp, *p;
    p = &root;
    pp = *p;
    while (pp == *p)
    {
        if ((d = *s - pp->splitchar) == 0)
        {
            if (*s++ == 0)
                return;
            p = &(pp->eqkid);
        }
        else if (d < 0)
            p = &(pp->lokid);
        else
            p = &(pp->hikid);
    }
    for (;;)
    {
        // *p = (Tptr) malloc(sizeof(Tnode));
        if (bufn-- == 0)
        {
            buffer = (Tptr)malloc(BUFSIZE * sizeof(Tnode));
            freearr[freen++] = (void *)buffer;
            bufn = BUFSIZE - 1;
        }
        *p = buffer++;
        pp = *p;
        pp->splitchar = *s;
        pp->lokid = pp->eqkid = pp->hikid = 0;
        if (*s++ == 0)
        {
            if (storestring)
                pp->eqkid = (Tptr)instr;
            return;
        }
        p = &(pp->eqkid);
    }
}
void cleanup2()
{
    int i;
    for (i = 0; i < freen; i++) free(freearr[i]);
}

// Search Algorithms

int search1(char *s)
{
    Tptr p;
    p = root;
    while (p)
    {
        if (*s < p->splitchar)
            p = p->lokid;
        else if (*s == p->splitchar)
        {
            if (*s++ == 0)
                return 1;
            p = p->eqkid;
        }
        else
            p = p->hikid;
    }
    return 0;
}

int search2(char *s)
{
    int d, sc;
    Tptr p;
    sc = *s;
    p = root;
    while (p)
    {
        if ((d = sc - p->splitchar) == 0)
        {
            if (sc == 0)
                return 1;
            sc = *++s;
            p = p->eqkid;
        }
        else if (d < 0)
            p = p->lokid;
        else
            p = p->hikid;
    }
    return 0;
}

// Advanced searching: Partial match, near words

int nodecnt;
char *srcharr[100000];
int srchtop;

void pmsearch(Tptr p, char *s)
{
    if (!p)
        return;
    nodecnt++;
    if (*s == '.' || *s < p->splitchar)
        pmsearch(p->lokid, s);
    if (*s == '.' || *s == p->splitchar)
        if (p->splitchar && *s)
            pmsearch(p->eqkid, s + 1);
    if (*s == 0 && p->splitchar == 0)
        srcharr[srchtop++] = (char *)p->eqkid;
    if (*s == '.' || *s > p->splitchar)
        pmsearch(p->hikid, s);
}

void nearsearch(Tptr p, char *s, int d)
{
    if (!p || d < 0)
        return;
    nodecnt++;
    if (d > 0 || *s < p->splitchar)
        nearsearch(p->lokid, s, d);
    if (p->splitchar == 0)
    {
        if ((int)strlen(s) <= d)
            srcharr[srchtop++] = (char *)p->eqkid;
    }
    else
        nearsearch(p->eqkid, *s ? s + 1 : s, (*s == p->splitchar) ? d : d - 1);
    if (d > 0 || *s > p->splitchar)
        nearsearch(p->hikid, s, d);
}

#define NUMBER_OF_STRING 3

int main(int argc, char *argv[])
{
    char *arr[NUMBER_OF_STRING] = {"apple", "cat", "boy"};

    ssort1main(arr, NUMBER_OF_STRING);

    for (int i = 0; i < NUMBER_OF_STRING; i++)
    {
        printf("%s ", arr[i]);
    }
}
#include <stdio.h>
void stoogesort(int[], int, int);

int main()
{
    int arr[100], i, n;

    printf("How many elements do you want to sort: ");
    scanf("%d", &n);
    for (i = 0; i < n; i++) scanf(" %d", &arr[i]);
    stoogesort(arr, 0, n - 1);
    printf("Sorted array : \n");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}

void stoogesort(int arr[], int i, int j)
{
    int temp, k;
    if (arr[i] > arr[j])
    {
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    if ((i + 1) >= j)
        return;
    k = (int)((j - i + 1) / 3);
    stoogesort(arr, i, j - k);
    stoogesort(arr, i + k, j);
    stoogesort(arr, i, j - k);
}
/**
 * \file
 * \brief [Shell sort algorithm](https://en.wikipedia.org/wiki/Shell_sort)
 * implementation.
 * \author [Krishna Vedala](https://github.com/kvedala)
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * @addtogroup sorting Sorting algorithms
 * @{
 */
/** Helper function to print array values */
void show_data(int *arr, long len)
{
    for (long i = 0; i < len; i++) printf("%3d ", arr[i]);
    printf("\n");
}

/** Function to swap values of two integers
 * @param [in,out] a reference to first variable
 * @param [in,out] b reference to second variable
 */
inline void swap(int *a, int *b)
{
    int tmp;

    tmp = *a;
    *a = *b;
    *b = tmp;
}

/**
 * Shell sort algorithm.\n
 * Optimized algorithm - takes half the time as other
 * @param [in,out] array array to sort
 * @param [in] LEN length of the array
 */
void shell_sort(int *array, long LEN)
{
    const int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};
    const int gap_len = 8;
    long i, j, g;

    for (g = 0; g < gap_len; g++)
    {  // for each gap
        int gap = gaps[g];
        for (i = gap; i < LEN; i++)
        {  // from gap position to the end
            int tmp = array[i];

            for (j = i; j >= gap && (array[j - gap] - tmp) > 0; j -= gap)
                array[j] = array[j - gap];
            array[j] = tmp;
        }
    }
#ifdef DEBUG
    for (i = 0; i < LEN; i++) printf("%s\t", data[i]);
#endif
}
/** @} */

/** Main function */
int main(int argc, char *argv[])
{
    int i;
    long size = 500;
    if (argc == 2)
        size = atol(argv[1]);
    else if (argc > 2)
        fprintf(stderr, "Usage: ./shell_sort [number of values]\n");

    int *array = (int *)malloc(size * sizeof(int));
    int range = 500;  // range of array values
    double time_spent;

    srand(time(NULL));  // initialize random number generator
    for (i = 0; i < size; i++)
        // fill array with random integers
        array[i] = rand() % range + 1;

    show_data(array, size);   // show array before sorting
    clock_t t1 = clock();     // start timer
    shell_sort(array, size);  // sort the array
    clock_t t2 = clock();     // end timer

    printf("Data Sorted\n");
    show_data(array, size);  // display array after sorting

    printf("Time spent sorting: %.4g s\n", (t2 - t1) / CLOCKS_PER_SEC);

    free(array);
    return 0;
}
/**
 * @file
 * @author [Dhruv Pasricha](https://github.com/DhruvPasricha)
 * @brief [Heap Sort](https://en.wikipedia.org/wiki/Heapsort) implementation
 * @details
 * Heap-sort is a comparison-based sorting algorithm.
 * Heap-sort can be thought of as an improved selection sort:
 * like selection sort, heap sort divides its input into a sorted
 * and an unsorted region, and it iteratively shrinks the unsorted
 * region by extracting the largest element from it and inserting
 * it into the sorted region.
 *
 * Unlike selection sort,
 * heap sort does not waste time with a linear-time scan of the
 * unsorted region; rather, heap sort maintains the unsorted region
 * in a heap data structure to more quickly find the largest element
 * in each step.
 * Time Complexity : O(Nlog(N))
 */

#include <assert.h>   /// for assert
#include <stdio.h>    /// for IO operations
#include <stdlib.h>   /// for dynamic memory allocation
#include <time.h>     /// for random numbers generation
#include <inttypes.h> /// for uint8_t, int8_t

/**
 * @brief Swapped two numbers using pointer
 * @param first pointer of first number
 * @param second pointer of second number
 */
void swap(int8_t *first, int8_t *second)
{
    int8_t temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * @brief heapifyDown Adjusts new root to the correct position in the heap
 * This heapify procedure can be thought of as building a heap from
 * the top down by successively shifting downward to establish the
 * heap property.
 * @param arr array to be sorted
 * @param size size of array
 * @return void
*/
void heapifyDown(int8_t *arr, const uint8_t size)
{
    uint8_t i = 0;

    while (2 * i + 1 < size)
    {
        uint8_t maxChild = 2 * i + 1;

        if (2 * i + 2 < size && arr[2 * i + 2] > arr[maxChild])
        {
            maxChild = 2 * i + 2;
        }

        if (arr[maxChild] > arr[i])
        {
            swap(&arr[i], &arr[maxChild]);
            i = maxChild;
        }
        else
        {
            break;
        }
    }
}

/**
 * @brief heapifyUp Adjusts arr[i] to the correct position in the heap
 * This heapify procedure can be thought of as building a heap from
 * the bottom up by successively shifting upward to establish the
 * heap property.
 * @param arr array to be sorted
 * @param i index of the pushed element
 * @return void
*/
void heapifyUp(int8_t *arr, uint8_t i)
{
    while (i > 0 && arr[(i - 1) / 2] < arr[i])
    {
        swap(&arr[(i - 1) / 2], &arr[i]);
        i = (i - 1) / 2;
    }
}

/**
 * @brief Heap Sort algorithm
 * @param arr array to be sorted
 * @param size size of the array
 * @returns void
 */
void heapSort(int8_t *arr, const uint8_t size)
{
    if (size <= 1)
    {
        return;
    }

    for (uint8_t i = 0; i < size; i++)
    {
        // Pushing `arr[i]` to the heap

        /*heapifyUp Adjusts arr[i] to the correct position in the heap*/
        heapifyUp(arr, i);
    }

    for (uint8_t i = size - 1; i >= 1; i--)
    {
        // Moving current root to the end
        swap(&arr[0], &arr[i]);

        // `heapifyDown` adjusts new root to the correct position in the heap
        heapifyDown(arr, i);

    }
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
    const uint8_t size = 10;
    int8_t *arr = (int8_t *)calloc(size, sizeof(int8_t));

    /* generate size random numbers from 0 to 100 */
    for (uint8_t i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    heapSort(arr, size);
    for (uint8_t i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    // Intializes random number generator
    srand(time(NULL));

    test(); // run self-test implementations
    return 0;
}
/**
 * @file
 * @author [Dhruv Pasricha](https://github.com/DhruvPasricha)
 * @brief [Selection Sort](https://en.wikipedia.org/wiki/Selection_sort)
 * implementation using recursion.
 */

#include <assert.h>     /// for assert
#include <stdio.h>      /// for IO operations
#include <stdlib.h>     /// for dynamic memory allocation
#include <time.h>       /// for random numbers generation
#include <inttypes.h>   /// for uint8_t, int8_t

/**
 * @brief Swapped two numbers using pointer
 * @param first pointer of first number
 * @param second pointer of second number
 */
void swap(int8_t *first, int8_t *second)
{
    int8_t temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * @brief Returns the index having minimum value using recursion
 * @param arr array to be sorted
 * @param size size of array
 * @return min_index index of an element having a minimum value
*/
uint8_t findIndex(const int8_t *arr, const uint8_t size)
{
    if (size == 1)
    {
        return 0;
    }

    // marking recursive call to reach starting element
    uint8_t min_index = findIndex(arr, size - 1);

    if (arr[size - 1] < arr[min_index])
    {
        min_index = size - 1;
    }

    return min_index;
}

/**
 * @brief Selection Sort algorithm implemented using recursion
 * @param arr array to be sorted
 * @param size size of the array
 * @returns void
 */
void selectionSort(int8_t *arr, const uint8_t size)
{
    if (size <= 1)
    {
        return;
    }

    /* findIndex(arr, size) returned the index having min value*/
    uint8_t min_index = findIndex(arr, size);
    /* arr[min_index] is the minimum value in the array*/

    if (min_index != 0)
    {
        swap(&arr[0], &arr[min_index]);
    }

    /*sorted the remaining array recursively*/
    selectionSort(arr + 1, size - 1);
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test()
{
    const uint8_t size = 10;
    int8_t *arr = (int8_t *)calloc(size, sizeof(int8_t));

    /* generate size random numbers from 0 to 100 */
    for (uint8_t i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    selectionSort(arr, size);
    for (uint8_t i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    /* Intializes random number generator */
    srand(time(NULL));

    test();  // run self-test implementations
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

/*Displays the array, passed to this method*/
void display(int arr[], int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

/*Swap function to swap two values*/
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

/*Partition method which selects a pivot
  and places each element which is less than the pivot value to its left
  and the elements greater than the pivot value to its right
  arr[] --- array to be partitioned
  lower --- lower index
  upper --- upper index
*/
int partition(int arr[], int lower, int upper)
{
    int i = (lower - 1);

    int pivot = arr[upper];  // Selects last element as the pivot value

    int j;
    for (j = lower; j < upper; j++)
    {
        if (arr[j] <= pivot)
        {  // if current element is smaller than the pivot

            i++;  // increment the index of smaller element
            swap(&arr[i], &arr[j]);
        }
    }

    swap(&arr[i + 1], &arr[upper]);  // places the last element i.e, the pivot
                                     // to its correct position

    return (i + 1);
}

/*This is where the sorting of the array takes place
    arr[] --- Array to be sorted
    lower --- Starting index
    upper --- Ending index
*/
void quickSort(int arr[], int lower, int upper)
{
    if (upper > lower)
    {
        // partitioning index is returned by the partition method , partition
        // element is at its correct poition

        int partitionIndex = partition(arr, lower, upper);

        // Sorting elements before and after the partition index
        quickSort(arr, lower, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, upper);
    }
}

int main()
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  // E.g. 8

    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(sizeof(int) * n);
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);  // Original array : 10 11 9 8 4 7 3 8

    quickSort(arr, 0, n - 1);

    printf("Sorted array: ");
    display(arr, n);  // Sorted array : 3 4 7 8 8 9 10 11
    getchar();
    free(arr);
    return 0;
}
/* Program to demonstrate non recursive merge sort */

/* Merge sort is an effective sorting algorithm which falls under divide and
conquer paradigm and produces a stable sort. Merge sort repeatedly breaks down a
list into several sublists until each sublist consists of a single element and
merging those sublists in a manner that results into a sorted list.

Bottom-Up Merge Sort Implementation:
The Bottom-Up merge sort approach uses iterative methodology. It starts with the
“single-element” array, and combines two adjacent elements and also sorting the
two at the same time. The combined-sorted arrays are again combined and sorted
with each other until one single unit of sorted array is achieved. */

#include <stdio.h>

void mergesort(int x[], int n);
void show(int x[], int n);

void mergesort(int x[], int n)
{
    int temp[50], i, j, k, lb1, lb2, ub1, ub2, size;

    size = 1;
    while (size < n)
    {
        lb1 = 0;
        k = 0;

        while (lb1 + size < n)
        {
            lb2 = lb1 + size;
            ub1 = lb2 - 1;
            if (ub1 + size < n)
                ub2 = ub1 + size;
            else
                ub2 = n - 1;

            i = lb1;
            j = lb2;

            while (i <= ub1 && j <= ub2)
                if (x[i] < x[j])
                    temp[k++] = x[i++];
                else
                    temp[k++] = x[j++];

            while (i <= ub1) temp[k++] = x[i++];

            while (j <= ub2) temp[k++] = x[j++];

            lb1 = ub2 + 1;
        }

        for (i = 0; i <= ub2; i++) x[i] = temp[i];

        size = size * 2;

        show(x, n);
    }
}

// function to show each pass
void show(int x[], int n)
{
    int i;
    for (i = 0; i < n; i++) printf("%d ", x[i]);
    printf("\n\n");
}

int main()  // main function
{
    int i, n, x[20];

    printf("Enter the number of elements: ");
    scanf("%d", &n);
    printf("Enter the elements:\n");
    for (i = 0; i < n; i++) scanf("%d", &x[i]);

    mergesort(x, n);

    printf("Sorted array is as shown:\n");
    for (i = 0; i < n; i++) printf("%d ", x[i]);
    return 0;
}

/* Output of the Program*/
/*
Enter the number of elements: 5
Enter the elements:
15
14
13
12
11
14 15 12 13 11

12 13 14 15 11

11 12 13 14 15

Sorted array is as shown:
11 12 13 14 15
*/
/**
 * @file
 * @brief [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort)
 * algorithm implementation.
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * @addtogroup sorting Sorting algorithms
 * @{
 */
/**
 * Insertion sort algorithm implements using Recursion 
 * @param arr array to be sorted
 * @param size size of array
 */
void RecursionInsertionSort(int *arr, int size)
{
    if(size <= 0)
    {
        return;
    }
    
    // marking recursive call to reach starting element
    RecursionInsertionSort(arr,size-1);
    
    int key = arr[size-1];
    int j = size-2;
    // swapping logic for insertion sort
    while(j >= 0 && arr[j] > key)
    {
        arr[j+1] = arr[j];
        j--;
    }
    arr[j+1] = key;
}
/** @} */
/** Test function
  * @returns None
  */
static void test()
{
    const int size = rand() % 500; /* random array size */
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from -50 to 49 */  
    for (int i = 0; i < size; i++)
    {
        arr[i] = (rand() % 100) - 50;/* signed random numbers */
    }
    RecursionInsertionSort(arr, size);
    for (int i = 0; i < size  ; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/** Main function
 *  @returns integer 0
 */
int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void sort(int *numbers, int size)
{
    int pos = 0;
    while (pos < size)
    {
        if (numbers[pos] >= numbers[pos - 1])
            pos++;
        else
        {
            int tmp = numbers[pos - 1];
            numbers[pos - 1] = numbers[pos];
            numbers[pos] = tmp;
            pos--;

            if (pos == 0)
                pos = 1;
        }
    }
}

void display(int *array, int n)
{
    int i;
    for (i = 0; i < n; ++i) printf("%d ", array[i]);
    printf("\n");
}

int main()
{
    int size = 6;
    int i;
    int *numbers = malloc(size * sizeof(int));
    printf("Insert %d unsorted numbers: \n", size);
    for (i = 0; i < size; ++i) scanf("%d", &numbers[i]);
    printf("Initial array: ");
    display(numbers, size);
    sort(numbers, size);
    printf("Sorted array: ");
    display(numbers, size);
    free(numbers);
    return 0;
}
/**
 * @file
 * @author [Edwin Ajong](https://github.com/eddybruv)
 * @brief [Odd Even Sort](https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort) implementation
 * @details
 * This algorithm is divided into two phases- Odd and Even Phase.
 * The algorithm runs until the array elements are sorted and in each iteration two phases occurs- Odd and Even Phases.
 * In the odd phase, we perform a bubble sort on odd indexed elements and in the even phase,
 * we perform a bubble sort on even indexed elements.
 * Time Complexity: O(N ^ 2)
 */

#include <assert.h>     /// for assert
#include <stdbool.h>    /// for bool
#include <stdio.h>      /// for IO operations
#include <stdlib.h>     /// for dynammic memory allocation
#include <time.h>       /// for random number generation
#include <inttypes.h>   /// for int32_t types

/**
 * @brief Swap numbers by reference(using pointers)
 * @param first pointer to first number
 * @param second pointer to second number
 * @returns void
 */
void swap(int32_t *first, int32_t *second)
{
    int32_t temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * @brief oddEvenSort sorts the array using the algorithm described above.
 * @details 
 * A boolean varaible(isSorted) is declared and initialised to "false".
 * In the while loop, the variable(isSorted) is then set to "true".
 * During even phase the for loop loops through the array, touching just the even indexes.
 * i.e arr[0], arr[2], arr[4] and so on.
 * While during the odd phase, the for loop loops through the array, touching just the odd indexes.
 * i.e arr[1], arr[3], arr[5] and so on.
 * During these phases, if the if statement check if the interger at the current position in the array
 * is greater than the interger at the next array index (i.e arr[index + 2], to make sure the index is odd
 * during the odd phase and even during the even phase).
 * If the condition is true, the function "swap" is called and address of the intergers in question are passed as
 * parameters. After the swap is completed, "isSorted" is set to "false".
 * The while loop will keep running till the array is propertly sorted.
 * @param arr array to be sorted
 * @param size the size of the array
 * @returns void
 */
void oddEvenSort(int *arr, int size)
{
    bool isSorted = false;
    while(!isSorted)
    {
        isSorted = true;
        int32_t i;

        // Even phase
        for(i = 0; i <= size - 2; i += 2)
        {
            if(arr[i] > arr[i + 1])
            {
                swap(&arr[i], &arr[i + 1]);
                isSorted = false;
            }
        }

        // Odd phase
        for(i = 1; i <= size - 2; i += 2)
        {
            if(arr[i] > arr[i + 1])
            {
                swap(&arr[i], &arr[i + 1]);
                isSorted = false;
            }
        }
    }
}

/**
 * @brief Self-test implementations
 * @details Two tests (unsorted) arrays were created and their corresponding solution(sorted) arrays were also created.
 * The test arrays and their respective sizes are then passed in to the oddEvenSort function.
 * To test if the algorithm works, a for loop is assigned to loop through the both arrays(test and solution) and check if the array elements 
 * of the test array correspond to the elements of the solution array.
 * @returns void
 */
static void test()
{
    int32_t arr1[] = {-9, 2, 3, 1};
    int32_t arr1Soln[] = {-9, 1, 2, 3};
    int32_t arr2[] = {9, 7, 5, 3, 8, 2, 1, 4, 0, 6};
    int32_t arr2Soln[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    oddEvenSort(arr1, 4);
    oddEvenSort(arr2, 10);

     for (int32_t i = 0; i < 4; i++)
     {
         assert(arr1[i] == arr1Soln[i]);    
     }

    for (int32_t i = 0; i < 10; i++)
    {
        assert(arr2[i] == arr2Soln[i]);    
    }
    printf("All tests have passed!\n");
}

/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    test();  // run self-test implementations
    return 0;
}
#include <stdio.h>

int largest(int a[], int n)
{
    int large = a[0], i;
    for (i = 1; i < n; i++)
    {
        if (large < a[i])
            large = a[i];
    }
    return large;
}

void RadixSort(int a[], int n)
{
    int bucket[10][10], bucket_count[10];
    int i, j, k, remainder, NOP = 0, divisor = 1, large, pass;

    large = largest(a, n);
    printf("The large element %d\n", large);
    while (large > 0)
    {
        NOP++;
        large /= 10;
    }

    for (pass = 0; pass < NOP; pass++)
    {
        for (i = 0; i < 10; i++)
        {
            bucket_count[i] = 0;
        }
        for (i = 0; i < n; i++)
        {
            remainder = (a[i] / divisor) % 10;
            bucket[remainder][bucket_count[remainder]] = a[i];
            bucket_count[remainder] += 1;
        }

        i = 0;
        for (k = 0; k < 10; k++)
        {
            for (j = 0; j < bucket_count[k]; j++)
            {
                a[i] = bucket[k][j];
                i++;
            }
        }
        divisor *= 10;

        for (i = 0; i < n; i++) printf("%d  ", a[i]);
        printf("\n");
    }
}

int main()
{
    int i, n, a[10];
    printf("Enter the number of elements :: ");
    scanf("%d", &n);
    printf("Enter the elements :: ");
    for (i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
    }
    RadixSort(a, n);
    printf("The sorted elements are ::  ");
    for (i = 0; i < n; i++) printf("%d  ", a[i]);
    printf("\n");
    return 0;
}
/*
  > Counting sort is a sorting technique based on keys between a specific range.
  > integer sorting algorithm
  > Worst-case performance O(n+k)
  > Stabilized by prefix sum array
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    int i, n, l = 0;

    printf("Enter size of array = ");
    scanf("%d", &n);

    int *a = (int *)malloc(n * sizeof(int));
    printf("Enter %d elements in array :\n", n);
    for (i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
        if (a[i] > l)
            l = a[i];
    }

    int *b = (int *)malloc((l + 1) * sizeof(int));
    memset(b, 0, (l + 1) * sizeof(b[0]));

    for (i = 0; i < n; i++) b[a[i]]++;  // hashing number to array index

    for (i = 0; i < (l + 1); i++)  // unstable , stabilized by prefix sum array
    {
        if (b[i] > 0)
        {
            while (b[i] != 0)  // for case when number exists more than once
            {
                printf("%d ", i);
                b[i]--;
            }
        }
    }

    free(a);
    free(b);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#define SHRINK 1.3  // suggested shrink factor value

void sort(int *numbers, int size)
{
    int gap = size;
    while (gap > 1)  // gap = 1 means that the array is sorted
    {
        gap = gap / SHRINK;
        int i = 0;
        while ((i + gap) < size)
        {  // similiar to the Shell Sort
            if (numbers[i] > numbers[i + gap])
            {
                int tmp = numbers[i];
                numbers[i] = numbers[i + gap];
                numbers[i + gap] = tmp;
            }
            i++;
        }
    }
}

void display(int *array, int n)
{
    int i;
    for (i = 0; i < n; ++i) printf("%d ", array[i]);
    printf("\n");
}

int main()
{
    int size = 6;
    int *numbers = malloc(size * sizeof(int));
    printf("Insert %d unsorted numbers: \n", size);
    int i;
    for (i = 0; i < size; ++i) scanf("%d", &numbers[i]);
    printf("Initial array: ");
    display(numbers, size);
    sort(numbers, size);
    printf("Sorted array: ");
    display(numbers, size);
    free(numbers);
    return 0;
}
// sorting of array list using Radix sort
#include <stdio.h>
#include <stdlib.h>

#define range 10  // Range for integers is 10 as digits range from 0-9

// Utility function to get the maximum value in ar[]
int MAX(int *ar, int size)
{
    int i, max = ar[0];
    for (i = 0; i < size; i++)
    {
        if (ar[i] > max)
            max = ar[i];
    }
    return max;
}

// Counting sort according to the digit represented by place
void countSort(int *arr, int n, int place)
{
    int i, freq[range] = {0};
    int *output = (int *)malloc(n * sizeof(int));

    // Store count of occurences in freq[]
    for (i = 0; i < n; i++) freq[(arr[i] / place) % range]++;

    // Change freq[i] so that it contains the actual position of the digit in
    // output[]
    for (i = 1; i < range; i++) freq[i] += freq[i - 1];

    // Build the output array
    for (i = n - 1; i >= 0; i--)
    {
        output[freq[(arr[i] / place) % range] - 1] = arr[i];
        freq[(arr[i] / place) % range]--;
    }

    // Copy the output array to arr[], so it contains numbers according to the
    // current digit
    for (i = 0; i < n; i++) arr[i] = output[i];
    free(output);
}

/*This is where the sorting of the array takes place
 arr[] --- Array to be sorted
 n --- Array Size
 max --- Maximum element in Array
 */
void radixsort2(int *arr, int n,
                int max)  // max is the maximum element in the array
{
    int mul = 1;
    while (max)
    {
        countSort(arr, n, mul);
        mul *= 10;
        max /= 10;
    }
}

void display(int *arr, int N)
{
    for (int i = 0; i < N; i++) printf("%d, ", arr[i]);
    putchar('\n');
}

int main(int argc, const char *argv[])
{
    int n;
    printf("Enter size of array:\n");
    scanf("%d", &n);  // E.g. 8

    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);  // Original array : 10 11 9 8 4 7 3 8

    int max;
    max = MAX(arr, n);

    radixsort2(arr, n, max);

    printf("Sorted array: ");
    display(arr, n);  // Sorted array : 3 4 7 8 8 9 10 11

    free(arr);
    return 0;
}
// Sorting of array list using cycle sort
#include <stdio.h>
#include <stdlib.h>

// Displays the array, passed to this method
void display(int *arr, int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }

    printf("\n");
}

// Swap function to swap two values
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

// Function sort the array using Cycle sort
void cycleSort(int *arr, int n)
{
    // count number of memory writes
    int writes = 0;

    // traverse array elements and put it to on
    // the right place
    for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++)
    {
        // initialize item as starting point
        int item = arr[cycle_start];

        // Find position where we put the item. We basically
        // count all smaller elements on right side of item.
        int pos = cycle_start;
        for (int i = cycle_start + 1; i < n; i++)
            if (arr[i] < item)
                pos++;

        // If item is already in correct position
        if (pos == cycle_start)
            continue;

        // ignore all duplicate elements
        while (item == arr[pos]) pos += 1;

        // put the item to it's right position
        if (pos != cycle_start)
        {
            swap(&item, &arr[pos]);
            writes++;
        }

        // Rotate rest of the cycle
        while (pos != cycle_start)
        {
            pos = cycle_start;

            // Find position where we put the element
            for (int i = cycle_start + 1; i < n; i++)
                if (arr[i] < item)
                    pos += 1;

            // ignore all duplicate elements
            while (item == arr[pos]) pos += 1;

            // put the item to it's right position
            if (item != arr[pos])
            {
                swap(&item, &arr[pos]);
                writes++;
            }
        }
    }
}

// Driver program to test above function
int main()
{
    int n;  // Size of array elements

    printf("Enter size of array:\n");
    scanf("%d", &n);  // E.g. 8

    printf("Enter the elements of the array\n");
    int i;
    int *arr = (int *)malloc(n * sizeof(int));
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
    }

    printf("Original array: ");
    display(arr, n);

    cycleSort(arr, n);
    printf("Sorted array: ");
    display(arr, n);

    free(arr);
    return 0;
}
/*
Randomised quick sort implementation in C language.
In normal quick sort, pivot chosen to partition is either the first or the last
element of the array. This can take time O(n*n) to sort in the worst case. Now
in randomised quick sort, pivot is randomly chosen and then recursively sort the
left and right sub-arrays. The expected running time of the algorithm is
O(nlog(n)).
*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int getBig(int *a, int i, int right, int pivot)
{
    for (int k = i; k <= right; k++)
    {
        if (a[k] > pivot)
            return k;
    }
    return right + 1;
}

int getSmall(int *a, int j, int left, int pivot)
{
    for (int k = j; k >= left; k--)
    {
        if (a[k] < pivot)
            return k;
    }
    return -1;
}

void swap(int *a, int *b)
{
    int t = *a;
    *a = *b;
    *b = t;
}

void random_quick(int *a, int left, int right)
{
    if (left >= right)
        return;
    int index = left + (rand() % (right - left)), i = left, j = right;
    int pivot_index = index;
    int pivot = a[index];
    // storing index of element greater than pivot
    i = getBig(a, i, right, pivot);
    // storing index of element smaller than pivot
    j = getSmall(a, j, left, pivot);
    while (i <= j)
    {
        swap(&a[i], &a[j]);
        i = getBig(a, i, right, pivot);
        j = getSmall(a, j, left, pivot);
    }
    // after separating the smaller and greater elements, there are 3 cases
    // possible
    if (pivot_index > j && pivot_index > i)
    {
        // case 1. When the pivot element index is greater than both i and j
        swap(&a[i], &a[pivot_index]);
        random_quick(a, left, i - 1);
        random_quick(a, i + 1, right);
    }
    else if (pivot_index < j && pivot_index < i)
    {
        // case 2. When the pivot element index is smaller than both i and j
        swap(&a[j], &a[pivot_index]);
        random_quick(a, left, j - 1);
        random_quick(a, j + 1, right);
    }
    else
    {
        // the pivot element is at its origin position.
        random_quick(a, left, pivot_index - 1);
        random_quick(a, pivot_index + 1, right);
    }
}

int main()
{
    srand(time(0));
    int num;
    scanf("%d", &num);
    int *arr = (int *)malloc(num * sizeof(int));
    for (int i = 0; i < num; i++)
    {
        scanf("%d", &arr[i]);
    }
    random_quick(arr, 0, num - 1);
    for (int i = 0; i < num; i++)
    {
        printf("%d ", arr[i]);
    }

    free(arr);
    printf("\n");
}
/**
 * @file
 * @brief [Selection sort](https://en.wikipedia.org/wiki/Selection_sort)
 * algorithm implementation.
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * Swapped two numbers using pointer
 * @param first first pointer of first number
 * @param second second pointer of second number
 */
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * Selection sort algorithm implements
 * @param arr array to be sorted
 * @param size size of array
 */
void selectionSort(int *arr, int size)
{
    for (int i = 0; i < size - 1; i++)
    {
        int min_index = i;
        for (int j = i + 1; j < size; j++)
        {
            if (arr[min_index] > arr[j])
            {
                min_index = j;
            }
        }
        if (min_index != i)
        {
            swap(arr + i, arr + min_index);
        }
    }
}

/** Test function
  * @returns None
  */
static void test()
{
    const int size = rand() % 500; /* random array size */
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from -50 to 49 */
    for (int i = 0; i < size; i++)
    {
        arr[i] = (rand() % 100) - 50; /* signed random numbers */
    }
    selectionSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/** Driver Code */
int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
/**
 * @file
 * @brief [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort)
 * algorithm implementation.
 */
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * Insertion sort algorithm implements
 * @param arr array to be sorted
 * @param size size of array
 */
void insertionSort(int *arr, int size)
{
    for (int i = 1; i < size; i++)
    {
        int j = i - 1;
        int key = arr[i];
        /* Move all elements greater than key to one position */
        while (j >= 0 && key < arr[j])
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        /* Find a correct position for key */
        arr[j + 1] = key;
    }
}

/** Test function
  * @returns None
  */
static void test()
{
    const int size = rand() % 500; /* random array size */
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from -50 to 49 */  
    for (int i = 0; i < size; i++)
    {
        arr[i] = (rand() % 100) - 50; /* signed random numbers */
    }
    insertionSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}
int main(int argc, const char *argv[])
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
/**
 * @file
 * @brief [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm
 * implementation using recursion.
 */
#include <assert.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/**
 * Swapped two numbers using pointer
 * @param first first pointer of first number
 * @param second second pointer of second number
 */
void swap(int *first, int *second)
{
    int temp = *first;
    *first = *second;
    *second = temp;
}

/**
 * Bubble sort algorithm implements using recursion
 * @param arr array to be sorted
 * @param size size of array
 */
void bubbleSort(int *arr, int size)
{
    if (size == 1)
    {
        return;
    }
    bool swapped = false;
    for (int i = 0; i < size - 1; ++i)
    {
        if (arr[i] > arr[i + 1])
        {
            swap(arr + i, arr + i + 1);
            swapped = true;
        }
    }
    if (swapped)
    {
        bubbleSort(arr, size - 1);
    }
}

/**
 * Test function
 */
void test()
{
    const int size = 10;
    int *arr = (int *)calloc(size, sizeof(int));

    /* generate size random numbers from 0 to 100 */
    for (int i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
    bubbleSort(arr, size);
    for (int i = 0; i < size - 1; ++i)
    {
        assert(arr[i] <= arr[i + 1]);
    }
    free(arr);
}

/** Driver Code */
int main()
{
    /* Intializes random number generator */
    srand(time(NULL));
    test();
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
void shakersort(int *a, int n)
{
    int p, i;
    for (p = 1; p <= n / 2; p++)
    {
        for (i = p - 1; i < n - p; i++)
            if (a[i] > a[i + 1])
            {
                swap(&a[i], &a[i + 1]);
            }
        for (i = n - p - 1; i >= p; i--)
            if (a[i] < a[i - 1])
            {
                swap(&a[i], &a[i - 1]);
            }
    }
}
int main()
{
    int n;
    scanf("%d", &n);
    int *arr = (int *)malloc(n * sizeof(int));
    int i;
    for (i = 0; i < n; i++) scanf("%d ", &arr[i]);
    shakersort(arr, n);
    for (i = 0; i < n; i++) printf("%d ", arr[i]);
    free(arr);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

void pigeonholeSort(int arr[], int size)
{
    int i, j, min = arr[0], max = arr[0], range;

    // Getting range of the array using max and min
    for (i = 1; i < size; i++)
    {
        if (arr[i] < min)
            min = arr[i];
        if (arr[i] > max)
            max = arr[i];
    }
    range = max - min + 1;

    // Make 'holes' and put array's numbers in holes
    int *holes = (int *)malloc(sizeof(int) * range);
    for (i = 0; i < range; i++)
    {
        holes[i] = 0;
    }
    for (i = 0; i < size; i++)
    {
        holes[arr[i] - min]++;
    }

    // Copy the numbers back to the original array
    j = 0;
    for (i = 0; i < range; i++)
    {
        while (holes[i] > 0)
        {
            arr[j] = i + min;
            holes[i]--;
            j++;
        }
    }

    free(holes);
}

int main()
{
    int i, n;

    printf("Enter the size of the array: ");
    scanf("%d", &n);
    int *arr = (int *)malloc(sizeof(int) * n);

    for (i = 0; i < n; i++)
    {
        printf("Number #%d: ", i + 1);
        scanf("%d", &arr[i]);
    }

    printf("You entered:  ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    pigeonholeSort(arr, n);
    printf("\nSorted array: ");
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");

    free(arr);
    return 0;
}/**
 * @file
 * @brief Functions related to 3D vector operations.
 * @author Krishna Vedala
 */

#include <stdio.h>
#ifdef __arm__  // if compiling for ARM-Cortex processors
#define LIBQUAT_ARM
#include <arm_math.h>
#else
#include <math.h>
#endif
#include <assert.h>

#include "geometry_datatypes.h"

/**
 * @addtogroup vec_3d 3D Vector operations
 * @{
 */

/**
 * Subtract one vector from another. @f[
 * \vec{c}=\vec{a}-\vec{b}=\left(a_x-b_x\right)\hat{i}+
 * \left(a_y-b_y\right)\hat{j}+\left(a_z-b_z\right)\hat{k}@f]
 * @param[in] a vector to subtract from
 * @param[in] b vector to subtract
 * @returns resultant vector
 */
vec_3d vector_sub(const vec_3d *a, const vec_3d *b)
{
    vec_3d out;
#ifdef LIBQUAT_ARM
    arm_sub_f32((float *)a, (float *)b, (float *)&out);
#else
    out.x = a->x - b->x;
    out.y = a->y - b->y;
    out.z = a->z - b->z;
#endif

    return out;
}

/**
 * Add one vector to another. @f[
 * \vec{c}=\vec{a}+\vec{b}=\left(a_x+b_x\right)\hat{i}+
 * \left(a_y+b_y\right)\hat{j}+\left(a_z+b_z\right)\hat{k}@f]
 * @param[in] a vector to add to
 * @param[in] b vector to add
 * @returns resultant vector
 */
vec_3d vector_add(const vec_3d *a, const vec_3d *b)
{
    vec_3d out;
#ifdef LIBQUAT_ARM
    arm_add_f32((float *)a, (float *)b, (float *)&out);
#else
    out.x = a->x + b->x;
    out.y = a->y + b->y;
    out.z = a->z + b->z;
#endif

    return out;
}

/**
 * Obtain the dot product of two 3D vectors.
 * @f[
 * \vec{a}\cdot\vec{b}=a_xb_x + a_yb_y + a_zb_z
 * @f]
 * @param[in] a first vector
 * @param[in] b second vector
 * @returns resulting dot product
 */
float dot_prod(const vec_3d *a, const vec_3d *b)
{
    float dot;
#ifdef LIBQUAT_ARM
    arm_dot_prod_f32((float *)a, (float *)b, &dot);
#else
    dot = a->x * b->x;
    dot += a->y * b->y;
    dot += a->z * b->z;
#endif

    return dot;
}

/**
 * Compute the vector product of two 3d vectors.
 * @f[\begin{align*}
 * \vec{a}\times\vec{b} &= \begin{vmatrix}
 *  \hat{i} & \hat{j} & \hat{k}\\
 *  a_x & a_y & a_z\\
 *  b_x & b_y & b_z
 *  \end{vmatrix}\\
 *  &= \left(a_yb_z-b_ya_z\right)\hat{i} - \left(a_xb_z-b_xa_z\right)\hat{j}
 * + \left(a_xb_y-b_xa_y\right)\hat{k} \end{align*}
 * @f]
 * @param[in] a first vector @f$\vec{a}@f$
 * @param[in] b second vector @f$\vec{b}@f$
 * @returns resultant vector @f$\vec{o}=\vec{a}\times\vec{b}@f$
 */
vec_3d vector_prod(const vec_3d *a, const vec_3d *b)
{
    vec_3d out;  // better this way to avoid copying results to input
                 // vectors themselves
    out.x = a->y * b->z - a->z * b->y;
    out.y = -a->x * b->z + a->z * b->x;
    out.z = a->x * b->y - a->y * b->x;

    return out;
}

/**
 * Print formatted vector on stdout.
 * @param[in] a vector to print
 * @param[in] name  name of the vector
 * @returns string representation of vector
 */
const char *print_vector(const vec_3d *a, const char *name)
{
    static char vec_str[100];  // static to ensure the string life extends the
                               // life of function

    snprintf(vec_str, 99, "vec(%s) = (%.3g)i + (%.3g)j + (%.3g)k\n", name, a->x,
             a->y, a->z);
    return vec_str;
}

/**
 * Compute the norm a vector.
 * @f[\lVert\vec{a}\rVert = \sqrt{\vec{a}\cdot\vec{a}} @f]
 * @param[in] a input vector
 * @returns norm of the given vector
 */
float vector_norm(const vec_3d *a)
{
    float n = dot_prod(a, a);
#ifdef LIBQUAT_ARM
    arm_sqrt_f32(*n, n);
#else
    n = sqrtf(n);
#endif

    return n;
}

/**
 * Obtain unit vector in the same direction as given vector.
 * @f[\hat{a}=\frac{\vec{a}}{\lVert\vec{a}\rVert}@f]
 * @param[in] a input vector
 * @returns n unit vector in the direction of @f$\vec{a}@f$
 */
vec_3d unit_vec(const vec_3d *a)
{
    vec_3d n = {0};

    float norm = vector_norm(a);
    if (fabsf(norm) < EPSILON)
    {  // detect possible divide by 0
        return n;
    }

    if (norm != 1.F)  // perform division only if needed
    {
        n.x = a->x / norm;
        n.y = a->y / norm;
        n.z = a->z / norm;
    }
    return n;
}

/**
 * The cross product of vectors can be represented as a matrix
 * multiplication operation. This function obtains the `3x3` matrix
 * of the cross-product operator from the first vector.
 * @f[\begin{align*}
 * \left(\vec{a}\times\right)\vec{b} &= \tilde{A}_a\vec{b}\\
 * \tilde{A}_a &=
 * \begin{bmatrix}0&-a_z&a_y\\a_z&0&-a_x\\-a_y&a_x&0\end{bmatrix}
 * \end{align*}@f]
 * @param[in] a input vector
 * @returns the `3x3` matrix for the cross product operator
 * @f$\left(\vec{a}\times\right)@f$
 */
mat_3x3 get_cross_matrix(const vec_3d *a)
{
    mat_3x3 A = {0., -a->z, a->y, a->z, 0., -a->x, -a->y, a->x, 0.};
    return A;
}

/**
 * Obtain the angle between two given vectors.
 * @f[\alpha=acos\left(\frac{\vec{a} \cdot \vec{b}}{\lVert\vec{a}\rVert \cdot \lVert\vec{b}\rVert}\right)@f]
 * @param[in] a first input vector
 * @param[in] b second input vector
 * @returns angle between @f$\vec{a}@f$ and @f$\vec{b}@f$ in radians
 */

double get_angle(const vec_3d *a, const vec_3d *b)
{
    double alpha, cos_alpha;
    float norm_a = vector_norm(a); ///< The norm of vector a
    float norm_b = vector_norm(b); ///< The norm of vector b
    if (fabsf(norm_a) < EPSILON || fabsf(norm_b) < EPSILON) /// detect possible division by 0 - the angle is not defined in this case
    {  
        return NAN; 
    }

    cos_alpha = dot_prod(a, b) / (norm_a * norm_b);
    alpha = acos(cos_alpha); // delivers the radian
    return alpha; // in range from -1 to 1
}

/** @} */

/**
 * @brief Testing function
 * @returns `void`
 */
static void test()
{
    vec_3d a = {1., 2., 3.};
    vec_3d b = {1., 1., 1.};
    float d;

    // printf("%s", print_vector(&a, "a"));
    // printf("%s", print_vector(&b, "b"));

    d = vector_norm(&a);
    // printf("|a| = %.4g\n", d);
    assert(fabsf(d - 3.742f) < 0.01);
    d = vector_norm(&b);
    // printf("|b| = %.4g\n", d);
    assert(fabsf(d - 1.732f) < 0.01);

    d = dot_prod(&a, &b);
    // printf("Dot product: %f\n", d);
    assert(fabsf(d - 6.f) < 0.01);

    vec_3d c = vector_prod(&a, &b);
    // printf("Vector product ");
    // printf("%s", print_vector(&c, "c"));
    assert(fabsf(c.x - (-1.f)) < 0.01);
    assert(fabsf(c.y - (2.f)) < 0.01);
    assert(fabsf(c.z - (-1.f)) < 0.01);

    double alpha = get_angle(&a, &b);
    // printf("The angle is %f\n", alpha);
    assert(fabsf(alpha - 0.387597) < 0.01);
}

/**
 * @brief Main function
 *
 * @return 0 on exit
 */
int main(void)
{
    test();

    return 0;
}
/**
 * @file
 * @brief Functions related to 3D quaternions and Euler angles.
 * @author Krishna Vedala
 */

#include <stdio.h>
#ifdef __arm__  // if compiling for ARM-Cortex processors
#define LIBQUAT_ARM
#include <arm_math.h>
#else
#include <math.h>
#endif
#include <assert.h>

#include "geometry_datatypes.h"

/**
 * @addtogroup quats 3D Quaternion operations
 * @{
 */

/**
 * Function to convert given Euler angles to a quaternion.
 * \f{eqnarray*}{
 * q_{0} & =
 * &\cos\left(\frac{\phi}{2}\right)\cos\left(\frac{\theta}{2}\right)\cos\left(\frac{\psi}{2}\right)
 * +
 * \sin\left(\frac{\phi}{2}\right)\sin\left(\frac{\theta}{2}\right)\sin\left(\frac{\psi}{2}\right)\\
 * q_{1} & =
 * &\sin\left(\frac{\phi}{2}\right)\cos\left(\frac{\theta}{2}\right)\cos\left(\frac{\psi}{2}\right)
 * -
 * \cos\left(\frac{\phi}{2}\right)\sin\left(\frac{\theta}{2}\right)\sin\left(\frac{\psi}{2}\right)\\
 * q_{2} & =
 * &\cos\left(\frac{\phi}{2}\right)\sin\left(\frac{\theta}{2}\right)\cos\left(\frac{\psi}{2}\right)
 * +
 * \sin\left(\frac{\phi}{2}\right)\cos\left(\frac{\theta}{2}\right)\sin\left(\frac{\psi}{2}\right)\\
 * q_{3} & =
 * &\cos\left(\frac{\phi}{2}\right)\cos\left(\frac{\theta}{2}\right)\sin\left(\frac{\psi}{2}\right)
 * -
 * \sin\left(\frac{\phi}{2}\right)\sin\left(\frac{\theta}{2}\right)\cos\left(\frac{\psi}{2}\right)\\
 * \f}
 *
 * @param [in] in_euler input Euler angles instance
 * @returns converted quaternion
 */
quaternion quat_from_euler(const euler *in_euler)
{
    quaternion out_quat;

    if (!in_euler)  // if null
    {
        fprintf(stderr, "%s: Invalid input.", __func__);
        return out_quat;
    }

    quaternion temp;

    float cy = cosf(in_euler->yaw * 0.5f);
    float sy = sinf(in_euler->yaw * 0.5f);
    float cp = cosf(in_euler->pitch * 0.5f);
    float sp = sinf(in_euler->pitch * 0.5f);
    float cr = cosf(in_euler->roll * 0.5f);
    float sr = sinf(in_euler->roll * 0.5f);

    temp.w = cr * cp * cy + sr * sp * sy;
    temp.q1 = sr * cp * cy - cr * sp * sy;
    temp.q2 = cr * sp * cy + sr * cp * sy;
    temp.q3 = cr * cp * sy - sr * sp * cy;

    return temp;
}

/**
 * Function to convert given quaternion to Euler angles.
 * \f{eqnarray*}{
 * \phi & = &
 * \tan^{-1}\left[\frac{2\left(q_0q_1+q_2q_3\right)}{1-2\left(q_1^2+q_2^2\right)}\right]\\
 * \theta & =
 * &-\sin^{-1}\left[2\left(q_0q_2-q_3q_1\right)\right]\\
 * \psi & = &
 * \tan^{-1}\left[\frac{2\left(q_0q_3+q_1q_2\right)}{1-2\left(q_2^2+q_3^2\right)}\right]\\
 * \f}
 *
 * @param [in] in_quat input quaternion instance
 * @returns converted euler angles
 */
euler euler_from_quat(const quaternion *in_quat)
{
    euler out_euler;
    if (!in_quat)  // if null
    {
        fprintf(stderr, "%s: Invalid input.", __func__);
        return out_euler;
    }

    out_euler.roll = atan2f(
        2.f * (in_quat->w * in_quat->q1 + in_quat->q2 * in_quat->q3),
        1.f - 2.f * (in_quat->q1 * in_quat->q1 + in_quat->q2 * in_quat->q2));
    out_euler.pitch =
        asinf(2.f * (in_quat->w * in_quat->q2 + in_quat->q1 * in_quat->q3));
    out_euler.yaw = atan2f(
        2.f * (in_quat->w * in_quat->q3 + in_quat->q1 * in_quat->q2),
        1.f - 2.f * (in_quat->q2 * in_quat->q2 + in_quat->q3 * in_quat->q3));

    return out_euler;
}

/**
 * Function to multiply two quaternions.
 * \f{eqnarray*}{
 * \mathbf{c} & = & \mathbf{a}\otimes\mathbf{b}\\
 * & = & \begin{bmatrix}a_{0} & a_{1} & a_{2} &
 *  a_{3}\end{bmatrix}\otimes\begin{bmatrix}b_{0} & b_{1} & b_{2} &
 *  b_{3}\end{bmatrix}\\
 * & = &
 * \begin{bmatrix}
 *  a_{0}b_{0}-a_{1}b_{1}-a_{2}b_{2}-a_{3}b_{3}\\
 *  a_{0}b_{1}+a_{1}b_{0}+a_{2}b_{3}-a_{3}b_{2}\\
 *  a_{0}b_{2}-a_{1}b_{3}+a_{2}b_{0}+a_{3}b_{1}\\
 *  a_{0}b_{3}+a_{1}b_{2}-a_{2}b_{1}+a_{3}b_{0}
 * \end{bmatrix}^{T}
 * \f}
 *
 * @param [in] in_quat1 first input quaternion instance
 * @param [in] in_quat2 second input quaternion instance
 * @returns resultant quaternion
 */
quaternion quaternion_multiply(const quaternion *in_quat1,
                               const quaternion *in_quat2)
{
    quaternion out_quat;
    if (!in_quat1 || !in_quat2)  // if null
    {
        fprintf(stderr, "%s: Invalid input.", __func__);
        return out_quat;
    }

    out_quat.w = in_quat1->w * in_quat2->w - in_quat1->q1 * in_quat2->q1 -
                 in_quat1->q2 * in_quat2->q2 - in_quat1->q3 * in_quat2->q3;
    out_quat.q1 = in_quat1->w * in_quat2->q1 + in_quat1->q1 * in_quat2->w +
                  in_quat1->q2 * in_quat2->q3 - in_quat1->q3 * in_quat2->q2;
    out_quat.q2 = in_quat1->w * in_quat2->q2 - in_quat1->q1 * in_quat2->q3 +
                  in_quat1->q2 * in_quat2->w + in_quat1->q3 * in_quat2->q1;
    out_quat.q3 = in_quat1->w * in_quat2->q3 + in_quat1->q1 * in_quat2->q2 -
                  in_quat1->q2 * in_quat2->q1 + in_quat1->q3 * in_quat2->w;

    return out_quat;
}

/** @} */

static void test()
{
    quaternion quat = {0.7071f, 0.7071f, 0.f, 0.f};
    euler eul = euler_from_quat(&quat);
    printf("Euler: %.4g, %.4g, %.4g\n", eul.pitch, eul.roll, eul.yaw);

    quaternion test_quat = quat_from_euler(&eul);
    printf("Quaternion: %.4g %+.4g %+.4g %+.4g\n", test_quat.w,
           test_quat.dual.x, test_quat.dual.y, test_quat.dual.z);

    assert(fabsf(test_quat.w - quat.w) < .01);
    assert(fabsf(test_quat.q1 - quat.q1) < .01);
    assert(fabsf(test_quat.q2 - quat.q2) < .01);
    assert(fabsf(test_quat.q3 - quat.q3) < .01);
}

int main()
{
    test();
    return 0;
}
/**
 * @file
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief Implementation of
 * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)
 *
 * @details
 * Implementation of the program is based on the geometry shown in the figure
 * below:
 *
 * <a
 * href="https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg"><img
 * src="https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg"
 * alt="Spirograph geometry from Wikipedia" style="width: 250px"/></a>
 */
#define _USE_MATH_DEFINES /**< required for MSVC compiler */
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/** Generate spirograph curve into arrays `x` and `y` such that the i^th point
 * in 2D is represented by `(x[i],y[i])`. The generating function is given by:
 * \f{eqnarray*}{
 * x &=& R\left[ (1-k) \cos (t) + l\cdot k\cdot\cos \left(\frac{1-k}{k}t\right)
 * \right]\\
 * y &=& R\left[ (1-k) \sin (t) - l\cdot k\cdot\sin \left(\frac{1-k}{k}t\right)
 * \right] \f}
 * where
 * * \f$R\f$ is the scaling parameter that we will consider \f$=1\f$
 * * \f$l=\frac{\rho}{r}\f$ is the relative distance of marker from the centre
 * of inner circle and \f$0\le l\le1\f$
 * * \f$\rho\f$ is physical distance of marker from centre of inner circle
 * * \f$r\f$ is the radius of inner circle
 * * \f$k=\frac{r}{R}\f$ is the ratio of radius of inner circle to outer circle
 * and \f$0<k<1\f$
 * * \f$R\f$ is the radius of outer circle
 * * \f$t\f$ is the angle of rotation of the point i.e., represents the time
 * parameter
 *
 * Since we are considering ratios, the actual values of \f$r\f$ and
 * \f$R\f$ are immaterial.
 *
 * @param [out] x output array containing absicca of points (must be
 * pre-allocated)
 * @param [out] y output array containing ordinates of points (must be
 * pre-allocated)
 * @param l the relative distance of marker from the centre of
 * inner circle and \f$0\le l\le1\f$
 * @param k the ratio of radius of inner circle to outer circle and
 * \f$0<k<1\f$
 * @param N number of sample points along the trajectory (higher = better
 * resolution but consumes more time and memory)
 * @param num_rot the number of rotations to perform (can be fractional value)
 */
void spirograph(double *x, double *y, double l, double k, size_t N, double rot)
{
    double dt = rot * 2.f * M_PI / N;
    double t = 0.f, R = 1.f;
    const double k1 = 1.f - k;

    for (size_t dk = 0; dk < N; dk++, t += dt)
    {
        x[dk] = R * (k1 * cos(t) + l * k * cos(k1 * t / k));
        y[dk] = R * (k1 * sin(t) - l * k * sin(k1 * t / k));
    }
}

/**
 * @brief Test function to save resulting points to a CSV file.
 *
 */
void test(void)
{
    size_t N = 500;
    double l = 0.3, k = 0.75, rot = 10.;
    char fname[50];
    snprintf(fname, 50, "spirograph_%.2f_%.2f_%.2f.csv", l, k, rot);
    FILE *fp = fopen(fname, "wt");
    if (!fp)
    {
        perror(fname);
        exit(EXIT_FAILURE);
    }

    double *x = (double *)malloc(N * sizeof(double));
    double *y = (double *)malloc(N * sizeof(double));

    spirograph(x, y, l, k, N, rot);

    for (size_t i = 0; i < N; i++)
    {
        fprintf(fp, "%.5g, %.5g", x[i], y[i]);
        if (i < N - 1)
        {
            fputc('\n', fp);
        }
    }

    fclose(fp);

    free(x);
    free(y);
}

#ifdef USE_GLUT  // this is set by CMAKE automatically, if available
#ifdef __APPLE__
#include <GLUT/glut.h>  // include path on Macs is different
#else
#include <GL/glut.h>
#endif

static bool paused = 0; /**< flag to set pause/unpause animation */
static const int animation_speed = 25; /**< animation delate in ms */

static const double step = 0.01;   /**< animation step size */
static double l_ratio = 0.1;       /**< the l-ratio defined in docs */
static double k_ratio = 0.1;       /**< the k-ratio defined in docs */
static const double num_rot = 20.; /**< number of rotations to simulate */

/** A wrapper that is not available in all GLUT implementations.
 */
static inline void glutBitmapString(void *font, char *string)
{
    for (char *ch = string; *ch != '\0'; ch++) glutBitmapCharacter(font, *ch);
}

/**
 * @brief Function to graph (x,y) points on the OpenGL graphics window.
 *
 * @param x array containing absicca of points (must be pre-allocated)
 * @param y array containing ordinates of points (must be pre-allocated)
 * @param N number of points in the the arrays
 */
void display_graph(const double *x, const double *y, size_t N, double l,
                   double k)
{
    glClearColor(1.0f, 1.0f, 1.0f,
                 0.0f);            // Set background color to white and opaque
    glClear(GL_COLOR_BUFFER_BIT);  // Clear the color buffer (background)

    if (x && y)
    {
        glBegin(GL_LINES);         // draw line segments
        glColor3f(0.f, 0.f, 1.f);  // blue
        glPointSize(2.f);          // point size in pixels

        for (size_t i = 1; i < N; i++)
        {
            glVertex2f(x[i - 1], y[i - 1]);  // line from
            glVertex2f(x[i], y[i]);          // line to
        }
        glEnd();
    }
    glColor3f(0.f, 0.f, 0.f);
    char buffer[20];
    snprintf(buffer, 20, "l = %.3f", l);
    glRasterPos2f(-.85, .85);
    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);
    snprintf(buffer, 20, "k = %.3f", k);
    glRasterPos2f(-.85, .75);
    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);

    glutSwapBuffers();
}

/**
 * @brief Test function with animation
 *
 */
void test2(void)
{
    const size_t N = 1000;  // number of samples

    static bool direction1 = true;  // increment if true, otherwise decrement
    static bool direction2 = true;  // increment if true, otherwise decrement

    double *x = (double *)malloc(N * sizeof(double));
    double *y = (double *)malloc(N * sizeof(double));

    spirograph(x, y, l_ratio, k_ratio, N, num_rot);
    display_graph(x, y, N, l_ratio, k_ratio);

    free(x);  // free dynamic memories
    free(y);

    if (paused)
        // if paused, do not update l_ratio and k_ratio
        return;

    if (direction1)  // increment k_ratio
    {
        if (k_ratio >= (1.f - step))  // maximum limit
            direction1 = false;       // reverse direction of k_ratio
        else
            k_ratio += step;
    }
    else  // decrement k_ratio
    {
        if (k_ratio <= step)  // minimum limit
        {
            direction1 = true;  // reverse direction of k_ratio

            if (direction2)  // increment l_ratio
            {
                if (l_ratio >= (1.f - step))  // max limit of l_ratio
                    direction2 = false;       // reverse direction of l_ratio
                else
                    l_ratio += step;
            }
            else  // decrement l_ratio
            {
                if (l_ratio <= step)    // minimum limit of l_ratio
                    direction2 = true;  // reverse direction of l_ratio
                else
                    l_ratio -= step;
            }
        }
        else  // no min limit of k_ratio
            k_ratio -= step;
    }
}

/**
 * @brief GLUT timer callback function to add animation delay.
 */
void timer_cb(int id)
{
    glutPostRedisplay();
    glutTimerFunc(animation_speed, timer_cb, 0);
}

/**
 * @brief Keypress event call back function.
 *
 * @param key ID of the key pressed
 * @param x mouse pointer position at event
 * @param y mouse pointer position at event
 */
void keyboard_cb(unsigned char key, int x, int y)
{
    switch (key)
    {
    case ' ':              // spacebar toggles pause
        paused = !paused;  // toggle
        break;
    case '+':  // up arrow key
        k_ratio += step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '_':  // down arrow key
        k_ratio -= step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '=':  // left arrow key
        l_ratio += step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case '-':  // right arrow key
        l_ratio -= step;
        display_graph(NULL, NULL, 1, l_ratio, k_ratio);
        break;
    case 0x1B:  // escape key exits
        exit(EXIT_SUCCESS);
    }
}
#endif

/** Main function */
int main(int argc, char **argv)
{
    test();

#ifdef USE_GLUT
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
    glutCreateWindow("Spirograph");
    glutInitWindowSize(400, 400);
    // glutIdleFunc(glutPostRedisplay);
    glutTimerFunc(animation_speed, timer_cb, 0);
    glutKeyboardFunc(keyboard_cb);
    glutDisplayFunc(test2);
    glutMainLoop();
#endif

    return 0;
}
/**
 * @file
 * @author [Carlos Rafael](https://github.com/CarlosZoft)
 * @author [Herick Lima](https://github.com/hericklima22)
 * @brief [naval_battle](https://en.wikipedia.org/wiki/Battleship_(game))
 * implementation in C using only the stdio.h for Standard Input and Output.
 * @details  Naval battle is a game, to be played by two people. It consists of
 * knocking down the enemy ship, through shots , when hit the ship is
 * revealed with the respective number of its size. Example: size 3 = 3 3 3 on
 * the board.
 * To play - boats over size 1, need direction; V -> vertical and H ->
 * horizontal. Example Input 1 A H -> line 1, column A, direction H
 * (Horizontal).
 */

#include <stdio.h>  /// for Standard Input Output

/**
 * @brief Function validEntryLineColumn
 * Responsible for validating entries, for positioning boats
 * @param line matrix row
 * @param column matrix column
 * @returns if the row and column are valid
 */
int validEntryLineColumn(int line, char column)
{
    if ((line >= 1 && line <= 10) && (column >= 65 && column <= 74))
    {
        return 1;
    }

    return 0;
}
/**
 * @brief Function validatePosition
 * Responsible for checking if the position can receive the boat.
 * @param mat board
 * @param boat boat
 * @param line matrix row
 * @param column matrix column
 * @returns if the position is valid
 */
int validatePosition(int mat[10][10], int boat, int line, int column,
                     char guide)
{
    int cont = 0;
    int i, j;

    if (line < 0 || line > 9 || column < 0 || column > 9 ||
        (guide != 'H' && guide != 'V') || boat < 1 || boat > 3)
    {
        return 0;
    }

    if (guide == 'H')
    {
        if ((10 - column) < boat)
        {
            return 0;
        }
        else
        {
            for (j = column; j < (column + boat); j++)
            {
                if (mat[line][j] == 0)
                {
                    cont++;
                }
            }
        }
    }

    if (guide == 'V')
    {
        if ((10 - line) < boat)
        {
            return 0;
        }

        else
        {
            for (i = line; i < (line + boat); i++)
            {
                if (mat[i][column] == 0)
                {
                    cont++;
                }
            }
        }
    }

    if (cont == boat)
    {
        return 1;
    }
    return 0;
}
/**
 * @brief Function canShoot
 * Responsible to verify that it is a valid position to shoot
 * @param mat board
 * @param line matrix row
 * @param column matrix column
 * @returns if the position is valid for shooting
 */

int canShoot(int mat[10][10], int line, int column)
{
    if (mat[line][column] == -2 || mat[line][column] == 10 ||
        mat[line][column] == 20 || mat[line][column] == 30 ||
        mat[line][column] == 50)
    {
        return 0;
    }

    return 1;
}
/**
 * @brief Function positionBoat
 * Responsible for placing the boats on the board, according to the size.
 * @param mat board
 * @param boat boat
 */
void positionBoat(int mat[10][10], int boat)
{
    int line, j;
    char column, guide;

    if (boat == 1)
    {
        scanf("%d %c", &line, &column);

        while (validEntryLineColumn(line, column) != 1 ||
               validatePosition(mat, boat, (line - 1), (column - 65), 'H') != 1)
        {
            printf("Position unavailable!\n");
            scanf("%d %c", &line, &column);
        }
    }

    else
    {
        scanf("%d %c %c", &line, &column, &guide);

        while (validEntryLineColumn(line, column) == 0 ||
               validatePosition(mat, boat, (line - 1), (column - 65), guide) ==
                   0)
        {
            printf("Position unavailable!\n");
            scanf("%d %c %c", &line, &column, &guide);
        }
    }

    int aux = column - 'A';
    line -= 1;

    if (boat == 1)
    {
        for (j = aux; j < (aux + boat); j++)
        {
            mat[line][j] = boat;
        }

        for (int a = line - 1; a < (line + boat + 1); a++)
        {
            for (int b = aux - 1; b < (aux + boat + 1); b++)
            {
                if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                {
                    if (mat[a][b] != boat)
                    {
                        mat[a][b] = -1;
                    }
                }
            }
        }
    }

    if (guide == 'H')
    {
        for (j = aux; j < (aux + boat); j++)
        {
            mat[line][j] = boat;
        }
        if (boat == 3)
        {
            for (int a = line - 1; a < (line + boat - 1); a++)
            {
                for (int b = aux - 1; b < (aux + boat + 1); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }

        else
        {
            for (int a = line - 1; a < (line + boat); a++)
            {
                for (int b = aux - 1; b < (aux + boat + 1); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }
    }

    if (guide == 'V')
    {
        for (j = line; j < (line + boat); j++)
        {
            mat[j][aux] = boat;
        }
        if (boat == 3)
        {
            for (int a = line - 1; a < (line + boat + 1); a++)
            {
                for (int b = aux - 1; b < (aux + boat - 1); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }

        else
        {
            for (int a = line - 1; a < (line + boat + 1); a++)
            {
                for (int b = aux - 1; b < (aux + boat); b++)
                {
                    if (a >= 0 && a <= 9 && b >= 0 && b <= 9)
                    {
                        if (mat[a][b] != boat)
                        {
                            mat[a][b] = -1;
                        }
                    }
                }
            }
        }
    }
}
/**
 * @brief Function printMessage
 * Responsible for printing the auxiliary message
 * @param msg msg with board
 */
void printMessage(char *msg)
{
    printf("************************\n");
    printf("*\n");
    printf("* %s\n", msg);
    printf("*\n");
    printf("************************\n");
}
/**
 * @brief Function printMessageScore
 * Responsible for printing the score messages
 * @param pts1 player 1 score
 * @param pts2 player 2 score
 */
void printMessageScore(int pts1, int pts2)
{
    printf("************************\n");
    printf("*\n");
    printf("* Player'S SCORE 1: %02d\n", pts1);
    printf("* Player'S SCORE 2: %02d\n", pts2);
    printf("*\n");
    printf("************************\n");
}
/**
 * @brief Function printTable
 * Responsible for printing the board
 * @param logic return of the logical matrix
 * @param stage game step
 * @returns char for visual matrix
 */
char printTable(int logic, int stage)
{
    if (stage == 0)
    {
        if (logic == 0)
        {
            return '.';
        }

        else if (logic == -1)
        {
            return '*';
        }

        else if (logic == 1)
        {
            return '1';
        }

        else if (logic == 2)
        {
            return '2';
        }

        else
        {
            return '3';
        }
    }

    else
    {
        if (logic == 0 || logic == -1 || logic == 1 || logic == 2 || logic == 3)
        {
            return '.';
        }

        else if (logic == -2)
        {
            return 'x';
        }

        else if (logic == 10 || logic == 20 || logic == 30)
        {
            return 'N';
        }

        else
        {
            return 'A';
        }
    }
}
/**
 * @brief Function printsTray
 * Responsible for printing the visual board for the user
 * @param mat Matrix
 * @param stage game step
 */
void printsTray(int mat[10][10], int stage)
{
    int logic;
    char imp;

    printf("     ");
    for (int i = 65; i < 75; i++)
    {
        printf("%c", i);
        if (i < 74)
        {
            printf(" ");
        }
    }
    printf("\n");

    for (int i = 0; i < 12; i++)
    {
        if (i > 0 && i < 11)
        {
            printf("%02d ", i);
        }

        else
        {
            printf("   ");
        }

        for (int j = 0; j < 12; j++)
        {
            if ((i > 0 && i < 11) && (j > 0 && j < 11))
            {
                logic = mat[i - 1][j - 1];
                imp = printTable(logic, stage);
                printf("%c", imp);
            }
            else
            {
                printf("#");
            }

            if (j < 11)
            {
                printf(" ");
            }
        }
        printf("\n");
    }
}
/**
 * @brief Function shoot
 * Responsible for saying if he hit a boat
 * @param mat board
 * @param line matrix row
 * @param column matrix column
 */
void shoot(int mat[10][10], int line, int column)
{
    if (mat[line][column] == 0 || mat[line][column] == -1)
    {
        mat[line][column] = -2;
    }

    else if (mat[line][column] == 1)
    {
        mat[line][column] = 10;
    }

    else if (mat[line][column] == 2)
    {
        mat[line][column] = 20;
    }

    else if (mat[line][column] == 3)
    {
        mat[line][column] = 30;
    }
}
/**
 * @brief Function calculateScore
 * Responsible for calculating the score obtained during the game
 * @param mat board
 * @param line matrix row
 * @param column matrix column
 * @returns resulting score
 */

int calculateScore(int mat[10][10], int line, int column)
{
    int c = 0, b = 0, e = 0, d = 0;

    if (mat[line][column] == 10)
    {
        mat[line][column] = 50;
        return 2;
    }

    else if (mat[line][column] == 20)
    {
        if (mat[line + 1][column] == 20)
        {
            b = 1;
        }

        if (mat[line - 1][column] == 20)
        {
            c = 1;
        }

        if (mat[line][column + 1] == 20)
        {
            d = 1;
        }

        if (mat[line][column - 1] == 20)
        {
            e = 1;
        }

        if (b == 1)
        {
            if (mat[line + 1][column] == 20)
            {
                mat[line][column] = 50;
                mat[line + 1][column] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }

        if (c == 1)
        {
            if (mat[line - 1][column] == 20)
            {
                mat[line][column] = 50;
                mat[line - 1][column] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }

        if (d == 1)
        {
            if (mat[line][column + 1] == 20)
            {
                mat[line][column] = 50;
                mat[line][column + 1] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }

        if (e == 1)
        {
            if (mat[line][column - 1] == 20)
            {
                mat[line][column] = 50;
                mat[line][column - 1] = 50;
                return 4;
            }
            else
            {
                return 0;
            }
        }
    }

    else if (mat[line][column] == 30)
    {
        if (mat[line + 1][column] == 30)
        {
            b = 1;
        }

        if (mat[line - 1][column] == 30)
        {
            c = 1;
        }
        if (mat[line][column + 1] == 30)
        {
            d = 1;
        }

        if (mat[line][column - 1] == 30)
        {
            e = 1;
        }

        if (b == 1 && c == 1)
        {
            if (mat[line + 1][column] == 30 && mat[line - 1][column] == 30)
            {
                mat[line][column] = 50;
                mat[line + 1][column] = 50;
                mat[line - 1][column] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (d == 1 && e == 1)
        {
            if (mat[line][column + 1] == 30 && mat[line][column - 1] == 30)
            {
                mat[line][column] = 50;
                mat[line][column - 1] = 50;
                mat[line][column + 1] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (d == 1)
        {
            if (mat[line][column + 1] == 30 && mat[line][column + 2] == 30)
            {
                mat[line][column] = 50;
                mat[line][column + 1] = 50;
                mat[line][column + 2] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (e == 1)
        {
            if (mat[line][column - 1] == 30 && mat[line][column - 2] == 30)
            {
                mat[line][column] = 50;
                mat[line][column - 1] = 50;
                mat[line][column - 2] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (c == 1)
        {
            if (mat[line - 1][column] == 30 && mat[line - 2][column] == 30)
            {
                mat[line][column] = 50;
                mat[line - 1][column] = 50;
                mat[line - 2][column] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }

        else if (b == 1)
        {
            if (mat[line + 1][column] == 30 && mat[line + 2][column] == 30)
            {
                mat[line][column] = 50;
                mat[line + 1][column] = 50;
                mat[line + 2][column] = 50;
                return 7;
            }
            else
            {
                return 0;
            }
        }
    }
    return 0;
}
/**
 * @brief Function printPositioning
 * Responsible for printing messages for positioning boats on the board; of
 * player 1 and 2
 * @param Player number representing the Player
 * @param boat number that represents the boat
 * @param nm which message to print
 */
void printPositioning(int Player, int boat, int nm)
{
    if (Player == 1)
    {
        char msg1[60] = "Player 1 - Position the size boat 1 (1/6)";
        char msg2[60] = "Player 1 - Position the size boat 1 (2/6)";
        char msg3[60] = "Player 1 - Position the size boat 1 (3/6)";
        char msg4[60] = "Player 1 - Position the size boat 1 (4/6)";
        char msg5[60] = "Player 1 - Position the size boat 1 (5/6)";
        char msg6[60] = "Player 1 - Position the size boat 1 (6/6)";

        char msg7[60] = "Player 1 - Position the size boat 2 (1/4)";
        char msg8[60] = "Player 1 - Position the size boat 2 (2/4)";
        char msg9[60] = "Player 1 - Position the size boat 2 (3/4)";
        char msg10[60] = "Player 1 - Position the size boat 2 (4/4)";

        char msg11[60] = "Player 1 - Position the size boat 3 (1/2)";
        char msg12[60] = "Player 1 - Position the size boat 3 (2/2)";

        if (boat == 1)
        {
            if (nm == 1)
            {
                printMessage(msg1);
            }
            else if (nm == 2)
            {
                printMessage(msg2);
            }
            else if (nm == 3)
            {
                printMessage(msg3);
            }

            else if (nm == 4)
            {
                printMessage(msg4);
            }

            else if (nm == 5)
            {
                printMessage(msg5);
            }

            else if (nm == 6)
            {
                printMessage(msg6);
            }
        }
        else if (boat == 2)
        {
            if (nm == 1)
            {
                printMessage(msg7);
            }
            else if (nm == 2)
            {
                printMessage(msg8);
            }
            else if (nm == 3)
            {
                printMessage(msg9);
            }
            else if (nm == 4)
            {
                printMessage(msg10);
            }
        }
        else if (boat == 3)
        {
            if (nm == 1)
            {
                printMessage(msg11);
            }
            if (nm == 2)
            {
                printMessage(msg12);
            }
        }
    }

    if (Player == 2)
    {
        char msg1[60] = "Player 2 - Position the size boat 1 (1/6)";
        char msg2[60] = "Player 2 - Position the size boat 1 (2/6)";
        char msg3[60] = "Player 2 - Position the size boat 1 (3/6)";
        char msg4[60] = "Player 2 - Position the size boat 1 (4/6)";
        char msg5[60] = "Player 2 - Position the size boat 1 (5/6)";
        char msg6[60] = "Player 2 - Position the size boat 1 (6/6)";

        char msg7[60] = "Player 2 - Position the size boat 2 (1/4)";
        char msg8[60] = "Player 2 - Position the size boat 2 (2/4)";
        char msg9[60] = "Player 2 - Position the size boat 2 (3/4)";
        char msg10[60] = "Player 2 - Position the size boat 2 (4/4)";

        char msg11[60] = "Player 2 - Position the size boat 3 (1/2)";
        char msg12[60] = "Player 2 - Position the size boat 3 (2/2)";

        if (boat == 1)
        {
            if (nm == 1)
            {
                printMessage(msg1);
            }
            else if (nm == 2)
            {
                printMessage(msg2);
            }
            else if (nm == 3)
            {
                printMessage(msg3);
            }
            else if (nm == 4)
            {
                printMessage(msg4);
            }
            else if (nm == 5)
            {
                printMessage(msg5);
            }
            else if (nm == 6)
            {
                printMessage(msg6);
            }
        }
        else if (boat == 2)
        {
            if (nm == 1)
            {
                printMessage(msg7);
            }
            else if (nm == 2)
            {
                printMessage(msg8);
            }
            else if (nm == 3)
            {
                printMessage(msg9);
            }
            else if (nm == 4)
            {
                printMessage(msg10);
            }
        }
        else if (boat == 3)
        {
            if (nm == 1)
            {
                printMessage(msg11);
            }
            else if (nm == 2)
            {
                printMessage(msg12);
            }
        }
    }
}
/**
 * @brief Main function
 * @returns 0 on exit
 */
int main()
{
    int Player1[10][10];
    int Player2[10][10];
    int plays = 1;
    int pts1 = 0, pts2 = 0, a1 = 0, a2 = 0;
    int line, col = 0, lin = 0;
    char column;

    // filling matrix with 0
    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            Player1[i][j] = 0;
            Player2[i][j] = 0;
        }
    }

    // positioning boats
    for (int i = 1; i <= 2; i++)
    {
        for (int j = 1; j <= 6; j++)
        {
            if (i == 1)
            {
                printPositioning(i, 1, j);
                printsTray(Player1, 0);
                positionBoat(Player1, 1);
            }
            else if (i == 2)
            {
                printPositioning(i, 1, j);
                printsTray(Player2, 0);
                positionBoat(Player2, 1);
            }
        }
        for (int j = 1; j <= 4; j++)
        {
            if (i == 1)
            {
                printPositioning(i, 2, j);
                printsTray(Player1, 0);
                positionBoat(Player1, 2);
            }
            else if (i == 2)
            {
                printPositioning(i, 2, j);
                printsTray(Player2, 0);
                positionBoat(Player2, 2);
            }
        }
        for (int j = 1; j <= 2; j++)
        {
            if (i == 1)
            {
                printPositioning(i, 3, j);
                printsTray(Player1, 0);
                positionBoat(Player1, 3);
            }
            else if (i == 2)
            {
                printPositioning(i, 3, j);
                printsTray(Player2, 0);
                positionBoat(Player2, 3);
            }
        }
    }

    // starting the game
    while (plays <= 40)
    {
        if (plays % 2 != 0)
        {
            printMessageScore(pts1, pts2);
            printMessage("Player's turn 1");
            printsTray(Player2, 1);
            scanf("%d %c", &line, &column);

            while (validEntryLineColumn(line, column) != 1 ||
                   canShoot(Player2, line - 1, column - 65) != 1)
            {
                line = 0;
                column = 'a';
                printf("Position unavailable!\n");
                scanf("%d %c", &line, &column);
            }
            lin = line - 1;
            col = column - 65;
            shoot(Player2, lin, col);
            a1 = pts1;
            pts1 += calculateScore(Player2, lin, col);

            if (a1 != pts1)
            {
                printMessage("Player 1 DROPPED A BOAT!");
            }
        }
        else
        {
            printMessageScore(pts1, pts2);
            printMessage("Player's turn 1");
            printsTray(Player1, 1);
            scanf("%d %c", &line, &column);

            while (validEntryLineColumn(line, column) != 1 ||
                   canShoot(Player1, line - 1, column - 65) != 1)
            {
                printf("Position unavailable!\n");
                scanf("%d %c", &line, &column);
            }
            lin = line - 1;
            col = column - 65;
            shoot(Player1, lin, col);
            a2 = pts2;
            pts2 += calculateScore(Player1, lin, col);

            if (a2 != pts2)
            {
                printMessage("Player 2 DROPPED A BOAT!");
            }
        }

        plays++;
    }
    /**
     * the one with the most points wins, or the one who knocks down all boats
     * first.
     */
    printMessage("END GAME\n");
    printMessageScore(pts1, pts2);

    return 0;
}
/**
 * @file tic-tac-toe.c
 * @author [vivekboss99](github.com/vivekboss99)
 * @author [Krishna Vedala](https://github.com/kvedala)
 * @brief [Tic-Tac-Toe game](https://en.wikipedia.org/wiki/Tic-tac-toe)
 * implementation in C
 * @details  Tic-Tac-Toe Game, where the user can decide to play with the
 * computer(single player mode) or with other user(double player mode), the
 * code as an array named 'game_table' which is the table and user needs to enter the
 * position inside the array(from 1-9) where he/she wants to place 'X' or 'O' on the
 * table.
 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

// Functions Declarations
static void singlemode();
static void doublemode();
static void placex(int);  // used for placing position of X by the 1st player
static void place();      // used by the computer to place O
static void placey(int);  // used in Double Player mode by the 2nd player to
                          // place the position of O
int checkwin();  // checks everytime when a player or computer places 'X' or 'O'

/** Tic-Tac-Toe table, so basically we are using variable 'game_table' as the table(size:3X3) and
 * updating it regularly
 */
static char game_table[9];

/**
 * Main program function.
 * @returns 0 on clean exit. 
 * @note No checks are included for program execution failures!
 */
int main()
{   
    srand( (unsigned int)time(NULL));
    int l = 0;
    do
    {
        int n = 0;

        // filling the table with multiple asterisks
        for (int i = 0; i < 9; i++) game_table[i] = '*';

        // displaying the main menu
        printf("***************************************\n");
        printf("*************TIC TAC TOE***************\n");
        printf("***************************************\n");
        printf("***********1. YOU vs COMPUTER ***********\n");
        printf("***********2. YOU vs PLAYER ***********\n");
        printf("***********3.EXIT *********************\n");
        printf("Enter your choice : ");
        scanf("%d", &n);

        switch (n)  // switch case to select between single player mode or
                    // double player mode
        {
        case 1:
            singlemode();
            break;
        case 2:
            doublemode();
            break;
        default:
            printf("THANK YOU and EXIT!");
        }

        printf("Next game ? : ");
        printf("Enter 1 – YES and 0 - NO ");
        scanf("%d", &l);

    } while (l == 1);

    return 0;
}

/**
 * @brief Implementation of game vs computer
 *
 * @returns None
 */
void singlemode()
{
    int m;
    int k = 0;
    int table_fill_count=0;

    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            printf("%c ", game_table[k]);
            k++;
        }

        printf("\n");
    }

    for (int x = 1; x < 10; x++)
    {
        k = 0;

        printf("Where would you like to place 'x' ");
        scanf("%d", &m);

        placex(m);
        if(table_fill_count<4)
        {
          place();
        }

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                printf("%c ", game_table[k]);
                k++;

            }

            printf("\n");
        }
        table_fill_count++;
        int o = checkwin();

        if (o == -1 || o == -2)
        {
            if (o == -1)
            {
                printf("YOU WIN\n");
            }
            if (o == -2)
            {
                printf("YOU LOSE\n");
            }

            break;
        }

        if (table_fill_count==4)
        {
            printf("\nDRAW ");
            break;
        }
    }
}

/**
 * @brief Implementation of game vs another player.
 *
 * @returns None
 */
void doublemode()
{
    int m;
    int e1;
    int k = 0;
    int doublemode_table_count=0;

    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            printf("%c ", game_table[k]);
            k++;
        }

        printf("\n");
    }
    for (int x = 1; x < 10; x++)
    {
        k = 0;

        printf("PLAYER1 - where would you like to place 'x' : ");
        scanf("%d", &m);

        placex(m);
        if(doublemode_table_count<4)
        {
        printf("PLAYER2 - where would you like to place 'o' : ");
        scanf("%d", &e1);

        placey(e1);
        }

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                printf("%c ", game_table[k]);
                k++;
            }

            printf("\n");
        }
        doublemode_table_count++;
        int o = checkwin();

        if (o == -1 || o == -2)
        {
            if (o == -1)
            {
                printf("Player 1 WIN\n");
            }
            if (o == -2)
            {
                printf("Player 2 WIN\n");
            }

            break;
        }
        if (doublemode_table_count==4)
        {
            printf("\nDRAW ");
            break;
        }
    }
}

int check_placex(){
	char input[50];
	int n1;
	while (1){
		fgets(input,49,stdin);
		if ( strlen(input) > 2 || strlen(input)  == 0){
			fprintf(stderr,"Invalid move, Enter number 1 - 9: ");
			continue;
		}
		if(sscanf(input,"%d",&n1) != 1){
			fprintf(stderr,"Invalid move, Enter number 1 - 9: ");
			continue;
		} 
		if ((game_table[n1-1] == 'x') || (game_table[n1-1]) == 'o' || (n1== 0)){
			fprintf(stderr,"Already allocated, Enter number: ");
			continue;
		}
		return n1;
	}
}	





/**
 * @brief Update table by placing an `X`
 *
 * @param m location to place `X`
 *
 * @returns None
 */
void placex(int m)
{
    int n1 = 0;
    if (m >= 1 && m <= 9)
    {
        if (game_table[m - 1] != 'x' && game_table[m - 1] != 'o')
        {
            game_table[m - 1] = 'x';
        }
        else
        {
			int n = check_placex();
			placex(n);
        }
    }
    else
    {
		int n = check_placex();
		placex(n);
    }
}
/**
 * @brief Update table by placing an `O`
 *
 * @returns None
 */
void place()
{

    int e = rand() % 9;

    if (e >= 0 && e <= 8)
    {
        if (game_table[e] != 'x' && game_table[e] != 'o')
        {
            game_table[e] = 'o';
            printf("\n Computer placed at %d position\n", e + 1);
        }
        else
        {
            place();
        }
    }
}
/**
 * @brief Update table by placing an `O`
 *
 * @param e1 location to place `O`
 *
 * @returns None
 */
void placey(int e1)
{
    int n1 = 0;
    if (e1 >= 1 && e1 <= 9)
    {
        if (game_table[e1 - 1] != 'x' && game_table[e1 - 1] != 'o')
        {
            game_table[e1 - 1] = 'o';
        }
        else
        {
			int n = check_placex();
			placex(n);
        }
    }
    else
    {
		int n = check_placex();
		placex(n);
    }
}
/**
 * @brief Implementation of win conditon checker for 'X' or 'O' whenever the table is updated
 *
 * @returns -1: if 'X' won 
 * @returns -2: if 'O' won
 * @returns 0: if there is no win condition for 'X' or 'O' 
 */
int checkwin()
{
    if (game_table[0] == game_table[1] && game_table[1] == game_table[2])
    {
        if (game_table[0] == 'x' && game_table[1] == 'x' &&
            game_table[2] == 'x')
        {
            return -1;
        }

        if (game_table[0] == 'o' && game_table[1] == 'o' &&
            game_table[2] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[0] == game_table[4] && game_table[4] == game_table[8])
    {
        if (game_table[0] == 'x' && game_table[4] == 'x' &&
            game_table[8] == 'x')
        {
            return -1;
        }

        if (game_table[0] == 'o' && game_table[4] == 'o' &&
            game_table[8] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[0] == game_table[3] && game_table[3] == game_table[6])
    {
        if (game_table[0] == 'x' && game_table[3] == 'x' &&
            game_table[6] == 'x')
        {
            return -1;
        }

        if (game_table[0] == 'o' && game_table[3] == 'o' &&
            game_table[6] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[3] == game_table[4] && game_table[4] == game_table[5])
    {
        if (game_table[3] == 'x' && game_table[4] == 'x' &&
            game_table[5] == 'x')
        {
            return -1;
        }

        if (game_table[3] == 'o' && game_table[4] == 'o' &&
            game_table[5] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[6] == game_table[7] && game_table[7] == game_table[8])
    {
        if (game_table[6] == 'x' && game_table[7] == 'x' &&
            game_table[8] == 'x')
        {
            return -1;
        }

        if (game_table[6] == 'o' && game_table[7] == 'o' &&
            game_table[8] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[1] == game_table[4] && game_table[4] == game_table[7])
    {
        if (game_table[1] == 'x' && game_table[4] == 'x' &&
            game_table[7] == 'x')
        {
            return -1;
        }

        if (game_table[1] == 'o' && game_table[4] == 'o' &&
            game_table[7] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[2] == game_table[5] && game_table[5] == game_table[8])
    {
        if (game_table[2] == 'x' && game_table[5] == 'x' &&
            game_table[8] == 'x')
        {
            return -1;
        }

        if (game_table[2] == 'o' && game_table[5] == 'o' &&
            game_table[8] == 'o')
        {
            return -2;
        }
    }
    else if (game_table[2] == game_table[4] && game_table[4] == game_table[6])
    {
        if (game_table[2] == 'x' && game_table[4] == 'x' &&
            game_table[6] == 'x')
        {
            return -1;
        }

        if (game_table[2] == 'o' && game_table[4] == 'o' &&
            game_table[6] == 'o')
        {
            return -2;
        }
    }
    return 0;
}
#include <stdio.h>
#include <stdlib.h>

#define MAX 20
#define INF 999

int mat[MAX][MAX];
int V;

int dist[MAX];

int q[MAX];
int qp = 0;

void enqueue(int v) { q[qp++] = v; }

int cf(void *a, void *b)
{
    int *x = (int *)a;
    int *y = (int *)b;
    return *y - *x;
}

int dequeue()
{
    qsort(q, qp, sizeof(int), cf);
    return q[--qp];
}

int queue_has_something() { return (qp > 0); }

int visited[MAX];
int vp = 0;

void dijkstra(int s)
{
    dist[s] = 0;
    int i;
    for (i = 0; i < V; ++i)
    {
        if (i != s)
        {
            dist[i] = INF;
        }
        enqueue(i);
    }
    while (queue_has_something())
    {
        int u = dequeue();
        visited[vp++] = u;
        for (i = 0; i < V; ++i)
        {
            if (mat[u][i])
            {
                if (dist[i] > dist[u] + mat[u][i])
                {
                    dist[i] = dist[u] + mat[u][i];
                }
            }
        }
    }
}

int main(int argc, char const *argv[])
{
    printf("Enter the number of vertices: ");
    scanf(" %d", &V);
    printf("Enter the adj matrix: ");
    int i, j;
    for (i = 0; i < V; ++i)
    {
        for (j = 0; j < V; ++j)
        {
            scanf(" %d", &mat[i][j]);
        }
    }

    dijkstra(0);

    printf("\nNode\tDist\n");
    for (i = 0; i < V; ++i)
    {
        printf("%d\t%d\n", i, dist[i]);
    }

    return 0;
}
/**
 * @file
 * @author [Timothy Maloney](https://github.com/sl1mb0)
 * @brief [Prim's algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm)
 * implementation in C to find the MST of a weighted, connected graph.
 * @details Prim's algorithm uses a greedy approach to generate the MST of a weighted connected graph.
 * The algorithm begins at an arbitrary vertex v, and selects a next vertex u, 
 * where v and u are connected by a weighted edge whose weight is the minimum of all edges connected to v. 
 * @references Page 319 "Introduction to the Design and Analysis of Algorithms" - Anany Levitin
 *
 * To test - run './prim -test'
 * prim() will find the MST of the following adj. matrix:
 *	  
 *	  0  1  2  3
 *        1  0  4  6
 *        2  4  0  5
 *        3  6  5  0
 * 
 * The minimum spanning tree for the above weighted connected graph is given by the following adj matrix:
 *	   
 *	  0  1  2  3
 *	  1  0  0  0
 *	  2  0  0  0
 *	  3  0  0  0
 *
 *
 * The following [link](https://visualgo.net/en/mst) provides a visual representation of graphs that can be used to test/verify the algorithm for different adj
 * matrices and their weighted, connected graphs.
 */

#include <stdio.h>        /// for IO operations
#include <string.h>      /// for string comparison
#include <assert.h>     /// for assert()
#include <inttypes.h>  /// for uint16_t

#define MAX 20
#define INF 999

/**
 * @brief Finds index of minimum element in edge list for an arbitrary vertex
 * @param arr graph row
 * @param N number of elements in arr
 * @returns index of minimum element in arr
 */
uint16_t minimum(uint16_t arr[], uint16_t N)
{
    uint16_t index = 0;
    uint16_t min = INF;

    for (uint16_t i = 0; i < N; i++)
    {
        if (arr[i] < min)
        {
            min = arr[i];
            index = i;
        }
    }
    return index;
}

/**
 * @brief Used to find MST of user-generated adj matrix G
 * @returns void
 */
void prim(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)
{
    uint16_t u, v;
    uint16_t E_t[MAX], path[MAX];
    uint16_t V_t[MAX], no_of_edges;

    E_t[0] = 0;  // edges for current vertex
    V_t[0] = 1;  // list of visited vertices

    for (uint16_t i = 1; i < V; i++)
    {
        E_t[i] = G[i][0];
        path[i] = 0;
        V_t[i] = 0;
    }

    no_of_edges = V - 1;

    while (no_of_edges > 0)
    {
        u = minimum(E_t, V);
        while (V_t[u] == 1)
        {
            E_t[u] = INF;
            u = minimum(E_t, V);
        }

        v = path[u];
        MST[v][u] = E_t[u];
        MST[u][v] = E_t[u];
        no_of_edges--;
        V_t[u] = 1;

        for (uint16_t i = 1; i < V; i++)
        {
            if (V_t[i] == 0 && G[u][i] < E_t[i])
            {
                E_t[i] = G[u][i];
                path[i] = v;
            }
        }
    }
}

/**
 * @brief Self-test implementations
 * @returns void
 */
static void test(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)
{
 
  uint16_t test[4][4] = {{0,1,2,3},{1,0,4,6},{2,4,0,5},{3,6,5,0}};
  uint16_t solution[4][4] = {{0,1,2,3},{1,0,0,0},{2,0,0,0},{3,0,0,0}};

  V = 4;

  for(uint16_t i = 0; i < V; ++i)
  {
    for(uint16_t j = 0; j < V; ++j)
    {
      G[i][j] = test[i][j];
    }
  }

  prim(&(*G),&(*MST),V);

  for(uint16_t i = 0; i < V; ++i)
  {
    for(uint16_t j = 0; j < V; ++j)
    {
      assert(MST[i][j] == solution[i][j]);
    }
  }
}

/**
 * @brief Function user_graph();
 * gets user input adj. matrix and finds MST of that graph
 * @returns void
 */
void user_graph(uint16_t G[][MAX], uint16_t MST[][MAX], uint16_t V)
{
      printf("Enter the number of vertices: ");
      scanf(" %hd", &V);

      assert(V <= MAX);

      printf("Enter the adj matrix\n");
      uint16_t i, j;
      for (i = 0; i < V; ++i)
      {
          for (j = 0; j < V; ++j)
          {
              printf("G[%d][%d]: ", i, j);
              scanf(" %hd", &G[i][j]);
              if (G[i][j] == 0)
                  G[i][j] = INF;
          }
      }

      prim(&(*G),&(*MST),V);

      printf("minimum spanning tree:\n");
      for (i = 0; i < V; ++i)
      {
          printf("\n");
          for (j = 0; j < V; ++j)
          {
              printf("%d\t", MST[i][j]);
          }
      }
}


/**
 * @brief Main function
 * @param argc commandline argument count (ignored)
 * @param argv commandline array of arguments (ignored)
 * @returns 0 on exit
 */
int main(int argc, char const *argv[])
{   

    uint16_t G[MAX][MAX];    ///< weighted, connected graph G
    uint16_t MST[MAX][MAX];  ///< adj matrix to hold minimum spanning tree of G
    uint16_t V;              ///< number of vertices in V in G


    if(argc == 2 && strcmp(argv[1],"-test") == 0)
    {
      test(&(*G),&(*MST),V);
    }
    else
    {
      user_graph(&(*G),&(*MST),V);
    }

    return 0;
}
