//= ===============================================================
// SHA1.js
//
// Module that replicates the SHA-1 Cryptographic Hash
// function in Javascript.
//= ===============================================================

// main variables
const CHAR_SIZE = 8

/**
 * Adds padding to binary/hex string representation
 *
 * @param {string} str - string representation (binary/hex)
 * @param {int} bits - total number of bits wanted
 * @return {string} - string representation padding with empty (0) bits
 *
 * @example
 *      pad("10011", 8); // "00010011"
 */
function pad (str, bits) {
  let res = str
  while (res.length % bits !== 0) {
    res = '0' + res
  }
  return res
}

/**
 * Separates string into chunks of the same size
 *
 * @param {string} str - string to separate into chunks
 * @param {int} size - number of characters wanted in each chunk
 * @return {array} - array of original string split into chunks
 *
 * @example
 *      chunkify("this is a test", 2)
 */
function chunkify (str, size) {
  const chunks = []
  for (let i = 0; i < str.length; i += size) {
    chunks.push(str.slice(i, i + size))
  }
  return chunks
}

/**
 * Rotates string representation of bits to the left
 *
 * @param {string} bits - string representation of bits
 * @param {int} turns - number of rotations to make
 * @return {string} - string representation of bits after rotation
 *
 * @example
 *      rotateLeft("1011", 3); // "1101"
 */
function rotateLeft (bits, turns) {
  return bits.substr(turns) + bits.substr(0, turns)
}

/**
 * Pre-processes message to feed the algorithm loop
 *
 * @param {string} message - message to pre-process
 * @return {string} - processed message
 */
function preProcess (message) {
  // convert message to binary representation padded to
  // 8 bits, and add 1
  let m = message.split('')
    .map(e => e.charCodeAt(0))
    .map(e => e.toString(2))
    .map(e => pad(e, 8))
    .join('') + '1'

  // extend message by adding empty bits (0)
  while (m.length % 512 !== 448) {
    m += '0'
  }

  // length of message in binary, padded, and extended
  // to a 64 bit representation
  let ml = (message.length * CHAR_SIZE).toString(2)
  ml = pad(ml, 8)
  ml = '0'.repeat(64 - ml.length) + ml

  return m + ml
}

/**
 * Hashes message using SHA-1 Cryptographic Hash Function
 *
 * @param {string} message - message to hash
 * @return {string} - message digest (hash value)
 */
function SHA1 (message) {
  // main variables
  let H0 = 0x67452301
  let H1 = 0xEFCDAB89
  let H2 = 0x98BADCFE
  let H3 = 0x10325476
  let H4 = 0xC3D2E1F0

  // pre-process message and split into 512 bit chunks
  const bits = preProcess(message)
  const chunks = chunkify(bits, 512)

  chunks.forEach(function (chunk, i) {
    // break each chunk into 16 32-bit words
    const words = chunkify(chunk, 32)

    // extend 16 32-bit words to 80 32-bit words
    for (let i = 16; i < 80; i++) {
      const val = [words[i - 3], words[i - 8], words[i - 14], words[i - 16]]
        .map(e => parseInt(e, 2))
        .reduce((acc, curr) => curr ^ acc, 0)
      const bin = (val >>> 0).toString(2)
      const paddedBin = pad(bin, 32)
      const word = rotateLeft(paddedBin, 1)
      words.push(word)
    }

    // initialize variables for this chunk
    let [a, b, c, d, e] = [H0, H1, H2, H3, H4]

    for (let i = 0; i < 80; i++) {
      let f, k
      if (i < 20) {
        f = (b & c) | (~b & d)
        k = 0x5A827999
      } else if (i < 40) {
        f = b ^ c ^ d
        k = 0x6ED9EBA1
      } else if (i < 60) {
        f = (b & c) | (b & d) | (c & d)
        k = 0x8F1BBCDC
      } else {
        f = b ^ c ^ d
        k = 0xCA62C1D6
      }
      // make sure f is unsigned
      f >>>= 0

      const aRot = rotateLeft(pad(a.toString(2), 32), 5)
      const aInt = parseInt(aRot, 2) >>> 0
      const wordInt = parseInt(words[i], 2) >>> 0
      const t = aInt + f + e + k + wordInt
      e = d >>> 0
      d = c >>> 0
      const bRot = rotateLeft(pad(b.toString(2), 32), 30)
      c = parseInt(bRot, 2) >>> 0
      b = a >>> 0
      a = t >>> 0
    }

    // add values for this chunk to main hash variables (unsigned)
    H0 = (H0 + a) >>> 0
    H1 = (H1 + b) >>> 0
    H2 = (H2 + c) >>> 0
    H3 = (H3 + d) >>> 0
    H4 = (H4 + e) >>> 0
  })

  // combine hash values of main hash variables and return
  const HH = [H0, H1, H2, H3, H4]
    .map(e => e.toString(16))
    .map(e => pad(e, 8))
    .join('')

  return HH
}

// export SHA1 function
export { SHA1 }
//= ===============================================================
// SHA256.js
//
// Module that replicates the SHA-256 Cryptographic Hash
// function in Javascript.
//= ===============================================================

// main variables
const CHAR_SIZE = 8

const K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]

/**
 * Adds padding to binary/hex string representation
 *
 * @param {string} str - string representation (binary/hex)
 * @param {int} bits - total number of bits wanted
 * @return {string} - string representation padding with empty (0) bits
 *
 * @example
 *      pad("10011", 8); // "00010011"
 */
function pad (str, bits) {
  let res = str
  while (res.length % bits !== 0) {
    res = '0' + res
  }
  return res
}

/**
 * Separates string into chunks of the same size
 *
 * @param {string} str - string to separate into chunks
 * @param {int} size - number of characters wanted in each chunk
 * @return {array} - array of original string split into chunks
 *
 * @example
 *      chunkify("this is a test", 2)
 */
function chunkify (str, size) {
  const chunks = []
  for (let i = 0; i < str.length; i += size) {
    chunks.push(str.slice(i, i + size))
  }
  return chunks
}

/**
 * Rotates string representation of bits to th left
 *
 * @param {string} bits - string representation of bits
 * @param {int} turns - number of rotations to make
 * @return {string} - string representation of bits after rotation
 *
 * @example
 *      rotateLeft("1011", 3); // "1101"
 */
function rotateRight (bits, turns) {
  return bits.substr(bits.length - turns) + bits.substr(0, bits.length - turns)
}

/**
 * Pre-processes message to feed the algorithm loop
 *
 * @param {string} message - message to pre-process
 * @return {string} - processed message
 */
function preProcess (message) {
  // convert message to binary representation padded to
  // 8 bits, and add 1
  let m = message.split('')
    .map(e => e.charCodeAt(0))
    .map(e => e.toString(2))
    .map(e => pad(e, 8))
    .join('') + '1'

  // extend message by adding empty bits (0)
  while (m.length % 512 !== 448) {
    m += '0'
  }

  // length of message in binary, padded, and extended
  // to a 64 bit representation
  let ml = (message.length * CHAR_SIZE).toString(2)
  ml = pad(ml, 8)
  ml = '0'.repeat(64 - ml.length) + ml

  return m + ml
}

/**
 * Hashes message using SHA-256 Cryptographic Hash Function
 *
 * @param {string} message - message to hash
 * @return {string} - message digest (hash value)
 */
function SHA256 (message) {
  // initial hash variables
  let H0 = 0x6a09e667
  let H1 = 0xbb67ae85
  let H2 = 0x3c6ef372
  let H3 = 0xa54ff53a
  let H4 = 0x510e527f
  let H5 = 0x9b05688c
  let H6 = 0x1f83d9ab
  let H7 = 0x5be0cd19

  // pre-process message and split into 512 bit chunks
  const bits = preProcess(message)
  const chunks = chunkify(bits, 512)

  chunks.forEach(function (chunk, i) {
    // break each chunk into 16 32-bit words
    const words = chunkify(chunk, 32)

    // extend 16 32-bit words to 80 32-bit words
    for (let i = 16; i < 64; i++) {
      const W1 = words[i - 15]
      const W2 = words[i - 2]
      const R1 = rotateRight(W1, 7)
      const R2 = rotateRight(W1, 18)
      const R3 = rotateRight(W2, 17)
      const R4 = rotateRight(W2, 19)
      const S0 = parseInt(R1, 2) ^ parseInt(R2, 2) ^ (parseInt(W1, 2) >>> 3)
      const S1 = parseInt(R3, 2) ^ parseInt(R4, 2) ^ (parseInt(W2, 2) >>> 10)
      const val = parseInt(words[i - 16], 2) + S0 + parseInt(words[i - 7], 2) + S1
      words[i] = pad((val >>> 0).toString(2), 32)
    }

    // initialize variables for this chunk
    let [a, b, c, d, e, f, g, h] = [H0, H1, H2, H3, H4, H5, H6, H7]

    for (let i = 0; i < 64; i++) {
      const S1 = [6, 11, 25]
        .map(turns => rotateRight(pad(e.toString(2), 32), turns))
        .map(bitstring => parseInt(bitstring, 2))
        .reduce((acc, curr) => acc ^ curr, 0) >>> 0
      const CH = ((e & f) ^ (~e & g)) >>> 0
      const temp1 = (h + S1 + CH + K[i] + parseInt(words[i], 2)) >>> 0
      const S0 = [2, 13, 22]
        .map(turns => rotateRight(pad(a.toString(2), 32), turns))
        .map(bitstring => parseInt(bitstring, 2))
        .reduce((acc, curr) => acc ^ curr, 0) >>> 0
      const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0
      const temp2 = (S0 + maj) >>> 0

      h = g
      g = f
      f = e
      e = (d + temp1) >>> 0
      d = c
      c = b
      b = a
      a = (temp1 + temp2) >>> 0
    }

    // add values for this chunk to main hash variables (unsigned)
    H0 = (H0 + a) >>> 0
    H1 = (H1 + b) >>> 0
    H2 = (H2 + c) >>> 0
    H3 = (H3 + d) >>> 0
    H4 = (H4 + e) >>> 0
    H5 = (H5 + f) >>> 0
    H6 = (H6 + g) >>> 0
    H7 = (H7 + h) >>> 0
  })

  // combine hash values of main hash variables and return
  const HH = [H0, H1, H2, H3, H4, H5, H6, H7]
    .map(e => e.toString(16))
    .map(e => pad(e, 8))
    .join('')

  return HH
}

// export SHA256 function
export { SHA256 }
/**
 * Adelson-Velsky and Landis Tree
 * [Wikipedia](https://en.wikipedia.org/wiki/AVL_tree)
 * [A video lecture](http://www.youtube.com/watch?v=TbvhGcf6UJU)
 */
'use strict'

/**
 * A utility class for comparator
 * A comparator is expected to have following structure
 *
 * comp(a, b) RETURN < 0 if a < b
 * RETURN > 0 if a > b
 * MUST RETURN 0 if a == b
 */
let utils;
(function (_utils) {
  function comparator () {
    return function (v1, v2) {
      if (v1 < v2) return -1
      if (v2 < v1) return 1
      return 0
    }
  }
  _utils.comparator = comparator
})(utils || (utils = {}))

/**
 * @constructor
 * A class for AVL Tree
 * @argument comp - A function used by AVL Tree For Comparison
 * If no argument is sent it uses utils.comparator
 */
const AVLTree = (function () {
  function _avl (comp) {
    /** @public comparator function */
    this._comp = undefined
    this._comp = comp !== undefined ? comp : utils.comparator()

    /** @public root of the AVL Tree */
    this.root = null
    /** @public number of elements in AVL Tree */
    this.size = 0
  }

  // creates new Node Object
  const Node = function (val) {
    this._val = val
    this._left = null
    this._right = null
    this._height = 1
  }

  // get height of a node
  const getHeight = function (node) {
    if (node == null) { return 0 }
    return node._height
  }

  // height difference or balance factor of a node
  const getHeightDifference = function (node) {
    return node == null ? 0 : getHeight(node._left) - getHeight(node._right)
  }

  // update height of a node based on children's heights
  const updateHeight = function (node) {
    if (node == null) { return }
    node._height = Math.max(getHeight(node._left), getHeight(node._right)) + 1
  }

  // Helper: To check if the balanceFactor is valid
  const isValidBalanceFactor = (balanceFactor) => [0, 1, -1].includes(balanceFactor)

  // rotations of AVL Tree
  const leftRotate = function (node) {
    const temp = node._right
    node._right = temp._left
    temp._left = node
    updateHeight(node)
    updateHeight(temp)
    return temp
  }
  const rightRotate = function (node) {
    const temp = node._left
    node._left = temp._right
    temp._right = node
    updateHeight(node)
    updateHeight(temp)
    return temp
  }

  // check if tree is balanced else balance it for insertion
  const insertBalance = function (node, _val, balanceFactor) {
    if (balanceFactor > 1 && _val < node._left._val) {
      return rightRotate(node) // Left Left Case
    }
    if (balanceFactor < 1 && _val > node._right._val) {
      return leftRotate(node) // Right Right Case
    }
    if (balanceFactor > 1 && _val > node._left._val) {
      node._left = leftRotate(node._left) // Left Right Case
      return rightRotate(node)
    }
    node._right = rightRotate(node._right)
    return leftRotate(node)
  }

  // check if tree is balanced after deletion
  const delBalance = function (node) {
    const balanceFactor1 = getHeightDifference(node)
    if (isValidBalanceFactor(balanceFactor1)) {
      return node
    }
    if (balanceFactor1 > 1) {
      if (getHeightDifference(node._left) >= 0) {
        return rightRotate(node) // Left Left
      }
      node._left = leftRotate(node._left)
      return rightRotate(node) // Left Right
    }
    if (getHeightDifference(node._right) > 0) {
      node._right = rightRotate(node._right)
      return leftRotate(node) // Right Left
    }
    return leftRotate(node) // Right Right
  }

  // implement avl tree insertion
  const insert = function (root, val, tree) {
    if (root == null) {
      tree.size++
      return new Node(val)
    }
    if (tree._comp(root._val, val) < 0) {
      root._right = insert(root._right, val, tree)
    } else if (tree._comp(root._val, val) > 0) {
      root._left = insert(root._left, val, tree)
    } else {
      return root
    }
    updateHeight(root)
    const balanceFactor = getHeightDifference(root)
    return isValidBalanceFactor(balanceFactor) ? root : insertBalance(root, val, balanceFactor)
  }

  // delete am element
  const deleteElement = function (root, _val, tree) {
    if (root == null) { return root }
    if (tree._comp(root._val, _val) === 0) { // key found case
      if (root._left === null && root._right === null) {
        root = null
        tree.size--
      } else if (root._left === null) {
        root = root._right
        tree.size--
      } else if (root._right === null) {
        root = root._left
        tree.size--
      } else {
        let temp = root._right
        while (temp._left != null) {
          temp = temp._left
        }
        root._val = temp._val
        root._right = deleteElement(root._right, temp._val, tree)
      }
    } else {
      if (tree._comp(root._val, _val) < 0) {
        root._right = deleteElement(root._right, _val, tree)
      } else {
        root._left = deleteElement(root._left, _val, tree)
      }
    }
    updateHeight(root)
    root = delBalance(root)
    return root
  }
  // search tree for a element
  const searchAVLTree = function (root, val, tree) {
    if (root == null) { return null }
    if (tree._comp(root._val, val) === 0) {
      return root
    }
    if (tree._comp(root._val, val) < 0) {
      return searchAVLTree(root._right, val, tree)
    }
    return searchAVLTree(root._left, val, tree)
  }

  /* Public Functions */
  /**
   * For Adding Elements to AVL Tree
   * @param {any} _val
   * Since in AVL Tree an element can only occur once so
   * if a element exists it return false
   * @returns {Boolean} element added or not
   */
  _avl.prototype.add = function (_val) {
    const prevSize = this.size
    this.root = insert(this.root, _val, this)
    return this.size !== prevSize
  }
  /**
   * TO check is a particular element exists or not
   * @param {any} _val
   * @returns {Boolean} exists or not
   */
  _avl.prototype.find = function (_val) {
    const temp = searchAVLTree(this.root, _val, this)
    return temp != null
  }
  /**
   *
   * @param {any} _val
   * It is possible that element doesn't exists in tree
   * in that case it return false
   * @returns {Boolean} if element was found and deleted
   */
  _avl.prototype.remove = function (_val) {
    const prevSize = this.size
    this.root = deleteElement(this.root, _val, this)
    return prevSize !== this.size
  }
  return _avl
}())

/**
 * A Code for Testing the AVLTree
 */
// (function test () {
//   const newAVL = new AVLTree()
//   const size = Math.floor(Math.random() * 1000000)
//   let uniques = 0
//   let i, temp, j
//   const array = []
//   for (i = 0; i < size; i++) {
//     temp = Math.floor(Math.random() * Number.MAX_VALUE)
//     if (newAVL.add(temp)) {
//       uniques++
//       array.push(temp)
//     }
//   }
//   if (newAVL.size !== uniques) {
//     throw new Error('elements not inserted properly')
//   }
//   const findTestSize = Math.floor(Math.random() * uniques)
//   for (i = 0; i < findTestSize; i++) {
//     j = Math.floor(Math.random() * uniques)
//     if (!newAVL.find(array[j])) {
//       throw new Error('inserted elements not found')
//     }
//   }
//   const deleteTestSize = Math.floor(uniques * Math.random())
//   for (i = 0; i < deleteTestSize; i++) {
//     j = Math.floor(Math.random() * uniques)
//     temp = array[j]
//     if (newAVL.find(temp)) {
//       if (!newAVL.remove(temp)) {
//         throw new Error('delete not working properly')
//       }
//     }
//   }
// })()

export { AVLTree }
/* Binary Search Tree!!
*
* Nodes that will go on the Binary Tree.
* They consist of the data in them, the node to the left, the node
* to the right, and the parent from which they came from.
*
* A binary tree is a data structure in which an element
* has two successors(children). The left child is usually
* smaller than the parent, and the right child is usually
* bigger.
*/

// class Node
const Node = (function Node () {
  // Node in the tree
  function Node (val) {
    this.value = val
    this.left = null
    this.right = null
  }

  // Search the tree for a value
  Node.prototype.search = function (val) {
    if (this.value === val) {
      return this
    } else if (val < this.value && this.left !== null) {
      return this.left.search(val)
    } else if (val > this.value && this.right !== null) {
      return this.right.search(val)
    }
    return null
  }

  // Visit a node
  Node.prototype.visit = function (output = value => console.log(value)) {
    // Recursively go left
    if (this.left !== null) {
      this.left.visit()
    }
    // Print out value
    output(this.value)
    // Recursively go right
    if (this.right !== null) {
      this.right.visit()
    }
  }

  // Add a node
  Node.prototype.addNode = function (n) {
    if (n.value < this.value) {
      if (this.left === null) {
        this.left = n
      } else {
        this.left.addNode(n)
      }
    } else if (n.value > this.value) {
      if (this.right === null) {
        this.right = n
      } else {
        this.right.addNode(n)
      }
    }
  }

  // remove a node
  Node.prototype.removeNode = function (val) {
    if (val === this.value) {
      if (!this.left && !this.right) {
        return null
      } else {
        if (this.left) {
          const leftMax = maxVal(this.left)
          this.value = leftMax
          this.left = this.left.removeNode(leftMax)
        } else {
          const rightMin = minVal(this.right)
          this.value = rightMin
          this.right = this.right.removeNode(rightMin)
        }
      }
    } else if (val < this.value) {
      this.left = this.left && this.left.removeNode(val)
    } else if (val > this.value) {
      this.right = this.right && this.right.removeNode(val)
    }
    return this
  }

  // find maximum value in the tree
  const maxVal = function (node) {
    if (!node.right) {
      return node.value
    }
    return maxVal(node.right)
  }

  // find minimum value in the tree
  const minVal = function (node) {
    if (!node.left) {
      return node.value
    }
    return minVal(node.left)
  }
  // returns the constructor
  return Node
}())

// class Tree
const Tree = (function () {
  function Tree () {
    // Just store the root
    this.root = null
  };

  // Inorder traversal
  Tree.prototype.traverse = function () {
    if (!this.root) {
      // No nodes are there in the tree till now
      return
    }
    this.root.visit()
  }

  // Start by searching the root
  Tree.prototype.search = function (val) {
    const found = this.root.search(val)
    if (found !== null) {
      return found.value
    }
    // not found
    return null
  }

  // Add a new value to the tree
  Tree.prototype.addValue = function (val) {
    const n = new Node(val)
    if (this.root === null) {
      this.root = n
    } else {
      this.root.addNode(n)
    }
  }

  // remove a value from the tree
  Tree.prototype.removeValue = function (val) {
    // remove something if root exists
    this.root = this.root && this.root.removeNode(val)
  }

  // returns the constructor
  return Tree
}())

export { Tree }
import { AVLTree } from '../AVLTree'

describe('AVLTree Implementation: ', () => {
  const avlTree = new AVLTree()
  const dataList = []
  const demoData = [1, 4, 6, 22, 7, 99, 4, 66, 77, 98]

  beforeAll(() => {
    demoData.forEach(item => {
      if (avlTree.add(item)) {
        dataList.push(item)
      }
    })
  })

  it('checks if element is inserted properly', () => {
    expect(dataList.length).toEqual(avlTree.size)
  })

  it('search if inserted element is present', () => {
    demoData.forEach(data => {
      expect(avlTree.find(data)).toBeTruthy()
    })
  })

  it('deletes the inserted element', () => {
    const deleteElement = dataList[3]
    expect(avlTree.remove(deleteElement)).toBeTruthy()
  })
})
const TrieNode = function TrieNode (key, parent) {
  this.key = key
  this.count = 0
  this.children = Object.create(null)
  if (parent === undefined) {
    this.parent = null
  } else {
    this.parent = parent
  }
}

function Trie () {
  // create only root with null key and parent
  this.root = new TrieNode(null, null)
}

// Recursively finds the occurrence of all words in a given node
Trie.findAllWords = function (root, word, output) {
  if (root === null) return
  if (root.count > 0) {
    if (typeof output === 'object') { output.push({ word, count: root.count }) }
  }
  let key
  for (key in root.children) {
    word += key
    this.findAllWords(root.children[key], word, output)
    word = word.slice(0, -1)
  }
}

Trie.prototype.insert = function (word) {
  if (typeof word !== 'string') return
  if (word === '') {
    this.root.count += 1
    return
  }
  let node = this.root
  const len = word.length
  let i
  for (i = 0; i < len; i++) {
    if (node.children[word.charAt(i)] === undefined) { node.children[word.charAt(i)] = new TrieNode(word.charAt(i), node) }
    node = node.children[word.charAt(i)]
  }
  node.count += 1
}

Trie.prototype.findPrefix = function (word) {
  if (typeof word !== 'string') return null
  let node = this.root
  const len = word.length
  let i
  // After end of this loop node will be at desired prefix
  for (i = 0; i < len; i++) {
    if (node.children[word.charAt(i)] === undefined) return null // No such prefix exists
    node = node.children[word.charAt(i)]
  }
  return node
}

Trie.prototype.remove = function (word, count) {
  if (typeof word !== 'string') return
  if (typeof count !== 'number') count = 1
  else if (count <= 0) return

  // for empty string just delete count of root
  if (word === '') {
    if (this.root.count >= count) this.root.count -= count
    else this.root.count = 0
    return
  }

  let child = this.root
  const len = word.length
  let i, key
  // child: node which is to be deleted
  for (i = 0; i < len; i++) {
    key = word.charAt(i)
    if (child.children[key] === undefined) return
    child = child.children[key]
  }

  // Delete no of occurrences specified
  if (child.count >= count) child.count -= count
  else child.count = 0

  // If some occurrences are left we dont delete it or else
  // if the object forms some other objects prefix we dont delete it
  // For checking an empty object
  // https://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object
  if (child.count <= 0 && (Object.keys(child.children).length && child.children.constructor === Object)) {
    child.parent.children[child.key] = undefined
  }
}

Trie.prototype.findAllWords = function (prefix) {
  const output = []
  // find the node with provided prefix
  const node = this.findPrefix(prefix)
  // No such prefix exists
  if (node === null) return output
  Trie.findAllWords(node, prefix, output)
  return output
}

Trie.prototype.contains = function (word) {
  // find the node with given prefix
  const node = this.findPrefix(word)
  // No such word exists
  if (node === null || node.count === 0) return false
  return true
}

Trie.prototype.findOccurences = function (word) {
  // find the node with given prefix
  const node = this.findPrefix(word)
  // No such word exists
  if (node === null) return 0
  return node.count
}

export { Trie }
import { DoubleLinkedList } from '../DoublyLinkedList'

describe('DoubleLinkedList', () => {
  it('Check append', () => {
    const list = new DoubleLinkedList()

    list.append(1)
    expect(list.getHead().element).toEqual(1)

    list.append(2)
    expect(list.getTail().element).toEqual(2)
  })

  it('Check insert', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 1)
    expect(list.getHead().element).toEqual(1)

    list.insert(1, 20)
    expect(list.getTail().element).toEqual(20)
  })

  it('Check removeAt', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 10)
    list.insert(1, 40)
    list.insert(2, 30)

    list.removeAt(0)
    expect(list.getHead().element).toEqual(40)

    list.removeAt(1)
    expect(list.getTail().element).toEqual(40)
  })

  it('Check delete', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 10)
    list.insert(1, 40)

    list.delete(10)
    expect(list.getHead().element).toEqual(40)
  })

  it('Check deleteTail', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 10)
    list.insert(1, 40)

    list.deleteTail()
    expect(list.getTail().element).toEqual(10)
  })

  it('Check toString', () => {
    const list = new DoubleLinkedList()

    list.insert(0, 20)
    expect(list.toString()).toEqual('20')
  })

  it('Check isEmpty', () => {
    const list = new DoubleLinkedList()

    expect(list.isEmpty()).toEqual(true)

    list.insert(0, 'Hello')
    expect(list.isEmpty()).toEqual(false)
  })

  it('Check size', () => {
    const list = new DoubleLinkedList()
    expect(list.size()).toBe(0)

    list.append(10)
    expect(list.size()).toBe(1)

    list.removeAt(1)
    expect(list.size()).toBe(1)
  })

  it('Check toArray', () => {
    const list = new DoubleLinkedList()
    list.append(1)
    list.append(2)

    const listArray = list.toArray()
    expect(listArray).toEqual([1, 2])
  })

  it('Check getHead', () => {
    const list = new DoubleLinkedList()
    expect(list.getHead()).toEqual(null)

    list.append(1)
    list.append(2)
    expect(list.getHead()).toBeInstanceOf(Object)
  })

  it('Check Iterator', () => {
    const list = new DoubleLinkedList()

    let iterate = list.iterator()
    expect(iterate).toBe(-1)

    const arr = [10, 20, 5]
    list.append(arr[0])
    list.append(arr[1])
    list.append(arr[2])
    iterate = list.iterator()

    for (let i = 0; i < arr.length; i++) {
      expect(iterate.next().value).toBe(arr[i])
    }
    expect(iterate.next().value).toBe(undefined)

    iterate = list.iterator()
    let count = 0
    for (const item of iterate) {
      expect(item).toBe(arr[count])
      count++
    }
  })
})
import { SinglyCircularLinkedList } from '../SinglyCircularLinkedList'

describe('SinglyCircularLinkedList', () => {
  let list
  beforeEach(() => {
    list = new SinglyCircularLinkedList()
  })
  it('Check get', () => {
    expect(list.get()).toEqual([])
    expect(list.add(1)).toEqual(1)
    expect(list.get()).toEqual([1])
    expect(list.add(5)).toEqual(2)
    expect(list.get()).toEqual([1, 5])
  })

  it('Check size', () => {
    expect(list.size()).toEqual(0)
    expect(list.add(1)).toEqual(1)
    expect(list.add(1)).toEqual(2)
    expect(list.size()).toEqual(2)
  })

  it('Check head', () => {
    expect(list.head()).toEqual(null)
    expect(list.add(1)).toEqual(1)
    expect(list.head()).toEqual(1)
    expect(list.add(1)).toEqual(2)
    expect(list.head()).toEqual(1)
    expect(list.addAtFirst(100)).toEqual(3)
    expect(list.head()).toEqual(100)
    expect(list.insertAt(0, 500)).toEqual(4)
    expect(list.head()).toEqual(500)
    list.clear()
    expect(list.head()).toEqual(null)
  })

  it('Check isEmpty', () => {
    expect(list.isEmpty()).toEqual(true)
    expect(list.add(1)).toEqual(1)
    expect(list.add(1)).toEqual(2)
    expect(list.isEmpty()).toEqual(false)
  })

  it('Check getElementAt', () => {
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)

    expect(list.getElementAt(1).data).toEqual(200)
    expect(list.getElementAt(3).data).toEqual(500)
  })

  it('Check addAtFirst', () => {
    list.add(1)
    list.add(5)
    list.add(7)
    list.add(9)
    list.add(0)
    expect(list.get()).toEqual([1, 5, 7, 9, 0])
    list.addAtFirst(100)
    expect(list.get()).toEqual([100, 1, 5, 7, 9, 0])
  })

  it('Check add', () => {
    list.add(1)
    list.add(5)
    list.add(7)
    list.add(9)
    list.add(0)
    expect(list.get()).toEqual([1, 5, 7, 9, 0])
    list.add(100)
    expect(list.get()).toEqual([1, 5, 7, 9, 0, 100])
  })

  it('Check insertAt', () => {
    expect(list.insertAt(0, 100)).toEqual(1)
    expect(list.get()).toEqual([100])
    expect(list.insertAt(0, 200)).toEqual(2)
    expect(list.get()).toEqual([200, 100])
    expect(list.insertAt(2, 300)).toEqual(3)
    expect(list.get()).toEqual([200, 100, 300])
  })

  it('Checks indexOf', () => {
    expect(list.indexOf(200)).toEqual(-1)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.indexOf(200)).toEqual(1)
  })

  it('Check remove', () => {
    expect(list.remove()).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.remove()
    expect(removedData).toEqual(900)
    expect(list.get()).toEqual([100, 200, 300, 500])
  })

  it('Check removeFirst', () => {
    expect(list.removeFirst()).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.removeFirst()
    expect(removedData).toEqual(100)
    expect(list.get()).toEqual([200, 300, 500, 900])
  })

  it('Check removeAt', () => {
    expect(list.removeAt(1)).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.removeAt(2)
    expect(removedData).toEqual(300)
    expect(list.get()).toEqual([100, 200, 500, 900])
  })

  it('Check removeData', () => {
    expect(list.removeData(100)).toEqual(null)
    list.add(100)
    list.add(200)
    list.add(300)
    list.add(500)
    list.add(900)
    expect(list.get()).toEqual([100, 200, 300, 500, 900])
    const removedData = list.removeData(200)
    expect(removedData).toEqual(200)
    expect(list.get()).toEqual([100, 300, 500, 900])
  })
})
import { AddTwoNumbers } from '../AddTwoNumbers.js'
import { LinkedList } from '../SinglyLinkedList'

describe('AddTwoNumbers', () => {
  it('Check Sum Of Two Linked List', () => {
    const list1 = new LinkedList()
    list1.addFirst(2)
    list1.addLast(4)
    list1.addLast(3)

    const list2 = new LinkedList()
    list2.addFirst(5)
    list2.addLast(6)
    list2.addLast(4)

    const expected = new LinkedList()
    expected.addFirst(7)
    expected.addLast(0)
    expected.addLast(8)

    const addTwoLinkedList = new AddTwoNumbers()
    addTwoLinkedList.solution(list1.headNode, list2.headNode)

    expect(addTwoLinkedList.solutionToArray()).toEqual(expected.get())
  })
})
import { LinkedList } from '../SinglyLinkedList'

describe('SinglyLinkedList', () => {
  it('Check addLast', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    expect(list.addLast(1)).toEqual(1)
    expect(list.get()).toEqual([1])

    expect(list.addLast(5)).toEqual(2)
    expect(list.get()).toEqual([1, 5])
  })

  it('Check addFirst', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    expect(list.addFirst(1)).toEqual(1)
    expect(list.get()).toEqual([1])

    expect(list.addFirst(5)).toEqual(2)
    expect(list.get()).toEqual([5, 1])
  })

  it('Check addAt', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    expect(list.addAt(0, 10)).toEqual(1)
    expect(list.get()).toEqual([10])

    expect(list.addAt(1, 20)).toEqual(2)
    expect(list.get()).toEqual([10, 20])

    expect(list.addAt(1, 30)).toEqual(3)
    expect(list.get()).toEqual([10, 30, 20])

    expect(list.addAt(3, 40)).toEqual(4)
    expect(list.get()).toEqual([10, 30, 20, 40])
  })

  it('Check removeLast', () => {
    const list = new LinkedList()
    list.addLast(1)
    list.addLast(2)
    expect(list.get()).toEqual([1, 2])

    expect(list.removeLast()).toEqual(2)
    expect(list.get()).toEqual([1])

    expect(list.removeLast()).toEqual(1)
    expect(list.get()).toEqual([])
  })

  it('Check removeFirst', () => {
    const list = new LinkedList()
    list.addLast(1)
    list.addLast(2)
    expect(list.get()).toEqual([1, 2])

    expect(list.removeFirst()).toEqual(1)
    expect(list.get()).toEqual([2])

    expect(list.removeFirst()).toEqual(2)
    expect(list.get()).toEqual([])
  })

  it('Check removeAt', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.get()).toEqual([10, 20, 30, 40, 50])

    expect(list.removeAt(0)).toEqual(10)
    expect(list.get()).toEqual([20, 30, 40, 50])

    expect(list.removeAt(3)).toEqual(50)
    expect(list.get()).toEqual([20, 30, 40])

    expect(list.removeAt(1)).toEqual(30)
    expect(list.get()).toEqual([20, 40])
  })

  it('Check remove', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    expect(list.get()).toEqual([10, 20, 30])

    expect(list.remove(10)).toEqual(10)
    expect(list.get()).toEqual([20, 30])

    expect(list.remove(100)).toEqual(null)
    expect(list.get()).toEqual([20, 30])
  })

  it('Check indexOf', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.indexOf(10)).toBe(0)
    expect(list.indexOf(30)).toBe(2)
    expect(list.indexOf(50)).toBe(4)
    expect(list.indexOf(70)).toBe(-1)
  })

  it('Check elementAt', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.elementAt(0)).toBe(10)
    expect(list.elementAt(1)).toBe(20)
    expect(list.elementAt(3)).toBe(40)
    expect(list.elementAt(4)).toBe(50)
  })

  it('Check isEmpty', () => {
    const list = new LinkedList()
    expect(list.isEmpty()).toBe(true)
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.isEmpty()).toBe(false)
  })

  it('Check head', () => {
    const list = new LinkedList()
    expect(list.head()).toBe(null)

    list.addLast(10)
    expect(list.head()).toBe(10)

    list.addLast(20)
    expect(list.head()).toBe(10)

    list.addFirst(30)
    expect(list.head()).toBe(30)
  })

  it('Check size', () => {
    const list = new LinkedList()
    expect(list.size()).toBe(0)

    list.addLast(10)
    expect(list.size()).toBe(1)

    list.addLast(20)
    expect(list.size()).toBe(2)

    list.removeFirst()
    expect(list.size()).toBe(1)
  })

  it('Check Iterator', () => {
    const list = new LinkedList()

    let iterate = list.iterator()
    expect(iterate).toBe(-1)

    const arr = [10, 20, 5]
    list.addLast(arr[0])
    list.addLast(arr[1])
    list.addLast(arr[2])
    iterate = list.iterator()

    for (let i = 0; i < arr.length; i++) {
      expect(iterate.next().value).toBe(arr[i])
    }
    expect(iterate.next().value).toBe(undefined)

    iterate = list.iterator()
    let count = 0
    for (const item of iterate) {
      expect(item).toBe(arr[count])
      count++
    }
  })
  it('Cleans the linkedList', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.size()).toEqual(5)
    list.clean()
    expect(list.isEmpty()).toBe(true)
  })
})
// Methods - size, head, isEmpty, getElementAt, addAtFirst, add, clean, insertAt, remove, removeData, printData, get, clear
import { Node } from './SinglyLinkedList.js'

class SinglyCircularLinkedList {
  constructor () {
    this.headNode = null
    this.length = 0
  }

  // Get size of the linkedList
  size = () => this.length
  // Get the headNode data
  head = () => this.headNode?.data || null
  // Check if the linkedList is empty
  isEmpty = () => this.length === 0

  // initiate the node and index
  initiateNodeAndIndex () {
    return { currentNode: this.headNode, currentIndex: 0 }
  }

  // get the data specific to an index
  getElementAt (index) {
    if (this.length !== 0 && index >= 0 && index <= this.length) {
      let { currentNode } = this.initiateNodeAndIndex()
      for (let i = 0; i < index && currentNode !== null; i++) {
        currentNode = currentNode.next
      }
      return currentNode
    }
    return undefined
  }

  // Add the element in the first position
  addAtFirst (data) {
    const node = new Node(data)
    node.next = this.headNode
    this.headNode = node
    this.length++
    return this.length
  }

  // Add any data to the end of the linkedList
  add (data) {
    if (!this.headNode) { return this.addAtFirst(data) }
    const node = new Node(data)
    // Getting the last node
    const currentNode = this.getElementAt(this.length - 1)
    currentNode.next = node
    node.next = this.headNode
    this.length++
    return this.length
  }

  // insert data at a specific position
  insertAt (index, data) {
    if (index === 0) return this.addAtFirst(data)
    if (index === this.length) return this.add(data)
    if (index < 0 || index > this.length) throw new RangeError(`Index is out of range max ${this.length}`)
    const node = new Node(data)
    const previousNode = this.getElementAt(index - 1)
    node.next = previousNode.next
    previousNode.next = node
    this.length++
    return this.length
  }

  // find the first index of the data
  indexOf (data) {
    let { currentNode } = this.initiateNodeAndIndex()
    // initializing currentIndex as -1
    let currentIndex = -1
    while (currentNode) {
      if (currentNode.data === data) {
        return currentIndex + 1
      }
      currentIndex++
      currentNode = currentNode.next
    }
    return -1
  }

  // remove the data from the end of the list
  remove () {
    if (this.isEmpty()) return null
    const secondLastNode = this.getElementAt(this.length - 2)
    const removedNode = secondLastNode.next
    secondLastNode.next = this.headNode
    this.length--
    return removedNode.data || null
  }

  // remove the data from the first of the list
  removeFirst () {
    if (this.isEmpty()) return null
    const removedNode = this.headNode
    if (this.length === 1) {
      this.clear()
      return removedNode.data
    }
    const lastNode = this.getElementAt(this.length - 1)
    this.headNode = this.headNode.next
    lastNode.next = this.headNode
    this.length--
    return removedNode.data || null
  }

  // remove the data from the index
  removeAt (index) {
    if (this.isEmpty()) return null
    if (index === 0) return this.removeFirst()
    if (index === this.length) return this.remove()
    if (index < 0 && index > this.length) return null
    const previousNode = this.getElementAt(index - 1)
    const currentNode = previousNode.next
    previousNode.next = currentNode.next
    this.length--
    return currentNode.data || null
  }

  // remove if the data is present
  removeData (data) {
    if (this.isEmpty()) return null
    const index = this.indexOf(data)
    return this.removeAt(index)
  }

  // logs the data
  printData (output = value => console.log(value)) {
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()

    while (currentNode !== null && currentIndex < this.length) {
      output(currentNode.data)
      currentNode = currentNode.next
      currentIndex++
    }
  }

  // get the data from the linkedList
  get () {
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    const list = []
    while (currentNode !== null && currentIndex < this.length) {
      list.push(currentNode.data)
      currentNode = currentNode.next
      currentIndex++
    }
    return list
  }

  clear () {
    this.headNode = null
    this.length = 0
  }
}

export { SinglyCircularLinkedList }
/**
 * A LinkedList based solution for Add Two Numbers
 *
 */
import { Node } from './SinglyLinkedList.js'

/*
Problem Statement:
Given two non-empty linked lists representing two non-negative integers.
The digits are stored in reverse order and each of their nodes contain a single digit.
Add the two numbers and return it as a linked list.

Link for the Problem: https://leetcode.com/problems/add-two-numbers/
*/

class AddTwoNumbers {
  constructor () {
    this.dummyNode = new Node(0)
  }

  solution (firstList, secondList) {
    let firstRunner = firstList
    let secondRunner = secondList
    let tail = this.dummyNode
    let carry = 0
    while (firstRunner != null || secondRunner != null) {
      const firstNumber = firstRunner ? firstRunner.data : 0
      const secondNumber = secondRunner ? secondRunner.data : 0
      const sum = carry + firstNumber + secondNumber
      carry = parseInt(sum / 10)
      tail.next = new Node(sum % 10)
      tail = tail.next
      if (firstRunner) {
        firstRunner = firstRunner.next
      }
      if (secondRunner) {
        secondRunner = secondRunner.next
      }
    }
    if (carry > 0) {
      tail.next = new Node(carry % 10)
    }

    return this.dummyNode.next
  }

  solutionToArray () {
    const list = []
    let currentNode = this.dummyNode.next
    while (currentNode) {
      list.push(currentNode.data)
      currentNode = currentNode.next
    }

    return list
  }
}

export { AddTwoNumbers }
/**
 * A LinkedList based solution for Detect a Cycle in a list
 * https://en.wikipedia.org/wiki/Cycle_detection
 */

function main () {
  /*
  Problem Statement:
  Given head, the head of a linked list, determine if the linked list has a cycle in it.

  Note:
  * While Solving the problem in given link below, don't use main() function.
  * Just use only the code inside main() function.
  * The purpose of using main() function here is to avoid global variables.

  Link for the Problem: https://leetcode.com/problems/linked-list-cycle/
  */
  const head = '' // Reference to head is given in the problem. So please ignore this line
  let fast = head
  let slow = head

  while (fast != null && fast.next != null && slow != null) {
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) {
      return true
    }
  }
  return false
}

main()
class Node {
  constructor (element) {
    this.element = element
    this.next = null
    this.prev = null
  }
}

class DoubleLinkedList {
  constructor () {
    this.length = 0
    this.head = null
    this.tail = null
  }

  // Add new element
  append (element) {
    const node = new Node(element)

    if (!this.head) {
      this.head = node
      this.tail = node
    } else {
      node.prev = this.tail
      this.tail.next = node
      this.tail = node
    }

    this.length++
  }

  // Add element
  insert (position, element) {
    // Check of out-of-bound values
    if (position >= 0 && position <= this.length) {
      const node = new Node(element)
      let current = this.head
      let previous = 0
      let index = 0

      if (position === 0) {
        if (!this.head) {
          this.head = node
          this.tail = node
        } else {
          node.next = current
          current.prev = node
          this.head = node
        }
      } else if (position === this.length) {
        current = this.tail
        current.next = node
        node.prev = current
        this.tail = node
      } else {
        while (index++ < position) {
          previous = current
          current = current.next
        }

        node.next = current
        previous.next = node

        // New
        current.prev = node
        node.prev = previous
      }

      this.length++
      return true
    } else {
      return false
    }
  }

  // Remove element at any position
  removeAt (position) {
    // look for out-of-bounds value
    if (position > -1 && position < this.length) {
      let current = this.head
      let previous = 0
      let index = 0

      // Removing first item
      if (position === 0) {
        this.head = current.next

        // if there is only one item, update this.tail //NEW
        if (this.length === 1) {
          this.tail = null
        } else {
          this.head.prev = null
        }
      } else if (position === this.length - 1) {
        current = this.tail
        this.tail = current.prev
        this.tail.next = null
      } else {
        while (index++ < position) {
          previous = current
          current = current.next
        }

        // link previous with current's next - skip it
        previous.next = current.next
        current.next.prev = previous
      }

      this.length--
      return current.element
    } else {
      return null
    }
  }

  // Get the indexOf item
  indexOf (elm) {
    let current = this.head
    let index = -1

    // If element found then return its position
    while (current) {
      if (elm === current.element) {
        return ++index
      }

      index++
      current = current.next
    }

    // Else return -1
    return -1
  }

  // Find the item in the list
  isPresent (elm) {
    return this.indexOf(elm) !== -1
  }

  // Delete an item from the list
  delete (elm) {
    return this.removeAt(this.indexOf(elm))
  }

  // Delete first item from the list
  deleteHead () {
    this.removeAt(0)
  }

  // Delete last item from the list
  deleteTail () {
    this.removeAt(this.length - 1)
  }

  // Print item of the string
  toString () {
    let current = this.head
    let string = ''

    while (current) {
      string += current.element + (current.next ? '\n' : '')
      current = current.next
    }

    return string
  }

  // Convert list to array
  toArray () {
    const arr = []
    let current = this.head

    while (current) {
      arr.push(current.element)
      current = current.next
    }

    return arr
  }

  // Check if list is empty
  isEmpty () {
    return this.length === 0
  }

  // Get the size of the list
  size () {
    return this.length
  }

  // Get the this.head
  getHead () {
    return this.head
  }

  // Get the this.tail
  getTail () {
    return this.tail
  }

  // Method to iterate over the LinkedList
  iterator () {
    let currentNode = this.getHead()
    if (currentNode === null) return -1

    const iterate = function * () {
      while (currentNode) {
        yield currentNode.element
        currentNode = currentNode.next
      }
    }
    return iterate()
  }

  // Method to log the LinkedList, for debugging
  // it' a circular structure, so can't use stringify to debug the whole structure
  log () {
    let currentNode = this.getHead()
    while (currentNode) {
      console.log(currentNode.element)
      currentNode = currentNode.next
    }
  }
}

// Example

// const newDoubleLinkedList = new DoubleLinkedList()
// newDoubleLinkedList.append(1)
// newDoubleLinkedList.append(2)
// newDoubleLinkedList.size() // returns 2
// const iterate = newDoubleLinkedList.iterator()
// console.log(iterate.next().value) // 1
// console.log(iterate.next().value) // 2
// console.log(newDoubleLinkedList.log())

export { DoubleLinkedList }
/**
 * A LinkedList based solution for Rotating a List to the right by k places
 */

function main () {
  /*
  Problem Statement:
  Given a linked list, rotate the list to the right by k places, where k is non-negative.

  Note:
  * While Solving the problem in given link below, don't use main() function.
  * Just use only the code inside main() function.
  * The purpose of using main() function here is to avoid global variables.

  Link for the Problem: https://leetcode.com/problems/rotate-list/
  */
  // Reference to both head and k is given in the problem. So please ignore below two lines
  let head = ''
  let k = ''
  let i = 0
  let current = head
  while (current) {
    i++
    current = current.next
  }
  k %= i
  current = head
  let prev = null
  while (k--) {
    if (!current || !current.next) {
      return current
    } else {
      while (current.next) {
        prev = current
        current = current.next
      }
      prev.next = current.next
      current.next = head
      head = current
    }
  }
  return head
}

main()
/* SinglyLinkedList!!
* A linked list is similar to an array, it holds a list of values.
* However, links in a linked list do not have indexes. With
* a linked list you do not need to predetermine its size as
* it grows and shrinks as it is edited. This is an example of
* a singly linked list.
*/

// Methods - size, head, addLast, addFirst, addAt, removeFirst, removeLast, remove, removeAt, indexOf, isEmpty,  elementAt, get, clean

class Node {
  constructor (data) {
    this.data = data
    this.next = null
  }
}

class LinkedList {
  constructor () {
    this.headNode = null
    this.length = 0
  }

  // initiates the currentNode and currentIndex and return as an object
  initiateNodeAndIndex () {
    return { currentNode: this.headNode, currentIndex: 0 }
  }

  // Returns length
  size () {
    return this.length
  }

  // Returns the head
  head () {
    return this.headNode?.data || null
  }

  // Return if the list is empty
  isEmpty () {
    return this.length === 0
  }

  // add a node at last it to linklist
  addLast (element) {
    // Check if its the first element
    if (this.headNode === null) {
      return this.addFirst(element)
    }
    let { currentNode } = this.initiateNodeAndIndex()

    // Loop till there is a node present in the list
    while (currentNode.next) {
      currentNode = currentNode.next
    }

    const node = new Node(element)
    // Adding node at the end of the list and increase the length
    currentNode.next = node
    this.length++
    return this.size()
  }

  // add a node at first it to linklist
  addFirst (element) {
    const node = new Node(element)
    node.next = this.headNode
    this.headNode = node
    this.length++
    return this.size()
  }

  // remove the first from the linklist
  removeFirst () {
    const removedNode = this.headNode
    if (this.length > 0) {
      this.headNode = this.headNode.next
      this.length--
    }
    console.log(removedNode.data)
    return removedNode?.data
  }

  // remove the last from the linklist
  removeLast () {
    if (this.isEmpty()) return null
    if (this.length === 1) {
      return this.removeFirst()
    }
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    while (currentIndex !== this.length - 2) {
      currentIndex++
      currentNode = currentNode.next
    }
    const removedNode = currentNode.next
    currentNode.next = null
    this.length--
    return removedNode.data
  }

  // Removes the node with the value as param
  remove (element) {
    if (this.isEmpty()) return null
    let { currentNode } = this.initiateNodeAndIndex()
    let removedNode = null
    // Check if the head node is the element to remove
    if (currentNode.data === element) {
      return this.removeFirst()
    }
    // Check which node is the node to remove
    while (currentNode?.next) {
      if (currentNode.next.data === element) {
        removedNode = currentNode.next
        currentNode.next = currentNode.next.next
        this.length--
        break
      }
      currentNode = currentNode.next
    }
    return removedNode?.data || null
  }

  // Returns the index of the element passed as param otherwise -1
  indexOf (element) {
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()

    while (currentNode) {
      // Checking if the node is the element we are searching for
      if (currentNode.data === element) {
        return currentIndex
      }
      currentNode = currentNode.next
      currentIndex++
    }
    return -1
  }

  // Returns the element at an index
  elementAt (index) {
    if (index >= this.length || index < 0) {
      throw new RangeError('Out of Range index')
    }
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    while (currentIndex < index) {
      currentIndex++
      currentNode = currentNode.next
    }
    return currentNode.data
  }

  // Adds the element at specified index
  addAt (index, element) {
    // Check if index is out of bounds of list
    if (index > this.length || index < 0) {
      throw new RangeError('Out of Range index')
    }
    if (index === 0) return this.addFirst(element)
    if (index === this.length) return this.addLast(element)
    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    const node = new Node(element)

    while (currentIndex !== index - 1) {
      currentIndex++
      currentNode = currentNode.next
    }

    // Adding the node at specified index
    const tempNode = currentNode.next
    currentNode.next = node
    node.next = tempNode
    // Incrementing the length
    this.length++
    return this.size()
  }

  // Removes the node at specified index
  removeAt (index) {
    // Check if index is present in list
    if (index < 0 || index >= this.length) {
      throw new RangeError('Out of Range index')
    }
    if (index === 0) return this.removeFirst()
    if (index === this.length) return this.removeLast()

    let { currentIndex, currentNode } = this.initiateNodeAndIndex()
    while (currentIndex !== index - 1) {
      currentIndex++
      currentNode = currentNode.next
    }
    const removedNode = currentNode.next
    currentNode.next = currentNode.next.next
    // Decrementing the length
    this.length--
    return removedNode.data
  }

  // make the linkedList Empty
  clean () {
    this.headNode = null
    this.length = 0
  }

  // Method to get the LinkedList
  get () {
    const list = []
    let { currentNode } = this.initiateNodeAndIndex()
    while (currentNode) {
      list.push(currentNode.data)
      currentNode = currentNode.next
    }

    return list
  }

  // Method to iterate over the LinkedList
  iterator () {
    let { currentNode } = this.initiateNodeAndIndex()
    if (currentNode === null) return -1

    const iterate = function * () {
      while (currentNode) {
        yield currentNode.data
        currentNode = currentNode.next
      }
    }
    return iterate()
  }

  // Method to log the LinkedList
  log () {
    console.log(JSON.stringify(this.headNode, null, 2))
  }
}

export { Node, LinkedList }
import { QuickSelect } from '../QuickSelect'

describe('QuickSelect tests', () => {
  it('should return the only element of a list of length 1', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    expect(QuickSelect([100], 1)).toEqual(100)
    expect(QuickSelect([-23], 1)).toEqual(-23)
    expect(QuickSelect([2007.102], 1)).toEqual(2007.102)
    expect(QuickSelect([0.9], 1)).toEqual(0.9)
    expect(QuickSelect([-0.075], 1)).toEqual(-0.075)
    expect(QuickSelect([0], 1)).toEqual(0)
    expect(QuickSelect([1], 1)).toEqual(1)
  })

  it('should throw an Error when k is greater than the length of the list', () => {
    expect(() => QuickSelect([100, 2], 5)).toThrow('Index Out of Bound')
  })

  it('should throw an Error when k is less than 1', () => {
    expect(() => QuickSelect([100, 2], 0)).toThrow('Index Out of Bound')
    expect(() => QuickSelect([100, 2], -1)).toThrow('Index Out of Bound')
  })

  describe('varieties of list composition', () => {
    it('should return the kth smallest element of a list that is in increasing order', () => {
      expect(QuickSelect([10, 22, 33, 44, 55], 1)).toEqual(10)
      expect(QuickSelect([10, 22, 33, 44, 55], 2)).toEqual(22)
      expect(QuickSelect([10, 22, 33, 44, 55], 3)).toEqual(33)
      expect(QuickSelect([10, 22, 33, 44, 55], 4)).toEqual(44)
      expect(QuickSelect([10, 22, 33, 44, 55], 5)).toEqual(55)
    })

    it('should return the kth smallest element of an input list that is in decreasing order', () => {
      expect(QuickSelect([82, 33.12, 4.0, 1], 1)).toEqual(1)
      expect(QuickSelect([82, 33.12, 4.0, 1], 2)).toEqual(4.0)
      expect(QuickSelect([82, 33.12, 4.0, 1], 2)).toEqual(4)
      expect(QuickSelect([82, 33.12, 4.0, 1], 3)).toEqual(33.12)
      expect(QuickSelect([82, 33.12, 4.0, 1], 4)).toEqual(82)
    })

    it('should return the kth smallest element of an input list that is no particular order', () => {
      expect(QuickSelect([123, 14231, -10, 0, 15], 3)).toEqual(15)
      expect(QuickSelect([0, 15, 123, 14231, -10], 3)).toEqual(15)
      expect(QuickSelect([-10, 15, 123, 14231, 0], 3)).toEqual(15)
      expect(QuickSelect([14231, 0, 15, 123, -10], 3)).toEqual(15)
      expect(QuickSelect([14231, 0, 15, -10, 123], 3)).toEqual(15)
    })
  })
})
import { LocalMaximomPoint } from '../LocalMaximomPoint'

describe('LocalMaximumPoint tests', () => {
  it('test boundary maximum points - last element', () => {
    const Array = [1, 2, 3, 4, 5, 6, 12]
    expect(LocalMaximomPoint(Array)).toEqual(6)
  })

  it('test boundary maximum points - first element', () => {
    const Array2 = [13, 6, 5, 4, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(0)
  })

  it('test boundary maximum points - should find first maximom point from the top', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [13, 2, 3, 4, 5, 6, 12]
    expect(LocalMaximomPoint(Array)).toEqual(6)
  })

  it('test inner points - second element', () => {
    const Array2 = [13, 16, 5, 4, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(1)
  })

  it('test inner points - element some where in the middle', () => {
    const Array2 = [13, 16, 5, 41, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(3)
  })
})
import { NumberOfLocalMaximumPoints } from '../NumberOfLocalMaximumPoints'

describe('LocalMaximomPoint tests', () => {
  it('test boundary maximum points - last element', () => {
    const Array = [1, 2, 3, 4, 5, 6, 12]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(1)
  })

  it('test boundary maximum points - first element', () => {
    const Array = [13, 6, 5, 4, 3, 2, 1]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(1)
  })

  it('test boundary maximum points - both boundaries have maximum points', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [13, 2, 3, 4, 5, 6, 12]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(2)
  })

  it('multiple maximum points in the middle', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [1, 3, 2, 5, 6, 9, 2, 7, 12, 1, 0]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(3)
  })

  it('multiple maximum points in the middle with one at end', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [1, 3, 2, 5, 6, 9, 2, 7, 12, 1, 10]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(4)
  })

  it('multiple maximum points in the middle with one at start', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [10, 3, 2, 5, 6, 9, 2, 7, 12, 1, 0]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(3)
  })

  it('multiple maximum points in the middle with two more at both ends', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [10, 3, 11, 5, 6, 9, 2, 7, 12, 1, 10]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(5)
  })
})
/**
 * [LocalMaxima](https://www.geeksforgeeks.org/find-indices-of-all-local-maxima-and-local-minima-in-an-array/) is an algorithm to find relative bigger numbers compared to their neighbors
 *
 * Notes:
 * - works by using divide and conquer
 * - the function gets the array A with n Real numbersand returns the local max point index (if more than one exists return the first one)
 *
 * @complexity: O(log(n)) (on average )
 * @complexity: O(log(n)) (worst case)
 * @flow
 */
const findMaxPointIndex = (array, rangeStartIndex, rangeEndIndex, originalLength) => {
  // find index range middle point
  const middleIndex = rangeStartIndex + parseInt((rangeEndIndex - rangeStartIndex) / 2)

  // handle array bounds
  if ((middleIndex === 0 || array[middleIndex - 1] <= array[middleIndex]) &&
        (middleIndex === originalLength - 1 || array[middleIndex + 1] <= array[middleIndex])) {
    return middleIndex
  } else if (middleIndex > 0 && array[middleIndex - 1] > array[middleIndex]) {
    return findMaxPointIndex(array, rangeStartIndex, (middleIndex - 1), originalLength)
  } else {
    // regular local max
    return findMaxPointIndex(array, (middleIndex + 1), rangeEndIndex, originalLength)
  }
}

const LocalMaximomPoint = (A) => findMaxPointIndex(A, 0, A.length - 1, A.length)

export { LocalMaximomPoint }
/**
 * [NumberOfLocalMaximumPoints](https://www.geeksforgeeks.org/find-indices-of-all-local-maxima-and-local-minima-in-an-array/) is an algorithm to find relative bigger numbers compared to their neighbors
 *
 * Notes:
 * - like the other similar local maxima search function find relative maxima points in array but doesn't stop at one but returns total point count
 * - runs on array A of size n and returns the local maxima count using divide and conquer methodology
 *
 * @complexity: O(n) (on average )
 * @complexity: O(n) (worst case)
 * @flow
 */

// check if returned index is a local maxima
const IsMaximumPoint = (array, index) => {
  // handle array bounds
  // array start
  if (index === 0) {
    return array[index] > array[index + 1]
    // array end
  } else if (index === array.length - 1) {
    return array[index] > array[index - 1]
    // handle index inside array bounds
  } else {
    return array[index] > array[index + 1] && array[index] > array[index - 1]
  }
}

const CountLocalMaximumPoints = (array, startIndex, endIndex) => {
  // stop check in divide and conquer recursion
  if (startIndex === endIndex) {
    return IsMaximumPoint(array, startIndex) ? 1 : 0
  }

  // handle the two halves
  const middleIndex = parseInt((startIndex + endIndex) / 2)
  return CountLocalMaximumPoints(array, startIndex, middleIndex) +
    CountLocalMaximumPoints(array, middleIndex + 1, endIndex)
}

const NumberOfLocalMaximumPoints = (A) => CountLocalMaximumPoints(A, 0, A.length - 1)

export { NumberOfLocalMaximumPoints }
/**
 * [QuickSelect](https://www.geeksforgeeks.org/quickselect-algorithm/) is an algorithm to find the kth smallest number
 *
 * Notes:
 * -QuickSelect is related to QuickSort, thus has optimal best and average
 * -case (O(n)) but unlikely poor worst case (O(n^2))
 * -This implementation uses randomly selected pivots for better performance
 *
 * @complexity: O(n) (on average )
 * @complexity: O(n^2) (worst case)
 * @flow
 */

function QuickSelect (items, kth) { // eslint-disable-line no-unused-vars
  if (kth < 1 || kth > items.length) {
    throw new RangeError('Index Out of Bound')
  }

  return RandomizedSelect(items, 0, items.length - 1, kth)
}

function RandomizedSelect (items, left, right, i) {
  if (left === right) return items[left]

  const pivotIndex = RandomizedPartition(items, left, right)
  const k = pivotIndex - left + 1

  if (i === k) return items[pivotIndex]
  if (i < k) return RandomizedSelect(items, left, pivotIndex - 1, i)

  return RandomizedSelect(items, pivotIndex + 1, right, i - k)
}

function RandomizedPartition (items, left, right) {
  const rand = getRandomInt(left, right)
  Swap(items, rand, right)
  return Partition(items, left, right)
}

function Partition (items, left, right) {
  const x = items[right]
  let pivotIndex = left - 1

  for (let j = left; j < right; j++) {
    if (items[j] <= x) {
      pivotIndex++
      Swap(items, pivotIndex, j)
    }
  }

  Swap(items, pivotIndex + 1, right)

  return pivotIndex + 1
}

function getRandomInt (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

function Swap (arr, x, y) {
  [arr[x], arr[y]] = [arr[y], arr[x]]
}

export { QuickSelect }
class Graph {
  constructor () {
    this.adjacencyMap = {}
  }

  addVertex (vertex) {
    this.adjacencyMap[vertex] = []
  }

  containsVertex (vertex) {
    return typeof (this.adjacencyMap[vertex]) !== 'undefined'
  }

  addEdge (vertex1, vertex2) {
    if (this.containsVertex(vertex1) && this.containsVertex(vertex2)) {
      this.adjacencyMap[vertex1].push(vertex2)
      this.adjacencyMap[vertex2].push(vertex1)
    }
  }

  printGraph (output = value => console.log(value)) {
    const keys = Object.keys(this.adjacencyMap)
    for (const i of keys) {
      const values = this.adjacencyMap[i]
      let vertex = ''
      for (const j of values) {
        vertex += j + ' '
      }
      output(i + ' -> ' + vertex)
    }
  }

  /**
   * Prints the Breadth first traversal of the graph from source.
   * @param {number} source The source vertex to start BFS.
   */
  bfs (source, output = value => console.log(value)) {
    const queue = [[source, 0]] // level of source is 0
    const visited = new Set()

    while (queue.length) {
      const [node, level] = queue.shift() // remove the front of the queue
      if (visited.has(node)) { // visited
        continue
      }

      visited.add(node)
      output(`Visited node ${node} at level ${level}.`)
      for (const next of this.adjacencyMap[node]) {
        queue.push([next, level + 1]) // level 1 more than current
      }
    }
  }

  /**
   * Prints the Depth first traversal of the graph from source.
   * @param {number} source The source vertex to start DFS.
   */
  dfs (source, visited = new Set(), output = value => console.log(value)) {
    if (visited.has(source)) { // visited
      return
    }

    output(`Visited node ${source}`)
    visited.add(source)
    for (const neighbour of this.adjacencyMap[source]) {
      this.dfs(neighbour, visited, output)
    }
  }
}

const example = () => {
  const g = new Graph()
  g.addVertex(1)
  g.addVertex(2)
  g.addVertex(3)
  g.addVertex(4)
  g.addVertex(5)
  g.addEdge(1, 2)
  g.addEdge(1, 3)
  g.addEdge(2, 4)
  g.addEdge(2, 5)

  // Graph
  // 1 -> 2 3
  // 2 -> 1 4 5
  // 3 -> 1
  // 4 -> 2
  // 5 -> 2

  // Printing the adjacency list
  // g.printGraph()

  // Breadth first search at node 1
  g.bfs(1)

  // Depth first search at node 1
  g.dfs(1)
}

export { Graph, example }
import { Graph } from '../Graph2'

describe('Test Graph2', () => {
  const vertices = ['A', 'B', 'C', 'D', 'E', 'F']
  const graph = new Graph(vertices.length)

  // adding vertices
  for (let i = 0; i < vertices.length; i++) {
    graph.addVertex(vertices[i])
  }

  // adding edges
  graph.addEdge('A', 'B')
  graph.addEdge('A', 'D')
  graph.addEdge('A', 'E')
  graph.addEdge('B', 'C')
  graph.addEdge('D', 'E')
  graph.addEdge('E', 'F')
  graph.addEdge('E', 'C')
  graph.addEdge('C', 'F')

  it('Check adjacency lists', () => {
    const mockFn = jest.fn()
    graph.printGraph(mockFn)

    // Expect one call per vertex
    expect(mockFn.mock.calls.length).toBe(vertices.length)

    // Collect adjacency lists from output (call args)
    const adjListArr = mockFn.mock.calls.map(v => v[0])

    expect(adjListArr).toEqual([
      'A -> B D E ',
      'B -> A C ',
      'C -> B E F ',
      'D -> A E ',
      'E -> A D F C ',
      'F -> E C '
    ])
  })
})
import { Graph } from '../Graph3'

describe('Test Graph3', () => {
  const g = new Graph()

  // Add Vertices
  g.addVertex('A')
  g.addVertex('B')
  g.addVertex('C')
  g.addVertex('D')
  g.addVertex('E')
  g.addVertex('F')

  // Add Edges
  g.addEdge('A', 'B')
  g.addEdge('A', 'C')
  g.addEdge('B', 'D')
  g.addEdge('C', 'E')
  g.addEdge('D', 'E')
  g.addEdge('D', 'F')
  g.addEdge('E', 'F')

  /**
   * A - B - D
   * |      / \
   * C - - E - F
   *
   * DFS(Iterative): A-C-E-F-D-B
   * DFS(Recursive): A-B-D-E-C-F
   * BFS: A-B-C-D-E-F
   */
  it('Check iterative DFS List', () => {
    const iterativeDFSList = g.DFSIterative('A')
    expect(iterativeDFSList).toEqual(['A', 'C', 'E', 'F', 'D', 'B'])
  })

  it('Check recursive DFS List', () => {
    const recursiveDFSList = g.DFS('A')
    expect(recursiveDFSList).toEqual(['A', 'B', 'D', 'E', 'C', 'F'])
  })

  it('Check BFS List', () => {
    const BFSList = g.BFS('A')
    expect(BFSList).toEqual(['A', 'B', 'C', 'D', 'E', 'F'])
  })

  /**
   * Test After Remove 'B' Vertex
   * A       D
   * |      / \
   * C - - E - F
   *
   * DFS(Iterative): A-C-E-F-D
   * DFS(Recursive): A-C-E-D-F
   * BFS: A-C-E-D-F
   */

  it('Check iterative DFS List After Removing Vertex B', () => {
    g.removeVertex('B')
    const iterativeDFSList = g.DFSIterative('A')
    expect(iterativeDFSList).toEqual(['A', 'C', 'E', 'F', 'D'])
  })

  it('Check recursive DFS List After Removing Vertex B', () => {
    g.removeVertex('B')
    const recursiveDFSList = g.DFS('A')
    expect(recursiveDFSList).toEqual(['A', 'C', 'E', 'D', 'F'])
  })

  it('Check BFS List After Removing Vertex B', () => {
    g.removeVertex('B')
    const BFSList = g.BFS('A')
    expect(BFSList).toEqual(['A', 'C', 'E', 'D', 'F'])
  })
})
// create a graph class
class Graph {
  // defining vertex array and
  // adjacent list
  constructor (noOfVertices) {
    this.noOfVertices = noOfVertices
    this.AdjList = new Map()
  }

  // functions to be implemented

  // addVertex(v)
  // addEdge(v, w)
  // printGraph()

  // bfs(v)
  // dfs(v)

  // add vertex to the graph
  addVertex (v) {
    // initialize the adjacent list with a
    // null array

    this.AdjList.set(v, [])
  }

  // add edge to the graph
  addEdge (v, w) {
    // get the list for vertex v and put the
    // vertex w denoting edge between v and w
    this.AdjList.get(v).push(w)

    // Since graph is undirected,
    // add an edge from w to v also
    this.AdjList.get(w).push(v)
  }

  // Prints the vertex and adjacency list
  printGraph (output = value => console.log(value)) {
    // get all the vertices
    const getKeys = this.AdjList.keys()

    // iterate over the vertices
    for (const i of getKeys) {
      // great the corresponding adjacency list
      // for the vertex
      const getValues = this.AdjList.get(i)
      let conc = ''

      // iterate over the adjacency list
      // concatenate the values into a string
      for (const j of getValues) {
        conc += j + ' '
      }

      // print the vertex and its adjacency list
      output(i + ' -> ' + conc)
    }
  }
}

export { Graph }
class Graph {
  constructor () {
    this.adjacencyObject = {}
  }

  addVertex (vertex) {
    if (!this.adjacencyObject[vertex]) this.adjacencyObject[vertex] = []
  }

  addEdge (vertex1, vertex2) {
    this.adjacencyObject[vertex1].push(vertex2)
    this.adjacencyObject[vertex2].push(vertex1)
  }

  removeEdge (vertex1, vertex2) {
    this.adjacencyObject[vertex1] = this.adjacencyObject[vertex1].filter(
      (v) => v !== vertex2
    )
    this.adjacencyObject[vertex2] = this.adjacencyObject[vertex2].filter(
      (v) => v !== vertex1
    )
  }

  removeVertex (vertex) {
    while (this.adjacencyObject[vertex].length) {
      const adjacentVertex = this.adjacencyObject[vertex].pop()
      this.removeEdge(vertex, adjacentVertex)
    }
  }

  /**
   * Return DFS (Depth First Search) List Using Recursive Method
   */
  DFS (start) {
    if (!start) return null

    const result = []
    const visited = {}
    const adjacencyObject = this.adjacencyObject

    function dfs (vertex) {
      if (!vertex) return null
      visited[vertex] = true
      result.push(vertex)
      adjacencyObject[vertex].forEach((neighbor) => {
        if (!visited[neighbor]) {
          dfs(neighbor)
        }
      })
    }

    dfs(start)
    return result
  }

  /**
   * Return DFS(Depth First Search) List Using Iteration
   */
  DFSIterative (start) {
    if (!start) return null

    const stack = [start]
    const visited = {}
    visited[start] = true

    const result = []
    let currentVertex

    while (stack.length) {
      currentVertex = stack.pop()
      result.push(currentVertex)

      this.adjacencyObject[currentVertex].forEach((neighbor) => {
        if (!visited[neighbor]) {
          visited[neighbor] = true
          stack.push(neighbor)
        }
      })
    }
    return result
  }

  BFS (start) {
    if (!start) return null

    const queue = [start]
    const visited = {}
    visited[start] = true

    let currentVertex
    const result = []

    while (queue.length) {
      currentVertex = queue.shift()
      result.push(currentVertex)

      this.adjacencyObject[currentVertex].forEach((neighbor) => {
        if (!visited[neighbor]) {
          visited[neighbor] = true
          queue.push(neighbor)
        }
      })
    }
    return result
  }
}

export { Graph }
/**
 * In mathematics and physics, a vector is an element of a vector space.
 *
 * The Vector2-class implements 2-dimensional vectors together with various vector-operations.
 * @see https://en.wikipedia.org/wiki/Vector_(mathematics_and_physics).
 */

class Vector2 {
  constructor (x, y) {
    this.x = x
    this.y = y
  }

  /**
   * Check for exact vector equality.
   *
   * @param vector The vector to compare to.
   * @returns Whether they are exactly equal or not.
   */
  equalsExactly (vector) {
    return this.x === vector.x && this.y === vector.y
  }

  /**
   * Check for approximate vector equality.
   *
   * @param vector The vector to compare to.
   * @param epsilon The allowed discrepancy for the x-values and the y-values.
   * @returns Whether they are approximately equal or not.
   */
  equalsApproximately (vector, epsilon) {
    return (Math.abs(this.x - vector.x) < epsilon && Math.abs(this.y - vector.y) < epsilon)
  }

  /**
   * Vector length.
   *
   * @returns The length of the vector.
   */
  length () {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }

  /**
   * Normalization sets the vector to length 1 while maintaining its direction.
   *
   * @returns The normalized vector.
   */
  normalize () {
    const length = this.length()
    if (length === 0) {
      throw new Error('Cannot normalize vectors of length 0')
    }
    return new Vector2(this.x / length, this.y / length)
  }

  /**
   * Vector addition
   *
   * @param vector The vector to be added.
   * @returns The sum-vector.
   */
  add (vector) {
    const x = this.x + vector.x
    const y = this.y + vector.y
    return new Vector2(x, y)
  }

  /**
   * Vector subtraction
   *
   * @param vector The vector to be subtracted.
   * @returns The difference-vector.
   */
  subtract (vector) {
    const x = this.x - vector.x
    const y = this.y - vector.y
    return new Vector2(x, y)
  }

  /**
   * Vector scalar multiplication
   *
   * @param scalar The factor by which to multiply the vector.
   * @returns The scaled vector.
   */
  multiply (scalar) {
    const x = this.x * scalar
    const y = this.y * scalar
    return new Vector2(x, y)
  }

  /**
   * Distance between this vector and another vector.
   *
   * @param vector The vector to which to calculate the distance.
   * @returns The distance.
   */
  distance (vector) {
    const difference = vector.subtract(this)
    return difference.length()
  }

  /**
   * Vector dot product
   *
   * @param vector The vector used for the multiplication.
   * @returns The resulting dot product.
   */
  dotProduct (vector) {
    return this.x * vector.x + this.y * vector.y
  }

  /**
   * Vector rotation (see https://en.wikipedia.org/wiki/Rotation_matrix)
   *
   * @param angleInRadians The angle in radians by which to rotate the vector.
   * @returns The rotated vector.
   */
  rotate (angleInRadians) {
    const ca = Math.cos(angleInRadians)
    const sa = Math.sin(angleInRadians)
    const x = ca * this.x - sa * this.y
    const y = sa * this.x + ca * this.y
    return new Vector2(x, y)
  }

  /**
   * Measure angle between two vectors
   *
   * @param vector The 2nd vector for the measurement.
   * @returns The angle in radians.
   */
  angleBetween (vector) {
    return Math.atan2(vector.y, vector.x) - Math.atan2(this.y, this.x)
  }
}

export { Vector2 }
import { Vector2 } from '../Vector2.js'

describe('Vector2', () => {
  describe('#equalsExactly', () => {
    it('should compare equality correctly', () => {
      expect(new Vector2(1, 0).equalsExactly(new Vector2(1, 0))).toBe(true)

      expect(new Vector2(1.23, 4.56).equalsExactly(new Vector2(0, 0))).toBe(false)
    })
  })

  describe('#equalsApproximately', () => {
    it('should compare equality (approximately) correctly', () => {
      expect(new Vector2(1, 0).equalsApproximately(new Vector2(1, 0.0000001), 0.000001))
        .toBe(true)

      expect(new Vector2(1.23, 4.56).equalsApproximately(new Vector2(1.24, 4.56), 0.000001))
        .toBe(false)
    })
  })

  describe('#add', () => {
    it('should add two vectors correctly', () => {
      expect(new Vector2(1, 0).add(new Vector2(0, 1)).equalsApproximately(new Vector2(1, 1), 0.000001))
        .toBe(true)

      expect(new Vector2(-3.3, -9).add(new Vector2(-2.2, 3)).equalsApproximately(new Vector2(-5.5, -6), 0.000001))
        .toBe(true)
    })
  })

  describe('#subtract', () => {
    it('should subtract two vectors correctly', () => {
      expect(new Vector2(1, 0).subtract(new Vector2(0, 1)).equalsApproximately(new Vector2(1, -1), 0.000001))
        .toBe(true)

      expect(new Vector2(234.5, 1.7).subtract(new Vector2(3.3, 2.7)).equalsApproximately(new Vector2(231.2, -1), 0.000001))
        .toBe(true)
    })
  })

  describe('#multiply', () => {
    it('should multiply two vectors correctly', () => {
      expect(new Vector2(1, 0).multiply(5).equalsApproximately(new Vector2(5, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(3.41, -7.12).multiply(-3.1).equalsApproximately(new Vector2(-10.571, 22.072), 0.000001))
        .toBe(true)
    })
  })

  describe('#length', () => {
    it('should calculate it\'s length correctly', () => {
      expect(new Vector2(1, 0).length()).toBe(1)

      expect(new Vector2(-1, 1).length()).toBe(Math.sqrt(2))
    })
  })

  describe('#normalize', () => {
    it('should normalize vectors correctly', () => {
      expect(new Vector2(1, 0).normalize().equalsApproximately(new Vector2(1, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(1, -1).normalize().equalsApproximately(new Vector2(Math.sqrt(2) / 2, -Math.sqrt(2) / 2), 0.000001))
        .toBe(true)
    })
  })

  describe('#distance', () => {
    it('should calculate the distance between two vectors correctly', () => {
      expect(new Vector2(0, 0).distance(new Vector2(0, -1))).toBe(1)

      expect(new Vector2(1, 0).distance(new Vector2(0, 1))).toBe(Math.sqrt(2))
    })
  })

  describe('#dotProduct', () => {
    it('should calculate the dot product correctly', () => {
      expect(new Vector2(1, 0).dotProduct(new Vector2(0, 1))).toBe(0)

      expect(new Vector2(1, 2).dotProduct(new Vector2(3, 4))).toBe(11) // 1 * 3 + 2 * 4
    })
  })

  describe('#rotate', () => {
    it('should rotate a vector correctly', () => {
      expect(new Vector2(0, -1).rotate(Math.PI / 2).equalsApproximately(new Vector2(1, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(1.23, -4.56).rotate(Math.PI).equalsApproximately(new Vector2(-1.23, 4.56), 0.000001))
        .toBe(true)
    })
  })

  describe('#angleBetween', () => {
    it('should calculate the angle between two vectors correctly', () => {
      expect(new Vector2(1, 0).angleBetween(new Vector2(0, 1))).toBe(Math.PI / 2)

      expect(new Vector2(1, 0).angleBetween(new Vector2(1, -1))).toBe(-Math.PI / 4)
    })
  })
})
/**
 *   Min Heap is one of the two Binary Heap types (the other is Max Heap)
 *   which maintains the smallest value of its input array on top and remaining values in loosely (but not perfectly sorted) order.
 *
 *   Min Heaps can be expressed as a 'complete' binary tree structure
 *   (in which all levels of the binary tree are filled, with the exception of the last level which must be filled left-to-right).
 *
 *   However the Min Heap class below expresses this tree structure as an array
 *   which represent the binary tree node values in an array ordered from root-to-leaf, left-to-right.
 *
 *   In the array representation, the parent node-child node relationship is such that the
 *      * parent index relative to its two children are: (parentIdx * 2) and (parent * 2 + 1)
 *      * and either child's index position relative to its parent is: Math.floor((childIdx-1)/2)
 *
 *   The parent and respective child values define much of heap behavior as we continue to sort or not sort depending on their values.
 *      * The parent value must be less than or equal to either child's value.
 *
 *   This is a condensed overview but for more information and visuals here is a nice read: https://www.geeksforgeeks.org/binary-heap/
 */

class MinHeap {
  constructor (array) {
    this.heap = this.initializeHeap(array)
  }

  /**
   *   startingParent represents the parent of the last index (=== array.length-1)
   *   and iterates towards 0 with all index values below sorted to meet heap conditions
  */
  initializeHeap (array) {
    const startingParent = Math.floor((array.length - 2) / 2)

    for (let currIdx = startingParent; currIdx >= 0; currIdx--) {
      this.sinkDown(currIdx, array.length - 1, array)
    }
    return array
  }

  /**
   *   overall functionality: heap-sort value at a starting index (currIdx) towards end of heap
   *
   *   currIdx is considered to be a starting 'parent' index of two children indices (childOneIdx, childTwoIdx).
   *   endIdx represents the last valid index in the heap.
   *
   *   first check that childOneIdx and childTwoIdx are both smaller than endIdx
   *   and check for the smaller heap value between them.
   *
   *   the child index with the smaller heap value is set to a variable called swapIdx.
   *
   *   swapIdx's value will be compared to currIdx (the 'parent' index)
   *   and if swapIdx's value is smaller than currIdx's value, swap the values in the heap,
   *   update currIdx and recalculate the new childOneIdx to check heap conditions again.
   *
   *   if there is no swap, it means the children indices and the parent index satisfy heap conditions and can exit the function.
  */
  sinkDown (currIdx, endIdx, heap) {
    let childOneIdx = currIdx * 2 + 1

    while (childOneIdx <= endIdx) {
      const childTwoIdx = childOneIdx + 1 <= endIdx ? childOneIdx + 1 : -1
      const swapIdx = childTwoIdx !== -1 && heap[childTwoIdx] < heap[childOneIdx]
        ? childTwoIdx
        : childOneIdx

      if (heap[swapIdx] < heap[currIdx]) {
        this.swap(currIdx, swapIdx, heap)
        currIdx = swapIdx
        childOneIdx = currIdx * 2 + 1
      } else {
        return
      }
    }
  }

  /**
   *   overall functionality: heap-sort value at a starting index (currIdx) towards front of heap.
   *
   *   while the currIdx's value is smaller than its parent's (parentIdx) value, swap the values in the heap
   *   update currIdx and recalculate the new parentIdx to check heap condition again.
   *
   *   iteration does not end while a valid currIdx has a value smaller than its parentIdx's value
  */
  bubbleUp (currIdx) {
    let parentIdx = Math.floor((currIdx - 1) / 2)

    while (currIdx > 0 && this.heap[currIdx] < this.heap[parentIdx]) {
      this.swap(currIdx, parentIdx, this.heap)
      currIdx = parentIdx
      parentIdx = Math.floor((currIdx - 1) / 2)
    }
  }

  peek () {
    return this.heap[0]
  }

  /**
   *   the min heap value should be the first value in the heap (=== this.heap[0])
   *
   *   firstIdx value and lastIdx value are swapped
   *   the resulting min heap value now resides at heap[heap.length-1] which is popped and later returned.
   *
   *   the remaining values in the heap are re-sorted
  */
  extractMin () {
    this.swap(0, this.heap.length - 1, this.heap)
    const min = this.heap.pop()
    this.sinkDown(0, this.heap.length - 1, this.heap)
    return min
  }

  // a new value is pushed to the end of the heap and sorted up
  insert (value) {
    this.heap.push(value)
    this.bubbleUp(this.heap.length - 1)
  }

  // index-swapping helper method
  swap (idx1, idx2, heap) {
    const temp = heap[idx1]
    heap[idx1] = heap[idx2]
    heap[idx2] = temp
  }
}

export { MinHeap }
import { MinHeap } from '../MinHeap'

describe('MinHeap', () => {
  const array = [2, 4, 10, 23, 43, 42, 39, 7, 9, 16, 85, 1, 51]
  let heap

  beforeEach(() => {
    heap = new MinHeap(array)
  })

  it('should initialize a heap from an input array', () => {
    expect(heap).toEqual({ 'heap': [1, 4, 2, 7, 16, 10, 39, 23, 9, 43, 85, 42, 51] })   // eslint-disable-line
  })

  it('should show the top value in the heap', () => {
    const minValue = heap.peek()

    expect(minValue).toEqual(1)
  })

  it('should remove and return the top value in the heap', () => {
    const minValue = heap.extractMin()

    expect(minValue).toEqual(1)
    expect(heap).toEqual({ 'heap': [2, 4, 10, 7, 16, 42, 39, 23, 9, 43, 85, 51] })      // eslint-disable-line
  })

  it('should insert a new value and sort until it meets heap conditions', () => {
    heap.insert(15)

    expect(heap).toEqual({ 'heap': [2, 4, 10, 7, 16, 15, 39, 23, 9, 43, 85, 51, 42] })  // eslint-disable-line
  })
})
import { MinPriorityQueue } from '../MinPriorityQueue'

describe('MinPriorityQueue', () => {
  const values = [5, 2, 4, 1, 7, 6, 3, 8]
  const capacity = values.length
  let queue

  beforeEach(() => {
    queue = new MinPriorityQueue(capacity)
    values.forEach(v => queue.insert(v))
  })

  it('Check heap ordering', () => {
    const mockFn = jest.fn()
    queue.print(mockFn)

    expect(mockFn.mock.calls.length).toBe(1) // Expect one call
    expect(mockFn.mock.calls[0].length).toBe(1) // Expect one argument

    const heap = mockFn.mock.calls[0][0]
    expect(heap.length).toBe(capacity)
    expect(heap).toStrictEqual([1, 2, 3, 5, 7, 6, 4, 8])
  })

  it('heapSort() expected to reverse the heap ordering', () => {
    queue.heapReverse()
    const mockFn = jest.fn()
    queue.print(mockFn)

    expect(mockFn.mock.calls.length).toBe(1)
    expect(mockFn.mock.calls[0].length).toBe(1)

    const heap = mockFn.mock.calls[0][0]
    expect(heap.length).toBe(capacity)
    expect(heap).toStrictEqual([8, 7, 6, 5, 4, 3, 2, 1])
  })

  describe('delete() function work properly', () => {
    it('return undefined if heap is empty', () => {
      const minqueue = new MinPriorityQueue(capacity)
      const min = minqueue.delete()
      expect(min).toBe(undefined)
    })
    it('return min value and remove it', () => {
      const sortedValues = values.sort()
      let initialSize = queue.size
      sortedValues.forEach((minValue, index) => {
        const min = queue.delete()
        expect(min).toBe(minValue)
        expect(queue.size).toBe(--initialSize)
      })
      expect(queue.size).toBe(0)
    })
  })
})
/**
 * Author: Samarth Jain
 * Max Heap implementation in Javascript
 */

class BinaryHeap {
  constructor () {
    this.heap = []
  }

  insert (value) {
    this.heap.push(value)
    this.heapify()
  }

  size () {
    return this.heap.length
  }

  empty () {
    return this.size() === 0
  }

  // using iterative approach to reorder the heap after insertion
  heapify () {
    let index = this.size() - 1

    while (index > 0) {
      const element = this.heap[index]
      const parentIndex = Math.floor((index - 1) / 2)
      const parent = this.heap[parentIndex]

      if (parent[0] >= element[0]) break
      this.heap[index] = parent
      this.heap[parentIndex] = element
      index = parentIndex
    }
  }

  // Extracting the maximum element from the Heap
  extractMax () {
    const max = this.heap[0]
    const tmp = this.heap.pop()
    if (!this.empty()) {
      this.heap[0] = tmp
      this.sinkDown(0)
    }
    return max
  }

  // To restore the balance of the heap after extraction.
  sinkDown (index) {
    const left = 2 * index + 1
    const right = 2 * index + 2
    let largest = index
    const length = this.size()

    if (left < length && this.heap[left][0] > this.heap[largest][0]) {
      largest = left
    }
    if (right < length && this.heap[right][0] > this.heap[largest][0]) {
      largest = right
    }
    // swap
    if (largest !== index) {
      const tmp = this.heap[largest]
      this.heap[largest] = this.heap[index]
      this.heap[index] = tmp
      this.sinkDown(largest)
    }
  }
}

// Example

// const maxHeap = new BinaryHeap()
// maxHeap.insert([4])
// maxHeap.insert([3])
// maxHeap.insert([6])
// maxHeap.insert([1])
// maxHeap.insert([8])
// maxHeap.insert([2])
// const mx = maxHeap.extractMax()

export { BinaryHeap }

/* Minimum Priority Queue
* It is a part of heap data structure
* A heap is a specific tree based data structure
* in which all the nodes of tree are in a specific order.
* that is the children are arranged in some
* respect of their parents, can either be greater
* or less than the parent. This makes it a min priority queue
* or max priority queue.
*/

// Functions: insert, delete, peek, isEmpty, print, heapSort, sink

class MinPriorityQueue {
  // calls the constructor and initializes the capacity
  constructor (c) {
    this.heap = []
    this.capacity = c
    this.size = 0
  }

  // inserts the key at the end and rearranges it
  // so that the binary heap is in appropriate order
  insert (key) {
    if (this.isFull()) return
    this.heap[this.size + 1] = key
    let k = this.size + 1
    while (k > 1) {
      if (this.heap[k] < this.heap[Math.floor(k / 2)]) {
        const temp = this.heap[k]
        this.heap[k] = this.heap[Math.floor(k / 2)]
        this.heap[Math.floor(k / 2)] = temp
      }
      k = Math.floor(k / 2)
    }
    this.size++
  }

  // returns the highest priority value
  peek () {
    return this.heap[1]
  }

  // returns boolean value whether the heap is empty or not
  isEmpty () {
    return this.size === 0
  }

  // returns boolean value whether the heap is full or not
  isFull () {
    if (this.size === this.capacity) return true
    return false
  }

  // prints the heap
  print (output = value => console.log(value)) {
    output(this.heap.slice(1))
  }

  // heap reverse can be done by performing swapping the first
  // element with the last, removing the last element to
  // new array and calling sink function.
  heapReverse () {
    const heapSort = []
    while (this.size > 0) {
      // swap first element with last element
      [this.heap[1], this.heap[this.size]] = [this.heap[this.size], this.heap[1]]
      heapSort.push(this.heap.pop())
      this.size--
      this.sink()
    }
    // first value from heap it's empty to respect
    // structure with 1 as index of the first element
    this.heap = [undefined, ...heapSort.reverse()]
    this.size = heapSort.length
  }

  // this function reorders the heap after every delete function
  sink () {
    let k = 1
    while (2 * k <= this.size || 2 * k + 1 <= this.size) {
      let minIndex
      if (this.heap[2 * k] >= this.heap[k]) {
        if (2 * k + 1 <= this.size && this.heap[2 * k + 1] >= this.heap[k]) {
          break
        } else if (2 * k + 1 > this.size) {
          break
        }
      }
      if (2 * k + 1 > this.size) {
        minIndex = this.heap[2 * k] < this.heap[k] ? 2 * k : k
      } else {
        if (
          this.heap[k] > this.heap[2 * k] ||
          this.heap[k] > this.heap[2 * k + 1]
        ) {
          minIndex =
            this.heap[2 * k] < this.heap[2 * k + 1] ? 2 * k : 2 * k + 1
        } else {
          minIndex = k
        }
      }
      const temp = this.heap[k]
      this.heap[k] = this.heap[minIndex]
      this.heap[minIndex] = temp
      k = minIndex
    }
  }

  // deletes the highest priority value from the heap. The last
  // element goes to ahead to first position and reorder heap
  delete () {
    // checks empty and one element array conditions
    if (this.isEmpty()) return
    if (this.size === 1) {
      this.size--
      return this.heap.pop()
    }
    const min = this.heap[1]
    this.heap[1] = this.heap.pop()
    this.size--
    this.sink()
    return min
  }
}

export { MinPriorityQueue }
// implementation of Queue using 2 stacks
// contribution made by hamza chabchoub for a university project

class Queue {
  constructor () {
    this.inputStack = []
    this.outputStack = []
  }

  // Push item into the inputstack
  enqueue (item) {
    this.inputStack.push(item)
  }

  dequeue () {
    // push all items to outputstack
    this.outputStack = []
    while (this.inputStack.length > 0) {
      this.outputStack.push(this.inputStack.pop())
    }
    // return the top element of the outputstack if any
    if (this.outputStack.length > 0) {
      const top = this.outputStack.pop()
      // repush all the items to the inputstack
      this.inputStack = []
      while (this.outputStack.length > 0) {
        this.inputStack.push(this.outputStack.pop())
      }
      return top
    }
  }

  // display elements of the inputstack
  listIn (output = value => console.log(value)) {
    let i = 0
    while (i < this.inputStack.length) {
      output(this.inputStack[i])
      i++
    }
  }

  // display element of the outputstack
  listOut (output = value => console.log(value)) {
    let i = 0
    while (i < this.outputStack.length) {
      output(this.outputStack[i])
      i++
    }
  }
}

export { Queue }
import { Queue } from '../QueueUsing2Stacks'

describe('QueueUsing2Stacks', () => {
  const queue = new Queue()

  it('Check enqueue/dequeue', () => {
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(8)
    queue.enqueue(9)

    expect(queue.dequeue()).toBe(1)
    expect(queue.dequeue()).toBe(2)
  })
})
import Queue from '../Queue'

describe('Testing the Queue DS', () => {
  const queue = new Queue()

  it('Testing enqueue method', () => {
    expect(queue.enqueue(1)).toBe(1)
    expect(queue.enqueue(2)).toBe(2)
    expect(queue.enqueue(8)).toBe(3)
    expect(queue.enqueue(9)).toBe(4)
  })

  it('Testing length after enqueue', () => {
    expect(queue.length).toBe(4)
  })

  it('Testing peekFirst & peekLast methods', () => {
    expect(queue.peekFirst()).toBe(1)
    expect(queue.peekLast()).toBe(9)
  })

  it('Testing toArray method', () => {
    expect(queue.toArray()).toEqual([1, 2, 8, 9])
  })

  it('Testing dequeue method', () => {
    expect(queue.dequeue()).toBe(1)
    expect(queue.dequeue()).toBe(2)
  })

  it('Testing length after dequeue', () => {
    expect(queue.length).toBe(2)
  })

  it('Testing isEmpty method', () => {
    const queue = new Queue()
    expect(queue.isEmpty()).toBeTruthy()

    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(8)
    queue.enqueue(9)

    expect(queue.isEmpty()).toBeFalsy()
  })
})
/* Queue
* A Queue is a data structure that allows you to add an element to the end of
* a list and remove the item at the front. A queue follows a FIFO (First In First Out)
* system, where the first item to enter the queue is the first to be removed,
* All these operation complexities are O(1).
* This implementation following the linked list structure.
*/

class Queue {
  #size

  constructor () {
    this.head = null
    this.tail = null
    this.#size = 0

    return Object.seal(this)
  }

  get length () {
    return this.#size
  }

  /**
   * @description - Add a value to the end of the queue
   * @param {*} data
   * @returns {number} - The current size of queue
   */
  enqueue (data) {
    const node = { data, next: null }

    if (!this.head && !this.tail) {
      this.head = node
      this.tail = node
    } else {
      this.tail.next = node
      this.tail = node
    }

    return ++this.#size
  }

  /**
   * @description - Removes the value at the front of the queue
   * @returns {*} - The first data of the queue
   */
  dequeue () {
    if (this.isEmpty()) {
      throw new Error('Queue is Empty')
    }

    const firstData = this.peekFirst()

    this.head = this.head.next

    if (!this.head) {
      this.tail = null
    }

    this.#size--

    return firstData
  }

  /**
   * @description - Return the item at the front of the queue
   * @returns {*}
   */
  peekFirst () {
    if (this.isEmpty()) {
      throw new Error('Queue is Empty')
    }

    return this.head.data
  }

  /**
   * @description - Return the item at the tail of the queue
   * @returns {*}
   */
  peekLast () {
    if (this.isEmpty()) {
      throw new Error('Queue is Empty')
    }

    return this.tail.data
  }

  /**
   * @description - Return the array of Queue
   * @returns {Array<*>}
   */
  toArray () {
    const array = []
    let node = this.head

    while (node) {
      array.push(node.data)
      node = node.next
    }

    return array
  }

  /**
  * @description - Return is queue empty or not
  * @returns {boolean}
  */
  isEmpty () {
    return this.length === 0
  }
}

export default Queue
// Circular Queues offer a quick to store FIFO data with a maximum size.
// Conserves memory as we only store up to our capacity
// It is opposed to a queue which could continue to grow if input outpaces output
// Doesnt use dynamic memory so No memory leaks

class CircularQueue {
  constructor (maxLength) {
    this.queue = []
    this.front = 0
    this.rear = 0
    this.maxLength = maxLength
  }

  // ADD ELEMENTS TO QUEUE
  enqueue (value) {
    if (this.checkOverflow()) return
    if (this.checkEmpty()) {
      this.front += 1
      this.rear += 1
    } else {
      if (this.rear === this.maxLength) {
        this.rear = 1
      } else this.rear += 1
    }
    this.queue[this.rear] = value
  }

  // REMOVES ELEMENTS
  dequeue () {
    if (this.checkEmpty()) {
      // UNDERFLOW
      return
    }
    const y = this.queue[this.front]
    this.queue[this.front] = '*'
    if (!this.checkSingleelement()) {
      if (this.front === this.maxLength) this.front = 1
      else {
        this.front += 1
      }
    }

    return y // Returns the removed element and replaces it with a star
  }

  // checks if the queue is empty or not
  checkEmpty () {
    if (this.front === 0 && this.rear === 0) {
      return true
    }
  }

  checkSingleelement () {
    if (this.front === this.rear && this.rear !== 0) {
      this.front = this.rear = 0
      return true
    }
  }

  // Checks if max capacity of queue has been reached or not
  checkOverflow () {
    if ((this.front === 1 && this.rear === this.maxLength) || (this.front === this.rear + 1)) {
      // CIRCULAR QUEUE OVERFLOW
      return true
    }
  }

  // Prints the entire array ('*' represents blank space)
  display (output = value => console.log(value)) {
    for (let index = 1; index < this.queue.length; index++) {
      output(this.queue[index])
    }
  }

  // Displays the length of queue
  length () {
    return this.queue.length - 1
  }

  // Display the top most value of queue
  peek () {
    return this.queue[this.front]
  }
}

export { CircularQueue }
/* Stack data-structure. It's work is based on the LIFO method (last-IN-first-OUT).
 * It means that elements added to the stack are placed on the top and only the
 * last element (from the top) can be reached. After we get access to the last
 * element, he pops from the stack.
 * This is a class-based implementation of a Stack. It provides functions
 * 'push' - to add an element, 'pop' - to remove an element from the top.
 * Also it implements 'length', 'last' and 'isEmpty' properties and
 * static isStack method to check is an object the instance of Stack class.
 */

// Class declaration
class Stack {
  constructor () {
    this.stack = []
    this.top = 0
  }

  // Adds a value to the end of the Stack
  push (newValue) {
    this.stack.push(newValue)
    this.top += 1
  }

  // Returns and removes the last element of the Stack
  pop () {
    if (this.top !== 0) {
      this.top -= 1
      return this.stack.pop()
    }
    throw new Error('Stack Underflow')
  }

  // Returns the number of elements in the Stack
  get length () {
    return this.top
  }

  // Returns true if stack is empty, false otherwise
  get isEmpty () {
    return this.top === 0
  }

  // Returns the last element without removing it
  get last () {
    if (this.top !== 0) {
      return this.stack[this.stack.length - 1]
    }
    return null
  }

  // Checks if an object is the instance os the Stack class
  static isStack (el) {
    return el instanceof Stack
  }
}

export { Stack }
/* Stack!!
* A stack is exactly what it sounds like. An element gets added to the top of
* the stack and only the element on the top may be removed. This is an example
* of an array implementation of a Stack. So an element can only be added/removed
* from the end of the array.
*/

// Functions: push, pop, peek, view, length

// Creates a stack constructor
const Stack = (function () {
  function Stack () {
    // The top of the Stack
    this.top = 0
    // The array representation of the stack
    this.stack = []
  }

  // Adds a value onto the end of the stack
  Stack.prototype.push = function (value) {
    this.stack[this.top] = value
    this.top++
  }

  // Removes and returns the value at the end of the stack
  Stack.prototype.pop = function () {
    if (this.top === 0) {
      return 'Stack is Empty'
    }

    this.top--
    const result = this.stack[this.top]
    this.stack = this.stack.splice(0, this.top)
    return result
  }

  // Returns the size of the stack
  Stack.prototype.size = function () {
    return this.top
  }

  // Returns the value at the end of the stack
  Stack.prototype.peek = function () {
    return this.stack[this.top - 1]
  }

  // To see all the elements in the stack
  Stack.prototype.view = function (output = value => console.log(value)) {
    for (let i = 0; i < this.top; i++) {
      output(this.stack[i])
    }
  }

  return Stack
}())

export { Stack }
import { FenwickTree } from '../FenwickTree'

describe('Fenwick Tree Implementation', () => {
  const fenwickArray = new Array(1000)
  const array = [3, 2, 0, 6, 5, -1, 2]
  const length = array.length

  const fenwickTree = new FenwickTree(fenwickArray, array, length)

  it('Fenwick Tree - Prefix sum of array', () => {
    const prefixSum = fenwickTree.getPrefixSum(fenwickArray, 6)
    expect(prefixSum).toBe(23)
  })

  array[2] += 6
  fenwickTree.update(fenwickArray, length, 2, 6)

  it('Fenwick Tree - Prefix sum of Updated array', () => {
    const prefixSum = fenwickTree.getPrefixSum(fenwickArray, 6)
    expect(prefixSum).toBe(23)
  })
})
import { BinaryTree, Node } from '../BreadthFirstTreeTraversal'

describe('Breadth First Tree Traversal', () => {
  const binaryTree = new BinaryTree()

  const root = new Node(7)
  root.left = new Node(5)
  root.right = new Node(8)
  root.left.left = new Node(3)
  root.left.right = new Node(6)
  root.right.right = new Node(9)
  binaryTree.root = root

  // Visualization :
  //
  //            7
  //           / \
  //          5   8
  //         / \   \
  //        3   6   9

  it('Binary tree - Level order traversal', () => {
    expect(binaryTree.traversal).toStrictEqual([])
    const traversal = binaryTree.breadthFirst()
    expect(traversal).toStrictEqual([7, 5, 8, 3, 6, 9])
  })
})
/*
  Breadth First Tree Traversal or level order traversal implementation in javascript
  Author: @GerardUbuntu
*/

class Node {
  constructor (data) {
    this.data = data
    this.left = null
    this.right = null
  }
}

class BinaryTree {
  constructor () {
    this.root = null
    this.traversal = []
  }

  breadthFirst () {
    const h = this.getHeight(this.root)
    for (let i = 0; i !== h; i++) {
      this.traverseLevel(this.root, i)
    }
    return this.traversal
  }

  // Computing the height of the tree
  getHeight (node) {
    if (node === null) {
      return 0
    }
    const lheight = this.getHeight(node.left)
    const rheight = this.getHeight(node.right)
    return lheight > rheight ? lheight + 1 : rheight + 1
  }

  traverseLevel (node, levelRemaining) {
    if (node === null) {
      return
    }
    if (levelRemaining === 0) {
      this.traversal.push(node.data)
    } else {
      this.traverseLevel(node.left, levelRemaining - 1)
      this.traverseLevel(node.right, levelRemaining - 1)
    }
  }
}

export { BinaryTree, Node }
/*
 * Author: Mohit Kumar
 * Fedwick Tree Implementation in JavaScript
 * Fedwick Tree Implementation for finding prefix sum.
*/

class FenwickTree {
  constructor (feneickArray, array, n) {
    for (let i = 1; i <= n; i++) {
      feneickArray[i] = 0
    }
    for (let i = 0; i < n; i++) {
      this.update(feneickArray, n, i, array[i])
    }
  }

  update (feneickArray, n, index, value) {
    index = index + 1
    while (index <= n) {
      feneickArray[index] += value
      index += index & (-index)
    }
  }

  getPrefixSum (feneickArray, index) {
    let currSum = 0
    index = index + 1
    while (index > 0) {
      currSum += feneickArray[index]
      index -= index & (-index)
    }

    return currSum
  }
}
export { FenwickTree }
/*
 * Author: Surendra Kumar
 * DFS Algorithm implementation in JavaScript
 * DFS Algorithm for traversing or searching graph data structures.
*/

function traverseDFS (root) {
  const stack = [root]
  const res = []

  while (stack.length) {
    const curr = stack.pop()
    res.push(curr.key)

    if (curr.right) {
      stack.push(curr.right)
    }

    if (curr.left) {
      stack.push(curr.left)
    }
  }

  return res.reverse()
}

function searchDFS (tree, value) {
  const stack = []

  stack.push(tree[0])

  while (stack.length !== 0) {
    for (let i = 0; i < stack.length; i++) {
      const node = stack.pop()

      if (node.value === value) {
        return node
      }
      if (node.right) {
        stack.push(tree[node.right])
      }
      if (node.left) {
        stack.push(tree[node.left])
      }
    }
  }
  return null
}

const tree = [
  { value: 6, left: 1, right: 2 },
  { value: 5, left: 3, right: 4 },
  { value: 7, left: null, right: 5 },
  { value: 3, left: 6, right: null },
  { value: 4, left: null, right: null },
  { value: 9, left: 7, right: 8 },
  { value: 2, left: 9, right: null },
  { value: 8, left: null, right: null },
  { value: 10, left: null, right: null },
  { value: 1, left: null, right: null }
]

searchDFS(tree, 9)
searchDFS(tree, 10)

traverseDFS(6)

//            6
//           / \
//          5   7
//         / \   \
//        3   4   9
//       /       / \
//      2       8   10
//     /
//    1
import { memoize } from '../Memoize'
import { union } from './cacheTest'
import { fibonacci } from '../../Dynamic-Programming/FibonacciNumber'
import { factorial } from '../../Recursive/Factorial'
import LFUCache from '../LFUCache'

const multipleFactorials = (arr) => arr.map(factorial)

describe('Testing Memoize', () => {
  it('expects the fibonacci function to use the cache on the second call', () => {
    const memoFibonacci = memoize(fibonacci)

    expect(memoFibonacci(5)).toEqual(fibonacci(5))
    expect(memoFibonacci(5)).toEqual(5)
    expect(memoFibonacci(10)).toEqual(fibonacci(10))
    expect(memoFibonacci(10)).toEqual(55)
  })

  it('expects the factorial function to use the cache on the second call', () => {
    const memoFactorial = memoize(factorial)

    expect(memoFactorial(5)).toEqual(factorial(5))
    expect(memoFactorial(5)).toEqual(120)
    expect(memoFactorial(10)).toEqual(factorial(10))
    expect(memoFactorial(10)).toEqual(3628800)
  })

  it('expects the multipleFactorials function to use the cache on the second call', () => {
    const memoMultipleFactorials = memoize(multipleFactorials)
    const input = [2, 3, 4, 5]

    expect(memoMultipleFactorials(input)).toEqual([2, 6, 24, 120])
    expect(memoMultipleFactorials(input)).toEqual(multipleFactorials(input))
  })

  it('expects the multipleFactorials function to use the cache on the second call', () => {
    const memoMultipleFactorials = memoize(multipleFactorials)
    const input = [2, 3, 4, 5]

    expect(memoMultipleFactorials(input)).toEqual([2, 6, 24, 120])
    expect(memoMultipleFactorials(input)).toEqual(multipleFactorials(input))
  })

  it('expects the union function to use the cache on the second call', () => {
    const memoUnion = memoize(union)
    const inputs = [
      new Set([1, 2, 3]),
      new Set([4, 3, 2]),
      new Set([5, 3, 6])
    ]

    expect(memoUnion(...inputs)).toEqual(new Set([1, 2, 3, 4, 5, 6]))
    expect(memoUnion(...inputs)).toEqual(union(...inputs))
  })

  it('Testing with explicit cache -> LFUCache', () => {
    const LFU = new LFUCache(2)

    const memoizeFibonacci = memoize(fibonacci, LFU) // added LFU cache explicitly
    const fibOfFiveHundred = memoizeFibonacci(500)
    const fibOfOneHundred = memoizeFibonacci(100)

    expect(memoizeFibonacci(500)).toBe(fibOfFiveHundred)
    expect(memoizeFibonacci(100)).toBe(fibOfOneHundred)

    expect(LFU.leastFrequency).toBe(2)
  })
})
import LFUCache from '../LFUCache'
import { fibonacciCache } from './cacheTest'

describe('Testing LFUCache class', () => {
  it('Example 1 (Small Cache, size = 2)', () => {
    const cache = new LFUCache(1) // initially capacity 1

    cache.capacity = 2 // increase the capacity

    expect(cache.capacity).toBe(2)

    cache.set(1, 1) // frequency = 1
    cache.set(2, 2) // frequency = 1

    expect(cache.get(1)).toBe(1) // frequency = 2
    expect(cache.get(2)).toBe(2) // frequency = 2

    // Additional entries triggers cache rotate
    cache.set(3, 3) // frequency = 1 & key 1 removed from the cached, cause now it's tie and followed the LRU system

    expect(cache.get(1)).toBe(null) // misses = 1
    expect(cache.get(2)).toBe(2) // frequency = 3
    expect(cache.get(3)).toBe(3) // frequency = 2

    cache.set(4, 4) // frequency = 1 & key 3 removed cause the frequency of 3 is 2 which is least frequency
    expect(cache.get(1)).toBe(null) // misses = 2
    expect(cache.get(2)).toBe(2) // frequency = 4
    expect(cache.get(3)).toBe(null) // misses = 3
    expect(cache.get(4)).toBe(4) // frequency = 2 which is least

    expect(cache.info).toEqual({
      misses: 3,
      hits: 6,
      capacity: 2,
      currentSize: 2,
      leastFrequency: 2
    })

    const json = '{"misses":3,"hits":6,"cache":{"2":{"key":"2","value":2,"frequency":4},"4":{"key":"4","value":4,"frequency":2}}}'
    expect(cache.toString()).toBe(json)

    const cacheInstance = cache.parse(json) // again merge the json

    expect(cacheInstance).toBe(cache) // return the same cache

    cache.capacity = 1 // decrease the capacity

    expect(cache.info).toEqual({ // after merging the info
      misses: 6,
      hits: 12,
      capacity: 1,
      currentSize: 1,
      leastFrequency: 5
    })

    const clearedCache = cache.clear() // clear the cache
    expect(clearedCache.size).toBe(0)
  })

  it('Example 2 (Computing Fibonacci Series, size = 100)', () => {
    const cache = new LFUCache(100)

    for (let i = 1; i <= 100; i++) {
      fibonacciCache(i, cache)
    }

    expect(cache.info).toEqual({
      misses: 103,
      hits: 193,
      capacity: 100,
      currentSize: 98,
      leastFrequency: 1
    })
  })
})
import LRUCache from '../LRUCache'
import { fibonacciCache } from './cacheTest'

describe('Testing LRUCache', () => {
  it('Testing with invalid capacity', () => {
    expect(() => new LRUCache()).toThrow()
    expect(() => new LRUCache('Invalid')).toThrow()
    expect(() => new LRUCache(-1)).toThrow()
    expect(() => new LRUCache(Infinity)).toThrow()
  })

  it('Example 1 (Small Cache, size = 2)', () => {
    const cache = new LRUCache(1) // initially capacity

    cache.capacity++ // now the capacity is increasing by one

    cache.set(1, 1)
    cache.set(2, 2)

    expect(cache.get(1)).toBe(1)
    expect(cache.get(2)).toBe(2)

    // Additional entries triggers cache rotate
    cache.set(3, 3)

    // Then we should have a cache miss for the first entry added
    expect(cache.get(1)).toBe(null)
    expect(cache.get(2)).toBe(2)
    expect(cache.get(3)).toBe(3)

    cache.set(4, 4)
    expect(cache.get(1)).toBe(null) // cache miss
    expect(cache.get(2)).toBe(null) // cache miss
    expect(cache.get(3)).toBe(3)
    expect(cache.get(4)).toBe(4)

    expect(cache.info).toEqual({
      misses: 3,
      hits: 6,
      capacity: 2,
      size: 2
    })

    const json = '{"misses":3,"hits":6,"cache":{"3":3,"4":4}}'
    expect(cache.toString()).toBe(json)

    // merge with json
    cache.parse(json)

    cache.capacity-- // now the capacity decreasing by one

    expect(cache.info).toEqual({
      misses: 6,
      hits: 12,
      capacity: 1,
      size: 1
    })
  })

  it('Example 2 (Computing Fibonacci Series, size = 100)', () => {
    const cache = new LRUCache(100)

    for (let i = 1; i <= 100; i++) {
      fibonacciCache(i, cache)
    }

    expect(cache.info).toEqual({
      misses: 103,
      hits: 193,
      capacity: 100,
      size: 98
    })
  })
})
/**
 * @function fibonacciCache
 * @description - this is a cached variant of fib number
 * @param {number} n  - Real number (n > -1)
 * @param {Object} cache
 * @returns {number}
 */
export const fibonacciCache = (n, cache = null) => {
  if (cache) {
    const value = cache.get(n)

    if (value !== null) {
      return value
    }
  }

  if (n === 1 || n === 2) {
    return 1
  }

  const result = fibonacciCache(n - 1, cache) + fibonacciCache(n - 2, cache)

  cache && cache.set(n, result)

  return result
}

/**
 * @title implementation of union function
 * @param {Set} sets
 * @return {new Set}
 */
export const union = (...sets) => {
  return new Set(
    sets.reduce((flatArray, set) => [...flatArray, ...set], [])
  )
}
/**
 * @function memoize
 * @description ->
 * From [Wikipedia](https://en.wikipedia.org/wiki/Memoization),
 * memoization is an optimization technique
 * used primarily to speed up computer programs,
 * by storing the results of expensive function calls
 * and returning the cached result when the same inputs occur again
 * This function is a first class objects,
 * which lets us use it as [Higher-Order Function](https://eloquentjavascript.net/05_higher_order.html)
 * and return another function
 * @param {Function} func Original function
 * @param {Map} cache - it's receive any cache DS which have get, set & has method
 * @returns {Function} Memoized function
 */
const memoize = (func, cache = new Map()) => {
  const jsonReplacer = (_, value) => {
    if (value instanceof Set) { // if the value is Set it's converted to Array cause JSON.stringify can't convert Set
      return [...value]
    }

    if (value instanceof Map) { // if the value is Map it's converted to Object cause JSON.stringify can't convert Map
      return Object.fromEntries(value)
    }

    return value
  }

  return (...args) => {
    /**
     * Arguments converted to JSON string for use as a key of Map - it's easy to detect collections like -> Object and Array
     * If the args input is -> [new Set([1, 2, 3, 4]), {name: 'myName', age: 23}]
     * Then the agrsKey generate to -> '[[1,2,3,4],{"name":"myName","age":23}]' which is JSON mean string
     * Now it's ready to be a perfect key for Map
     */
    const argsKey = JSON.stringify(args, jsonReplacer)

    /**
     * Checks if the argument is already present in the cache,
     * then return the associated value / result
     */
    if (cache.has(argsKey)) {
      return cache.get(argsKey)
    }

    /**
     * If the argument is not yet present in the cache,
     * execute original function and save its value / result in cache,
     * finally return it
     */
    const result = func(...args) // spread all args
    cache.set(argsKey, result)

    return result
  }
}

export { memoize }
class LRUCache {
  // LRU Cache to store a given capacity of data
  #capacity

  /**
   * @param {number} capacity - the capacity of LRUCache
   * @returns {LRUCache} - sealed
   */
  constructor (capacity) {
    if (!Number.isInteger(capacity) || capacity < 0) {
      throw new TypeError('Invalid capacity')
    }

    this.#capacity = ~~capacity
    this.misses = 0
    this.hits = 0
    this.cache = new Map()

    return Object.seal(this)
  }

  get info () {
    return Object.freeze({
      misses: this.misses,
      hits: this.hits,
      capacity: this.capacity,
      size: this.size
    })
  }

  get size () {
    return this.cache.size
  }

  get capacity () {
    return this.#capacity
  }

  set capacity (newCapacity) {
    if (newCapacity < 0) {
      throw new RangeError('Capacity should be greater than 0')
    }

    if (newCapacity < this.capacity) {
      let diff = this.capacity - newCapacity

      while (diff--) {
        this.#removeLeastRecentlyUsed()
      }
    }

    this.#capacity = newCapacity
  }

  /**
 * delete oldest key existing in map by the help of iterator
 */
  #removeLeastRecentlyUsed () {
    this.cache.delete(this.cache.keys().next().value)
  }

  /**
   * @param {string} key
   * @returns {*}
   */
  has (key) {
    key = String(key)

    return this.cache.has(key)
  }

  /**
   * @param {string} key
   * @param {*} value
   */
  set (key, value) {
    key = String(key)
    // Sets the value for the input key and if the key exists it updates the existing key
    if (this.size === this.capacity) {
      this.#removeLeastRecentlyUsed()
    }

    this.cache.set(key, value)
  }

  /**
   * @param {string} key
   * @returns {*}
   */
  get (key) {
    key = String(key)
    // Returns the value for the input key. Returns null if key is not present in cache
    if (this.cache.has(key)) {
      const value = this.cache.get(key)

      // refresh the cache to update the order of key
      this.cache.delete(key)
      this.cache.set(key, value)

      this.hits++
      return value
    }

    this.misses++
    return null
  }

  /**
   * @param {JSON} json
   * @returns {LRUCache}
   */
  parse (json) {
    const { misses, hits, cache } = JSON.parse(json)

    this.misses += misses ?? 0
    this.hits += hits ?? 0

    for (const key in cache) {
      this.set(key, cache[key])
    }

    return this
  }

  /**
   * @param {number} indent
   * @returns {JSON} - string
   */
  toString (indent) {
    const replacer = (_, value) => {
      if (value instanceof Set) {
        return [...value]
      }

      if (value instanceof Map) {
        return Object.fromEntries(value)
      }

      return value
    }

    return JSON.stringify(this, replacer, indent)
  }
}

export default LRUCache
class CacheNode {
  constructor (key, value, frequency) {
    this.key = key
    this.value = value
    this.frequency = frequency

    return Object.seal(this)
  }
}

// This frequency map class will act like javascript Map DS with more two custom method refresh & insert
class FrequencyMap extends Map {
  static get [Symbol.species] () { return Map } // for using Symbol.species we can access Map constructor  @see -> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@species
  get [Symbol.toStringTag] () { return '' }

  /**
  * @method refresh
  * @description - It's revive a CacheNode, increment of this nodes frequency and refresh the frequencyMap via new incremented nodes frequency
  * @param {CacheNode} node
  */
  refresh (node) {
    const { frequency } = node
    const freqSet = this.get(frequency)
    freqSet.delete(node)

    node.frequency++

    this.insert(node)
  }

  /**
   * @method insert
   * @description - Add new CacheNode into HashSet by the frequency
   * @param {CacheNode} node
   */
  insert (node) {
    const { frequency } = node

    if (!this.has(frequency)) {
      this.set(frequency, new Set())
    }

    this.get(frequency).add(node)
  }
}

class LFUCache {
    #capacity
    #frequencyMap

    /**
     * @param {number} capacity - The range of LFUCache
     * @returns {LFUCache} - sealed
     */
    constructor (capacity) {
      this.#capacity = capacity
      this.#frequencyMap = new FrequencyMap()
      this.misses = 0
      this.hits = 0
      this.cache = new Map()

      return Object.seal(this)
    }

    /**
   * Get the capacity of the LFUCache
   * @returns {number}
   */
    get capacity () {
      return this.#capacity
    }

    /**
   * Get the current size of LFUCache
   * @returns {number}
   */
    get size () {
      return this.cache.size
    }

    /**
     * Set the capacity of the LFUCache if you decrease the capacity its removed CacheNodes following the LFU - least frequency used
     */
    set capacity (newCapacity) {
      if (this.#capacity > newCapacity) {
        let diff = this.#capacity - newCapacity // get the decrement number of capacity

        while (diff--) {
          this.#removeCacheNode()
        }

        this.cache.size === 0 && this.#frequencyMap.clear()
      }

      this.#capacity = newCapacity
    }

    get info () {
      return Object.freeze({
        misses: this.misses,
        hits: this.hits,
        capacity: this.capacity,
        currentSize: this.size,
        leastFrequency: this.leastFrequency
      })
    }

    get leastFrequency () {
      const freqCacheIterator = this.#frequencyMap.keys()
      let leastFrequency = freqCacheIterator.next().value || null

      // select the non-empty frequency Set
      while (this.#frequencyMap.get(leastFrequency)?.size === 0) {
        leastFrequency = freqCacheIterator.next().value
      }

      return leastFrequency
    }

    #removeCacheNode () {
      const leastFreqSet = this.#frequencyMap.get(this.leastFrequency)
      // Select the least recently used node from the least Frequency set
      const LFUNode = leastFreqSet.values().next().value

      leastFreqSet.delete(LFUNode)
      this.cache.delete(LFUNode.key)
    }

    /**
   * if key exist then return true otherwise false
   * @param {any} key
   * @returns {boolean}
   */
    has (key) {
      key = String(key) // converted to string

      return this.cache.has(key)
    }

    /**
     * @method get
     * @description - This method return the value of key & refresh the frequencyMap by the oldNode
     * @param {string} key
     * @returns {any}
     */
    get (key) {
      key = String(key) // converted to string

      if (this.cache.has(key)) {
        const oldNode = this.cache.get(key)
        this.#frequencyMap.refresh(oldNode)

        this.hits++

        return oldNode.value
      }

      this.misses++
      return null
    }

    /**
     * @method set
     * @description - This method stored the value by key & add frequency if it doesn't exist
     * @param {string} key
     * @param {any} value
     * @param {number} frequency
     * @returns {LFUCache}
     */
    set (key, value, frequency = 1) {
      key = String(key) // converted to string

      if (this.#capacity === 0) {
        throw new RangeError('LFUCache ERROR: The Capacity is 0')
      }

      if (this.cache.has(key)) {
        const node = this.cache.get(key)
        node.value = value

        this.#frequencyMap.refresh(node)

        return this
      }

      // if the cache size is full, then it's delete the Least Frequency Used node
      if (this.#capacity === this.cache.size) {
        this.#removeCacheNode()
      }

      const newNode = new CacheNode(key, value, frequency)

      this.cache.set(key, newNode)
      this.#frequencyMap.insert(newNode)

      return this
    }

    /**
     * @method parse
     * @description - This method receive a valid LFUCache JSON & run JSON.prase() method and merge with existing LFUCache
     * @param {JSON} json
     * @returns {LFUCache} - merged
     */
    parse (json) {
      const { misses, hits, cache } = JSON.parse(json)

      this.misses += misses ?? 0
      this.hits += hits ?? 0

      for (const key in cache) {
        const { value, frequency } = cache[key]
        this.set(key, value, frequency)
      }

      return this
    }

    /**
     * @method clear
     * @description - This method cleared the whole LFUCache
     * @returns {LFUCache}
     */
    clear () {
      this.cache.clear()
      this.#frequencyMap.clear()

      return this
    }

    /**
     * @method toString
     * @description - This method generate a JSON format of LFUCache & return it.
     * @param {number} indent
     * @returns {string} - JSON
     */
    toString (indent) {
      const replacer = (_, value) => {
        if (value instanceof Set) {
          return [...value]
        }

        if (value instanceof Map) {
          return Object.fromEntries(value)
        }

        return value
      }

      return JSON.stringify(this, replacer, indent)
    }
}

export default LFUCache
// Foot: https://en.wikipedia.org/wiki/Foot_(unit)
const feetToMeter = (feet) => {
  return feet * 0.3048
}

const meterToFeet = (meter) => {
  return meter / 0.3048
}

export { feetToMeter, meterToFeet }
/*
    The time conversion of normalized time to the railway is a simple algorithm
    because we know that if the time is in 'AM' value it means they only want
    some changes on hours and minutes and if the time in 'PM' it means the only
    want some changes in hour value.

    Input Format -> 07:05:45PM
    Output Format -> 19:05:45

    Problem & Explanation Source : https://www.mathsisfun.com/time.html
*/

/**
 * RailwayTimeConversion method converts normalized time string to Railway time string.
 * @param {String} timeString Normalized time string.
 * @returns {String} Railway time string.
 */
const RailwayTimeConversion = (timeString) => {
  // firstly, check that input is a string or not.
  if (typeof timeString !== 'string') {
    return new TypeError('Argument is not a string.')
  }
  // split the string by ':' character.
  const [hour, minute, scondWithShift] = timeString.split(':')
  // split second and shift value.
  const [second, shift] = [scondWithShift.substr(0, 2), scondWithShift.substr(2)]
  // convert shifted time to not-shift time(Railway time) by using the above explanation.
  if (shift === 'PM') {
    if (parseInt(hour) === 12) { return `${hour}:${minute}:${second}` } else { return `${parseInt(hour) + 12}:${minute}:${second}` }
  } else {
    if (parseInt(hour) === 12) { return `00:${minute}:${second}` } else { return `${hour}:${minute}:${second}` }
  }
}

export { RailwayTimeConversion }
/*
    Problem statement and Explanation : https://www.codeproject.com/Tips/162540/Letter-Case-Conversion-Algorithms-Title-Case-Toggl.
    [Title case](https://en.wikipedia.org/wiki/Title_case) is a style where all words are capitalized. Officially, title case
    does not capitalize some words, such as very short words like "a" or "is", but for the purposes of this function, a general approach
    is taken where all words are capitalized regardless of length.
*/

/**
 * The titleCaseConversion function converts a string into a title case string.
 * @param {string} inputString The input string which can have any types of letter casing.
 * @returns {string} A string that is in title case.
 */
const titleCaseConversion = (inputString) => {
  if (inputString === '') return ''
  // Extract all space separated string.
  const stringCollections = inputString.split(' ').map(word => {
    let firstChar = ''
    // Get the [ASCII](https://en.wikipedia.org/wiki/ASCII) character code by the use charCodeAt method.
    const firstCharCode = word[0].charCodeAt()
    // If the ASCII character code lies between 97 to 122 it means they are in the lowercase so convert it.
    if (firstCharCode >= 97 && firstCharCode <= 122) {
      // Convert the case by use of the above explanation.
      firstChar += String.fromCharCode(firstCharCode - 32)
    } else {
      // Else store the characters without any modification.
      firstChar += word[0]
    }
    const newWordChar = word.slice(1).split('').map(char => {
      // Get the ASCII character code by the use charCodeAt method.
      const presentCharCode = char.charCodeAt()
      // If the ASCII character code lies between 65 to 90, it means they are in the uppercase so convert it.
      if (presentCharCode >= 65 && presentCharCode <= 90) {
        // Convert the case by use of the above explanation.
        return String.fromCharCode(presentCharCode + 32)
      }
      // Else return the characters without any modification.
      return char
    })
    // Return the first converted character and remaining character string.
    return firstChar + newWordChar.join('')
  })
  // Convert all words in a string and return it.
  return stringCollections.join(' ')
}

export { titleCaseConversion }
import { base64ToBuffer } from '../Base64ToArrayBuffer'
import { TextDecoder } from 'util'

describe('Base64ToArrayBuffer', () => {
  it('should decode "SGVsbG8sIHdvcmxkIQ==" as "Hello, world!"', () => {
    const testBase64String = 'SGVsbG8sIHdvcmxkIQ=='
    const buffer = base64ToBuffer(testBase64String)
    const decoder = new TextDecoder()
    const helloWorldString = decoder.decode(buffer)
    expect(helloWorldString).toBe('Hello, world!')
  })

  it('should decode base64 "Nxex6kQaWg==" as binary buffer [55,23,177,234,68,26,90]', () => {
    const testBase64String = 'Nxex6kQaWg=='
    const buffer = base64ToBuffer(testBase64String)
    const array = [...new Uint8Array(buffer)]
    expect(array).toEqual([55, 23, 177, 234, 68, 26, 90])
  })

  it('should decode base64 "AAECAwQFBgcICQ==" as binary buffer [0,1,2,3,4,5,6,7,8,9]', () => {
    const testBase64String = 'AAECAwQFBgcICQ=='
    const buffer = base64ToBuffer(testBase64String)
    const array = [...new Uint8Array(buffer)]
    expect(array).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  })
})
import { octalToDecimal } from '../OctToDecimal'

test('The Decimal representation of Octal number 56 is 46', () => {
  const res = octalToDecimal(56)
  expect(res).toBe(46)
})

test('The Decimal representation of Octal number 99 is 81', () => {
  const res = octalToDecimal(99)
  expect(res).toBe(81)
})

test('The Decimal representation of Octal number 17 is 15', () => {
  const res = octalToDecimal(17)
  expect(res).toBe(15)
})

test('The Decimal representation of Octal number 100 is 64', () => {
  const res = octalToDecimal(100)
  expect(res).toBe(64)
})

test('The Decimal representation of Octal number 0 is 0', () => {
  const res = octalToDecimal(0)
  expect(res).toBe(0)
})
import binaryToDecimal from '../BinaryToDecimal'

describe('BinaryToDecimal', () => {
  it('expects to return correct decimal value', () => {
    expect(binaryToDecimal('1000')).toBe(8)
  })

  it('expects to return correct hexadecimal value for more than one hex digit', () => {
    expect(binaryToDecimal('01101000')).toBe(104)
  })

  it('expects to return correct hexadecimal value for padding-required binary', () => {
    expect(binaryToDecimal('1000101')).toBe(69)
  })
})
import * as tc from '../TemperatureConversion.js'

describe('Testing Conversion of Celsius to fahrenheit', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToFahrenheit(10)
    expect(test1).toBe(50)
  })
})

describe('Testing Conversion of Celsius to kelvin', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToKelvin(15)
    expect(test1).toBe(288)
  })
})

describe('Testing Conversion of Celsius to Rankine', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToRankine(28)
    expect(test1).toBe(542)
  })
})

describe('Testing Conversion of Fahrenheit to Celsius', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToCelsius(134)
    expect(test1).toBe(57)
  })
})

describe('Testing Conversion of Fahrenheit to Kelvin', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToKelvin(125)
    expect(test1).toBe(325)
  })
})

describe('Testing Conversion of Fahrenheit to Rankine', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToRankine(10)
    expect(test1).toBe(470)
  })
})

describe('Testing Conversion of Kelvin to Celsius', () => {
  it('with Kelvin value', () => {
    const test1 = tc.kelvinToCelsius(100)
    expect(test1).toBe(-173)
  })
})

describe('Testing Conversion of Kelvin to Fahrenheit', () => {
  it('with Kelvin value', () => {
    const test1 = tc.kelvinToFahrenheit(20)
    expect(test1).toBe(-424)
  })
})

describe('Testing Conversion of Kelvin to Rankine', () => {
  it('with kelvin value', () => {
    const test1 = tc.kelvinToRankine(69)
    expect(test1).toBe(124)
  })
})
describe('Testing Conversion of Rankine to Celsius', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToCelsius(234)
    expect(test1).toBe(-143)
  })
})
describe('Testing Conversion of Rankine to Fahrenheit', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToFahrenheit(98)
    expect(test1).toBe(-362)
  })
})
describe('Testing Conversion of Rankine to Kelvin', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToKelvin(10)
    expect(test1).toBe(6)
  })
})
describe('Testing Conversion of Reamur to Celsius', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToCelsius(100)
    expect(test1).toBe(125)
  })
})
describe('Testing Conversion of Reamur to Fahrenheit', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToFahrenheit(100)
    expect(test1).toBe(257)
  })
})
describe('Testing Conversion of Reamur to Kelvin', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToKelvin(100)
    expect(test1).toBe(398)
  })
})
describe('Testing Conversion of Reamur to Rankine', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToRankine(100)
    expect(test1).toBe(717)
  })
})
import hexToBinary from '../HexToBinary'

describe('Testing hexToBinary', () => {
  it('expects throw error in invalid types', () => {
    expect(() => hexToBinary(false)).toThrowError()
    expect(() => hexToBinary(null)).toThrowError()
    expect(() => hexToBinary(23464)).toThrowError()
  })

  it('expects throw error in invalid hex', () => {
    expect(() => hexToBinary('Hello i am not a valid Hex')).toThrowError()
    expect(() => hexToBinary('Gf46f')).toThrowError()
    expect(() => hexToBinary('M')).toThrowError()
  })

  it('expects to return correct hexadecimal value', () => {
    expect(hexToBinary('8')).toBe('1000')
  })

  it('expects to return correct binary value for more than one hex digit', () => {
    expect(hexToBinary('EA')).toBe('11101010')
  })

  it('expects to test its robustness as it should be case-insensitive', () => {
    expect(hexToBinary('4d')).toBe('01001101')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(2)', () => {
    expect(hexToBinary('F')).toBe(parseInt('F', 16).toString(2))
  })
})
import { upperCaseConversion } from '../UpperCaseConversion'

describe(('Test the upperCaseConversion function'), () => {
  it('should return an empty string when the input is an empty string', () => {
    expect(upperCaseConversion('')).toEqual('')
  })

  it('should return an all-uppercase string when input is an all-uppercase string', () => {
    expect(upperCaseConversion('ALLUPPERCASE')).toEqual('ALLUPPERCASE')
  })

  it('should return an all-uppercase string when input is an all-uppercase string with spaces', () => {
    expect(upperCaseConversion('ALL UPPERCASE')).toEqual('ALL UPPERCASE')
  })

  it('should return an all-uppercase string when input is an all-uppercase string with punctuation', () => {
    expect(upperCaseConversion('ALL UPPER-CASE!')).toEqual('ALL UPPER-CASE!')
  })

  it('should return an all-uppercase string when input is an all-lowercase string', () => {
    expect(upperCaseConversion('lowercaseinput')).toEqual('LOWERCASEINPUT')
  })

  it('should return an all-uppercase string when input is an all-lowercase string with spaces', () => {
    expect(upperCaseConversion('lowercase input')).toEqual('LOWERCASE INPUT')
  })

  it('should return an all-uppercase string when input is an all-lowercase string with punctuation', () => {
    expect(upperCaseConversion('lower-case, input.')).toEqual('LOWER-CASE, INPUT.')
  })

  it('should return an all-uppercase string when input is an mixed-case string', () => {
    expect(upperCaseConversion('mixeDCaSeINPuT')).toEqual('MIXEDCASEINPUT')
  })

  it('should return an all-uppercase string when input is an mixed-case string with spaces', () => {
    expect(upperCaseConversion('mixeD CaSe INPuT')).toEqual('MIXED CASE INPUT')
  })

  it('should return an all-uppercase string when input is an mixed-case string with punctuation', () => {
    expect(upperCaseConversion('mixeD-CaSe INPuT!')).toEqual('MIXED-CASE INPUT!')
  })
})
import binaryToHex from '../BinaryToHex'

describe('BinaryToHex', () => {
  it('expects to return correct hexadecimal value', () => {
    expect(binaryToHex('1000')).toBe('8')
  })

  it('expects to return correct hexadecimal value for more than one hex digit', () => {
    expect(binaryToHex('11101010')).toBe('EA')
  })

  it('expects to return correct hexadecimal value for padding-required binary', () => {
    expect(binaryToHex('1001101')).toBe('4D')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(16)', () => {
    expect(binaryToHex('1111')).toBe(parseInt('1111', 2).toString(16).toUpperCase())
  })
})
import { DateDayDifference } from '../DateDayDifference'

test('The difference between 17/08/2002 & 10/10/2020 is 6630', () => {
  const res = DateDayDifference('17/08/2002', '10/10/2020')
  expect(res).toBe(6630)
})

test('The difference between 18/02/2001 & 16/03/2022 is 7696', () => {
  const res = DateDayDifference('18/02/2001', '16/03/2022')
  expect(res).toBe(7696)
})

test('The difference between 11/11/2011 & 12/12/2012 is 398', () => {
  const res = DateDayDifference('11/11/2011', '12/12/2012')
  expect(res).toBe(398)
})

test('The difference between 01/01/2001 & 16/03/2011 is 3727', () => {
  const res = DateDayDifference('01/01/2001', '16/03/2011')
  expect(res).toBe(3727)
})
import { LowerCaseConversion } from '../LowerCaseConversion'

test('The LowerCaseConversion of ApoLO is apolo', () => {
  const res = LowerCaseConversion('ApoLO')
  expect(res).toBe('apolo')
})

test('The LowerCaseConversion of WEB is web', () => {
  const res = LowerCaseConversion('WEB')
  expect(res).toBe('web')
})

test('The LowerCaseConversion of EaRTh is earth', () => {
  const res = LowerCaseConversion('EaRTh')
  expect(res).toBe('earth')
})

test('The LowerCaseConversion of TiGER is tiger', () => {
  const res = LowerCaseConversion('TiGER')
  expect(res).toBe('tiger')
})

test('The LowerCaseConversion of Cricket is cricket', () => {
  const res = LowerCaseConversion('Cricket')
  expect(res).toBe('cricket')
})
import { decimalToRoman } from '../DecimalToRoman'

describe('decimalToRoman', () => {
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(34)).toBe('XXXIV')
  })
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(28)).toBe('XXVIII')
  })
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(2021)).toBe('MMXXI')
  })
})
import { decimalToBinary } from '../DecimalToBinary'

test('The Binary representation of 35 is 100011', () => {
  const res = decimalToBinary(35)
  expect(res).toBe('100011')
})

test('The Binary representation of 1 is 1', () => {
  const res = decimalToBinary(1)
  expect(res).toBe('1')
})

test('The Binary representation of 1000 is 1111101000', () => {
  const res = decimalToBinary(1000)
  expect(res).toBe('1111101000')
})

test('The Binary representation of 2 is 10', () => {
  const res = decimalToBinary(2)
  expect(res).toBe('10')
})

test('The Binary representation of 17 is 10001', () => {
  const res = decimalToBinary(17)
  expect(res).toBe('10001')
})
import { decimalToHex } from '../DecimalToHex'

describe('DecimalToHex', () => {
  it('expects to return correct hexadecimal value', () => {
    expect(decimalToHex(255)).toBe('FF')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(16)', () => {
    expect(decimalToHex(32768)).toBe((32768).toString(16).toUpperCase())
  })

  it('expects to not handle negative numbers', () => {
    expect(decimalToHex(-32768)).not.toBe((-32768).toString(16).toUpperCase())
  })
})
import { convertArbitraryBase } from '../ArbitraryBase'

test('Check the answer of convertArbitraryBase(98, 0123456789, 01234567) is 142', () => {
  const res = convertArbitraryBase('98', '0123456789', '01234567')
  expect(res).toBe('142')
})

test('Check the answer of convertArbitraryBase(98, 0123456789, abcdefgh) is bec', () => {
  const res = convertArbitraryBase('98', '0123456789', 'abcdefgh')
  expect(res).toBe('bec')
})

test('Check the answer of convertArbitraryBase(98, 0123456789, 98765432) is 857', () => {
  const res = convertArbitraryBase('98', '0123456789', '98765432')
  expect(res).toBe('857')
})

test('Check the answer of convertArbitraryBase(129, 0123456789, 01234567) is 201', () => {
  const res = convertArbitraryBase('129', '0123456789', '01234567')
  expect(res).toBe('201')
})

test('Check the answer of convertArbitraryBase(112, 0123456789, 12345678) is 271', () => {
  const res = convertArbitraryBase('112', '0123456789', '12345678')
  expect(res).toBe('271')
})

test('Check the answer of convertArbitraryBase(112, 0123456789, 123456789) is 245', () => {
  const res = convertArbitraryBase('112', '0123456789', '123456789')
  expect(res).toBe('245')
})

test('Check the answer of convertArbitraryBase(111, 0123456789, abcdefgh) is bfh', () => {
  const res = convertArbitraryBase('111', '0123456789', 'abcdefgh')
  expect(res).toBe('bfh')
})
import { meterToFeet, feetToMeter } from '../MeterToFeetConversion'

describe('Testing conversion of Meter to Feet', () => {
  it('with feet value', () => {
    expect(meterToFeet(30.48)).toBe(100)
  })
})

describe('Testing conversion of Feet to Meter', () => {
  it('with feet value', () => {
    expect(feetToMeter(10)).toBe(3.048)
  })
})
import { RGBToHex } from '../RGBToHex'

test('The Hex format of RGB (225, 225, 225) is #ffffff', () => {
  const res = RGBToHex(255, 255, 255)
  expect(res).toBe('#ffffff')
})

test('The Hex format of RGB (190, 108, 217) is #be6cd9', () => {
  const res = RGBToHex(190, 108, 217)
  expect(res).toBe('#be6cd9')
})

test('The Hex format of RGB (255, 99, 71) is #ff6347', () => {
  const res = RGBToHex(255, 99, 71)
  expect(res).toBe('#ff6347')
})

test('The Hex format of RGB (100, 108, 217) is #646cd9', () => {
  const res = RGBToHex(100, 108, 217)
  expect(res).toBe('#646cd9')
})
import { approximatelyEqualHsv, hsvToRgb, rgbToHsv } from '../RgbHsvConversion'

describe('hsvToRgb', () => {
  // Expected RGB-values taken from https://www.rapidtables.com/convert/color/hsv-to-rgb.html
  it('should calculate the correct RGB values', () => {
    expect(hsvToRgb(0, 0, 0)).toEqual([0, 0, 0])
    expect(hsvToRgb(0, 0, 1)).toEqual([255, 255, 255])
    expect(hsvToRgb(0, 1, 1)).toEqual([255, 0, 0])
    expect(hsvToRgb(60, 1, 1)).toEqual([255, 255, 0])
    expect(hsvToRgb(120, 1, 1)).toEqual([0, 255, 0])
    expect(hsvToRgb(240, 1, 1)).toEqual([0, 0, 255])
    expect(hsvToRgb(300, 1, 1)).toEqual([255, 0, 255])
    expect(hsvToRgb(180, 0.5, 0.5)).toEqual([64, 128, 128])
    expect(hsvToRgb(234, 0.14, 0.88)).toEqual([193, 196, 224])
    expect(hsvToRgb(330, 0.75, 0.5)).toEqual([128, 32, 80])
  })
})

describe('rgbToHsv', () => {
  // "approximatelyEqualHsv" needed because of small deviations due to rounding for the RGB-values
  it('should calculate the correct HSV values', () => {
    expect(approximatelyEqualHsv(rgbToHsv(0, 0, 0), [0, 0, 0])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 255, 255), [0, 0, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 0, 0), [0, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 255, 0), [60, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(0, 255, 0), [120, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(0, 0, 255), [240, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 0, 255), [300, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(64, 128, 128), [180, 0.5, 0.5])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(193, 196, 224), [234, 0.14, 0.88])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(128, 32, 80), [330, 0.75, 0.5])).toEqual(true)
  })
})
import { DateToDay } from '../DateToDay'

test('The date 18/02/2001 is Monday', () => {
  const res = DateToDay('18/02/2001')
  expect(res).toBe('Monday')
})

test('The date 18/12/2020 is Friday', () => {
  const res = DateToDay('18/12/2020')
  expect(res).toBe('Friday')
})

test('The date 12/12/2012 is Wednesday', () => {
  const res = DateToDay('12/12/2012')
  expect(res).toBe('Wednesday')
})
test('The date 01/01/2001 is Friday', () => {
  const res = DateToDay('01/01/2001')
  expect(res).toBe('Friday')
})
import { decimalToOctal } from '../DecimalToOctal'

test('The Octal representation of 8 is 10', () => {
  const res = decimalToOctal(8)
  expect(res).toBe(10)
})

test('The Octal representation of 1 is 1', () => {
  const res = decimalToOctal(1)
  expect(res).toBe(1)
})

test('The Octal representation of 0 is 0', () => {
  const res = decimalToOctal(0)
  expect(res).toBe(0)
})

test('The Octal representation of 100 is 144', () => {
  const res = decimalToOctal(100)
  expect(res).toBe(144)
})

test('The Octal representation of 111 is 157', () => {
  const res = decimalToOctal(111)
  expect(res).toBe(157)
})
import { hexStringToRGB } from '../HexToRGB'

test('The RGB form of Hex String E1E1E1 is {r: 225, g: 225, b: 225}', () => {
  const res = hexStringToRGB('E1E1E1')
  expect(res).toEqual({ r: 225, g: 225, b: 225 })
})

test('The RGB form of Hex String 000000 is {r: 0, g: 0, b: 0}', () => {
  const res = hexStringToRGB('000000')
  expect(res).toEqual({ r: 0, g: 0, b: 0 })
})

test('The RGB form of Hex String 6CE1CD is {r: 108, g: 225, b: 205}', () => {
  const res = hexStringToRGB('6CE1CD')
  expect(res).toEqual({ r: 108, g: 225, b: 205 })
})
import { titleCaseConversion } from '../TitleCaseConversion'

describe(('Tests for the titleCaseConversion function'), () => {
  it('should return an empty string when the input is an empty string', () => {
    expect(titleCaseConversion('')).toEqual('')
  })

  it('should return the input string when the input string is a title case string', () => {
    expect(titleCaseConversion('A Proper Title Case String')).toEqual('A Proper Title Case String')
  })

  it('should return a title case string when input is an all-uppercase string', () => {
    expect(titleCaseConversion('ALL UPPER CASE')).toEqual('All Upper Case')
  })

  it('should return a title case string when input is a title case string of with spaces', () => {
    expect(titleCaseConversion('ALL UPPERCASE')).toEqual('All Uppercase')
  })

  it('should return a title case string when input is a title case string of with no spaces', () => {
    expect(titleCaseConversion('ALLUPPERCASE')).toEqual('Alluppercase')
  })

  it('should return a title case string when input is a title case string with punctuation', () => {
    expect(titleCaseConversion('All Title Case!')).toEqual('All Title Case!')
  })

  it('should return a title case string when input is an all-lowercase string with no spaces', () => {
    expect(titleCaseConversion('lowercaseinput')).toEqual('Lowercaseinput')
  })

  it('should return a title case string when input is an all-lowercase string with spaces', () => {
    expect(titleCaseConversion('lowercase input')).toEqual('Lowercase Input')
  })

  it('should return a title case string when input is an all-lowercase string with punctuation', () => {
    expect(titleCaseConversion('lower, case, input.')).toEqual('Lower, Case, Input.')
  })

  it('should return a title case string when input is an mixed-case string', () => {
    expect(titleCaseConversion('mixeD CaSe INPuT')).toEqual('Mixed Case Input')
  })

  it('should return a title case string when input is an mixed-case string with no spaces', () => {
    expect(titleCaseConversion('mixeDCaSeINPuT')).toEqual('Mixedcaseinput')
  })

  it('should return a title case string when input is an mixed-case string with punctuation', () => {
    expect(titleCaseConversion('mixeD, CaSe, INPuT!')).toEqual('Mixed, Case, Input!')
  })
})
import { bufferToBase64 } from '../ArrayBufferToBase64'
import { TextEncoder } from 'util'

describe('ArrayBufferToBase64', () => {
  it('should encode "Hello, world!" as "SGVsbG8sIHdvcmxkIQ=="', () => {
    const testString = 'Hello, world!'
    const encoder = new TextEncoder()
    const helloWorldBuffer = encoder.encode(testString)
    const result = bufferToBase64(helloWorldBuffer)
    expect(result).toBe('SGVsbG8sIHdvcmxkIQ==')
  })

  it('should encode binary buffer [55,23,177,234,68,26,90] as "Nxex6kQaWg=="', () => {
    const testBuffer = new Uint8Array([55, 23, 177, 234, 68, 26, 90])
    const result = bufferToBase64(testBuffer)
    expect(result).toBe('Nxex6kQaWg==')
  })

  it('should encode binary buffer [0,1,2,3,4,5,6,7,8,9] as "AAECAwQFBgcICQ=="', () => {
    const testBuffer = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    const result = bufferToBase64(testBuffer)
    expect(result).toBe('AAECAwQFBgcICQ==')
  })
})
import { RailwayTimeConversion } from '../RailwayTimeConversion'

test('The RailwayTimeConversion of 07:05:45AM is 07:05:45', () => {
  const res = RailwayTimeConversion('07:05:45AM')
  expect(res).toEqual('07:05:45')
})

test('The RailwayTimeConversion of 07:05:45PM is 19:05:45', () => {
  const res = RailwayTimeConversion('07:05:45PM')
  expect(res).toEqual('19:05:45')
})

test('The RailwayTimeConversion of 10:20:00AM is 10:20:00', () => {
  const res = RailwayTimeConversion('10:20:00AM')
  expect(res).toEqual('10:20:00')
})

test('The RailwayTimeConversion of 11:20:00PM is 23:20:00', () => {
  const res = RailwayTimeConversion('11:20:00PM')
  expect(res).toEqual('23:20:00')
})
import { romanToDecimal } from '../RomanToDecimal'

describe('romanToDecimal', () => {
  it('XXIIVV', () => {
    expect(romanToDecimal('XXIIVV')).toBe(28)
  })

  it('MDCCCIV', () => {
    expect(romanToDecimal('MDCCCIV')).toBe(1804)
  })

  it('XXIVI', () => {
    expect(romanToDecimal('XXIVI')).toBe(25)
  })
})
const pad = (num, padlen) => {
  const pad = new Array(1 + padlen).join(0)
  return (pad + num).slice(-pad.length)
}

const hexLookup = (bin) => {
  let binary = bin
  if (binary.length < 4) {
    binary = pad(binary, 4)
  }
  switch (binary) {
    case '0000': return '0'
    case '0001': return '1'
    case '0010': return '2'
    case '0011': return '3'
    case '0100': return '4'
    case '0101': return '5'
    case '0110': return '6'
    case '0111': return '7'
    case '1000': return '8'
    case '1001': return '9'
    case '1010': return 'A'
    case '1011': return 'B'
    case '1100': return 'C'
    case '1101': return 'D'
    case '1110': return 'E'
    case '1111': return 'F'
  }
}
const binaryToHex = (binaryString) => {
  /*
  Function for convertung Binary to Hex

  1. The conversion will start from Least Significant Digit (LSB) to the Most Significant Bit (MSB).
  2. We divide the bits into sections of 4-bits starting from LSB to MSB.
  3. If the MSB get less than 4 bits, then we pad 0s to the front of it.

  For Example:
  Binary String = '1001101'

  1. Divide it to 2 parts => ['100', '1101']
  2. Pad 0s the MSB so it'll be => ['0100', '1101']
  3. Use the lookup table and merge them, therefore the result is 4D.

  */

  let result = ''
  binaryString = binaryString.split('')
  for (let i = binaryString.length - 1; i >= 0; i = i - 4) {
    if (i >= 3) {
      result += hexLookup(binaryString.slice(i - 3, i + 1).join(''))
    } else {
      result += hexLookup(binaryString.slice(0, i + 1).join(''))
    }
  }
  return result.split('').reverse().join('')
}

export default binaryToHex
// About base64: https://en.wikipedia.org/wiki/Base64

/**
 * Converts an array of bytes to base64 encoding
 * @param {ArrayBuffer} binaryData An ArrayBuffer which represents an array of bytes
 * @returns {string} A string containing the base64 encoding of `binaryData`
 */
function bufferToBase64 (binaryData) {
  // The base64 encoding uses the following set of characters to encode any binary data as text
  const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  // Every 3 bytes translates to 4 base64 characters, if we have less than 3 bytes we must append '=' chars as padding
  const padding = 3 - (binaryData.byteLength % 3)
  // Create an instance of Uint8Array, to read from the binaryData array buffer
  const byteView = new Uint8Array(binaryData)
  let result = ''

  // Loop through all bytes in the buffer, in increments of 3 bytes
  for (let i = 0; i < byteView.byteLength; i += 3) {
    // Get the index for the next 4 base64 chars
    const char1 = (byteView[i] & 252) >> 2
    const char2 = ((byteView[i] & 3) << 4) + ((byteView[i + 1] & 240) >> 4)
    const char3 = ((byteView[i + 1] & 15) << 2) + ((byteView[i + 2] & 192) >> 6)
    const char4 = byteView[i + 2] & 63

    result +=
        base64Table[char1] +
        base64Table[char2] +
        base64Table[char3] +
        base64Table[char4]
  }

  // Add padding '=' chars if needed
  if (padding !== 3) {
    const paddedResult = result.slice(0, result.length - padding) + '='.repeat(padding)
    return paddedResult
  }

  return result
}

export { bufferToBase64 }
function RGBToHex (r, g, b) {
  if (
    typeof r !== 'number' ||
    typeof g !== 'number' ||
    typeof b !== 'number'
  ) {
    throw new TypeError('argument is not a Number')
  }

  const toHex = n => (n || '0').toString(16).padStart(2, '0')

  return `#${toHex(r)}${toHex(g)}${toHex(b)}`
}

export { RGBToHex }

// > RGBToHex(255, 255, 255)
// '#ffffff'

// > RGBToHex(255, 99, 71)
// '#ff6347'
/*
    DateDayDifference Method
    ------------------------
    DateDayDifference method calculates the number of days between two dates.

    Algorithm & Explanation : https://ncalculators.com/time-date/date-difference-calculator.htm
*/

// Internal method for make calculations easier
const isLeap = (year) => {
  if (year % 400 === 0) return true
  else if (year % 100 === 0) return false
  else if (year % 4 === 0) return true
  else return false
}
const DateToDay = (dd, mm, yyyy) => {
  return Math.floor((365 * (yyyy - 1)) + ((yyyy - 1) / 4) - ((yyyy - 1) / 100) + ((yyyy - 1) / 400) + dd + (((367 * mm) - 362) / 12) + (mm <= 2 ? 0 : isLeap(yyyy) ? -1 : -2))
}

const DateDayDifference = (date1, date2) => {
  // firstly, check that both input are string or not.
  if (typeof date1 !== 'string' && typeof date2 !== 'string') {
    return new TypeError('Argument is not a string.')
  }
  // extract the first date
  const [firstDateDay, firstDateMonth, firstDateYear] = date1.split('/').map((ele) => Number(ele))
  // extract the second date
  const [secondDateDay, secondDateMonth, secondDateYear] = date2.split('/').map((ele) => Number(ele))
  // check the both data are valid or not.
  if (firstDateDay < 0 || firstDateDay > 31 ||
        firstDateMonth > 12 || firstDateMonth < 0 ||
        secondDateDay < 0 || secondDateDay > 31 ||
        secondDateMonth > 12 || secondDateMonth < 0) {
    return new TypeError('Date is not valid.')
  }
  return Math.abs(DateToDay(secondDateDay, secondDateMonth, secondDateYear) - DateToDay(firstDateDay, firstDateMonth, firstDateYear))
}

// Example : DateDayDifference('17/08/2002', '10/10/2020') => 6630

export { DateDayDifference }
const binLookup = (key) => ({
  0: '0000',
  1: '0001',
  2: '0010',
  3: '0011',
  4: '0100',
  5: '0101',
  6: '0110',
  7: '0111',
  8: '1000',
  9: '1001',
  a: '1010',
  b: '1011',
  c: '1100',
  d: '1101',
  e: '1110',
  f: '1111'
}[key.toLowerCase()]) // select the binary number by valid hex key with the help javascript object

const hexToBinary = (hexString) => {
  if (typeof hexString !== 'string') {
    throw new TypeError('Argument is not a string type')
  }

  if (/[^\da-f]/gi.test(hexString)) {
    throw new Error('Argument is not a valid HEX code!')
  }
  /*
    Function for converting Hex to Binary

    1. We convert every hexadecimal bit to 4 binary bits
    2. Conversion goes by searching in the lookup table
  */

  return hexString.replace(
    /[0-9a-f]/gi,
    lexeme => binLookup(lexeme)
  )
}

export default hexToBinary
/*
    Decimal To Roman

    This algorithm take decimal number and convert to roman numeral according to standard form (https://en.wikipedia.org/wiki/Roman_numerals#Description)

    Algorithm & Explanation : https://www.rapidtables.com/convert/number/how-number-to-roman-numerals.html
*/

const values = {
  M: 1000,
  CM: 900,
  D: 500,
  CD: 400,
  C: 100,
  XC: 90,
  L: 50,
  XL: 40,
  X: 10,
  IX: 9,
  V: 5,
  IV: 4,
  I: 1
}

const orders = [
  'M',
  'CM',
  'D',
  'CD',
  'C',
  'XC',
  'L',
  'XL',
  'X',
  'IX',
  'V',
  'IV',
  'I'
]

function decimalToRoman (num) {
  let roman = ''
  for (const symbol of orders) {
    while (num >= values[symbol]) {
      roman += symbol
      num -= values[symbol]
    }
  }
  return roman
}

export { decimalToRoman }
const values = {
  I: 1,
  V: 5,
  X: 10,
  L: 50,
  C: 100,
  D: 500,
  M: 1000
}

export function romanToDecimal (romanNumber) {
  let prev = ' '

  let sum = 0

  let newPrev = 0
  for (let i = romanNumber.length - 1; i >= 0; i--) {
    const c = romanNumber.charAt(i)

    if (prev !== ' ') {
      newPrev = values[prev] > newPrev ? values[prev] : newPrev
    }

    const currentNum = values[c]
    if (currentNum >= newPrev) {
      sum += currentNum
    } else {
      sum -= currentNum
    }

    prev = c
  }
  return sum
}
// About base64: https://en.wikipedia.org/wiki/Base64

/**
 * Converts a base64 string to an array of bytes
 * @param {string} b64 A base64 string
 * @returns {ArrayBuffer} An ArrayBuffer representing the bytes encoded by the base64 string
 */
function base64ToBuffer (b64) {
  // The base64 encoding uses the following set of characters to encode any binary data as text
  const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  // Find the index of char '=' first occurrence
  const paddingIdx = b64.indexOf('=')
  // Remove padding chars from base64 string, if there are any
  const b64NoPadding = paddingIdx !== -1 ? b64.slice(0, paddingIdx) : b64
  // Calculate the length of the result buffer
  const bufferLength = Math.floor((b64NoPadding.length * 6) / 8)
  // Create the result buffer
  const result = new ArrayBuffer(bufferLength)
  // Create an instance of Uint8Array, to write to the `result` buffer
  const byteView = new Uint8Array(result)

  // Loop through all chars in the base64 string, in increments of 4 chars, and in increments of 3 bytes
  for (let i = 0, j = 0; i < b64NoPadding.length; i += 4, j += 3) {
    // Get the index of the next 4 base64 chars
    const b64Char1 = base64Table.indexOf(b64NoPadding[i])
    const b64Char2 = base64Table.indexOf(b64NoPadding[i + 1])
    let b64Char3 = base64Table.indexOf(b64NoPadding[i + 2])
    let b64Char4 = base64Table.indexOf(b64NoPadding[i + 3])

    // If base64 chars 3 and 4 don't exit, then set them to 0
    if (b64Char3 === -1) b64Char3 = 0
    if (b64Char4 === -1) b64Char4 = 0

    // Calculate the next 3 bytes
    const byte1 = (b64Char1 << 2) + ((b64Char2 & 48) >> 4)
    const byte2 = ((b64Char2 & 15) << 4) + ((b64Char3 & 60) >> 2)
    const byte3 = ((b64Char3 & 3) << 6) + b64Char4

    byteView[j] = byte1
    byteView[j + 1] = byte2
    byteView[j + 2] = byte3
  }

  return result
}

export { base64ToBuffer }
function octalToDecimal (num) {
  let dec = 0
  let base = 1
  while (num > 0) {
    const r = num % 10
    num = Math.floor(num / 10)
    dec = dec + (r * base)
    base = base * 8
  }
  return dec
}

export { octalToDecimal }

// > octalToDecimal(56)
// 46

// > octalToDecimal(2365)
// 1269
function hexToInt (hexNum) {
  const numArr = hexNum.split('') // converts number to array
  return numArr.map((item, index) => {
    switch (item) {
      case 'A': return 10
      case 'B': return 11
      case 'C': return 12
      case 'D': return 13
      case 'E': return 14
      case 'F': return 15
      default: return parseInt(item)
    }
  })
}

function hexToDecimal (hexNum) {
  const intItemsArr = hexToInt(hexNum)
  return intItemsArr.reduce((accumulator, current, index) => {
    return accumulator + (current * Math.pow(16, (intItemsArr.length - (1 + index))))
  }, 0)
}

export { hexToInt, hexToDecimal }
function intToHex (num) {
  switch (num) {
    case 10: return 'A'
    case 11: return 'B'
    case 12: return 'C'
    case 13: return 'D'
    case 14: return 'E'
    case 15: return 'F'
  }
  return num
}

function decimalToHex (num) {
  const hexOut = []
  while (num > 15) {
    hexOut.unshift(intToHex(num % 16))
    num = Math.floor(num / 16)
  }
  return intToHex(num) + hexOut.join('')
}

export { decimalToHex }
/*
    Explanation :- A user gives a string (it can be incomplete lowercase or
        partially in lowercase) and then the program converts it into a
        completely (all characters in uppercase) uppercase string. The
        logic we have used in the following program is: All the lowercase
        characters (a-z) has [ASCII](https://en.wikipedia.org/wiki/ASCII) value ranging from 97 to 122 and their
        corresponding uppercase characters (A-Z) have ASCII values 32
        lesser than them. For example a has an ASCII value of 97
        and A has an ASCII value of 65 (97 - 32). The same applies to other
        characters.
*/

/**
 * upperCaseConversion takes any case-style string and converts it to the uppercase-style string.
 * @param {string} inputString Any case style string
 * @returns {string} Uppercase string
 */
const upperCaseConversion = (inputString) => {
  // Take a string and split it into characters.
  const newString = inputString.split('').map(char => {
    // Get a character code by the use charCodeAt method.
    const presentCharCode = char.charCodeAt()
    // If the character code lies between 97 to 122, it means they are in the lowercase so convert it.
    if (presentCharCode >= 97 && presentCharCode <= 122) {
      // Convert the case by use of the above explanation.
      return String.fromCharCode(presentCharCode - 32)
    }
    // Else return the characters without any modification.
    return char
  })
  // After modification, with the help of the join method, join all the characters and return them.
  return newString.join('')
}

export { upperCaseConversion }
function decimalToOctal (num) {
  let oct = 0
  let c = 0
  while (num > 0) {
    const r = num % 8
    oct = oct + (r * Math.pow(10, c++))
    num = Math.floor(num / 8) // basically /= 8 without remainder if any
  }
  return oct
}

export { decimalToOctal }

// > decimalToOctal(2)
// 2

// > decimalToOctal(8)
// 10

// > decimalToOctal(65)
// 101

// > decimalToOctal(216)
// 330

// > decimalToOctal(512)
// 1000
/**
* Converts a string from one base to other
* @param {string} stringInBaseOne String in input base
* @param {string} baseOneCharacters Character set for the input base
* @param {string} baseTwoCharacters Character set for the output base
* @returns {string}
*/
const convertArbitraryBase = (stringInBaseOne, baseOneCharacters, baseTwoCharacters) => {
  if ([stringInBaseOne, baseOneCharacters, baseTwoCharacters].map(arg => typeof arg).some(type => type !== 'string')) {
    throw new TypeError('Only string arguments are allowed')
  }
  [baseOneCharacters, baseTwoCharacters].forEach(baseString => {
    const charactersInBase = [...baseString]
    if (charactersInBase.length !== new Set(charactersInBase).size) {
      throw new TypeError('Duplicate characters in character set are not allowed')
    }
  })
  const reversedStringOneChars = [...stringInBaseOne].reverse()
  const stringOneBase = baseOneCharacters.length
  let value = 0
  let placeValue = 1
  for (const digit of reversedStringOneChars) {
    const digitNumber = baseOneCharacters.indexOf(digit)
    if (digitNumber === -1) {
      throw new TypeError(`Not a valid character: ${digit}`)
    }
    value += (digitNumber * placeValue)
    placeValue *= stringOneBase
  }
  let stringInBaseTwo = ''
  const stringTwoBase = baseTwoCharacters.length
  while (value > 0) {
    const remainder = value % stringTwoBase
    stringInBaseTwo = baseTwoCharacters.charAt(remainder) + stringInBaseTwo
    value /= stringTwoBase
  }
  const baseTwoZero = baseTwoCharacters.charAt(0)
  return stringInBaseTwo.replace(new RegExp(`^${baseTwoZero}+`), '')
}

export { convertArbitraryBase }

// > convertArbitraryBase('98', '0123456789', '01234567')
// '142'

// > convertArbitraryBase('98', '0123456789', 'abcdefgh')
// 'bec'

// > convertArbitraryBase('129', '0123456789', '01234567')
// '201'
/*
    Explanation :- a user gives a String (it can be incomplete uppercase or
        partial uppercase) and then the program would convert it into a
        complete(all characters in lower case) lower case string. The
        logic we have used in the following program is: All the upper case
        characters (A-Z) has ASCII value ranging from 65 to 90 and their
        corresponding lower case characters (a-z) have ASCII values 32
        greater than them. For example A has an ASCII value of 65
        and a has an ASCII value of 97 (65+32). The same applies to other
        characters.
*/

/**
 * LowerCaseConversion takes any case-style string and converts it to the lower case-style string.
 * @param {String} inputString any case style string
 * @returns {String} lower case string
 */
const LowerCaseConversion = (inputString) => {
  // Take a string and split it into characters.
  const newString = inputString.split('').map(char => {
    // Get a character code by the use charCodeAt method.
    const presentCharCode = char.charCodeAt()
    // If the character code lies between 65 to 90 it means they are in the upper case so convert it.
    if (presentCharCode >= 65 && presentCharCode <= 90) {
      // Convert the case by use of the above explanation.
      return String.fromCharCode(presentCharCode + 32)
    }
    // Else return the characters without any modification.
    return char
  })
  // After modification, with the help of the join method, join all the characters and return them.
  return newString.join('')
}

export { LowerCaseConversion }
// This files has functions to convert different temperature units
// Functions take temperature value as a argument and returns corresponding converted value

const celsiusToFahrenheit = (celsius) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  return Math.round(((celsius) * 9 / 5) + 32)
}

const celsiusToKelvin = (celsius) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  return Math.round((celsius) + 273.15)
}

const celsiusToRankine = (celsius) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  return Math.round(((celsius) * 9 / 5) + 491.67)
}

const fahrenheitToCelsius = (fahrenheit) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  return Math.round(((fahrenheit) - 32) * 5 / 9)
}

const fahrenheitToKelvin = (fahrenheit) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  return Math.round((((fahrenheit) - 32) * 5 / 9) + 273.15)
}

const fahrenheitToRankine = (fahrenheit) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  return Math.round((fahrenheit) + 459.67)
}

const kelvinToCelsius = (kelvin) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  return Math.round((kelvin) - 273.15)
}

const kelvinToFahrenheit = (kelvin) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  return Math.round((((kelvin) - 273.15) * 9 / 5) + 32)
}

const kelvinToRankine = (kelvin) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  return Math.round(((kelvin) * 9 / 5))
}

const rankineToCelsius = (rankine) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  return Math.round(((rankine) - 491.67) * 5 / 9)
}

const rankineToFahrenheit = (rankine) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  return Math.round((rankine) - 459.67)
}

const rankineToKelvin = (rankine) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  return Math.round(((rankine) * 5 / 9))
}

const reaumurToKelvin = (reaumur) => {
  // Reference:- http://www.csgnetwork.com/temp2conv.html
  return Math.round(((reaumur) * 1.25 + 273.15))
}

const reaumurToFahrenheit = (reaumur) => {
  // Reference:- http://www.csgnetwork.com/temp2conv.html
  return Math.round(((reaumur) * 2.25 + 32))
}

const reaumurToCelsius = (reaumur) => {
  // Reference:- http://www.csgnetwork.com/temp2conv.html
  return Math.round(((reaumur) * 1.25))
}

const reaumurToRankine = (reaumur) => {
  // Reference:- http://www.csgnetwork.com/temp2conv.html
  return Math.round(((reaumur) * 2.25 + 32 + 459.67))
}

export {
  celsiusToFahrenheit, celsiusToKelvin, celsiusToRankine,
  fahrenheitToCelsius, fahrenheitToKelvin, fahrenheitToRankine,
  kelvinToCelsius, kelvinToFahrenheit, kelvinToRankine,
  rankineToCelsius, rankineToFahrenheit, rankineToKelvin,
  reaumurToCelsius, reaumurToFahrenheit, reaumurToKelvin, reaumurToRankine
}
/*
                    DateToDay Method
                    ----------------
    The DateToDay method takes a date in string format and
    returns the name of a day. The approach behind this method
    is very simple, we first take a string date and check
    whether their date is valid or not, if the date is valid
    then we do this But apply the algorithm shown below. The
    algorithm shown below gives us the number of the day and
    finally converts it to the name of the day.

    Algorithm & Explanation : https://cs.uwaterloo.ca/~alopez-o/math-faq/node73.html
*/

// March is taken as the first month of the year.
const calcMonthList = {
  1: 11,
  2: 12,
  3: 1,
  4: 2,
  5: 3,
  6: 4,
  7: 5,
  8: 6,
  9: 7,
  10: 8,
  11: 9,
  12: 10
}

// show the week day in a number : Sunday - Saturday => 0 - 6
const daysNameList = { // weeks-day
  0: 'Sunday',
  1: 'Monday',
  2: 'Tuesday',
  3: 'Wednesday',
  4: 'Thursday',
  5: 'Friday',
  6: 'Saturday'
}

const DateToDay = (date) => {
  // firstly, check that input is a string or not.
  if (typeof date !== 'string') {
    return new TypeError('Argument is not a string.')
  }
  // extract the date
  const [day, month, year] = date.split('/').map((x) => Number(x))
  // check the data are valid or not.
  if (day < 0 || day > 31 || month > 12 || month < 0) {
    return new TypeError('Date is not valid.')
  }
  // divide year to century and yearDigit value.
  const yearDigit = (year % 100)
  const century = Math.floor(year / 100)
  // Apply the algorithm shown above
  const weekDay = Math.abs((day + Math.floor((2.6 * calcMonthList[month]) - 0.2) - (2 * century) + yearDigit + Math.floor(yearDigit / 4) + Math.floor(century / 4)) % 7)
  // return the weekDay name.
  return daysNameList[weekDay]
}

// Example : DateToDay("18/12/2020") => Friday

export { DateToDay }
function hexStringToRGB (hexString) {
  let r = hexString.substring(0, 2)
  let g = hexString.substring(2, 4)
  let b = hexString.substring(4, 6)

  r = parseInt(r, 16)
  g = parseInt(g, 16)
  b = parseInt(b, 16)
  const obj = { r, g, b }

  return obj
}

export { hexStringToRGB }

// > hexStringToRGB('ffffff')
// { r: 255, g: 255, b: 255 }
/*
 * The RGB color model is an additive color model in which red, green, and blue light are added
 * together in various ways to reproduce a broad array of colors. The name of the model comes from
 * the initials of the three additive primary colors, red, green, and blue. Meanwhile, the HSV
 * representation models how colors appear under light. In it, colors are represented using three
 * components: hue, saturation and (brightness-)value. This file provides functions for converting
 * colors from one representation to the other. (description adapted from
 * https://en.wikipedia.org/wiki/RGB_color_model and https://en.wikipedia.org/wiki/HSL_and_HSV).
 */

/**
 * Conversion from the HSV-representation to the RGB-representation.
 *
 * @param hue Hue of the color.
 * @param saturation Saturation of the color.
 * @param value Brightness-value of the color.
 * @return The tuple of RGB-components.
 */
export function hsvToRgb (hue, saturation, value) {
  if (hue < 0 || hue > 360) {
    throw new Error('hue should be between 0 and 360')
  }

  if (saturation < 0 || saturation > 1) {
    throw new Error('saturation should be between 0 and 1')
  }

  if (value < 0 || value > 1) {
    throw new Error('value should be between 0 and 1')
  }

  const chroma = value * saturation
  const hueSection = hue / 60
  const secondLargestComponent = chroma * (1 - Math.abs(hueSection % 2 - 1))
  const matchValue = value - chroma

  return getRgbBySection(hueSection, chroma, matchValue, secondLargestComponent)
}

/**
 * Conversion from the RGB-representation to the HSV-representation.
 *
 * @param red Red-component of the color.
 * @param green Green-component of the color.
 * @param blue Blue-component of the color.
 * @return The tuple of HSV-components.
 */
export function rgbToHsv (red, green, blue) {
  if (red < 0 || red > 255) {
    throw new Error('red should be between 0 and 255')
  }

  if (green < 0 || green > 255) {
    throw new Error('green should be between 0 and 255')
  }

  if (blue < 0 || blue > 255) {
    throw new Error('blue should be between 0 and 255')
  }

  const dRed = red / 255
  const dGreen = green / 255
  const dBlue = blue / 255
  const value = Math.max(Math.max(dRed, dGreen), dBlue)
  const chroma = value - Math.min(Math.min(dRed, dGreen), dBlue)
  const saturation = value === 0 ? 0 : chroma / value
  let hue

  if (chroma === 0) {
    hue = 0
  } else if (value === dRed) {
    hue = 60 * ((dGreen - dBlue) / chroma)
  } else if (value === dGreen) {
    hue = 60 * (2 + (dBlue - dRed) / chroma)
  } else {
    hue = 60 * (4 + (dRed - dGreen) / chroma)
  }

  hue = (hue + 360) % 360

  return [hue, saturation, value]
}

export function approximatelyEqualHsv (hsv1, hsv2) {
  const bHue = Math.abs(hsv1[0] - hsv2[0]) < 0.2
  const bSaturation = Math.abs(hsv1[1] - hsv2[1]) < 0.002
  const bValue = Math.abs(hsv1[2] - hsv2[2]) < 0.002

  return bHue && bSaturation && bValue
}

function getRgbBySection (hueSection, chroma, matchValue, secondLargestComponent) {
  function convertToInt (input) {
    return Math.round(255 * input)
  }

  let red
  let green
  let blue

  if (hueSection >= 0 && hueSection <= 1) {
    red = convertToInt(chroma + matchValue)
    green = convertToInt(secondLargestComponent + matchValue)
    blue = convertToInt(matchValue)
  } else if (hueSection > 1 && hueSection <= 2) {
    red = convertToInt(secondLargestComponent + matchValue)
    green = convertToInt(chroma + matchValue)
    blue = convertToInt(matchValue)
  } else if (hueSection > 2 && hueSection <= 3) {
    red = convertToInt(matchValue)
    green = convertToInt(chroma + matchValue)
    blue = convertToInt(secondLargestComponent + matchValue)
  } else if (hueSection > 3 && hueSection <= 4) {
    red = convertToInt(matchValue)
    green = convertToInt(secondLargestComponent + matchValue)
    blue = convertToInt(chroma + matchValue)
  } else if (hueSection > 4 && hueSection <= 5) {
    red = convertToInt(secondLargestComponent + matchValue)
    green = convertToInt(matchValue)
    blue = convertToInt(chroma + matchValue)
  } else {
    red = convertToInt(chroma + matchValue)
    green = convertToInt(matchValue)
    blue = convertToInt(secondLargestComponent + matchValue)
  }

  return [red, green, blue]
}
function decimalToBinary (num) {
  const bin = []
  while (num > 0) {
    bin.unshift(num % 2)
    num >>= 1 // basically /= 2 without remainder if any
  }
  return bin.join('')
}

export { decimalToBinary }

// > decimalToBinary(2)
// '10'

// > decimalToBinary(7)
// '111'

// > decimalToBinary(35)
// '100011'
export default function binaryToDecimal (binaryString) {
  let decimalNumber = 0
  const binaryDigits = binaryString.split('').reverse() // Splits the binary number into reversed single digits
  binaryDigits.forEach((binaryDigit, index) => {
    decimalNumber += binaryDigit * (Math.pow(2, index)) // Summation of all the decimal converted digits
  })
  return decimalNumber
}
/*
 * Problem Statement: Generate all distinct permutations of a an array (all permutations should be in sorted order);
 *
 * What is permutations?
 * - Permutation means possible arrangements in a set (here it is an array);
 *
 * Reference to know more about permutations:
 * - https://www.britannica.com/science/permutation
 *
 */

const swap = (arr, i, j) => {
  const newArray = [...arr];

  [newArray[i], newArray[j]] = [newArray[j], newArray[i]] // Swapping elements ES6 way

  return newArray
}

const permutations = arr => {
  const P = []
  const permute = (arr, low, high) => {
    if (low === high) {
      P.push([...arr])
      return P
    }
    for (let i = low; i <= high; i++) {
      arr = swap(arr, low, i)
      permute(arr, low + 1, high)
    }
    return P
  }
  return permute(arr, 0, arr.length - 1)
}

export { permutations }
class NQueen {
  constructor (size) {
    this.board = new Array(size).fill('.').map(() => new Array(size).fill('.'))
    this.size = size
    this.solutionCount = 0
  }

  isValid ([row, col]) {
    // function to check if the placement of the queen in the given location is valid

    // checking the left of the current row
    for (let i = 0; i < col; i++) {
      if (this.board[row][i] === 'Q') return false
    }

    // checking the upper left diagonal
    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {
      if (this.board[i][j] === 'Q') return false
    }

    // checking the lower left diagonal
    for (let i = row, j = col; j >= 0 && i < this.size; i++, j--) {
      if (this.board[i][j] === 'Q') return false
    }

    return true
  }

  placeQueen (row, col) {
    this.board[row][col] = 'Q'
  }

  removeQueen (row, col) {
    this.board[row][col] = '.'
  }

  solve (col = 0) {
    if (col >= this.size) {
      this.solutionCount++
      return true
    }

    for (let i = 0; i < this.size; i++) {
      if (this.isValid([i, col])) {
        this.placeQueen(i, col)
        this.solve(col + 1)
        this.removeQueen(i, col)
      }
    }

    return false
  }

  printBoard (output = value => console.log(value)) {
    if (!output._isMockFunction) {
      output('\n')
    }
    for (const row of this.board) {
      output(row)
    }
  }
}

export { NQueen }
import { Combinations } from '../AllCombinationsOfSizeK'

describe('AllCombinationsOfSizeK', () => {
  it('should return 3x2 matrix solution for n = 3 and k = 2', () => {
    const test1 = new Combinations(3, 2)
    expect(test1.findCombinations()).toEqual([[1, 2], [1, 3], [2, 3]])
  })

  it('should return 6x2 matrix solution for n = 4 and k = 2', () => {
    const test2 = new Combinations(4, 2)
    expect(test2.findCombinations()).toEqual([[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]])
  })
})
import { NQueen } from '../NQueen'

describe('NQueen', () => {
  it('should return 2 solutions for 4x4 size board', () => {
    const _4Queen = new NQueen(4)
    _4Queen.solve()
    expect(_4Queen.solutionCount).toEqual(2)
  })

  it('should return 92 solutions for 8x8 size board', () => {
    const _8Queen = new NQueen(8)
    _8Queen.solve()
    expect(_8Queen.solutionCount).toEqual(92)
  })
})
import { OpenKnightTour } from '../KnightTour'

describe('OpenKnightTour', () => {
  it('OpenKnightTour(5)', () => {
    const KT = new OpenKnightTour(5)
    expect(KT.board).toEqual([
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0]
    ])

    KT.solve()
    expect(KT.board).toEqual([
      [19, 4, 15, 10, 25],
      [14, 9, 18, 5, 16],
      [1, 20, 3, 24, 11],
      [8, 13, 22, 17, 6],
      [21, 2, 7, 12, 23]
    ])
  })
})
import { Sudoku } from '../Sudoku'

const data = [
  [3, 0, 6, 5, 0, 8, 4, 0, 0],
  [5, 2, 0, 0, 0, 0, 0, 0, 0],
  [0, 8, 7, 0, 0, 0, 0, 3, 1],
  [0, 0, 3, 0, 1, 0, 0, 8, 0],
  [9, 0, 0, 8, 6, 3, 0, 0, 5],
  [0, 5, 0, 0, 9, 0, 6, 0, 0],
  [1, 3, 0, 0, 0, 0, 2, 5, 0],
  [0, 0, 0, 0, 0, 0, 0, 7, 4],
  [0, 0, 5, 2, 0, 6, 3, 0, 0]
]

const solved = [
  [3, 1, 6, 5, 7, 8, 4, 9, 2],
  [5, 2, 9, 1, 3, 4, 7, 6, 8],
  [4, 8, 7, 6, 2, 9, 5, 3, 1],
  [2, 6, 3, 4, 1, 5, 9, 8, 7],
  [9, 7, 4, 8, 6, 3, 1, 2, 5],
  [8, 5, 1, 7, 9, 2, 6, 4, 3],
  [1, 3, 8, 9, 4, 7, 2, 5, 6],
  [6, 9, 2, 3, 5, 1, 8, 7, 4],
  [7, 4, 5, 2, 8, 6, 3, 1, 9]
]

describe('Sudoku', () => {
  it('should create a valid board successfully', () => {
    // we deliberately want to check whether this constructor call fails or not
    // eslint-disable-next-line no-new
    expect(() => { new Sudoku(data) }).not.toThrow()
  })

  it('should find an empty cell', () => {
    const board = new Sudoku(data)
    const emptyCell = board.findEmptyCell()
    expect(emptyCell).not.toEqual([-1, -1])
  })

  it('should solve the board successfully', () => {
    const board = new Sudoku(data)
    board.solve()

    // should not have empty cells anymore
    const emptyCell = board.findEmptyCell()
    expect(emptyCell).toEqual([-1, -1])

    // solved board should match our expectation
    for (let i = 0; i < 9; i++) {
      const section = board.getSection(i, [0, 9])
      expect(section).toEqual(solved[i])
    }
  })
})
import { permutations } from '../GeneratePermutations'

describe('Permutations', () => {
  it('Permutations of [1, 2, 3]', () => {
    expect(permutations([1, 2, 3])).toEqual([
      [1, 2, 3],
      [1, 3, 2],
      [2, 1, 3],
      [2, 3, 1],
      [3, 1, 2],
      [3, 2, 1]
    ])
  })
})
import { RatInAMaze } from '../RatInAMaze'

describe('RatInAMaze', () => {
  it('should fail for non-arrays', () => {
    const values = [undefined, null, {}, 42, 'hello, world']

    for (const value of values) {
      // we deliberately want to check whether this constructor call fails or not
      // eslint-disable-next-line no-new
      expect(() => { new RatInAMaze(value) }).toThrow()
    }
  })

  it('should fail for an empty array', () => {
    // we deliberately want to check whether this constructor call fails or not
    // eslint-disable-next-line no-new
    expect(() => { new RatInAMaze([]) }).toThrow()
  })

  it('should fail for a non-square array', () => {
    const array = [
      [0, 0, 0],
      [0, 0]
    ]

    // we deliberately want to check whether this constructor call fails or not
    // eslint-disable-next-line no-new
    expect(() => { new RatInAMaze(array) }).toThrow()
  })

  it('should fail for arrays containing invalid values', () => {
    const values = [[[2]], [['a']]]

    for (const value of values) {
      // we deliberately want to check whether this constructor call fails or not
      // eslint-disable-next-line no-new
      expect(() => { new RatInAMaze(value) }).toThrow()
    }
  })

  it('should work for a single-cell maze', () => {
    const maze = new RatInAMaze([[1]])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('')
  })

  it('should work for a single-cell maze that can not be solved', () => {
    const maze = new RatInAMaze([[0]])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })

  it('should work for a simple 3x3 maze', () => {
    const maze = new RatInAMaze([[1, 1, 0], [0, 1, 0], [0, 1, 1]])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('RDDR')
  })

  it('should work for a simple 2x2 that can not be solved', () => {
    const maze = new RatInAMaze([[1, 0], [0, 1]])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })

  it('should work for a more complex maze', () => {
    const maze = new RatInAMaze([
      [1, 1, 1, 1, 1, 0, 0],
      [0, 0, 0, 0, 1, 0, 0],
      [1, 1, 1, 0, 1, 0, 0],
      [1, 0, 1, 0, 1, 0, 0],
      [1, 0, 1, 1, 1, 0, 0],
      [1, 0, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 1, 1, 1]
    ])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('RRRRDDDDLLUULLDDDDRRRRRR')
  })

  it('should work for a more complex maze that can not be solved', () => {
    const maze = new RatInAMaze([
      [1, 1, 1, 1, 1, 0, 1],
      [0, 0, 0, 0, 1, 0, 1],
      [1, 1, 1, 0, 1, 0, 1],
      [1, 0, 1, 0, 1, 0, 1],
      [1, 0, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 1, 1, 1]
    ])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })
})
import { sumOfSubset } from '../SumOfSubset'

describe('SumOfSubset', () => {
  it('should return the subsets that add up to the given number', () => {
    // W = [2, 5, 7, 8, 12, 16, 23, 40]
    // K = 25

    const nums = [2, 5, 7, 8, 12, 16, 23, 40]

    const subsets = sumOfSubset(nums, [], 0, 0, 25)

    expect(subsets).toEqual([
      [2, 7, 16],
      [2, 23],
      [5, 8, 12]
    ])
  })
})
class Sudoku {
  // Sudoku Class to hold the board and related functions
  constructor (board) {
    this.board = board
  }

  findEmptyCell () {
    // Find a empty cell in the board (returns [-1, -1] if all cells are filled)
    for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        if (this.board[i][j] === 0) return [i, j]
      }
    }
    return [-1, -1]
  }

  check ([y, x], value) {
    // checks if the value to be added in the board is an acceptable value for the cell

    // checking through the row
    for (let i = 0; i < 9; i++) {
      if (this.board[i][x] === value) return false
    }
    // checking through the column
    for (let i = 0; i < 9; i++) {
      if (this.board[y][i] === value) return false
    }

    // checking through the 3x3 block of the cell
    const secRow = Math.floor(y / 3)
    const secCol = Math.floor(x / 3)
    for (let i = (secRow * 3); i < ((secRow * 3) + 3); i++) {
      for (let j = (secCol * 3); j < ((secCol * 3) + 3); j++) {
        if (y !== i && x !== j && this.board[i][j] === value) return false
      }
    }

    return true
  }

  solve () {
    const [y, x] = this.findEmptyCell()

    // checking if the board is complete
    if (y === -1 && x === -1) return true

    for (let val = 1; val < 10; val++) {
      if (this.check([y, x], val)) {
        this.board[y][x] = val
        if (this.solve()) return true
        // backtracking if the board cannot be solved using current configuration
        this.board[y][x] = 0
      }
    }
    // returning false the board cannot be solved using current configuration
    return false
  }

  getSection (row, [start, end]) {
    return this.board[row].slice(start, end)
  }

  printBoard (output = (...v) => console.log(...v)) {
    // helper function to display board
    for (let i = 0; i < 9; i++) {
      if (i % 3 === 0 && i !== 0) {
        output('- - - - - - - - - - - -')
      }
      output(
        ...this.getSection(i, [0, 3]), ' | ',
        ...this.getSection(i, [3, 6]), ' | ',
        ...this.getSection(i, [6, 9]))
    }
  }
}

export { Sudoku }
/*
 * Problem Statement:
 * - Given a NxN grid, find whether rat in cell [0, 0] can reach the target in cell [N-1, N-1]
 * - The grid is represented as an array of rows. Each row is represented as an array of 0 or 1 values.
 * - A cell with value 0 can not be moved through. Value 1 means the rat can move here.
 * - The rat can not move diagonally.
 *
 * Reference for this problem: https://www.geeksforgeeks.org/rat-in-a-maze-backtracking-2/
 *
 * Based on the original implementation contributed by Chiranjeev Thapliyal (https://github.com/chiranjeev-thapliyal).
 */

/**
 * Checks if the given grid is valid.
 *
 * A grid needs to satisfy these conditions:
 * - must not be empty
 * - must be a square
 * - must not contain values other than {@code 0} and {@code 1}
 *
 * @param grid The grid to check.
 * @throws TypeError When the given grid is invalid.
 */
function validateGrid (grid) {
  if (!Array.isArray(grid) || grid.length === 0) throw new TypeError('Grid must be a non-empty array')

  const allRowsHaveCorrectLength = grid.every(row => row.length === grid.length)
  if (!allRowsHaveCorrectLength) throw new TypeError('Grid must be a square')

  const allCellsHaveValidValues = grid.every(row => {
    return row.every(cell => cell === 0 || cell === 1)
  })
  if (!allCellsHaveValidValues) throw new TypeError('Grid must only contain 0s and 1s')
}

function isSafe (grid, x, y) {
  const n = grid.length
  return x >= 0 && x < n && y >= 0 && y < n && grid[y][x] === 1
}

/**
 * Attempts to calculate the remaining path to the target.
 *
 * @param grid The full grid.
 * @param x The current X coordinate.
 * @param y The current Y coordinate.
 * @param solution The current solution matrix.
 * @param path The path we took to get from the source cell to the current location.
 * @returns {string|boolean} Either the path to the target cell or false.
 */
function getPathPart (grid, x, y, solution, path) {
  const n = grid.length

  // are we there yet?
  if (x === n - 1 && y === n - 1 && grid[y][x] === 1) {
    solution[y][x] = 1
    return path
  }

  // did we step on a 0 cell or outside the grid?
  if (!isSafe(grid, x, y)) return false

  // are we walking onto an already-marked solution coordinate?
  if (solution[y][x] === 1) return false

  // none of the above? let's dig deeper!

  // mark the current coordinates on the solution matrix
  solution[y][x] = 1

  // attempt to move right
  const right = getPathPart(grid, x + 1, y, solution, path + 'R')
  if (right) return right

  // right didn't work: attempt to move down
  const down = getPathPart(grid, x, y + 1, solution, path + 'D')
  if (down) return down

  // down didn't work: attempt to move up
  const up = getPathPart(grid, x, y - 1, solution, path + 'U')
  if (up) return up

  // up didn't work: attempt to move left
  const left = getPathPart(grid, x - 1, y, solution, path + 'L')
  if (left) return left

  // no direction was successful: remove this cell from the solution matrix and backtrack
  solution[y][x] = 0
  return false
}

function getPath (grid) {
  // grid dimensions
  const n = grid.length

  // prepare solution matrix
  const solution = []
  for (let i = 0; i < n; i++) {
    const row = Array(n)
    row.fill(0)
    solution[i] = row
  }

  return getPathPart(grid, 0, 0, solution, '')
}

/**
 * Creates an instance of the "rat in a maze" based on a given grid (maze).
 */
export class RatInAMaze {
  constructor (grid) {
    // first, let's do some error checking on the input
    validateGrid(grid)

    // attempt to solve the maze now - all public methods only query the result state later
    const solution = getPath(grid)

    if (solution !== false) {
      this.path = solution
      this.solved = true
    } else {
      this.path = ''
      this.solved = false
    }
  }
}
/*
  Problem: Given two numbers, n and k, make all unique combinations of k numbers from 1 to n and in sorted order

  What is combinations?
  - Combinations is selecting items from a collections without considering order of selection

  Example:
  - We have an apple, a banana, and a jackfruit
  - We have three objects, and need to choose two items, then combinations will be

  1. Apple & Banana
  2. Apple & Jackfruit
  3. Banana & Jackfruit

  To read more about combinations, you can visit the following link:
  - https://betterexplained.com/articles/easy-permutations-and-combinations/

  Solution:
  - We will be using backtracking to solve this questions
  - Take one element, and make all them combinations for k-1 elements
  - Once we get all combinations of that element, pop it and do same for next element
*/

class Combinations {
  constructor (n, k) {
    this.n = n
    this.k = k
    this.current = [] // will be used for storing current combination
    this.combinations = []
  }

  findCombinations (high = this.n, total = this.k, low = 1) {
    if (total === 0) {
      this.combinations.push([...this.current])
      return this.combinations
    }
    for (let i = low; i <= high; i++) {
      this.current.push(i)
      this.findCombinations(high, total - 1, i + 1)
      this.current.pop()
    }
    return this.combinations
  }
}

export { Combinations }
/*
 *
 *  Sum of Subset problem
 *
 *  Given an ordered set W of non-negative integers and a value K,
 *  determine all possible subsets from the given set W whose sum
 *  of its elements equals to the given value K.
 *
 *  More info: https://www.geeksforgeeks.org/subset-sum-backtracking-4/
 */

/*
 * @param {number[]} set Original set of numbers
 * @param {number[]} subset Subset being evaluated
 * @param {number} setIndex Index from set of last element in subset
 * @param {number} Sum of elements from subset
 * @param {targetSum} The target sum on which the subset sum is compared to
 * @returns {number[][]} Subsets whose elements add up to targetSum
 */
const sumOfSubset = (set, subset, setindex, sum, targetSum) => {
  // Base case where the subset sum is equal to target sum
  // Evaluation of following subsets on this path will always add up to
  // greater than targetSum, so no need to continue
  if (sum === targetSum) return [subset]

  // This and following subsets on this path will always add up to
  // greater than targetSum, so no need to continue
  if (sum > targetSum) return []

  // Initialize results array. Will contain only valid subsets
  let results = []

  // Slice gets from the set all the elements at the right of the last element
  // to be evaluated (last element of subset)
  // forEach iterated on the resulting array
  set.slice(setindex).forEach((num, index) => {
    // The next subset to be evaluated, current subset plus next element
    const nextSubset = [...subset, num]

    // Next index from the set. Current set index plus iteration index
    // index starts at 0, so a + 1 is required
    const nextSetIndex = setindex + index + 1

    // Sum of elements from the next subset to be evaluated
    const nextSum = sum + num

    // Call recursively the sumOfSubset for the nextSubset
    const subsetResult = sumOfSubset(
      set,
      nextSubset,
      nextSetIndex,
      nextSum,
      targetSum
    )

    // Concat the recursive result with current result array
    results = [...results, ...subsetResult]
  })

  // Return results
  return results
}

export { sumOfSubset }
// Wikipedia: https://en.wikipedia.org/wiki/Knight%27s_tour

class OpenKnightTour {
  constructor (size) {
    this.board = new Array(size).fill(0).map(() => new Array(size).fill(0))
    this.size = size
  }

  getMoves ([i, j]) {
    // helper function to get the valid moves of the knight from the current position
    const moves = [
      [i + 2, j - 1],
      [i + 2, j + 1],
      [i - 2, j - 1],
      [i - 2, j + 1],
      [i + 1, j - 2],
      [i + 1, j + 2],
      [i - 1, j - 2],
      [i - 1, j + 2]
    ]

    return moves.filter(([y, x]) => y >= 0 && y < this.size && x >= 0 && x < this.size)
  }

  isComplete () {
    // helper function to check if the board is complete
    return !this.board.map(row => row.includes(0)).includes(true)
  }

  solve () {
    // function to find the solution for the given board
    for (let i = 0; i < this.size; i++) {
      for (let j = 0; j < this.size; j++) {
        if (this.solveHelper([i, j], 0)) return true
      }
    }
    return false
  }

  solveHelper ([i, j], curr) {
    // helper function for the main computation
    if (this.isComplete()) return true

    for (const [y, x] of this.getMoves([i, j])) {
      if (this.board[y][x] === 0) {
        this.board[y][x] = curr + 1
        if (this.solveHelper([y, x], curr + 1)) return true
        // backtracking
        this.board[y][x] = 0
      }
    }
    return false
  }

  printBoard (output = value => console.log(value)) {
    // utility function to display the board
    for (const row of this.board) {
      let string = ''
      for (const elem of row) {
        string += elem + '\t'
      }
      output(string)
    }
  }
}

export { OpenKnightTour }
/*
Conway's Game of Life
The Game of Life is a cellular automaton devised by the British mathematician John Horton Conway in 1970. The universe of the Game of Life is an infinite, two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead, (or populated and unpopulated, respectively). Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur:
  1. Any live cell with two or three live neighbours survives.
  2. Any dead cell with three live neighbours becomes a live cell.
  3. All other live cells die in the next generation. Similarly, all other dead cells stay dead.
(description adapted from https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life )
(example adapted from https://github.com/TheAlgorithms/Python/blob/master/cellular_automata/conways_game_of_life.py )
*/

/**
 * Generates the next generation for a given state of Conway's Game of Life.
 */
export function newGeneration (cells) {
  const nextGeneration = []
  for (let i = 0; i < cells.length; i++) {
    const nextGenerationRow = []
    for (let j = 0; j < cells[i].length; j++) {
      // Get the number of living neighbours
      let neighbourCount = 0
      if (i > 0 && j > 0) neighbourCount += cells[i - 1][j - 1]
      if (i > 0) neighbourCount += cells[i - 1][j]
      if (i > 0 && j < cells[i].length - 1) neighbourCount += cells[i - 1][j + 1]
      if (j > 0) neighbourCount += cells[i][j - 1]
      if (j < cells[i].length - 1) neighbourCount += cells[i][j + 1]
      if (i < cells.length - 1 && j > 0) neighbourCount += cells[i + 1][j - 1]
      if (i < cells.length - 1) neighbourCount += cells[i + 1][j]
      if (i < cells.length - 1 && j < cells[i].length - 1) neighbourCount += cells[i + 1][j + 1]

      // Decide whether the cell is alive or dead
      const alive = cells[i][j] === 1
      if ((alive && neighbourCount >= 2 && neighbourCount <= 3) || (!alive && neighbourCount === 3)) {
        nextGenerationRow.push(1)
      } else {
        nextGenerationRow.push(0)
      }
    }
    nextGeneration.push(nextGenerationRow)
  }
  return nextGeneration
}
import { newGeneration } from '../ConwaysGameOfLife'

describe('newGeneration', () => {
  it('should produce the next generation according to the rules', () => {
    expect(newGeneration([[0, 1, 0], [0, 1, 0], [0, 1, 0]]))
      .toEqual([[0, 0, 0], [1, 1, 1], [0, 0, 0]])
  })
})
// wiki - https://en.wikipedia.org/wiki/Tower_of_Hanoi
// Recursive Javascript function to solve tower of hanoi

export function TowerOfHanoi (n, from, to, aux, output = []) {
  if (n === 1) {
    output.push(`Move disk 1 from rod ${from} to rod ${to}`)
    return output
  }
  TowerOfHanoi(n - 1, from, aux, to, output)
  output.push(`Move disk ${n} from rod ${from} to rod ${to}`)
  TowerOfHanoi(n - 1, aux, to, from, output)
  return output
}

// Driver code (A, C, B are the name of rods)

// const n = 4
// TowerOfHanoi(n, 'A', 'C', 'B')
function euclideanGCDRecursive (first, second) {
  /*
    Calculates GCD of two numbers using Euclidean Recursive Algorithm
    :param first: First number
    :param second: Second number
    :return: GCD of the numbers
    */
  if (second === 0) {
    return first
  } else {
    return euclideanGCDRecursive(second, (first % second))
  }
}

function euclideanGCDIterative (first, second) {
  /*
    Calculates GCD of two numbers using Euclidean Iterative Algorithm
    :param first: First number
    :param second: Second number
    :return: GCD of the numbers
    */
  while (second !== 0) {
    const temp = second
    second = first % second
    first = temp
  }
  return first
}

export { euclideanGCDIterative, euclideanGCDRecursive }
import { Vector2, iterate } from './KochSnowflake'

/**
 * Method to render the Koch snowflake to a canvas.
 *
 * @param canvasWidth The width of the canvas.
 * @param steps The number of iterations.
 * @returns The canvas of the rendered Koch snowflake.
 */
function getKochSnowflake (canvasWidth = 600, steps = 5) {
  if (canvasWidth <= 0) {
    throw new Error('canvasWidth should be greater than zero')
  }

  const offsetX = canvasWidth / 10.0
  const offsetY = canvasWidth / 3.7
  const vector1 = new Vector2(offsetX, offsetY)
  const vector2 = new Vector2(canvasWidth / 2, Math.sin(Math.PI / 3) * canvasWidth * 0.8 + offsetY)
  const vector3 = new Vector2(canvasWidth - offsetX, offsetY)
  const initialVectors = []
  initialVectors.push(vector1)
  initialVectors.push(vector2)
  initialVectors.push(vector3)
  initialVectors.push(vector1)
  const vectors = iterate(initialVectors, steps)
  return drawToCanvas(vectors, canvasWidth, canvasWidth)
}

/**
 * Utility-method to render the Koch snowflake to a canvas.
 *
 * @param vectors The vectors defining the edges to be rendered.
 * @param canvasWidth The width of the canvas.
 * @param canvasHeight The height of the canvas.
 * @returns The canvas of the rendered edges.
 */
function drawToCanvas (vectors, canvasWidth, canvasHeight) {
  const canvas = document.createElement('canvas')
  canvas.width = canvasWidth
  canvas.height = canvasHeight

  // Draw the edges
  const ctx = canvas.getContext('2d')
  ctx.beginPath()
  ctx.moveTo(vectors[0].x, vectors[0].y)
  for (let i = 1; i < vectors.length; i++) {
    ctx.lineTo(vectors[i].x, vectors[i].y)
  }
  ctx.stroke()

  return canvas
}

// plot the results if the script is executed in a browser with a window-object
if (typeof window !== 'undefined') {
  const canvas = getKochSnowflake()
  document.body.append(canvas)
}
import { factorial } from '../Factorial'

describe('Factorial', () => {
  it('should return factorial 1 for value "0"', () => {
    expect(factorial(0)).toBe(1)
  })

  it('should return factorial 120 for value "5"', () => {
    expect(factorial(5)).toBe(120)
  })
})
import { fibonacci } from '../FibonacciNumberRecursive'

describe('FibonacciNumberRecursive', () => {
  it('should return 0', () => {
    expect(fibonacci(0)).toBe(0)
  })

  it('should return 1', () => {
    expect(fibonacci(1)).toBe(1)
  })

  it('should return 5', () => {
    expect(fibonacci(5)).toBe(5)
  })

  it('should return 9', () => {
    expect(fibonacci(9)).toBe(34)
  })
})
import { binarySearch } from '../BinarySearch'

describe('BinarySearch', () => {
  const arr = [2, 3, 4, 10, 25, 40, 45, 60, 100, 501, 700, 755, 800, 999]
  const low = 0
  const high = arr.length - 1

  it('should return index 3 for searchValue 10', () => {
    const searchValue = 10
    expect(binarySearch(arr, searchValue, low, high)).toBe(3)
  })

  it('should return index 0 for searchValue 2', () => {
    const searchValue = 2
    expect(binarySearch(arr, searchValue, low, high)).toBe(0)
  })

  it('should return index 13 for searchValue 999', () => {
    const searchValue = 999
    expect(binarySearch(arr, searchValue, low, high)).toBe(13)
  })

  it('should return -1 for searchValue 1', () => {
    const searchValue = 1
    expect(binarySearch(arr, searchValue, low, high)).toBe(-1)
  })

  it('should return -1 for searchValue 1000', () => {
    const searchValue = 1000
    expect(binarySearch(arr, searchValue, low, high)).toBe(-1)
  })
})
import { palindrome } from '../Palindrome'

describe('Palindrome', () => {
  it('expects to return true for palindrome string', () => {
    const isPalindrome = palindrome('madam')
    expect(isPalindrome).toBe(true)
  })

  it('expects to return true for Empty String', () => {
    const isPalindrome = palindrome('')
    expect(isPalindrome).toBe(true)
  })

  it('expects to return false for non-palindrome string', () => {
    const isPalindrome = palindrome('foobar')
    expect(isPalindrome).toBe(false)
  })

  it('Throw Error for Invalid Input', () => {
    expect(() => palindrome(123)).toThrow('Invalid Input')
    expect(() => palindrome(null)).toThrow('Invalid Input')
    expect(() => palindrome(undefined)).toThrow('Invalid Input')
  })
})
import { breadthFirstSearch, depthFirstSearch } from '../FloodFill'

// some constants
const black = [0, 0, 0]
const green = [0, 255, 0]
const violet = [255, 0, 255]
const white = [255, 255, 255]
const orange = [255, 128, 0]

describe('FloodFill', () => {
  it('should calculate the correct colors using breadth-first approach', () => {
    expect(testBreadthFirst([1, 1], green, orange, [1, 1])).toEqual(orange)
    expect(testBreadthFirst([1, 1], green, orange, [0, 1])).toEqual(violet)
    expect(testBreadthFirst([1, 1], green, orange, [6, 4])).toEqual(white)
  })

  it('should calculate the correct colors using depth-first approach', () => {
    expect(testDepthFirst([1, 1], green, orange, [1, 1])).toEqual(orange)
    expect(testDepthFirst([1, 1], green, orange, [0, 1])).toEqual(violet)
    expect(testDepthFirst([1, 1], green, orange, [6, 4])).toEqual(white)
  })
})

/**
 * Utility-function to test the function "breadthFirstSearch".
 *
 * @param fillLocation The start location on the image where the flood fill is applied.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 * @param testLocation The location of the color to be checked.
 * @return The color at testLocation.
 */
function testBreadthFirst (fillLocation, targetColor, replacementColor, testLocation) {
  const rgbData = generateTestRgbData()
  breadthFirstSearch(rgbData, fillLocation, targetColor, replacementColor)
  return rgbData[testLocation[0]][testLocation[1]]
}

/**
 * Utility-function to test the function "depthFirstSearch".
 *
 * @param fillLocation The start location on the image where the flood fill is applied.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 * @param testLocation The location of the color to be checked.
 * @return The color at testLocation.
 */
function testDepthFirst (fillLocation, targetColor, replacementColor, testLocation) {// eslint-disable-line
  const rgbData = generateTestRgbData()
  depthFirstSearch(rgbData, fillLocation, targetColor, replacementColor)
  return rgbData[testLocation[0]][testLocation[1]]
}

/**
 * Generates the rgbData-matrix for the tests.
 *
 * @return example rgbData-matrix.
 */
function generateTestRgbData () {
  const layout = [
    [violet, violet, green, green, black, green, green],
    [violet, green, green, black, green, green, green],
    [green, green, green, black, green, green, green],
    [black, black, green, black, white, white, green],
    [violet, violet, black, violet, violet, white, white],
    [green, green, green, violet, violet, violet, violet],
    [violet, violet, violet, violet, violet, violet, violet]
  ]

  // transpose layout-matrix so the x-index comes before the y-index
  const transposed = []
  for (let x = 0; x < layout[0].length; x++) {
    transposed[x] = []
    for (let y = 0; y < layout.length; y++) {
      transposed[x][y] = layout[y][x]
    }
  }

  return transposed
}
import { iterate, Vector2 } from '../KochSnowflake'

describe('KochSnowflake', () => {
  it('should produce the correctly-transformed vectors', () => {
    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[0])
      .toEqual({ x: 0, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[1])
      .toEqual({ x: 1 / 3, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[2])
      .toEqual({ x: 1 / 2, y: Math.sin(Math.PI / 3) / 3 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[3])
      .toEqual({ x: 2 / 3, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[4])
      .toEqual({ x: 1, y: 0 })
  })
})
/**
 * @function Palindrome
 * @description Check whether the given string is Palindrome or not.
 * @param {String} str - The input string
 * @return {Boolean}.
 * @see [Palindrome](https://en.wikipedia.org/wiki/Palindrome)
 */

const palindrome = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Invalid Input')
  }

  if (str.length <= 1) {
    return true
  }

  if (str[0] !== str[str.length - 1]) {
    return false
  } else {
    return palindrome(str.slice(1, str.length - 1))
  }
}

export { palindrome }
/*
 * Problem Statement: Find all distinct, non-empty subsequence of given string in lexicographical order using recursive approach.
 *
 * What is subsequence?
 * A Subsequence is sequence obtained by deleting some or no elements without changing the order of elements
 * Example: Given a string = "abcd"
 * 1. "abc" is a subsequence
 * 2. "abd" is a subsequence
 * 3. But "ba" is not a subsequence (because order is changed)
 *
 * What is lexicographical order?
 * In simple terms, lexicographical order is dictionary order.
 * Example: Given a string = "abcd"
 * 1. "abc" will come before "abcd".
 * 2. "abd" will come before "ac".
 *
 * References for meaning of subsequence & lexicographical:
 * https://en.wikipedia.org/wiki/Subsequence
 * https://en.wikipedia.org/wiki/Lexicographic_order
 */

export const subsequence = (str, seq, low, output = []) => {
  if (low <= str.length && str.length !== 0) {
    output.push(seq)
  }
  for (let i = low; i < str.length; i++) {
    subsequence(str, seq + str[i], i + 1, output)
  }
  return output
}
/**
 * Flood fill.
 *
 * Flood fill, also called seed fill, is an algorithm that determines and alters the area connected to a given node in a
 * multi-dimensional array with some matching attribute. It is used in the "bucket" fill tool of paint programs to fill
 * connected, similarly-colored areas with a different color.
 *
 * (description adapted from https://en.wikipedia.org/wiki/Flood_fill)
 * @see https://www.techiedelight.com/flood-fill-algorithm/
 */

const neighbors = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]

/**
 * Implements the flood fill algorithm through a breadth-first approach using a queue.
 *
 * @param rgbData The image to which the algorithm is applied.
 * @param location The start location on the image.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 */
export function breadthFirstSearch (rgbData, location, targetColor, replacementColor) {
  if (location[0] < 0 ||
    location[0] >= rgbData.length ||
    location[1] < 0 ||
    location[1] >= rgbData[0].length) {
    throw new Error('location should point to a pixel within the rgbData')
  }

  const queue = []
  queue.push(location)

  while (queue.length > 0) {
    breadthFirstFill(rgbData, location, targetColor, replacementColor, queue)
  }
}

/**
 * Implements the flood fill algorithm through a depth-first approach using recursion.
 *
 * @param rgbData The image to which the algorithm is applied.
 * @param location The start location on the image.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 */
export function depthFirstSearch (rgbData, location, targetColor, replacementColor) {
  if (location[0] < 0 ||
    location[0] >= rgbData.length ||
    location[1] < 0 ||
    location[1] >= rgbData[0].length) {
    throw new Error('location should point to a pixel within the rgbData')
  }

  depthFirstFill(rgbData, location, targetColor, replacementColor)
}

/**
 * Utility-function to implement the breadth-first loop.
 *
 * @param rgbData The image to which the algorithm is applied.
 * @param location The start location on the image.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 * @param queue The locations that still need to be visited.
 */
function breadthFirstFill (rgbData, location, targetColor, replacementColor, queue) {
  const currentLocation = queue[0]
  queue.shift()

  if (rgbData[currentLocation[0]][currentLocation[1]] === targetColor) {
    rgbData[currentLocation[0]][currentLocation[1]] = replacementColor

    for (let i = 0; i < neighbors.length; i++) {
      const x = currentLocation[0] + neighbors[i][0]
      const y = currentLocation[1] + neighbors[i][1]
      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {
        queue.push([x, y])
      }
    }
  }
}

/**
 * Utility-function to implement the depth-first loop.
 *
 * @param rgbData The image to which the algorithm is applied.
 * @param location The start location on the image.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 */
function depthFirstFill (rgbData, location, targetColor, replacementColor) {
  if (rgbData[location[0]][location[1]] === targetColor) {
    rgbData[location[0]][location[1]] = replacementColor

    for (let i = 0; i < neighbors.length; i++) {
      const x = location[0] + neighbors[i][0]
      const y = location[1] + neighbors[i][1]
      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {
        depthFirstFill(rgbData, [x, y], targetColor, replacementColor)
      }
    }
  }
}

/**
 * @function BinarySearch
 * @description Search the integer inside the sorted integers array using Binary Search Algorithm.
 * @param {Integer[]} arr - sorted array of integers
 * @param {Integer} low - The input integer
 * @param {Integer} high - The input integer
 * @param {Integer} searchValue - The input integer
 * @return {Integer} - return index of searchValue if found else return -1.
 * @see [BinarySearch](https://en.wikipedia.org/wiki/Binary_search_algorithm)
 */

const binarySearch = (arr, searchValue, low = 0, high = arr.length - 1) => {
  // base case
  if (high < low || arr.length === 0) return -1

  const mid = low + Math.floor((high - low) / 2)

  // If the element is present at the middle
  if (arr[mid] === searchValue) {
    return mid
  }

  // If element is smaller than mid, then
  // it can only be present in left subarray
  if (arr[mid] > searchValue) {
    return binarySearch(arr, searchValue, low, mid - 1)
  }

  // Else the element can only be present in right subarray
  return binarySearch(arr, searchValue, mid + 1, high)
}

export { binarySearch }
/**
 * The Koch snowflake is a fractal curve and one of the earliest fractals to have been described.
 *
 * The Koch snowflake can be built up iteratively, in a sequence of stages. The first stage is an equilateral triangle,
 * and each successive stage is formed by adding outward bends to each side of the previous stage, making smaller
 * equilateral triangles. This can be achieved through the following steps for each line:
 * 1. divide the line segment into three segments of equal length.
 * 2. draw an equilateral triangle that has the middle segment from step 1 as its base and points outward.
 * 3. remove the line segment that is the base of the triangle from step 2.
 *
 * (description adapted from https://en.wikipedia.org/wiki/Koch_snowflake)
 * (for a more detailed explanation and an implementation in the Processing language, see
 * https://natureofcode.com/book/chapter-8-fractals/ #84-the-koch-curve-and-the-arraylist-technique).
 */

/** Class to handle the vector calculations. */
export class Vector2 {
  constructor (x, y) {
    this.x = x
    this.y = y
  }

  /**
   * Vector addition
   *
   * @param vector The vector to be added.
   * @returns The sum-vector.
   */
  add (vector) {
    const x = this.x + vector.x
    const y = this.y + vector.y
    return new Vector2(x, y)
  }

  /**
   * Vector subtraction
   *
   * @param vector The vector to be subtracted.
   * @returns The difference-vector.
   */
  subtract (vector) {
    const x = this.x - vector.x
    const y = this.y - vector.y
    return new Vector2(x, y)
  }

  /**
   * Vector scalar multiplication
   *
   * @param scalar The factor by which to multiply the vector.
   * @returns The scaled vector.
   */
  multiply (scalar) {
    const x = this.x * scalar
    const y = this.y * scalar
    return new Vector2(x, y)
  }

  /**
   * Vector rotation (see https://en.wikipedia.org/wiki/Rotation_matrix)
   *
   * @param angleInDegrees The angle by which to rotate the vector.
   * @returns The rotated vector.
   */
  rotate (angleInDegrees) {
    const radians = angleInDegrees * Math.PI / 180
    const ca = Math.cos(radians)
    const sa = Math.sin(radians)
    const x = ca * this.x - sa * this.y
    const y = sa * this.x + ca * this.y
    return new Vector2(x, y)
  }
}

/**
 * Go through the number of iterations determined by the argument "steps".
 *
 * Be careful with high values (above 5) since the time to calculate increases exponentially.
 *
 * @param initialVectors The vectors composing the shape to which the algorithm is applied.
 * @param steps The number of iterations.
 * @returns The transformed vectors after the iteration-steps.
 */
export function iterate (initialVectors, steps) {
  let vectors = initialVectors
  for (let i = 0; i < steps; i++) {
    vectors = iterationStep(vectors)
  }

  return vectors
}

/**
 * Loops through each pair of adjacent vectors.
 *
 * Each line between two adjacent vectors is divided into 4 segments by adding 3 additional vectors in-between the
 * original two vectors. The vector in the middle is constructed through a 60 degree rotation so it is bent outwards.
 *
 * @param vectors The vectors composing the shape to which the algorithm is applied.
 * @returns The transformed vectors after the iteration-step.
 */
function iterationStep (vectors) {
  const newVectors = []
  for (let i = 0; i < vectors.length - 1; i++) {
    const startVector = vectors[i]
    const endVector = vectors[i + 1]
    newVectors.push(startVector)
    const differenceVector = endVector.subtract(startVector).multiply(1 / 3)
    newVectors.push(startVector.add(differenceVector))
    newVectors.push(startVector.add(differenceVector).add(differenceVector.rotate(60)))
    newVectors.push(startVector.add(differenceVector.multiply(2)))
  }

  newVectors.push(vectors[vectors.length - 1])
  return newVectors
}
/*
 * Problem Statement: Given a positive number `num`, find it's binary equivalent using recursion
 *
 * What is Binary Equivalent?
 * - In binary number system, a number is represented in terms of 0s and 1s,
 *   for example:
 *    - Binary Of 2 = 10
 *    - Binary of 3 = 11
 *    - Binary of 4 = 100
 *
 * Reference on how to find Binary Equivalent
 * - https://byjus.com/maths/decimal-to-binary/
 *
 */

export const binaryEquivalent = (num) => {
  if (num === 0 || num === 1) {
    return String(num)
  }
  return binaryEquivalent(Math.floor(num / 2)) + String(num % 2)
}
/**
 * @function Factorial
 * @description function to find factorial using recursion.
 * @param {Integer} n - The input integer
 * @return {Integer} - Factorial of n.
 * @see [Factorial](https://en.wikipedia.org/wiki/Factorial)
 * @example 5! = 1*2*3*4*5 = 120
 * @example 2! = 1*2 = 2
 */

const factorial = (n) => {
  if (n === 0) {
    return 1
  }
  return n * factorial(n - 1)
}

export { factorial }

/**
 * @function Fibonacci
 * @description Function to return the N-th Fibonacci number.
 * @param {Integer} n - The input integer
 * @return {Integer} - Return the N-th Fibonacci number
 * @see [Fibonacci](https://en.wikipedia.org/wiki/Fibonacci_number)
 */

const fibonacci = (n) => {
  if (n < 2) {
    return n
  }
  return fibonacci(n - 2) + fibonacci(n - 1)
}

export { fibonacci }
/**
 * @function HaversineDistance
 * @description Calculate the distance between two coordinates using the haversine formula
 * @param {Integer} latitude1 - The input integer
 * @param {Integer} latitude2 - The input integer
 * @param {Integer} longitude1 - The input integer
 * @param {Integer} longitude2 - The input integer
 * @return {Integer} Haversine Distance.
 * @see [Haversine_Distance](https://pt.wikipedia.org/wiki/F%C3%B3rmula_de_Haversine)
 */
const haversineDistance = (latitude1 = 0, longitude1 = 0, latitude2 = 0, longitude2 = 0) => {
  validateLatOrLong(latitude1)
  validateLatOrLong(latitude2)
  validateLatOrLong(longitude1)
  validateLatOrLong(longitude2)
  const earthRadius = 6371e3 // 6,371km
  const pi = Math.PI
  const cos1 = latitude1 * pi / 180.0
  const cos2 = latitude2 * pi / 180.0
  const deltaLatitude = (latitude2 - latitude1) * pi / 180.0
  const deltaLongitude = (longitude2 - longitude1) * pi / 180.0

  const alpha = Math.sin(deltaLatitude / 2) * Math.sin(deltaLatitude / 2) + Math.cos(cos1) * Math.cos(cos2) * Math.sin(deltaLongitude / 2) * Math.sin(deltaLongitude / 2)
  const constant = 2 * Math.atan2(Math.sqrt(alpha), Math.sqrt(1 - alpha))
  return earthRadius * constant
}

const validateLatOrLong = value => {
  if (typeof value !== 'number') {
    throw new TypeError('The value of latitude or longitude should be a number')
  }
}

export { haversineDistance }
import { haversineDistance } from '../Haversine'

describe('Testing the haversine distance calculator', () => {
  it('Calculate distance', () => {
    const distance = haversineDistance(64.1265, -21.8174, 40.7128, -74.0060)
    expect(distance).toBe(4208198.758424171)
  })
  it('Test validation, expect throw', () => {
    expect(() => haversineDistance(64.1265, -21.8174, 40.7128, '74.0060')).toThrow()
  })
})
/**
 * Problem 12 - Highly divisible triangular number
 *
 * https://projecteuler.net/problem=11
 *
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
 *
 * The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * Let us list the factors of the first seven triangle numbers:
 *
 * 1: 1
 * 3: 1,3
 * 6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 *
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred divisors?
*/

/**
 * Gets number of divisors of a given number
 * @params num The number whose divisors to find
 */
const getNumOfDivisors = (num) => {
  // initialize numberOfDivisors
  let numberOfDivisors = 0

  // if one divisor less than sqrt(num) exists
  // then another divisor greater than sqrt(n) exists and its value is num/i
  const sqrtNum = Math.sqrt(num)
  for (let i = 0; i <= sqrtNum; i++) {
    // check if i divides num
    if (num % i === 0) {
      if (i === sqrtNum) {
        // if both divisors are equal, i.e., num is perfect square, then only 1 divisor
        numberOfDivisors++
      } else {
        // 2 divisors, one of them is less than sqrt(n), other greater than sqrt(n)
        numberOfDivisors += 2
      }
    }
  }
  return numberOfDivisors
}

/**
 * Loops till first triangular number with 500 divisors is found
 */
const firstTriangularWith500Divisors = () => {
  let triangularNum
  // loop forever until numOfDivisors becomes greater than or equal to 500
  for (let n = 1; ; n++) {
    // nth triangular number is (1/2)*n*(n+1) by Arithmetic Progression
    triangularNum = (1 / 2) * n * (n + 1)
    if (getNumOfDivisors(triangularNum) >= 500) return triangularNum
  }
}

export { firstTriangularWith500Divisors }
// https://projecteuler.net/problem=2
const SQ5 = 5 ** 0.5 // Square root of 5
const PHI = (1 + SQ5) / 2 // definition of PHI

// theoretically it should take O(1) constant amount of time as long
// arithmetic calculations are considered to be in constant amount of time
export const EvenFibonacci = (limit) => {
  const highestIndex = Math.floor(Math.log(limit * SQ5) / Math.log(PHI))
  const n = Math.floor(highestIndex / 3)
  return ((PHI ** (3 * n + 3) - 1) / (PHI ** 3 - 1) -
    ((1 - PHI) ** (3 * n + 3) - 1) / ((1 - PHI) ** 3 - 1)) / SQ5
}
/**
 * Problem 16 - Power digit sum
 *
 * @see {@link https://projecteuler.net/problem=16}
 *
 * 2 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
 *
 * What is the sum of the digits of the number 2 ?
 */

/**
 * Returns the power digit sum of n^pow.
 *
 * @param {number} [n=2]
 * @param {number} [pow=1000]
 * @returns {number}
 */
const powerDigitSum = function (n = 2, pow = 1000) {
  // The idea is to consider each digit (d*10^exp) separately, right-to-left.
  // digits = [units, tens, ...]

  const digits = [n]
  let p = 1

  while (++p <= pow) {
    let carry = 0
    for (let exp = 0; exp < digits.length; exp++) {
      const prod = digits[exp] * n + carry
      carry = Math.floor(prod / 10)
      digits[exp] = prod % 10
    }
    while (carry > 0) {
      digits.push(carry % 10)
      carry = Math.floor(carry / 10)
    }
  }

  // (digits are reversed but we only want the sum so it doesn't matter)

  return digits.reduce((prev, current) => prev + current, 0)
}

export { powerDigitSum }
// https://projecteuler.net/problem=6

export const squareDifference = (num = 100) => {
  let sumOfSquares = 0
  let sums = 0
  for (let i = 1; i <= num; i++) {
    sumOfSquares += i ** 2 // add squares to the sum of squares
    sums += i // add number to sum to square later
  }
  return (sums ** 2) - sumOfSquares // difference of square of the total sum and sum of squares
}
/**
 * Problem 23 - Non-Abundant Sums
 *
 * @see {@link https://projecteuler.net/problem=23}
 *
 * A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.
 *
 * A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.
 *
 * As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.
 *
 * Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
 *
 */

/**
 * collect the abundant numbers, generate and store their sums with each other, and check for numbers not in the llst of sums, adds them and returns their sum.
 * @param {number} [n = 28123]
 * @returns {number}
 */

function sumOfNonAbundantNumbers (n = 28123) {
  const abundantNumbers = [] // array to store the abundant numbers
  const sumOfAbundantNumbers = {} // instead of an array, checking an object takes way less time. sets may be used as well.
  let sum = 0

  for (let i = 1; i <= n; i++) {
    if (isAbundant(i)) {
      abundantNumbers.push(i) // collect the abundant numbers
      abundantNumbers.forEach(num => { // collect their sums
        const sum = num + i
        sumOfAbundantNumbers[sum] = true
      })
    }
  }

  for (let i = 1; i <= n; i++) {
    if (!sumOfAbundantNumbers[i]) { // if the number is not found in the list of sums, then it is added
      sum += i
    }
  }

  return sum
}

/**
 * generates the divisors of the number and checks if it is abundant
 * @param {number} number
 * @returns {bool}
 */

function isAbundant (number) {
  let sum = 0
  for (let i = 1; i <= number / 2; i++) {
    if (number % i === 0) { // generate divisors
      sum += i // calculate their sums
    }
  }
  return sum > number
}

export { sumOfNonAbundantNumbers }
import { firstTriangularWith500Divisors } from '../Problem012'

describe('checkFirstTriangularWith500Divisors()', () => {
  it('Problem Statement Answer', () => {
    const firstTriangular = firstTriangularWith500Divisors()
    expect(firstTriangular).toBe(76576500)
  })
})
import { fibonacciIndex } from '../Problem025'

describe('Check Problem 25 - 1000 digit Fibonnaci number', () => {
  it('First term of the Fibonnaci sequence containing 3 digits', () => {
    expect(fibonacciIndex(3)).toBe(12)
  })

  it('First term of the Fibonnaci sequence containing 10 digits', () => {
    expect(fibonacciIndex(10)).toBe(45)
  })

  it('First term of the Fibonnaci sequence containing 50 digits', () => {
    expect(fibonacciIndex(50)).toBe(237)
  })

  it('First term of the Fibonnaci sequence containing 100 digits', () => {
    expect(fibonacciIndex(100)).toBe(476)
  })

  it('First term of the Fibonnaci sequence containing 1000 digits', () => {
    expect(fibonacciIndex(1000)).toBe(4782)
  })

  it('First term of the Fibonnaci sequence containing 10000 digits', () => {
    expect(fibonacciIndex(10000)).toBe(47847)
  })
})
import { largestAdjacentNumber } from '../Problem008'

const grid1 = `73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
38991007832084782777189757278819047278899274961949
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
82834772897718748193457134085784719857638187485919
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
83247832478757285710958372981577583275832789327921
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
84327878357761783787589375857378271083787811983779
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
82347875831098357801578571807585817518287829189189`

const grid2 = `73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450`

const grid3 = `89125732138957892357892768971807934878999818278898
48327483578957875827583295789187588875238579887789
74358275778171870973857835738758275210873583758279
81347834738473878758758373857893758787772897580719
81232847857895758758987587501087575387538183787098
17047878395783578750837100983787587582797837508298
42894789325732857893759187987487489748377578791989
82147328972387832578327581919827382758932789798289
83243289473847328974832947832748932472387895738978
84738294738973289578753287582375238957573297892398
29383748329748397483274832748327477575018978975289
48327483758375846372864736476478364783647463278787
73281473847832974328758975890189373857875875895898
74328978748329789357389578329758329758937893758979
81738957389579287598217589127589375893275987359889
71890743894732897510875895783297591085738975837897
10783974839479879857895789758975981735870175835789
01494787857897583758975849758475107589754897589789
09939858758919788017587897587387585775289757982898
74718478978758758975897589789789798789178957789789`

const grid4 = `99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999`

describe('checkLargestAdjacentNumberProduct', () => {
  it('Random Example', () => {
    const RESULT = largestAdjacentNumber(grid1, 13)
    expect(RESULT).toBe(23514624000)
  })
  it('Problem statement Example', () => {
    const RESULT = largestAdjacentNumber(grid2, 13)
    expect(RESULT).toBe(23514624000)
  })
  it('Random Example 2', () => {
    const RESULT = largestAdjacentNumber(grid3, 13)
    expect(RESULT).toBe(580717154304)
  })
  it('Example with all 9', () => {
    const RESULT = largestAdjacentNumber(grid4, 13)
    expect(RESULT).toBe(2541865828329)
  })
})
import { maxPathSum } from '../Problem018'

const example = `
3
7 4
2 4 6
8 5 9 3
`

describe('Check Problem 18 - Maximum path sum I', () => {
  it('Check example', () => {
    expect(maxPathSum(example)).toBe(23)
  })

  it('Check solution', () => {
    expect(maxPathSum()).toBe(1074)
  })
})
import { calculateSumOfPrimeNumbers } from '../Problem010'

describe('checkAnagram', () => {
  it('Return the sum of prime numbers up to but less than 14', () => {
    const SUT = calculateSumOfPrimeNumbers(14)
    expect(SUT).toBe(41)
  })
  it('Return the sum of prime numbers up to but less than 10', () => {
    const SUT = calculateSumOfPrimeNumbers(10)
    expect(SUT).toBe(17)
  })
  it('Return the sum of prime numbers up to but less than 100', () => {
    const SUT = calculateSumOfPrimeNumbers(100)
    expect(SUT).toBe(1060)
  })
})
import { sumOfNonAbundantNumbers } from '../Problem023'

describe('Check Problem 23 - Non-Abundant Sums', () => {
  it('Sum of all positive integers <= 10000 which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(10000)).toBe(3731004)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(15000)).toBe(4039939)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(20000)).toBe(4159710)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(28123)).toBe(4179871)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(30000)).toBe(4179871)
  })
})
import { powerDigitSum } from '../Problem016'

describe('Check Problem 16 - Power digit sum', () => {
  it('Power digit sum of 2^15', () => {
    expect(powerDigitSum(2, 15)).toBe(26)
  })

  it('Power digit sum of 2^1000', () => {
    expect(powerDigitSum()).toBe(1366)
    expect(powerDigitSum(2, 1000)).toBe(1366)
  })

  it('Power digit sum of 3^5000', () => {
    expect(powerDigitSum(3, 5000)).toBe(11097)
  })
})
import { factorialDigitSum } from '../Problem020'

describe('Check Problem 20 - Factorial digit sum', () => {
  it('Factorial digit sum of 10!', () => {
    expect(factorialDigitSum(10)).toBe(27)
  })

  it('Factorial digit sum of 100!', () => {
    expect(factorialDigitSum()).toBe(648)
    expect(factorialDigitSum(100)).toBe(648)
  })

  it('Factorial digit sum of 1000!', () => {
    expect(factorialDigitSum(1000)).toBe(10539)
  })
})
// https://projecteuler.net/problem=3

export const largestPrime = (num = 600851475143) => {
  let newnumm = num
  let largestFact = 0
  let counter = 2
  while (counter * counter <= newnumm) {
    if (newnumm % counter === 0) {
      newnumm = newnumm / counter
    } else {
      counter++
    }
  }
  if (newnumm > largestFact) {
    largestFact = newnumm
  }
  return largestFact
}
/**
 * @file Provides solution for Project Euler Problem 18 - Maximum path sum I
 * @author Eric Lavault {@link https://github.com/lvlte}
 * @license MIT
 */

/**
 * Problem 18 - Maximum path sum I
 *
 * @see {@link https://projecteuler.net/problem=18}
 *
 * By starting at the top of the triangle below and moving to adjacent numbers
 * on the row below, the maximum total from top to bottom is 23 :
 *
 *                            3
 *                           7 4
 *                          2 4 6
 *                         8 5 9 3
 *
 * That is, 3 + 7 + 4 + 9 = 23.
 *
 * Find the maximum total from top to bottom of the triangle below :
 *
 *                            75
 *                           95 64
 *                         17 47 82
 *                        18 35 87 10
 *                      20 04 82 47 65
 *                     19 01 23 75 03 34
 *                   88 02 77 73 07 63 67
 *                  99 65 04 28 06 16 70 92
 *                41 41 26 56 83 40 80 70 33
 *               41 48 72 33 47 32 37 16 94 29
 *             53 71 44 65 25 43 91 52 97 51 14
 *            70 11 33 28 77 73 17 78 39 68 17 57
 *          91 71 52 38 17 14 91 43 58 50 27 29 48
 *         63 66 04 68 89 53 67 30 73 16 69 87 40 31
 *       04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
 *
 * NOTE: As there are only 16384 routes, it is possible to solve this problem
 * by trying every route. However, Problem 67, is the same challenge with a
 * triangle containing one-hundred rows; it cannot be solved by brute force,
 * and requires a clever method! ;o)
 */

const triangle = `
75
95 64
17 47 82
18 35 87 10
20 04 82 47 65
19 01 23 75 03 34
88 02 77 73 07 63 67
99 65 04 28 06 16 70 92
41 41 26 56 83 40 80 70 33
41 48 72 33 47 32 37 16 94 29
53 71 44 65 25 43 91 52 97 51 14
70 11 33 28 77 73 17 78 39 68 17 57
91 71 52 38 17 14 91 43 58 50 27 29 48
63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
`

export const maxPathSum = function (grid = triangle) {
  /**
   * If we reduce the problem to its simplest form, considering :
   *
   *         7      -> The max sum depends on the two adjacent numbers below 7,
   *        2 4        not 7 itself.
   *
   *    obviously 4 > 2 therefore the max sum is 7 + 4 = 11
   *
   *                       6
   * Likewise, with :     4 6     6 > 4 therefore the max sum is 6 + 6 = 12
   *
   * Now, let's say we are given :
   *
   *         3
   *        7 6
   *       2 4 6
   *
   *    and we decompose it into sub-problems such that each one fits the simple
   *    case above, we got :
   *
   *         .           .           3
   *        7 .         . 6         ? ?
   *       2 4 .       . 4 6       . . .
   *
   *    Again, considering any number, the best path depends on the two adjacent
   *    numbers below it, not the number itself. That's why we have to compute
   *    the max sum from bottom to top, replacing each number with the sum of
   *    that number plus the greatest of the two adjacent numbers computed from
   *    the previous row.
   *
   *          .          .              3              15
   *        11 .        . 12    ->    11 12    ->    x   x
   *       x  x .      . x  x        x  x  x        x  x  x
   *
   * We are simplifying a complicated problem by breaking it down into simpler
   * sub-problems in a recursive manner, this is called Dynamic Programming.
   */

  grid = grid.split(/\r\n|\n/).filter(l => l).map(r => r.split(' ').map(n => +n))

  for (let i = grid.length - 2; i >= 0; i--) {
    for (let j = 0; j < grid[i].length; j++) {
      grid[i][j] += Math.max(grid[i + 1][j], grid[i + 1][j + 1])
    }
  }

  return grid[0][0]
}
// Problem: https://projecteuler.net/problem=8

const largestAdjacentNumber = (grid, consecutive) => {
  grid = grid.split('\n').join('')
  const splitedGrid = grid.split('\n')
  let largestProd = 0

  for (const row in splitedGrid) {
    const currentRow = splitedGrid[row].split('').map(x => Number(x))

    for (let i = 0; i < currentRow.length - consecutive; i++) {
      const combine = currentRow.slice(i, i + consecutive)

      if (!combine.includes(0)) {
        const product = combine.reduce(function (a, b) {
          return a * b
        })

        if (largestProd < product) largestProd = product
      }
    }
  }
  return largestProd
}

export { largestAdjacentNumber }
/*
Special Pythagorean triplet

A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,

a^2 + b^2 = c^2
For example, 32 + 42 = 9 + 16 = 25 = 52.

There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
*/

const isPythagoreanTriplet = (a, b, c) => Math.pow(a, 2) + Math.pow(b, 2) === Math.pow(c, 2)

export const findSpecialPythagoreanTriplet = () => {
  for (let a = 0; a < 1000; a++) {
    for (let b = a + 1; b < 1000; b++) {
      for (let c = b + 1; c < 1000; c++) {
        if (isPythagoreanTriplet(a, b, c) && a + b + c === 1000) {
          return a * b * c
        }
      }
    }
  }
}
/*
Longest Collatz sequence

The following iterative sequence is defined for the set of positive integers:

n  n/2 (n is even)
n  3n + 1 (n is odd)

Using the rule above and starting with 13, we generate the following sequence:

13  40  20  10  5  16  8  4  2  1
It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.

Which starting number, under one million, produces the longest chain?

NOTE: Once the chain starts the terms are allowed to go above one million.
*/

const getCollatzSequenceLength = (num, seqLength) => {
  if (num === 1) {
    return seqLength
  } else {
    let newElement
    if (num % 2 === 0) {
      newElement = num / 2
    } else {
      newElement = (3 * num) + 1
    }
    seqLength++
    return getCollatzSequenceLength(newElement, seqLength)
  }
}

export const findLongestCollatzSequence = (limit = 1000000) => {
  let startingPointForLargestSequence = 1
  let largestSequenceLength = 1
  for (let i = 2; i < limit; i++) {
    const currentSequenceLength = getCollatzSequenceLength(i, 1)
    if (currentSequenceLength > largestSequenceLength) {
      startingPointForLargestSequence = i
      largestSequenceLength = currentSequenceLength
    }
  }
  return startingPointForLargestSequence
}
/**
 * Problem 20 - Factorial digit sum
 *
 * @see {@link https://projecteuler.net/problem=20}
 *
 * n! means n  (n  1)  ...  3  2  1
 *
 * For example, 10! = 10  9  ...  3  2  1 = 3628800,
 * and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27
 *
 * Find the sum of the digits in the number 100!
 */

const factorialDigitSum = (n = 100) => {
  // Consider each digit*10^exp separately, right-to-left ([units, tens, ...]).
  const digits = [1]

  for (let x = 2; x <= n; x++) {
    let carry = 0
    for (let exp = 0; exp < digits.length; exp++) {
      const prod = digits[exp] * x + carry
      carry = Math.floor(prod / 10)
      digits[exp] = prod % 10
    }
    while (carry > 0) {
      digits.push(carry % 10)
      carry = Math.floor(carry / 10)
    }
  }

  // (digits are reversed but we only want the sum so it doesn't matter)

  return digits.reduce((prev, current) => prev + current, 0)
}

export { factorialDigitSum }
// https://projecteuler.net/problem=4
/* A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91  99.
   Find the largest palindrome made from the product of two 3-digit numbers.
*/
export const largestPalindromic = (digits) => {
  let i
  let n
  let m
  let d
  let limit
  let number = 0

  for (i = 1; i < digits; i++) {
    number = 10 * number + 9
  }
  const inf = number // highest (digits - 1) number, in this example highest 2 digit number
  const sup = 10 * number + 9 // highest (digits) number, in this example highest 3 digit number

  const isPalindromic = (n) => {
    let p = 0
    const q = n
    let r
    while (n > 0) {
      r = n % 10
      p = 10 * p + r
      n = Math.floor(n / 10)
    }
    return p === q // returning whether the number is palindromic or not
  }

  for (n = sup * sup, m = inf * inf; n > m; n--) {
    if (isPalindromic(n)) {
      limit = Math.ceil(Math.sqrt(n))
      d = sup
      while (d >= limit) {
        if (n % d === 0 && n / d > inf) {
          return n
        }
        d -= 1
      }
    }
  }
  return NaN // returning not a number, if any such case arise
}
// https://projecteuler.net/problem=10

const isPrime = (number) => {
  if (number === 2) return true
  if (number % 2 === 0) return false

  for (let j = 3; j * j <= number; j += 2) {
    if (number % j === 0) {
      return false
    }
  }
  return true
}

const calculateSumOfPrimeNumbers = (maxNumber) => {
  let sum = 0
  for (let i = maxNumber - 1; i >= 2; i--) {
    if (isPrime(parseInt(i)) === true) {
      sum += i
    }
  }
  return sum
}
export { calculateSumOfPrimeNumbers }
/**
* Problem 25 - 1000-digit Fibonacci number
*
* @see {@link https://projecteuler.net/problem=25}
*
* The Fibonacci sequence is defined by the recurrence relation:
*
* Fn = Fn1 + Fn2, where F1 = 1 and F2 = 1.
*
* Hence the first 12 terms will be:
*
* F1 = 1
* F2 = 1
* F3 = 2
* F4 = 3
* F5 = 5
* F6 = 8
* F7 = 13
* F8 = 21
* F9 = 34
* F10 = 55
* F11 = 89
* F12 = 144
* The 12th term, F12, is the first term to contain three digits.

* What is the index of the first term in the Fibonacci sequence to contain 1000 digits?
*/

// brute force method

function fibonacciIndex (t = 1000) {
  const digits = 10n ** BigInt(t - 1)
  let fib0 = BigInt(0)
  let fib1 = BigInt(1)
  let index = 1
  while (fib1 < digits) { // using this to compare number of digits instead of .toString() significantly improved run time
    const tempfib = fib1
    fib1 = fib1 + fib0
    fib0 = tempfib
    index += 1
  }
  return (index)
}

export { fibonacciIndex }
// https://projecteuler.net/problem=1
/*    Multiples of 3 and 5
    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below the provided parameter value number.
*/

const multiplesThreeAndFive = (num) => {
  let total = 0
  // total for calculating the sum
  for (let i = 0; i < num; i++) {
    if (i % 3 === 0 || i % 5 === 0) {
      total += i
    }
  }
  return total
}

export { multiplesThreeAndFive }
// https://projecteuler.net/problem=15
/* Starting in the top left corner of a 22 grid, and only being able to move to
the right and down, there are exactly 6 routes to the bottom right corner.
How many such routes are there through a 2020 grid?
*/

// A lattice path is composed of horizontal and vertical lines that pass through lattice points.

export const latticePath = (gridSize) => {
  let paths
  for (let i = 1, paths = 1; i <= gridSize; i++) {
    paths = paths * (gridSize + i) / i
  }
  // The total number of paths can be found using the binomial coefficient (b+a)/a.
  return paths
}

// > latticePath(20))
// 137846528820
/*
Smallest multiple

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
*/

export const findSmallestMultiple = () => {
  const divisors = [20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]
  let num = 21
  let result

  while (!result) {
    const isDivisibleByAll = divisors.every((divisor) => num % divisor === 0)
    if (isDivisibleByAll) result = num
    else num++
  }

  return result
}
/**
* Sliding Window:
* This pattern involve creating a window which can either be
* an array or numbers from one position to another.
*
* Depending on a certain condition, the window either increases
* or closes (and a new window is created).
*
* Very useful for keeping track of a subset of data in an
* array/string etc.
*
* Time Complexity: Best - O(n);
*
* Examples:
* maxSubarraySum([1,2,5,2,8,1,5],2) // returns 10
* maxSubarraySum([1,2,5,2,8,1,5],15) // returns null
* maxSubarraySum([5,2,6,9],3) // returns 17
 * @param {[Int]} arr - An array of integers on which we will perform the test.
 * @param {Int} num - An integer that displays the size of the window you want to check.
 * @returns {Int / Null} - Returns a total of N consecutive numbers or null
 */

function slidingWindow (arr, num) {
  // Edge Case:
  // If the length of the array shorter than the window size (num) return null.
  if (arr.length < num) return null
  // The highest amount of consecutive numbers
  let maxSum = 0
  // Temp amount of consecutive numbers - For comparative purposes
  let tempSum = 0
  // loop over the array {num} times and save their total amount in {maxSum}
  for (let i = 0; i < num; i++) {
    maxSum += arr[i]
  }
  // initialize {tempSum} to {maxSum}.
  tempSum = maxSum
  // loop over the array n times
  for (let i = num; i < arr.length; i++) {
    // Add the next num in the array and remove the first one
    tempSum = tempSum - arr[i - num] + arr[i]
    // save the largest number between {maxNum} and {tempNum} in maxSum.
    maxSum = Math.max(maxSum, tempSum)
  }
  return maxSum
}

export { slidingWindow }
/**
 * Exponential Search
 *
 * The algorithm consists of two stages. The first stage determines a
 * range in which the search key would reside if it were in the list.
 * In the second stage, a binary search is performed on this range.
 *
 *
 *
 */

function binarySearch (arr, value, floor, ceiling) {
  // Middle index
  const mid = Math.floor((floor + ceiling) / 2)

  // If value is at the mid position return this position
  if (arr[mid] === value) {
    return mid
  }

  if (floor > ceiling) return -1

  // If the middle element is great than the value
  // search the left part of the array
  if (arr[mid] > value) {
    return binarySearch(arr, value, floor, mid - 1)
    // If the middle element is lower than the value
    // search the right part of the array
  } else {
    return binarySearch(arr, value, mid + 1, ceiling)
  }
}

function exponentialSearch (arr, length, value) {
  // If value is the first element of the array return this position
  if (arr[0] === value) {
    return 0
  }

  // Find range for binary search
  let i = 1
  while (i < length && arr[i] <= value) {
    i = i * 2
  }

  // Call binary search for the range found above
  return binarySearch(arr, value, i / 2, Math.min(i, length))
}

export { binarySearch, exponentialSearch }

// const arr = [2, 3, 4, 10, 40, 65, 78, 100]
// const value = 78
// const result = exponentialSearch(arr, arr.length, value)
import { exponentialSearch } from '../ExponentialSearch'

test('The Exponential Search of the Array [2, 3, 4, 10, 40, 65, 78, 100] is 6 where the value = 78', () => {
  const arr = [2, 3, 4, 10, 40, 65, 78, 100]
  const value = 78
  const result = exponentialSearch(arr, arr.length, value)
  expect(result).toEqual(6)
})

test('The Exponential Search of the Array [2, 3, 4, 10, 40, 65, 78, 100] is -1 where the value = 178', () => {
  const arr = [2, 3, 4, 10, 40, 65, 78, 100]
  const value = 178
  const result = exponentialSearch(arr, arr.length, value)
  expect(result).toEqual(-1)
})
import { ternarySearchRecursive, ternarySearchIterative } from '../TernarySearch'

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)
  expect(indexNumber).toBe(2)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 8)
  expect(indexNumber).toBe(7)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0)
  expect(indexNumber).toBe(-1)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 12)
  expect(indexNumber).toBe(-1)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Cathrynli')
  expect(indexNumber).toBe(1)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Josuke')
  expect(indexNumber).toBe(2)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Angela')
  expect(indexNumber).toBe(-1)
})
import { binarySearchIterative, binarySearchRecursive } from '../BinarySearch'

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const stringArr = [
  'Alpha',
  'Bravo',
  'Charlie',
  'Delta',
  'Echo',
  'Foxtrot',
  'Golf',
  'Hotel',
  'India',
  'Juliet',
  'Kilo',
  'Lima',
  'Mike',
  'November',
  'Oscar',
  'Papa',
  'Quebec',
  'Romeo',
  'Sierra',
  'Tango',
  'Uniform',
  'Victor',
  'Whiskey',
  'X-Ray',
  'Yankee',
  'Zulu'
]

describe('Binary Search', () => {
  const funcs = [binarySearchIterative, binarySearchRecursive]
  for (const func of funcs) {
    test('expect to return the index of the item in the array', () => {
      expect(func(arr, 3)).toBe(2)
    })
    test('expect to return -1 if not in array', () => {
      expect(func(arr, 11)).toBe(-1)
    })
    test('expect to return the index of the item in the array', () => {
      expect(func(stringArr, 'Charlie')).toBe(2)
    })
    test('expect to return -1 if not in array', () => {
      expect(func(stringArr, 'Zoft')).toBe(-1)
    })
  }
})
import { UnionFind } from '../UnionFind'

const uf = new UnionFind(5)

test('should expose .size():', () => {
  const size = uf.size()
  expect(size).toBe(5)
})

test('should do .union(num1, num2):', () => {
  uf.union(1, 2)
  uf.union(3, 4)
  uf.union(0, 4)
  expect(uf.connected(1, 2)).toBe(true)
  expect(uf.connected(1, 2)).toBe(true)

  expect(uf.connected(3, 4)).toBe(true)
  expect(uf.connected(3, 0)).toBe(true)
  expect(uf.connected(4, 0)).toBe(true)

  expect(uf.connected(1, 3)).toBe(false)
  expect(uf.connected(1, 4)).toBe(false)
  expect(uf.connected(1, 0)).toBe(false)
  expect(uf.connected(2, 3)).toBe(false)
  expect(uf.connected(2, 4)).toBe(false)
  expect(uf.connected(2, 0)).toBe(false)
})

test('.count(), should return the number of disparate groups:', () => {
  expect(uf.count()).toBe(2)
})

test('should check if two components are connected, .connected(num1, num2):', () => {
  expect(uf.connected(1, 2)).toBe(true)
  expect(uf.connected(1, 3)).toBe(false)
})

test('should find the root of the tree in which the given element lives, .find(num):', () => {
  expect(uf.find(1)).toBe(1)
  expect(uf.find(2)).toBe(1)
  expect(uf.find(3)).toBe(3)
  expect(uf.find(4)).toBe(3)
  expect(uf.find(0)).toBe(3)
})

test('should always change the id of the smaller tree and preserve the id of the larger one', () => {
  uf.union(2, 3)
  expect(uf.count()).toBe(1)
  expect(uf.find(0)).toBe(3)
  expect(uf.find(1)).toBe(3)
  expect(uf.find(2)).toBe(3)
  expect(uf.find(3)).toBe(3)
  expect(uf.find(4)).toBe(3)
})
import { slidingWindow } from '../SlidingWindow'

test('expect to return the largest sum of sequence in the array', () => {
  const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 2)
  expect(sum).toBe(10)
})

test('expect to return the largest sum of sequence in the array', () => {
  const sum = slidingWindow([5, 2, 6, 9], 3)
  expect(sum).toBe(17)
})

test('expect to return null when the sequence size is larger then the array length', () => {
  const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 15)
  expect(sum).toBe(null)
})
/*
 * Places the `k` smallest elements in `array` in the first `k` indices: `[0..k-1]`
 * Modifies the passed in array *in place*
 * Returns a slice of the wanted elements for convenience
 * Efficient mainly because it never performs a full sort.
 *
 * The only guarantees are that:
 *
 * - The `k`th element is in its final sort index (if the array were to be sorted)
 * - All elements before index `k` are smaller than the `k`th element
 *
 * [Reference](http://en.wikipedia.org/wiki/Quickselect)
 */
export function quickSelectSearch (array, k) {
  if (!array || array.length <= k) {
    throw new Error('Invalid arguments')
  }

  let from = 0
  let to = array.length - 1
  while (from < to) {
    let left = from
    let right = to
    const pivot = array[Math.ceil((left + right) * 0.5)]

    while (left < right) {
      if (array[left] >= pivot) {
        const tmp = array[left]
        array[left] = array[right]
        array[right] = tmp
        --right
      } else {
        ++left
      }
    }

    if (array[left] > pivot) {
      --left
    }

    if (k <= left) {
      to = left
    } else {
      from = left + 1
    }
  }
  return array
}

/* ---------------------------------- Test ---------------------------------- */

// const arr = [1121111, 21, 333, 41, 5, 66, 7777, 28, 19, 11110]
// quickSelectSearch(arr, 5) // [ 19, 21, 28, 41, 5, 66, 333, 11110, 1121111, 7777 ]
// quickSelectSearch(arr, 2) // [ 19, 5, 21, 41, 28, 333, 11110, 1121111, 7777, 66 ]
// quickSelectSearch(arr, 7) // [ 19, 5, 21, 41, 28, 66, 333, 7777, 11110, 1121111 ]
/*
 * Linear search or sequential search is a method for finding a target
 * value within a list. It sequentially checks each element of the list
 * for the target value until a match is found or until all the elements
 * have been searched.
 */
function SearchArray (searchNum, ar, output = v => console.log(v)) {
  const position = Search(ar, searchNum)
  if (position !== -1) {
    output('The element was found at ' + (position + 1))
  } else {
    output('The element not found')
  }
}

// Search theArray for the specified key value
function Search (theArray, key) {
  for (let n = 0; n < theArray.length; n++) {
    if (theArray[n] === key) { return n }
  }
  return -1
}

export { SearchArray, Search }

// const ar = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// SearchArray(3, ar)
// SearchArray(4, ar)
// SearchArray(11, ar)
/*
 * String Search
 */

function makeTable (str) {
  // create a table of size equal to the length of `str`
  // table[i] will store the prefix of the longest prefix of the substring str[0..i]
  const table = new Array(str.length)
  let maxPrefix = 0
  // the longest prefix of the substring str[0] has length
  table[0] = 0

  // for the substrings the following substrings, we have two cases
  for (let i = 1; i < str.length; i++) {
    // case 1. the current character doesn't match the last character of the longest prefix
    while (maxPrefix > 0 && str.charAt(i) !== str.charAt(maxPrefix)) {
      // if that is the case, we have to backtrack, and try find a character  that will be equal to the current character
      // if we reach 0, then we couldn't find a character
      maxPrefix = table[maxPrefix - 1]
    }
    // case 2. The last character of the longest prefix matches the current character in `str`
    if (str.charAt(maxPrefix) === str.charAt(i)) {
      // if that is the case, we know that the longest prefix at position i has one more character.
      // for example consider `.` be any character not contained in the set [a.c]
      // str = abc....abc
      // consider `i` to be the last character `c` in `str`
      // maxPrefix = will be 2 (the first `c` in `str`)
      // maxPrefix now will be 3
      maxPrefix++
      // so the max prefix for table[9] is 3
    }
    table[i] = maxPrefix
  }
  return table
}

// Find all the words that matches in a given string `str`
export function stringSearch (str, word) {
  // find the prefix table in O(n)
  const prefixes = makeTable(word)
  const matches = []

  // `j` is the index in `P`
  let j = 0
  // `i` is the index in `S`
  let i = 0
  while (i < str.length) {
    // Case 1.  S[i] == P[j] so we move to the next index in `S` and `P`
    if (str.charAt(i) === word.charAt(j)) {
      i++
      j++
    }
    // Case 2.  `j` is equal to the length of `P`
    // that means that we reached the end of `P` and thus we found a match
    // Next we have to update `j` because we want to save some time
    // instead of updating to j = 0 , we can jump to the last character of the longest prefix well known so far.
    // j-1 means the last character of `P` because j is actually `P.length`
    // e.g.
    // S =  a b a b d e
    // P = `a b`a b
    // we will jump to `a b` and we will compare d and a in the next iteration
    // a b a b `d` e
    //     a b `a` b
    if (j === word.length) {
      matches.push(i - j)
      j = prefixes[j - 1]
      // Case 3.
      // S[i] != P[j] There's a mismatch!
    } else if (str.charAt(i) !== word.charAt(j)) {
      // if we  found at least a character in common, do the same thing as in case 2
      if (j !== 0) {
        j = prefixes[j - 1]
      } else {
        // else j = 0, and we can move to the next character S[i+1]
        i++
      }
    }
  }

  return matches
}

// stringSearch('Hello search the position of me', 'pos')
/* The Jump Search algorithm allows to combine a linear search with a speed optimization.
  * This means that instead of going 1 by 1, we will increase the step of n and increase that
  * step of n which make the step getting bigger and bigger.
  * The asymptotic analysis of Jump Search is o(n). Like the binary search, it needs to be sorted.
  * The advantage against binary search is that Jump Search traversed back only once.
 */

const jumpSearch = (arr, value) => {
  const length = arr.length
  let step = Math.floor(Math.sqrt(length))
  let lowerBound = 0
  while (arr[Math.min(step, length) - 1] < value) {
    lowerBound = step
    step += step
    if (lowerBound >= length) {
      return -1
    }
  }

  const upperBound = Math.min(step, length)
  while (arr[lowerBound] < value) {
    lowerBound++
    if (lowerBound === upperBound) {
      return -1
    }
  }
  if (arr[lowerBound] === value) {
    return lowerBound
  }
  return -1
}
const arr = [0, 0, 4, 7, 10, 23, 34, 40, 55, 68, 77, 90]
jumpSearch(arr, 4)
jumpSearch(arr, 34)
jumpSearch(arr, 77)
/**
 * union find data structure for javascript
 *
 * In computer science, a disjoint-set data structure, also called a unionfind data structure or mergefind set,
 * is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition
 * of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union),
 * and finding a representative member of a set.
 * The last operation allows to find out efficiently if any two elements are in the same or different sets.
 *
 * Disjoint-set data structures play a key role in Kruskal's algorithm for finding the minimum spanning tree of a graph.
 * The importance of minimum spanning trees means that disjoint-set data structures underlie a wide variety of algorithms.
 * In addition, disjoint-set data structures also have applications to symbolic computation, as well in compilers,
 * especially for register allocation problems.
 *
 * you can learn more on disjoint-set / unionfind data structure at https://en.wikipedia.org/wiki/Disjoint-set_data_structure
 */
function UnionFind (n, key) {
  if (!(this instanceof UnionFind)) return new UnionFind(n)
  if (key && typeof key !== 'function') {
    throw new Error('key has to be a function or else left undefined')
  }
  let cnt, length
  // init Union Find with number of distinct groups. Each group will be referred to as index of the array of size 'size' starting at 0.
  // Provide an optional key function that maps these indices. I.e. for the groups starting with 1 provide function(a){return a-1;}. The default value is function(a){return a;}.
  key = key || function (a) { return a }
  cnt = length = n
  const id = new Array(n)
  const sz = new Array(n)
  for (let i = 0; i < n; i++) {
    id[i] = i
    sz[i] = 1
  }
  // Returns the number of elements of uf object.
  this.size = function () {
    return length
  }
  // Returns the number of distinct groups left inside the object.
  this.count = function () {
    return cnt
  }
  // Return the root (value) of the group in which p is.
  this.find = function (p) {
    p = key(p)
    while (p !== id[p]) {
      id[p] = id[id[p]]
      p = id[p]
    }
    return p
  }
  // Returns true if p and p are both in same group, false otherwise.
  this.connected = function (p, q) {
    p = key(p)
    q = key(q)
    ensureIndexWithinBounds(p, q)
    return this.find(p) === this.find(q)
  }
  // Combine elements in groups p and q into a single group. In other words connect the two groups.
  this.union = function (p, q) {
    p = key(p)
    q = key(q)
    ensureIndexWithinBounds(p, q)
    const i = this.find(p)
    const j = this.find(q)
    if (i === j) return
    if (sz[i] < sz[j]) {
      id[i] = j; sz[j] += sz[i]
    } else {
      id[j] = i; sz[i] += sz[j]
    }
    cnt--
  }
  function ensureIndexWithinBounds (args) {
    for (let i = arguments.length - 1; i >= 0; i--) {
      const p = arguments[i]
      if (p >= length) throw new Error('Index out of bounds. The maximum index can be length-1')
    }
  }
}

export { UnionFind }
/* Binary Search: https://en.wikipedia.org/wiki/Binary_search_algorithm
 *
 * Search a sorted array by repeatedly dividing the search interval
 * in half. Begin with an interval covering the whole array. If the value of the
 * search key is less than the item in the middle of the interval, narrow the interval
 * to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the
 * value is found or the interval is empty.
 */

function binarySearchRecursive (arr, x, low = 0, high = arr.length - 1) {
  const mid = Math.floor(low + (high - low) / 2)

  if (high >= low) {
    if (arr[mid] === x) {
      // item found => return its index
      return mid
    }

    if (x < arr[mid]) {
      // arr[mid] is an upper bound for x, so if x is in arr => low <= x < mid
      return binarySearchRecursive(arr, x, low, mid - 1)
    } else {
      // arr[mid] is a lower bound for x, so if x is in arr => mid < x <= high
      return binarySearchRecursive(arr, x, mid + 1, high)
    }
  } else {
    // if low > high => we have searched the whole array without finding the item
    return -1
  }
}
function binarySearchIterative (arr, x, low = 0, high = arr.length - 1) {
  while (high >= low) {
    const mid = Math.floor(low + (high - low) / 2)

    if (arr[mid] === x) {
      // item found => return its index
      return mid
    }

    if (x < arr[mid]) {
      // arr[mid] is an upper bound for x, so if x is in arr => low <= x < mid
      high = mid - 1
    } else {
      // arr[mid] is a lower bound for x, so if x is in arr => mid < x <= high
      low = mid + 1
    }
  }
  // if low > high => we have searched the whole array without finding the item
  return -1
}

export { binarySearchIterative, binarySearchRecursive }
/**
 * Interpolation Search
 *
 * Time Complexity:
 * -Best case: O(1)
 * -Worst case: O(n)
 * -O((log(log(n))) If the data are uniformly distributed
 *
 *
 */

export function interpolationSearch (arr, key) {
  const length = arr.length - 1
  let low = 0
  let high = length
  let position = -1
  let delta = -1

  // Because the array is sorted the key must be between low and high
  while (low <= high && key >= arr[low] && key <= arr[high]) {
    delta = (key - arr[low]) / (arr[high] - arr[low])
    position = low + Math.floor((high - low) * delta)

    // Target found return its position
    if (arr[position] === key) {
      return position
    }

    // If the key is larger then it is in the upper part of the array
    if (arr[position] < key) {
      low = position + 1
      // If the key is smaller then it is in the lower part of the array
    } else {
      high = position - 1
    }
  }

  return -1
}

// const arr = [2, 6, 8, 10, 12, 14, 16, 18, 20, 22, 26, 34, 39]

// interpolationSearch(arr, 2)
// interpolationSearch(arr, 12)
// interpolationSearch(arr, 1000)
// interpolationSearch(arr, 39)
/* Ternary search is similar to binary search but it divide the sorted array
 * into three parts and determine which part the key lies in. The array will
 * be divided into three intervals by using two middle points, mid1 and mid2.
 * The value of the key will first compared with the two mid points, the value
 * will be returned if there is a match. Then, if the value of the key is less
 * than mid1, narrow the interval to the first part. Else, if the value of the
 * key is greater than mid2, narrow the interval to the third part. Otherwise,
 * narrow the interval to the middle part. Repeat the steps until the value is
 * found or the interval is empty(value not found after checking all elements).
 *
 * Reference: https://www.geeksforgeeks.org/ternary-search/
 */

function ternarySearchRecursive (arr, key, low = 0, high = arr.length - 1) {
  if (high >= low) {
    // find the mid1 and mid2
    const mid1 = Math.floor(low + (high - low) / 3)
    const mid2 = Math.floor(high - (high - low) / 3)

    // check if key is found at any mid
    if (arr[mid1] === key) {
      // return index of key if found
      return mid1
    }
    if (arr[mid2] === key) {
      // return index of key if found
      return mid2
    }

    // since the key is not found at mid,
    // check in which region it is present
    // and repeat the Search operation
    // in that region
    if (key < arr[mid1]) {
      // the key lies in between low and mid1
      return ternarySearchRecursive(arr, key, low, mid1 - 1)
    } else if (key > arr[mid2]) {
      // the key lies in between mid2 and high
      return ternarySearchRecursive(arr, key, mid2 + 1, high)
    } else {
      // the key lies in between mid1 and mid2
      return ternarySearchRecursive(arr, key, mid1 + 1, mid2 - 1)
    }
  } else {
    // if low > high => we have searched the whole array without finding the item
    return -1
  }
}

function ternarySearchIterative (arr, key, low = 0, high = arr.length - 1) {
  while (high >= low) {
    // find the mid1 and mid2
    const mid1 = Math.floor(low + (high - low) / 3)
    const mid2 = Math.floor(high - (high - low) / 3)

    // check if key is found at any mid
    if (arr[mid1] === key) {
      // return index of key if found
      return mid1
    }
    if (arr[mid2] === key) {
      // return index of key if found
      return mid2
    }

    // since the key is not found at mid,
    // check in which region it is present
    // and repeat the Search operation
    // in that region
    if (key < arr[mid1]) {
      // the key lies in between low and mid1
      high = mid1 - 1
    } else if (key > arr[mid2]) {
      // the key lies in between mid2 and high
      low = mid2 + 1
    } else {
      // the key lies in between mid1 and mid2
      low = mid1 + 1
      high = mid2 - 1
    }
  }
  // the key was not found
  return -1
}

export { ternarySearchRecursive, ternarySearchIterative }
/****************************************************************************
 * Fibonacci Search JavaScript Implementation
 * Author   Alhassan Atama Isiaka
 * Version v1.0.0
 * Copyright 2020
 * https://github.com/komputarist
 *
 * This implementation is based on Generalizing the Fibonacci search we
 * define the Fibonacci search of degree K. Like the Fibonacci search,
 * which it reduces to for K = 2, the Fibonacci search of degree K
 * involves only addition and subtraction.
 *  Capocelli R.M. (1991) A Generalization of the Fibonacci Search. In:
 * Bergum G.E., Philippou A.N., Horadam A.F. (eds) Applications of Fibonacci
 * Numbers. Springer, Dordrecht. https://doi.org/10.1007/978-94-011-3586-3_9
 *
 * This snippet is free. Feel free to improve on it
 *
 * We define a function fibonacciSearch() that takes an array of numbers,
 * the item (number) to be searched for and the length of the items in the array
 ****************************************************************************/

export const fibonacciSearch = (arr, x, n) => {
  let fib2 = 0 // (K-2)'th Fibonacci Number
  let fib1 = 1 // (K-1)'th Fibonacci Number.
  let fibK = fib2 + fib1 // Kth Fibonacci

  /* We want to store the smallest fibonacci number smaller such that
    number is greater than or equal to n, we use fibK for this */
  while (fibK < n) {
    fib2 = fib1
    fib1 = fibK
    fibK = fib2 + fib1
  }
  //  This marks the eliminated range from front
  let offset = -1

  /* while there are elements to be checked. We compare arr[fib2] with x.
    When fibM becomes 1, fib2 becomes 0 */

  while (fibK > 1) {
    // Check if fibK is a valid location
    const i = Math.min(offset + fib2, n - 1)

    /*  If x is greater than the value at
      index fib2, Partition the subarray array
      from offset to i */
    if (arr[i] < x) {
      fibK = fib1
      fib1 = fib2
      fib2 = fibK - fib1
      offset = i
      /* If x is greater than the value at
            index fib2, cut the subarray array
            from offset to i */
    } else if (arr[i] > x) {
      fibK = fib2
      fib1 = fib1 - fib2
      fib2 = fibK - fib1
    } else {
    //  return index for found element
      return i
    }
  }

  //    comparing the last element with x */
  if (fib1 && arr[offset + 1] === x) {
    return offset + 1
  }
  //    element not found. return -1
  return -1
}

// Example
// const myArray = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
// const n = myArray.length
// const x = 90
// const fibFinder = fibonacciSearch(myArray, x, n)
/**
 * @function fibonacci
 * @description Fibonacci is the sum of previous two fibonacci numbers.
 * @param {Integer} N - The input integer
 * @return {Integer} fibonacci of N.
 * @see [Fibonacci_Numbers](https://en.wikipedia.org/wiki/Fibonacci_number)
 */
const fibonacci = (N) => {
  if (!Number.isInteger(N)) {
    throw new TypeError('Input should be integer')
  }

  // memoize the last two numbers
  let firstNumber = 0
  let secondNumber = 1

  for (let i = 1; i < N; i++) {
    const sumOfNumbers = firstNumber + secondNumber
    // update last two numbers
    firstNumber = secondNumber
    secondNumber = sumOfNumbers
  }

  return N ? secondNumber : firstNumber
}

export { fibonacci }
/*
Given an array of non-negative integers and a value sum,
determine the total number of the subset with sum
equal to the given sum.
*/
/*
 Given solution is O(n*sum) Time complexity and O(sum) Space complexity
*/
function NumberOfSubsetSum (array, sum) {
  const dp = [] // create an dp array where dp[i] denote number of subset with sum equal to i
  for (let i = 1; i <= sum; i++) {
    dp[i] = 0
  }
  dp[0] = 1 // since sum equal to 0 is always possible with no element in subset

  for (let i = 0; i < array.length; i++) {
    for (let j = sum; j >= array[i]; j--) {
      if (j - array[i] >= 0) {
        dp[j] += dp[j - array[i]]
      }
    }
  }
  return dp[sum]
}

// example

// const array = [1, 1, 2, 2, 3, 1, 1]
// const sum = 4
// const result = NumberOfSubsetSum(array, sum)

export { NumberOfSubsetSum }
/*
Wikipedia -> https://en.wikipedia.org/wiki/Edit_distance

Q. -> Given two strings `word1` and `word2`. You can perform these operations on any of the string to make both strings similar.
    - Insert
    - Remove
    - Replace
Find the minimum operation cost required to make both same. Each operation cost is 1.

Algorithm details ->
time complexity - O(n*m)
space complexity - O(n*m)
*/

const minimumEditDistance = (word1, word2) => {
  const n = word1.length
  const m = word2.length
  const dp = new Array(m + 1).fill(0).map(item => [])

  /*
    fill dp matrix with default values -
        - first row is filled considering no elements in word2.
        - first column filled considering no elements in word1.
    */

  for (let i = 0; i < n + 1; i++) {
    dp[0][i] = i
  }

  for (let i = 0; i < m + 1; i++) {
    dp[i][0] = i
  }

  /*
        indexing is 1 based for dp matrix as we defined some known values at first row and first column/
    */

  for (let i = 1; i < m + 1; i++) {
    for (let j = 1; j < n + 1; j++) {
      const letter1 = word1[j - 1]
      const letter2 = word2[i - 1]

      if (letter1 === letter2) {
        dp[i][j] = dp[i - 1][j - 1]
      } else {
        dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1
      }
    }
  }

  return dp[m][n]
}

export { minimumEditDistance }
/*
Given a data set of an unknown size,
Get a random sample in a random order
It's used in data analytics, often as a way to get a small random sample from a data lake or warehouse, or from a large CSV file
*/
function shuf (datasetSource, sampleSize) {
  const output = fillBaseSample(datasetSource, sampleSize)

  return randomizeOutputFromDataset(datasetSource, output)
}

/**
 * Fills the output if possible, with the minimum number of values
 * @param {Iterable.<T>} datasetSource The iterable source of data
 * @param {number} sampleSize The size of the sample to extract from the dataset
 * @returns {Array.<T>} The random sample, as an array
 * @template T
 */
function fillBaseSample (datasetSource, sampleSize) {
  let filledIndexes = []
  let output = new Array(sampleSize)

  // Spread data out filling the array
  while (true) {
    const iterator = datasetSource.next()
    if (iterator.done) break

    let insertTo = Math.floor(Math.random() * output.length)
    while (filledIndexes.includes(insertTo)) {
      insertTo++
      if (insertTo === output.length) {
        insertTo = 0
      }
    }
    output[insertTo] = {
      value: iterator.value
    }

    filledIndexes = [...filledIndexes, insertTo]

    if (filledIndexes.length === sampleSize) {
      break
    }
  }

  if (filledIndexes.length < output.length) {
    // Not a large enough dataset to fill the sample - trim empty values
    output = output.filter((_, i) => filledIndexes.includes(i))
  }

  return output.map((o) => o.value)
}

/**
 * Replaces values in the output randomly with new ones from the dataset
 * @param {Iterable.<T>} datasetSource The iterable source of data
 * @param {Array.<T>} output The output so far, filled with data
 * @returns {Array.<T>} The random sample, as an array
 * @template T
 */
function randomizeOutputFromDataset (datasetSource, output) {
  const newOutput = [...output]
  let readSoFar = output.length

  while (true) {
    const iterator = datasetSource.next()
    if (iterator.done) break
    readSoFar++

    const insertTo = Math.floor(Math.random() * readSoFar)
    if (insertTo < newOutput.length) {
      newOutput[insertTo] = iterator.value
    }
  }

  return newOutput
}

// Example

/**
 * Generates a random range of data, with values between 0 and 2^31 - 1
 * @param {number} length The number of data items to generate
 * @returns {Iterable<number>} Random iterable data
*/
function * generateRandomData (length) {
  const maxValue = Math.pow(2, 31) - 1
  for (let i = 0; i < length; i++) {
    yield Math.floor(Math.random() * maxValue)
  }
}

// const source = generateRandomData(1000)
// const result = shuf(source, 10)

export { shuf, generateRandomData }
import { PermutationinString } from '../PermutationinString.js'

describe('PermutationinString', () => {
  it("should  return true if one of s1's permutations is the substring of s2", () => {
    expect(PermutationinString('ab', 'eidbaooo')).toEqual(true)
    expect(PermutationinString('abc', 'bcab')).toEqual(true)
    expect(PermutationinString('ab', 'eidboaoo')).toEqual(false)
    expect(PermutationinString('abc', '')).toEqual(false)
  })
})
import { LongestSubstringWithoutRepeatingCharacters } from '../LongestSubstringWithoutRepeatingCharacters.js'

describe('LongestSubstringWithoutRepeatingCharacters', () => {
  it('should return longest substring without repeating characters', () => {
    expect(LongestSubstringWithoutRepeatingCharacters('abcabcbb')).toEqual(3)
    expect(LongestSubstringWithoutRepeatingCharacters('bbbbb')).toEqual(1)
    expect(LongestSubstringWithoutRepeatingCharacters('pwwkew')).toEqual(3)
    expect(LongestSubstringWithoutRepeatingCharacters('a')).toEqual(1)
    expect(LongestSubstringWithoutRepeatingCharacters('')).toEqual(0)
  })
})
/**
 *  @name The-Sliding-Window Algorithm is primarily used for the problems dealing with linear data structures like Arrays, Lists, Strings etc.
 *  These problems can easily be solved using Brute Force techniques which result in quadratic or exponential time complexity.
 *  Sliding window technique reduces the required time to linear O(n).
 *  @see [The-Sliding-Window](https://www.geeksforgeeks.org/window-sliding-technique/)
 */
/**
 * @function PermutationinString
 * @description Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
 * @param {String} s1 - The input string
 * @param {String} s2 - The input string
 * @return {boolean} - Returns true if s2 contains a permutation of s1, or false otherwise.
 */

export function PermutationinString (s1, s2) {
  if (s1.length > s2.length) return false
  let start = 0
  let end = s1.length - 1
  const s1Set = SetHash()
  const s2Set = SetHash()
  for (let i = 0; i < s1.length; i++) {
    s1Set[s1[i]]++
    s2Set[s2[i]]++
  }
  if (equals(s1Set, s2Set)) return true
  while (end < s2.length - 1) {
    if (equals(s1Set, s2Set)) return true
    end++
    const c1 = s2[start]
    const c2 = s2[end]
    if (s2Set[c1] > 0) s2Set[c1]--
    s2Set[c2]++
    start++
    if (equals(s1Set, s2Set)) return true
  }
  return false
}
function equals (a, b) {
  return JSON.stringify(a) === JSON.stringify(b)
}

function SetHash () {
  const set = new Set()
  const alphabets = 'abcdefghijklmnopqrstuvwxyz'
  for (let i = 0; i < alphabets.length; i++) {
    set[alphabets[i]] = 0
  }
  return set
}

// Example 1:
// Input: s1 = "ab", s2 = "eidbaooo"
// Output: true
// Explanation: s2 contains one permutation of s1 ("ba").

// Example 2:
// Input: s1 = "ab", s2 = "eidboaoo"
// Output: false
/**
 *  @name The-Sliding-Window Algorithm is primarily used for the problems dealing with linear data structures like Arrays, Lists, Strings etc.
 *  These problems can easily be solved using Brute Force techniques which result in quadratic or exponential time complexity.
 *  Sliding window technique reduces the required time to linear O(n).
 *  @see [The-Sliding-Window](https://www.geeksforgeeks.org/window-sliding-technique/)
 */

/**
 * @function LongestSubstringWithoutRepeatingCharacters
 * @description Get the length of the longest substring without repeating characters
 * @param {String} s - The input string
 */
export function LongestSubstringWithoutRepeatingCharacters (s) {
  let maxLength = 0
  let start = 0
  let end = 0
  const map = {}
  while (end < s.length) {
    if (map[s[end]] === undefined) {
      map[s[end]] = 1
      maxLength = Math.max(maxLength, end - start + 1)
      end++
    } else {
      while (s[start] !== s[end]) {
        delete map[s[start]]
        start++
      }
      delete map[s[start]]
      start++
    }
  }
  return maxLength
}

// Example 1:
// Input: s = "abcabcbb"
// Output: 3
// Explanation: The answer is "abc", with the length of 3.

// Example 2:
// Input: s = "bbbbb"
// Output: 1
// Explanation: The answer is "b", with the length of 1.

// Example 3:
// Input: s = "pwwkew"
// Output: 3
// Explanation: The answer is "wke", with the length of 3.
// Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
/**
 * A Dynamic Programming based solution for calculating Zero One Knapsack
 * https://en.wikipedia.org/wiki/Knapsack_problem
 */

const zeroOneKnapsack = (arr, n, cap, cache) => {
  if (cap === 0 || n === 0) {
    cache[n][cap] = 0
    return cache[n][cap]
  }
  if (cache[n][cap] !== -1) {
    return cache[n][cap]
  }
  if (arr[n - 1][0] <= cap) {
    cache[n][cap] = Math.max(arr[n - 1][1] + zeroOneKnapsack(arr, n - 1, cap - arr[n - 1][0], cache), zeroOneKnapsack(arr, n - 1, cap, cache))
    return cache[n][cap]
  } else {
    cache[n][cap] = zeroOneKnapsack(arr, n - 1, cap, cache)
    return cache[n][cap]
  }
}

const example = () => {
  /*
  Problem Statement:
  You are a thief carrying a single bag with limited capacity S. The museum you stole had N artifact that you could steal. Unfortunately you might not be able to steal all the artifact because of your limited bag capacity.
  You have to cherry pick the artifact in order to maximize the total value of the artifacts you stole.

  Link for the Problem: https://www.hackerrank.com/contests/srin-aadc03/challenges/classic-01-knapsack
  */
  let input = `1
    4 5
    1 8
    2 4
    3 0
    2 5
    2 3`

  input = input.trim().split('\n')
  input.shift()
  const length = input.length

  const output = []

  let i = 0
  while (i < length) {
    const cap = Number(input[i].trim().split(' ')[0])
    const currlen = Number(input[i].trim().split(' ')[1])
    let j = i + 1
    const arr = []
    while (j <= i + currlen) {
      arr.push(input[j])
      j++
    }
    const newArr = arr.map(e =>
      e.trim().split(' ').map(Number)
    )
    const cache = []
    for (let i = 0; i <= currlen; i++) {
      const temp = []
      for (let j = 0; j <= cap; j++) {
        temp.push(-1)
      }
      cache.push(temp)
    }
    const result = zeroOneKnapsack(newArr, currlen, cap, cache)
    output.push(result)
    i += currlen + 1
  }

  return output
}

export { zeroOneKnapsack, example }

const isValid = (board, row, col, k) => {
  for (let i = 0; i < 9; i++) {
    const m = 3 * Math.floor(row / 3) + Math.floor(i / 3)
    const n = 3 * Math.floor(col / 3) + i % 3
    if (board[row][i] === k || board[i][col] === k || board[m][n] === k) {
      return false
    }
  }
  return true
}

const sudokuSolver = (data) => {
  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 9; j++) {
      if (data[i][j] === '.') {
        for (let k = 1; k <= 9; k++) {
          if (isValid(data, i, j, `${k}`)) {
            data[i][j] = `${k}`
            if (sudokuSolver(data)) {
              return true
            } else {
              data[i][j] = '.'
            }
          }
        }
        return false
      }
    }
  }
  return true
}

// testing

// const board = [
//   ['.', '9', '.', '.', '4', '2', '1', '3', '6'],
//   ['.', '.', '.', '9', '6', '.', '4', '8', '5'],
//   ['.', '.', '.', '5', '8', '1', '.', '.', '.'],
//   ['.', '.', '4', '.', '.', '.', '.', '.', '.'],
//   ['5', '1', '7', '2', '.', '.', '9', '.', '.'],
//   ['6', '.', '2', '.', '.', '.', '3', '7', '.'],
//   ['1', '.', '.', '8', '.', '4', '.', '2', '.'],
//   ['7', '.', '6', '.', '.', '.', '8', '1', '.'],
//   ['3', '.', '.', '.', '9', '.', '.', '.', '.']
// ]
// sudokuSolver(board) // -> board updated by reference

export { sudokuSolver }
/**
 * @function Tribonacci
 * @description Tribonacci is the sum of previous three tribonacci numbers.
 * @param {Integer} n - The input integer
 * @return {Integer} tribonacci of n.
 * @see [Tribonacci_Numbers](https://www.geeksforgeeks.org/tribonacci-numbers/)
 */
const tribonacci = (n) => {
  // creating array to store previous tribonacci numbers
  const dp = new Array(n + 1)
  dp[0] = 0
  dp[1] = 1
  dp[2] = 1
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
  }
  return dp[n]
}

export { tribonacci }
/**
 * @function ClimbStairs
 * @description You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
 * @param {Integer} n - The input integer
 * @return {Integer} distinct ways can you climb to the top.
 * @see [Climb_Stairs](https://www.geeksforgeeks.org/count-ways-reach-nth-stair/)
 */

const climbStairs = (n) => {
  let prev = 0
  let cur = 1
  let temp

  for (let i = 0; i < n; i++) {
    temp = prev
    prev = cur
    cur += temp
  }
  return cur
}

export { climbStairs }
import { tribonacci } from '../TribonacciNumber'

describe('TribonacciNumber', () => {
  it('tribonacci of 0', () => {
    expect(tribonacci(0)).toBe(0)
  })

  it('tribonacci of 1', () => {
    expect(tribonacci(1)).toBe(1)
  })

  it('tribonacci of 2', () => {
    expect(tribonacci(2)).toBe(1)
  })

  it('tribonacci of 10', () => {
    expect(tribonacci(10)).toBe(149)
  })

  it('tribonacci of 25', () => {
    expect(tribonacci(25)).toBe(1389537)
  })
})
import { kadaneAlgo } from '../KadaneAlgo'
test('it is being checked that 15 is the answer to the corresponding array input', () => {
  expect(kadaneAlgo([1, 2, 3, 4, 5])).toBe(15)
})

test('it is being checked that 5 is the answer to the corresponding array input', () => {
  expect(kadaneAlgo([-1, -2, -3, -4, 5])).toBe(5)
})
import { trap } from '../TrappingRainWater'

describe('TrappingRainWater', () => {
  it('expects 6 units of rain water are being trapped', () => {
    expect(trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6)
  })

  it('expects 9 units of rain water are being trapped', () => {
    expect(trap([4, 2, 0, 3, 2, 5])).toBe(9)
  })
})
import { maxProductOfThree } from '../MaxProductOfThree'

describe('MaxProductOfThree', () => {
  it('expects to throw error for array with only 2 numbers', () => {
    expect(() => {
      maxProductOfThree([1, 3])
    }).toThrow('Triplet cannot exist with the given array')
  })

  it('expects to return 300 as the maximum product', () => {
    expect(maxProductOfThree([10, 6, 5, 3, 1, -10])).toBe(300)
  })

  it('expects to return 300 as the maximum product', () => {
    expect(maxProductOfThree([10, -6, 5, 3, 1, -10])).toBe(600)
  })
})
import { change, coinChangeMin } from '../CoinChange'

test('Base Case 1', () => {
  const coins = [2, 3, 5]
  const amount = 0
  expect(change(coins, amount)).toBe(1)
  expect(coinChangeMin(coins, amount)).toBe(0)
})
test('Base Case 2', () => {
  const coins = []
  const amount = 100
  expect(change(coins, amount)).toBe(0)
  expect(coinChangeMin(coins, amount)).toBe(-1)
})
test('Test Case 1', () => {
  const coins = [2, 4, 5]
  const amount = 12
  expect(change(coins, amount)).toBe(5)
  expect(coinChangeMin(coins, amount)).toBe(3)
})
test('Test Case 2', () => {
  const coins = [5, 2, 3, 7, 6, 1, 12, 11, 9, 15]
  const amount = 45
  expect(change(coins, amount)).toBe(12372)
  expect(coinChangeMin(coins, amount)).toBe(3)
})
test('Test Case 3', () => {
  const coins = [2]
  const amount = 3
  expect(change(coins, amount)).toBe(0)
  expect(coinChangeMin(coins, amount)).toBe(-1)
})
test('Test Case 4', () => {
  const coins = [3, 5, 7, 8, 9, 10, 11]
  const amount = 500
  expect(change(coins, amount)).toBe(35502874)
  expect(coinChangeMin(coins, amount)).toBe(46)
})
test('Test Case 5', () => {
  const coins = [10]
  const amount = 10
  expect(change(coins, amount)).toBe(1)
  expect(coinChangeMin(coins, amount)).toBe(1)
})
import { sieveOfEratosthenes } from '../SieveOfEratosthenes'

describe('SieveOfEratosthenes', () => {
  it('Primes till 0', () => {
    expect(sieveOfEratosthenes(0)).toEqual([])
  })

  it('Primes till 1', () => {
    expect(sieveOfEratosthenes(1)).toEqual([])
  })

  it('Primes till 10', () => {
    expect(sieveOfEratosthenes(10)).toEqual([2, 3, 5, 7])
  })

  it('Primes till 23', () => {
    expect(sieveOfEratosthenes(23)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23])
  })

  it('Primes till 70', () => {
    expect(sieveOfEratosthenes(70)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67])
  })
})
import { longestPalindromeSubsequence } from '../LongestPalindromicSubsequence'

describe('LongestPalindromicSubsequence', () => {
  it('expects to return 1 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('abcdefgh')).toBe(1)
  })

  it('expects to return 4 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('bbbab')).toBe(4)
  })

  it('expects to return 2 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('cbbd')).toBe(2)
  })

  it('expects to return 7 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('racexyzcxar')).toBe(7)
  })
})
import { longestValidParentheses } from '../LongestValidParentheses'

describe('longestValidParentheses', () => {
  it('expects to return 0 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('')).toBe(0)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('(()')).toBe(2)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses(')()())')).toBe(4)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('(((')).toBe(0)
  })
})
import { longestCommonSubsequence } from '../LongestCommonSubsequence'

describe('LongestCommonSubsequence', () => {
  it('expects to return an empty string for empty inputs', () => {
    expect(longestCommonSubsequence('', '')).toEqual(''.length)
    expect(longestCommonSubsequence('aaa', '')).toEqual(''.length)
    expect(longestCommonSubsequence('', 'bbb')).toEqual(''.length)
  })

  it('expects to return an empty string for inputs without a common subsequence', () => {
    expect(longestCommonSubsequence('abc', 'deffgf')).toEqual(''.length)
    expect(longestCommonSubsequence('de', 'ghm')).toEqual(''.length)
    expect(longestCommonSubsequence('aupj', 'xyz')).toEqual(''.length)
  })

  it('expects to return the longest common subsequence, short inputs', () => {
    expect(longestCommonSubsequence('abc', 'abc')).toEqual('abc'.length)
    expect(longestCommonSubsequence('abc', 'abcd')).toEqual('abc'.length)
    expect(longestCommonSubsequence('abc', 'ab')).toEqual('ab'.length)
    expect(longestCommonSubsequence('abc', 'a')).toEqual('a'.length)
    expect(longestCommonSubsequence('abc', 'b')).toEqual('b'.length)
    expect(longestCommonSubsequence('abc', 'c')).toEqual('c'.length)
    expect(longestCommonSubsequence('abd', 'abcd')).toEqual('abd'.length)
    expect(longestCommonSubsequence('abd', 'ab')).toEqual('ab'.length)
    expect(longestCommonSubsequence('abc', 'abd')).toEqual('ab'.length)
  })

  it('expects to return the longest common subsequence, medium-length inputs', () => {
    expect(longestCommonSubsequence('bsbininm', 'jmjkbkjkv')).toEqual('b'.length)
    expect(longestCommonSubsequence('oxcpqrsvwf', 'shmtulqrypy')).toEqual('qr'.length)
  })
})
import { rodCut } from '../RodCutting'

test('Test Case 1', () => {
  expect(rodCut([1, 5, 8, 9, 10, 17, 17, 20], 8)).toBe(22)
})

test('Test Case 2', () => {
  expect(rodCut([1, 5, 4, 2, 1, 11, 19, 12], 8)).toBe(20)
})

test('Test Case 3', () => {
  expect(rodCut([1, 2, 1], 3)).toBe(3)
})

test('Test Case 4', () => {
  expect(rodCut([5, 4, 3, 2, 1], 5)).toBe(25)
})

test('Test Case 5', () => {
  expect(rodCut([3, 5, 8, 8, 10, 16, 14, 19], 8)).toBe(24)
})
import { fibonacci } from '../FibonacciNumber'

describe('Testing FibonacciNumber', () => {
  it('Testing for invalid type', () => {
    expect(() => fibonacci('0')).toThrowError()
    expect(() => fibonacci('12')).toThrowError()
    expect(() => fibonacci(true)).toThrowError()
  })

  it('fibonacci of 0', () => {
    expect(fibonacci(0)).toBe(0)
  })

  it('fibonacci of 1', () => {
    expect(fibonacci(1)).toBe(1)
  })

  it('fibonacci of 10', () => {
    expect(fibonacci(10)).toBe(55)
  })

  it('fibonacci of 25', () => {
    expect(fibonacci(25)).toBe(75025)
  })
})
import { climbStairs } from '../ClimbingStairs'

describe('ClimbingStairs', () => {
  it('climbStairs of 0', () => {
    expect(climbStairs(0)).toBe(1)
  })

  it('climbStairs of 1', () => {
    expect(climbStairs(1)).toBe(1)
  })

  it('climbStairs of 10', () => {
    expect(climbStairs(10)).toBe(89)
  })

  it('climbStairs of 15', () => {
    expect(climbStairs(15)).toBe(987)
  })
})
/**
 * @param {number[]} height
 * @return {number}
 */

/* 42. Trapping Rain Water
https://leetcode.com/problems/trapping-rain-water/

Helpful animation of this prompt: https://youtu.be/HmBbcDiJapY?t=51

Given n non-negative integers representing an elevation map where
the width of each bar is 1, compute how much water it is able to trap
after raining.

VIEW ELEVATION MAP ON LEETCODE

Example:

Input:            [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6

Plan:
iterate through and find left maxes
iterate through and find right maxes
create minheight and assign it to the min(leftmax, rightmax)
if current height(element) < minheight
  push minheight - height into water array
else
  push 0 onto water array

sum up water array and return

left maxes =      [0,0,1,1,2,2,2,2,3,3,3,3]
right maxes =     [3,3,3,3,3,3,3,2,2,2,1,0]
water contained = [0,0,1,0,1,2,1,0,0,1,0,0] -> sum = 6
*/

export const trap = (heights) => {
  const maxes = new Array(heights.length).fill(0)

  let leftMax = 0
  for (let i = 0; i < heights.length; i++) {
    const height = heights[i]
    maxes[i] = leftMax
    leftMax = Math.max(leftMax, height)
  }

  let rightMax = 0
  for (let i = heights.length - 1; i >= 0; i -= 1) {
    const height = heights[i]
    const minHeight = Math.min(rightMax, maxes[i])

    if (height < minHeight) {
      maxes[i] = minHeight - height
    } else {
      maxes[i] = 0
    }
    rightMax = Math.max(rightMax, height)
  }
  return maxes.reduce((a, b) => a + b, 0)
}
/*
Problem:
Given two sequences, find the length of longest subsequence present in both of them.
A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.
For example, abc, abg, bdf, aeg, acefg, .. etc are subsequences of abcdefg

Our Solution:
We use recursion with tabular memoization.
Time complexity: O(M x N)
Solving each subproblem has a cost of O(1). Again, there are MxN subproblems,
and so we get a total time complexity of O(MxN).
Space complexity: O(M x N)
We need to store the answer for each of the MxN subproblems.

Improvement:
It's possible to optimize space complexity to O(min(M, N)) or time to O((N + r)log(N))
where r is the number of matches between the two sequences. Try to figure out how.

References:
[wikipedia](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem)
[leetcode](https://leetcode.com/problems/longest-common-subsequence/)
*/

/**
 * Finds length of the longest common subsequence among the two input string
 * @param {string} str1 Input string #1
 * @param {string} str2 Input string #2
 * @returns {number} Length of the longest common subsequence
 */
function longestCommonSubsequence (str1, str2) {
  const memo = new Array(str1.length + 1).fill(null)
    .map(() => new Array(str2.length + 1).fill(null))

  function recursive (end1, end2) {
    if (end1 === -1 || end2 === -1) {
      return 0
    }

    if (memo[end1][end2] !== null) {
      return memo[end1][end2]
    }

    if (str1[end1] === str2[end2]) {
      memo[end1][end2] = 1 + recursive(end1 - 1, end2 - 1)
      return memo[end1][end2]
    } else {
      memo[end1][end2] = Math.max(
        recursive(end1 - 1, end2),
        recursive(end1, end2 - 1)
      )
      return memo[end1][end2]
    }
  }

  return recursive(str1.length - 1, str2.length - 1)
}

export { longestCommonSubsequence }
/**
 *  Given an array of numbers, return the maximum product
 *  of 3 numbers from the array
 *  https://wsvincent.com/javascript-three-sum-highest-product-of-three-numbers/
 * @param {number[]} arrayItems
 * @returns number
 */
export function maxProductOfThree (arrayItems) {
  // if size is less than 3, no triplet exists
  const n = arrayItems.length
  if (n < 3) throw new Error('Triplet cannot exist with the given array')
  let max1 = arrayItems[0]
  let max2 = -1
  let max3 = -1
  let min1 = arrayItems[0]
  let min2 = -1
  for (let i = 1; i < n; i++) {
    if (arrayItems[i] > max1) {
      max3 = max2
      max2 = max1
      max1 = arrayItems[i]
    } else if (max2 === -1 || arrayItems[i] > max2) {
      max3 = max2
      max2 = arrayItems[i]
    } else if (max3 === -1 || arrayItems[i] > max3) {
      max3 = arrayItems[i]
    }
    if (arrayItems[i] < min1) {
      min2 = min1
      min1 = arrayItems[i]
    } else if (min2 === -1 || arrayItems[i] < min2) {
      min2 = arrayItems[i]
    }
  }
  const prod1 = max1 * max2 * max3
  const prod2 = max1 * min1 * min2
  return Math.max(prod1, prod2)
}
/**
 * @function SieveOfEratosthenes
 * @description Calculates prime numbers till input number n
 * @param {Number} n - The input integer
 * @return {Number[]} List of Primes till n.
 * @see [Sieve_of_Eratosthenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/)
 */
function sieveOfEratosthenes (n) {
  if (n <= 1) return []
  const primes = new Array(n + 1).fill(true) // set all as true initially
  primes[0] = primes[1] = false // Handling case for 0 and 1
  for (let i = 2; i * i <= n; i++) {
    if (primes[i]) {
      for (let j = i * i; j <= n; j += i) {
        primes[j] = false
      }
    }
  }

  return primes.reduce((result, isPrime, index) => {
    if (isPrime) {
      result.push(index)
    }
    return result
  }, [])
}

// Example

// const n = 69 // number till where we wish to find primes
// const primes = sieveOfEratosthenes(n)

export { sieveOfEratosthenes }
/*
  LeetCode -> https://leetcode.com/problems/longest-palindromic-subsequence/

  Given a string s, find the longest palindromic subsequence's length in s.
  You may assume that the maximum length of s is 1000.

*/

export const longestPalindromeSubsequence = function (s) {
  const n = s.length

  const dp = new Array(n).fill(0).map(item => new Array(n).fill(0).map(item => 0))

  // fill predefined for single character
  for (let i = 0; i < n; i++) {
    dp[i][i] = 1
  }

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < n - i; j++) {
      const col = j + i
      if (s[j] === s[col]) {
        dp[j][col] = 2 + dp[j + 1][col - 1]
      } else {
        dp[j][col] = Math.max(dp[j][col - 1], dp[j + 1][col])
      }
    }
  }

  return dp[0][n - 1]
}
// Problem Statement => https://www.youtube.com/watch?v=lBRtnuxg-gU

const minCostPath = (matrix) => {
  /*
        Find the min cost path from top-left to bottom-right in matrix
        >>> minCostPath([[2, 1], [3, 1], [4, 2]])
        >>> 6
    */

  const n = matrix.length
  const m = matrix[0].length

  // moves[i][j] => minimum number of moves to reach cell i, j
  const moves = new Array(n)
  for (let i = 0; i < moves.length; i++) moves[i] = new Array(m)

  // base conditions
  moves[0][0] = matrix[0][0] // to reach cell (0, 0) from (0, 0) is of no moves
  for (let i = 1; i < m; i++) moves[0][i] = moves[0][i - 1] + matrix[0][i]
  for (let i = 1; i < n; i++) moves[i][0] = moves[i - 1][0] + matrix[i][0]

  for (let i = 1; i < n; i++) {
    for (let j = 1; j < m; j++) { moves[i][j] = Math.min(moves[i - 1][j], moves[i][j - 1]) + matrix[i][j] }
  }

  return moves[n - 1][m - 1]
}

export { minCostPath }

// Example

// minCostPath([
//   [2, 1],
//   [3, 1],
//   [4, 2]
// ])

// minCostPath([
//   [2, 1, 4],
//   [2, 1, 3],
//   [3, 2, 1]
// ])
/* Kadane's algorithm is one of the most efficient ways to
 * calculate the maximum contiguous subarray sum for a given array.
 * Below is the implementation of kadanes's algorithm along with
 * some sample test cases.
 * There might be a special case in this problem if al the elements
 * of the given array are negative. In such a case, the maximum negative
 * value present in the array is the answer.
 *
 * Reference article :- https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/
 */

export function kadaneAlgo (array) {
  let cummulativeSum = 0
  let maxSum = Number.NEGATIVE_INFINITY // maxSum has the least possible value
  for (let i = 0; i < array.length; i++) {
    cummulativeSum = cummulativeSum + array[i]
    if (maxSum < cummulativeSum) {
      maxSum = cummulativeSum
    } else if (cummulativeSum < 0) {
      cummulativeSum = 0
    }
  }
  return maxSum
  // This function returns largest sum contiguous sum in a array
}
function maximumNonAdjacentSum (nums) {
  /*
         * Find the maximum non-adjacent sum of the integers in the nums input list
         * :param nums: Array of Numbers
         * :return: The maximum non-adjacent sum
    */

  if (nums.length < 0) return 0

  let maxIncluding = nums[0]
  let maxExcluding = 0

  for (const num of nums.slice(1)) {
    const temp = maxIncluding
    maxIncluding = maxExcluding + num
    maxExcluding = Math.max(temp, maxExcluding)
  }

  return Math.max(maxExcluding, maxIncluding)
}

// Example

// maximumNonAdjacentSum([1, 2, 3]))
// maximumNonAdjacentSum([1, 5, 3, 7, 2, 2, 6]))
// maximumNonAdjacentSum([-1, -5, -3, -7, -2, -2, -6]))
// maximumNonAdjacentSum([499, 500, -3, -7, -2, -2, -6]))

export { maximumNonAdjacentSum }
/**
 * A Dynamic Programming based solution for calculation of the Levenshtein Distance
 * https://en.wikipedia.org/wiki/Levenshtein_distance
 */

function minimum (a, b, c) {
  if (a < b && a < c) {
    return a
  } else if (b < a && b < c) {
    return b
  } else {
    return c
  }
}

function costOfSubstitution (x, y) {
  return x === y ? 0 : 1
}

// Levenshtein distance between x and y
function calculate (x, y) {
  const dp = new Array(x.length + 1)
  for (let i = 0; i < x.length + 1; i++) {
    dp[i] = new Array(y.length + 1)
  }

  for (let i = 0; i < x.length + 1; i++) {
    for (let j = 0; j < y.length + 1; j++) {
      if (i === 0) {
        dp[i][j] = j
      } else if (j === 0) {
        dp[i][j] = i
      } else {
        dp[i][j] = minimum(dp[i - 1][j - 1] + costOfSubstitution(x.charAt(i - 1), y.charAt(j - 1)), dp[i - 1][j] + 1, dp[i][j - 1] + 1)
      }
    }
  }

  return dp[x.length][y.length]
}

export { calculate }
/**
 * A Dynamic Programming based solution for calculating Longest Increasing Subsequence
 * https://en.wikipedia.org/wiki/Longest_increasing_subsequence
 */

// Return the length of the Longest Increasing Subsequence, given array x
function longestIncreasingSubsequence (x) {
  const length = x.length
  const dp = Array(length).fill(1)

  let res = 1

  for (let i = 0; i < length; i++) {
    for (let j = 0; j < i; j++) {
      if (x[i] > x[j]) {
        dp[i] = Math.max(dp[i], 1 + dp[j])
        if (dp[i] > res) {
          res = dp[i]
        }
      }
    }
  }

  return res
}

export { longestIncreasingSubsequence }
/*
  * You are given a rod of 'n' length and an array of prices associated with all the lengths less than 'n'.
  * Find the maximum profit possible by cutting the rod and selling the pieces.
*/

export function rodCut (prices, n) {
  const memo = new Array(n + 1)
  memo[0] = 0

  for (let i = 1; i <= n; i++) {
    let maxVal = Number.MIN_VALUE
    for (let j = 0; j < i; j++) { maxVal = Math.max(maxVal, prices[j] + memo[i - j - 1]) }
    memo[i] = maxVal
  }

  return memo[n]
}
/*
  LeetCode -> https://leetcode.com/problems/longest-valid-parentheses/

  Given a string containing just the characters '(' and ')',
  find the length of the longest valid (well-formed) parentheses substring.
*/

export const longestValidParentheses = (s) => {
  const n = s.length
  const stack = []

  // storing results
  const res = new Array(n).fill(-Infinity)

  for (let i = 0; i < n; i++) {
    const bracket = s[i]

    if (bracket === ')' && s[stack[stack.length - 1]] === '(') {
      res[i] = 1
      res[stack[stack.length - 1]] = 1
      stack.pop()
    } else {
      stack.push(i)
    }
  }

  // summing all adjacent valid
  for (let i = 1; i < n; i++) {
    res[i] = Math.max(res[i], res[i] + res[i - 1])
  }

  // adding 0 if there are none so it will return 0 instead of -Infinity
  res.push(0)
  return Math.max(...res)
}
/**
 * @params {Array} coins
 * @params {Number} amount
 */
export const change = (coins, amount) => {
  // Create and initialize the storage
  const combinations = new Array(amount + 1).fill(0)
  combinations[0] = 1
  // Determine the direction of smallest sub-problem
  for (let i = 0; i < coins.length; i++) {
    // Travel and fill the combinations array
    for (let j = coins[i]; j < combinations.length; j++) {
      combinations[j] += combinations[j - coins[i]]
    }
  }
  return combinations[amount]
}
/**
 * @params {Array} coins
 * @params {Number} amount
 */
export const coinChangeMin = (coins, amount) => {
  const map = { 0: 1 }
  for (let i = 1; i <= amount; i++) {
    let min = Infinity
    for (const coin of coins) {
      if (i < coin) continue
      min = Math.min(min, 1 + map[i - coin])
    }
    map[i] = min
  }
  return map[amount] === Infinity ? -1 : map[amount] - 1
}
/*
*  This algorithm accepts a month in the format mm/yyyy.
*  And prints out the month's calendar.
*  It uses an epoch of 1/1/1900, Monday.
*/

class Month {
  constructor () {
    this.Days = ['M', 'T', 'W', 'Th', 'F', 'S', 'Su']
    this.BDays = ['M', 'Su', 'S', 'F', 'Th', 'W', 'T']
    this.epoch = { month: 1, year: 1900 }
    this.monthDays = [31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    this.monthDaysLeap = [31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  }

  printCal (days, startDay, output = value => console.log(value)) {
    output('M   T   W   Th  F   S   Su')
    const dates = []; let i
    for (i = 1; i <= days; i++) {
      dates.push(i)
    }
    for (i = 0; i < this.Days.indexOf(startDay); i++) {
      dates.unshift(' ')
    }
    while (true) {
      let row = ''
      for (i = 0; (i < 7) && (dates.length !== 0); i++) {
        row += dates.shift()
        while ((row.length % 4) !== 0) {
          row += ' '
        }
      }
      output(row)
      if (dates.length === 0) break
    }
  }

  parseDate (date) {
    const dateAr = []; let block = ''; let i
    for (i = 0; i < date.length; i++) {
      if (date[i] === '/') {
        dateAr.push(parseInt(block))
        block = ''
        continue
      }
      block += date[i]
    }
    dateAr.push(parseInt(block))
    if (dateAr.length !== 2) throw new Error('Improper string encoding')
    const dateOb = { month: dateAr[0], year: dateAr[1] }
    return dateOb
  }

  isLeapYear (year) {
    if (((year % 400) === 0) || (((year % 100) !== 0) && ((year % 4) === 0))) return true
    return false
  }

  isGreater (startDate, endDate) {
    if (startDate.year > endDate.year) {
      return true
    } else if (startDate.year < endDate.year) {
      return false
    } else if (startDate.month > endDate.month) {
      return true
    } else if (startDate.month < endDate.month) {
      return false
    }
    return true
  }

  getDayDiff (startDate, endDate) {
    if (this.isGreater(startDate, endDate) === null) {
      return 0
    } else if ((this.isGreater(startDate, endDate) === true)) {
      const midDate = startDate
      startDate = endDate
      endDate = midDate
    }
    let diff = 0
    while (startDate.year !== endDate.year) {
      diff += (this.isLeapYear(startDate.year)) ? 366 : 365
      startDate.year = startDate.year + 1
    }
    while (startDate.month !== endDate.month) {
      if (startDate.month < endDate.month) {
        if (this.isLeapYear(startDate.year)) diff += this.monthDaysLeap[startDate.month]
        else diff += this.monthDays[startDate.month]
        startDate.month = startDate.month + 1
      } else {
        if (this.isLeapYear(startDate.year)) diff -= this.monthDaysLeap[startDate.month - 1]
        else diff -= this.monthDays[startDate.month - 1]
        startDate.month = startDate.month - 1
      }
    }
    return diff
  }

  generateMonthCal (date) {
    const Month = this.parseDate(date); let day = ''
    let difference = this.getDayDiff(this.epoch, Month)
    difference = difference % 7
    let Month2 = this.parseDate(date)
    day = (this.isGreater(Month2, this.epoch)) ? this.Days[difference] : this.BDays[difference]
    Month2 = this.parseDate(date)
    if (this.isLeapYear(Month2.year)) this.printCal(this.monthDaysLeap[Month2.month], day)
    else this.printCal(this.monthDays[Month2.month], day)
  }
}

export { Month }

// const x = new Month()
// x.generateMonthCal('1/2021')
/**
 * @function XORCipher
 * @description - Encrypt using an XOR cipher
 * The XOR cipher is a type of additive cipher.
 * Each character is bitwise XORed with the key.
 * We loop through the input string, XORing each
 * character with the key.
 * @param {string} str - string to be encrypted
 * @param {number} key - key for encryption
 * @return {string} encrypted string
 */
const XORCipher = (str, key) => {
  if (typeof str !== 'string' || !Number.isInteger(key)) {
    throw new TypeError('Arguments type are invalid')
  }

  return str.replace(
    /./g, (char) => String.fromCharCode(char.charCodeAt() ^ key)
  )
}

export default XORCipher
import caesarsCipher from '../CaesarsCipher'

describe('Testing the caesarsCipher function', () => {
  it('Test - 1, Testing for invalid types', () => {
    expect(() => caesarsCipher(false, 3)).toThrow()
    expect(() => caesarsCipher('false', -1)).toThrow()
    expect(() => caesarsCipher('true', null)).toThrow()
  })

  it('Test - 2, Testing for valid string and rotation', () => {
    expect(caesarsCipher('middle-Outz', 2)).toBe('okffng-Qwvb')
    expect(caesarsCipher('abcdefghijklmnopqrstuvwxyz', 3)).toBe('defghijklmnopqrstuvwxyzabc')
    expect(caesarsCipher('Always-Look-on-the-Bright-Side-of-Life', 5)).toBe('Fqbfdx-Qttp-ts-ymj-Gwnlmy-Xnij-tk-Qnkj')
    expect(caesarsCipher('THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG', 23)).toBe('QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD')
  })
})
import { encrypt, decrypt } from '../KeywordShiftedAlphabet'

test('Hello world! === dcrypt(encrypt(Hello world!))', () => {
  const word = 'Hello world!'
  const result = decrypt('keyword', encrypt('keyword', word))
  expect(result).toMatch(word)
})

test('The Algorithms === dcrypt(encrypt(The Algorithms))', () => {
  const word = 'The Algorithms'
  const result = decrypt('keyword', encrypt('keyword', word))
  expect(result).toMatch(word)
})
import Atbash from '../Atbash'

describe('Testing Atbash function', () => {
  it('Test - 1, passing a non-string as an argument', () => {
    expect(() => Atbash(0x345)).toThrow()
    expect(() => Atbash(123)).toThrow()
    expect(() => Atbash(123n)).toThrow()
    expect(() => Atbash(false)).toThrow()
    expect(() => Atbash({})).toThrow()
    expect(() => Atbash([])).toThrow()
  })

  it('Test - 2, passing a string as an argument', () => {
    const clearText = 'The quick brown fox jumps over the lazy dog'
    const cryptText = Atbash(clearText)
    expect(Atbash(cryptText)).toBe(clearText)
  })
})
import XORCipher from '../XORCipher'

describe('Testing XORCipher function', () => {
  it('Test - 1, passing a non-string as an argument', () => {
    expect(() => XORCipher(false, 0x345)).toThrow()
    expect(() => XORCipher(true, 123)).toThrow()
    expect(() => XORCipher(1n, 123n)).toThrow()
    expect(() => XORCipher(false, 0.34)).toThrow()
    expect(() => XORCipher({})).toThrow()
    expect(() => XORCipher([])).toThrow()
  })

  it('Test - 2, passing a string & number as an argument', () => {
    // NB: Node REPL might not output the null char '\x00' (charcode 0)
    expect(XORCipher('test string', 32)).toBe('TEST\x00STRING')
    expect(XORCipher('TEST\x00STRING', 32)).toBe('test string')
  })
})
import ROT13 from '../ROT13'

describe('Testing ROT13 function', () => {
  it('Test - 1, passing a non-string as an argument', () => {
    expect(() => ROT13(0x345)).toThrow()
    expect(() => ROT13(123)).toThrow()
    expect(() => ROT13(123n)).toThrow()
    expect(() => ROT13(false)).toThrow()
    expect(() => ROT13({})).toThrow()
    expect(() => ROT13([])).toThrow()
  })

  it('Test - 2, passing a string as an argument', () => {
    expect(ROT13('Uryyb Jbeyq')).toBe('Hello World')
    expect(ROT13('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')).toBe('NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm')
    expect(ROT13('The quick brown fox jumps over the lazy dog')).toBe('Gur dhvpx oebja sbk whzcf bire gur ynml qbt')
  })
})
import { encrypt, decrypt } from '../VigenereCipher'

test('Hello world! === dcrypt(encrypt(Hello world!))', () => {
  const word = 'Hello world!'
  const result = decrypt(encrypt(word, 'code'), 'code')
  expect(result).toMatch(word)
})

test('The Algorithms === dcrypt(encrypt(The Algorithms))', () => {
  const word = 'The Algorithms'
  const result = decrypt(encrypt(word, 'code'), 'code')
  expect(result).toMatch(word)
})
/**
 * @function caesarsCipher
 * @description - In cryptography, a Caesar cipher, also known as Caesar's cipher, the shift cipher, Caesar's code or Caesar shift, is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, D would be replaced by A, E would become B, and so on. The method is named after Julius Caesar, who used it in his private correspondence.
 * @see - [wiki](https://en.wikipedia.org/wiki/Caesar_cipher)
 * @param  {string} str - string to be encrypted
 * @param {number} rotation - the number of rotation, expect real number ( > 0)
 * @return {string} - decrypted string
 */
const caesarsCipher = (str, rotation) => {
  if (typeof str !== 'string' || !Number.isInteger(rotation) || rotation < 0) {
    throw new TypeError('Arguments are invalid')
  }

  const alphabets = new Array(26)
    .fill()
    .map((_, index) => String.fromCharCode(97 + index)) // generate all lower alphabets array a-z

  const cipherMap = alphabets.reduce(
    (map, char, index) => map.set(char, alphabets[(rotation + index) % 26]),
    new Map()
  )

  return str.replace(/[a-z]/gi, (char) => {
    if (/[A-Z]/.test(char)) {
      return cipherMap.get(char.toLowerCase()).toUpperCase()
    }

    return cipherMap.get(char)
  })
}

export default caesarsCipher
/**
 * @function ROT13
 * @description - ROT13 ("rotate by 13 places", sometimes hyphenated ROT-13) is a simple letter substitution cipher that replaces a letter with the 13th letter after it in the alphabet. ROT13 is a special case of the Caesar cipher which was developed in ancient Rome. Because there are 26 letters (213) in the basic Latin alphabet, ROT13 is its own inverse; that is, to undo ROT13, the same algorithm is applied, so the same action can be used for encoding and decoding. The algorithm provides virtually no cryptographic security, and is often cited as a canonical example of weak encryption.
 * @see - [wiki](https://en.wikipedia.org/wiki/ROT13)
 * @param {String} str - string to be decrypted
 * @return {String} decrypted string
 */
function ROT13 (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

  return str.replace(/[a-z]/gi, (char) => {
    const charCode = char.charCodeAt()

    if (/[n-z]/i.test(char)) {
      return String.fromCharCode(charCode - 13)
    }

    return String.fromCharCode(charCode + 13)
  })
}

export default ROT13
/**
 * Check if the Character is letter or not
 * @param {String} str - character to check
 * @return {object} An array with the character or null if isn't a letter
 */
function isLetter (str) {
  return str.length === 1 && str.match(/[a-zA-Z]/i)
}

/**
 * Check if is Uppercase or Lowercase
 * @param {String} character - character to check
 * @return {Boolean} result of the checking
 */
function isUpperCase (character) {
  if (character === character.toUpperCase()) {
    return true
  }
  if (character === character.toLowerCase()) {
    return false
  }
}

/**
 * Encrypt a Vigenere cipher
 * @param {String} message - string to be encrypted
 * @param {String} key - key for encrypt
 * @return {String} result - encrypted string
 */
function encrypt (message, key) {
  let result = ''

  for (let i = 0, j = 0; i < message.length; i++) {
    const c = message.charAt(i)
    if (isLetter(c)) {
      if (isUpperCase(c)) {
        result += String.fromCharCode((c.charCodeAt(0) + key.toUpperCase().charCodeAt(j) - 2 * 65) % 26 + 65) // A: 65
      } else {
        result += String.fromCharCode((c.charCodeAt(0) + key.toLowerCase().charCodeAt(j) - 2 * 97) % 26 + 97) // a: 97
      }
    } else {
      result += c
    }
    j = ++j % key.length
  }
  return result
}

/**
 * Decrypt a Vigenere cipher
 * @param {String} message - string to be decrypted
 * @param {String} key - key for decrypt
 * @return {String} result - decrypted string
 */
function decrypt (message, key) {
  let result = ''

  for (let i = 0, j = 0; i < message.length; i++) {
    const c = message.charAt(i)
    if (isLetter(c)) {
      if (isUpperCase(c)) {
        result += String.fromCharCode(90 - (25 - (c.charCodeAt(0) - key.toUpperCase().charCodeAt(j))) % 26)
      } else {
        result += String.fromCharCode(122 - (25 - (c.charCodeAt(0) - key.toLowerCase().charCodeAt(j))) % 26)
      }
    } else {
      result += c
    }
    j = ++j % key.length
  }
  return result
}

export { encrypt, decrypt }

// > encrypt('Hello World!', 'code')
// 'Jsopq Zstzg!'

// > decrypt('Jsopq Zstzg!', 'code')
// 'Hello World!'
/**
 * Keyword shifted alphabet is a simple cipher using a translation table created with a help of a keyword.
 * Keyword must be a word where each character can occur only once.
 * To create the translation table, we write all the alphabet characters to the first.
 * Second row start with the keyword, then we continue with the rest of the characters that are missing in alphabetical order.
 *
 * |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|
 * |K|E|Y|W|O|R|D|A|B|C|F|G|H|I|J|L|M|N|P|Q|S|T|U|V|W|Z|
 *
 * Encryption is then just a matter of writing the matching (same index) letter from the second row instead of the first row:
 * 'Hello world' -> 'Aoggj ujngw'
 *
 * Decryption is then just the reverse process of writing the matching (same index) letter from the first row instead of the second row
 * 'Aogg ujngw' -> 'Hello world'
 *
 * Non alphabetical characters (space, exclamation mark, ...) are kept as they are
 */

const alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

function checkKeywordValidity (keyword) {
  keyword.split('').forEach((char, index) => {
    const rest = keyword.slice(0, index) + keyword.slice(index + 1)
    if (rest.indexOf(char) !== -1) {
      return false
    }
  })
  return true
}

function getEncryptedAlphabet (keyword) {
  const encryptedAlphabet = keyword.split('')
  alphabet.forEach((char) => {
    if (encryptedAlphabet.indexOf(char) === -1) {
      encryptedAlphabet.push(char)
    }
  })
  return encryptedAlphabet
}

function translate (sourceAlphabet, targetAlphabet, message) {
  return message.split('').reduce((encryptedMessage, char) => {
    const isUpperCase = char === char.toUpperCase()
    const encryptedCharIndex = sourceAlphabet.indexOf(char.toLowerCase())
    const encryptedChar = encryptedCharIndex !== -1 ? targetAlphabet[encryptedCharIndex] : char
    encryptedMessage += isUpperCase ? encryptedChar.toUpperCase() : encryptedChar
    return encryptedMessage
  }, '')
}

function checkInputs (keyword, message) {
  if (!keyword || !message) {
    throw new Error('Both keyword and message must be specified')
  }

  if (!checkKeywordValidity(keyword)) {
    throw new Error('Invalid keyword!')
  }
}

function encrypt (keyword, message) {
  checkInputs(keyword, message)
  return translate(alphabet, getEncryptedAlphabet(keyword.toLowerCase()), message)
}

function decrypt (keyword, message) {
  checkInputs(keyword, message)
  return translate(getEncryptedAlphabet(keyword.toLowerCase()), alphabet, message)
}

export { encrypt, decrypt }

// encrypt('keyword', 'Hello world!') // Prints 'Aoggj ujngw!'
// decrypt('keyword', 'Aoggj ujngw!') // Prints 'Hello world!
/**
 * @function Atbash - Decrypt a Atbash cipher
 * @description - The Atbash cipher is a particular type of monoalphabetic cipher formed by taking the alphabet and mapping it to its reverse, so that the first letter becomes the last letter, the second letter becomes the second to last letter, and so on.
 * @param {string} str - string to be decrypted/encrypt
 * @return {string} decrypted/encrypted string
 * @see - [wiki](https://en.wikipedia.org/wiki/Atbash)
 */
const Atbash = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

  return str.replace(/[a-z]/gi, (char) => {
    const charCode = char.charCodeAt()

    if (/[A-Z]/.test(char)) {
      return String.fromCharCode(90 + 65 - charCode)
    }

    return String.fromCharCode(122 + 97 - charCode)
  })
}

export default Atbash
/******************************************************
 Find and retrieve the encryption key automatically
 Note: This is a draft version, please help to modify, Thanks!
 ******************************************************/
function keyFinder (str) { // str is used to get the input of encrypted string
  const wordBank = [
    'I ',
    'You ',
    'We ',
    'They ',
    'He ',
    'She ',
    'It ',
    ' the ',
    'The ',
    ' of ',
    ' is ',
    'Is ',
    ' am ',
    'Am ',
    ' are ',
    'Are ',
    ' have ',
    'Have ',
    ' has ',
    'Has ',
    ' may ',
    'May ',
    ' be ',
    'Be ']
  // let wordbankelementCounter = 0;
  // let key = 0; // return zero means the key can not be found
  const inStr = str.toString() // convert the input to String
  let outStr = '' // store the output value
  let outStrElement = '' // temporary store the word inside the outStr, it is used for comparison
  for (let k = 0; k < 26; k++) { // try the number of key shifted, the sum of character from a-z or A-Z is 26
    outStr = caesarCipherEncodeAndDecodeEngine(inStr, k) // use the encryption engine to decrypt the input string

    // loop through the whole input string
    for (let s = 0; s < outStr.length; s++) {
      for (let i = 0; i < wordBank.length; i++) {
        // initialize the outStrElement which is a temp output string for comparison,
        // use a loop to find the next digit of wordBank element and compare with outStr's digit
        for (let w = 0; w < wordBank[i].length; w++) {
          outStrElement += outStr[s + w]
        }
        // this part need to be optimize with the calculation of the number of occurrence of word's probabilities
        // linked list will be used in the next stage of development to calculate the number of occurrence of the key
        if (wordBank[i] === outStrElement) {
          return k // return the key number if founded
        }
        outStrElement = '' // reset the temp word
      } // end for ( let i=0; i < wordBank.length; i++)
    }
  }
  return 0 // return 0 if found nothing
}

/* this sub-function is used to assist the keyFinder to find the key */
function caesarCipherEncodeAndDecodeEngine (inStr, numShifted) {
  const shiftNum = numShifted
  let charCode = 0
  let outStr = ''
  let shiftedCharCode = 0
  let result = 0

  for (let i = 0; i < inStr.length; i++) {
    charCode = inStr[i].charCodeAt()
    shiftedCharCode = charCode + shiftNum
    result = charCode

    if ((charCode >= 48 && charCode <= 57)) {
      if (shiftedCharCode < 48) {
        let diff = Math.abs(48 - 1 - shiftedCharCode) % 10

        while (diff >= 10) {
          diff = diff % 10
        }
        document.getElementById('diffID').innerHTML = diff

        shiftedCharCode = 57 - diff

        result = shiftedCharCode
      } else if (shiftedCharCode >= 48 && shiftedCharCode <= 57) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 57) {
        let diff = Math.abs(57 + 1 - shiftedCharCode) % 10

        while (diff >= 10) {
          diff = diff % 10
        }
        document.getElementById('diffID').innerHTML = diff

        shiftedCharCode = 48 + diff

        result = shiftedCharCode
      }
    } else if ((charCode >= 65 && charCode <= 90)) {
      if (shiftedCharCode <= 64) {
        let diff = Math.abs(65 - 1 - shiftedCharCode) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 90 - diff
        result = shiftedCharCode
      } else if (shiftedCharCode >= 65 && shiftedCharCode <= 90) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 90) {
        let diff = Math.abs(shiftedCharCode - 1 - 90) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 65 + diff
        result = shiftedCharCode
      }
    } else if ((charCode >= 97 && charCode <= 122)) {
      if (shiftedCharCode <= 96) {
        let diff = Math.abs(97 - 1 - shiftedCharCode) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 122 - diff
        result = shiftedCharCode
      } else if (shiftedCharCode >= 97 && shiftedCharCode <= 122) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 122) {
        let diff = Math.abs(shiftedCharCode - 1 - 122) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 97 + diff
        result = shiftedCharCode
      }
    }
    outStr = outStr + String.fromCharCode(parseInt(result))
  }
  return outStr
}

export { keyFinder }

// > keyFinder('test')
// 0
import { getMonthDays } from '../GetMonthDays'

describe('Get the Days of a Month', () => {
  it('expects to return 28', () => {
    expect(getMonthDays(2, 2018)).toEqual(28)
  })

  it('expects to return 30', () => {
    expect(getMonthDays(6, 254)).toEqual(30)
  })

  it('expects to return 29', () => {
    expect(getMonthDays(2, 2024)).toEqual(29)
  })

  it('expects to throw a type error', () => {
    expect(() => { getMonthDays(13, 2020) }).toThrow('Invalid Month Number.')
  })
})
/**
 * @author Nandan V
 * Sunday, 26 July 2020 8:33 AM
 * @description Singleton class that handles the <b>timing of tests</b> and
 *   specs. <br/> The class is singleton as <u>javascript does not support
 *   multiple timer instances<u/>.
 */
class IntervalTimer {
  /**
   * @description Constructor for Timer.
   * @param interval Sets the interval for running the timer.
   * @param callBack The callback function to be executed.
   * @return {IntervalTimer} If exists, the existing object.
   */
  constructor (interval = 10,
    callBack = () => {}) {
    this.prevInterval = 0
    if (this.instance == null) {
      this.interval = interval
      this.callBack = callBack
      this.instance = this
    } else {
      return this.instance
    }
  }

  /**
   * @description Starts the timer.
   */
  startTimer () {
    this.timer = setInterval(this.callBack, this.interval)
  }

  /**
   * @description Resets the timer.
   * @return {number} Elapsed time in milliseconds.
   */
  resetTimer () {
    clearInterval(this.timer)
    this.callBack = () => {}
    return this.getElapsedTime()
  }

  /**
   * @return {number} Elapsed time in milliseconds since reset.
   */
  getElapsedTime (offset = 0) {
    this.timeElapsed = this.timer - this.prevInterval
    this.prevInterval = this.timer
    return this.timeElapsed - offset
  }

  /**
   * @return {number} Elapsed time since start.
   */
  getRunTime () {
    return this.timer
  }
}

/**
 * @author Nandan V
 * Saturday, 01 August 2020 8:33 AM
 * @description Example usage
 */
const ExampleIntervalTimer = function (output = v => console.log(v)) {
  /**
   * Create am object with default settings.
   * @type {IntervalTimer} Used to get timing information.
   */
  const timer = new IntervalTimer()
  timer.startTimer()

  // ... Initialization code ...
  // I generally use it for timing tests in Jasmine JS.

  /**
   * Gets the runtime till this point.
   * Can be subtracted from ElapsedTime to offset timing of initialization code.
   */
  const initOffset = timer.getRunTime()

  // ... A test ...
  // The time taken to run the test.
  output(timer.getElapsedTime(initOffset))

  /**
   * Returns the elapsed time and resets the timer to 0.
   */
  output(timer.resetTimer())
}

export { IntervalTimer, ExampleIntervalTimer }
/**
  function that takes month number and its year and returns the number of days within it
  * @param monthNumber.
  * @param year.
  e.g.: mahfoudh.arous@gmail.com -> true
  e.g.: mahfoudh.arous.com ->false
*/

const getMonthDays = (monthNumber, year) => {
  const the31DaysMonths = [1, 3, 5, 7, 8, 10, 12]
  const the30DaysMonths = [4, 6, 9, 11]

  if (!the31DaysMonths.includes(monthNumber) && !the30DaysMonths.includes(monthNumber) &&
    (monthNumber !== 2)
  ) {
    throw new TypeError('Invalid Month Number.')
  }

  if (the31DaysMonths.includes(monthNumber)) { return 31 }

  if (the30DaysMonths.includes(monthNumber)) { return 30 }

  // Check for Leap year
  if (year % 4 === 0) {
    if ((year % 100 !== 0) || (year % 100 === 0 && year % 400 === 0)) {
      return 29
    }
  }

  return 28
}

export { getMonthDays }
/**
*
* @title Midpoint rule for definite integral evaluation
* @author [ggkogkou](https://github.com/ggkogkou)
* @brief Calculate definite integrals with midpoint method
*
* @details The idea is to split the interval in a number N of intervals and use as interpolation points the xi
* for which it applies that xi = x0 + i*h, where h is a step defined as h = (b-a)/N where a and b are the
* first and last points of the interval of the integration [a, b].
*
* We create a table of the xi and their corresponding f(xi) values and we evaluate the integral by the formula:
* I = h * {f(x0+h/2) + f(x1+h/2) + ... + f(xN-1+h/2)}
*
* N must be > 0 and a<b. By increasing N, we also increase precision
*
* [More info link](https://tutorial.math.lamar.edu/classes/calcii/approximatingdefintegrals.aspx)
*
*/

function integralEvaluation (N, a, b, func) {
  // Check if all restrictions are satisfied for the given N, a, b
  if (!Number.isInteger(N) || Number.isNaN(a) || Number.isNaN(b)) { throw new TypeError('Expected integer N and finite a, b') }
  if (N <= 0) { throw Error('N has to be >= 2') } // check if N > 0
  if (a > b) { throw Error('a must be less or equal than b') } // Check if a < b
  if (a === b) return 0 // If a === b integral is zero

  // Calculate the step h
  const h = (b - a) / N

  // Find interpolation points
  let xi = a // initialize xi = x0
  const pointsArray = []

  // Find the sum {f(x0+h/2) + f(x1+h/2) + ... + f(xN-1+h/2)}
  let temp
  for (let i = 0; i < N; i++) {
    temp = func(xi + h / 2)
    pointsArray.push(temp)
    xi += h
  }

  // Calculate the integral
  let result = h
  temp = 0
  for (let i = 0; i < pointsArray.length; i++) temp += pointsArray[i]

  result *= temp

  if (Number.isNaN(result)) { throw Error('Result is NaN. The input interval does not belong to the functions domain') }

  return result
}

export { integralEvaluation }
/**
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 */

const perfectCube = (num) => Math.round(num ** (1 / 3)) ** 3 === num

export { perfectCube }
/*
* Author: Rak Laptudirm
*
* https://en.wikipedia.org/wiki/Newton%27s_method
*
* Finding the square root of a number using Newton's method.
*/

function sqrt (num, precision = 4) {
  if (!Number.isFinite(num)) { throw new TypeError(`Expected a number, received ${typeof num}`) }
  if (!Number.isFinite(precision)) { throw new TypeError(`Expected a number, received ${typeof precision}`) }
  let sqrt = 1
  for (let i = 0; i < precision; i++) {
    sqrt -= (sqrt * sqrt - num) / (2 * sqrt)
  }
  return sqrt
}

export { sqrt }
/*
  Modified from:
    https://github.com/TheAlgorithms/Python/blob/master/maths/binary_exponentiation.py

  Explanation:
    https://en.wikipedia.org/wiki/Exponentiation_by_squaring
*/

export const binaryExponentiation = (a, n) => {
  // input: a: int, n: int
  // returns: a^n: int
  if (n === 0) {
    return 1
  } else if (n % 2 === 1) {
    return binaryExponentiation(a, n - 1) * a
  } else {
    const b = binaryExponentiation(a, n / 2)
    return b * b
  }
}
/*
* Reference: https://en.wikipedia.org/wiki/Farey_sequence
* Inspiration: https://www.youtube.com/watch?v=7LKy3lrkTRA
*
* Farey Approximation algorithm is an algorithm to
* approximate a reduced fraction value for a certain
* decimal number x where 0 < x < 1.
*
* The algorithm works by keeping two fractional upper and
* lower bounds which start at 0 / 1 and 1 / 1. These values
* are then used to find the "mediate" which is a value between
* the two fractions.
*
* For any two fractions a / b and c / d,
* mediate = a + c / b + d
*
* Then it is checked if the decimal is greater than or less
* than the mediate and then the lower or the upper value is
* set to be the mediate respectively.
*
* This is repeated for n times and then the mediate is
* returned.
*
* This is explained in a greater detail in the "Inspiration"
* link.
*/

function fareyApproximation (decimal, repeat = 20) {
  let a = 0; let b = 1; let c = 1; let d = 1; let numerator; let denominator

  for (let i = 0; i < repeat; i++) {
    numerator = a + c
    denominator = b + d

    if (decimal > numerator / denominator) {
      [a, b] = [numerator, denominator]
    } else {
      [c, d] = [numerator, denominator]
    }
  }

  return { numerator, denominator }
}

export { fareyApproximation }
/**
 * isLeapYear :: Number -> Boolean
 *
 * Check if a year is a leap year or not. A leap year is a year which has 366 days.
 * For the extra +1 day the February month contains 29 days instead of 28 days.
 *
 * The logic behind the leap year is-
 * 1. If the year is divisible by 400 then it is a leap year.
 * 2. If it is not divisible by 400 but divisible by 100 then it is not a leap year.
 * 3. If the year is not divisible by both 400 and 100 but divisible by 4 then a leap year.
 * 4. Other cases except the describing ones are not a leap year.
 *
 * @param {number} year
 * @returns {boolean} true if this is a leap year, false otherwise.
 */
export const isLeapYear = (year) => {
  if (year % 400 === 0) return true
  if (year % 100 === 0) return false
  if (year % 4 === 0) return true

  return false
}
/*
    Problem statement and Explanation : https://www.geeksforgeeks.org/check-if-a-number-is-a-krishnamurthy-number-or-not-2/

    krishnamurthy number is a number the sum of the all factorial of the all dights is equal to the number itself.
    145 => 1! + 4! + 5! = 1  + 24 + 120 = 145
*/

// factorial utility method.
const factorial = (n) => {
  let fact = 1
  while (n !== 0) {
    fact = fact * n
    n--
  }
  return fact
}

/**
 * krishnamurthy number is a number the sum of the factorial of the all dights is equal to the number itself.
 * @param {Number} number a number for checking is krishnamurthy number or not.
 * @returns return correspond boolean value, if the number is krishnamurthy number return `true` else return `false`.
 * @example 145 => 1! + 4! + 5! = 1  + 24 + 120 = 145
 */
const CheckKishnamurthyNumber = (number) => {
  // firstly, check that input is a number or not.
  if (typeof number !== 'number') {
    return new TypeError('Argument is not a number.')
  }
  // create a variable to store the sum of all digits factorial.
  let sumOfAllDigitFactorial = 0
  // convert the number to string for convenience.
  let newNumber = number
  // Extract number digits using the remainder method.
  while (newNumber > 0) {
    const lastDigit = newNumber % 10
    // calculate each digit factorial.
    sumOfAllDigitFactorial += factorial(lastDigit)
    newNumber = Math.floor(newNumber / 10)
  }
  // if the sumOftheFactorial is equal to the given number it means the number is a Krishnamurthy number.
  return sumOfAllDigitFactorial === number
}

export { CheckKishnamurthyNumber }
/**
 * @function FindMinIterator
 * @description Function to find the minimum number given in an array.
 */

const FindMinIterator = (_iterable, _selector = undefined) => {
  let min

  const iterator = _iterable[Symbol.iterator]()
  if (!_selector) {
    let current = iterator.next()
    if (current.done) { return undefined }
    min = current.value

    current = iterator.next()
    while (!current.done) {
      const x = current.value
      if (x < min) { min = x }
      current = iterator.next()
    }
  } else {
    let current = iterator.next()
    if (current.done) { return undefined }
    min = _selector(current.value)

    current = iterator.next()
    while (!current.done) {
      const x = _selector(current.value)
      if (x < min) { min = x }
      current = iterator.next()
    }
  }
  return min
}

export { FindMinIterator }
/*
  Source:
    https://en.wikipedia.org/wiki/Exponentiation_by_squaring

  Complexity:
    O(d^3 log n)
    where: d is the dimension of the square matrix
           n is the power the matrix is raised to
*/

const Identity = (n) => {
  // Input: n: int
  // Output: res: Identity matrix of size n x n
  // Complexity: O(n^2)
  const res = []
  for (let i = 0; i < n; i++) {
    res[i] = []
    for (let j = 0; j < n; j++) {
      res[i][j] = i === j ? 1 : 0
    }
  }
  return res
}

const MatMult = (matrixA, matrixB) => {
  // Input: matrixA: 2D Array of Numbers of size n x n
  //        matrixB: 2D Array of Numbers of size n x n
  // Output: matrixA x matrixB: 2D Array of Numbers of size n x n
  // Complexity: O(n^3)
  const n = matrixA.length
  const matrixC = []
  for (let i = 0; i < n; i++) {
    matrixC[i] = []
    for (let j = 0; j < n; j++) {
      matrixC[i][j] = 0
    }
  }
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      for (let k = 0; k < n; k++) {
        matrixC[i][j] += matrixA[i][k] * matrixB[k][j]
      }
    }
  }
  return matrixC
}

export const MatrixExponentiationRecursive = (mat, m) => {
  // Input: mat: 2D Array of Numbers of size n x n
  // Output: mat^n: 2D Array of Numbers of size n x n
  // Complexity: O(n^3 log m)
  if (m === 0) {
    // return identity matrix of size n x n
    return Identity(mat.length)
  } else if (m % 2 === 1) {
    // tmp = mat ^ m-1
    const tmp = MatrixExponentiationRecursive(mat, m - 1)
    /// return tmp * mat = (mat ^ m-1) * mat = mat ^ m
    return MatMult(tmp, mat)
  } else {
    // tmp = mat ^ m/2
    const tmp = MatrixExponentiationRecursive(mat, m >> 1)
    // return tmp * tmp = (mat ^ m/2) ^ 2 = mat ^ m
    return MatMult(tmp, tmp)
  }
}

// const mat = [[1, 0, 2], [2, 1, 0], [0, 2, 1]]

// // mat ^ 0 = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
// MatrixExponentiationRecursive(mat, 0)

// // mat ^ 1 = [ [ 1, 0, 2 ], [ 2, 1, 0 ], [ 0, 2, 1 ] ]
// MatrixExponentiationRecursive(mat, 1)

// // mat ^ 2 = [ [ 1, 4, 4 ], [ 4, 1, 4 ], [ 4, 4, 1 ] ]
// MatrixExponentiationRecursive(mat, 2)

// // mat ^ 5 = [ [ 1, 4, 4 ], [ 4, 1, 4 ], [ 4, 4, 1 ] ]
// MatrixExponentiationRecursive(mat, 5)
/*
 * function isolates the decimal part of a number.
 * Take the number and subtract it from the floored number.
 * Return the result.
 */

export const decimalIsolate = (number) => {
  const answer = parseFloat((number + '').replace(/^[-\d]+./, '.'))
  return isNaN(answer) === true ? 0 : answer
}
/*
 * Author: Akshay Dubey (https://github.com/itsAkshayDubey)
 * Pronic Number: https://en.wikipedia.org/wiki/Pronic_number
 * function to check if number is pronic.
 * return true if number is pronic.
 * else false
 */

/**
 * @function isPronic
 * @description -> Checking if number is pronic using product of two consecutive numbers
 * If number is a product of two consecutive numbers, then it is pronic
 * therefore, the function will return true
 *
 * If number is not a product of two consecutive numbers, then it is not pronic
 * therefore, the function will return false
 * @param {number} number
 * @returns {boolean}
 */

export const isPronic = (number) => {
  if (number === 0) {
    return true
  }
  const sqrt = Math.sqrt(number)
  return sqrt % 1 !== 0 && Math.ceil(sqrt) * Math.floor(sqrt) === number
}
/*
 * Odd Number: https://simple.wikipedia.org/wiki/Odd_number
 * function to check if number is odd.
 * return true if number is odd.
 * else false
 */

/**
 * @function isOdd
 * @description -> Checking if number is odd using not divisibility by 2
 * If number is not divisible by 2 i.e remainder = 1, then it is odd
 * therefore, the function will return true
 *
 * If number is divisible by 2 i.e remainder != 1, then it is even
 * therefore, the function will return false
 * @param {number} number
 * @returns {boolean}
 */
const isOdd = (number) => Boolean(number % 2) // 1 -> true, 0 -> false
/**
 * @function isOddBitwise
 * @description -> Checking if number is even using bitwise operator
 * Bitwise AND (&) compares the bits of the 32
 * bit binary representations of the number and
 * returns a number after comparing each bit:
 *
 * 0 & 0 -> 0
 * 0 & 1 -> 0
 * 1 & 0 -> 0
 * 1 & 1 -> 1
 *
 * For every odd numbers, the last binary bit will be 1
 * and for even numbers, the last binary bit will be 0.
 *
 * As the number is compared with one, all the
 * other bits except the last will become 0. The
 * last bit will be 0 for even numbers and 1 for
 * odd numbers.
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND
 * @param {number} number
 * @returns {boolean}
*/
const isOddBitwise = (number) => Boolean(number & 1) // 1 -> true, 0 -> false

export { isOdd, isOddBitwise }
// Wikipedia: https://en.wikipedia.org/wiki/Reverse_Polish_notation

const calcRPN = (expression) => {
  const operators = {
    '+': (a, b) => a + b,
    '-': (a, b) => a - b,
    '*': (a, b) => a * b,
    '/': (a, b) => b / a
  }

  const tokens = expression.split(' ')

  const stack = []

  tokens.forEach((token) => {
    const operator = operators[token]

    if (typeof operator === 'function') {
      const a = stack.pop()
      const b = stack.pop()

      const result = operator(a, b)

      stack.push(result)
    } else {
      stack.push(parseFloat(token))
    }
  })

  return stack.pop()
}

export { calcRPN }
/*
 * Even Number: https://simple.wikipedia.org/wiki/Even_number
 *
 * function to check if number is even
 * return true if number is even
 * else false
 */

/**
 * @function isEven
 * @description - Checking if number is even using divisibility by 2
 *
 * If number is divisible by 2 i.e remainder = 0, then it is even
 * therefore, the function will return true
 *
 * If number is not divisible by 2 i.e remainder != 0, then it is not even i.e odd
 * therefore, the function will return false
 * @param {number} number
 * @return {boolean}
 */
export const isEven = (number) => number % 2 === 0

/**
 * @function isEvenBitwise
 * @description - Checking if number is even using bitwise operator
 * Bitwise AND (&) compares the bits of the 32
 * bit binary representations of the number and
 * returns a number after comparing each bit:
 *
 * 0 & 0 -> 0
 * 0 & 1 -> 0
 * 1 & 0 -> 0
 * 1 & 1 -> 1
 *
 * For odd numbers, the last binary bit will be 1
 * and for even numbers, the last binary bit will
 * be 0.
 *
 * As the number is compared with one, all the
 * other bits except the last will become 0. The
 * last bit will be 0 for even numbers and 1 for
 * odd numbers, which is checked with the use
 * of the equality operator.
 * @param {number} number
 * @returns {boolean}
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND
 */
export const isEvenBitwise = (number) => (number & 1) === 0
/*
 * Radian : https://en.wikipedia.org/wiki/Radian
 * Degree : https://en.wikipedia.org/wiki/Degree_(angle)
 *
 * Angle in Degree = ( Angle in Radian ) x ( 180 / pi )
 *
 * Example :
 * Question : Convert pi / 2 degree to radian
 * So, Angle in Radian = pi / 2
 *
 * Solution :
 * Angle in Degree = ( pi / 2 ) x ( 180 / pi ) = 90
 *
 * So, pi / 2 radian is equal to 90 degree
 */

/**
 * @param {number} radian
 * @return {number}
 */
export const radianToDegree = (radian) => {
  return radian * (180 / Math.PI)
}
/*
 Calculate the mathematical properties involving coordinates
 Calculate the Distance Between 2 Points on a 2 Dimensional Plane
 Example: coorDistance(2,2,14,11) will return 15
 Wikipedia reference: https://en.wikipedia.org/wiki/Geographical_distance#Flat-surface_formulae
*/
const euclideanDistance = (longitude1, latitude1, longitude2, latitude2) => {
  const width = longitude2 - longitude1
  const height = latitude2 - latitude1
  return (Math.sqrt(width * width + height * height))
}

const manhattanDistance = (longitude1, latitude1, longitude2, latitude2) => {
  const width = Math.abs(longitude2 - longitude1)
  const height = Math.abs(latitude2 - latitude1)
  return width + height
}

export { euclideanDistance, manhattanDistance }
/**
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 */

const perfectSquare = (num) => Math.sqrt(num) ** 2 === num

export { perfectSquare }
import { aliquotSum } from '../AliquotSum'

describe('Aliquot Sum of a Number', () => {
  it('Aliquot Sum of 6', () => {
    expect(aliquotSum(6)).toBe(6)
  })

  it('Aliquot Sum of 1', () => {
    expect(aliquotSum(1)).toBe(0)
  })

  it('Aliquot Sum of 28', () => {
    expect(aliquotSum(28)).toBe(28)
  })
})
import { generate } from '../PascalTriangle'

describe('Pascals Triangle', () => {
  it('should have the the same length as the number', () => {
    const pascalsTriangle = generate(5)
    expect(pascalsTriangle.length).toEqual(5)
  })
  it('should have same length as its index in the array', () => {
    const pascalsTriangle = generate(5)
    pascalsTriangle.forEach((arr, index) => {
      expect(arr.length).toEqual(index + 1)
    })
  })
  it('should return an array of arrays', () => {
    const pascalsTriangle = generate(3)
    expect(pascalsTriangle).toEqual(
      expect.arrayContaining([[1], [1, 1], [1, 2, 1]])
    )
  })
})
import * as area from '../Area'

describe('Testing surfaceAreaCube calculations', () => {
  it('with natural number', () => {
    const surfaceAreaOfOne = area.surfaceAreaCube(1.2)
    const surfaceAreaOfThree = area.surfaceAreaCube(3)
    expect(surfaceAreaOfOne).toBe(8.64)
    expect(surfaceAreaOfThree).toBe(54)
  })
  it('with negative argument, expect throw', () => {
    expect(() => area.surfaceAreaCube(-1)).toThrow()
  })
  it('with non-numeric argument, expect throw', () => {
    expect(() => area.surfaceAreaCube('199')).toThrow()
  })
})

describe('Testing surfaceAreaSphere calculations', () => {
  it('with correct value', () => {
    const calculateArea = area.surfaceAreaSphere(5)
    const expected = 314.1592653589793
    expect(calculateArea).toBe(expected)
  })
  it('with negative value, expect throw', () => {
    expect(() => area.surfaceAreaSphere(-1)).toThrow()
  })
})

describe('Testing areaRectangle calculations', () => {
  it('with correct args', () => {
    const areaRectangle = area.areaRectangle(2.5, 2)
    expect(areaRectangle).toBe(5.0)
  })
  it('with incorrect args, expect throw', () => {
    expect(() => area.areaRectangle(-1, 20)).toThrow()
    expect(() => area.areaRectangle('1', 0)).toThrow()
    expect(() => area.areaRectangle(23, -1)).toThrow()
    expect(() => area.areaRectangle(23, 'zero')).toThrow()
  })
})

describe('Testing areaSquare calculations', () => {
  it('with correct args', () => {
    const areaSquare = area.areaSquare(2.5)
    expect(areaSquare).toBe(6.25)
  })
  it('with incorrect side length, expect throw', () => {
    expect(() => area.areaSquare(-1)).toThrow()
    expect(() => area.areaSquare('zero')).toThrow()
  })
})

describe('Testing areaTriangle calculations', () => {
  it('with correct args', () => {
    const areaTriangle = area.areaTriangle(1.66, 3.44)
    expect(areaTriangle).toBe(2.8552)
  })
  it('with incorrect base and height, expect throw', () => {
    expect(() => area.areaTriangle(-1, 1)).toThrow()
    expect(() => area.areaTriangle(9, 'zero')).toThrow()
  })
})

describe('Testing areaTriangleWithAllThreeSides calculations', () => {
  it('with correct args', () => {
    const areaTriangle = area.areaTriangleWithAllThreeSides(5, 6, 7)
    expect(areaTriangle).toBe(14.7)
  })
  it('with incorrect sides, expect throw', () => {
    expect(() => area.areaTriangleWithAllThreeSides(-1, 1, 10)).toThrow()
    expect(() => area.areaTriangleWithAllThreeSides(9, 'zero', 2)).toThrow()
    expect(() => area.areaTriangleWithAllThreeSides(1, 10, 12)).toThrow()
  })
})

describe('Testing areaParallelogram calculations', () => {
  it('with correct args', () => {
    const areaParallelogram = area.areaParallelogram(1.66, 3.44)
    expect(areaParallelogram).toBe(5.7104)
  })
  it('with incorrect base and height, expect throw', () => {
    expect(() => area.areaParallelogram(-1, 1)).toThrow()
    expect(() => area.areaParallelogram(9, 'zero')).toThrow()
  })
})

describe('Testing areaTrapezium calculations', () => {
  it('with correct args', () => {
    const areaTrapezium = area.areaTrapezium(1.66, 2.41, 4.1)
    expect(areaTrapezium).toBe(8.3435)
  })
  it('with incorrect bases and height, expect throw', () => {
    expect(() => area.areaTrapezium(-1, 1, 0)).toThrow()
    expect(() => area.areaTrapezium(9, 'zero', 2)).toThrow()
    expect(() => area.areaTrapezium(9, 1, 'seven')).toThrow()
  })
})

describe('Testing areaCircle calculations', () => {
  it('with correct args', () => {
    const areaCircle = area.areaCircle(3.456)
    expect(areaCircle).toBe(37.52298159254666)
  })
  it('with incorrect diagonal, expect throw', () => {
    expect(() => area.areaCircle(-1)).toThrow()
    expect(() => area.areaCircle('zero')).toThrow()
  })
})

describe('Testing areaRhombus calculations', () => {
  it('with correct args', () => {
    const areaRhombus = area.areaRhombus(2.5, 2.0)
    expect(areaRhombus).toBe(2.5)
  })
  it('with incorrect diagonals, expect throw', () => {
    expect(() => area.areaRhombus(7, -1)).toThrow()
    expect(() => area.areaRhombus('zero', 2)).toThrow()
  })
})
import { perfectCube } from '../PerfectCube'

describe('PerfectCube', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectCube(125)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectCube(100)).toBeFalsy()
  })
})
import { degreeToRadian } from '../DegreeToRadian'

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(0)
  expect(radianEqual).toBe(0)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(45)
  expect(radianEqual).toBe(Math.PI / 4)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(90)
  expect(radianEqual).toBe(Math.PI / 2)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(180)
  expect(radianEqual).toBe(Math.PI)
})
import { factorsOfANumber } from '../Factors'

describe('Factors', () => {
  factorsOfANumber(50).forEach((num) => {
    it(`${num} is a factor of 50`, () => {
      const isFactor = 50 % num === 0
      expect(isFactor).toBeTruthy()
    })
  })
})
import { isLeapYear } from '../LeapYear'

describe('Leap Year', () => {
  it('Should return true on the year 2000', () => {
    expect(isLeapYear(2000)).toBe(true)
  })
  it('Should return false on the year 2001', () => {
    expect(isLeapYear(2001)).toBe(false)
  })
  it('Should return false on the year 2002', () => {
    expect(isLeapYear(2002)).toBe(false)
  })
  it('Should return false on the year 2003', () => {
    expect(isLeapYear(2003)).toBe(false)
  })
  it('Should return false on the year 2004', () => {
    expect(isLeapYear(2004)).toBe(true)
  })
  it('Should return false on the year 1900', () => {
    expect(isLeapYear(1900)).toBe(false)
  })
})
import { calcRPN } from '../ReversePolishNotation'

describe('ReversePolishNotation', () => {
  it('should evaluate correctly for two values', () => {
    expect(calcRPN('2 3 +')).toEqual(5)
  })
  it("should evaluate' for multiple values", () => {
    expect(calcRPN('2 2 2 * +')).toEqual(6)
    expect(calcRPN('6 9 7 + 2 / + 3 *')).toEqual(42)
  })
})
import * as coordinate from '../Coordinate'

describe('Testing euclideanDistance calculations', () => {
  it('Should give a numeric output (distance between 2 points) with 4 numeric arguments', () => {
    const euclideanDistance = coordinate.euclideanDistance(2, 2, -10, -7)
    expect(euclideanDistance).toBe(15)
  })
  it('Should not give any output given non-numeric argument', () => {
    const euclideanDistance = coordinate.euclideanDistance('ABC', '123', '', '###')
    expect(euclideanDistance).toBeNaN()
  })
  it('Should not give any output given any number of numeric arguments less than 4', () => {
    const euclideanDistance3arg = coordinate.euclideanDistance(2, 2, -10)
    const euclideanDistance2arg = coordinate.euclideanDistance(2, 2)
    const euclideanDistance1arg = coordinate.euclideanDistance(2)
    const euclideanDistance0arg = coordinate.euclideanDistance()
    expect(euclideanDistance3arg).toBeNaN()
    expect(euclideanDistance2arg).toBeNaN()
    expect(euclideanDistance1arg).toBeNaN()
    expect(euclideanDistance0arg).toBeNaN()
  })
})

describe('Testing manhattanDistance calculations', () => {
  it('Should give a numeric output (distance between 2 points) with 4 numeric arguments', () => {
    const manhattanDistance = coordinate.manhattanDistance(2, 2, -10, -7)
    expect(manhattanDistance).toBe(21)
  })
  it('Should not give any output given non-numeric argument', () => {
    const manhattanDistance = coordinate.manhattanDistance('ABC', '123', '', '###')
    expect(manhattanDistance).toBeNaN()
  })
  it('Should not give any output given any number of numeric arguments less than 4', () => {
    const manhattanDistance3arg = coordinate.manhattanDistance(2, 2, -10)
    const manhattanDistance2arg = coordinate.manhattanDistance(2, 2)
    const manhattanDistance1arg = coordinate.manhattanDistance(2)
    const manhattanDistance0arg = coordinate.manhattanDistance()
    expect(manhattanDistance3arg).toBeNaN()
    expect(manhattanDistance2arg).toBeNaN()
    expect(manhattanDistance1arg).toBeNaN()
    expect(manhattanDistance0arg).toBeNaN()
  })
})
import { isDivisible } from '../IsDivisible'

describe('isDivisible', () => {
  const testCases = [
    [0, 1, true],
    [0, 2, true],
    [1, 1, true],
    [1, 2, false],
    [2, 1, true],
    [4, 4, true],
    [16, 4, true],
    [36978235, 5, true],
    [36978235, 4, false],
    [4.5, 1.5, true],
    [4.5, 1.2, false],
    [5, 0, false],
    [5, -0, false]
  ]

  test.each(testCases)('if parameters are (%i, %i) it returns %p', (dividend, divisor, expected) => {
    expect(isDivisible(dividend, divisor)).toBe(expected)
  })

  const errorCases = [
    [NaN, NaN],
    [NaN, 1],
    [1, NaN],
    ['1', 1],
    [1, '1'],
    [1, true],
    [false, 2]
  ]

  test.each(errorCases)('throws an error if parameters are (%p, %p)', (dividend, divisor) => {
    expect(() => {
      isDivisible(dividend, divisor)
    }).toThrow()
  })
})
import { calcFactorial } from '../Factorial'

describe('calcFactorial', () => {
  it('should return a statement for value "0"', () => {
    expect(calcFactorial(0)).toBe('The factorial of 0 is 1.')
  })

  it('should return a statement for "null" and "undefined"', () => {
    const nullFactorial = calcFactorial(null)
    const undefinedFactorial = calcFactorial(undefined)

    expect(nullFactorial).toBe(
      'Sorry, factorial does not exist for null or undefined numbers.'
    )
    expect(undefinedFactorial).toBe(
      'Sorry, factorial does not exist for null or undefined numbers.'
    )
  })

  it('should not support negative numbers', () => {
    const negativeFactorial = calcFactorial(-5)
    expect(negativeFactorial).toBe(
      'Sorry, factorial does not exist for negative numbers.'
    )
  })

  it('should return the factorial of a positive number', () => {
    const positiveFactorial = calcFactorial(3)
    expect(positiveFactorial).toBe('The factorial of 3 is 6')
  })
})
import { eulerFull } from '../EulerMethod'

function plotLine (label, points, width, height) {
  // utility function to plot the results

  // container needed to control the size of the canvas
  const container = document.createElement('div')
  container.style.width = width + 'px'
  container.style.height = height + 'px'
  document.body.append(container)

  // the canvas for plotting
  const canvas = document.createElement('canvas')
  container.append(canvas)

  // Chart-class from chartjs
  const chart = new Chart(canvas, { // eslint-disable-line
    type: 'scatter',
    data: {
      datasets: [{
        label,
        data: points,
        showLine: true,
        fill: false,
        tension: 0,
        borderColor: 'black'
      }]
    },
    options: {
      maintainAspectRatio: false,
      responsive: true
    }
  })
}

function exampleEquation1 (x, y) {
  return x
}

// example from https://en.wikipedia.org/wiki/Euler_method
function exampleEquation2 (x, y) {
  return y
}

// example from https://www.geeksforgeeks.org/euler-method-solving-differential-equation/
function exampleEquation3 (x, y) {
  return x + y + x * y
}

// plot the results if the script is executed in a browser with a window-object
if (typeof window !== 'undefined') {
  const points1 = eulerFull(0, 4, 0.1, 0, exampleEquation1)
  const points2 = eulerFull(0, 4, 0.1, 1, exampleEquation2)
  const points3 = eulerFull(0, 0.1, 0.025, 1, exampleEquation3)

  const script = document.createElement('script')

  // using chartjs
  script.src = 'https://www.chartjs.org/dist/2.9.4/Chart.min.js'
  script.onload = function () {
    plotLine('example 1: dy/dx = x', points1, 600, 400)
    plotLine('example 2: dy/dx = y', points2, 600, 400)
    plotLine('example 3: dy/dx = x + y + x * y', points3, 600, 400)
  }
  document.body.append(script)
}
import { isEven, isEvenBitwise } from '../IsEven'

describe('Testing isEven function', () => {
  it('should return if the number is even or not', () => {
    const isEvenNumber = isEven(4)
    expect(isEvenNumber).toBe(true)
  })

  it('should return if the number is even or not', () => {
    const isEvenNumber = isEven(7)
    expect(isEvenNumber).toBe(false)
  })
})

describe('Testing isEvenBitwise function', () => {
  it('should return if the number is even or not', () => {
    const isEvenNumber = isEvenBitwise(6)
    expect(isEvenNumber).toBe(true)
  })

  it('should return if the number is even or not', () => {
    const isEvenNumber = isEvenBitwise(3)
    expect(isEvenNumber).toBe(false)
  })
})
import { eulersTotientFunction } from '../EulersTotientFunction'

describe('eulersTotientFunction', () => {
  it('is a function', () => {
    expect(typeof eulersTotientFunction).toEqual('function')
  })
  it('should return the phi of a given number', () => {
    const phiOfNumber = eulersTotientFunction(10)
    expect(phiOfNumber).toBe(4)
  })
})
import { Softmax } from '../Softmax'

describe('Softmax', () => {
  it('should return equal distribution of 1 for equal input values', () => {
    expect(Softmax([1, 1])).toEqual([0.5, 0.5])
    expect(Softmax([1, 1, 1, 1])).toEqual([0.25, 0.25, 0.25, 0.25])
  })

  it('should return values which sum to the value of 1', () => {
    expect(Softmax([1, 2, 3, 4]).reduce((a, b) => a + b, 0)).toEqual(1)
  })
})
import { perfectSquare } from '../PerfectSquare'

describe('PerfectSquare', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectSquare(16)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectSquare(10)).toBeFalsy()
  })
})
import { Polynomial } from '../Polynomial'

describe('Polynomial', () => {
  it('should not return a expression for zero', () => {
    const polynomial = new Polynomial([0])
    expect(polynomial.display()).toBe('')
  })
  it('should not return an expression for zero values', () => {
    const polynomial = new Polynomial([0, 0, 0, 0, 0])
    expect(polynomial.display()).toBe('')
  })
  it('should return an expression for single a non zero value', () => {
    const polynomial = new Polynomial([9])
    expect(polynomial.display()).toBe('(9)')
  })
  it('should return an expression for two values', () => {
    const polynomial = new Polynomial([3, 2])
    expect(polynomial.display()).toBe('(2x) + (3)')
  })
  it('should return an expression for values including zero', () => {
    const polynomial = new Polynomial([0, 2])
    expect(polynomial.display()).toBe('(2x)')
  })
  it('should return an expression and evaluate it', () => {
    const polynomial = new Polynomial([1, 2, 3, 4])
    expect(polynomial.display()).toBe('(4x^3) + (3x^2) + (2x) + (1)')
    expect(polynomial.evaluate(2)).toEqual(49)
  })
  it('should evaluate 0 for zero values', () => {
    const polynomial = new Polynomial([0, 0, 0, 0])
    expect(polynomial.evaluate(5)).toEqual(0)
  })
  it('should evaluate for negative values', () => {
    const polynomial = new Polynomial([-1, -3, -4, -7])
    expect(polynomial.evaluate(-5)).toBe(789)
  })
})
import { isPronic } from '../IsPronic'

const pronicNumbers = [0, 2, 6, 12, 20, 30, 42, 56, 72, 90, 110, 132, 156, 182, 210, 240, 272, 306, 342, 380, 420, 462, 506, 552, 600, 650, 702, 756, 812, 870, 930, 992, 1056, 1122, 1190, 1260, 1332, 1406, 1482, 1560, 1640, 1722, 1806, 1892, 1980, 2070, 2162, 2256, 2352, 2450, 2550]

describe('Testing isPronic function', () => {
  for (let i = 0; i <= 2500; i++) {
    it('should return true', () => {
      const isPronicNumber = isPronic(i)
      expect(isPronicNumber).toBe(pronicNumbers.includes(i))
    })
  }
})
import { twinPrime } from '../TwinPrime.js'

describe('Twin Primes', () => {
  it('Should be valid twin primes', () => {
    expect(twinPrime(3)).toBe(5)
    expect(twinPrime(5)).toBe(7)
    expect(twinPrime(4)).toBe(-1)
    expect(twinPrime(17)).toBe(19)
  })
})
import { factorial, permutation, combination } from '../PermutationAndCombination'

describe('Factorial', () => {
  it('factorial(5)', () => {
    expect(factorial(5)).toBe(120)
  })
})

describe('Permutation', () => {
  it('permutation(5, 2)', () => {
    expect(permutation(5, 2)).toBe(20)
  })
})

describe('Combination', () => {
  it('combination(5, 2)', () => {
    expect(combination(5, 2)).toBe(10)
  })
})
import { fermatPrimeCheck, modularExponentiation } from '../FermatPrimalityTest'

describe('modularExponentiation', () => {
  it('should give the correct output for all exponentiations', () => {
    expect(modularExponentiation(38, 220, 221)).toBe(1)
    expect(modularExponentiation(24, 220, 221)).toBe(81)
  })
})

describe('fermatPrimeCheck', () => {
  it('should give the correct output for prime and composite numbers', () => {
    expect(fermatPrimeCheck(2, 35)).toBe(true)
    expect(fermatPrimeCheck(10, 30)).toBe(false)
    expect(fermatPrimeCheck(94286167)).toBe(true)
    expect(fermatPrimeCheck(83165867)).toBe(true)
    expect(fermatPrimeCheck(13268774)).toBe(false)
    expect(fermatPrimeCheck(13233852)).toBe(false)
  })
})
import { LinearSieve } from '../LinearSieve'
import { PrimeCheck } from '../PrimeCheck'

describe('LinearSieve', () => {
  it('should return primes below 100', () => {
    expect(LinearSieve(100)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
  })

  it('should return primes only', () => {
    const n = 100000
    const primes = LinearSieve(n)
    for (const p of primes) {
      expect(PrimeCheck(p)).toBeTruthy()
    }
  })
})
import { GetEuclidGCD } from '../GetEuclidGCD'

function testEuclidGCD (n, m, expected) {
  test('Testing on ' + n + ' and ' + m + '!', () => {
    expect(GetEuclidGCD(n, m)).toBe(expected)
  })
}

testEuclidGCD(5, 20, 5)
testEuclidGCD(109, 902, 1)
testEuclidGCD(290, 780, 10)
testEuclidGCD(104, 156, 52)
import { isOdd, isOddBitwise } from '../IsOdd'

describe('Testing the isOdd function', () => {
  it('should return true, if the number is odd', () => {
    const isOddNumber = isOdd(4)
    expect(isOddNumber).toBe(false)
  })

  it('should return true, if the number is odd', () => {
    const isOddNumber = isOdd(7)
    expect(isOddNumber).toBe(true)
  })
})

describe('Testing the isOddBitwise function', () => {
  it('should return true, if the number is odd', () => {
    const isOddNumber = isOddBitwise(6)
    expect(isOddNumber).toBe(false)
  })

  it('should return true, if the number is odd', () => {
    const isOddNumber = isOddBitwise(3)
    expect(isOddNumber).toBe(true)
  })
})
import { decExp } from '../DecimalExpansion'

/**
 * Decimal
 */

describe('Finite Decimal Expansion', () => {
  it('1/2 = 0.5', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 2)
    expect(integer).toBe(0)
    expect(decimals).toEqual([5])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/5 = 0.2', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 5)
    expect(integer).toBe(0)
    expect(decimals).toEqual([2])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/8 = 0.125', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 8)
    expect(integer).toBe(0)
    expect(decimals).toEqual([1, 2, 5])
    expect(cycleIndex).toBeUndefined()
  })

  it('255/40 = 6.375', () => {
    const [integer, decimals, cycleIndex] = decExp(255, 40)
    expect(integer).toBe(6)
    expect(decimals).toEqual([3, 7, 5])
    expect(cycleIndex).toBeUndefined()
  })
})

describe('Repeating Decimal Expansion', () => {
  it('1/3 = 0.(3)', () => {
    expect(decExp(1, 3)).toStrictEqual([0, [3], 0])
  })

  it('1/6 = 0.1(6)', () => {
    expect(decExp(1, 6)).toStrictEqual([0, [1, 6], 1])
  })

  it('1/7 = 0.(142857)', () => {
    expect(decExp(1, 7)).toStrictEqual([0, [1, 4, 2, 8, 5, 7], 0])
  })
})

/**
 * Binary
 */

describe('Finite Binary Expansion', () => {
  it('1/2 = 0.1', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 2, 2)
    expect(integer).toBe(0)
    expect(decimals).toEqual([1])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/8 = 0.001', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 8, 2)
    expect(integer).toBe(0)
    expect(decimals).toEqual([0, 0, 1])
    expect(cycleIndex).toBeUndefined()
  })

  it('255/40 = 110.011', () => {
    const [integer, decimals, cycleIndex] = decExp(255, 40, 2)
    expect(integer).toBe(110)
    expect(decimals).toEqual([0, 1, 1])
    expect(cycleIndex).toBeUndefined()
  })
})

describe('Repeating Binary Expansion', () => {
  it('1/3 = 0.(01)', () => {
    expect(decExp(1, 3, 2)).toStrictEqual([0, [0, 1], 0])
  })

  it('1/5 = 0.(0011)', () => {
    expect(decExp(1, 5, 2)).toStrictEqual([0, [0, 0, 1, 1], 0])
  })

  it('1/6 = 0.0(01)', () => {
    expect(decExp(1, 6, 2)).toStrictEqual([0, [0, 0, 1], 1])
  })

  it('1/7 = 0.(001)', () => {
    expect(decExp(1, 7, 2)).toStrictEqual([0, [0, 0, 1], 0])
  })
})

/**
 * Octal
 */

describe('Finite Octal Expansion', () => {
  it('1/2 = 0.4', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 2, 8)
    expect(integer).toBe(0)
    expect(decimals).toEqual([4])
    expect(cycleIndex).toBeUndefined()
  })

  it('1/8 = 0.1', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 8, 8)
    expect(integer).toBe(0)
    expect(decimals).toEqual([1])
    expect(cycleIndex).toBeUndefined()
  })

  it('255/40 = 6.3', () => {
    const [integer, decimals, cycleIndex] = decExp(255, 40, 8)
    expect(integer).toBe(6)
    expect(decimals).toEqual([3])
    expect(cycleIndex).toBeUndefined()
  })
})

describe('Repeating Octal Expansion', () => {
  it('1/3 = 0.(25)', () => {
    expect(decExp(1, 3, 8)).toStrictEqual([0, [2, 5], 0])
  })

  it('1/5 = 0.(1463)', () => {
    expect(decExp(1, 5, 8)).toStrictEqual([0, [1, 4, 6, 3], 0])
  })

  it('1/6 = 0.1(25)', () => {
    expect(decExp(1, 6, 8)).toStrictEqual([0, [1, 2, 5], 1])
  })

  it('1/7 = 0.(1)', () => {
    expect(decExp(1, 7, 8)).toStrictEqual([0, [1], 0])
  })
})

/**
 * Integers
 */

describe('Integers', () => {
  it('1/1 = 1', () => {
    const [integer, decimals, cycleIndex] = decExp(1, 1)
    expect(integer).toBe(1)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })

  it('5/5 = 1', () => {
    const [integer, decimals, cycleIndex] = decExp(5, 5)
    expect(integer).toBe(1)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })

  it('2/1 = 2', () => {
    const [integer, decimals, cycleIndex] = decExp(2, 1)
    expect(integer).toBe(2)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })

  it('9/3 = 3', () => {
    const [integer, decimals, cycleIndex] = decExp(9, 3)
    expect(integer).toBe(3)
    expect(decimals).toStrictEqual([])
    expect(cycleIndex).toBeUndefined()
  })
})

/**
 * Unsupported base
 */

describe('Throws on unsupported base', () => {
  it('negative base', () => {
    expect(() => decExp(1, 1, -2)).toThrow(RangeError)
  })
  it('base 0', () => {
    expect(() => decExp(1, 1, 0)).toThrow(RangeError)
  })
  it('base 1', () => {
    expect(() => decExp(1, 1, 1)).toThrow(RangeError)
  })
  it('base 11', () => {
    expect(() => decExp(1, 1, 11)).toThrow(RangeError)
  })
})
import { lucas } from '../LucasSeries'

describe('Nth Lucas Number', () => {
  it('should return the 20th Lucas Number', () => {
    expect(lucas(20)).toBe(15127)
  })

  it('should return the 20th Lucas Number', () => {
    expect(lucas(0)).toBe(2)
  })

  it('should return the 20th Lucas Number', () => {
    expect(lucas(100)).toBe(792070839848372100000)
  })
})
import { factorialize } from '../WhileLoopFactorial'

function testFactorial (n, expected) {
  test('Testing on ' + n + '!', () => {
    expect(factorialize(n)).toBe(expected)
  })
}

testFactorial(3, 6)
testFactorial(7, 5040)
testFactorial(0, 1)
testFactorial(12, 479001600)
import { findMaxRecursion } from '../FindMaxRecursion'

describe('Test findMaxRecursion function', () => {
  const positiveAndNegativeArray = [1, 2, 4, 5, -1, -2, -4, -5]
  const positiveAndNegativeArray1 = [10, 40, 100, 20, -10, -40, -100, -20]

  const positiveArray = [1, 2, 4, 5]
  const positiveArray1 = [10, 40, 100, 20]

  const negativeArray = [-1, -2, -4, -5]
  const negativeArray1 = [-10, -40, -100, -20]

  const zeroArray = [0, 0, 0, 0]
  const emptyArray = []

  it('Testing with positive arrays', () => {
    expect(findMaxRecursion(positiveArray, 0, positiveArray.length - 1)).toBe(5)
    expect(findMaxRecursion(positiveArray1, 0, positiveArray1.length - 1)).toBe(
      100
    )
  })

  it('Testing with negative arrays', () => {
    expect(findMaxRecursion(negativeArray, 0, negativeArray.length - 1)).toBe(
      -1
    )
    expect(findMaxRecursion(negativeArray1, 0, negativeArray1.length - 1)).toBe(
      -10
    )
  })

  it('Testing with positive and negative arrays', () => {
    expect(
      findMaxRecursion(
        positiveAndNegativeArray,
        0,
        positiveAndNegativeArray.length - 1
      )
    ).toBe(5)
    expect(
      findMaxRecursion(
        positiveAndNegativeArray1,
        0,
        positiveAndNegativeArray1.length - 1
      )
    ).toBe(100)
  })

  it('Testing with zero arrays', () => {
    expect(findMaxRecursion(zeroArray, 0, zeroArray.length - 1)).toBe(0)
  })

  it('Testing with empty arrays', () => {
    expect(findMaxRecursion(emptyArray, 0, emptyArray.length - 1)).toBe(
      undefined
    )
  })
})
import { sieveOfEratosthenes } from '../SieveOfEratosthenes'
import { PrimeCheck } from '../PrimeCheck'

describe('should return an array of prime booleans', () => {
  it('should have each element in the array as a prime boolean', () => {
    const n = 30
    const primes = sieveOfEratosthenes(n)
    primes.forEach((primeBool, index) => {
      if (primeBool) {
        expect(PrimeCheck(index)).toBeTruthy()
      }
    })
  })
})
import { sumOfGeometricProgression } from '../SumOfGeometricProgression'

describe('Sum Of Geometric Progression', () => {
  it('should return the sum of a finite GP', () => {
    expect(sumOfGeometricProgression(100, 1.5, 4)).toBe(812.5)
  })

  it('should return the sum of an infinite GP', () => {
    expect(sumOfGeometricProgression(2, 0.5, Infinity)).toBe(4)
  })
})
import { findHCF } from '../FindHcf'

describe('findHCF', () => {
  it('should throw a statement for values less than 1', () => {
    expect(findHCF(0, 0)).toBe('Please enter values greater than zero.')
  })

  it('should throw a statement for one value less than 1', () => {
    expect(findHCF(0, 1)).toBe('Please enter values greater than zero.')
    expect(findHCF(1, 0)).toBe('Please enter values greater than zero.')
  })

  it('should return an error for values non-integer values', () => {
    expect(findHCF(2.24, 4.35)).toBe('Please enter whole numbers.')
  })

  it('should return the HCF of two given integers', () => {
    expect(findHCF(27, 36)).toBe(9)
  })
})
import { armstrongNumber } from '../ArmstrongNumber'

describe('ArmstrongNumber', () => {
  it('should return true for an armstrong number', () => {
    expect(armstrongNumber(371)).toBeTruthy()
  })

  it('should return false for a non-armstrong number', () => {
    expect(armstrongNumber(300)).toBeFalsy()
  })
  it('should return false for negative values', () => {
    expect(armstrongNumber(-2)).toBeFalsy()
  })
})
import { EulersTotient } from '../EulersTotient'

describe('EulersTotient', () => {
  it('should return 6 as 1, 2, 4, 5, 7, and 8 are coprime to 9', () => {
    expect(EulersTotient(9)).toBe(6)
  })

  it('should return 4 as 1, 3, 7, and 9 are coprime to 10', () => {
    expect(EulersTotient(10)).toBe(4)
  })
})
import { sqrt } from '../SquareRoot'

test('Check SquareRoot of 4 is 2', () => {
  const res = sqrt(4, 10)
  expect(res).toBeCloseTo(2)
})

test('Check SquareRoot of 2 is 1.4142135', () => {
  const res = sqrt(2, 10)
  expect(res).toBeCloseTo(1.4142135)
})

test('Check SquareRoot of 3.2 is 1.788854381999832', () => {
  const res = sqrt(3.2, 10)
  expect(res).toBeCloseTo(1.788854381999832)
})

test('Check SquareRoot of 1 is 1', () => {
  const res = sqrt(1, 10)
  expect(res).toBe(1)
})

test('Check SquareRoot of 144 is 12', () => {
  const res = sqrt(144, 10)
  expect(res).toBeCloseTo(12)
})

test('Check SquareRoot of 0 is 0', () => {
  const res = sqrt(0, 10)
  expect(res).toBeCloseTo(0)
})

test('Check SquareRoot of 1000 is 31.62277', () => {
  const res = sqrt(1000, 10)
  expect(res).toBeCloseTo(31.62277)
})
import { PalindromeRecursive, PalindromeIterative } from '../Palindrome'

describe('Palindrome', () => {
  it('should return true for a palindrome for PalindromeRecursive', () => {
    expect(PalindromeRecursive('mom')).toBeTruthy()
  })
  it('should return true  for a palindrome for PalindromeIterative', () => {
    expect(PalindromeIterative('mom')).toBeTruthy()
  })
  it('should return false for a non-palindrome for PalindromeRecursive', () => {
    expect(PalindromeRecursive('Algorithms')).toBeFalsy()
  })
  it('should return true  for a non-palindrome for PalindromeIterative', () => {
    expect(PalindromeIterative('JavaScript')).toBeFalsy()
  })
})
import { getRGBData } from '../Mandelbrot'

// plot the results if the script is executed in a browser with a window-object
if (typeof window !== 'undefined') {
  const rgbData = getRGBData()
  const width = rgbData.length
  const height = rgbData[0].length
  const canvas = document.createElement('canvas')
  canvas.width = width
  canvas.height = height
  const ctx = canvas.getContext('2d')
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const rgb = rgbData[x][y]
      ctx.fillStyle = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')'
      ctx.fillRect(x, y, 1, 1)
    }
  }
  document.body.append(canvas)
}
import { radianToDegree } from '../RadianToDegree'

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(0)
  expect(degreeEqual).toBe(0)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI / 4)
  expect(degreeEqual).toBe(45)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI / 2)
  expect(degreeEqual).toBe(90)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI)
  expect(degreeEqual).toBe(180)
})
import { sumOfDigitsUsingLoop, sumOfDigitsUsingRecursion, sumOfDigitsUsingString } from '../SumOfDigits'

test('Testing on sumOfDigitsUsingLoop', () => {
  const sum = sumOfDigitsUsingLoop(123)
  expect(sum).toBe(6)
})

test('Testing on sumOfDigitsUsingRecursion', () => {
  const sum = sumOfDigitsUsingRecursion(123)
  expect(sum).toBe(6)
})

test('Testing on sumOfDigitsUsingString', () => {
  const sum = sumOfDigitsUsingString(123)
  expect(sum).toBe(6)
})
import { perfectNumber } from '../PerfectNumber'

describe('PerfectNumber', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectNumber(28)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectNumber(10)).toBeFalsy()
  })
})
import { findMin } from '../FindMin'

describe('FindMin', () => {
  test('Should return the minimum number in the array', () => {
    const min = findMin(2, 5, 1, 12, 43, 1, 9)
    expect(min).toBe(1)
  })

  test('Should return the minimum number in the array', () => {
    const min = findMin(21, 513, 6)
    expect(min).toBe(6)
  })

  test('Should throw error', () => {
    const min = () => findMin()
    expect(min).toThrow('Array is empty')
  })
})
import { mean } from '../AverageMean'

describe('Tests for average mean', () => {
  it('should be a function', () => {
    expect(typeof mean).toEqual('function')
  })

  it('should throw error for invalid input', () => {
    expect(() => mean(123)).toThrow()
  })

  it('should return the mean of an array of numbers', () => {
    const meanFunction = mean([1, 2, 4, 5])
    expect(meanFunction).toBe(3)
  })

  it('should return the mean of an array of numbers', () => {
    const meanFunction = mean([10, 40, 100, 20])
    expect(meanFunction).toBe(42.5)
  })
})
import { findLcm } from '../FindLcm'

describe('findLcm', () => {
  it('should throw a statement for values less than 1', () => {
    expect(findLcm(0, 0)).toBe('Please enter values greater than zero.')
  })

  it('should throw a statement for one value less than 1', () => {
    expect(findLcm(1, 0)).toBe('Please enter values greater than zero.')
    expect(findLcm(0, 1)).toBe('Please enter values greater than zero.')
  })

  it('should return an error for values non-integer values', () => {
    expect(findLcm(4.564, 7.39)).toBe('Please enter whole numbers.')
  })

  it('should return the LCM of two given integers', () => {
    expect(findLcm(27, 36)).toBe(108)
  })
})
import { integralEvaluation } from '../SimpsonIntegration'

test('Should return the integral of f(x) = sqrt(x) in [1, 3] to be equal 2.797434', () => {
  const result = integralEvaluation(16, 1, 3, (x) => { return Math.sqrt(x) })
  expect(Number(result.toPrecision(7))).toBe(2.797434)
})

test('Should return the integral of f(x) = sqrt(x) + x^2 in [1, 3] to be equal 11.46410161', () => {
  const result = integralEvaluation(64, 1, 3, (x) => { return Math.sqrt(x) + Math.pow(x, 2) })
  expect(Number(result.toPrecision(10))).toBe(11.46410161)
})

test('Should return the integral of f(x) = log(x) + Pi*x^3 in [5, 12] to be equal 15809.9141543', () => {
  const result = integralEvaluation(128, 5, 12, (x) => { return Math.log(x) + Math.PI * Math.pow(x, 3) })
  expect(Number(result.toPrecision(12))).toBe(15809.9141543)
})
import { agm } from '../ArithmeticGeometricMean.js'

describe('Tests for AGM', () => {
  it('should be a function', () => {
    expect(typeof agm).toEqual('function')
  })

  it('number of parameters should be 2', () => {
    expect(agm.length).toEqual(2)
  })

  const m = 0x100 // scale for rand

  it('should return NaN if any or all params has a negative argument', () => {
    // I multiplied by minus one, because the sign inversion is more clearly visible
    expect(agm(-1 * Math.random() * m, Math.random() * m)).toBe(NaN)
    expect(agm(Math.random() * m, -1 * Math.random() * m)).toBe(NaN)
    expect(agm(-1 * Math.random() * m, -1 * Math.random() * m)).toBe(NaN)
  })

  it('should return Infinity if any arg is Infinity and the other is not 0', () => {
    expect(agm(Math.random() * m + 1, Infinity)).toEqual(Infinity)
    expect(agm(Infinity, Math.random() * m + 1)).toEqual(Infinity)
    expect(agm(Infinity, Infinity)).toEqual(Infinity)
  })

  it('should return NaN if some arg is Infinity and the other is 0', () => {
    expect(agm(0, Infinity)).toBe(NaN)
    expect(agm(Infinity, 0)).toBe(NaN)
  })

  it('should return +0 if any or all args are +0 or -0, and return -0 if all are -0', () => {
    expect(agm(Math.random() * m, 0)).toBe(0)
    expect(agm(0, Math.random() * m)).toBe(0)
    expect(agm(Math.random() * m, -0)).toBe(0)
    expect(agm(-0, Math.random() * m)).toBe(0)
    expect(agm(0, -0)).toBe(0)
    expect(agm(-0, 0)).toBe(0)
    expect(agm(-0, -0)).toBe(-0)
  })

  it('should return NaN if any or all args are NaN', () => {
    expect(agm(Math.random() * m, NaN)).toBe(NaN)
    expect(agm(NaN, Math.random() * m)).toBe(NaN)
    expect(agm(NaN, NaN)).toBe(NaN)
  })

  it('should return an accurate approximation of the AGM between 2 valid input args', () => {
    // all the constants are provided by WolframAlpha
    expect(agm(1, 2)).toBeCloseTo(1.4567910310469068)
    expect(agm(2, 256)).toBeCloseTo(64.45940719438667)
    expect(agm(55555, 34)).toBeCloseTo(9933.4047239552)
    // test "unsafe" numbers
    expect(agm(2 ** 48, 3 ** 27)).toBeCloseTo(88506556379265.7)
  })
})
import { powLinear, powFaster } from '../Pow'

describe('Testing powLinear function', () => {
  it('should return 1 for numbers with exponent 0', () => {
    expect(powLinear(2, 0)).toBe(1)
  })

  it('should return 0.5 for numbers with exponent -1', () => {
    expect(powLinear(2, -1)).toBe(0.5)
  })

  it('should return 0 for numbers with base 0', () => {
    expect(powLinear(0, 23)).toBe(0)
  })

  it('should return the base to the exponent power', () => {
    expect(powLinear(24, 4)).toBe(331776)
  })
})

describe('Testing powFaster function', () => {
  it('should return 1 for numbers with exponent 0', () => {
    expect(powFaster(2, 0)).toBe(1)
  })

  it('should return 0.5 for numbers with exponent -1', () => {
    expect(powFaster(2, -1)).toBe(0.5)
  })

  it('should return 0 for numbers with base 0', () => {
    expect(powFaster(0, 23)).toBe(0)
  })

  it('should return the base to the exponent power', () => {
    expect(powFaster(24, 4)).toBe(331776)
  })

  it('should return the result in O(lonN) complexity', () => {
    expect(powFaster(2, 64)).toBe(18446744073709552000) // execution time Math.log2(64) -> 6
  })
})
import { exponent } from '../BinaryExponentiationIterative'

describe('exponent', () => {
  it('should return 1 when power is 0', () => {
    expect(exponent(5, 0)).toBe(1)
  })

  it('should return 0 when base is 0', () => {
    expect(exponent(0, 7)).toBe(0)
  })

  it('should return the value of a base raised to a power', () => {
    expect(exponent(3, 5)).toBe(243)
  })
})
import { FindMinIterator } from '../FindMinIterator'

describe('FindMinIterator', () => {
  test('given empty array then min is undefined', () => {
    expect(FindMinIterator([])).toBeUndefined()
  })

  test('given single value array then min is found', () => {
    expect(FindMinIterator([1])).toBe(1)
    expect(FindMinIterator([-1])).toBe(-1)
    expect(FindMinIterator([0])).toBe(0)
  })

  test('given array then min is found', () => {
    expect(FindMinIterator([1, 2])).toBe(1)
    expect(FindMinIterator([-1, 10])).toBe(-1)
    expect(FindMinIterator([0, 100])).toBe(0)
    expect(FindMinIterator([100, 0])).toBe(0)
    expect(FindMinIterator([100, 50, 20, 0, -100, 0, 2, 30, 45, 99, 104, 23])).toBe(-100)
  })

  test('given empty generator then min is undefined', () => {
    const src = function* () { } // eslint-disable-line
    expect(FindMinIterator(src())).toBeUndefined()
  })

  test('given generator then min is found', () => {
    const src = function* () { // eslint-disable-line
      yield 1
      yield -1
      yield 0
    }
    expect(FindMinIterator(src())).toBe(-1)
  })

  test('given string generator then min string length is found', () => {
    const src = function* () { // eslint-disable-line
      yield 'abc'
      yield 'de'
      yield 'qwerty'
    }
    expect(FindMinIterator(src(), _x => _x.length)).toBe(2)
  })

  test('given array of objects then min accessor is found', () => {
    const array = [
      { name: 'Item #1', price: 1.0 },
      { name: 'Item #2', price: 0.0 },
      { name: 'Item #3', price: -1.0 }
    ]
    expect(FindMinIterator(array, _x => _x.price)).toBe(-1)
    expect(FindMinIterator(array, _x => _x.name)).toBe('Item #1')
  })
})
import {
  FibonacciDpWithoutRecursion,
  FibonacciRecursiveDP,
  FibonacciIterative,
  FibonacciRecursive,
  FibonacciMatrixExpo
} from '../Fibonacci'

describe('Fibonacci', () => {
  it('should return an array of numbers for FibonacciIterative', () => {
    expect(FibonacciIterative(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return an array of numbers for FibonacciRecursive', () => {
    expect(FibonacciRecursive(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return number for FibonacciRecursiveDP', () => {
    expect(FibonacciRecursiveDP(5)).toBe(5)
  })

  it('should return an array of numbers for FibonacciDpWithoutRecursion', () => {
    expect(FibonacciDpWithoutRecursion(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return number for FibonacciMatrixExpo', () => {
    expect(FibonacciMatrixExpo(0)).toBe(0)
    expect(FibonacciMatrixExpo(1)).toBe(1)
    expect(FibonacciMatrixExpo(2)).toBe(1)
    expect(FibonacciMatrixExpo(3)).toBe(2)
    expect(FibonacciMatrixExpo(4)).toBe(3)
    expect(FibonacciMatrixExpo(5)).toBe(5)
  })
})
import { integralEvaluation } from '../MidpointIntegration'

test('Should return the integral of f(x) = sqrt(x) in [1, 3] to be equal 2.797434', () => {
  const result = integralEvaluation(10000, 1, 3, (x) => { return Math.sqrt(x) })
  expect(Number(result.toPrecision(6))).toBe(2.79743)
})

test('Should return the integral of f(x) = sqrt(x) + x^2 in [1, 3] to be equal 11.46410161', () => {
  const result = integralEvaluation(10000, 1, 3, (x) => { return Math.sqrt(x) + Math.pow(x, 2) })
  expect(Number(result.toPrecision(10))).toBe(11.46410161)
})

test('Should return the integral of f(x) = log(x) + Pi*x^3 in [5, 12] to be equal 15809.9141543', () => {
  const result = integralEvaluation(20000, 5, 12, (x) => { return Math.log(x) + Math.PI * Math.pow(x, 3) })
  expect(Number(result.toPrecision(10))).toBe(15809.91415)
})
import { fareyApproximation } from '../FareyApproximation'

describe('fareyApproximation', () => {
  it('Return Farey Approximation of 0.7538385', () => {
    const approx = fareyApproximation(0.7538385)
    expect(approx).toStrictEqual({ numerator: 52, denominator: 69 })
  })

  it('Return Farey Approximation of 0.23584936', () => {
    const approx = fareyApproximation(0.23584936)
    expect(approx).toStrictEqual({ numerator: 196, denominator: 831 })
  })
})
import { collatz } from '../CollatzSequence'

describe('The Collatz Sequence', () => {
  it('Should be 1', () => {
    expect(collatz(1)).toStrictEqual({ result: 1, steps: [] })
    expect(collatz(5)).toStrictEqual({ result: 1, steps: [16, 8, 4, 2, 1] })
  })
})
import { abs } from '../Abs'

describe('Testing abs function', () => {
  it('Testing for invalid types', () => {
    expect(() => abs('234a')).toThrow()
    expect(() => abs({})).toThrow()
    expect(() => abs([12, -32, -60])).toThrow()
  })

  it('Testing for number of string type', () => {
    expect(abs('-345')).toBe(345)
    expect(abs('-345.455645')).toBe(345.455645)
  })

  it('Testing for a boolean type', () => {
    expect(abs(true)).toBe(1)
    expect(abs(false)).toBe(0)
  })

  it('should return an absolute value of a negative number', () => {
    const absOfNegativeNumber = abs(-34)
    expect(absOfNegativeNumber).toBe(34)
  })

  it('should return an absolute value of a positive number', () => {
    const absOfPositiveNumber = abs(50)
    expect(absOfPositiveNumber).toBe(50)
  })

  it('should return an absolute value of a zero number', () => {
    const absOfPositiveNumber = abs(0)
    expect(absOfPositiveNumber).toBe(0)
  })

  it('should return an absolute value of any floating number', () => {
    const absOfPositiveNumber = abs(-20.2034)
    expect(absOfPositiveNumber).toBe(20.2034)
  })
})
import { numberOfDigit } from '../NumberOfDigits'

describe('NumberOfDigits', () => {
  it('should return the correct number of digits for an integer', () => {
    expect(numberOfDigit(1234000)).toBe(7)
  })

  it('should return the correct number of digits for a negative number', () => {
    expect(numberOfDigit(-2346243)).toBe(7)
  })
})
import { getRGBData } from '../Mandelbrot'

describe('Mandelbrot', () => {
  it('should produce black pixels inside the set', () => {
    const blackAndWhite = getRGBData(800, 600, -0.6, 0, 3.2, 50, false)
    expect(blackAndWhite[400][300]).toEqual([0, 0, 0]) // black

    const colorCoded = getRGBData(800, 600, -0.6, 0, 3.2, 50, true)
    expect(colorCoded[400][300]).toEqual([0, 0, 0]) // black
  })

  it('should produce white pixels outside of the set', () => {
    const blackAndWhite = getRGBData(800, 600, -0.6, 0, 3.2, 50, false)
    expect(blackAndWhite[0][0]).toEqual([255, 255, 255]) // black
  })

  it('should produce colored pixels distant to the set', () => {
    const colorCoded = getRGBData(800, 600, -0.6, 0, 3.2, 50, true)
    expect(colorCoded[0][0]).toEqual([255, 0, 0]) // red
  })
})
import { PrimeCheck } from '../PrimeCheck'

describe('PrimeCheck', () => {
  it('should return true for Prime Numbers', () => {
    expect(PrimeCheck(1000003)).toBeTruthy()
  })
  it('should return false for Non Prime Numbers', () => {
    expect(PrimeCheck(1000001)).toBeFalsy()
  })
  it('should return false for 1 and 0', () => {
    expect(PrimeCheck(1)).toBeFalsy()
    expect(PrimeCheck(0)).toBeFalsy()
  })
})
import { PrimeFactors } from '../PrimeFactors'

describe('EulersTotient', () => {
  it('should return the prime factors for 100', () => {
    expect(PrimeFactors(100)).toEqual([2, 2, 5, 5])
  })

  it('should return the prime factors for 2560', () => {
    expect(PrimeFactors(2560)).toEqual([2, 2, 2, 2, 2, 2, 2, 2, 2, 5])
  })
})
import { meanSquaredError } from '../MeanSquareError'

describe('meanSquareError', () => {
  it('should throw an error on non-array arguments', () => {
    expect(() => meanSquaredError(1, 4)).toThrow('Argument must be an Array')
  })

  it('should throw an error on non equal length ', () => {
    const firstArr = [1, 2, 3, 4, 5]
    const secondArr = [1, 2, 3]
    expect(() => meanSquaredError(firstArr, secondArr)).toThrow(
      'The two lists must be of equal length'
    )
  })

  it('should return the mean square error of two equal length arrays', () => {
    const firstArr = [1, 2, 3, 4, 5]
    const secondArr = [1, 3, 5, 6, 7]
    expect(meanSquaredError(firstArr, secondArr)).toBe(2.6)
  })
})
import * as volume from '../Volume'

test('Testing on volCuboid', () => {
  const volCuboid = volume.volCuboid(2.0, 5.0, 3)
  expect(volCuboid).toBe(30.0)
})

test('Testing on volCube', () => {
  const volCube = volume.volCube(2.0)
  expect(volCube).toBe(8.0)
})

test('Testing on volCone', () => {
  const volCone = volume.volCone(3.0, 8.0)
  expect(volCone).toBe(75.39822368615503)
})

test('Testing on volPyramid', () => {
  const volPyramid = volume.volPyramid(2.0, 3.0, 8.0)
  expect(volPyramid).toBe(16.0)
})

test('Testing on volCylinder', () => {
  const volCylinder = volume.volCylinder(3.0, 8.0)
  expect(volCylinder).toBe(226.1946710584651)
})

test('Testing on volTriangularPrism', () => {
  const volTriangularPrism = volume.volTriangularPrism(3.0, 6.0, 8.0)
  expect(volTriangularPrism).toBe(72.0)
})

test('Testing on volPentagonalPrism', () => {
  const volPentagonalPrism = volume.volPentagonalPrism(1.0, 4.0, 8.0)
  expect(volPentagonalPrism).toBe(80.0)
})

test('Testing on volSphere', () => {
  const volSphere = volume.volSphere(4.0)
  expect(volSphere).toBe(268.082573106329)
})

test('Testing on volHemisphere', () => {
  const volHemisphere = volume.volHemisphere(4.0)
  expect(volHemisphere).toBe(134.0412865531645)
})
import { averageMedian } from '../AverageMedian'

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([1, 2, 6, 4, 5])
  expect(medianValue).toBe(4)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([8, 9, 1, 2, 5, 10, 11])
  expect(medianValue).toBe(8)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([15, 18, 3, 9, 13, 5])
  expect(medianValue).toBe(11)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([1, 2, 3, 4, 6, 8])
  expect(medianValue).toBe(3.5)
})
import { binaryExponentiation } from '../BinaryExponentiationRecursive'

describe('BinaryExponentiationRecursive', () => {
  it('should calculate 2 to the power of 10 correctly', () => {
    expect(binaryExponentiation(2, 10)).toBe(1024)
  })

  it('should calculate 3 to the power of 9 correctly', () => {
    expect(binaryExponentiation(3, 9)).toBe(19683)
  })
})
import { gridGetX, gridGetY } from '../GridGet'

describe('GridGet', () => {
  it('should have a value of x for the 27th element if the square array has 400 elements', () => {
    expect(gridGetX(Math.sqrt(400), 27)).toEqual(8)
  })
  it('should have a value of x for the 11th element if the square array has 7 columns and 3 rows', () => {
    expect(gridGetX(7, 11)).toEqual(5)
  })
  it('should have a value of y for the 27th element if the square array has 400 elements', () => {
    expect(gridGetY(Math.sqrt(400), 27)).toEqual(2)
  })
  it('should have a value of y for the 11th element if the square array has 7 columns and 3 rows ', () => {
    expect(gridGetX(7, 11)).toEqual(5)
  })
})
import { powLogarithmic } from '../PowLogarithmic'

describe('PowLogarithmic', () => {
  it('should return 1 for numbers with exponent 0', () => {
    expect(powLogarithmic(2, 0)).toBe(1)
  })

  it('should return 0 for numbers with base 0', () => {
    expect(powLogarithmic(0, 23)).toBe(0)
  })

  it('should return the base to the exponent power', () => {
    expect(powLogarithmic(24, 4)).toBe(331776)
  })
})
import { modularBinaryExponentiation } from '../ModularBinaryExponentiationRecursive'

describe('modularBinaryExponentiation', () => {
  it('should return the binary exponentiation', () => {
    expect(modularBinaryExponentiation(2, 10, 17)).toBe(4)
  })
})
import {
  isTriangular,
  isTetrahedral,
  isPentatope,
  checkAll
} from '../FigurateNumber'

describe('FigurateNumber', () => {
  it('Triangular : should return true', () => {
    expect(isTriangular(1)).toEqual(true)
  })
  it('Triangular : should return true', () => {
    expect(isTriangular(3)).toEqual(true)
  })

  it('Triangular : should return false', () => {
    expect(isTriangular(5)).toEqual(false)
  })

  it('Triangular : should return true', () => {
    expect(isTriangular(171)).toEqual(true)
  })
  /** End */

  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(1)).toEqual(true)
  })
  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(4)).toEqual(true)
  })

  it('Tetrahedral : should return false', () => {
    expect(isTetrahedral(3)).toEqual(false)
  })

  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(165)).toEqual(true)
  })

  /** End */
  it('Pentatope : should return true', () => {
    expect(isPentatope(1)).toEqual(true)
  })
  it('Pentatope : should return true', () => {
    expect(isPentatope(5)).toEqual(true)
  })

  it('Pentatope : should return false', () => {
    expect(isPentatope(3)).toEqual(false)
  })

  it('Pentatope : should return true', () => {
    expect(isPentatope(1001)).toEqual(true)
  })
  /** End */

  it('Check All : should return all true', () => {
    expect(checkAll(1)).toEqual({
      isTriangular: true,
      isTetrahedral: true,
      isPentatope: true
    })
  })

  it('Check All : should return all true,true,false', () => {
    expect(checkAll(15)).toEqual({
      isTriangular: true,
      isTetrahedral: false,
      isPentatope: true
    })
  })
})
import { findRoot } from '../BisectionMethod'

test('Equation f(x) = x^2 - 3*x + 2 = 0, has root x = 1 in [a, b] = [0, 1.5]', () => {
  const root = findRoot(0, 1.5, (x) => { return Math.pow(x, 2) - 3 * x + 2 }, 8)
  expect(root).toBe(0.9990234375)
})

test('Equation f(x) = ln(x) + sqrt(x) + *x^2 = 0, has root x = 0.36247037 in [a, b] = [0, 10]', () => {
  const root = findRoot(0, 10, (x) => { return Math.log(x) + Math.sqrt(x) + Math.PI * Math.pow(x, 2) }, 32)
  expect(Number(Number(root).toPrecision(8))).toBe(0.36247037)
})

test('Equation f(x) = sqrt(x) + e^(2*x) - 8*x = 0, has root x = 0.93945851 in [a, b] = [0.5, 100]', () => {
  const root = findRoot(0.5, 100, (x) => { return Math.exp(2 * x) + Math.sqrt(x) - 8 * x }, 32)
  expect(Number(Number(root).toPrecision(8))).toBe(0.93945851)
})
import { BinaryConvert } from '../BinaryConvert'

describe('BinaryConvert', () => {
  it('should return the correct value', () => {
    expect(BinaryConvert(4)).toBe(100)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(12)).toBe(1100)
  })
  it('should return the correct value of the sum from two number', () => {
    expect(BinaryConvert(12 + 2)).toBe(1110)
  })
  it('should return the correct value of the subtract from two number', () => {
    expect(BinaryConvert(245 - 56)).toBe(10111101)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(254)).toBe(11111110)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(63483)).toBe(1111011111111011)
  })
})
import { eulerFull, eulerStep } from '../EulerMethod'

describe('eulerStep', () => {
  it('should calculate the next y value correctly', () => {
    expect(eulerStep(0, 0.1, 0, function (x, y) { return x })).toBe(0)
    expect(eulerStep(2, 1, 1, function (x, y) { return x * x })).toBe(5)
  })
})

describe('eulerFull', () => {
  it('should return all the points found', () => {
    expect(eulerFull(0, 3, 1, 0, function (x, y) { return x }))
      .toEqual([{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 1 }, { x: 3, y: 3 }])

    expect(eulerFull(3, 4, 0.5, 1, function (x, y) { return x * x }))
      .toEqual([{ x: 3, y: 1 }, { x: 3.5, y: 5.5 }, { x: 4, y: 11.625 }])
  })
})
import { zellersCongruenceAlgorithm } from '../ZellersCongruenceAlgorithm'

function testZeller (day, month, year, expected) {
  test('Testing on ' + day + '/' + month + '/' + year, () => {
    expect(zellersCongruenceAlgorithm(day, month, year)).toBe(expected)
  })
}

test('Testing on this/should/throw', () => {
  expect(() => {
    zellersCongruenceAlgorithm('this', 'should', 'error')
  }).toThrowError(new TypeError('Arguments are not all numbers.'))
})
testZeller(25, 1, 2013, 'Friday')
testZeller(26, 1, 2013, 'Saturday')
testZeller(16, 4, 2022, 'Saturday')
testZeller(25, 4, 2022, 'Monday')
import { piEstimation } from '../PiApproximationMonteCarlo'

describe('PiApproximationMonteCarlo', () => {
  it('should be between the range of 2 to 4', () => {
    const pi = piEstimation()
    const piRange = pi >= 2 && pi <= 4
    expect(piRange).toBeTruthy()
  })
})
import { extendedEuclideanGCD } from '../ExtendedEuclideanGCD'

describe('extendedEuclideanGCD', () => {
  it('should return valid values in order for positive arguments', () => {
    expect(extendedEuclideanGCD(240, 46)).toMatchObject([2, -9, 47])
    expect(extendedEuclideanGCD(46, 240)).toMatchObject([2, 47, -9])
  })
  it('should give error on non-positive arguments', () => {
    expect(() => extendedEuclideanGCD(0, 240)).toThrowError(new TypeError('Must be positive numbers'))
    expect(() => extendedEuclideanGCD(46, -240)).toThrowError(new TypeError('Must be positive numbers'))
  })
  it('should give error on non-numeric arguments', () => {
    expect(() => extendedEuclideanGCD('240', 46)).toThrowError(new TypeError('Not a Number'))
    expect(() => extendedEuclideanGCD([240, 46])).toThrowError(new TypeError('Not a Number'))
  })
})
/*
  Program to get the Nth Lucas Number
  Article on Lucas Number: https://en.wikipedia.org/wiki/Lucas_number
  Examples:
    > loopLucas(1)
    1
    > loopLucas(20)
    15127
    > loopLucas(100)
    792070839848372100000
*/

/**
 * @param {Number} index The position of the number you want to get from the Lucas Series
 */
function lucas (index) {
  // index can't be negative
  if (index < 0) throw new TypeError('Index cannot be Negative')

  // index can't be a decimal
  if (Math.floor(index) !== index) throw new TypeError('Index cannot be a Decimal')

  let a = 2
  let b = 1
  for (let i = 0; i < index; i++) {
    const temp = a + b
    a = b
    b = temp
  }
  return a
}

export { lucas }
/*
  Modified from:
    https://github.com/TheAlgorithms/Python/blob/master/maths/binary_exp_mod.py

  Explanation:
    https://en.wikipedia.org/wiki/Exponentiation_by_squaring
*/

const modularBinaryExponentiation = (a, n, m) => {
  // input: a: int, n: int, m: int
  // returns: (a^n) % m: int
  if (n === 0) {
    return 1
  } else if (n % 2 === 1) {
    return (modularBinaryExponentiation(a, n - 1, m) * a) % m
  } else {
    const b = modularBinaryExponentiation(a, n / 2, m)
    return (b * b) % m
  }
}

export { modularBinaryExponentiation }
/**
 * @function abs
 * @description This script will find the absolute value of a number.
 * @param {number} num - The input integer
 * @return {number} - Absolute number of num.
 * @see https://en.wikipedia.org/wiki/Absolute_value
 * @example abs(-10) = 10
 * @example abs(50) = 50
 * @example abs(0) = 0
 */

const abs = (num) => {
  const validNumber = +num // converted to number, also can use - Number(num)

  if (Number.isNaN(validNumber)) {
    throw new TypeError('Argument is NaN - Not a Number')
  }

  return validNumber < 0 ? -validNumber : validNumber // if number is less then zero mean negative then it converted to positive. i.e -> n = -2 = -(-2) = 2
}

export { abs }
/**
 * @function powLinear
 * @description - The powLinear function is a power function with Linear O(n) complexity
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @example - powLinear(2, 2) => 4 --> 2 * 2
 * @example - powLinear(3, 3) => 27 --> 3 * 3 * 3
 */
const powLinear = (base, exponent) => {
  if (exponent < 0) {
    base = 1 / base
    exponent = -exponent
  }

  let result = 1

  while (exponent--) { // Break the execution while the exponent will 0
    result *= base
  }

  return result
}

/**
 * @function powFaster
 * @description - The powFaster function is a power function with O(logN) complexity
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @example - powFaster(2, 2) => 4 --> 2 * 2
 * @example - powFaster(3, 3) => 27 --> 3 * 3 * 3
 */
const powFaster = (base, exponent) => {
  if (exponent < 2) { // explanation below - 1
    return base && ([1, base][exponent] || powFaster(1 / base, -exponent))
  }

  if (exponent & 1) { // if the existing exponent is odd
    return base * powFaster(base * base, exponent >> 1) // explanation below - 2
  }

  return powFaster(base * base, exponent / 2)
}

/**
 * 1 - Magic of short circuit evaluation (&&, ||)
 * if the base is 0 then it returns 0 cause 0 is falsy
 * if the base is not 0 then it's must be truthy. after that, it will be executed the right portion of the && (AND) operator
 * Now it checks the exponent by the help array index, is it 0 or 1.
 * if the exponent is not 0 or 1 it's definitely less than 0, and a negative number is not a valid index number so it returns "undefined"
 * if the expression is undefined mean -> falsy, the || (OR) operator evaluates the right portion that is a recursive function.
 */

/**
 * 2 - Play with right shift bitwise operator (>>)
 * right shift with any odd numbers it returns the floor number instead of float.
 * E.g. if the number is 5, after right shifting with 1 it's will give us 2, not 2.5
 * cause the right shift formula is --> x >> y = |x| / 2^y
 */

export { powLinear, powFaster }
/**
 * @function FindMin
 * @description Function to find the minimum number given in an array of integers.
 * @param {Integer[]} nums - Array of Integers
 * @return {Integer} - The minimum number of the array.
 */

const findMin = (...nums) => {
  if (nums.length === 0) {
    throw new TypeError('Array is empty')
  }

  let min = nums[0]
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] < min) {
      min = nums[i]
    }
  }

  return min
}

export { findMin }
/*
  Source:
    https://en.wikipedia.org/wiki/Euler%27s_totient_function

  EulersTotient(n) = n * product(1 - 1/p for all prime p dividing n)

  Complexity:
    O(sqrt(n))
*/

export const EulersTotient = (n) => {
  // input: n: int
  // output: phi(n): count of numbers b/w 1 and n that are coprime to n
  let res = n
  for (let i = 2; i * i <= n; i++) {
    if (n % i === 0) {
      while (n % i === 0) {
        n = Math.floor(n / i)
      }
      // i is a prime diving n, multiply res by 1 - 1/i
      // res = res * (1 - 1/i) = res - (res / i)
      res = res - Math.floor(res / i)
    }
  }
  if (n > 1) {
    res = res - Math.floor(res / n)
  }
  return res
}
/**
 * A palindrome is any string that can be reversed and still be the same.
 * An example of one is 'radar', since it is spelled the same even after
 * being reversed. One method to check if a
 *
 * Here's how this works recursively:
 *
 * Palindrome('radar')
 * true && Palindrome('ada')
 * true && true && Palindrome('d')
 * true && true && true && true
 *
 * @flow
 * @complexity: O(n)
 */

const PalindromeRecursive = (string) => {
  // Base case
  if (string.length < 2) return true

  // Check outermost keys
  if (string[0] !== string[string.length - 1]) {
    return false
  }

  return PalindromeRecursive(string.slice(1, string.length - 1))
}

const PalindromeIterative = (string) => {
  const _string = string
    .toLowerCase()
    .replace(/ /g, '')
    .replace(/,/g, '')
    .replace(/'.'/g, '')
    .replace(/:/g, '')
    .split('')

  // A word of only 1 character is already a palindrome, so we skip to check it
  while (_string.length > 1) {
    if (_string.shift() !== _string.pop()) {
      return false
    }
  }

  return true
}

export { PalindromeIterative, PalindromeRecursive }
/*
*
* @file
* @title Composite Simpson's rule for definite integral evaluation
* @author: [ggkogkou](https://github.com/ggkogkou)
* @brief Calculate definite integrals using composite Simpson's numerical method
*
* @details The idea is to split the interval in an EVEN number N of intervals and use as interpolation points the xi
* for which it applies that xi = x0 + i*h, where h is a step defined as h = (b-a)/N where a and b are the
* first and last points of the interval of the integration [a, b].
*
* We create a table of the xi and their corresponding f(xi) values and we evaluate the integral by the formula:
* I = h/3 * {f(x0) + 4*f(x1) + 2*f(x2) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)}
*
* That means that the first and last indexed i f(xi) are multiplied by 1,
* the odd indexed f(xi) by 4 and the even by 2.
*
* N must be even number and a<b. By increasing N, we also increase precision
*
* More info: [Wikipedia link](https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson's_rule)
*
*/

function integralEvaluation (N, a, b, func) {
  // Check if N is an even integer
  let isNEven = true
  if (N % 2 !== 0) isNEven = false

  if (!Number.isInteger(N) || Number.isNaN(a) || Number.isNaN(b)) { throw new TypeError('Expected integer N and finite a, b') }
  if (!isNEven) { throw Error('N is not an even number') }
  if (N <= 0) { throw Error('N has to be >= 2') }

  // Check if a < b
  if (a > b) { throw Error('a must be less or equal than b') }
  if (a === b) return 0

  // Calculate the step h
  const h = (b - a) / N

  // Find interpolation points
  let xi = a // initialize xi = x0
  const pointsArray = []

  // Find the sum {f(x0) + 4*f(x1) + 2*f(x2) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)}
  let temp
  for (let i = 0; i < N + 1; i++) {
    if (i === 0 || i === N) temp = func(xi)
    else if (i % 2 === 0) temp = 2 * func(xi)
    else temp = 4 * func(xi)

    pointsArray.push(temp)
    xi += h
  }

  // Calculate the integral
  let result = h / 3
  temp = 0
  for (let i = 0; i < pointsArray.length; i++) temp += pointsArray[i]

  result *= temp

  if (Number.isNaN(result)) { throw Error("Result is NaN. The input interval doesn't belong to the functions domain") }

  return result
}

export { integralEvaluation }
/*
    author: PatOnTheBack
    license: GPL-3.0 or later

    Modified from:
        https://github.com/TheAlgorithms/Python/blob/master/maths/findLcm.py

    More about LCM:
        https://en.wikipedia.org/wiki/Least_common_multiple
*/

'use strict'

// Find the LCM of two numbers.
const findLcm = (num1, num2) => {
  // If the input numbers are less than 1 return an error message.
  if (num1 < 1 || num2 < 1) {
    return 'Please enter values greater than zero.'
  }

  // If the input numbers are not integers return an error message.
  if (num1 !== Math.round(num1) || num2 !== Math.round(num2)) {
    return 'Please enter whole numbers.'
  }

  // Get the larger number between the two
  const maxNum = Math.max(num1, num2)
  let lcm = maxNum

  while (true) {
    if (lcm % num1 === 0 && lcm % num2 === 0) return lcm
    lcm += maxNum
  }
}

export { findLcm }
/**
 * @function agm
 * @description This finds the Arithmetic-Geometric Mean between any 2 numbers.
 * @param {Number} a - 1st number, also used to store Arithmetic Mean.
 * @param {Number} g - 2nd number, also used to store Geometric Mean.
 * @return {Number} - AGM of both numbers.
 * @see [AGM](https://en.wikipedia.org/wiki/Arithmetic%E2%80%93geometric_mean)
 */

export const agm = (a, g) => {
  if (a === Infinity && g === 0) return NaN
  if (Object.is(a, -0) && !Object.is(g, -0)) return 0
  if (a === g) return a // avoid rounding errors, and increase efficiency
  let x // temp var
  do {
    [a, g, x] = [(a + g) / 2, Math.sqrt(a * g), a]
  } while (a !== x && !isNaN(a))
  /*
  `x !== a` ensures the return value has full precision,
  and prevents infinite loops caused by rounding differences between `div` and `sqrt` (no need for "epsilon").
  If we were to compare `a` with `g`, some input combinations (not all) can cause an infinite loop,
  because the rounding mode never changes at runtime.
  Precision is not the same as accuracy, but they're related.
  This function isn't always 100% accurate (round-errors), but at least is more than 95% accurate.
  `!isNaN(x)` prevents infinite loops caused by invalid inputs like: negatives, NaNs and Infinities.
  */
  return a
}
/**
 * @function BinaryConvert
 * @description Convert the decimal to binary.
 * @param {Integer} num - The input integer
 * @return {Integer} - Binary of num.
 * @see [BinaryConvert](https://www.programiz.com/javascript/examples/decimal-binary)
 * @example BinaryConvert(12) = 1100
 * @example BinaryConvert(12 + 2) = 1110
 */

const BinaryConvert = (num) => {
  let power = 1
  let binary = 0

  while (num) {
    const rem = num % 2
    num = Math.floor(num / 2)
    binary = rem * power + binary
    power *= 10
  }

  return binary
}

export { BinaryConvert }
/*
    author: TangibleDream
    license: GPL-3.0 or later

    These methods will find x or y given the element and columns for a 2 dimensional array.

    If your array is a perfect square, you can find columns by getting the square
    root of the length of the array.

    Let's say for instance you had an array of 10 by 10 or 100, elements and you wanted to
    find the shortest distance between element 3, and element 49. In this case coding out
    a function to return the distance without finding x and y for both elements I found to
    be painful. If you first find x and y, where 3 becomes 4,1 and 49 becomes 10,5, you can
    find distance by first subtracting x from x and y from y this returns 6,4 or -6,-4.
    Next apply absolute value to assure the results are positive,
    last choose the maximum value of the set, or 6.

    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  | 3|  |  |  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  |  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  |  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  |  |  |  |49|
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  |  |  |  |  |

    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  | 3|  |  |  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  | 1|  |  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  | 2|  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  | 3| 4| 5|6!|
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  |  |  |  |  |

*/

const gridGetX = (columns, index) => {
  while (index + 1 > columns) {
    index = index - columns
  }
  return index + 1
}

const gridGetY = (columns, index) => {
  return Math.floor(index / columns) + 1
}

export { gridGetX, gridGetY }
/**
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 * More on Factors:
 *      https://www.mathsisfun.com/definitions/factor.html
 *
 */

const factorsOfANumber = (number = 0) => {
  return Array.from(Array(number + 1).keys()).filter(
    (num) => number % num === 0
  )
}

export { factorsOfANumber }
// Wikipedia: https://en.wikipedia.org/wiki/Monte_Carlo_method
// Video Explanation: https://www.youtube.com/watch?v=ELetCV_wX_c

const piEstimation = (iterations = 100000) => {
  let circleCounter = 0

  for (let i = 0; i < iterations; i++) {
    // generating random points and checking if it lies within a circle of radius 1
    const x = Math.random()
    const y = Math.random()
    const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))

    if (radius < 1) circleCounter += 1
  }

  // fomula for pi = (ratio of number inside circle and total iteration) x 4
  const pi = (circleCounter / iterations) * 4
  return pi
}

export { piEstimation }
/**
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 * An Armstrong number is equal to the sum of its own digits each raised to the power of the number of digits.
 * For example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370.
 * An Armstrong number is often called Narcissistic number.
 *
 */

const armstrongNumber = (num) => {
  if (num < 0 || typeof num !== 'number') return false

  let newSum = 0

  const numArr = num.toString().split('')
  numArr.forEach((num) => {
    newSum += parseInt(num) ** numArr.length
  })

  return newSum === num
}

export { armstrongNumber }
/**
 *
 * @file
 * @brief Find real roots of a function in a specified interval [a, b], where f(a)*f(b) < 0
 *
 * @details Given a function f(x) and an interval [a, b], where f(a) * f(b) < 0, find an approximation of the root
 * by calculating the middle m = (a + b) / 2, checking f(m) * f(a) and f(m) * f(b) and then by choosing the
 * negative product that means Bolzano's theorem is applied,, define the new interval with these points. Repeat until
 * we get the precision we want [Wikipedia](https://en.wikipedia.org/wiki/Bisection_method)
 *
 * @author [ggkogkou](https://github.com/ggkogkou)
 *
 */

const findRoot = (a, b, func, numberOfIterations) => {
  // Check if a given  real value belongs to the function's domain
  const belongsToDomain = (x, f) => {
    const res = f(x)
    return !Number.isNaN(res)
  }
  if (!belongsToDomain(a, func) || !belongsToDomain(b, func)) throw Error("Given interval is not a valid subset of function's domain")

  // Bolzano theorem
  const hasRoot = (a, b, func) => {
    return func(a) * func(b) < 0
  }
  if (hasRoot(a, b, func) === false) { throw Error('Product f(a)*f(b) has to be negative so that Bolzano theorem is applied') }

  // Declare m
  const m = (a + b) / 2

  // Recursion terminal condition
  if (numberOfIterations === 0) { return m }

  // Find the products of f(m) and f(a), f(b)
  const fm = func(m)
  const prod1 = fm * func(a)
  const prod2 = fm * func(b)

  // Depending on the sign of the products above, decide which position will m fill (a's or b's)
  if (prod1 > 0 && prod2 < 0) return findRoot(m, b, func, --numberOfIterations)
  else if (prod1 < 0 && prod2 > 0) return findRoot(a, m, func, --numberOfIterations)
  else throw Error('Unexpected behavior')
}

export { findRoot }
const addRow = (triangle) => {
  const previous = triangle[triangle.length - 1]
  const newRow = [1]
  for (let i = 0; i < previous.length - 1; i++) {
    const current = previous[i]
    const next = previous[i + 1]
    newRow.push(current + next)
  }
  newRow.push(1)
  return triangle.push(newRow)
}

const generate = (numRows) => {
  const triangle = [[1], [1, 1]]

  if (numRows === 0) {
    return []
  } else if (numRows === 1) {
    return [[1]]
  } else if (numRows === 2) {
    return [[1], [1, 1]]
  } else {
    for (let i = 2; i < numRows; i++) {
      addRow(triangle)
    }
  }
  return triangle
}

export { generate }
/*
  Modified from:
    https://github.com/TheAlgorithms/Python/blob/master/maths/prime_check.py

  Complexity:
    O(sqrt(n))
*/

const PrimeCheck = (n) => {
  // input: n: int
  // output: boolean
  if (n === 1) return false
  if (n === 0) return false
  if (n === 2) return true
  if (n % 2 === 0) return false

  for (let i = 3; i * i <= n; i += 2) {
    if (n % i === 0) {
      return false
    }
  }
  return true
}

export { PrimeCheck }
const sieveOfEratosthenes = (n) => {
  /*
   * Calculates prime numbers till a number n
   * :param n: Number up to which to calculate primes
   * :return: A boolean list containing only primes
   */
  const primes = new Array(n + 1)
  primes.fill(true) // set all as true initially
  primes[0] = primes[1] = false // Handling case for 0 and 1
  const sqrtn = Math.ceil(Math.sqrt(n))
  for (let i = 2; i <= sqrtn; i++) {
    if (primes[i]) {
      for (let j = i * i; j <= n; j += i) {
        /*
        Optimization.
        Let j start from i * i, not 2 * i, because smaller multiples of i have been marked false.

        For example, let i = 4.
        We do not have to check from 8(4 * 2) to 12(4 * 3)
        because they have been already marked false when i=2 and i=3.
        */
        primes[j] = false
      }
    }
  }
  return primes
}

export { sieveOfEratosthenes }
// Wikipedia URL for General Matrix Multiplication Concepts: https://en.wikipedia.org/wiki/Matrix_multiplication

// This algorithm has multiple functions that ultimately check if the inputs are actually matrices and if two Matrices (that can be different sizes) can be multiplied together.
// matrices that are of the same size [2x2]x[2x2], and the second is the multiplication of two matrices that are not the same size [2x3]x[3x2].

// MatrixCheck tests to see if all of the rows of the matrix inputted have similar size columns
const matrixCheck = (matrix) => {
  let columnNumb
  for (let index = 0; index < matrix.length; index++) {
    if (index === 0) {
      columnNumb = matrix[index].length
    } else if (matrix[index].length !== columnNumb) {
      // The columns in this array are not equal
    } else {
      return columnNumb
    }
  }
}

// tests to see if the matrices have a like side, i.e. the row length on the first matrix matches the column length on the second matrix, or vice versa.
const twoMatricesCheck = (first, second) => {
  const [firstRowLength, secondRowLength, firstColLength, secondColLength] = [first.length, second.length, matrixCheck(first), matrixCheck(second)]
  if (firstRowLength !== secondColLength || secondRowLength !== firstColLength) {
    // These matrices do not have a common side
    return false
  } else {
    return true
  }
}

// returns an empty array that has the same number of rows as the left matrix being multiplied.
// Uses Array.prototype.map() to loop over the first (or left) matrix and returns an empty array on each iteration.
const initiateEmptyArray = (first, second) => {
  if (twoMatricesCheck(first, second)) {
    const emptyArray = first.map(() => {
      return ['']
    })
    return emptyArray
  } else {
    return false
  }
}

// Finally, `matrixMult` uses `Array.prototype.push()`, multiple layers of nested `for` loops, the addition assignment `+=` operator and multiplication operator `*` to perform the dot product between two matrices of differing sizes.
// Dot product, takes the row of the first matrix and multiplies it by the column of the second matrix, the `twoMatricesCheck` tested to see if they were the same size already.
// The dot product for each iteration is then saved to its respective index into `multMatrix`.
export const matrixMult = (firstArray, secondArray) => {
  const multMatrix = initiateEmptyArray(firstArray, secondArray)
  for (let rm = 0; rm < firstArray.length; rm++) {
    const rowMult = []
    for (let col = 0; col < firstArray[0].length; col++) {
      rowMult.push(firstArray[rm][col])
    }
    for (let cm = 0; cm < firstArray.length; cm++) {
      const colMult = []
      for (let row = 0; row < secondArray.length; row++) {
        colMult.push(secondArray[row][cm])
      }
      let newNumb = 0
      for (let index = 0; index < rowMult.length; index++) {
        newNumb += rowMult[index] * colMult[index]
      }
      multMatrix[rm][cm] = newNumb
    }
  }
  return multMatrix
}

// const firstMatrix = [
//   [1, 2],
//   [3, 4]
// ]

// const secondMatrix = [
//   [5, 6],
//   [7, 8]
// ]

// matrixMult(firstMatrix, secondMatrix) // [ [ 19, 22 ], [ 43, 50 ] ]

// const thirdMatrix = [
//   [-1, 4, 1],
//   [7, -6, 2]
// ]
// const fourthMatrix = [
//   [2, -2],
//   [5, 3],
//   [3, 2]
// ]

// matrixMult(thirdMatrix, fourthMatrix) // [ [ 21, 16 ], [ -10, -28 ] ]
/**
 * @function findMaxRecursion
 * @description This algorithm will find the maximum value of a array of numbers.
 *
 * @param {Integer[]} arr Array of numbers
 * @param {Integer} left Index of the first element
 * @param {Integer} right Index of the last element
 *
 * @return {Integer} Maximum value of the array
 *
 * @see [Maximum value](https://en.wikipedia.org/wiki/Maximum_value)
 *
 * @example findMaxRecursion([1, 2, 4, 5]) = 5
 * @example findMaxRecursion([10, 40, 100, 20]) = 100
 * @example findMaxRecursion([-1, -2, -4, -5]) = -1
 */
function findMaxRecursion (arr, left, right) {
  const len = arr.length

  if (len === 0 || !arr) {
    return undefined
  }

  if (left >= len || left < -len || right >= len || right < -len) {
    throw new Error('Index out of range')
  }

  if (left === right) {
    return arr[left]
  }

  // n >> m is equivalent to floor(n / pow(2, m)), floor(n / 2) in this case, which is the mid index
  const mid = (left + right) >> 1

  const leftMax = findMaxRecursion(arr, left, mid)
  const rightMax = findMaxRecursion(arr, mid + 1, right)

  // Return the maximum
  return Math.max(leftMax, rightMax)
}

export { findMaxRecursion }
/*
  Gets the sum of the digits of the numbers inputted
  sumOfDigits(10) will return 1 + 0 = 1
  sumOfDigits(255) will return 2 + 5 + 5 = 12
  Wikipedia: https://en.wikipedia.org/wiki/Digit_sum
*/

/*
  The given input is converted to a string, split into an array of characters.
  This array is reduced to a number using the method <Array>.reduce
  NOTE: The final parseInt is just there in cases where 1 digit numbers are given, since without that it would result in a String output.
*/
function sumOfDigitsUsingString (number) {
  if (number < 0) number = -number

  return Number.parseInt(number.toString().split('').reduce((a, b) => Number(a) + Number(b)))
}

/*
  The input is divided by 10 in each iteration, till the input is equal to 0
  The sum of all the digits is returned (The res variable acts as a collector, taking the remainders on each iteration)
*/
function sumOfDigitsUsingLoop (number) {
  if (number < 0) number = -number
  let res = 0

  while (number > 0) {
    res += number % 10
    number = Math.floor(number / 10)
  }

  return res
}

/*
  We use the fact that the sum of the digits of a one digit number is itself, and check whether the number is less than 10. If so, then we return the number. Else, we take the number divided by 10 and floored, and recursively call the function, while adding it with the number mod 10
*/
function sumOfDigitsUsingRecursion (number) {
  if (number < 0) number = -number

  if (number < 10) return number

  return (number % 10) + sumOfDigitsUsingRecursion(Math.floor(number / 10))
}

export { sumOfDigitsUsingRecursion, sumOfDigitsUsingLoop, sumOfDigitsUsingString }
/*
    author sandyboypraper

    Here is the EulerTotientFunction.
    it is also represented by phi

    so EulersTotientFunction(n) (or phi(n)) is the count of numbers in {1,2,3,....,n} that are relatively
    prime to n, i.e., the numbers whose GCD (Greatest Common Divisor) with n is 1.
*/

const gcdOfTwoNumbers = (x, y) => {
  // x is smaller than y
  // let gcd of x and y is gcdXY
  // so it divides x and y completely
  // so gcdXY should also divide y%x (y = gcdXY*a and x = gcdXY*b and y%x = y - x*k so y%x = gcdXY(a - b*k))
  // and gcd(x,y) is equal to gcd(y%x , x)
  return x === 0 ? y : gcdOfTwoNumbers(y % x, x)
}

const eulersTotientFunction = (n) => {
  let countOfRelativelyPrimeNumbers = 1
  for (let iterator = 2; iterator <= n; iterator++) {
    if (gcdOfTwoNumbers(iterator, n) === 1) countOfRelativelyPrimeNumbers++
  }
  return countOfRelativelyPrimeNumbers
}

export { eulersTotientFunction }
/*
    Problem statement and Explanation : https://en.wikipedia.org/wiki/Coprime_integers

    In number theory, two integers a and b are coprime, relatively prime or
    mutually prime if the only positive integer that is a divisor of both
    of them is Consequently, any prime number that divides one of a
    or b does not divide the other. This is equivalent to their greatest
    common divisor (gcd) being. One says also a is prime to b or a
    is coprime with b.
*/

// Here we use a GetEuclidGCD method as a utility.
const GetEuclidGCD = (arg1, arg2) => {
  let less = arg1 > arg2 ? arg2 : arg1
  for (less; less >= 2; less--) {
    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)
  }
  return (less)
}

// CoPrimeCheck function return the boolean in respect of the given number is co-prime or not.
/**
 * CoPrimeCheck function return the boolean in respect of the given number is co-prime or not.
 * @param {Number} firstNumber first number for checking is prime or not.
 * @param {Number} secondNumber second number for checking is prime or not.
 * @returns return correspond boolean value, if both number are co-prime return `true`, else return `false`.
 */
const CoPrimeCheck = (firstNumber, secondNumber) => {
  // firstly, check that input is a number or not.
  if (typeof firstNumber !== 'number' || typeof secondNumber !== 'number') {
    return new TypeError('Argument is not a number.')
  }
  /*
    This is the most efficient algorithm for checking co-primes
    if the GCD of both the numbers is 1 that means they are co-primes.
    */
  return GetEuclidGCD(firstNumber, secondNumber) === 1
}

export { CoPrimeCheck }
/**
 * @function mean
 * @description This script will find the mean value of a array of numbers.
 * @param {Integer[]} nums - Array of integer
 * @return {Integer} - mean of nums.
 * @see [Mean](https://en.wikipedia.org/wiki/Mean)
 * @example mean([1, 2, 4, 5]) = 3
 * @example mean([10, 40, 100, 20]) = 42.5
 */

const mean = (nums) => {
  if (!Array.isArray(nums)) {
    throw new TypeError('Invalid Input')
  }

  // This loop sums all values in the 'nums' array using forEach loop
  const sum = nums.reduce((sum, cur) => sum + cur, 0)

  // Divide sum by the length of the 'nums' array.
  return sum / nums.length
}

export { mean }
/*
 * Median: https://en.wikipedia.org/wiki/Median
 *
 * function averageMedian
 * to find the median value of an array of numbers
 * the numbers in an array will be sorted in ascending order by the function sortNumbers
 * if the length of the array is even number, the median value will be the average of the two middle numbers
 * else if the length of the array is odd number, the median value will be the middle number in the array
 */

const averageMedian = (sourceArrayOfNumbers) => {
  let numbers = [...sourceArrayOfNumbers]
  let median = 0
  const numLength = numbers.length
  numbers = numbers.sort(sortNumbers)

  if (numLength % 2 === 0) {
    median = (numbers[numLength / 2 - 1] + numbers[numLength / 2]) / 2
  } else {
    median = numbers[(numLength - 1) / 2]
  }

  return median
}

const sortNumbers = (num1, num2) => {
  return num1 - num2
}

export { averageMedian }
/*
 * Radian : https://en.wikipedia.org/wiki/Radian
 * Degree : https://en.wikipedia.org/wiki/Degree_(angle)
 *
 * Angle in Radian = ( Angle in Degree ) x ( pi / 180 )
 *
 * Example :
 * Question : Convert 90 degree to radian
 * So, Angle in Degree = 90
 *
 * Solution :
 * Angle in Radian = ( 90 ) x ( pi / 180 ) = pi / 2
 *
 * So, 90 degree is equal to pi / 2 radian
 */

/**
 * @param {number} degree
 * @return {number}
 */
export const degreeToRadian = (degree) => {
  return degree * (Math.PI / 180)
}
/*
    Problem statement and Explanation : https://en.wikipedia.org/wiki/Euclidean_algorithm

    In this method, we have followed the iterative approach to first
    find a minimum of both numbers and go to the next step.
*/

/**
 * GetEuclidGCD return the gcd of two numbers using Euclidean algorithm.
 * @param {Number} arg1 first argument for gcd
 * @param {Number} arg2 second argument for gcd
 * @returns return a `gcd` value of both number.
 */
const GetEuclidGCD = (arg1, arg2) => {
  // firstly, check that input is a number or not.
  if (typeof arg1 !== 'number' || typeof arg2 !== 'number') {
    return new TypeError('Argument is not a number.')
  }
  // check that the input number is not a negative value.
  if (arg1 < 1 || arg2 < 1) {
    return new TypeError('Argument is a negative number.')
  }
  // Find a minimum of both numbers.
  let less = arg1 > arg2 ? arg2 : arg1
  // Iterate the number and find the gcd of the number using the above explanation.
  for (less; less >= 2; less--) {
    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)
  }
  return (less)
}

export { GetEuclidGCD }
/**
 * @details Calculates the number of permutations and combinations.
 * @external_link (Permutation And Combinations)[https://www.geeksforgeeks.org/permutation-and-combination/]
 */

/**
 * @brief Calculates the factorial of the given number.
 * @param num: integer
 * @details Factorial of n = n * (n - 1) * (n - 2) * ... * 1
 * @returns integer: Factorial of the number.
            NaN: if negative number is provided.
 */
const factorial = (n) => {
  if (n >= 0) {
    if (n === 0) {
      return 1
    } else {
      return n * factorial(n - 1)
    }
  } else {
    return NaN
  }
}

/**
 * @brief Calculates the number of Permutations from the given data.
 * @param
 * n: integer -> number of items.
 * r: integer -> number of times n is taken.
 * @returns integer: The number of permutations.
            NaN: if negative number is provided.
 */
const permutation = (n, r) => {
  return factorial(n) / factorial(n - r)
}

/**
 * @brief Calculates the number of Combinations from the given data.
 * @param
 * n -> number of items.
 * r -> number of times n is taken.
 * @returns integer: The number of combinations.
            NaN: if negative number is provided.
 */
const combination = (n, r) => {
  return factorial(n) / (factorial(r) * factorial(n - r))
}

// Exports the functions to be used in other files.
export { factorial, permutation, combination }
/**
 *
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 * Returns the number of digits of a given integer
 *
 */

const numberOfDigit = (n) => Math.abs(n).toString().length

export { numberOfDigit }
/**
 * Problem statement and explanation: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
 *
 * This algorithm plays an important role for modular arithmetic, and by extension for cyptography algorithms
 *
 * Basic explanation:
 * The Extended Euclidean algorithm is a modification of the standard Euclidean GCD algorithm.
 * It allows to calculate coefficients x and y for the equation:
 *          ax + by = gcd(a,b)
 *
 * This is called Bzout's identity and the coefficients are called Bzout coefficients
 *
 * The algorithm uses the Euclidean method of getting remainder:
 * r_i+1 = r_i-1 - qi*ri
 * and applies it to series s and t (with same quotient q at each stage)
 * When r_n reaches 0, the value r_n-1 gives the gcd, and s_n-1 and t_n-1 give the coefficients
 *
 * This implementation uses an iterative approach to calculate the values
 */

/**
 *
 * @param {Number} arg1 first argument
 * @param {Number} arg2 second argument
 * @returns Array with GCD and first and second Bzout coefficients
 */
const extendedEuclideanGCD = (arg1, arg2) => {
  if (typeof arg1 !== 'number' || typeof arg2 !== 'number') throw new TypeError('Not a Number')
  if (arg1 < 1 || arg2 < 1) throw new TypeError('Must be positive numbers')

  // Make the order of coefficients correct, as the algorithm assumes r0 > r1
  if (arg1 < arg2) {
    const res = extendedEuclideanGCD(arg2, arg1)
    const temp = res[1]
    res[1] = res[2]
    res[2] = temp
    return res
  }

  // At this point arg1 > arg2

  // Remainder values
  let r0 = arg1
  let r1 = arg2

  // Coefficient1 values
  let s0 = 1
  let s1 = 0

  // Coefficient 2 values
  let t0 = 0
  let t1 = 1

  while (r1 !== 0) {
    const q = Math.floor(r0 / r1)

    const r2 = r0 - r1 * q
    const s2 = s0 - s1 * q
    const t2 = t0 - t1 * q

    r0 = r1
    r1 = r2
    s0 = s1
    s1 = s2
    t0 = t1
    t1 = t2
  }
  return [r0, s0, t0]
}

export { extendedEuclideanGCD }
/*
  A program to calculate the Aliquot Sum of a number.
  The aliquot sum of a number n, is the sum of all the proper divisors of n apart from n itself
  For example, for the number 6
  The divisors are 1, 2, 3 (we don't consider 6), so its aliquot sum is 1 + 2 + 3 = 6
  1 is the only number whose aliquot sum is 0 (since its only divisor is 1 and aliquot sum of a number couldn't have itself)
  For all prime numbers, the aliquot sum is 1, since their only divisor apart from themselves is 1
  Article on Aliquot Sum: https://en.wikipedia.org/wiki/Aliquot_sum
 */

/**
 * @param {Number} input The number whose aliquot sum you want to calculate
 */
function aliquotSum (input) {
  // input can't be negative
  if (input < 0) throw new TypeError('Input cannot be Negative')

  // input can't be a decimal
  if (Math.floor(input) !== input) throw new TypeError('Input cannot be a Decimal')

  // Dealing with 1, which isn't a prime
  if (input === 1) return 0

  let sum = 0
  for (let i = 1; i <= (input / 2); i++) {
    if (input % i === 0) sum += i
  }

  return sum
}

export { aliquotSum }
import { PrimeCheck } from './PrimeCheck'

/**
 * @function twinPrime
 * Gets the 'twin prime' of a prime number.
 *
 * @param {Integer} n The number to find the twin prime of.
 * @returns {Integer} Either the twin, or -1 if n or n + 2 is not prime.
 *
 * @see https://en.wikipedia.org/wiki/Twin_prime
 *
 * @example twinPrime(5) = 7
 * @example twinPrime(4) = -1
*/
function twinPrime (n) {
  const prime = PrimeCheck(n)

  if (!prime) {
    return -1
  }

  if (!PrimeCheck(n + 2)) {
    return -1
  }

  return n + 2
}

export { twinPrime }
/**
 * In mathematics and computational science, the Euler method (also called forward Euler method) is a first-order
 * numerical procedure for solving ordinary differential equations (ODEs) with a given initial value. It is the most
 * basic explicit method for numerical integration of ordinary differential equations. The method proceeds in a series
 * of steps. At each step the y-value is calculated by evaluating the differential equation at the previous step,
 * multiplying the result with the step-size and adding it to the last y-value: y_n+1 = y_n + stepSize * f(x_n, y_n).
 *
 * (description adapted from https://en.wikipedia.org/wiki/Euler_method)
 * @see https://www.geeksforgeeks.org/euler-method-solving-differential-equation/
 */
export function eulerStep (xCurrent, stepSize, yCurrent, differentialEquation) {
  // calculates the next y-value based on the current value of x, y and the stepSize
  return yCurrent + stepSize * differentialEquation(xCurrent, yCurrent)
}

export function eulerFull (xStart, xEnd, stepSize, yStart, differentialEquation) {
  // loops through all the steps until xEnd is reached, adds a point for each step and then returns all the points
  const points = [{ x: xStart, y: yStart }]
  let yCurrent = yStart
  let xCurrent = xStart

  while (xCurrent < xEnd) {
    // Euler method for next step
    yCurrent = eulerStep(xCurrent, stepSize, yCurrent, differentialEquation)
    xCurrent += stepSize
    points.push({ x: xCurrent, y: yCurrent })
  }

  return points
}
/*
    author: redfly1
    More about HCF:
        https://en.wikipedia.org/wiki/Greatest_common_divisor
 */

const findHCF = (x, y) => {
  // If the input numbers are less than 1 return an error message.
  if (x < 1 || y < 1) {
    return 'Please enter values greater than zero.'
  }

  // If the input numbers are not integers return an error message.
  if (x !== Math.round(x) || y !== Math.round(y)) {
    return 'Please enter whole numbers.'
  }

  // Now apply Euclid's algorithm to the two numbers.
  while (Math.max(x, y) % Math.min(x, y) !== 0) {
    if (x > y) {
      x %= y
    } else {
      y %= x
    }
  }

  // When the while loop finishes the minimum of x and y is the HCF.
  return Math.min(x, y)
}

export { findHCF }
// Checks if a number is divisible by another number.

export const isDivisible = (num1, num2) => {
  if (!Number.isFinite(num1) || !Number.isFinite(num2)) {
    throw new TypeError('Expected a number')
  }
  if (num2 === 0) {
    return false
  }
  return num1 % num2 === 0
}

// isDivisible(10, 5) // returns true
// isDivisible(123498175, 5) // returns true
// isDivisible(99, 5) // returns false
/*
    author: Theepag, optimised by merelymyself
 */
export const factorialize = (num) => {
  // Step 1. Handles cases where num is 0 or 1, by returning 1.
  let result = 1
  // Step 2. WHILE loop
  while (num > 1) {
    result *= num // or result = result * num;
    num-- // decrement 1 at each iteration
  }
  // Step 3. Return the factorial
  return result
}
/**
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 * == Perfect Number ==
 * In number theory, a perfect number is a positive integer that is equal to the sum of
 * its positive divisors(factors), excluding the number itself.
 * For example: 6 ==> divisors[1, 2, 3, 6]
 *      Excluding 6, the sum(divisors) is 1 + 2 + 3 = 6
 *      So, 6 is a Perfect Number
 * Other examples of Perfect Numbers: 28, 486, ...
 *
 * More on Perfect Number:
 *      https://en.wikipedia.org/wiki/Perfect_number
 *
 */

const factorsExcludingNumber = (n) => {
  return [...Array(n).keys()].filter((num) => n % num === 0)
}

const perfectNumber = (n) => {
  const factorSum = factorsExcludingNumber(n).reduce((num, initialValue) => {
    return num + initialValue
  }, 0)

  return factorSum === n
}

export { perfectNumber }
const list = []

const FibonacciIterative = (nth) => {
  const sequence = []

  if (nth >= 1) sequence.push(1)
  if (nth >= 2) sequence.push(1)

  for (let i = 2; i < nth; i++) {
    sequence.push(sequence[i - 1] + sequence[i - 2])
  }

  return sequence
}

const FibonacciRecursive = (number) => {
  return (() => {
    switch (list.length) {
      case 0:
        list.push(1)
        return FibonacciRecursive(number)
      case 1:
        list.push(1)
        return FibonacciRecursive(number)
      case number:
        return list
      default:
        list.push(list[list.length - 1] + list[list.length - 2])
        return FibonacciRecursive(number)
    }
  })()
}

const dict = new Map()

const FibonacciRecursiveDP = (stairs) => {
  if (stairs <= 0) return 0
  if (stairs === 1) return 1

  // Memoize stair count
  if (dict.has(stairs)) return dict.get(stairs)

  const res =
    FibonacciRecursiveDP(stairs - 1) + FibonacciRecursiveDP(stairs - 2)

  dict.set(stairs, res)

  return res
}

// Algorithms
// Calculates Fibonacci(n) such that Fibonacci(n) = Fibonacci(n - 1) + Fibonacci(n - 2)
// Fibonacci(0) = Fibonacci(1) = 1
// Uses a bottom up dynamic programming approach
// Solve each sub-problem once, using results of previous sub-problems
// which are n-1 and n-2 for Fibonacci numbers
// Although this algorithm is linear in space and time as a function
// of the input value n, it is exponential in the size of n as
// a function of the number of input bits
// @Satzyakiz

const FibonacciDpWithoutRecursion = (number) => {
  const table = []
  table.push(1)
  table.push(1)
  for (let i = 2; i < number; ++i) {
    table.push(table[i - 1] + table[i - 2])
  }
  return table
}

// Using Matrix exponentiation to find n-th fibonacci in O(log n) time

const copyMatrix = (A) => {
  return A.map(row => row.map(cell => cell))
}

const Identity = (size) => {
  const I = Array(size).fill(null).map(() => Array(size).fill())
  return I.map((row, rowIdx) => row.map((_col, colIdx) => {
    return rowIdx === colIdx ? 1 : 0
  }))
}

// A of size (l x m) and B of size (m x n)
// product C will be of size (l x n)
const matrixMultiply = (A, B) => {
  A = copyMatrix(A)
  B = copyMatrix(B)
  const l = A.length
  const m = B.length
  const n = B[0].length // Assuming non-empty matrices
  const C = Array(l).fill(null).map(() => Array(n).fill())
  for (let i = 0; i < l; i++) {
    for (let j = 0; j < n; j++) {
      C[i][j] = 0
      for (let k = 0; k < m; k++) {
        C[i][j] += A[i][k] * B[k][j]
      }
    }
  }
  return C
}

/**
 * Computes A raised to the power n i.e. pow(A, n) where A is a square matrix
 * @param {*} A the square matrix
 * @param {*} n the exponent
 */
// A is a square matrix
const matrixExpo = (A, n) => {
  A = copyMatrix(A)

  // Just like Binary exponentiation mentioned in ./BinaryExponentiationIterative.js
  let result = Identity(A.length) // Identity matrix
  while (n > 0) {
    if (n % 2 !== 0) result = matrixMultiply(result, A)
    n = Math.floor(n / 2)
    if (n > 0) A = matrixMultiply(A, A)
  }
  return result
}

const FibonacciMatrixExpo = (n) => {
  // F(0) = 0, F(1) = 1
  // F(n) = F(n-1) + F(n-2)
  // Consider below matrix multiplication:

  // | F(n) |   |1  1|   |F(n-1)|
  // |      | = |    | * |      |
  // |F(n-1)|   |1  0|   |F(n-2)|

  // Let's rewrite it as F(n, n-1) = A * F(n-1, n-2)
  // or                  F(n, n-1) = A * A * F(n-2, n-3)
  // or                  F(n, n-1) = pow(A, n-1) * F(1, 0)

  if (n === 0) return 0

  const A = [
    [1, 1],
    [1, 0]
  ]
  const poweredA = matrixExpo(A, n - 1) // A raised to the power n-1
  let F = [
    [1],
    [0]
  ]
  F = matrixMultiply(poweredA, F)
  return F[0][0]
}

export { FibonacciDpWithoutRecursion }
export { FibonacciIterative }
export { FibonacciRecursive }
export { FibonacciRecursiveDP }
export { FibonacciMatrixExpo }
// Wikipedia: https://en.wikipedia.org/wiki/Softmax_function

const Softmax = (inputs) => {
  const eulerExpOfAllInputs = inputs.map(input => Math.exp(input))
  const sumOfEulerExpOfAllInputs = eulerExpOfAllInputs.reduce((a, b) => a + b)

  return inputs.map((input) => {
    const eulerExpInputs = Math.exp(input)
    return eulerExpInputs / sumOfEulerExpOfAllInputs
  })
}

export { Softmax }
// Zeller's Congruence Algorithm finds the day of the week from the Gregorian Date. Wikipedia: https://en.wikipedia.org/wiki/Zeller%27s_congruence
export const zellersCongruenceAlgorithm = (day, month, year) => {
  if (typeof day !== 'number' || typeof month !== 'number' || typeof year !== 'number') {
    throw new TypeError('Arguments are not all numbers.')
  }
  const q = day
  let m = month
  let y = year
  if (month < 3) {
    m += 12
    y -= 1
  }
  day =
      (q + Math.floor(26 * (m + 1) / 10) + (y % 100) + Math.floor((y % 100) / 4) + Math.floor(Math.floor(y / 100) / 4) + (5 * Math.floor(y / 100))) %
          7
  const days = [
    'Saturday',
    'Sunday',
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday'
  ]
  return days[day]
}
/**
 * Polynomials are algebraic expressions consisting of two or more algebraic terms.
 * Terms of a polynomial are:
 * 1. Coefficients e.g. 5, 4 in 5x^0, 4x^3 respectively
 * 2. Variables e.g. y in 3y^2
 * 3. Exponents e.g. 5 in y^5
 *
 * Class Polynomial constructs the polynomial using Array as an argument.
 * The members of array are coefficients and their indexes as exponents.
 */
class Polynomial {
  constructor (array) {
    this.coefficientArray = array // array of coefficients
    this.polynomial = '' // in terms of x e.g. (2x) + (1)
    this.construct()
  }

  /**
   * Function to construct the polynomial in terms of x using the coefficientArray
   */
  construct () {
    this.polynomial = this.coefficientArray
      .map((coefficient, exponent) => {
        if (coefficient === 0) {
          return '0'
        }
        if (exponent === 0) {
          return `(${coefficient})`
        } else if (exponent === 1) {
          return `(${coefficient}x)`
        } else {
          return `(${coefficient}x^${exponent})`
        }
      })
      .filter((x) =>
        x !== '0'
      )
      .reverse()
      .join(' + ')
  }

  /**
   * Function to display polynomial in terms of x
   * @returns {String} of polynomial representation in terms of x
   */
  display () {
    return this.polynomial
  }

  /**
   * Function to calculate the value of the polynomial by substituting variable x
   * @param {Number} value
   */
  evaluate (value) {
    return this.coefficientArray.reduce((result, coefficient, exponent) => {
      return result + coefficient * Math.pow(value, exponent)
    }, 0)
  }
}

export { Polynomial }
/*
  Calculate the area of various shapes
*/

/**
 * @function surfaceAreaCube
 * @description Calculate the Surface Area of a Cube.
 * @param {Integer} side - Integer
 * @return {Integer} - 6 * side ** 2
 * @see [surfaceAreaCube](https://en.wikipedia.org/wiki/Area#Surface_area)
 * @example surfaceAreaCube(1) = 6
 */
const surfaceAreaCube = (side) => {
  validateNumericParam(side, 'side')
  return 6 * side ** 2
}

/**
 * @function surfaceAreaSphere
 * @description Calculate the Surface Area of a Sphere.
 * @param {Integer} radius - Integer
 * @return {Integer} - 4 * pi * r^2
 * @see [surfaceAreaSphere](https://en.wikipedia.org/wiki/Sphere)
 * @example surfaceAreaSphere(5) = 314.1592653589793
 */
const surfaceAreaSphere = (radius) => {
  validateNumericParam(radius, 'radius')
  return 4.0 * Math.PI * radius ** 2.0
}

/**
 * @function areaRectangle
 * @description Calculate the area of a rectangle.
 * @param {Integer} length - Integer
 * @param {Integer} width - Integer
 * @return {Integer} - width * length
 * @see [areaRectangle](https://en.wikipedia.org/wiki/Area#Quadrilateral_area)
 * @example areaRectangle(4) = 16
 */
const areaRectangle = (length, width) => {
  validateNumericParam(length, 'Length')
  validateNumericParam(width, 'Width')
  return width * length
}

/**
 * @function areaSquare
 * @description Calculate the area of a square.
 * @param {Integer} side - Integer
 * @return {Integer} - side ** 2.
 * @see [areaSquare](https://en.wikipedia.org/wiki/Square)
 * @example areaSquare(4) = 16
 */
const areaSquare = (side) => {
  validateNumericParam(side, 'square side')
  return side ** 2
}

/**
 * @function areaTriangle
 * @description Calculate the area of a triangle.
 * @param {Integer} base - Integer
 * @param {Integer} height - Integer
 * @return {Integer} - base * height / 2.
 * @see [areaTriangle](https://en.wikipedia.org/wiki/Area#Triangle_area)
 * @example areaTriangle(1.66, 3.44) = 2.8552
 */
const areaTriangle = (base, height) => {
  validateNumericParam(base, 'Base')
  validateNumericParam(height, 'Height')
  return (base * height) / 2.0
}

/**
 * @function areaTriangleWithAllThreeSides
 * @description Calculate the area of a triangle with the all three sides given.
 * @param {Integer} side1 - Integer
 * @param {Integer} side2 - Integer
 * @param {Integer} side3 - Integer
 * @return {Integer} - area of triangle.
 * @see [areaTriangleWithAllThreeSides](https://en.wikipedia.org/wiki/Heron%27s_formula)
 * @example areaTriangleWithAllThreeSides(5, 6, 7) = 14.7
 */
const areaTriangleWithAllThreeSides = (side1, side2, side3) => {
  validateNumericParam(side1, 'side1')
  validateNumericParam(side2, 'side2')
  validateNumericParam(side3, 'side3')
  if (
    side1 + side2 <= side3 ||
    side1 + side3 <= side2 ||
    side2 + side3 <= side1
  ) {
    throw new TypeError('Invalid Triangle sides.')
  }
  // Finding Semi perimeter of the triangle using formula
  const semi = (side1 + side2 + side3) / 2

  // Calculating the area of the triangle
  const area = Math.sqrt(
    semi * (semi - side1) * (semi - side2) * (semi - side3)
  )
  return Number(area.toFixed(2))
}

/**
 * @function areaParallelogram
 * @description Calculate the area of a parallelogram.
 * @param {Integer} base - Integer
 * @param {Integer} height - Integer
 * @return {Integer} - base * height
 * @see [areaParallelogram](https://en.wikipedia.org/wiki/Area#Dissection,_parallelograms,_and_triangles)
 * @example areaParallelogram(5, 6) = 24
 */
const areaParallelogram = (base, height) => {
  validateNumericParam(base, 'Base')
  validateNumericParam(height, 'Height')
  return base * height
}

/**
 * @function areaTrapezium
 * @description Calculate the area of a trapezium.
 * @param {Integer} base1 - Integer
 * @param {Integer} base2 - Integer
 * @param {Integer} height - Integer
 * @return {Integer} - (1 / 2) * (base1 + base2) * height
 * @see [areaTrapezium](https://en.wikipedia.org/wiki/Trapezoid)
 * @example areaTrapezium(5, 12, 10) = 85
 */
const areaTrapezium = (base1, base2, height) => {
  validateNumericParam(base1, 'Base One')
  validateNumericParam(base2, 'Base Two')
  validateNumericParam(height, 'Height')
  return (1 / 2) * (base1 + base2) * height
}

/**
 * @function areaCircle
 * @description Calculate the area of a circle.
 * @param {Integer} radius - Integer
 * @return {Integer} - Math.PI * radius ** 2
 * @see [areaCircle](https://en.wikipedia.org/wiki/Area_of_a_circle)
 * @example areaCircle(5, 12, 10) = 85
 */
const areaCircle = (radius) => {
  validateNumericParam(radius, 'Radius')
  return Math.PI * radius ** 2
}

/**
 * @function areaRhombus
 * @description Calculate the area of a rhombus.
 * @param {Integer} diagonal1 - Integer
 * @param {Integer} diagonal2 - Integer
 * @return {Integer} - (1 / 2) * diagonal1 * diagonal2
 * @see [areaRhombus](https://en.wikipedia.org/wiki/Rhombus)
 * @example areaRhombus(12, 10) = 60
 */
const areaRhombus = (diagonal1, diagonal2) => {
  validateNumericParam(diagonal1, 'diagonal one')
  validateNumericParam(diagonal2, 'diagonal two')
  return (1 / 2) * diagonal1 * diagonal2
}

const validateNumericParam = (param, paramName = 'param') => {
  if (typeof param !== 'number') {
    throw new TypeError('The ' + paramName + ' should be type Number')
  } else if (param < 0) {
    throw new Error('The ' + paramName + ' only accepts non-negative values')
  }
}

export {
  surfaceAreaCube,
  surfaceAreaSphere,
  areaRectangle,
  areaSquare,
  areaTriangle,
  areaParallelogram,
  areaTrapezium,
  areaCircle,
  areaRhombus,
  areaTriangleWithAllThreeSides
}
// Wikipedia: https://en.wikipedia.org/wiki/Mean_squared_error

const meanSquaredError = (predicted, expected) => {
  if (!Array.isArray(predicted) || !Array.isArray(expected)) {
    throw new TypeError('Argument must be an Array')
  }

  if (predicted.length !== expected.length) {
    throw new TypeError('The two lists must be of equal length')
  }

  let err = 0

  for (let i = 0; i < expected.length; i++) {
    err += (expected[i] - predicted[i]) ** 2
  }

  return err / expected.length
}

export { meanSquaredError }
/*
  Modified from:
    https://github.com/TheAlgorithms/Python/blob/master/maths/prime_factors.py
*/

export const PrimeFactors = (n) => {
  // input: n: int
  // output: primeFactors: Array of all prime factors of n
  const primeFactors = []
  for (let i = 2; i * i <= n; i++) {
    while (n % i === 0) {
      primeFactors.push(i)
      n = Math.floor(n / i)
    }
  }
  if (n > 1) {
    primeFactors.push(n)
  }
  return primeFactors
}
/**
 * @author Eric Lavault <https://github.com/lvlte>
 *
 * Represents the decimal (or binary, octal, any base from 2 to 10) expansion
 * of a/b using euclidean division.
 *
 * Because this function is recursive, it may throw an error when reaching the
 * maximum call stack size.
 *
 * Returns an array containing : [
 *  0: integer part of the division
 *  1: array of decimals (if any, or an empty array)
 *  2: indexOf 1st cycle digit in decimals array if a/b is periodic, or undef.
 * ]
 *
 * @see https://mathworld.wolfram.com/DecimalExpansion.html
 *
 * @param {number} a
 * @param {number} b
 * @param {number} [base=10]
 * @returns {array}
 */
export function decExp (a, b, base = 10, exp = [], d = {}, dlen = 0) {
  if (base < 2 || base > 10) {
    throw new RangeError('Unsupported base. Must be in range [2, 10]')
  }

  if (a === 0) {
    return [0, [], undefined]
  }

  if (a === b && dlen === 0) {
    return [1, [], undefined]
  }

  // d contains the dividends used so far and the corresponding index of its
  // euclidean division by b in the expansion array.
  d[a] = dlen++

  if (a < b) {
    exp.push(0)
    return decExp(a * base, b, base, exp, d, dlen)
  }

  // Euclid's division lemma : a = bq + r
  const r = a % b
  const q = (a - r) / b

  // Decimal expansion (1st element is the integer part)
  exp.push(+q.toString(base))

  if (r === 0) {
    // got a regular number (division terminates)
    return [exp[0], exp.slice(1), undefined]
  }

  // For the next iteration
  a = r * base

  // Check if `a` has already been used as a dividend, in which case it means
  // the expansion is periodic.
  if (a in d) {
    return [exp[0], exp.slice(1), d[a] - 1]
  }

  return decExp(a, b, base, exp, d, dlen)
}
const LinearSieve = (n) => {
  /*
   * Calculates prime numbers till a number n
   * Time Complexity: O(n)
   * Explanation: https://cp-algorithms.com/algebra/prime-sieve-linear.html
   * :param n: Number up to which to calculate primes
   * :return: A list containing only primes
   */
  const isnPrime = new Array(n + 1)
  isnPrime[0] = isnPrime[1] = true
  const primes = []
  for (let i = 2; i <= n; i++) {
    if (!isnPrime[i]) primes.push(i)
    for (const p of primes) {
      const k = i * p
      if (k > n) break
      isnPrime[k] = true
      if (i % p === 0) break
    }
  }
  return primes
}

export { LinearSieve }
/**
 * Method to generate the image of the Mandelbrot set.
 *
 * Two types of coordinates are used: image-coordinates that refer to the pixels and figure-coordinates that refer to
 * the complex numbers inside and outside the Mandelbrot set. The figure-coordinates in the arguments of this method
 * determine which section of the Mandelbrot set is viewed. The main area of the Mandelbrot set is roughly between
 * "-1.5 < x < 0.5" and "-1 < y < 1" in the figure-coordinates.
 *
 * The Mandelbrot set is the set of complex numbers "c" for which the series "z_(n+1) = z_n * z_n + c" does not diverge,
 * i.e. remains bounded. Thus, a complex number "c" is a member of the Mandelbrot set if, when starting with "z_0 = 0"
 * and applying the iteration repeatedly, the absolute value of "z_n" remains bounded for all "n > 0". Complex numbers
 * can be written as "a + b*i": "a" is the real component, usually drawn on the x-axis, and "b*i" is the imaginary
 * component, usually drawn on the y-axis. Most visualizations of the Mandelbrot set use a color-coding to indicate
 * after how many steps in the series the numbers outside the set cross the divergence threshold. Images of the
 * Mandelbrot set exhibit an elaborate and infinitely complicated boundary that reveals progressively ever-finer
 * recursive detail at increasing magnifications, making the boundary of the Mandelbrot set a fractal curve.
 *
 * (description adapted from https://en.wikipedia.org/wiki/Mandelbrot_set)
 * @see https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set
 *
 * @param {number} imageWidth The width of the rendered image.
 * @param {number} imageHeight The height of the rendered image.
 * @param {number} figureCenterX The x-coordinate of the center of the figure.
 * @param {number} figureCenterY The y-coordinate of the center of the figure.
 * @param {number} figureWidth The width of the figure.
 * @param {number} maxStep Maximum number of steps to check for divergent behavior.
 * @param {boolean} useDistanceColorCoding Render in color or black and white.
 * @return {object} The RGB-data of the rendered Mandelbrot set.
 */
export function getRGBData (
  imageWidth = 800,
  imageHeight = 600,
  figureCenterX = -0.6,
  figureCenterY = 0,
  figureWidth = 3.2,
  maxStep = 50,
  useDistanceColorCoding = true) {
  if (imageWidth <= 0) {
    throw new Error('imageWidth should be greater than zero')
  }

  if (imageHeight <= 0) {
    throw new Error('imageHeight should be greater than zero')
  }

  if (maxStep <= 0) {
    throw new Error('maxStep should be greater than zero')
  }

  const rgbData = []
  const figureHeight = figureWidth / imageWidth * imageHeight

  // loop through the image-coordinates
  for (let imageX = 0; imageX < imageWidth; imageX++) {
    rgbData[imageX] = []
    for (let imageY = 0; imageY < imageHeight; imageY++) {
      // determine the figure-coordinates based on the image-coordinates
      const figureX = figureCenterX + (imageX / imageWidth - 0.5) * figureWidth
      const figureY = figureCenterY + (imageY / imageHeight - 0.5) * figureHeight

      const distance = getDistance(figureX, figureY, maxStep)

      // color the corresponding pixel based on the selected coloring-function
      rgbData[imageX][imageY] =
        useDistanceColorCoding
          ? colorCodedColorMap(distance)
          : blackAndWhiteColorMap(distance)
    }
  }

  return rgbData
}

/**
 * Black and white color-coding that ignores the relative distance.
 *
 * The Mandelbrot set is black, everything else is white.
 *
 * @param {number} distance Distance until divergence threshold
 * @return {object} The RGB-value corresponding to the distance.
 */
function blackAndWhiteColorMap (distance) {
  return distance >= 1 ? [0, 0, 0] : [255, 255, 255]
}

/**
 * Color-coding taking the relative distance into account.
 *
 * The Mandelbrot set is black.
 *
 * @param {number} distance Distance until divergence threshold
 * @return {object} The RGB-value corresponding to the distance.
 */
function colorCodedColorMap (distance) {
  if (distance >= 1) {
    return [0, 0, 0]
  } else {
    // simplified transformation of HSV to RGB
    // distance determines hue
    const hue = 360 * distance
    const saturation = 1
    const val = 255
    const hi = (Math.floor(hue / 60)) % 6
    const f = hue / 60 - Math.floor(hue / 60)

    const v = val
    const p = 0
    const q = Math.floor(val * (1 - f * saturation))
    const t = Math.floor(val * (1 - (1 - f) * saturation))

    switch (hi) {
      case 0:
        return [v, t, p]
      case 1:
        return [q, v, p]
      case 2:
        return [p, v, t]
      case 3:
        return [p, q, v]
      case 4:
        return [t, p, v]
      default:
        return [v, p, q]
    }
  }
}

/**
 * Return the relative distance (ratio of steps taken to maxStep) after which the complex number
 * constituted by this x-y-pair diverges.
 *
 * Members of the Mandelbrot set do not diverge so their distance is 1.
 *
 * @param {number} figureX The x-coordinate within the figure.
 * @param {number} figureY The y-coordinate within the figure.
 * @param {number} maxStep Maximum number of steps to check for divergent behavior.
 * @return {number} The relative distance as the ratio of steps taken to maxStep.
 */
function getDistance (figureX, figureY, maxStep) {
  let a = figureX
  let b = figureY
  let currentStep = 0
  for (let step = 0; step < maxStep; step++) {
    currentStep = step
    const aNew = a * a - b * b + figureX
    b = 2 * a * b + figureY
    a = aNew

    // divergence happens for all complex number with an absolute value
    // greater than 4 (= divergence threshold)
    if (a * a + b * b > 4) {
      break
    }
  }
  return currentStep / (maxStep - 1)
}
/*
 * The Fermat primality test is a probabilistic test to determine whether a number
 * is a probable prime.
 *
 * It relies on Fermat's Little Theorem, which states that if p is prime and a
 * is not divisible by p, then
 *
 *     a^(p - 1) % p = 1
 *
 * However, there are certain numbers (so called Fermat Liars) that screw things up;
 * if a is one of these liars the equation will hold even though p is composite.
 *
 * But not everything is lost! It's been proven that at least half of all integers
 * aren't Fermat Liars (these ones called Fermat Witnesses). Thus, if we keep
 * testing the primality with random integers, we can achieve higher reliability.
 *
 * The interesting about all of this is that since half of all integers are
 * Fermat Witnesses, the precision gets really high really fast! Suppose that we
 *  make the test 50 times: the chance of getting only Fermat Liars in all runs is
 *
 *     1 / 2^50 = 8.8 * 10^-16 (a pretty small number)
 *
 * For comparison, the probability of a cosmic ray causing an error to your
 * infalible program is around 1.4 * 10^-15. An order of magnitude below!
 *
 * But because nothing is perfect, there's a major flaw to this algorithm, and
 * the cause are the so called Carmichael Numbers. These are composite numbers n
 * that hold the equality from Fermat's Little Theorem for every a < n (excluding
 * is factors). In other words, if we are trying to determine if a Carmichael Number
 * is prime or not, the chances of getting a wrong answer are pretty high! Because
 * of that, the Fermat Primality Test is not used is serious applications. :(
 *
 * You can find more about the Fermat primality test and its flaws here:
 * https://en.wikipedia.org/wiki/Fermat_primality_test
 *
 * And about Carmichael Numbers here:
 * https://primes.utm.edu/glossary/xpage/CarmichaelNumber.html
 */

/**
 * Faster exponentiation that capitalize on the fact that we are only interested
 * in the modulus of the exponentiation.
 *
 * Find out more about it here: https://en.wikipedia.org/wiki/Modular_exponentiation
 *
 * @param {number} base
 * @param {number} exponent
 * @param {number} modulus
 */
const modularExponentiation = (base, exponent, modulus) => {
  if (modulus === 1) return 0 // after all, any x % 1 = 0

  let result = 1
  base %= modulus // make sure that base < modulus

  while (exponent > 0) {
    // if exponent is odd, multiply the result by the base
    if (exponent % 2 === 1) {
      result = (result * base) % modulus
      exponent--
    } else {
      exponent = exponent / 2 // exponent is even for sure
      base = (base * base) % modulus
    }
  }

  return result
}

/**
 * Test if a given number n is prime or not.
 *
 * @param {number} n The number to check for primality
 * @param {number} numberOfIterations The number of times to apply Fermat's Little Theorem
 * @returns True if prime, false otherwise
 */
const fermatPrimeCheck = (n, numberOfIterations = 50) => {
  // first check for edge cases
  if (n <= 1 || n === 4) return false
  if (n <= 3) return true // 2 and 3 are included here

  for (let i = 0; i < numberOfIterations; i++) {
    // pick a random number a, with 2 <= a < n - 2
    const randomNumber = Math.floor(Math.random() * (n - 2) + 2)

    // if a^(n - 1) % n is different than 1, n is composite
    if (modularExponentiation(randomNumber, n - 1, n) !== 1) {
      return false
    }
  }

  // if we arrived here without finding a Fermat Witness, this is almost guaranteed
  // to be a prime number (or a Carmichael number, if you are unlucky)
  return true
}

export { modularExponentiation, fermatPrimeCheck }
/*
Calculate the volume of the shapes

Volume for Cuboid
Volume for Cube
Volume for Cone
Volume for Pyramid
Volume for Cylinder
Volume for Triangular Prism
Volume for Pentagonal Prism
Volume for Sphere
Volume for Hemisphere
*/

/*
  Calculate the volume for a Cuboid
  Reference: https://www.cuemath.com/measurement/volume-of-cuboid/
  return width * length * height
*/
const volCuboid = (width, length, height) => {
  isNumber(width, 'Width')
  isNumber(length, 'Length')
  isNumber(height, 'Height')
  return (width * length * height)
}

/*
  Calculate the volume for a Cube
  Reference: https://www.cuemath.com/measurement/volume-of-cube/
  return length * length * length
*/
const volCube = (length) => {
  isNumber(length, 'Length')
  return (length ** 3)
}

/*
  Calculate the volume for a Cone
  Reference: https://www.cuemath.com/measurement/volume-of-cone/
  return PI * radius^2 * height/3
*/
const volCone = (radius, height) => {
  isNumber(radius, 'Radius')
  isNumber(height, 'Height')
  return (Math.PI * radius ** 2 * height / 3.0)
}

/*
  Calculate the volume for a Pyramid
  Reference: https://www.cuemath.com/measurement/volume-of-pyramid/
  return (baseLength * baseWidth * height) / 3
*/
const volPyramid = (baseLength, baseWidth, height) => {
  isNumber(baseLength, 'BaseLength')
  isNumber(baseWidth, 'BaseWidth')
  isNumber(height, 'Height')
  return (baseLength * baseWidth * height) / 3.0
}

/*
  Calculate the volume for a Cylinder
  Reference: https://www.cuemath.com/measurement/volume-of-cylinder/
  return PI * radius^2 * height
*/
const volCylinder = (radius, height) => {
  isNumber(radius, 'Radius')
  isNumber(height, 'Height')
  return (Math.PI * radius ** 2 * height)
}

/*
  Calculate the volume for a Triangular Prism
  Reference: http://lrd.kangan.edu.au/numbers/content/03_volume/04_page.htm
  return 1 / 2 * baseLengthTriangle * heightTriangle * height
*/
const volTriangularPrism = (baseLengthTriangle, heightTriangle, height) => {
  isNumber(baseLengthTriangle, 'BaseLengthTriangle')
  isNumber(heightTriangle, 'HeightTriangle')
  isNumber(height, 'Height')
  return (1 / 2 * baseLengthTriangle * heightTriangle * height)
}

/*
  Calculate the volume for a Pentagonal Prism
  Reference: https://www.cuemath.com/measurement/volume-of-pentagonal-prism/
  return 5/2 * pentagonalLength * pentagonalBaseLength * height
*/
const volPentagonalPrism = (pentagonalLength, pentagonalBaseLength, height) => {
  isNumber(pentagonalLength, 'PentagonalLength')
  isNumber(pentagonalBaseLength, 'PentagonalBaseLength')
  isNumber(height, 'Height')
  return (5 / 2 * pentagonalLength * pentagonalBaseLength * height)
}

/*
  Calculate the volume for a Sphere
  Reference: https://www.cuemath.com/measurement/volume-of-sphere/
  return 4/3 * PI * radius^3
*/
const volSphere = (radius) => {
  isNumber(radius, 'Radius')
  return (4 / 3 * Math.PI * radius ** 3)
}

/*
  Calculate the volume for a Hemisphere
  Reference: https://www.cuemath.com/measurement/volume-of-hemisphere/
  return (2 * PI * radius^3)/3
*/
const volHemisphere = (radius) => {
  isNumber(radius, 'Radius')
  return (2.0 * Math.PI * radius ** 3) / 3.0
}

const isNumber = (number, noName = 'number') => {
  if (typeof number !== 'number') {
    throw new TypeError('The ' + noName + ' should be Number type')
  } else if (number < 0 || (!Number.isFinite(number))) {
    throw new Error('The ' + noName + ' only accepts positive values')
  }
}

export { volCuboid, volCube, volCone, volPyramid, volCylinder, volTriangularPrism, volPentagonalPrism, volSphere, volHemisphere }
// To calculate x^n i.e. exponent(x, n) in O(log n) time in iterative way
// n is an integer and n >= 0

// Explanation: https://en.wikipedia.org/wiki/Exponentiation_by_squaring

// Examples:
// 2^3 = 8
// 5^0 = 1

// Uses the fact that
// exponent(x, n)
//          = exponent(x*x, floor(n/2))   ; if n is odd
//          = x*exponent(x*x, floor(n/2)) ; if n is even
const exponent = (x, n) => {
  let answer = 1
  while (n > 0) {
    if (n % 2 !== 0) answer *= x
    n = Math.floor(n / 2)
    if (n > 0) x *= x
  }
  return answer
}

export { exponent }
import { isEven } from './IsEven'

/**
 * This algorithm is divide the n by 2 every time and pass this to recursive call to find the result of smaller result.
 * why? Because
 *      x^n => [if n is even] x^(n / 2) *  x^(n / 2)     (example : 7^4 => 7^2 * 7^2)
 *             [if n is odd]  x^(n / 2) *  x^(n / 2) * x (example : 7^5 => 7^2 * 7^2 * 7)
 * and repeat the above step until we reach to the base case.
 *
 * @function PowLogarithmic
 * @description Given two integers x and n, return x^n in logarithmic complexity.
 * @param {Integer} x - The input integer
 * @param {Integer} n - The input integer
 * @return {Integer} - Returns x^n.
 * @see [Pow-Logarithmic](https://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/)
 */
const powLogarithmic = (x, n) => {
  if (n === 0) return 1
  const result = powLogarithmic(x, Math.floor(n / 2))
  if (isEven(n)) {
    return result * result
  }
  return result * result * x
}

export { powLogarithmic }
/*
    author: PatOnTheBack
    license: GPL-3.0 or later

    Modified from:
        https://github.com/TheAlgorithms/Python/blob/master/maths/factorial_python.py

    This script will find the factorial of a number provided by the user.

    More about factorials:
        https://en.wikipedia.org/wiki/factorial
*/

'use strict'

const calcRange = (num) => {
  return [...Array(num).keys()].map(i => i + 1)
}

const calcFactorial = (num) => {
  if (num === 0) {
    return 'The factorial of 0 is 1.'
  }
  if (num < 0) {
    return 'Sorry, factorial does not exist for negative numbers.'
  }
  if (!num) {
    return 'Sorry, factorial does not exist for null or undefined numbers.'
  }
  if (num > 0) {
    const range = calcRange(num)
    const factorial = range.reduce((a, c) => a * c, 1)
    return `The factorial of ${num} is ${factorial}`
  }
}

export { calcFactorial }
/*
    Problem statement and Explanation : https://medium.com/@ManBearPigCode/how-to-reverse-a-number-mathematically-97c556626ec6
*/

/**
 * ReverseNumber return the reversed value of the given number.
 * @param {Number} n any digit number.
 * @returns `Number` n reverse in reverse.
 */
const ReverseNumber = (number) => {
  // firstly, check that input is a number or not.
  if (typeof number !== 'number') {
    return new TypeError('Argument is not a number.')
  }
  // A variable for storing the reversed number.
  let reverseNumber = 0
  // Iterate the process until getting the number is 0.
  while (number > 0) {
    // get the last digit of the number
    const lastDigit = number % 10
    // add to the last digit to in reverseNumber
    reverseNumber = reverseNumber * 10 + lastDigit
    // reduce the actual number.
    number = Math.floor(number / 10)
  }
  return reverseNumber
}

export { ReverseNumber }
/**
 * @function collatz
 * @description Applies the Collatz Sequence on a specified number.
 * The Collatz Sequence states that every natural number will always fall in a 1, 2, 4 loop when iterated under the following function:
 * If the number is even, divide by 2, and if its odd, multiply it by 3 and add 1.
 *
 * @parama {Integer} n The number to apply the Collatz Sequence to.
 *
 * @return An array of steps and the final result..
 *
 * @see [Collatz Conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture)
 *
 * @example collatz(1) = { result: 1, steps: [] }
 * @example collatz(5) = { result: 1, steps: [16, 8, 4, 2, 1] }
*/
export function collatz (n) {
  const steps = []

  while (n !== 1) {
    if (n % 2 === 0) {
      n = n / 2
    } else {
      n = 3 * n + 1
    }

    steps.push(n)
  }

  return { result: n, steps: steps }
}
/**
 Problem Statement and Explanation :
 Triangular  => https://en.wikipedia.org/wiki/Triangular_number
 Tetrahedral => https://en.wikipedia.org/wiki/Tetrahedral_number
 Pentatope   => https://en.wikipedia.org/wiki/Pentatope_number

 Example:
 Triangular  => (0, 1, 3, 6, 10, 15, 21, 28, 36, 45)
 Tetrahedral => (1, 4, 10, 20, 35, 56, 84, 120, 165,)
 Pentatope   => (1, 5, 15, 35, 70, 126, 210, 330, 495)
 */

/**
 *
 * @param {*} number
 * @returns
 */
const isTriangular = (number) => {
  for (let i = 0; i <= number; i++) {
    if ((i * (i + 1)) / 2 === number) {
      return true
    } else if ((i * (i + 1)) / 2 > number) {
      return false
    }
  }
  return false
}

/**
 *
 * @param {*} number
 * @returns
 */
const isTetrahedral = (number) => {
  for (let i = 1; i <= number; i++) {
    if ((i * (i + 1) * (i + 2)) / 6 === number) {
      return true
    } else if ((i * (i + 1) * (i + 2)) / 6 > number) {
      return false
    }
  }
  return false
}
/**
 *
 * @param {*} number
 * @returns
 */
const isPentatope = (number) => {
  for (let i = 1; i <= number; i++) {
    if ((i * (i + 1) * (i + 2) * (i + 3)) / 24 === number) {
      return true
    } else if ((i * (i + 1) * (i + 2) * (i + 3)) / 24 > number) {
      return false
    }
  }
  return false
}

/**
 *
 * @param {*} number
 * @returns
 */
const checkAll = (number) => {
  return {
    isTriangular: isTriangular(number),
    isTetrahedral: isTetrahedral(number),
    isPentatope: isPentatope(number)
  }
}
export { isTriangular }
export { isTetrahedral }
export { isPentatope }
export { checkAll }
/*
  Returns the sum of a geometric progression
  Article on Geometric Progression: https://en.wikipedia.org/wiki/Geometric_series
  Examples:
  > sumOfGeometricProgression(2, 0.5, 6)
  3.9375
  > sumOfGeometricProgression(0.5, 10, 3)
  55.5
  > sumOfGeometricProgression(0.5, 10, Infinity)
  Error: The geometric progression is diverging, and its sum cannot be calculated
*/

/**
 *
 * @param {Number} firstTerm The first term of the geometric progression
 * @param {Number} commonRatio The common ratio of the geometric progression
 * @param {Number} numOfTerms The number of terms in the progression
 */
function sumOfGeometricProgression (firstTerm, commonRatio, numOfTerms) {
  if (!Number.isFinite(numOfTerms)) {
    /*
      If the number of Terms is Infinity, the common ratio needs to be less than 1 to be a convergent geometric progression
      Article on Convergent Series: https://en.wikipedia.org/wiki/Convergent_series
    */
    if (Math.abs(commonRatio) < 1) return firstTerm / (1 - commonRatio)
    throw new Error('The geometric progression is diverging, and its sum cannot be calculated')
  }

  if (commonRatio === 1) return firstTerm * numOfTerms

  return (firstTerm * (Math.pow(commonRatio, numOfTerms) - 1)) / (commonRatio - 1)
}

export { sumOfGeometricProgression }
/**
 * Returns whether the given string is a valid email address or not.
 */
const validateEmail = (str) => {
  if (str === '' || str === null) {
    throw new TypeError('Email Address String Null or Empty.')
  }

  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(str)
}

export { validateEmail }
/**
 * @function upper
 * @description Will convert the entire string to uppercase letters.
 * @param {String} str - The input string
 * @return {String} Uppercase string
 * @example upper("hello") => HELLO
 * @example upper("He_llo") => HE_LLO
 */
const upper = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

  return str.replace(
    /[a-z]/g, (char) => String.fromCharCode(char.charCodeAt() - 32)
  )
}

export default upper
// CheckSnakeCase method checks the given string is in snake_case or not.

// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)

/**
 * checkSnakeCase method returns true if the string in snake_case, else return the false.
 * @param {String} varName the name of the variable to check.
 * @returns `Boolean` return true if the string is in snake_case, else return false.
 */
const checkSnakeCase = (varName) => {
  // firstly, check that input is a string or not.
  if (typeof varName !== 'string') {
    throw new TypeError('Argument is not a string.')
  }

  const pat = /(.*?)_([a-zA-Z])*/
  return pat.test(varName)
}

export { checkSnakeCase }
// Problem Statement and Explanation: https://leetcode.com/problems/scramble-string/

/**
 * Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */

const isScramble = (s1, s2) => {
  return helper({}, s1, s2)
}

const helper = function (dp, s1, s2) {
  const map = {}

  if (dp[s1 + s2] !== undefined) return dp[s1 + s2]
  if (s1 === s2) return true

  for (let j = 0; j < s1.length; j++) {
    if (map[s1[j]] === undefined) map[s1[j]] = 0
    if (map[s2[j]] === undefined) map[s2[j]] = 0
    map[s1[j]]++
    map[s2[j]]--
  }

  for (const key in map) {
    if (map[key] !== 0) {
      dp[s1 + s2] = false
      return false
    }
  }

  for (let i = 1; i < s1.length; i++) {
    if (
      (helper(dp, s1.substr(0, i), s2.substr(0, i)) &&
        helper(dp, s1.substr(i), s2.substr(i))) ||
      (helper(dp, s1.substr(0, i), s2.substr(s2.length - i)) &&
        helper(dp, s1.substr(i), s2.substr(0, s2.length - i)))
    ) {
      dp[s1 + s2] = true
      return true
    }
  }

  dp[s1 + s2] = false
  return false
}

export { isScramble }
/**
 * @function checkExceeding
 * @description - Exceeding words are words where the gap between two adjacent characters is increasing. The gap is the distance in ascii
 * @param {string} str
 * @returns {boolean}
 * @example - checkExceeding('delete') => true, ascii difference - [1, 7, 7, 15, 15] which is incremental
 * @example - checkExceeding('update') => false, ascii difference - [5, 12, 3, 19, 15] which is not incremental
 */
const checkExceeding = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument is not a string')
  }

  const upperChars = str
    .toUpperCase()
    .replace(/[^A-Z]/g, '') // remove all from str except A to Z alphabets

  const adjacentDiffList = []

  for (let i = 0; i < upperChars.length - 1; i++) {
    // destructuring current char & adjacent char by index, cause in javascript String is an object.
    const { [i]: char, [i + 1]: adjacentChar } = upperChars

    if (char !== adjacentChar) {
      adjacentDiffList.push(
        Math.abs(char.charCodeAt() - adjacentChar.charCodeAt())
      )
    }
  }

  for (let i = 0; i < adjacentDiffList.length - 1; i++) {
    const { [i]: charDiff, [i + 1]: secondCharDiff } = adjacentDiffList

    if (charDiff > secondCharDiff) {
      return false
    }
  }

  return true
}

export { checkExceeding }
import { checkWordOccurrence } from '../CheckWordOccurrence'

describe('Testing checkWordOccurrence', () => {
  it('expects throw on insert wrong string', () => {
    const value = 123

    expect(() => checkWordOccurrence(value)).toThrow()
  })

  it('expect throw on insert wrong param for case sensitive', () => {
    const value = 'hello'

    expect(() => checkWordOccurrence(value, value)).toThrow()
  })

  it('check occurrence with case sensitive', () => {
    const stringToTest = 'The quick brown fox jumps over the lazy dog'
    const expectResult = { The: 1, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, the: 1, lazy: 1, dog: 1 }

    expect(checkWordOccurrence(stringToTest)).toEqual(expectResult)
  })

  it('check occurrence with case insensitive', () => {
    const stringToTest = 'The quick brown fox jumps over the lazy dog'
    const expectResult = { the: 2, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, lazy: 1, dog: 1 }

    expect(checkWordOccurrence(stringToTest, true)).toEqual(expectResult)
  })
})
import { KMPSearch } from '../KMPPatternSearching'

describe('KMP Matcher', () => {
  it('TC1: expects to return matching indices for pattern in text', () => {
    const text = 'ABC ABCDAB ABCDABCDABDE'
    const pattern = 'ABCDABD'
    expect(KMPSearch(text, pattern)).toStrictEqual([15])
  })

  it('TC2: expects to return matching indices for pattern in text', () => {
    const text = 'ABC ABCDABD ABCDABCDABDE'
    const pattern = 'ABCDABD'
    expect(KMPSearch(text, pattern)).toStrictEqual([4, 16])
  })

  it('TC3: expects to return matching indices for pattern in text', () => {
    const text = 'AAAAA'
    const pattern = 'AAA'
    expect(KMPSearch(text, pattern)).toStrictEqual([0, 1, 2])
  })

  it('TC4: expects to return matching indices for pattern in text', () => {
    const text = 'ABCD'
    const pattern = 'BA'
    expect(KMPSearch(text, pattern)).toStrictEqual([])
  })
})
import { checkCamelCase } from '../CheckCamelCase'
describe('checkCamelCase', () => {
  it('expect to throw an error if input is not a string', () => {
    expect(() => checkCamelCase(null)).toThrow()
  })

  it('expects to return true if the input is in camel case format', () => {
    const value = 'dockerBuild'
    const result = checkCamelCase(value)
    expect(result).toBe(true)
  })

  it('expects to return false if the input is not in camel case format', () => {
    const value = 'docker_build'
    const result = checkCamelCase(value)
    expect(result).toBe(false)
  })
})
import { diceCoefficient } from '../DiceCoefficient'

describe('diceCoefficient', () => {
  it('should calculate edit distance between two strings', () => {
    // equal strings return 1 (max possible value)
    expect(diceCoefficient('abc', 'abc')).toBe(1)
    expect(diceCoefficient('', '')).toBe(1)

    // string length needs to be at least 2 (unless equal)
    expect(diceCoefficient('a', '')).toBe(0)
    expect(diceCoefficient('', 'a')).toBe(0)

    expect(diceCoefficient('skate', 'ate')).toBe(0.66)

    expect(diceCoefficient('money', 'honey')).toBe(0.75)

    expect(diceCoefficient('love', 'hate')).toBe(0)

    expect(diceCoefficient('skilled', 'killed')).toBe(0.9)
  })
})
import { createPermutations } from '../CreatePermutations'

describe('createPermutations', () => {
  it('expects to generate 6 different combinations', () => {
    const text = 'abc'
    const SUT = createPermutations(text)
    expect(SUT).toStrictEqual(['abc', 'acb', 'bac', 'bca', 'cab', 'cba'])
  })
  it('expects to generate 2 different combinations', () => {
    const text = '12'
    const SUT = createPermutations(text)
    expect(SUT).toStrictEqual(['12', '21'])
  })
})
import reverseWords from '../ReverseWords'

describe('Testing the reverseWords function', () => {
  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => {
        reverseWords(input)
      }).toThrow('The given value is not a string')
    }
  )

  it('expects to reverse words to return a joined word', () => {
    expect(reverseWords('I Love JS')).toBe('JS Love I')
    expect(reverseWords('Hello World')).toBe('World Hello')
    expect(reverseWords('The Algorithms Javascript')).toBe('Javascript Algorithms The')
  })
})
import { AlternativeStringArrange } from '../AlternativeStringArrange'

test('AlternativeStringArrange(Agrtm, loih) -> Algorithm', () => {
  const str1 = 'Agrtm'
  const str2 = 'loih'
  const res = AlternativeStringArrange(str1, str2)
  expect(res).toEqual('Algorithm')
})

test('AlternativeStringArrange(JvSrp, aacit) -> JavaScript', () => {
  const str1 = 'JvSrp'
  const str2 = 'aacit'
  const res = AlternativeStringArrange(str1, str2)
  expect(res).toEqual('JavaScript')
})

test('AlternativeStringArrange(abc, def) -> adbecf', () => {
  const str1 = 'abc'
  const str2 = 'def'
  const res = AlternativeStringArrange(str1, str2)
  expect(res).toEqual('adbecf')
})
import { checkAnagramMap, checkAnagramRegex } from '../CheckAnagram'

describe('Testing checkAnagramRegex', () => {
  it.each`
    inputOne              | inputTwo
    ${123456}             | ${'abcd'}
    ${[1, 2, 3, 4, 5, 6]} | ${'abcd'}
    ${{ test: 'test' }}   | ${'abcd'}
    ${'abcd'}             | ${123456}
    ${'abcd'}             | ${[1, 2, 3, 4, 5, 6]}
    ${'abcd'}             | ${{ test: 'test' }}
  `(
    'expects to throw the type Error given values $inputOne and $inputTwo',
    ({ inputOne, inputTwo }) => {
      expect(
        () => checkAnagramRegex(inputOne, inputTwo)
      ).toThrowError()
    }
  )

  it('expects to return false if the arguments have different lengths', () => {
    const SUT = checkAnagramRegex('abs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return false if the arguments are not anagrams', () => {
    const SUT = checkAnagramRegex('abcs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return true if the arguments are anagrams', () => {
    const SUT = checkAnagramRegex('abcd', 'bcad')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of length 1 and are the same letter', () => {
    const SUT = checkAnagramRegex('a', 'a')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of are both empty strings', () => {
    const SUT = checkAnagramRegex('', '')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an odd length', () => {
    const SUT = checkAnagramRegex('abcde', 'edcab')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an even length', () => {
    const SUT = checkAnagramRegex('abcdef', 'fedcab')
    expect(SUT).toBe(true)
  })

  it('expects to return false if either argument is an empty string while the other is not', () => {
    const SUT = checkAnagramRegex('', 'edcab')
    expect(SUT).toBe(false)
    const SUT2 = checkAnagramRegex('edcab', '')
    expect(SUT2).toBe(false)
  })

  it('expects to return true if the arguments contain the same letters but have unequal case', () => {
    const SUT = checkAnagramRegex('ABDCE', 'abcde')
    expect(SUT).toBe(true)
    const SUT2 = checkAnagramRegex('AbCdE', 'aBCdE')
    expect(SUT2).toBe(true)
    const SUT3 = checkAnagramRegex('Eleven plus two', 'Twelve plus one')
    expect(SUT3).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain number characters', () => {
    const SUT = checkAnagramRegex('a1b2', '12ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain space characters', () => {
    const SUT = checkAnagramRegex('a1 b2', '1 2ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain punctuation characters', () => {
    const SUT = checkAnagramRegex('a!1b@2', '1@2ba!')
    expect(SUT).toBe(true)
  })

  it('expects to return false if the arguments contain the same letters but contain a different amount of space characters', () => {
    const SUT = checkAnagramRegex('ea        cb', 'e cba')
    expect(SUT).toBe(false)
  })
})

describe('Testing checkAnagramMap', () => {
  it.each`
    inputOne              | inputTwo
    ${123456}             | ${'abcd'}
    ${[1, 2, 3, 4, 5, 6]} | ${'abcd'}
    ${{ test: 'test' }}   | ${'abcd'}
    ${'abcd'}             | ${123456}
    ${'abcd'}             | ${[1, 2, 3, 4, 5, 6]}
    ${'abcd'}             | ${{ test: 'test' }}
  `(
    'expects to throw the type Error given values $inputOne and $inputTwo',
    ({ inputOne, inputTwo }) => {
      expect(
        () => checkAnagramMap(inputOne, inputTwo)
      ).toThrowError()
    }
  )

  it('expects to return false if the arguments have different lengths', () => {
    const SUT = checkAnagramMap('abs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return false if the arguments are not anagrams', () => {
    const SUT = checkAnagramMap('abcs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return true if the arguments are anagrams', () => {
    const SUT = checkAnagramMap('abcd', 'bcad')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of length 1 and are the same letter', () => {
    const SUT = checkAnagramMap('a', 'a')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of are both empty strings', () => {
    const SUT = checkAnagramMap('', '')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an odd length', () => {
    const SUT = checkAnagramMap('abcde', 'edcab')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an even length', () => {
    const SUT = checkAnagramMap('abcdef', 'fedcab')
    expect(SUT).toBe(true)
  })

  it('expects to return false if either argument is an empty string while the other is not', () => {
    const SUT = checkAnagramMap('', 'edcab')
    expect(SUT).toBe(false)
    const SUT2 = checkAnagramMap('edcab', '')
    expect(SUT2).toBe(false)
  })

  it('expects to return true if the arguments contain the same letters but have unequal case', () => {
    const SUT = checkAnagramMap('ABDCE', 'abcde')
    expect(SUT).toBe(true)
    const SUT2 = checkAnagramMap('AbCdE', 'aBCdE')
    expect(SUT2).toBe(true)
    const SUT3 = checkAnagramMap('Eleven plus two', 'Twelve plus one')
    expect(SUT3).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain number characters', () => {
    const SUT = checkAnagramMap('a1b2', '12ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain space characters', () => {
    const SUT = checkAnagramMap('a1 b2', '1 2ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain punctuation characters', () => {
    const SUT = checkAnagramMap('a!1b@2', '1@2ba!')
    expect(SUT).toBe(true)
  })

  it('expects to return false if the arguments contain the same letters but contain a different amount of space characters', () => {
    const SUT = checkAnagramMap('ea        cb', 'e cba')
    expect(SUT).toBe(false)
  })
})
import { countVowels } from '../CountVowels'

describe('CountVowels', () => {
  it('expect throws on use wrong param', () => {
    expect(() => countVowels(0)).toThrow()
  })

  it('count the vowels in a string', () => {
    const value = 'Mad World'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return 0 when input is a string with no vowels', () => {
    const value = 'bcdfgh'
    const count = countVowels(value)
    expect(count).toBe(0)
  })

  it('should return 1 when input is a string of length 1 that is a vowel', () => {
    const value = 'a'
    const count = countVowels(value)
    expect(count).toBe(1)
  })

  it('should return the correct result when input is in all uppercase letters', () => {
    const value = 'ABCDE'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return the correct result when input is in all lowercase letters', () => {
    const value = 'abcdefghi'
    const count = countVowels(value)
    expect(count).toBe(3)
  })

  it('should return the correct result when input string contains spaces', () => {
    const value = 'abc def   ghi'
    const count = countVowels(value)
    expect(count).toBe(3)
  })

  it('should return the correct result when input contains number characters', () => {
    const value = 'a1b2c3'
    const count = countVowels(value)
    expect(count).toBe(1)
  })

  it('should return the correct result when input contains punctuation characters', () => {
    const value = 'a!b.ce)'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return 0 when the input is an empty string', () => {
    const value = ''
    const count = countVowels(value)
    expect(count).toBe(0)
  })

  it('should count multiple occurrences of the same vowel in the input', () => {
    const value = 'aaaaa'
    const count = countVowels(value)
    expect(count).toBe(5)
  })
})
import { permutate } from '../PermutateString'

describe('Permutate a string', () => {
  it('expects to throw an Error with an empty string', () => {
    expect(() => { permutate() }).toThrow('The arg must be a valid, non empty string')
  })
  it('expects to permute "no" into [no, on]', () => {
    expect(['no', 'on']).toEqual(permutate('no'))
  })
  it('expects to permute "yes" into [esy, eys, sey, sye, yes, yse]', () => {
    expect(['esy', 'eys', 'sey', 'sye', 'yes', 'yse']).toEqual(permutate('yes'))
  })
  it('expects to permute "good" into [dgoo dogo doog gdoo godo good odgo odog ogdo ogod oodg oogd ]', () => {
    expect(['dgoo', 'dogo', 'doog', 'gdoo', 'godo', 'good', 'odgo', 'odog', 'ogdo', 'ogod', 'oodg', 'oogd'])
      .toEqual(permutate('good'))
  })
})
import lower from '../Lower'

describe('Testing the Lower function', () => {
  it('Test 1: Check by invalid type', () => {
    expect(() => lower(345)).toThrowError()
    expect(() => lower(true)).toThrowError()
    expect(() => lower(null)).toThrowError()
  })

  it('Test 2: Check by uppercase string', () => {
    expect(lower('WORLD')).toBe('world')
    expect(lower('Hello_WORLD')).toBe('hello_world')
  })

  it('Test 3: Check by lowercase string', () => {
    expect(lower('hello')).toBe('hello')
    expect(lower('hello_world')).toBe('hello_world')
  })
})
import { validateCreditCard } from '../ValidateCreditCard'

describe('Validate credit card number', () => {
  it('should throw error if card number is boolean', () => {
    const invalidCC = true
    expect(() => validateCreditCard(invalidCC)).toThrow(
      'The given value is not a string'
    )
  })
  it('returns true if the credit card number is valid', () => {
    const validCreditCard = '4111111111111111'
    const validationResult = validateCreditCard(validCreditCard)
    expect(validationResult).toBe(true)
  })
  it('should throw an error on non-numeric character in given credit card number', () => {
    const nonNumericCCNumbers = ['123ABCDEF', 'ABCDKDKD', 'ADS232']
    nonNumericCCNumbers.forEach(nonNumericCC => expect(() => validateCreditCard(nonNumericCC)).toThrow(
      `${nonNumericCC} is an invalid credit card number because ` + 'it has nonnumerical characters.'
    ))
  })
  it('should throw an error on credit card with invalid length', () => {
    const ccWithInvalidLength = ['41111', '4111111111111111111111']
    ccWithInvalidLength.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'of its length.'
    ))
  })
  it('should throw an error on credit card with invalid start substring', () => {
    const ccWithInvalidStartSubstring = ['12345678912345', '23456789123456', '789123456789123', '891234567891234', '912345678912345', '31345678912345', '32345678912345', '33345678912345', '38345678912345']
    ccWithInvalidStartSubstring.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'of its first two digits.'
    ))
  })
  it('should throw an error on credit card with luhn check fail', () => {
    const invalidCCs = ['411111111111111', '371211111111111', '49999999999999']
    invalidCCs.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'it fails the Luhn check.'
    ))
  })
})
import { palindromeRearranging } from '../CheckRearrangePalindrome'

test('palindromeRearranging(apple) -> false', () => {
  const word = 'apple'
  const res = palindromeRearranging(word)
  expect(res).toBeFalsy()
})

test('palindromeRearranging(aapplle) -> true', () => {
  const word = 'aapplle'
  const res = palindromeRearranging(word)
  expect(res).toBeTruthy()
})

test('palindromeRearranging(value) -> false', () => {
  const word = 'value'
  const res = palindromeRearranging(word)
  expect(res).toBeFalsy()
})

test('palindromeRearranging(aaeccrr) -> true', () => {
  const word = 'aaeccrr'
  const res = palindromeRearranging(word)
  expect(res).toBeTruthy()
})
import { maxWord } from '../MaxWord'

describe('Testing the maxWord function', () => {
  it('Expect throw with non string argument', () => {
    expect(() => maxWord(10)).toThrow()
  })
  it('get the max word', () => {
    const string = 'be be be be a a banana'
    const mostOccurringWord = maxWord(string)
    expect(mostOccurringWord).toBe('be')
  })
})
import { levenshteinDistance } from '../LevenshteinDistance'

describe('levenshteinDistance', () => {
  it('should calculate edit distance between two strings', () => {
    expect(levenshteinDistance('', '')).toBe(0)
    expect(levenshteinDistance('a', '')).toBe(1)
    expect(levenshteinDistance('', 'a')).toBe(1)
    expect(levenshteinDistance('abc', '')).toBe(3)
    expect(levenshteinDistance('', 'abc')).toBe(3)

    // Should just add I to the beginning.
    expect(levenshteinDistance('igloo', 'gloo')).toBe(1)

    // Should just substitute i with o, m with g and insert e at end
    expect(levenshteinDistance('firm', 'forge')).toBe(3)

    // Should just substitute f with s, g with t and delete h
    expect(levenshteinDistance('fighting', 'sitting')).toBe(3)

    // Should add 4 letters b, a, s and e at the beginning.
    expect(levenshteinDistance('ball', 'baseball')).toBe(4)

    // Should delete 4 letters b, a, s and e at the beginning and replace the last 4 with f, o, o, t
    expect(levenshteinDistance('baseball', 'foot')).toBe(8)
  })
})
import { checkPangramRegex, checkPangramSet } from '../CheckPangram'

describe('Testing checkPangramRegex function', () => {
  it('"The quick brown fox jumps over the lazy dog" is a pangram', () => {
    expect(
      checkPangramRegex('The quick brown fox jumps over the lazy dog')
    ).toBe(true)
  })

  it('"Waltz, bad nymph, for quick jigs vex." is a pangram', () => {
    expect(checkPangramRegex('Waltz, bad nymph, for quick jigs vex.')).toBe(true)
  })

  it('"Jived fox nymph grabs quick waltz." is a pangram', () => {
    expect(checkPangramRegex('Jived fox nymph grabs quick waltz.')).toBe(true)
  })

  it('"My name is Unknown" is NOT a pangram', () => {
    expect(checkPangramRegex('My name is Unknown')).toBe(false)
  })

  it('"The quick brown fox jumps over the la_y dog" is NOT a pangram', () => {
    expect(
      checkPangramRegex('The quick brown fox jumps over the la_y dog')
    ).toBe(false)
  })

  it('Throws an error if given param is not a string', () => {
    expect(() => {
      checkPangramRegex(undefined)
    }).toThrow('The given value is not a string')
  })
})

describe('Testing checkPangramSet function', () => {
  it('"The quick brown fox jumps over the lazy dog" is a pangram', () => {
    expect(
      checkPangramSet('The quick brown fox jumps over the lazy dog')
    ).toBe(true)
  })

  it('"Waltz, bad nymph, for quick jigs vex." is a pangram', () => {
    expect(checkPangramSet('Waltz, bad nymph, for quick jigs vex.')).toBe(true)
  })

  it('"Jived fox nymph grabs quick waltz." is a pangram', () => {
    expect(checkPangramSet('Jived fox nymph grabs quick waltz.')).toBe(true)
  })

  it('"My name is Unknown" is NOT a pangram', () => {
    expect(checkPangramSet('My name is Unknown')).toBe(false)
  })

  it('"The quick brown fox jumps over the la_y dog" is NOT a pangram', () => {
    expect(
      checkPangramSet('The quick brown fox jumps over the la_y dog')
    ).toBe(false)
  })

  it('Throws an error if given param is not a string', () => {
    expect(() => {
      checkPangramSet(undefined)
    }).toThrow('The given value is not a string')
  })
})
import { checkFlatCase } from '../CheckFlatCase'

describe('checkFlatCase function', () => {
  it('should return false when the input string is not in flatcase', () => {
    const actual = checkFlatCase('this is not in flatcase')
    expect(actual).toBe(false)
  })

  it('should return true when the input string is a single letter character', () => {
    const actual = checkFlatCase('a')
    expect(actual).toBe(true)
  })

  it('should return true when the input string is a string of lowercase letter characters with no spaces', () => {
    const actual = checkFlatCase('abcdefghijklmnopqrstuvwxyz')
    expect(actual).toBe(true)
  })
})
import formatPhoneNumber from '../FormatPhoneNumber'

describe('Testing the formatPhoneNumber functions', () => {
  it('expects to throw a type error', () => {
    expect(() => formatPhoneNumber('1234567')).toThrow('Invalid phone number!')
    expect(() => formatPhoneNumber('123456text')).toThrow('Invalid phone number!')
    expect(() => formatPhoneNumber(12345)).toThrow('Invalid phone number!')
  })

  it('expects to return the formatted phone number', () => {
    expect(formatPhoneNumber('1234567890')).toEqual('(123) 456-7890')
    expect(formatPhoneNumber('2124323322')).toEqual('(212) 432-3322')
    expect(formatPhoneNumber('1721543455')).toEqual('(172) 154-3455')
  })
})
import { checkPalindrome } from '../CheckPalindrome'

describe('checkPalindrome', () => {
  it('expects to return "Palindrome" if the given string is a palindrome', () => {
    const SUT = checkPalindrome('madam')
    expect(SUT).toBe('Palindrome')
  })
  it('expects to return "Empty string" if the given string is empty', () => {
    const SUT = checkPalindrome('')
    expect(SUT).toBe('Empty string')
  })
  it('expects to return "Not a string" if the given string is not a string', () => {
    const SUT = checkPalindrome(123)
    expect(SUT).toBe('Not a string')
  })
})
import { checkIfPatternExists } from '../PatternMatching'
describe('checkIfPatternExists', () => {
  it('expects to find a pattern with correct input', () => {
    const text = 'AABAACAADAABAAAABAA'
    const pattern = 'AABA'
    const SUT = checkIfPatternExists(text.toLowerCase(), pattern.toLowerCase())
    expect(SUT).toBe('Given pattern is found at index 0')
  })
  it('expects to return a message when there is no pattern', () => {
    const text = 'ABCDEFG'
    const pattern = 'AEG'
    const SUT = checkIfPatternExists(text.toLowerCase(), pattern.toLowerCase())
    expect(SUT).toBe(undefined)
  })
  it('expects to find a pattern independent of casing', () => {
    const text = 'AbCAAAAAAB'
    const pattern = 'abc'
    const SUT = checkIfPatternExists(text, pattern)
    expect(SUT).toBe(undefined)
  })
  it('expects to throw an error message when given input is not a string', () => {
    const text = 123444456
    const pattern = 123
    expect(() => checkIfPatternExists(text, pattern)).toThrow(
      'Given input is not a string'
    )
  })
})
import maxCharacter from '../MaxCharacter'

describe('Testing the maxCharacter function', () => {
  it('Expect throw with wrong arg', () => {
    expect(() => maxCharacter(123)).toThrow()
    expect(() => maxCharacter('')).toThrow()
  })

  it('Check the max character in string', () => {
    const theString = 'I can\'t do that'
    const maxCharInAllCount = maxCharacter(theString)
    const maxChar = maxCharacter(theString, /\s/)

    expect(maxCharInAllCount).toBe(' ')
    expect(maxChar).toBe('t')

    expect(maxCharacter('!!!Hello, World!!!', /[a-z]/)).toBe('!')

    expect(maxCharacter('!!!Hello, World!!!', /[^a-z]/i)).toBe('l')
  })
})
import { validateEmail } from '../ValidateEmail'

describe('Validation of an Email Address', () => {
  it('expects to return false', () => {
    expect(validateEmail('mahfoudh.arous.com')).toEqual(false)
  })

  it('expects to return false', () => {
    expect(validateEmail('mahfoudh.arous@com')).toEqual(false)
  })

  it('expects to return true', () => {
    expect(validateEmail('mahfoudh.arous@gmail.com')).toEqual(true)
  })

  it('expects to return true', () => {
    expect(validateEmail('icristianbaciu@.helsinki.edu')).toEqual(true)
  })

  it('expects to throw a type error', () => {
    expect(() => { validateEmail('') }).toThrow('Email Address String Null or Empty.')
    expect(() => { validateEmail(null) }).toThrow('Email Address String Null or Empty.')
  })
})
import { CheckKebabCase } from '../CheckKebabCase'

test('CheckKebabCase(The-Algorithms) -> true', () => {
  const word = 'The-Algorithms'
  const res = CheckKebabCase(word)
  expect(res).toBeTruthy()
})

test('CheckKebabCase(The Algorithms) -> false', () => {
  const word = 'The Algorithms'
  const res = CheckKebabCase(word)
  expect(res).toBeFalsy()
})
import { checkExceeding } from '../CheckExceeding'

describe('Testing CheckExceeding function', () => {
  it('Testing the invalid types', () => {
    expect(() => checkExceeding(Math.random())).toThrow('Argument is not a string')
    expect(() => checkExceeding(null)).toThrow('Argument is not a string')
    expect(() => checkExceeding(false)).toThrow('Argument is not a string')
    expect(() => checkExceeding(false)).toThrow('Argument is not a string')
  })

  it('Testing with empty string', () => {
    expect(checkExceeding('')).toBe(true)
  })

  it('Testing with linear alphabets', () => {
    expect(checkExceeding('a b c d e ')).toBe(true)
    expect(checkExceeding('f g h i j ')).toBe(true)
    expect(checkExceeding('k l m n o ')).toBe(true)
    expect(checkExceeding('p q r s t ')).toBe(true)
    expect(checkExceeding('u v w x y z')).toBe(true)
  })

  it('Testing not exceeding words', () => {
    expect(checkExceeding('Hello')).toBe(false)
    expect(checkExceeding('world')).toBe(false)
    expect(checkExceeding('update')).toBe(false)
    expect(checkExceeding('university')).toBe(false)
    expect(checkExceeding('dog')).toBe(false)
    expect(checkExceeding('exceeding')).toBe(false)
    expect(checkExceeding('resolved')).toBe(false)
    expect(checkExceeding('future')).toBe(false)
    expect(checkExceeding('fixed')).toBe(false)
    expect(checkExceeding('codes')).toBe(false)
    expect(checkExceeding('facebook')).toBe(false)
    expect(checkExceeding('vscode')).toBe(false)
  })

  it('Testing exceeding words', () => {
    expect(checkExceeding('bee')).toBe(true) // [ 3 ]
    expect(checkExceeding('can')).toBe(true) // [ 2, 13 ]
    expect(checkExceeding('good')).toBe(true) //  [ 8, 11 ]
    expect(checkExceeding('bad')).toBe(true) // [ 1, 3 ]
    expect(checkExceeding('play')).toBe(true) // [ 4, 11, 24 ]
    expect(checkExceeding('delete')).toBe(true) // [1, 7, 7, 15, 15]
  })
})
import { CheckPascalCase } from '../CheckPascalCase'

test('CheckPascalCase(TheAlgorithms) -> true', () => {
  const word = 'TheAlgorithms'
  const res = CheckPascalCase(word)
  expect(res).toBeTruthy()
})

test('CheckPascalCase(theAlgorithms) -> false', () => {
  const word = 'theAlgorithms'
  const res = CheckPascalCase(word)
  expect(res).toBeFalsy()
})

test('CheckPascalCase(The Algorithms) -> false', () => {
  const word = 'The Algorithms'
  const res = CheckPascalCase(word)
  expect(res).toBeFalsy()
})
import { validateURL } from '../ValidateUrl'

describe('ValidateUrl', () => {
  it('expects to return false', () => {
    expect(validateURL('google')).toEqual(false)
    expect(validateURL('link: https://www.google.com')).toEqual(false)
  })

  it('expects to return true', () => {
    expect(validateURL('http://www.google.com')).toEqual(true)
    expect(validateURL('https://www.google.com')).toEqual(true)
    expect(validateURL('www.google.com')).toEqual(true)
  })
})
import { ReverseStringIterative, ReverseStringIterativeInplace } from '../ReverseString'

describe('ReverseStringIterative', () => {
  it('expects to reverse a simple string', () => {
    expect(ReverseStringIterative('reverse')).toEqual('esrever')
    expect(ReverseStringIterative('some')).toEqual('emos')
    expect(ReverseStringIterative('string')).toEqual('gnirts')
    expect(ReverseStringIterative('The Algorithms Javascript')).toEqual('tpircsavaJ smhtiroglA ehT')
  })

  it('expects to reverse a string with spaces in between', () => {
    expect(ReverseStringIterative('reverse me')).toEqual('em esrever')
  })

  it('expects to reverse a simple string without capitalizing the first letter', () => {
    expect(ReverseStringIterative('Javascript')).toEqual('tpircsavaJ')
  })

  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => ReverseStringIterative(input)).toThrow('The given value is not a string')
    }
  )

  it('expects to return a empty string with an empty string is given', () => {
    expect(ReverseStringIterative('')).toEqual('')
  })
})

describe('ReverseStringIterativeInplace', () => {
  it('expects to reverse a simple string', () => {
    expect(ReverseStringIterativeInplace('reverse')).toEqual('esrever')
    expect(ReverseStringIterativeInplace('some')).toEqual('emos')
    expect(ReverseStringIterativeInplace('string')).toEqual('gnirts')
    expect(ReverseStringIterativeInplace('The Algorithms Javascript')).toEqual('tpircsavaJ smhtiroglA ehT')
  })

  it('expects to reverse a simple string without capitalizing the first letter', () => {
    expect(ReverseStringIterativeInplace('Javascript')).toEqual('tpircsavaJ')
  })

  it('expects to return an empty string given an empty string', () => {
    expect(ReverseStringIterativeInplace('Javascript')).toEqual('tpircsavaJ')
  })

  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => ReverseStringIterativeInplace(input)).toThrow('The given value is not a string')
    }
  )
})
import upper from '../Upper'

describe('Testing the Upper function', () => {
  it('return uppercase strings', () => {
    expect(upper('hello')).toBe('HELLO')
    expect(upper('WORLD')).toBe('WORLD')
    expect(upper('hello_WORLD')).toBe('HELLO_WORLD')
  })
})
import { isScramble } from '../ScrambleStrings'

describe('ScrambleStrings', () => {
  it('expects to return true for same string', () => {
    expect(isScramble('a', 'a')).toBe(true)
  })

  it('expects to return false for non-scrambled strings', () => {
    expect(isScramble('abcde', 'caebd')).toBe(false)
  })

  it('expects to return true for scrambled strings', () => {
    expect(isScramble('great', 'rgeat')).toBe(true)
  })
})
import alphaNumericPalindrome from '../AlphaNumericPalindrome'

describe('Testing the alpha numeric palindrome', () => {
  // should return true if the given string has alphanumeric characters that are palindrome irrespective of case and symbols
  it('Testing with valid alphabetic palindrome', () => {
    expect(alphaNumericPalindrome('eye')).toBe(true)
    expect(alphaNumericPalindrome('Madam')).toBe(true)
    expect(alphaNumericPalindrome('race CAR')).toBe(true)
    expect(alphaNumericPalindrome('A man, a plan, a canal. Panama')).toBe(true)
  })

  it('Testing with number and symbol', () => {
    expect(alphaNumericPalindrome('0_0 (: /-:) 0-0')).toBe(true)
    expect(alphaNumericPalindrome('03_|53411435|_30')).toBe(true)
  })

  it('Testing with alphabets and symbols', () => {
    expect(alphaNumericPalindrome('five|_/|evif')).toBe(true)
    expect(alphaNumericPalindrome('five|_/|four')).toBe(false)
  })
})
import { checkSnakeCase } from '../CheckSnakeCase'
describe('checkSnakeCase', () => {
  it('expect to throw an error if input is not a string', () => {
    expect(() => checkSnakeCase(0)).toThrow()
  })

  it('expects to return true if the input is in snake case format', () => {
    const value = 'docker_build'
    const result = checkSnakeCase(value)
    expect(result).toBe(true)
  })

  it('expects to return false if the input is not in snake case format', () => {
    const value = 'dockerBuild'
    const result = checkSnakeCase(value)
    expect(result).toBe(false)
  })
})
import { hammingDistance } from '../HammingDistance'

test('should throw an error when trying to compare the strings of different length', () => {
  const compareStringsOfDifferentLength = () => {
    hammingDistance('abc', 'abcd')
  }

  expect(compareStringsOfDifferentLength).toThrowError()
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('a', 'a')).toBe(0)
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('abc', 'add')).toBe(2)
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('1011101', '1001001')).toBe(2)
})
// Palindrome check is case sensitive; i.e. Aba is not a palindrome
// input is a string
const checkPalindrome = (str) => {
  // check that input is a string
  if (typeof str !== 'string') {
    return 'Not a string'
  }
  if (str.length === 0) {
    return 'Empty string'
  }
  // Reverse only works with array, thus convert the string to array, reverse it and convert back to string
  // return as palindrome if the reversed string is equal to the input string
  const reversed = [...str].reverse().join('')
  return str === reversed ? 'Palindrome' : 'Not a Palindrome'
}

export { checkPalindrome }
/**
 * Hamming Distance: https://en.wikipedia.org/wiki/Hamming_distance
 *
 *
 * Hamming distance is a metric for comparing two binary data strings.
 *
 * While comparing two binary strings of equal length, Hamming distance
 * is the number of bit positions in which the two bits are different.
 * The Hamming distance between two strings, a and b is denoted as d(a,b)
 */

/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */

export const hammingDistance = (a, b) => {
  if (a.length !== b.length) {
    throw new Error('Strings must be of the same length')
  }

  let distance = 0

  for (let i = 0; i < a.length; i += 1) {
    if (a[i] !== b[i]) {
      distance += 1
    }
  }

  return distance
}
// Implementing KMP Search Algorithm to search all the instances of pattern in
// given text
// Reference Book: Introduction to Algorithms, CLRS

// Explanation: https://www.topcoder.com/community/competitive-programming/tutorials/introduction-to-string-searching-algorithms/

const computeLPS = (pattern) => {
  const lps = Array(pattern.length)
  lps[0] = 0
  for (let i = 1; i < pattern.length; i++) {
    let matched = lps[i - 1]
    while (matched > 0 && pattern[i] !== pattern[matched]) {
      matched = lps[matched - 1]
    }
    if (pattern[i] === pattern[matched]) {
      matched++
    }
    lps[i] = matched
  }
  return lps
}

/**
 * Returns all indices where pattern starts in text
 * @param {*} text a big text in which pattern string is to find
 * @param {*} pattern the string to find
 */
const KMPSearch = (text, pattern) => {
  if (!pattern || !text) {
    return [] // no results
  }

  // lps[i] = length of proper prefix of pattern[0]...pattern[i-1]
  //          which is also proper suffix of it
  const lps = computeLPS(pattern)
  const result = []

  let matched = 0
  for (let i = 0; i < text.length; i++) {
    while (matched > 0 && text[i] !== pattern[matched]) {
      matched = lps[matched - 1]
    }
    if (text[i] === pattern[matched]) {
      matched++
    }
    if (matched === pattern.length) {
      result.push(i - pattern.length + 1)
      matched = lps[matched - 1]
    }
  }

  return result
}

export { KMPSearch }
// CheckPascalCase method checks the given string is in PascalCase or not.

// Problem Source & Explanation: https://www.theserverside.com/definition/Pascal-case

/**
 * CheckPascalCase method returns true if the string in PascalCase, else return the false.
 * @param {String} VarName the name of the variable to check.
 * @returns `Boolean` return true if the string is in PascalCase, else return false.
 */
const CheckPascalCase = (VarName) => {
  // firstly, check that input is a string or not.
  if (typeof VarName !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /^[A-Z][A-Za-z]*$/
  return pat.test(VarName)
}

export { CheckPascalCase }
/**
 * What is Pangram?
 * Pangram is a sentence that contains all the letters in the alphabet https://en.wikipedia.org/wiki/Pangram
 */

/**
 * @function checkPangramRegex
 * @description - This function check pangram with the help of regex pattern
 * @param {string} string
 * @returns {boolean}
 * @example - checkPangramRegex("'The quick brown fox jumps over the lazy dog' is a pangram") => true
 * @example - checkPangramRegex('"Waltz, bad nymph, for quick jigs vex." is a pangram') => true
 */
const checkPangramRegex = (string) => {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  /**
   * Match all 26 alphabets using regex, with the help of:
   * Capturing group - () -> Groups multiple tokens together and creates a capture group for extracting a substring or using a backreference.
   * Character set - [a-z] -> Matches a char in the range a to z in case-insensitive for the 'i' flag
   * Negative lookahead - (?!) -> Specifies a group that can not match after the main expression (if it matches, the result is discarded).
   * Dot - . -> Matches any character except linebreaks. Equivalent to
   * Star - * -> Matches 0 or more of the preceding token.
   * Numeric reference - \{$n} -> Matches the results of a capture group. E.g. - \1  matches the results of the first capture group & \3 matches the third.
 */
  return string.match(/([a-z])(?!.*\1)/gi).length === 26
}

/**
 * @function checkPangramSet
 * @description - This function detect the pangram sentence by HashSet
 * @param {string} string
 * @returns {boolean}
 */
const checkPangramSet = (string) => {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const lettersSet = new Set()

  for (const letter of string.toUpperCase()) {
    if (/[A-Z]/.test(letter)) {
      // if the letter is a valid uppercase alphabet then the add method insert the letter to the HashSet
      lettersSet.add(letter)
    }
  }

  return lettersSet.size === 26
}

export { checkPangramRegex, checkPangramSet }
/*
a permutation of a set is, loosely speaking, an arrangement of its members into a sequence or linear order, or if the set is already ordered, a rearrangement of its elements.
The word "permutation" also refers to the act or process of changing the linear order of an ordered set
More at : https://en.wikipedia.org/wiki/Permutation
*/

const createPermutations = (str) => {
// convert string to array
  const arr = str.split('')

  // get array length
  const strLen = arr.length
  // this will hold all the permutations
  const perms = []
  let rest
  let picked
  let restPerms
  let next

  // if strLen is zero, return the same string
  if (strLen === 0) { return [str] }
  // loop to the length to get all permutations
  for (let i = 0; i < strLen; i++) {
    rest = Object.create(arr)
    picked = rest.splice(i, 1)

    restPerms = createPermutations(rest.join(''))

    for (let j = 0, jLen = restPerms.length; j < jLen; j++) {
      next = picked.concat(restPerms[j])
      perms.push(next.join(''))
    }
  }
  return perms
}
export { createPermutations }
/* The SrensenDice coefficient is a statistic used to gauge the similarity of two samples.
 * Applied to strings, it can give you a value between 0 and 1 (included) which tells you how similar they are.
 * Dice coefficient is calculated by comparing the bigrams of both strings,
 * a bigram is a substring of the string of length 2.
 * read more: https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient
 */

// Time complexity: O(m + n), m and n being the sizes of string A and string B

// Find the bistrings of a string and return a hashmap (key => bistring, value => count)
function mapBigrams (string) {
  const bigrams = new Map()
  for (let i = 0; i < string.length - 1; i++) {
    const bigram = string.substring(i, i + 2)
    const count = bigrams.get(bigram)
    bigrams.set(bigram, (count || 0) + 1)
  }
  return bigrams
}

// Calculate the number of common bigrams between a map of bigrams and a string

function countCommonBigrams (bigrams, string) {
  let count = 0
  for (let i = 0; i < string.length - 1; i++) {
    const bigram = string.substring(i, i + 2)
    if (bigrams.has(bigram)) count++
  }
  return count
}

// Calculate Dice coeff of 2 strings
function diceCoefficient (stringA, stringB) {
  if (stringA === stringB) return 1
  else if (stringA.length < 2 || stringB.length < 2) return 0

  const bigramsA = mapBigrams(stringA)

  const lengthA = stringA.length - 1
  const lengthB = stringB.length - 1

  let dice = (2 * countCommonBigrams(bigramsA, stringB)) / (lengthA + lengthB)

  // cut 0.xxxxxx to 0.xx for simplicity
  dice = Math.floor(dice * 100) / 100

  return dice
}

export { diceCoefficient }
/*
Generates a UUID/GUID in Node.Js.
The script uses `Math.random` in combination with the timestamp for better randomness.
The function generate an RFC4122 (https://www.ietf.org/rfc/rfc4122.txt) version 4 UUID/GUID
*/

export const Guid = () => {
  const pattern = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
  let currentDateMilliseconds = new Date().getTime()
  return pattern.replace(/[xy]/g, currentChar => {
    const randomChar = (currentDateMilliseconds + Math.random() * 16) % 16 | 0
    currentDateMilliseconds = Math.floor(currentDateMilliseconds / 16)
    return (currentChar === 'x' ? randomChar : (randomChar & 0x7 | 0x8)).toString(16)
  })
}

// > Guid()
// 'edc848db-3478-1760-8b55-7986003d895f'
/**
 * @function countVowels
 * @description Given a string of words or phrases, count the number of vowels.
 * @param {String} str - The input string
 * @return {Number} - The number of vowels
 * @example countVowels("ABCDE") => 2
 * @example countVowels("Hello") => 2
 */

const countVowels = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Input should be a string')
  }

  const vowelRegex = /[aeiou]/gi
  const vowelsArray = str.match(vowelRegex) || []

  return vowelsArray.length
}

export { countVowels }
/**
 * @function reverseWords
 * @param {string} str
 * @returns {string} - reverse string
 */
const reverseWords = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  return str
    .split(/\s+/) // create an array with each word in string
    .reduceRight((reverseStr, word) => `${reverseStr} ${word}`, '') // traverse the array from last & create an string
    .trim() // remove the first useless space
}

export default reverseWords
/**
  * What is a palindrome? https://en.wikipedia.org/wiki/Palindrome
  * Receives a string and returns whether it can be rearranged to become a palindrome or not
  * The string can only be a palindrome if the count of ALL characters is even or if the ONLY ONE character count is odd
  * Input is a string
  *
  **/

export const palindromeRearranging = (str) => {
  // check that input is a string
  if (typeof str !== 'string') {
    return 'Not a string'
  }
  // Check if is a empty string
  if (str.length === 0) {
    return 'Empty string'
  }

  // First obtain the character count for each character in the string and store it in an object.
  // Filter the object's values to only the odd character counts.
  const charCounts = [...str].reduce((counts, char) => {
    counts[char] = counts[char] ? counts[char] + 1 : 1
    return counts
  }, {})
  // If the length of the resulting array is 0 or 1, the string can be a palindrome.
  return Object.values(charCounts).filter(count => count % 2 !== 0).length <= 1
}

// testing

// > palindromeRearranging('aaeccrr')
// true

// > palindromeRearranging('leve')
// false
/*
 *
 *
 *Implementation of the Boyer-Moore String Search Algorithm.
 *The BoyerMoore string search algorithm allows linear time in
 *search by skipping indices when searching inside a string for a pattern.
 *
 *
 *
 *
 **/
const buildBadMatchTable = (str) => {
  const tableObj = {}
  const strLength = str.length
  for (let i = 0; i < strLength - 1; i++) {
    tableObj[str[i]] = strLength - 1 - i
  }
  if (tableObj[str[strLength - 1]] === undefined) {
    tableObj[str[strLength - 1]] = strLength
  }
  return tableObj
}

const boyerMoore = (str, pattern) => {
  const badMatchTable = buildBadMatchTable(pattern)
  let offset = 0
  const patternLastIndex = pattern.length - 1
  const maxOffset = str.length - pattern.length
  // if the offset is bigger than maxOffset, cannot be found
  while (offset <= maxOffset) {
    let scanIndex = 0
    while (pattern[scanIndex] === str[scanIndex + offset]) {
      if (scanIndex === patternLastIndex) {
        // found at this index
        return offset
      }
      scanIndex++
    }
    const badMatchString = str[offset + patternLastIndex]
    if (badMatchTable[badMatchString]) {
      // increase the offset if it exists
      offset += badMatchTable[badMatchString]
    } else {
      offset++
    }
  }
  return -1
}
export { boyerMoore }
/**
 * @function alphaNumericPalindrome
 * @description alphaNumericPalindrome should return true if the string has alphanumeric characters that are palindrome irrespective of special characters and the letter case.
 * @param {string} str the string to check
 * @returns {boolean}
 * @see [Palindrome](https://en.wikipedia.org/wiki/Palindrome)
 * @example
 * The function alphaNumericPalindrome() receives a string with varying formats
 * like "racecar", "RaceCar", and "race CAR"
 * The string can also have special characters
 * like "2A3*3a2", "2A3 3a2", and "2_A3*3#A2"
 *
 * But the catch is, we have to check only if the alphanumeric characters
 * are palindrome i.e remove spaces, symbols, punctuations etc
 * and the case of the characters doesn't matter
 */
const alphaNumericPalindrome = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be string')
  }

  // removing all the special characters and turning everything to lowercase
  const newStr = str.replace(/[^a-z0-9]+/ig, '').toLowerCase()
  const midIndex = newStr.length >> 1 // x >> y = floor(x / 2^y)

  for (let i = 0; i < midIndex; i++) {
    if (newStr.at(i) !== newStr.at(~i)) { // ~n = -(n + 1)
      return false
    }
  }

  return true
}

export default alphaNumericPalindrome
/**
 * A short example showing how to reverse a string.
 */
function ReverseStringIterative (string) {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }
  let reversedString = ''
  let index

  for (index = string.length - 1; index >= 0; index--) {
    reversedString += string[index]
  }

  return reversedString
}

/**
 * JS disallows string mutation so we're actually a bit slower.
 *
 * @complexity O(n)
 */
function ReverseStringIterativeInplace (string) {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const _string = string.split('')

  for (let i = 0; i < Math.floor(_string.length / 2); i++) {
    const first = _string[i]
    _string[i] = _string[_string.length - 1 - i]
    _string[_string.length - 1 - i] = first
  }

  return _string.join('')
}

export { ReverseStringIterative, ReverseStringIterativeInplace }
// CheckCamelCase method checks the given string is in camelCase or not.

// Problem Source & Explanation: https://en.wikipedia.org/wiki/Camel_case

/**
 * checkCamelCase method returns true if the string in camelCase, else return the false.
 * @param {String} varName the name of the variable to check.
 * @returns `Boolean` return true if the string is in camelCase, else return false.
 */
const checkCamelCase = (varName) => {
  // firstly, check that input is a string or not.
  if (typeof varName !== 'string') {
    throw new TypeError('Argument is not a string.')
  }

  const pat = /^[a-z][A-Za-z]*$/
  return pat.test(varName)
}

export { checkCamelCase }
/**
 * Validate a given credit card number
 *
 * The core of the validation of credit card numbers is the Luhn algorithm.
 *
 * The validation sum should be completely divisible by 10 which is calculated as follows,
 * every first digit is added directly to the validation sum.
 * For every second digit in the credit card number, the digit is multiplied by 2.
 * If the product is greater than 10 the digits of the product are added.
 * This resultant digit is considered for the validation sum rather than the digit itself.
 *
 * Ref: https://www.geeksforgeeks.org/luhn-algorithm/
 */

const luhnValidation = (creditCardNumber) => {
  let validationSum = 0
  creditCardNumber.split('').forEach((digit, index) => {
    let currentDigit = parseInt(digit)
    if (index % 2 === 0) {
      // Multiply every 2nd digit from the left by 2
      currentDigit *= 2
      // if product is greater than 10 add the individual digits of the product to get a single digit
      if (currentDigit > 9) {
        currentDigit %= 10
        currentDigit += 1
      }
    }
    validationSum += currentDigit
  })

  return validationSum % 10 === 0
}

const validateCreditCard = (creditCardString) => {
  const validStartSubString = ['4', '5', '6', '37', '34', '35'] // Valid credit card numbers start with these numbers

  if (typeof creditCardString !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const errorMessage = `${creditCardString} is an invalid credit card number because `
  if (isNaN(creditCardString)) {
    throw new TypeError(errorMessage + 'it has nonnumerical characters.')
  }
  const creditCardStringLength = creditCardString.length
  if (!((creditCardStringLength >= 13) && (creditCardStringLength <= 16))) {
    throw new Error(errorMessage + 'of its length.')
  }
  if (!validStartSubString.some(subString => creditCardString.startsWith(subString))) {
    throw new Error(errorMessage + 'of its first two digits.')
  }
  if (!luhnValidation(creditCardString)) {
    throw new Error(errorMessage + 'it fails the Luhn check.')
  }

  return true
}

export { validateCreditCard }
// An [Anagram](https://en.wikipedia.org/wiki/Anagram) is a string that is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Anagram check is not case-sensitive;
/**
 * @function checkAnagramRegex
 * @param {string} str1
 * @param {string} str2
 * @returns {boolean}
 * @description - check anagram with the help of Regex
 * @example - checkAnagramRegex('node', 'deno') => true
 * @example - checkAnagramRegex('Eleven plus two', 'Twelve plus one') => true
 */
const checkAnagramRegex = (str1, str2) => {
  // check that inputs are strings.
  if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    throw new TypeError('Both arguments should be strings.')
  }

  // If both strings have not same lengths then they can not be anagram.
  if (str1.length !== str2.length) {
    return false
  }

  /**
   * str1 converted to an array and traverse each letter of str1 by reduce method
   * reduce method return string which is empty or not.
   * if it returns empty string '' -> falsy, with Logical !(NOT) Operator, it's will be converted to boolean and return true else false
   */
  return ![...str1].reduce(
    (str2Acc, cur) => str2Acc.replace(new RegExp(cur, 'i'), ''), // remove the similar letter from str2Acc in case-insensitive
    str2
  )
}

/**
 * @function checkAnagramMap
 * @description - check anagram via using HashMap
 * @param {string} str1
 * @param {string} str2
 * @returns {boolean}
 * @example - checkAnagramMap('node', 'deno') => true
 * @example - checkAnagramMap('Eleven plus two', 'Twelve plus one') => true
 */
const checkAnagramMap = (str1, str2) => {
  // check that inputs are strings.
  if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    throw new TypeError('Both arguments should be strings.')
  }

  // If both strings have not same lengths then they can not be anagram.
  if (str1.length !== str2.length) {
    return false
  }

  const str1List = Array.from(str1.toUpperCase()) // str1 to array

  // get the occurrences of str1 characters by using HashMap
  const str1Occurs = str1List.reduce(
    (map, char) => map.set(char, map.get(char) + 1 || 1),
    new Map()
  )

  for (const char of str2.toUpperCase()) {
    // if char has not exist to the map it's return false
    if (!str1Occurs.has(char)) {
      return false
    }

    let getCharCount = str1Occurs.get(char)
    str1Occurs.set(char, --getCharCount)

    getCharCount === 0 && str1Occurs.delete(char)
  }

  return true
}

export { checkAnagramRegex, checkAnagramMap }
// Alternative arrange the two given strings in one string in O(n) time complexity.

// Problem Source & Explanation: https://www.geeksforgeeks.org/alternatively-merge-two-strings-in-java/

/**
 * Alternative arrange the two given strings in one string in O(n) time complexity.
 * @param {String} str1 first input string
 * @param {String} str2 second input string
 * @returns `String` return one alternative arrange string.
 */
const AlternativeStringArrange = (str1, str2) => {
  // firstly, check that both inputs are strings.
  if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    return 'Not string(s)'
  }

  // output string value.
  let outStr = ''

  // get first string length.
  const firstStringLength = str1.length
  // get second string length.
  const secondStringLength = str2.length
  // absolute length for operation.
  const absLength = firstStringLength > secondStringLength ? firstStringLength : secondStringLength

  // Iterate the character count until the absolute count is reached.
  for (let charCount = 0; charCount < absLength; charCount++) {
    // If firstStringLength is lesser than the charCount it means they are able to re-arrange.
    if (charCount < firstStringLength) {
      outStr += str1[charCount]
    }

    // If secondStringLength is lesser than the charCount it means they are able to re-arrange.
    if (charCount < secondStringLength) {
      outStr += str2[charCount]
    }
  }

  // return the output string.
  return outStr
}

export { AlternativeStringArrange }
/*
Pattern matching is case insensitive as
the inputs are converted to lower case before the
algorithm is run.

The algorithm will run through the entire text and
return the starting index if the given pattern is
available in the text
*/
const checkIfPatternExists = (text, pattern) => {
  if (typeof text !== 'string' || typeof pattern !== 'string') {
    throw new TypeError('Given input is not a string')
  }
  const textLength = text.length // Store the length of the text in a variable
  const patternLength = pattern.length // Store the length of the pattern in a variable

  // Iterate through the text until the textlength - patternlength index
  for (let i = 0; i <= textLength - patternLength; i++) {
    // For each character in the text check if the subsequent character
    // are matching the given pattern; if not break from the condition
    for (let j = 0; j < textLength; j++) {
      if (text[i + j] !== pattern[j]) break

      // For each iteration of j check if the value of
      // j + 1 is equal to the length of the pattern
      if (j + 1 === patternLength) {
        return `Given pattern is found at index ${i}`
      }
    }
  }
}

export { checkIfPatternExists }
/* The Levenshtein distance (a.k.a edit distance) is a
measure of similarity between two strings. It is
defined as the minimum number of changes required to
convert string a into string b (this is done by
inserting, deleting or replacing a character in
string a).
The smaller the Levenshtein distance,
the more similar the strings are. This is a very
common problem in the application of Dynamic Programming.
*/

const levenshteinDistance = (a, b) => {
  // Declaring array 'D' with rows = len(a) + 1 and columns = len(b) + 1:
  const distanceMatrix = Array(b.length + 1)
    .fill(null)
    .map(() => Array(a.length + 1).fill(null))

  // Initializing first column:
  for (let i = 0; i <= a.length; i += 1) {
    distanceMatrix[0][i] = i
  }

  // Initializing first row:
  for (let j = 0; j <= b.length; j += 1) {
    distanceMatrix[j][0] = j
  }

  for (let j = 1; j <= b.length; j += 1) {
    for (let i = 1; i <= a.length; i += 1) {
      const indicator = a[i - 1] === b[j - 1] ? 0 : 1
      // choosing the minimum of all three, vis-a-vis:
      distanceMatrix[j][i] = Math.min(
        distanceMatrix[j][i - 1] + 1, // deletion
        distanceMatrix[j - 1][i] + 1, // insertion
        distanceMatrix[j - 1][i - 1] + indicator // substitution
      )
    }
  }

  return distanceMatrix[b.length][a.length]
}

export { levenshteinDistance }
// checkFlatCase method checks if the given string is in flatcase or not. Flatcase is a convention
// where all letters are in lowercase, and there are no spaces between words.
// thisvariable is an example of flatcase. In camelCase it would be thisVariable, snake_case this_variable and so on.

// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)

/**
 * checkFlatCase method returns true if the string in flatcase, else return the false.
 * @param {string} varname the name of the variable to check.
 * @returns {boolean} return true if the string is in flatcase, else return false.
 */
const checkFlatCase = (varname) => {
  // firstly, check that input is a string or not.
  if (typeof varname !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /^[a-z]*$/
  return pat.test(varname)
}

export { checkFlatCase }
// CheckKebabCase method checks the given string is in kebab-case or not.

// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)

/**
 * CheckKebabCase method returns true if the string in kebab-case, else return the false.
 * @param {String} varName the name of the variable to check.
 * @returns `Boolean` return true if the string is in kebab-case, else return false.
 */
const CheckKebabCase = (varName) => {
  // firstly, check that input is a string or not.
  if (typeof varName !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /(\w+)-(\w)([\w-]*)/
  return pat.test(varName) && !varName.includes('_')
}

export { CheckKebabCase }
'use strict'

const permutate = (aString) => {
  if (typeof aString !== 'string' || !aString) {
    throw new Error('The arg must be a valid, non empty string')
  }
  const characters = aString.split('')
  let permutations = [[characters.shift()]]
  while (characters.length) {
    const currentCharacter = characters.shift()
    permutations = calculateCurrentCharacterPermutation(permutations, currentCharacter)
  }
  return permutations
    .map(character => character.join(''))
    .filter((item, index, self) => (self.indexOf(item) === index))
    .sort()
}

const calculateCurrentCharacterPermutation = (allPermutations, currentCharacter) => {
  const currentPermutations = []
  allPermutations.forEach(permutation => {
    let index = 0
    while (index <= permutation.length) {
      const tmp = [...permutation]
      tmp.splice(index, 0, currentCharacter)
      currentPermutations.push(tmp)
      index++
    }
  })
  return currentPermutations
}

export { permutate }
/**
 * @function lower
 * @description Will convert the entire string to lowercase letters.
 * @param {String} str - The input string
 * @returns {String} Lowercase string
 * @example lower("HELLO") => hello
 * @example lower("He_llo") => he_llo
 */

const lower = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Invalid Input Type')
  }

  return str.replace(
    /[A-Z]/g, (char) => String.fromCharCode(char.charCodeAt() + 32)
  )
}

export default lower
/**
 * @function maxCharacter
 * @example - Given a string of characters, return the character that appears the most often. Example: input = "Hello World!" return "l"
 * @param {string} str
 * @param {RegExp} ignorePattern - ignore the char in str that is not required
 * @returns {string} - char
 */
const maxCharacter = (str, ignorePattern) => { // initially it's count only alphabets
  if (typeof str !== 'string') {
    throw new TypeError('Argument should be a string')
  } else if (!str) {
    throw new Error('The param should be a nonempty string')
  }

  // store all char in occurrence map
  const occurrenceMap = new Map()

  for (const char of str) {
    if (!ignorePattern?.test(char)) {
      occurrenceMap.set(char, occurrenceMap.get(char) + 1 || 1)
    }
  }

  // find the max char from the occurrence map
  let max = { char: '', occur: -Infinity }

  for (const [char, occur] of occurrenceMap) {
    if (occur > max.occur) {
      max = { char, occur }
    }
  }

  return max.char
}

export default maxCharacter
/**
 * @function checkWordOccurrence
 * @description - this function count all the words in a sentence and return an word occurrence object
 * @param {string} str
 * @param {boolean} isCaseSensitive
 * @returns {Object}
 */
const checkWordOccurrence = (str, isCaseSensitive = false) => {
  if (typeof str !== 'string') {
    throw new TypeError('The first param should be a string')
  }

  if (typeof isCaseSensitive !== 'boolean') {
    throw new TypeError('The second param should be a boolean')
  }

  const modifiedStr = isCaseSensitive ? str.toLowerCase() : str

  return modifiedStr
    .split(/\s+/) // remove all spaces and distribute all word in List
    .reduce(
      (occurrence, word) => {
        occurrence[word] = occurrence[word] + 1 || 1
        return occurrence
      },
      {}
    )
}

export { checkWordOccurrence }
// Given a sentence, return the most occurring word

/**
 * @param {string} sentence - the sentence you want to find the most occurring word
 * @returns {string} - the most occurring word
 *
 * @example
 *     -  maxWord('lala lili lala'); // lala
 */
const maxWord = (sentence = '') => {
  if (typeof sentence !== 'string') {
    throw new TypeError('the param should be string')
  }

  if (!sentence) {
    return null
  }

  const words = sentence.split(' ')
  if (words.length < 2) {
    return words[0]
  }

  const occurrences = {}
  words.forEach(word => {
    occurrences[word.toLocaleLowerCase()] = occurrences[word.toLocaleLowerCase()] + 1 || 1
  })

  const max = Object.keys(occurrences).reduce((n, word) => {
    if (occurrences[word] > n.count) { return { word, count: occurrences[word] } } else { return n }
  }, { word: '', count: 0 })

  return max.word
}

export { maxWord }
/**
 * @description - function that takes 10 digits and returns a string of the formatted phone number e.g.: 1234567890 -> (123) 456-7890
 * @param {string} phoneNumber
 * @returns {string} - Format to (XXX) XXX-XXXX pattern
 */
const formatPhoneNumber = (phoneNumber) => {
  if ((phoneNumber.length !== 10) || isNaN(phoneNumber)) {
    // return "Invalid phone number."
    throw new TypeError('Invalid phone number!')
  }

  let index = 0
  return '(XXX) XXX-XXXX'.replace(/X/g, () => phoneNumber[index++])
}

export default formatPhoneNumber
/**
 * @function ValidateURL
 * @description validate the URL.
 * @param {String} url - The input URL string
 * @return {Boolean}
 */
const validateURL = (url) => {
  const URL_PATTERN = /^(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})$/gi

  return URL_PATTERN.test(url)
}

export { validateURL }
// Priority Queue Helper functions
function getParentPosition (position) {
  // Get the parent node of the current node
  return Math.floor((position - 1) / 2)
}
function getChildrenPosition (position) {
  // Get the children nodes of the current node
  return [2 * position + 1, 2 * position + 2]
}

class PriorityQueue {
  // Priority Queue class using Minimum Binary Heap
  constructor () {
    this._heap = []
    this.keys = {}
  }

  isEmpty () {
    // Checking if the heap is empty
    return this._heap.length === 0
  }

  push (key, priority) {
    // Adding element to the queue (equivalent to add)
    this._heap.push([key, priority])
    this.keys[key] = this._heap.length - 1
    this._shiftUp(this.keys[key])
  }

  pop () {
    // Removing the element with least priority (equivalent to extractMin)
    this._swap(0, this._heap.length - 1)
    const [key] = this._heap.pop()
    delete this.keys[key]
    this._shiftDown(0)
    return key
  }

  contains (key) {
    // Check if a given key is present in the queue
    return (key in this.keys)
  }

  update (key, priority) {
    // Update the priority of the given element (equivalent to decreaseKey)
    const currPos = this.keys[key]
    this._heap[currPos][1] = priority
    const parentPos = getParentPosition(currPos)
    const currPriority = this._heap[currPos][1]
    let parentPriority = Infinity
    if (parentPos >= 0) {
      parentPriority = this._heap[parentPos][1]
    }
    const [child1Pos, child2Pos] = getChildrenPosition(currPos)
    let [child1Priority, child2Priority] = [Infinity, Infinity]
    if (child1Pos < this._heap.length) {
      child1Priority = this._heap[child1Pos][1]
    }
    if (child2Pos < this._heap.length) {
      child2Priority = this._heap[child2Pos][1]
    }

    if (parentPos >= 0 && parentPriority > currPriority) {
      this._shiftUp(currPos)
    } else if (child2Pos < this._heap.length &&
      (child1Priority < currPriority || child2Priority < currPriority)) {
      this._shiftDown(currPos)
    }
  }

  _shiftUp (position) {
    // Helper function to shift up a node to proper position (equivalent to bubbleUp)
    let currPos = position
    let parentPos = getParentPosition(currPos)
    let currPriority = this._heap[currPos][1]
    let parentPriority = Infinity
    if (parentPos >= 0) {
      parentPriority = this._heap[parentPos][1]
    }

    while (parentPos >= 0 && parentPriority > currPriority) {
      this._swap(currPos, parentPos)
      currPos = parentPos
      parentPos = getParentPosition(currPos)
      currPriority = this._heap[currPos][1]
      try {
        parentPriority = this._heap[parentPos][1]
      } catch (error) {
        parentPriority = Infinity
      }
    }
    this.keys[this._heap[currPos][0]] = currPos
  }

  _shiftDown (position) {
    // Helper function to shift down a node to proper position (equivalent to bubbleDown)
    let currPos = position
    let [child1Pos, child2Pos] = getChildrenPosition(currPos)
    let [child1Priority, child2Priority] = [Infinity, Infinity]
    if (child1Pos < this._heap.length) {
      child1Priority = this._heap[child1Pos][1]
    }
    if (child2Pos < this._heap.length) {
      child2Priority = this._heap[child2Pos][1]
    }
    let currPriority
    try {
      currPriority = this._heap[currPos][1]
    } catch {
      return
    }

    while (child2Pos < this._heap.length &&
      (child1Priority < currPriority || child2Priority < currPriority)) {
      if (child1Priority < currPriority && child1Priority < child2Priority) {
        this._swap(child1Pos, currPos)
        currPos = child1Pos
      } else {
        this._swap(child2Pos, currPos)
        currPos = child2Pos
      }
      [child1Pos, child2Pos] = getChildrenPosition(currPos)
      try {
        [child1Priority, child2Priority] = [this._heap[child1Pos][1], this._heap[child2Pos][1]]
      } catch (error) {
        [child1Priority, child2Priority] = [Infinity, Infinity]
      }

      currPriority = this._heap[currPos][1]
    }
    this.keys[this._heap[currPos][0]] = currPos
    if (child1Pos < this._heap.length && child1Priority < currPriority) {
      this._swap(child1Pos, currPos)
      this.keys[this._heap[child1Pos][0]] = child1Pos
    }
  }

  _swap (position1, position2) {
    // Helper function to swap 2 nodes
    [this._heap[position1], this._heap[position2]] = [this._heap[position2], this._heap[position1]]
    this.keys[this._heap[position1][0]] = position1
    this.keys[this._heap[position2][0]] = position2
  }
}

class GraphWeightedUndirectedAdjacencyList {
  // Weighted Undirected Graph class
  constructor () {
    this.connections = {}
  }

  addNode (node) {
    // Function to add a node to the graph (connection represented by set)
    this.connections[node] = {}
  }

  addEdge (node1, node2, weight) {
    // Function to add an edge (adds the node too if they are not present in the graph)
    if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1][node2] = weight
    this.connections[node2][node1] = weight
  }

  PrimMST (start) {
    // Prim's Algorithm to generate a Minimum Spanning Tree (MST) of a graph
    // Details: https://en.wikipedia.org/wiki/Prim%27s_algorithm
    const distance = {}
    const parent = {}
    const priorityQueue = new PriorityQueue()
    // Initialization
    for (const node in this.connections) {
      distance[node] = (node === start.toString() ? 0 : Infinity)
      parent[node] = null
      priorityQueue.push(node, distance[node])
    }
    // Updating 'distance' object
    while (!priorityQueue.isEmpty()) {
      const node = priorityQueue.pop()
      Object.keys(this.connections[node]).forEach(neighbour => {
        if (priorityQueue.contains(neighbour) && distance[node] + this.connections[node][neighbour] < distance[neighbour]) {
          distance[neighbour] = distance[node] + this.connections[node][neighbour]
          parent[neighbour] = node
          priorityQueue.update(neighbour, distance[neighbour])
        }
      })
    }

    // MST Generation from the 'parent' object
    const graph = new GraphWeightedUndirectedAdjacencyList()
    Object.keys(parent).forEach(node => {
      if (node && parent[node]) {
        graph.addEdge(node, parent[node], this.connections[node][parent[node]])
      }
    })
    return graph
  }
}

export { GraphWeightedUndirectedAdjacencyList }

// const graph = new GraphWeightedUndirectedAdjacencyList()
// graph.addEdge(1, 2, 1)
// graph.addEdge(2, 3, 2)
// graph.addEdge(3, 4, 1)
// graph.addEdge(3, 5, 100) // Removed in MST
// graph.addEdge(4, 5, 5)
// graph.PrimMST(1)
import { BellmanFord } from '../BellmanFord.js'

test('Test Case 1', () => {
  const V = 5
  const E = 8
  const destination = 3
  const graph = [[0, 1, -1], [0, 2, 4],
    [1, 2, 3], [1, 3, 2],
    [1, 4, 2], [3, 2, 5],
    [3, 1, 1], [4, 3, -3]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(-2)
})
test('Test Case 2', () => {
  const V = 6
  const E = 9
  const destination = 4
  const graph = [[0, 1, 3], [0, 3, 6],
    [0, 5, -1], [1, 2, -3],
    [1, 4, -2], [5, 2, 5],
    [2, 3, 1], [4, 3, 5], [5, 4, 2]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(1)
})
test('Test Case 3', () => {
  const V = 4
  const E = 5
  const destination = 1
  const graph = [[0, 3, -1], [0, 2, 4],
    [3, 2, 2], [3, 1, 5],
    [2, 1, -1]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(0)
})
import { breadthFirstSearch } from '../BreadthFirstSearch'

describe('BreadthFirstSearch', () => {
  const graph = {
    A: ['B', 'D'],
    B: ['E'],
    C: ['D'],
    D: ['A'],
    E: ['D'],
    F: ['G'],
    G: []
  }
  /*
        A <-> B
             |
        |     |
        v     v
  C --> D <-- E

  F --> G
  */

  it('should return the visited nodes', () => {
    expect(Array.from(breadthFirstSearch(graph, 'C'))).toEqual(['C', 'D', 'A', 'B', 'E'])
    expect(Array.from(breadthFirstSearch(graph, 'A'))).toEqual(['A', 'B', 'D', 'E'])
    expect(Array.from(breadthFirstSearch(graph, 'F'))).toEqual(['F', 'G'])
  })
})
import { breadthFirstShortestPath } from '../BreadthFirstShortestPath'

describe('BreadthFirstShortestPath', () => {
  const graph = {
    A: ['B', 'D'],
    B: ['E'],
    C: ['D'],
    D: ['A'],
    E: ['D'],
    F: ['G'],
    G: []
  }
  /*
        A <-> B
             |
        |     |
        v     v
  C --> D <-- E

  F --> G
  */

  it('should return the visited nodes', () => {
    expect(breadthFirstShortestPath(graph, 'C', 'E')).toEqual(['C', 'D', 'A', 'B', 'E'])
    expect(breadthFirstShortestPath(graph, 'E', 'B')).toEqual(['E', 'D', 'A', 'B'])
    expect(breadthFirstShortestPath(graph, 'F', 'G')).toEqual(['F', 'G'])
    expect(breadthFirstShortestPath(graph, 'A', 'G')).toEqual([])
  })
})
/**
 * Breadth-first approach can be applied to determine the shortest path between two nodes in an equi-weighted graph.
 *
 * It searches the target node among all neighbors of the starting node, then the process is repeated on the level of
 * the neighbors of the neighbors and so on.
 *
 * @see https://en.wikipedia.org/wiki/Breadth-first_search
 * @see https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core
 */
export function breadthFirstShortestPath (graph, startNode, targetNode) {
  // check if startNode & targetNode are identical
  if (startNode === targetNode) {
    return [startNode]
  }

  // visited keeps track of all nodes visited
  const visited = new Set()

  // queue contains the paths to be explored in the future
  const initialPath = [startNode]
  const queue = [initialPath]

  while (queue.length > 0) {
    // start with the queue's first path
    const path = queue.shift()
    const node = path[path.length - 1]

    // explore this node if it hasn't been visited yet
    if (!visited.has(node)) {
      // mark the node as visited
      visited.add(node)

      const neighbors = graph[node]

      // create a new path in the queue for each neighbor
      for (let i = 0; i < neighbors.length; i++) {
        const newPath = path.concat([neighbors[i]])

        // the first path to contain the target node is the shortest path
        if (neighbors[i] === targetNode) {
          return newPath
        }

        // queue the new path
        queue.push(newPath)
      }
    }
  }

  // the target node was not reachable
  return []
}
/**
 * Author: Samarth Jain
 * Dijkstra's Algorithm implementation in JavaScript
 * Dijkstra's Algorithm calculates the minimum distance between two nodes.
 * It is used to find the shortest path.
 * It uses graph data structure.
 */

function createGraph (V, E) {
  // V - Number of vertices in graph
  // E - Number of edges in graph (u,v,w)
  const adjList = [] // Adjacency list
  for (let i = 0; i < V; i++) {
    adjList.push([])
  }
  for (let i = 0; i < E.length; i++) {
    adjList[E[i][0]].push([E[i][1], E[i][2]])
    adjList[E[i][1]].push([E[i][0], E[i][2]])
  }
  return adjList
}

function djikstra (graph, V, src) {
  const vis = Array(V).fill(0)
  const dist = []
  for (let i = 0; i < V; i++) dist.push([10000, -1])
  dist[src][0] = 0

  for (let i = 0; i < V - 1; i++) {
    let mn = -1
    for (let j = 0; j < V; j++) {
      if (vis[j] === 0) {
        if (mn === -1 || dist[j][0] < dist[mn][0]) mn = j
      }
    }

    vis[mn] = 1
    for (let j = 0; j < graph[mn].length; j++) {
      const edge = graph[mn][j]
      if (vis[edge[0]] === 0 && dist[edge[0]][0] > dist[mn][0] + edge[1]) {
        dist[edge[0]][0] = dist[mn][0] + edge[1]
        dist[edge[0]][1] = mn
      }
    }
  }

  return dist
}

export { createGraph, djikstra }

// const V = 9
// const E = [
//   [0, 1, 4],
//   [0, 7, 8],
//   [1, 7, 11],
//   [1, 2, 8],
//   [7, 8, 7],
//   [6, 7, 1],
//   [2, 8, 2],
//   [6, 8, 6],
//   [5, 6, 2],
//   [2, 5, 4],
//   [2, 3, 7],
//   [3, 5, 14],
//   [3, 4, 9],
//   [4, 5, 10]
// ]

// const graph = createGraph(V, E)
// const distances = djikstra(graph, V, 0)

/**
 * The first value in the array determines the minimum distance and the
 * second value represents the parent node from which the minimum distance has been calculated
 */
class GraphUnweightedUndirected {
  // Unweighted Undirected Graph class
  constructor () {
    this.connections = {}
  }

  addNode (node) {
    // Function to add a node to the graph (connection represented by set)
    this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
    // Function to add an edge (adds the node too if they are not present in the graph)
    if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSIterative (node, value) {
    // DFS Function to search if a node with the given value is present in the graph
    const stack = [node]
    const visited = new Set()
    while (stack.length > 0) {
      const currNode = stack.pop()
      // if the current node contains the value being searched for, true is returned
      if (currNode === value) { return true }
      // adding the current node to the visited set
      visited.add(currNode)
      // adding neighbours in the stack
      for (const neighbour of this.connections[currNode]) {
        if (!visited.has(neighbour)) {
          stack.push(neighbour)
        }
      }
    }
    return false
  }
}

export { GraphUnweightedUndirected }

// Example

// const graph = new GraphUnweightedUndirected()
// graph.addEdge(1, 2)
// graph.addEdge(2, 3)
// graph.addEdge(2, 4)
// graph.addEdge(3, 5)
// graph.DFSIterative(5, 1)
// graph.DFSIterative(5, 100)
/*
The BellmanFord algorithm is an algorithm that computes shortest paths
from a single source vertex to all of the other vertices in a weighted digraph.
It also detects negative weight cycle.

Complexity:
    Worst-case performance O(VE)
    Best-case performance O(E)
    Worst-case space complexity O(V)

Reference:
    https://en.wikipedia.org/wiki/BellmanFord_algorithm
    https://cp-algorithms.com/graph/bellman_ford.html

*/

/**
 *
 * @param graph Graph in the format (u, v, w) where
 *  the edge is from vertex u to v. And weight
 *  of the edge is w.
 * @param V Number of vertices in graph
 * @param E Number of edges in graph
 * @param src Starting node
 * @param dest Destination node
 * @returns Shortest distance from source to destination
 */
function BellmanFord (graph, V, E, src, dest) {
  // Initialize distance of all vertices as infinite.
  const dis = Array(V).fill(Infinity)
  // initialize distance of source as 0
  dis[src] = 0

  // Relax all edges |V| - 1 times. A simple
  // shortest path from src to any other
  // vertex can have at-most |V| - 1 edges
  for (let i = 0; i < V - 1; i++) {
    for (let j = 0; j < E; j++) {
      if ((dis[graph[j][0]] + graph[j][2]) < dis[graph[j][1]]) { dis[graph[j][1]] = dis[graph[j][0]] + graph[j][2] }
    }
  }
  // check for negative-weight cycles.
  for (let i = 0; i < E; i++) {
    const x = graph[i][0]
    const y = graph[i][1]
    const weight = graph[i][2]
    if ((dis[x] !== Infinity) && (dis[x] + weight < dis[y])) {
      return null
    }
  }
  for (let i = 0; i < V; i++) {
    if (i === dest) return dis[i]
  }
}

export { BellmanFord }
/**
 * Breadth-first search is an algorithm for traversing a graph.
 *
 * It discovers all nodes reachable from the starting position by exploring all of the neighbor nodes at the present
 * depth prior to moving on to the nodes at the next depth level.
 *
 * (description adapted from https://en.wikipedia.org/wiki/Breadth-first_search)
 * @see https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core
 */
export function breadthFirstSearch (graph, startingNode) {
  // visited keeps track of all nodes visited
  const visited = new Set()

  // queue contains the nodes to be explored in the future
  const queue = [startingNode]

  while (queue.length > 0) {
    // start with the queue's first node
    const node = queue.shift()

    if (!visited.has(node)) {
      // mark the node as visited
      visited.add(node)
      const neighbors = graph[node]

      // put all its neighbors into the queue
      for (let i = 0; i < neighbors.length; i++) {
        queue.push(neighbors[i])
      }
    }
  }

  return visited
}
/*
  Source:
    https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm

  Complexity:
    O(|V|^3) where V is the set of vertices
*/

const FloydWarshall = (dist) => {
  // Input:- dist: 2D Array where dist[i][j] = edge weight b/w i and j
  // Output:- dist: 2D Array where dist[i][j] = shortest dist b/w i and j
  const n = dist.length
  for (let k = 0; k < n; k++) {
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (dist[i][j] > dist[i][k] + dist[k][j]) {
          // dist from i to j via k is lesser than the current distance
          dist[i][j] = dist[i][k] + dist[k][j]
        }
      }
    }
  }
  return dist
}

export { FloydWarshall }

// For the following graph (edge weights are shown in brackets)
//  4       1       dist[1][2] = dist[2][1] = 1
//   \  (2)/ \      dist[1][3] = dist[3][1] = 2
//    \   /   \(1)  dist[1][4] = dist[4][1] = Infinity
//  (1)\ /     \    dist[3][4] = dist[4][3] = 1
//      3       2   dist[2][4] = dist[4][2] = Infinity
//                  dist[2][3] = dist[3][2] = Infinity
// Output should be:
// [ [0, 1, 2, 3],
//   [1, 0, 3, 4],
//   [2, 3, 0, 1],
//   [3, 4, 1, 0] ]

// FloydWarshall(
//     [[0, 1, 2, Infinity],
//       [1, 0, Infinity, Infinity],
//       [2, Infinity, 0, 1],
//       [Infinity, Infinity, 1, 0]
//     ]
//   )
/* Number of Islands
https://dev.to/rattanakchea/amazons-interview-question-count-island-21h6
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

a two dimensional grid map
each element is going to represent a piece of land
1 is land,
0 is water
output a number which is the number of islands

Example 1:
  Input:
  11110
  11010
  11000
  00000

  Output: 1

Example 2:
  Input:
  11000
  11000
  00100
  00011

  Output: 3

I: two dimensional array
O: a single integer; total number of islands

Pseudocode:
  OUTER FUNCTION
    set count to 0

    INNER FUNCTION - flood (col, row)
      if the tile is water
        return
      make tile water(flood tile)
      invoke flood on the neighbor coordinates

    iterate over the matrix (col, row)
      if the current element is a 1
        increment count
        invoke flood (coordinates for col and row)

    Return the count
*/

const islands = (matrixGrid) => {
  const matrix = matrixGrid
  let counter = 0

  const flood = (row, col) => {
    if (row < 0 || col < 0) return // Off the map above or left
    if (row >= matrix.length || col >= matrix[row].length) return // Off the map below or right

    const tile = matrix[row][col]
    if (tile !== '1') return

    matrix[row][col] = '0'

    flood(row + 1, col) // Down
    flood(row - 1, col) // Up
    flood(row, col + 1) // Right
    flood(row, col - 1) // Left
  }

  for (let row = 0; row < matrix.length; row += 1) {
    for (let col = 0; col < matrix[row].length; col += 1) {
      const current = matrix[row][col]
      if (current === '1') {
        flood(row, col)
        counter += 1
      }
    }
  }
  return counter
}

export { islands }

// islands(
//   ['1', '1', '0', '0', '0'],
//   ['1', '1', '0', '0', '0'],
//   ['0', '0', '1', '0', '0'],
//   ['0', '0', '0', '1', '1']
// )
class DisjointSetTreeNode {
  // Disjoint Set Node to store the parent and rank
  constructor (key) {
    this.key = key
    this.parent = this
    this.rank = 0
  }
}

class DisjointSetTree {
  // Disjoint Set DataStructure
  constructor () {
    // map to from node name to the node object
    this.map = {}
  }

  makeSet (x) {
    // Function to create a new set with x as its member
    this.map[x] = new DisjointSetTreeNode(x)
  }

  findSet (x) {
    // Function to find the set x belongs to (with path-compression)
    if (this.map[x] !== this.map[x].parent) {
      this.map[x].parent = this.findSet(this.map[x].parent.key)
    }
    return this.map[x].parent
  }

  union (x, y) {
    // Function to merge 2 disjoint sets
    this.link(this.findSet(x), this.findSet(y))
  }

  link (x, y) {
    // Helper function for union operation
    if (x.rank > y.rank) {
      y.parent = x
    } else {
      x.parent = y
      if (x.rank === y.rank) {
        y.rank += 1
      }
    }
  }
}

class GraphWeightedUndirectedAdjacencyList {
  // Weighted Undirected Graph class
  constructor () {
    this.connections = {}
    this.nodes = 0
  }

  addNode (node) {
    // Function to add a node to the graph (connection represented by set)
    this.connections[node] = {}
    this.nodes += 1
  }

  addEdge (node1, node2, weight) {
    // Function to add an edge (adds the node too if they are not present in the graph)
    if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1][node2] = weight
    this.connections[node2][node1] = weight
  }

  KruskalMST () {
    // Kruskal's Algorithm to generate a Minimum Spanning Tree (MST) of a graph
    // Details: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm
    // getting the edges in ascending order of weights
    const edges = []
    const seen = new Set()
    for (const start of Object.keys(this.connections)) {
      for (const end of Object.keys(this.connections[start])) {
        if (!seen.has(`${start} ${end}`)) {
          seen.add(`${end} ${start}`)
          edges.push([start, end, this.connections[start][end]])
        }
      }
    }
    edges.sort((a, b) => a[2] - b[2])
    // creating the disjoint set
    const disjointSet = new DisjointSetTree()
    Object.keys(this.connections).forEach(node => disjointSet.makeSet(node))
    // MST generation
    const graph = new GraphWeightedUndirectedAdjacencyList()
    let numEdges = 0
    let index = 0
    while (numEdges < this.nodes - 1) {
      const [u, v, w] = edges[index]
      index += 1
      if (disjointSet.findSet(u) !== disjointSet.findSet(v)) {
        numEdges += 1
        graph.addEdge(u, v, w)
        disjointSet.union(u, v)
      }
    }
    return graph
  }
}

export { GraphWeightedUndirectedAdjacencyList }

// const graph = new GraphWeightedUndirectedAdjacencyList()
// graph.addEdge(1, 2, 1)
// graph.addEdge(2, 3, 2)
// graph.addEdge(3, 4, 1)
// graph.addEdge(3, 5, 100) // Removed in MST
// graph.addEdge(4, 5, 5)
// graph.KruskalMST()
// https://en.wikipedia.org/wiki/Neighbourhood_(graph_theory)

class Graph {
  // Generic graph: the algorithm works regardless of direction or weight
  constructor () {
    this.edges = []
  }

  addEdge (node1, node2) {
    // Adding edges to the graph
    this.edges.push({
      node1,
      node2
    })
  }

  nodeNeighbors (node) {
    // Returns an array with all of the node neighbors
    const neighbors = new Set()
    for (const edge of this.edges) {
      // Checks if they have an edge between them and if the neighbor is not
      // already in the neighbors array
      if (edge.node1 === node && !(neighbors.has(edge.node2))) {
        neighbors.add(edge.node2)
      } else if (edge.node2 === node && !(neighbors.has(edge.node1))) {
        neighbors.add(edge.node1)
      }
    }
    return neighbors
  }
}

export { Graph }

// const graph = new Graph()
// graph.addEdge(1, 2)
// graph.addEdge(2, 3)
// graph.addEdge(3, 5)
// graph.addEdge(1, 5)
// graph.nodeNeighbors(1)
class GraphUnweightedUndirected {
  // Unweighted Undirected Graph class
  constructor () {
    this.connections = {}
  }

  addNode (node) {
    // Function to add a node to the graph (connection represented by set)
    this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
    // Function to add an edge (adds the node too if they are not present in the graph)
    if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSRecursive (node, value, visited = new Set()) {
    // DFS Function to search if a node with the given value is present in the graph
    // checking if the searching node has been found
    if (node === value) { return true }
    // adding the current node to the visited set
    visited.add(node)
    // calling the helper function recursively for all unvisited nodes
    for (const neighbour of this.connections[node]) {
      if (!visited.has(neighbour)) {
        if (this.DFSRecursive(neighbour, value, visited)) { return true }
      }
    }
    return false
  }
}

export { GraphUnweightedUndirected }

// const graph = new GraphUnweightedUndirected()
// graph.addEdge(1, 2)
// graph.addEdge(2, 3)
// graph.addEdge(2, 4)
// graph.addEdge(3, 5)
// graph.DFSRecursive(5, 1)
// graph.DFSRecursive(5, 100)
/*
The density of a network is a measure of how many edges exist proportional to
how many edges would exist in a complete network (where all possible edges).
https://networkx.org/documentation/networkx-1.9/reference/generated/networkx.classes.function.density.html
*/
function density (numberOfNodes, numberOfEdges, isDirected = false) {
  const multi = isDirected ? 1 : 2
  return (multi * numberOfEdges) / (numberOfNodes * (numberOfNodes - 1))
}

export { density }
class GraphUnweightedUndirectedAdjacencyList {
  // Unweighted Undirected Graph class
  constructor () {
    this.connections = {}
  }

  addNode (node) {
    // Function to add a node to the graph (connection represented by set)
    this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
    // Function to add an edge (adds the node too if they are not present in the graph)
    if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSComponent (components, node, visited) {
    // Helper function to populate the visited set with the nodes in each component

    // adding the first visited node in the component to the array
    components.push(node)
    const stack = [node]
    // populating the visited set using DFS (Iterative)
    while (stack.length > 0) {
      const curr = stack.pop()
      visited.add(curr.toString())
      for (const neighbour of this.connections[curr].keys()) {
        if (!visited.has(neighbour.toString())) { stack.push(neighbour) }
      }
    }
  }

  connectedComponents () {
    // Function to generate the Connected Components
    // Result is an array containing 1 node from each component
    const visited = new Set()
    const components = []
    for (const node of Object.keys(this.connections)) {
      if (!visited.has(node.toString())) { this.DFSComponent(components, node, visited) }
    }
    return components
  }
}

export { GraphUnweightedUndirectedAdjacencyList }

// Example

// const graph = new GraphUnweightedUndirectedAdjacencyList()
// graph.addEdge(1, 2) // Component 1
// graph.addEdge(3, 4) // Component 2
// graph.addEdge(3, 5) // Component 2
// const components = graph.connectedComponents()
// starting at s
function solve (graph, s) {
  const solutions = {}
  solutions[s] = []
  solutions[s].dist = 0

  while (true) {
    let p = null
    let neighbor = null
    let dist = Infinity

    for (const n in solutions) {
      if (!solutions[n]) { continue }
      const ndist = solutions[n].dist
      const adj = graph[n]

      for (const a in adj) {
        if (solutions[a]) { continue }

        const d = adj[a] + ndist
        if (d < dist) {
          p = solutions[n]
          neighbor = a
          dist = d
        }
      }
    }

    // no more solutions
    if (dist === Infinity) {
      break
    }

    // extend parent's solution path
    solutions[neighbor] = p.concat(neighbor)
    // extend parent's cost
    solutions[neighbor].dist = dist
  }

  return solutions
}

export { solve }

// // create graph
// const graph = {}

// const layout = {
//   R: ['2'],
//   2: ['3', '4'],
//   3: ['4', '6', '13'],
//   4: ['5', '8'],
//   5: ['7', '11'],
//   6: ['13', '15'],
//   7: ['10'],
//   8: ['11', '13'],
//   9: ['14'],
//   10: [],
//   11: ['12'],
//   12: [],
//   13: ['14'],
//   14: [],
//   15: []
// }

// // convert uni-directional to bi-directional graph
// let  graph = {
//     a: {e:1, b:1, g:3},
//     b: {a:1, c:1},
//     c: {b:1, d:1},
//     d: {c:1, e:1},
//     e: {d:1, a:1},
//     f: {g:1, h:1},
//     g: {a:3, f:1},
//     h: {f:1}
// };

// for (const id in layout) {
//   if (!graph[id]) { graph[id] = {} }
//   layout[id].forEach(function (aid) {
//     graph[id][aid] = 1
//     if (!graph[aid]) { graph[aid] = {} }
//     graph[aid][id] = 1
//   })
// }

// // choose start node
// const start = '10'
// // get all solutions
// const solutions = solve(graph, start)

// // for s in solutions..
// ' -> ' + s + ': [' + solutions[s].join(', ') + ']   (dist:' + solutions[s].dist + ')'

// From '10' to
//  -> 2: [7, 5, 4, 2]   (dist:4)
//  -> 3: [7, 5, 4, 3]   (dist:4)
//  -> 4: [7, 5, 4]   (dist:3)
//  -> 5: [7, 5]   (dist:2)
//  -> 6: [7, 5, 4, 3, 6]   (dist:5)
//  -> 7: [7]   (dist:1)
//  -> 8: [7, 5, 4, 8]   (dist:4)
//  -> 9: [7, 5, 4, 3, 13, 14, 9]   (dist:7)
//  -> 10: []   (dist:0)
//  -> 11: [7, 5, 11]   (dist:3)
//  -> 12: [7, 5, 11, 12]   (dist:4)
//  -> 13: [7, 5, 4, 3, 13]   (dist:5)
//  -> 14: [7, 5, 4, 3, 13, 14]   (dist:6)
//  -> 15: [7, 5, 4, 3, 6, 15]   (dist:6)
//  -> R: [7, 5, 4, 2, R]   (dist:5)
import { convexHull } from '../ConvexHullGraham'

test('The ConvexHull of the following points is [{x: 0, y: 3}, {x: 4, y: 4}, {x: 3, y: 1}, {x: 0, y: 0}]', () => {
  const points = [
    { x: 0, y: 3 },
    { x: 1, y: 1 },
    { x: 2, y: 2 },
    { x: 4, y: 4 },
    { x: 0, y: 0 },
    { x: 1, y: 2 },
    { x: 3, y: 1 },
    { x: 3, y: 3 }]
  const res = convexHull(points)
  expect(res).toEqual([{ x: 0, y: 3 }, { x: 4, y: 4 }, { x: 3, y: 1 }, { x: 0, y: 0 }])
})

test('The ConvexHull of the following points is [{x: 1, y: 4}, {x: 9, y: 6}, {x: 7, y: 0}, {x: 0, y: 0}]', () => {
  const points = [
    { x: 4, y: 3 },
    { x: 1, y: 4 },
    { x: 2, y: 4 },
    { x: 0, y: 0 },
    { x: 9, y: 6 },
    { x: 1, y: 3 },
    { x: 4, y: 1 },
    { x: 7, y: 0 }]
  const res = convexHull(points)
  expect(res).toEqual([{ x: 1, y: 4 }, { x: 9, y: 6 }, { x: 7, y: 0 }, { x: 0, y: 0 }])
})
/**
 * Author: Arnab Ray
 * ConvexHull using Graham Scan
 * Wikipedia: https://en.wikipedia.org/wiki/Graham_scan
 * Given a set of points in the plane. The Convex hull of the set is the smallest
 * convex polygon that contains all the points of it.
 */

function compare (a, b) {
  // Compare Function to Sort the points, a and b are points to compare
  if (a.x < b.x) return -1
  if (a.x === b.x && a.y < b.y) return -1
  return 1
}
function orientation (a, b, c) {
  // Check orientation of Line(a,b) and Line(b,c)
  const alpha = (b.y - a.y) / (b.x - a.x)
  const beta = (c.y - b.y) / (c.x - b.x)

  // Clockwise
  if (alpha > beta) return 1
  // Anticlockwise
  else if (beta > alpha) return -1
  // Colinear
  return 0
}

function convexHull (points) {
  const pointsLen = points.length
  if (pointsLen <= 2) {
    throw new Error('Minimum of 3 points is required to form closed polygon!')
  }

  points.sort(compare)
  const p1 = points[0]; const p2 = points[pointsLen - 1]

  // Divide Hull in two halves
  const upperPoints = []; const lowerPoints = []

  upperPoints.push(p1)
  lowerPoints.push(p1)

  for (let i = 1; i < pointsLen; i++) {
    if (i === pointsLen - 1 || orientation(p1, points[i], p2) !== -1) {
      let upLen = upperPoints.length

      while (upLen >= 2 && orientation(upperPoints[upLen - 2], upperPoints[upLen - 1], points[i]) === -1) {
        upperPoints.pop()
        upLen = upperPoints.length
      }
      upperPoints.push(points[i])
    }
    if (i === pointsLen - 1 || orientation(p1, points[i], p2) !== 1) {
      let lowLen = lowerPoints.length
      while (lowLen >= 2 && orientation(lowerPoints[lowLen - 2], lowerPoints[lowLen - 1], points[i]) === 1) {
        lowerPoints.pop()
        lowLen = lowerPoints.length
      }
      lowerPoints.push(points[i])
    }
  }
  const hull = []
  for (let i = 1; i < upperPoints.length - 1; i++) {
    hull.push(upperPoints[i])
  }
  for (let i = lowerPoints.length - 1; i >= 0; i--) {
    hull.push(lowerPoints[i])
  }

  return hull
}

export { convexHull }

// Example

// const points = [
//   { x: 0, y: 3 },
//   { x: 1, y: 1 },
//   { x: 2, y: 2 },
//   { x: 4, y: 4 },
//   { x: 0, y: 0 },
//   { x: 1, y: 2 },
//   { x: 3, y: 1 },
//   { x: 3, y: 3 }]

// convexHull(points)
import { setBit } from '../SetBit'

test('Set bit number 0 in 1:', () => {
  const setBitPos = setBit(1, 0)
  expect(setBitPos).toBe(1)
})

test('Set bit number 0 in 2:', () => {
  const setBitPos = setBit(2, 0)
  expect(setBitPos).toBe(3)
})

test('Set bit number 1 in 10:', () => {
  const setBitPos = setBit(10, 1)
  expect(setBitPos).toBe(10)
})

test('Set bit number 2 in 10:', () => {
  const setBitPos = setBit(10, 2)
  expect(setBitPos).toBe(14)
})
import { nextPowerOfTwo } from '../NextPowerOfTwo'

describe('NextPowerOfTwo', () => {
  it.each`
    input    | result
    ${0}     | ${1}
    ${1}     | ${1}
    ${2}     | ${2}
    ${3}     | ${4}
    ${5}     | ${8}
    ${125}   | ${128}
    ${1024}  | ${1024}
    ${10000} | ${16384}
  `('returns $result when is given $input', ({ input, result }) => {
    const res = nextPowerOfTwo(input)
    expect(res).toBe(result)
  })
})
import { IsPowerOfTwo } from '../IsPowerOfTwo'

test('Check if 0 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(0)
  expect(res).toBe(false)
})

test('Check if 1 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1)
  expect(res).toBe(true)
})

test('Check if 4 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(4)
  expect(res).toBe(true)
})

test('Check if 1024 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1024)
  expect(res).toBe(true)
})

test('Check if 1025 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1025)
  expect(res).toBe(false)
})
import { BinaryCountSetBits } from '../BinaryCountSetBits'

test('check BinaryCountSetBits of 25 is 3', () => {
  const res = BinaryCountSetBits(25)
  expect(res).toBe(3)
})
test('check BinaryCountSetBits of 36 is 2', () => {
  const res = BinaryCountSetBits(36)
  expect(res).toBe(2)
})
test('check BinaryCountSetBits of 16 is 1', () => {
  const res = BinaryCountSetBits(16)
  expect(res).toBe(1)
})
test('check BinaryCountSetBits of 58 is 4', () => {
  const res = BinaryCountSetBits(58)
  expect(res).toBe(4)
})
test('check BinaryCountSetBits of 4294967295 is 32', () => {
  const res = BinaryCountSetBits(4294967295)
  expect(res).toBe(32)
})
test('check BinaryCountSetBits of 0 is 0', () => {
  const res = BinaryCountSetBits(0)
  expect(res).toBe(0)
})
/*
    author: @Aayushi-Mittal

    This script will check whether the given
    number is a power of two or not.

    A number will be a power of two if only one bit is set and rest are unset.
    This is true for all the cases except 01 because (2^0 = 1) which is not a power of 2.
    For eg: 10 (2^1 = 2), 100 (2^2 = 4), 10000 (2^4 = 16)

    Reference Link: https://www.hackerearth.com/practice/notes/round-a-number-to-the-next-power-of-2/

    If we will subtract 1 from a number that is a power of 2 we will get it's 1's complement.
    And we know that 1's complement is just opp. of that number.
    So, (n & (n-1)) will be 0.

    For eg:    (1000 & (1000-1))
                1 0 0 0     // Original Number (8)
                0 1 1 1     // After Subtracting 1 (8-1 = 7)
                _______
                0 0 0 0     // will become 0

*/

export const IsPowerOfTwo = (n) => {
  if (n > 0 && (n & (n - 1)) === 0) {
    return true
  }
  return false
}
/*
 * Setting Bit: https://www.geeksforgeeks.org/set-k-th-bit-given-number/
 *
 * To set any bit we use bitwise OR (|) operator.
 *
 * Bitwise OR (|) compares the bits of the 32
 * bit binary representations of the number and
 * returns a number after comparing each bit.
 *
 * 0 | 0 -> 0
 * 0 | 1 -> 1
 * 1 | 0 -> 1
 * 1 | 1 -> 1
 *
 * In-order to set kth bit of a number (where k is the position where bit is to be changed)
 * we need to shift 1 k times to its left and then perform bitwise OR operation with the
 * number and result of left shift performed just before.
 *
 * References:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR
 */

/**
 * @param {number} number
 * @param {number} bitPosition - zero based.
 * @return {number}
 */

export const setBit = (number, bitPosition) => {
  return number | (1 << bitPosition)
}
/**
 *
 *  This script will find next power of two
 *    of given number.
 *  More about it:
 *   https://www.techiedelight.com/round-next-highest-power-2/
 *
 */

export const nextPowerOfTwo = (n) => {
  if (n > 0 && (n & (n - 1)) === 0) return n
  let result = 1
  while (n > 0) {
    result = result << 1
    n = n >> 1
  }
  return result
}
/*
    author: vivek9patel
    license: GPL-3.0 or later

    This script will find number of 1's
    in binary representation of given number

*/

function BinaryCountSetBits (a) {
  'use strict'
  // convert number into binary representation and return number of set bits in binary representation
  return a.toString(2).split('1').length - 1
}

export { BinaryCountSetBits }
/**
 * @function QuickSort
 * @description Quick sort is a comparison sorting algorithm that uses a divide and conquer strategy.
 * @param {Integer[]} items - Array of integers
 * @return {Integer[]} - Sorted array.
 * @see [QuickSort](https://en.wikipedia.org/wiki/Quicksort)
 */
function quickSort (items) {
  const length = items.length

  if (length <= 1) {
    return items
  }
  const PIVOT = items[0]
  const GREATER = []
  const LESSER = []

  for (let i = 1; i < length; i++) {
    if (items[i] > PIVOT) {
      GREATER.push(items[i])
    } else {
      LESSER.push(items[i])
    }
  }

  const sorted = [...quickSort(LESSER), PIVOT, ...quickSort(GREATER)]
  return sorted
}

export { quickSort }
/*
 * Gnome sort is a sort algorithm that moving an element to its proper place is accomplished by a series of swap
 * more information: https://en.wikipedia.org/wiki/Gnome_sort
 *
 */
export function gnomeSort (items) {
  if (items.length <= 1) {
    return
  }

  let i = 1

  while (i < items.length) {
    if (items[i - 1] <= items[i]) {
      i++
    } else {
      [items[i], items[i - 1]] = [items[i - 1], items[i]]

      i = Math.max(1, i - 1)
    }
  }
  return items
}

// Implementation of gnomeSort

// const ar = [5, 6, 7, 8, 1, 2, 12, 14]
// gnomeSort(ar)
/**
 * Flashsort is a distribution sorting algorithm showing linear
 * computational complexity O(n) for uniformly distributed
 * data sets and relatively little additional memory requirement.
 *
 * Wikipedia: https://en.wikipedia.org/wiki/Flashsort
 */

export function flashSort (arr) {
  let max = 0; let min = arr[0]
  const n = arr.length
  const m = ~~(0.45 * n)
  const l = new Array(m)

  for (let i = 1; i < n; ++i) {
    if (arr[i] < min) {
      min = arr[i]
    }
    if (arr[i] > arr[max]) {
      max = i
    }
  }

  if (min === arr[max]) {
    return arr
  }

  const c1 = (m - 1) / (arr[max] - min)

  for (let k = 0; k < m; k++) {
    l[k] = 0
  }

  for (let j = 0; j < n; ++j) {
    const k = ~~(c1 * (arr[j] - min))
    ++l[k]
  }

  for (let p = 1; p < m; ++p) {
    l[p] = l[p] + l[p - 1]
  }

  let hold = arr[max]
  arr[max] = arr[0]
  arr[0] = hold

  // permutation
  let move = 0; let t; let flash
  let j = 0
  let k = m - 1

  while (move < (n - 1)) {
    while (j > (l[k] - 1)) {
      ++j
      k = ~~(c1 * (arr[j] - min))
    }
    if (k < 0) break
    flash = arr[j]
    while (j !== l[k]) {
      k = ~~(c1 * (flash - min))
      hold = arr[t = --l[k]]
      arr[t] = flash
      flash = hold
      ++move
    }
  }

  // insertion
  for (j = 1; j < n; j++) {
    hold = arr[j]
    let i = j - 1
    while (i >= 0 && arr[i] > hold) {
      arr[i + 1] = arr[i--]
    }
    arr[i + 1] = hold
  }
  return arr
}

/**
* Implementation of Flash Sort
*/
// const array = [3, 0, 2, 5, -1, 4, 1, -2]
// flashSort(array)
/**
 * @function Intosort (As implemented in STD C++ Lib)
 * The function performs introsort which is used in
 * C++ Standard LIbrary, the implementation is inspired from]
 * library routine itself.
 * ALGORITHM:
 * 1) It performs quicksort on array until the recursion depth
 *    exceeds a pre determined limit.
 * 2) If the limit is reached it switches to heapsort
 * 3) For array size less than a threshold(16) directly
 *    does insertion sort on array
 * @param {Array} array the array to be sorted
 * @param {Function} compare the comparison function
 *
 * @see [Introsort](https://en.wikipedia.org/wiki/Introsort)
 * @author [Lakhan Nad](https://github.com/Lakhan-Nad)
 */
function introsort (array, compare) {
  /**
   * @function Default Comparison Function
   * This function is same as implemented by
   * Array.sort method
   * @see [StackOverflow](https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function)
   * @param {*} a variable 1
   * @param {*} b variable 2
   * @returns {Number}
   * -1 if a is less than b
   *  0 if a is equal to b
   *  1 if a greater than b
   */
  const defaultComparator = function (x, y) {
    if (x === undefined && y === undefined) return 0
    if (x === undefined) return 1
    if (y === undefined) return -1
    const xString = toString(x)
    const yString = toString(y)
    if (xString < yString) return -1
    if (xString > yString) return 1
    return 0
  }
  /**
   * @function helper function for defaultComparator
   * Converts a given object to String
   * @throws TypeError()
   * @param {Object} obj
   * @returns {String} String representation of given object
   */
  const toString = function (obj) {
    if (obj === null) return 'null'
    if (typeof obj === 'boolean' || typeof obj === 'number') {
      return obj.toString()
    }
    if (typeof obj === 'string') return obj
    if (typeof obj === 'symbol') throw new TypeError()
    return obj.toString()
  }
  /**
   * Checks if the value passed is an array
   * or not
   */
  if (Array.isArray(array) === false) {
    return
  }
  /**
   * If the compare parameter is not a function
   * or not passed at all use default comparator
   * function
   */
  if (typeof compare !== 'function') {
    compare = defaultComparator // If compare is not a comparator function
  }
  /**
   * Use a closure to define the whole sort
   * implementation this is done through
   * [IIFE](https://en.wikipedia.org/wiki/Immediately_invoked_function_expression)
   */
  return (function (array, comparator) {
    const swap = function (index1, index2) {
      const temp = array[index1]
      array[index1] = array[index2]
      array[index2] = temp
    }
    /**
     * @constant THRESHOLD
     * If the length of array is less than
     * this then we simply perform insertion sort
     */
    const THRESHOLD = 16
    /**
     * @constant TUNEMAXDEPTH
     * Constant usec to increase or decrease value
     * of maxDepth
     */
    const TUNEMAXDEPTH = 1
    const len = array.length
    /**
     * Return if array is only of length 1
     * Array of size 1 is always sorted
     */
    if (len === 1) {
      return
    }
    /**
     * Calculate maxDepth = log2(len)
     * Taken from implementation in stdc++
     */
    const maxDepth = Math.floor(Math.log2(len)) * TUNEMAXDEPTH
    /**
     * The very first call to quicksort
     * this initiates sort routine
     */
    quickSort(0, len, maxDepth)
    /**
     * A final check call to insertion sort
     * on sorted array
     */
    insertionSort(0, len)
    /** *********************  Implementation of various routines  **************************/
    /**
     * @function
     * This is recursive quicksort implementation in array
     * of segment [start,last-1]
     * [QuickSort](https://en.wikipedia.org/wiki/Quicksort)
     * @param {Number} start the start index of array segment to be sorted
     * @param {Number} last  one more than the last index of array segment
     * @param {Number} depth this measures how many recursive calls are done
     */
    function quickSort (start, last, depth) {
      if (last - start <= THRESHOLD) {
        insertionSort(start, last)
        return
      } else if (depth <= 0) {
        heapSort(start, last)
        return
      }
      let pivot = (last + start) >> 1
      pivot = partition(start, last, pivot)
      quickSort(start, pivot, depth - 1)
      quickSort(pivot + 1, last, depth - 1)
    }
    /**
     * @function Helper function to quicksort
     * @param {Number} start the start of array segment to partition
     * @param {Number} last  one more than last index of the array segment
     * @param {Number} pivot the index of pivot to be used
     * @returns {Number} the index of pivot after partition
     */
    function partition (start, last, pivot) {
      swap(start, pivot)
      pivot = start
      let lo = start
      let hi = last
      while (true) {
        lo++
        while (comparator(array[lo], array[pivot]) <= 0 && lo !== last) {
          lo++
        }
        hi--
        while (comparator(array[hi], array[pivot]) > 0 && hi !== start) {
          hi--
        }
        if (lo >= hi) {
          break
        }
        swap(lo, hi)
      }
      swap(start, hi)
      return hi
    }
    /**
     * @function
     * Performs insertion sort on array of range
     * [start, last-1]
     * @param {Number} start the first index of array segment to be sorted
     * @param {Number} last  one more than last index of array to be sorted
     */
    function insertionSort (start, last) {
      let i, j
      for (i = start + 1; i < last; i++) {
        j = i - 1
        while (j >= 0 && comparator(array[j], array[j + 1]) > 0) {
          swap(j, j + 1)
          j--
        }
      }
    }
    /**
     * @function
     * Performs heapsort in array segment of range [start, last-1]
     * [HeapSort](https://en.wikipedia.org/wiki/Heapsort)
     * @param {Number} start the first index of array segment to be sorted
     * @param {Number} last  one more than last index of array to be sorted
     */
    function heapSort (start, last) {
      let x = (last + start) >> 1
      while (x - start >= 0) {
        heapify(x, start, last)
        x--
      }
      x = last - 1
      while (x - start > 0) {
        swap(start, x)
        heapify(start, start, x)
        x--
      }
    }
    /**
     * @function Helper function to heapsort routine
     * @param {Number} cur the index we need to heapify
     * @param {Number} start the start index of array segment that cur belongs to
     * @param {Number} last  one more than last index of segment that cur belongs to
     */
    function heapify (cur, start, last) {
      const size = last - start
      let max, lt, rt
      cur = cur - start
      while (true) {
        max = cur
        lt = 2 * max + 1
        rt = 2 * max + 2
        if (
          lt < size &&
          comparator(array[start + max], array[start + lt]) < 0
        ) {
          max = lt
        }
        if (
          rt < size &&
          comparator(array[start + max], array[start + rt]) < 0
        ) {
          max = rt
        }
        if (max !== cur) {
          swap(start + cur, start + max)
          cur = max
        } else {
          break
        }
      }
    }
  })(array, compare)
}

/**
 * @example Demo run of the sort routine
 * The data is randomly generated
 * Returns 'RIGHT:)' if the sort routine worked as expected,
 *         'WRONG!!' otherwise
 */
function demo1 () {
  const data = []
  const size = 1000000
  let i = 0
  let temp
  const c = function (a, b) {
    return a - b
  }
  for (i = 0; i < size; i++) {
    temp = Math.random() * Number.MAX_SAFE_INTEGER
    data.push(temp)
  }
  introsort(data, c)
  let faulty = false
  for (i = 1; i < size; i++) {
    if (data[i] < data[i - 1]) {
      faulty = true
      break
    }
  }
  if (faulty) {
    return 'WRONG!!'
  } else {
    return 'RIGHT:)'
  }
}

/**
 * @example Demo run of the sort routine
 * using the default compare function and
 * comparing the results with Array.sort
 */
function demo2 () {
  const data = []
  const data2 = []
  const size = 1000000
  let i = 0
  let temp
  for (i = 0; i < size; i++) {
    temp = Math.random() * Number.MAX_SAFE_INTEGER
    data.push(temp)
    data2.push(temp)
  }
  introsort(data)
  data2.sort()
  let faulty = false
  for (i = 1; i < size; i++) {
    if (data[i] !== data2[i]) {
      faulty = true
      break
    }
  }
  if (faulty) {
    return 'WRONG Implemented Comparator!!'
  } else {
    return 'Comparator Works Fine:)'
  }
}

export { introsort, demo1, demo2 }
import { radixSort } from '../RadixSort'

test('The RadixSort of the array [4, 3, 2, 1] is [1, 2, 3, 4]', () => {
  const arr = [4, 3, 2, 1]
  const res = radixSort(arr, 10)
  expect(res).toEqual([1, 2, 3, 4])
})

test('The RadixSort of the array [] is []', () => {
  const arr = []
  const res = radixSort(arr, 10)
  expect(res).toEqual([])
})

test('The RadixSort of the array [14, 16, 10, 12] is [10, 12, 14, 16]', () => {
  const arr = [14, 16, 10, 12]
  const res = radixSort(arr, 10)
  expect(res).toEqual([10, 12, 14, 16])
})
import { oddEvenSort } from '../OddEvenSort'

test('The OddEvenSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = oddEvenSort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The OddEvenSort of the array [] is []', () => {
  const arr = []
  const res = oddEvenSort(arr)
  expect(res).toEqual([])
})

test('The OddEvenSort of the array [10, 14, 12, 20] is [10, 12, 14, 20]', () => {
  const arr = [10, 14, 12, 20]
  const res = oddEvenSort(arr)
  expect(res).toEqual([10, 12, 14, 20])
})

test('The OddEvenSort of the array [166, 169, 144] is [144, 166, 169]', () => {
  const arr = [166, 169, 144]
  const res = oddEvenSort(arr)
  expect(res).toEqual([144, 166, 169])
})
import { beadSort } from '../BeadSort'

describe('BeadSort', () => {
  it('should sort arrays correctly', () => {
    expect(beadSort([5, 4, 3, 2, 1])).toEqual([1, 2, 3, 4, 5])
    expect(beadSort([7, 9, 4, 3, 5])).toEqual([3, 4, 5, 7, 9])
  })

  it('should throw a RangeError when the array contains negative integers', () => {
    expect(() => beadSort([-1, 5, 8, 4, 3, 19])).toThrow(RangeError)
  })
})
import { cycleSort } from '../CycleSort'

describe('cycleSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(cycleSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(cycleSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(cycleSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(cycleSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(cycleSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(cycleSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(cycleSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(cycleSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(cycleSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(cycleSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(cycleSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(cycleSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(cycleSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(cycleSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(cycleSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})
import { insertionSortAlternativeImplementation } from '../InsertionSort'

describe('insertionSortAlternativeImplementation', () => {
  it('expects to work with empty array', () => {
    expect(insertionSortAlternativeImplementation([])).toEqual([])
  })

  it('expects to return input array when array.length is less than 2', () => {
    const input = [3]
    expect(insertionSortAlternativeImplementation(input)).toEqual(input)
  })

  it('expects to return array sorted in ascending order', () => {
    expect(insertionSortAlternativeImplementation([14, 11])).toEqual([11, 14])
    expect(insertionSortAlternativeImplementation([21, 22, 23])).toEqual([21, 22, 23])
    expect(insertionSortAlternativeImplementation([1, 3, 2, 3, 7, 2])).toEqual([1, 2, 2, 3, 3, 7])
    expect(insertionSortAlternativeImplementation([1, 6, 4, 5, 9, 2])).toEqual([1, 2, 4, 5, 6, 9])
  })
})
import { flipArray, findMax, pancakeSort } from '../PancakeSort'

describe('flipArray', () => {
  it('should flip any subarray of any array', () => {
    expect(flipArray([1, 2, 3, 4], 0, 3)).toEqual([4, 3, 2, 1])
    expect(flipArray([1, 2, 3, 4, 5], 2, 4)).toEqual([1, 2, 5, 4, 3])
    expect(flipArray([], 0, 0)).toEqual([])
  })
})

describe('findMax', () => {
  it('should find the index of the maximum value in any subarray of any array', () => {
    expect(findMax([1, 3, 2, 5], 0, 3)).toEqual(3)
    expect(findMax([1, 3, 2, 5], 0, 2)).toEqual(1)
  })
})

describe('pancakeSort', () => {
  it('should sort any array', () => {
    expect(pancakeSort([4, 3, 2, 1])).toEqual([1, 2, 3, 4])
    expect(pancakeSort([3, 1, 4, 2])).toEqual([1, 2, 3, 4])
    expect(pancakeSort([100, 1000, 10, 1])).toEqual([1, 10, 100, 1000])
  })
})
import { combSort } from '../CombSort'

describe('combSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(combSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(combSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(combSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(combSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(combSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(combSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(combSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(combSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(combSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(combSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(combSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(combSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(combSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(combSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(combSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})
import { flashSort } from '../FlashSort'

test('The flash sort of the array [3, 0, 2, 5, -1, 4, 1, -2] is [-2, -1, 0, 1, 2, 3, 4, 5]', () => {
  const array = [3, 0, 2, 5, -1, 4, 1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-2, -1, 0, 1, 2, 3, 4, 5])
})

test('The flash sort of the array [-3, 0, 2, -5, -1, 4, 1, -2] is [-5, -3, -2, -1, 0, 1, 2, 4]', () => {
  const array = [-3, 0, 2, -5, -1, 4, 1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-5, -3, -2, -1, 0, 1, 2, 4])
})

test('The flash sort of the array [13, 0, 12, 5, -1, 14, 1, -2] is [-2, -1, 0, 1, 5, 12, 13, 14]', () => {
  const array = [13, 0, 12, 5, -1, 14, 1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-2, -1, 0, 1, 5, 12, 13, 14])
})

test('The flash sort of the array [-3, 0, -2, -5, -1, -4, -1, -2] is [-5, -4, -3, -2, -2, -1, -1, 0]', () => {
  const array = [-3, 0, -2, -5, -1, -4, -1, -2]
  const res = flashSort(array)
  expect(res).toEqual([-5, -4, -3, -2, -2, -1, -1, 0])
})
import { quickSort } from '../QuickSort'

describe('QuickSort', () => {
  it('should work for empty arrays', () => {
    expect(quickSort([])).toEqual([])
  })

  it('should sort arrays correctly', () => {
    expect(quickSort([5, 4, 3, 10, 2, 1])).toEqual([1, 2, 3, 4, 5, 10])
    expect(quickSort([5, 4])).toEqual([4, 5])
    expect(quickSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(quickSort([0, 5, 3, 2, 2])).toEqual([0, 2, 2, 3, 5])
  })
})
import { alphaNumericalSort } from '../AlphaNumericalSort'

describe('alphaNumericalComparer', () => {
  test('given array of eng symbols return correct sorted array', () => {
    const src = ['b', 'a', 'c']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['a', 'b', 'c'])
  })

  test('given array of numbers return correct sorted array', () => {
    const src = ['15', '0', '5']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['0', '5', '15'])
  })

  test('correct sort with numbers and strings', () => {
    const src = ['3', 'a1b15c', 'z', 'a1b14c']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['3', 'a1b14c', 'a1b15c', 'z'])
  })

  test('correct sort with long numbers', () => {
    const src = ['abc999999999999999999999999999999999cba', 'abc999999999999999999999999999999990cba', 'ab']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['ab', 'abc999999999999999999999999999999990cba', 'abc999999999999999999999999999999999cba'])
  })

  test('correct sort with z prefix', () => {
    const src = ['z', 'abc003def', 'abc1def', 'a']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['a', 'abc1def', 'abc003def', 'z'])
  })

  test('correct sort with other language', () => {
    const src = ['10', '2', '10', '05']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['2', '10', '05', '10'])
  })
})
import { pigeonHoleSort } from '../PigeonHoleSort'

test('The pigeonHoleSort of the array [1, 4, 3, 2] is [1, 2, 3, 4]', () => {
  const arr = [1, 4, 3, 2]
  const res = pigeonHoleSort(arr)
  expect(res).toEqual([1, 2, 3, 4])
})

test('The pigeonHoleSort of the array [5, 4, 1, 2] is [1, 2, 4, 5]', () => {
  const arr = [5, 4, 1, 2]
  const res = pigeonHoleSort(arr)
  expect(res).toEqual([1, 2, 4, 5])
})

test('The pigeonHoleSort of the array [18, 31, 29, 35, 11] is [11, 18, 29, 31, 35]', () => {
  const arr = [18, 31, 29, 35, 11]
  const res = pigeonHoleSort(arr)
  expect(res).toEqual([11, 18, 29, 31, 35])
})
import { gnomeSort } from '../GnomeSort'

test('The gnomeSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = gnomeSort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The gnomeSort of the array [-5, 4, -3, 2, -1] is [-5, -3, -1, 2, 4]', () => {
  const arr = [-5, 4, -3, 2, -1]
  const res = gnomeSort(arr)
  expect(res).toEqual([-5, -3, -1, 2, 4])
})

test('The gnomeSort of the array [15, 4, -13, 2, -11] is [-13, -11, 2, 4, 15]', () => {
  const arr = [15, 4, -13, 2, -11]
  const res = gnomeSort(arr)
  expect(res).toEqual([-13, -11, 2, 4, 15])
})
import { shellSort } from '../ShellSort'

test('The ShellSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = shellSort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The ShellSort of the array [] is []', () => {
  const arr = []
  const res = shellSort(arr)
  expect(res).toEqual([])
})

test('The ShellSort of the array [15, 24, 31, 42, 11] is [11, 15, 24, 31, 42]', () => {
  const arr = [15, 24, 31, 42, 11]
  const res = shellSort(arr)
  expect(res).toEqual([11, 15, 24, 31, 42])
})

test('The ShellSort of the array [121, 190, 169] is [121, 169, 190]', () => {
  const arr = [121, 190, 169]
  const res = shellSort(arr)
  expect(res).toEqual([121, 169, 190])
})
import { secondLargestElement } from '../FindSecondLargestElement'

test('The second largest element of the array [1, 2, 3, 4, 5] is 4', () => {
  const array = [1, 2, 3, 4, 5]
  const res = secondLargestElement(array)
  expect(res).toEqual(4)
})

test('The second largest element of the array [-1, -2, -3, -4, -5] is -2', () => {
  const array = [-1, -2, -3, -4, -5]
  const res = secondLargestElement(array)
  expect(res).toEqual(-2)
})
import { stoogeSort } from '../StoogeSort'

test('The StoogeSort of the array [1, 6, 4, 7, 2] is [1, 2, 4, 6, 7]', () => {
  const arr = [1, 6, 4, 7, 2]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([1, 2, 4, 6, 7])
})

test('The StoogeSort of the array [] is []', () => {
  const arr = []
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([])
})

test('The StoogeSort of the array [46, 15, 49, 65, 23] is [15, 23, 46, 49, 65]', () => {
  const arr = [46, 15, 49, 65, 23]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([15, 23, 46, 49, 65])
})

test('The StoogeSort of the array [136, 459, 132, 566, 465] is [132, 136, 459, 465, 566]', () => {
  const arr = [136, 459, 132, 566, 465]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([132, 136, 459, 465, 566])
})

test('The StoogeSort of the array [45, 3, 156, 1, 56] is [1, 3, 45, 56, 156]', () => {
  const arr = [45, 3, 156, 1, 56]
  const res = stoogeSort(arr, 0, arr.length)
  expect(res).toEqual([1, 3, 45, 56, 156])
})
import { countingSort } from '../CountingSort'

test('The countingSort of the array [3, 0, 2, 5, 4, 1] is [0, 1, 2, 3, 4, 5]', () => {
  const array = [3, 0, 2, 5, 4, 1]
  const res = countingSort(array, 0, 5)
  expect(res).toEqual([0, 1, 2, 3, 4, 5])
})

test('The countingSort of the array [6, 4, 2, 1, 3, 5] is [1, 2, 3, 4, 5, 6]', () => {
  const array = [6, 4, 2, 1, 3, 5]
  const res = countingSort(array, 1, 6)
  expect(res).toEqual([1, 2, 3, 4, 5, 6])
})

test('The countingSort of the array [11, 14, 12, 15, 16, 13] is [11, 12, 13, 14, 15, 16]', () => {
  const array = [11, 14, 12, 15, 16, 13]
  const res = countingSort(array, 11, 16)
  expect(res).toEqual([11, 12, 13, 14, 15, 16])
})

test('The countingSort of the array [13, 18, 2, 15, 43, 11] is [2, 11, 13, 15, 18, 43]', () => {
  const array = [13, 18, 2, 15, 43, 11]
  const res = countingSort(array, 2, 43)
  expect(res).toEqual([2, 11, 13, 15, 18, 43])
})
import { bogoSort, isSorted } from '../BogoSort'

describe('isSorted', () => {
  it('should return true for empty arrays', () => {
    expect(isSorted([])).toBe(true)
  })

  it('should return true for single-element arrays', () => {
    expect(isSorted([1])).toBe(true)
  })

  it('should return true for arrays that are properly sorted', () => {
    expect(isSorted([1, 2, 3])).toBe(true)
  })

  it('should return false for arrays that are not properly sorted', () => {
    expect(isSorted([3, 2, 1])).toBe(false)
  })
})

describe('bogoSort', () => {
  it('should (eventually) sort the array', () => {
    expect(bogoSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })
})
import { Timsort } from '../TimSort'

test('The Timsort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const arr = [5, 4, 3, 2, 1]
  const res = Timsort(arr)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The Timsort of the array [] is []', () => {
  const arr = []
  const res = Timsort(arr)
  expect(res).toEqual([])
})

test('The Timsort of the array [-5, -4, -3, -2, -1] is [-5, -4, -3, -2, -1]', () => {
  const arr = [-5, -4, -3, -2, -1]
  const res = Timsort(arr)
  expect(res).toEqual([-5, -4, -3, -2, -1])
})

test('The Timsort of the array [9, 0, -5, -11, 3] is [-11, -5, 0, 3, 9]', () => {
  const arr = [9, 0, -5, -11, 3]
  const res = Timsort(arr)
  expect(res).toEqual([-11, -5, 0, 3, 9])
})
import { quickSort } from '../QuickSortRecursive'

describe('QuickSortRecursive | Partition In Place Method', () => {
  it('Expectedly, throw some error if we pass a non-array input', () => {
    expect(() => quickSort('xyz', 0, 2)).toThrow('Please input a valid list or array.')
    expect(() => quickSort(null, 0, 4)).toThrow('Please input a valid list or array.')
    expect(() => quickSort(55, 0, 2)).toThrow('Please input a valid list or array.')
  })

  it('Expectedly, the quickSort method will sort the unsorted list in ascending order', () => {
    const unSortArray = [5, 9, 3, 4, 6, 2, 0, 1, 7, 8]
    const sortedExpectedArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    expect(quickSort(unSortArray, 0, unSortArray.length - 1)).toEqual(sortedExpectedArray)
  })

  it('Expectedly, the quickSort method will arrange the list of character values in dictionary order.', () => {
    const unSortList = ['d', 'e', 'c', 'a', 'f', 'b']
    const sortedExpectedList = ['a', 'b', 'c', 'd', 'e', 'f']
    expect(quickSort(unSortList, 0, unSortList.length - 1)).toEqual(sortedExpectedList)
  })
})
import { heapSort } from '../HeapSortV2'

test('The heapSort of the array [4, 3, 2, 1] is [1, 2, 3, 4]', () => {
  const arr = [4, 3, 2, 1]
  const res = heapSort(arr)
  expect(res).toEqual([1, 2, 3, 4])
})

test('The heapSort of the array [] is []', () => {
  const arr = []
  const res = heapSort(arr)
  expect(res).toEqual([])
})

test('The heapSort of the array [41, 31, 32, 31] is [31, 31, 32, 41]', () => {
  const arr = [41, 31, 32, 31]
  const res = heapSort(arr)
  expect(res).toEqual([31, 31, 32, 41])
})
import { selectionSort } from '../SelectionSort'

describe('selectionSort', () => {
  it('expects to return the array sorted in ascending order', () => {
    const toSort = [5, 6, 7, 8, 1, 2, 12, 14]
    const expected = [1, 2, 5, 6, 7, 8, 12, 14]

    expect(selectionSort(toSort)).toEqual(expected)
  })

  it('expects to throw if it is not a valid array', () => {
    expect(() => selectionSort('abc')).toThrow('Given input is not an array')
    expect(() => selectionSort(123)).toThrow('Given input is not an array')
    expect(() => selectionSort({})).toThrow('Given input is not an array')
    expect(() => selectionSort(null)).toThrow('Given input is not an array')
    expect(() => selectionSort()).toThrow('Given input is not an array')
  })

  it('expects to throw if one of the elements in the array is not a number', () => {
    expect(() => selectionSort([1, 'x', 2])).toThrow('One of the items in your array is not a number')
  })
})
import { shuffle } from '../FisherYatesShuffle'

describe('shuffle', () => {
  it('expects to have a new array with same size', () => {
    const fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    const mixedArray = shuffle(fibonacci)

    expect(mixedArray).toHaveLength(fibonacci.length)
  })

  it('expects to have a new array with same values', () => {
    const fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    const mixedArray = shuffle(fibonacci)

    expect(mixedArray).toContain(0)
    expect(mixedArray).toContain(1)
    expect(mixedArray).toContain(2)
    expect(mixedArray).toContain(3)
    expect(mixedArray).toContain(5)
    expect(mixedArray).toContain(8)
    expect(mixedArray).toContain(13)
    expect(mixedArray).toContain(21)
    expect(mixedArray).toContain(34)
    expect(mixedArray).toContain(55)
    expect(mixedArray).toContain(89)
  })
})
import { heapSort } from '../HeapSort'

test('The HeapSort of the array [5, 4, 3, 2, 1] is [1, 2, 3, 4, 5]', () => {
  const array = [5, 4, 3, 2, 1]
  const res = heapSort(array)
  expect(res).toEqual([1, 2, 3, 4, 5])
})

test('The HeapSort of the array [-5, -4, -3, -2, -1] is [-5, -4, -3, -2, -1]', () => {
  const array = [-5, -4, -3, -2, -1]
  const res = heapSort(array)
  expect(res).toEqual([-5, -4, -3, -2, -1])
})

test('The HeapSort of the array [50, 43, 31, 52, 91] is [31, 43, 50, 52, 91]', () => {
  const array = [50, 43, 31, 52, 91]
  const res = heapSort(array)
  expect(res).toEqual([31, 43, 50, 52, 91])
})

test('The HeapSort of the array [] is []', () => {
  const array = []
  const res = heapSort(array)
  expect(res).toEqual([])
})
import { secondLargestElement } from '../FindSecondLargestElement'

test('The second largest element of the array [100, 200, 300, 400] is 300', () => {
  const array = [100, 200, 300, 400]
  const res = secondLargestElement(array)
  expect(res).toBe(300)
})

test('The second largest element of the array [1100, 2400, 1300, 4002] is 2400', () => {
  const array = [1100, 2400, 1300, 4002]
  const res = secondLargestElement(array)
  expect(res).toBe(2400)
})

test('The second largest element of the array [10, 20, 39, 34] is 34', () => {
  const array = [10, 20, 39, 34]
  const res = secondLargestElement(array)
  expect(res).toBe(34)
})

test('The second largest element of the array [1, 20, 3, 40] is 20', () => {
  const array = [1, 20, 3, 40]
  const res = secondLargestElement(array)
  expect(res).toBe(20)
})
import { cocktailShakerSort } from '../CocktailShakerSort'

describe('CocktailShakerSort', () => {
  it('should sort arrays correctly', () => {
    expect(cocktailShakerSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(cocktailShakerSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(cocktailShakerSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })

  it('should work for empty arrays, too', () => {
    expect(cocktailShakerSort([])).toEqual([])
  })
})
import { bucketSort } from '../BucketSort'

describe('Tests for bucketSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(bucketSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(bucketSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(bucketSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(bucketSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(bucketSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(bucketSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(bucketSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(bucketSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(bucketSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(bucketSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(bucketSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(bucketSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(bucketSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(bucketSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(bucketSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})
import { merge, mergeSort } from '../MergeSort'

describe('merge', () => {
  it('should merge arrays correctly', () => {
    expect(merge([5, 4], [1, 2, 3])).toEqual([1, 2, 3, 5, 4])
    expect(merge([], [1, 2])).toEqual([1, 2])
    expect(merge([1, 2, 3], [1])).toEqual([1, 1, 2, 3])
    expect(merge([], [])).toEqual([])
  })
})

describe('MergeSort', () => {
  it('should work for empty arrays', () => {
    expect(mergeSort([])).toEqual([])
  })

  it('should sort arrays correctly', () => {
    expect(mergeSort([5, 4])).toEqual([4, 5])
    expect(mergeSort([8, 4, 10, 15, 9])).toEqual([4, 8, 9, 10, 15])
    expect(mergeSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(mergeSort([10, 5, 3, 8, 2, 6, 4, 7, 9, 1])).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
  })
})
import { simplifiedWiggleSort } from '../SimplifiedWiggleSort.js'

describe('simplified wiggle sort', () => {
  test('simplified wiggle sort for chars', () => {
    const src = ['a', 'b', 'c']
    expect(simplifiedWiggleSort(src)).toEqual(['a', 'c', 'b'])
  })

  test('wiggle sort with duplicates, even array', () => {
    const src = [2, 2, 1, 3]
    expect(simplifiedWiggleSort(src)).toEqual([1, 3, 2, 2])
  })

  test('wiggle sort with duplicates, odd array', () => {
    const src = [1, 1, 1, 2, 4]
    expect(simplifiedWiggleSort(src)).toEqual([1, 4, 1, 2, 1])
  })

  test('simplified wiggle sort which leads to equal values next to ' +
    'each other', () => {
    const src = [3, 3, 5, 1]
    expect(simplifiedWiggleSort(src)).toEqual([1, 5, 3, 3])
  })
})
import { alternativeBubbleSort, bubbleSort } from '../BubbleSort'

describe('bubbleSort', () => {
  it('should sort arrays correctly', () => {
    expect(bubbleSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(bubbleSort([])).toEqual([])
    expect(bubbleSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(bubbleSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
    expect(bubbleSort([5, 6, 7, 8, 9, 4])).toEqual([4, 5, 6, 7, 8, 9])
    expect(bubbleSort([20, 30, 40])).toEqual([20, 30, 40])
    expect(bubbleSort([2, 1, 3])).toEqual([1, 2, 3])
    expect(bubbleSort([10, 15, 16, 100])).toEqual([10, 15, 16, 100])
    expect(bubbleSort([10, 9, 11])).toEqual([9, 10, 11])
    expect(bubbleSort([10, 9, 12])).toEqual([9, 10, 12])
    expect(bubbleSort([3, 2, 1])).toEqual([1, 2, 3])
    expect(bubbleSort([10, 9, 8])).toEqual([8, 9, 10])
  })
})

describe('alternativeBubbleSort', () => {
  it('should sort arrays correctly', () => {
    expect(alternativeBubbleSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(alternativeBubbleSort([])).toEqual([])
    expect(alternativeBubbleSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(alternativeBubbleSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })
})
/**
 * Comb sort improves on bubble sort.
 *
 * The basic idea is to eliminate turtles, or small values
 * near the end of the list, since in a bubble sort these slow the sorting
 * down tremendously. Rabbits, large values around the beginning of the list,
 * do not pose a problem in bubble sort.
 *
 * In bubble sort, when any two elements are compared, they always have a
 * gap (distance from each other) of 1. The basic idea of comb sort is
 * that the gap can be much more than 1. The inner loop of bubble sort,
 * which does the actual swap, is modified such that gap between swapped
 * elements goes down (for each iteration of outer loop) in steps of
 * a "shrink factor" k: [ n/k, n/k2, n/k3, ..., 1 ].
 *
 * Wikipedia: https://en.wikipedia.org/wiki/Comb_sort
 */

/**
 * combSort returns an array of numbers sorted in increasing order.
 *
 * @param {number[]} list The array of numbers to sort.
 * @return {number[]} The array of numbers sorted in increasing order.
 */
function combSort (list) {
  if (list.length === 0) {
    return list
  }
  const shrink = 1.3
  let gap = list.length
  let isSwapped = true
  let i = 0

  while (gap > 1 || isSwapped) {
    // Update the gap value for a next comb
    gap = parseInt(parseFloat(gap) / shrink, 10)

    isSwapped = false
    i = 0

    while (gap + i < list.length) {
      if (list[i] > list[i + gap]) {
        [list[i], list[i + gap]] = [list[i + gap], list[i]]
        isSwapped = true
      }
      i += 1
    }
  }
  return list
}

export { combSort }
/*
* Find Second Largest is a real technical interview question.
* Chances are you will be asked to find the second largest value
* inside of an array of numbers. You must also be able to filter
* out duplicate values.  It's important to know how to do this with
* clean code that is also easy to explain.
*
* Resources:
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
*/

const secondLargestElement = (array) => {
  const largestElement = Math.max(...array)
  let element = -Number.MAX_VALUE

  for (let i = 0; i < array.length; i++) {
    if (element < array[i] && array[i] !== largestElement) {
      element = array[i]
    }
  }

  return element
}

export { secondLargestElement }
/**
 * Counting sort is an algorithm for sorting a collection
 * of objects according to keys that are small integers.
 *
 * It is an integer sorting algorithm.
 *
 * Wikipedia: https://en.wikipedia.org/wiki/Counting_sort
 * Animated Visual: https://www.cs.usfca.edu/~galles/visualization/CountingSort.html
 */

export const countingSort = (arr, min, max) => {
  // Create an auxiliary resultant array
  const res = []
  // Create and initialize the frequency[count] array
  const count = new Array(max - min + 1).fill(0)
  // Populate the freq array
  for (let i = 0; i < arr.length; i++) {
    count[arr[i] - min]++
  }
  // Create a prefix sum array out of the frequency[count] array
  count[0] -= 1
  for (let i = 1; i < count.length; i++) {
    count[i] += count[i - 1]
  }
  // Populate the result array using the prefix sum array
  for (let i = arr.length - 1; i >= 0; i--) {
    res[count[arr[i] - min]] = arr[i]
    count[arr[i] - min]--
  }
  return res
}

/**
 * Implementation of Counting Sort
 */
// const array = [3, 0, 2, 5, 4, 1]
// countingSort(array, 0, 5)
/*
* Radix sorts an integer array without comparing the integers.
* It groups the integers by their digits which share the same
* significant position.
* For more information see: https://en.wikipedia.org/wiki/Radix_sort
*/
export function radixSort (items, RADIX) {
  // default radix is then because we usually count to base 10
  if (RADIX === undefined || RADIX < 1) {
    RADIX = 10
  }

  let maxLength = false
  let placement = 1

  while (!maxLength) {
    maxLength = true
    const buckets = []

    for (let i = 0; i < RADIX; i++) {
      buckets.push([])
    }

    for (let j = 0; j < items.length; j++) {
      const tmp = items[j] / placement
      buckets[Math.floor(tmp % RADIX)].push(items[j])
      if (maxLength && tmp > 0) {
        maxLength = false
      }
    }

    let a = 0
    for (let b = 0; b < RADIX; b++) {
      const buck = buckets[b]
      for (let k = 0; k < buck.length; k++) {
        items[a] = buck[k]
        a++
      }
    }
    placement *= RADIX
  }
  return items
}
/*
    Quicksort is the most popular sorting algorithm and there have
    lots of different implementations but the "recursive" or "Partition in place"
    is one of the most efficient implementations below we have discussed how to
    implement it.

    Partition in place => "in place" Partition in place indicates that we
    do not need any other space to store the auxiliary array and the term
    "partition" denotes that we split the list into two parts one is less
    than the pivot and the other is greater than the pivot and repeats this
    process recursively and breaks the problem into sub-problems and makes
    it singular so that the behavior or "divide and conquer" get involved
    too.

    Problem & Source of Explanation => https://www.cs.auckland.ac.nz/software/AlgAnim/qsort1a.html
*/

/**
 * Partition in place QuickSort.
 * @param {number[]} inputList list of values.
 * @param {number} low lower index for partition.
 * @param {number} high higher index for partition.
 */
const quickSort = (inputList, low, high) => {
  if (!Array.isArray(inputList)) {
    throw new TypeError('Please input a valid list or array.')
  }
  if (low < high) {
    // get the partition index.
    const pIndex = partition(inputList, low, high)
    // recursively call the quickSort method again.
    quickSort(inputList, low, pIndex - 1)
    quickSort(inputList, pIndex + 1, high)
  }
  return inputList
}

/**
 * Partition In Place method.
 * @param {number[]} partitionList list for partitioning.
 * @param {number} low lower index for partition.
 * @param {number} high higher index for partition.
 * @returns {number} `pIndex` pivot index value.
 */
const partition = (partitionList, low, high) => {
  const pivot = partitionList[high]
  let pIndex = low
  for (let index = low; index <= high - 1; index++) {
    if (partitionList[index] < pivot) {
      // swap variables using array destructuring
      [partitionList[index], partitionList[pIndex]] = [partitionList[pIndex], partitionList[index]]
      pIndex += 1
    }
  }
  [partitionList[pIndex], partitionList[high]] = [partitionList[high], partitionList[pIndex]]
  return pIndex
}

export { quickSort }
/*
https://en.wikipedia.org/wiki/Pigeonhole_sort

*Pigeonhole sorting is a sorting algorithm that is suitable
* for sorting lists of elements where the number of elements
* (n) and the length of the range of possible key values (N)
* are approximately the same.
 */
export function pigeonHoleSort (arr) {
  let min = arr[0]
  let max = arr[0]

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > max) { max = arr[i] }
    if (arr[i] < min) { min = arr[i] }
  }

  const range = max - min + 1
  const pigeonhole = Array(range).fill(0)

  for (let i = 0; i < arr.length; i++) {
    pigeonhole[arr[i] - min]++
  }

  let index = 0

  for (let j = 0; j < range; j++) {
    while (pigeonhole[j]-- > 0) {
      arr[index++] = j + min
    }
  }
  return arr
}
/*
  oddeven sort or oddeven transposition sort
  is a relatively simple sorting algorithm, developed originally for use on parallel processors with local interconnections.
  It is a comparison sort related to bubble sort, with which it shares many characteristics.

   for more information : https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort
*/

// Helper function to swap array items
function swap (arr, i, j) {
  const tmp = arr[i]
  arr[i] = arr[j]
  arr[j] = tmp
}

export function oddEvenSort (arr) {
  let sorted = false
  while (!sorted) {
    sorted = true
    for (let i = 1; i < arr.length - 1; i += 2) {
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1)
        sorted = false
      }
    }
    for (let i = 0; i < arr.length - 1; i += 2) {
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1)
        sorted = false
      }
    }
  }
  return arr
}

export function TopologicalSorter () {
  const graph = {}
  let isVisitedNode
  let finishTimeCount
  let finishingTimeList
  let nextNode

  this.addOrder = function (nodeA, nodeB) {
    nodeA = String(nodeA)
    nodeB = String(nodeB)
    graph[nodeA] = graph[nodeA] || []
    graph[nodeA].push(nodeB)
  }

  this.sortAndGetOrderedItems = function () {
    isVisitedNode = Object.create(null)
    finishTimeCount = 0
    finishingTimeList = []

    for (const node in graph) {
      if (Object.prototype.hasOwnProperty.call(graph, node) && !isVisitedNode[node]) {
        dfsTraverse(node)
      }
    }

    finishingTimeList.sort(function (item1, item2) {
      return item1.finishTime > item2.finishTime ? -1 : 1
    })

    return finishingTimeList.map(function (value) { return value.node })
  }

  function dfsTraverse (node) {
    isVisitedNode[node] = true
    if (graph[node]) {
      for (let i = 0; i < graph[node].length; i++) {
        nextNode = graph[node][i]
        if (isVisitedNode[nextNode]) continue
        dfsTraverse(nextNode)
      }
    }

    finishingTimeList.push({
      node,
      finishTime: ++finishTimeCount
    })
  }
}

/* TEST */
// const topoSorter = new TopologicalSorter()
// topoSorter.addOrder(5, 2)
// topoSorter.addOrder(5, 0)
// topoSorter.addOrder(4, 0)
// topoSorter.addOrder(4, 1)
// topoSorter.addOrder(2, 3)
// topoSorter.addOrder(3, 1)
// topoSorter.sortAndGetOrderedItems()
/**
 * Cycle sort is an in-place, unstable sorting algorithm,
 * a comparison sort that is theoretically optimal in terms of the total
 * number of writes to the original array, unlike any other in-place sorting
 * algorithm. It is based on the idea that the permutation to be sorted can
 * be factored into cycles, which can individually be rotated to give a sorted result.
 *
 * Wikipedia: https://en.wikipedia.org/wiki/Cycle_sort
 */

/**
 * cycleSort takes an input array of numbers and returns the array sorted in increasing order.
 *
 * @param {number[]} list An array of numbers to be sorted.
 * @return {number[]} An array of numbers sorted in increasing order.
 */
function cycleSort (list) {
  for (let cycleStart = 0; cycleStart < list.length; cycleStart++) {
    let value = list[cycleStart]
    let position = cycleStart

    // search position
    for (let i = cycleStart + 1; i < list.length; i++) {
      if (list[i] < value) {
        position++
      }
    }
    // if it is the same, continue
    if (position === cycleStart) {
      continue
    }
    while (value === list[position]) {
      position++
    }

    const oldValue = list[position]
    list[position] = value
    value = oldValue

    // rotate the rest
    while (position !== cycleStart) {
      position = cycleStart
      for (let i = cycleStart + 1; i < list.length; i++) {
        if (list[i] < value) {
          position++
        }
      }
      while (value === list[position]) {
        position++
      }
      const oldValueCycle = list[position]
      list[position] = value
      value = oldValueCycle
    }
  }
  return list
}

export { cycleSort }
/* In insertion sort, we divide the initial unsorted array into two parts;
 * sorted part and unsorted part. Initially the sorted part just has one
 * element (Array of only 1 element is a sorted array). We then pick up
 * element one by one from unsorted part; insert into the sorted part at
 * the correct position and expand sorted part one element at a time.
 */

export function insertionSort (unsortedList) {
  const len = unsortedList.length
  for (let i = 1; i < len; i++) {
    let j
    const tmp = unsortedList[i] // Copy of the current element.
    /* Check through the sorted part and compare with the number in tmp. If large, shift the number */
    for (j = i - 1; j >= 0 && (unsortedList[j] > tmp); j--) {
      // Shift the number
      unsortedList[j + 1] = unsortedList[j]
    }
    // Insert the copied number at the correct position
    // in sorted part.
    unsortedList[j + 1] = tmp
  }
}

/**
 * @function insertionSortAlternativeImplementation
 * @description InsertionSort is a stable sorting algorithm
 * @param {Integer[]} array - Array of integers
 * @return {Integer[]} - Sorted array
 * @see [InsertionSort](https://en.wikipedia.org/wiki/Quicksort)
 */

/*
  * Big-O Analysis
      * Time Complexity
        - O(N^2) on average and worst case scenario
        - O(N) on best case scenario (when input array is already almost sorted)
      * Space Complexity
        - O(1)
*/

export function insertionSortAlternativeImplementation (array) {
  const length = array.length
  if (length < 2) return array

  for (let i = 1; i < length; i++) {
    // Take current element in array
    const currentItem = array[i]
    // Take index of previous element in array
    let j = i - 1

    // While j >= 0 and previous element is greater than current element
    while (j >= 0 && array[j] > currentItem) {
      // Move previous, greater element towards the unsorted part
      array[j + 1] = array[j]
      j--
    }
    // Insert currentItem number at the correct position in sorted part.
    array[j + 1] = currentItem
  }
  // Return array sorted in ascending order
  return array
}
/* The selection sort algorithm sorts an array by repeatedly finding the minimum element
 *(considering ascending order) from unsorted part and putting it at the beginning. The
 *algorithm maintains two subarrays in a given array.
 *1) The subarray which is already sorted.
 *2) Remaining subarray which is unsorted.
 *
 *In every iteration of selection sort, the minimum element (considering ascending order)
 *from the unsorted subarray is picked and moved to the sorted subarray.
 */

export const selectionSort = (list) => {
  if (!Array.isArray(list)) {
    throw new TypeError('Given input is not an array')
  }
  const items = [...list] // We don't want to modify the original array
  const length = items.length
  for (let i = 0; i < length - 1; i++) {
    if (typeof items[i] !== 'number') {
      throw new TypeError('One of the items in your array is not a number')
    }
    // Number of passes
    let min = i // min holds the current minimum number position for each pass; i holds the Initial min number
    for (let j = i + 1; j < length; j++) { // Note that j = i + 1 as we only need to go through unsorted array
      if (items[j] < items[min]) { // Compare the numbers
        min = j // Change the current min number position if a smaller num is found
      }
    }
    if (min !== i) {
      // After each pass, if the current min num != initial min num, exchange the position.
      // Swap the numbers
      [items[i], items[min]] = [items[min], items[i]]
    }
  }
  return items
}
export const shuffle = (array) => {
  let maxLength = array.length
  let temp
  let idx

  // While there remain elements to shuffle...
  while (maxLength) {
    // Pick a remaining element...
    idx = Math.floor(Math.random() * maxLength--)

    // And swap it with the current element
    temp = array[maxLength]
    array[maxLength] = array[idx]
    array[idx] = temp
  }

  return array
}
/*
 * Wiggle sort sorts the array into a wave like array.
 * An array arr[0..n-1] is sorted in wave form if arr[0] <= arr[1] >= arr[2] <= arr[3] >= arr[4] <= ..
 * KEEP IN MIND: there are also more strict definitions of wiggle sort which use
 * the rule arr[0] < arr[1] > arr[2] < arr[3] > arr[4] <  but this function
 * allows for equality of values next to each other.
 */
import { quickSelectSearch } from '../Search/QuickSelectSearch.js'

export const simplifiedWiggleSort = function (arr) {
  // find Median using QuickSelect
  let median = quickSelectSearch(arr, Math.floor(arr.length / 2.0))
  median = median[Math.floor(arr.length / 2.0)]

  const sorted = new Array(arr.length)

  let smallerThanMedianIndx = 0
  let greaterThanMedianIndx = arr.length - 1 - (arr.length % 2)

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > median) {
      sorted[greaterThanMedianIndx] = arr[i]
      greaterThanMedianIndx -= 2
    } else {
      if (smallerThanMedianIndx < arr.length) {
        sorted[smallerThanMedianIndx] = arr[i]
        smallerThanMedianIndx += 2
      } else {
        sorted[greaterThanMedianIndx] = arr[i]
        greaterThanMedianIndx -= 2
      }
    }
  }

  return sorted
}
/**
 * Bead Sort, also known as Gravity sort.
 *
 * This algorithm was inspired from natural phenomena and was designed keeping in mind objects (or beads) falling under
 * the influence of gravity.
 *
 * NOTE: It only works for arrays of positive integers.
 *
 * Wikipedia: https://en.wikipedia.org/wiki/Bead_sort
 */
export function beadSort (sequence) {
  /* Let's ensure our sequence has only Positive Integers */
  if (sequence.some((integer) => integer < 0)) {
    throw RangeError('Sequence must be a list of Positive integers Only!')
  }

  const sequenceLength = sequence.length
  const max = Math.max(...sequence)

  // Set initial Grid
  const grid = sequence.map(number => {
    const maxArr = new Array(max)

    for (let i = 0; i < number; i++) {
      maxArr[i] = '*'
    }

    return maxArr
  })

  // Drop the Beads!
  for (let col = 0; col < max; col++) {
    let beadsCount = 0

    for (let row = 0; row < sequenceLength; row++) {
      if (grid[row][col] === '*') {
        beadsCount++
      }
    }

    for (let row = sequenceLength - 1; row > -1; row--) {
      if (beadsCount) {
        grid[row][col] = '*'
        beadsCount--
      } else {
        grid[row][col] = undefined
      }
    }
  }

  /* Finally, let's turn our Bead rows into their Respective Numbers */
  return grid.map((beadArray) => {
    const beadsArray = beadArray.filter(bead => bead === '*')
    return beadsArray.length
  })
}
let arrayLength = 0

/* to create MAX  array */

function heapRoot (input, i) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let max = i

  if (left < arrayLength && input[left] > input[max]) {
    max = left
  }

  if (right < arrayLength && input[right] > input[max]) {
    max = right
  }

  if (max !== i) {
    swap(input, i, max)
    heapRoot(input, max)
  }
}

function swap (input, indexA, indexB) {
  [input[indexA], input[indexB]] = [input[indexB], input[indexA]]
}

export function heapSort (input) {
  arrayLength = input.length

  for (let i = Math.floor(arrayLength / 2); i >= 0; i -= 1) {
    heapRoot(input, i)
  }

  for (let i = input.length - 1; i > 0; i--) {
    swap(input, 0, i)
    arrayLength--

    heapRoot(input, 0)
  }
  return input
}
/**
 * Cocktail Shaker Sort is an algorithm that is a Bidirectional Bubble Sort.
 *
 * The algorithm extends bubble sort by operating in two directions.
 * While it improves on bubble sort by more quickly moving items to the beginning of the list, it provides only marginal
 * performance improvements.
 *
 * Wikipedia (Cocktail Shaker Sort): https://en.wikipedia.org/wiki/Cocktail_shaker_sort
 * Wikipedia (Bubble Sort): https://en.wikipedia.org/wiki/Bubble_sort
 */
export function cocktailShakerSort (items) {
  for (let i = items.length - 1; i > 0; i--) {
    let j

    // Backwards
    for (j = items.length - 1; j > i; j--) {
      if (items[j] < items[j - 1]) {
        [items[j], items[j - 1]] = [items[j - 1], items[j]]
      }
    }

    // Forwards
    for (j = 0; j < i; j++) {
      if (items[j] > items[j + 1]) {
        [items[j], items[j + 1]] = [items[j + 1], items[j]]
      }
    }
  }

  return items
}
/* Bubble Sort is an algorithm to sort an array. It
*  compares adjacent element and swaps their position
*  The big O on bubble sort in worst and best case is O(N^2).
*  Not efficient.
*  Somehow if the array is sorted or nearly sorted then we can optimize bubble sort by adding a flag.
*
*  In bubble sort, we keep iterating while something was swapped in
*  the previous inner-loop iteration. By swapped I mean, in the
*  inner loop iteration, we check each number if the number proceeding
*  it is greater than itself, if so we swap them.
*
*  Wikipedia: https://en.wikipedia.org/wiki/Bubble_sort
*  Animated Visual: https://www.toptal.com/developers/sorting-algorithms/bubble-sort
*/

/**
 * Using 2 for loops.
 */
export function bubbleSort (items) {
  const length = items.length
  let noSwaps

  for (let i = length; i > 0; i--) {
    // flag for optimization
    noSwaps = true
    // Number of passes
    for (let j = 0; j < (i - 1); j++) {
      // Compare the adjacent positions
      if (items[j] > items[j + 1]) {
        // Swap the numbers
        [items[j], items[j + 1]] = [items[j + 1], items[j]]
        noSwaps = false
      }
    }
    if (noSwaps) {
      break
    }
  }

  return items
}

/**
 * Using a while loop and a for loop.
 */
export function alternativeBubbleSort (arr) {
  let swapped = true

  while (swapped) {
    swapped = false
    for (let i = 0; i < arr.length - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]
        swapped = true
      }
    }
  }

  return arr
}
/*
 * MergeSort implementation.
 *
 * Merge Sort is an algorithm where the main list is divided down into two half sized lists, which then have merge sort
 * called on these two smaller lists recursively until there is only a sorted list of one.
 *
 * On the way up the recursive calls, the lists will be merged together inserting
 * the smaller value first, creating a larger sorted list.
 */

/**
 * Sort and merge two given arrays.
 *
 * @param {Array} list1 Sublist to break down.
 * @param {Array} list2 Sublist to break down.
 * @return {Array} The merged list.
 */
export function merge (list1, list2) {
  const results = []
  let i = 0
  let j = 0

  while (i < list1.length && j < list2.length) {
    if (list1[i] < list2[j]) {
      results.push(list1[i++])
    } else {
      results.push(list2[j++])
    }
  }

  return results.concat(list1.slice(i), list2.slice(j))
}

/**
 * Break down the lists into smaller pieces to be merged.
 *
 * @param {Array} list List to be sorted.
 * @return {Array} The sorted list.
 */
export function mergeSort (list) {
  if (list.length < 2) return list

  const listHalf = Math.floor(list.length / 2)
  const subList1 = list.slice(0, listHalf)
  const subList2 = list.slice(listHalf, list.length)

  return merge(mergeSort(subList1), mergeSort(subList2))
}
/**
 * BucketSort implementation.
 *
 * Wikipedia says: Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array
 * into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by
 * recursively applying the bucket sorting algorithm. It is a distribution sort, and is a cousin of radix sort in the
 * most to least significant digit flavour. Bucket sort is a generalization of pigeonhole sort. Bucket sort can be
 * implemented with comparisons and therefore can also be considered a comparison sort algorithm. The computational
 * complexity estimates involve the number of buckets.
 *
 * @see https://en.wikipedia.org/wiki/Bucket_sort#:~:text=Bucket%20sort%2C%20or%20bin%20sort,applying%20the%20bucket%20sorting%20algorithm.&text=Sort%20each%20non%2Dempty%20bucket.
 *
 * Time Complexity of Solution:
 * Best Case O(n); Average Case O(n); Worst Case O(n)
 *
 * @param {number[]} list The array of numbers to be sorted.
 * @param {number} size The size of the buckets used. If not provided, size will be 5.
 * @return {number[]} An array of numbers sorted in increasing order.
 */
export function bucketSort (list, size) {
  if (undefined === size) {
    size = 5
  }
  if (list.length === 0) {
    return list
  }
  let min = list[0]
  let max = list[0]
  // find min and max
  for (let iList = 0; iList < list.length; iList++) {
    if (list[iList] < min) {
      min = list[iList]
    } else if (list[iList] > max) {
      max = list[iList]
    }
  }
  // how many buckets we need
  const count = Math.floor((max - min) / size) + 1

  // create buckets
  const buckets = []
  for (let iCount = 0; iCount < count; iCount++) {
    buckets.push([])
  }

  // bucket fill
  for (let iBucket = 0; iBucket < list.length; iBucket++) {
    const key = Math.floor((list[iBucket] - min) / size)
    buckets[key].push(list[iBucket])
  }
  const sorted = []
  // now sort every bucket and merge it to the sorted list
  for (let iBucket = 0; iBucket < buckets.length; iBucket++) {
    const arr = buckets[iBucket].sort((a, b) => a - b)
    for (let iSorted = 0; iSorted < arr.length; iSorted++) {
      sorted.push(arr[iSorted])
    }
  }
  return sorted
}
/*
 * Shell Sort sorts an array based on  insertion sort algorithm
 * more information: https://en.wikipedia.org/wiki/Shellsort
 *
 */
export function shellSort (items) {
  let interval = 1

  while (interval < items.length / 3) {
    interval = interval * 3 + 1
  }

  while (interval > 0) {
    for (let outer = interval; outer < items.length; outer++) {
      const value = items[outer]
      let inner = outer

      while (inner > interval - 1 && items[inner - interval] >= value) {
        items[inner] = items[inner - interval]
        inner = inner - interval
      }
      items[inner] = value
    }
    interval = (interval - 1) / 3
  }
  return items
}
/*
  https://en.wikipedia.org/wiki/Natural_sort_order

  In computing, natural sort order (or natural sorting) is the ordering of strings in alphabetical order,
  except that multi-digit numbers are treated atomically, i.e., as if they were a single character. Natural sort order
  has been promoted as being more human-friendly ("natural") than machine-oriented, pure alphabetical sort order.[1]

  For example, in alphabetical sorting, "z11" would be sorted before "z2" because the "1" in the first string is sorted as smaller
  than "2", while in natural sorting "z2" is sorted before "z11" because "2" is treated as smaller than "11".

  Alphabetical sorting:
  1.z11
  2.z2

  Natural sorting:
  1. z2
  2. z11

  P.S. use this function, as there are a lot of implementations on the stackoverflow and other forums, but many of them don't work correctly (can't pass all my tests)

*/

const alphaNumericalSort = (a, b) => {
  /*
    https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare

    The localeCompare() method returns a number indicating whether a reference string comes before, or after, or is the same as the given string in sort order.

    The new locales and options arguments let applications specify the language whose sort order should be used and customize the behavior of the function.
    In older implementations, which ignore the locales and options arguments, the locale and sort order used are entirely implementation-dependent.
    Syntax:
    localeCompare(compareString, locales, options)

  */
  return a.localeCompare(b, undefined, { numeric: true })
}

export { alphaNumericalSort }
/**
  *  @function Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort,
  *  designed to perform well on many kinds of real-world data.
  *  It was implemented by Tim Peters in 2002 for use in the Python programming language.
  *  It is also used to sort arrays of non-primitive type in Java SE 7,
  *  on the Android platform, in GNU Octave, on V8, Swift and Rust.
  *  1) It sorts small partitions using Insertion Sort.
  *  2) Merges the partition using Merge Sort.
  *  @see [Timsort](https://en.wikipedia.org/wiki/Timsort)
  *  @param {Array} array
  */

const Timsort = (array) => {
  // Default size of a partition
  const RUN = 32
  const n = array.length
  // Sorting the partitions using Insertion Sort
  for (let i = 0; i < n; i += RUN) {
    InsertionSort(array, i, Math.min(i + RUN - 1, n - 1))
  }
  for (let size = RUN; size < n; size *= 2) {
    for (let left = 0; left < n; left += 2 * size) {
      const mid = left + size - 1
      const right = Math.min(left + 2 * size - 1, n - 1)
      Merge(array, left, mid, right)
    }
  }
  return array
}

/**
 * @function performs insertion sort on the partition
 * @param {Array} array array to be sorted
 * @param {Number} left left index of partition
 * @param {Number} right right index of partition
 */

const InsertionSort = (array, left, right) => {
  for (let i = left + 1; i <= right; i++) {
    const key = array[i]
    let j = i - 1
    while (j >= left && array[j] > key) {
      array[j + 1] = array[j]
      j--
    }
    array[j + 1] = key
  }
}

/**
 * @function merges two sorted partitions
 * @param {Array} array array to be sorted
 * @param {Number} left left index of partition
 * @param {Number} mid mid index of partition
 * @param {Number} right right index of partition
 */

const Merge = (array, left, mid, right) => {
  if (mid >= right) return
  const len1 = mid - left + 1
  const len2 = right - mid
  const larr = Array(len1)
  const rarr = Array(len2)
  for (let i = 0; i < len1; i++) {
    larr[i] = array[left + i]
  }
  for (let i = 0; i < len2; i++) {
    rarr[i] = array[mid + 1 + i]
  }
  let i = 0; let j = 0; let k = left
  while (i < larr.length && j < rarr.length) {
    if (larr[i] < rarr[j]) {
      array[k++] = larr[i++]
    } else {
      array[k++] = rarr[j++]
    }
  }
  while (i < larr.length) {
    array[k++] = larr[i++]
  }
  while (j < rarr.length) {
    array[k++] = rarr[j++]
  }
}

/**
 * @example Test of Timsort functions.
 * Data is randomly generated.
 * Return "RIGHT" if it works as expected,
 * otherwise "FAULTY"
 */
const demo = () => {
  const size = 1000000
  const data = Array(size)
  for (let i = 0; i < size; i++) {
    data[i] = Math.random() * Number.MAX_SAFE_INTEGER
  }
  const isSorted = function (array) {
    const n = array.length
    for (let i = 0; i < n - 1; i++) {
      if (array[i] > array[i + 1]) return false
    }
    return true
  }
  Timsort(data)
  if (isSorted(data)) {
    return 'RIGHT'
  } else {
    return 'FAULTY'
  }
}

export { Timsort, demo }
/*
 * Unlike a traditional sorting algorithm, which attempts to sort with the fewest
 * comparisons possible, the goal of pancake sort is to sort the sequence in as few reversals as
 * possible. The idea is to do something similar to Selection Sort. We one by one place
 * maximum element at the end and reduce the size of current array by one.
 *
 * Source: https://www.geeksforgeeks.org/pancake-sorting/
 *
 * This sorting algorithm is inspired by the pancake problem (hence the name),
 * where a spatula can be placed anywhere between two pancakes and flip all pancakes
 * above.
 *
 * The interesting about this algorithm (besides its name) is that instead of comparisons,
 * the algorithm relies on flipping an array.
 *
 * Source: https://en.wikipedia.org/wiki/Pancake_sorting#The_original_pancake_problem
 *
 */

/**
 * Unlike Array.prototype.reverse, flipArray reverses only a subarray of the given
 * array, determined by the parameters startIndex and endIndex
 *
 * @param {number[]} array The array to flip
 * @param {number} startIndex The start of the subarray
 * @param {number} endIndex The end of the subarray
 * @returns The flipped array
 */
export function flipArray (array, startIndex, endIndex) {
  while (startIndex < endIndex) {
    // swap front and back of the subarray
    const temp = array[startIndex]
    array[startIndex] = array[endIndex]
    array[endIndex] = temp

    // essentially reducing the problem to a smaller subarray
    startIndex++
    endIndex--
  }

  return array
}

/**
 * Returns the index of the maximum number of a subarray in a given array
 *
 * @param {number[]} array The array to found the maximum number's index
 * @param {*} startIndex The start of the subarray
 * @param {*} endIndex The end of the subarray
 * @returns The index of the maximum number
 */
export function findMax (array, startIndex, endIndex) {
  let maxIndex = 0
  for (let i = startIndex; i <= endIndex; i++) {
    if (array[i] > array[maxIndex]) maxIndex = i
  }

  return maxIndex
}

/**
 * The Pancake Sort algorithm.
 *
 * Note that even though it's a completely different concept of sorting an
 * array, it's rather simple!
 *
 * @param {number[]} array The array to sort
 * @returns The sorted array
 */
export function pancakeSort (array) {
  for (let subarraySize = array.length; subarraySize > 1; subarraySize--) {
    const maximumIndex = findMax(array, 0, subarraySize - 1)

    if (maximumIndex !== subarraySize - 1) {
      flipArray(array, 0, maximumIndex)
      flipArray(array, 0, subarraySize - 1)
    }
  }

  return array
}
/*
 * Build a max heap out of the array. A heap is a specialized tree like
 * data structure that satisfies the heap property. The heap property
 * for max heap is the following: "if P is a parent node of C, then the
 * key (the value) of node P is greater than the key of node C"
 * Source: https://en.wikipedia.org/wiki/Heap_(data_structure)
 */
/* eslint no-extend-native: ["off", { "exceptions": ["Object"] }] */
Array.prototype.heapify = function (index, heapSize) {
  let largest = index
  const leftIndex = 2 * index + 1
  const rightIndex = 2 * index + 2

  if (leftIndex < heapSize && this[leftIndex] > this[largest]) {
    largest = leftIndex
  }

  if (rightIndex < heapSize && this[rightIndex] > this[largest]) {
    largest = rightIndex
  }

  if (largest !== index) {
    const temp = this[largest]
    this[largest] = this[index]
    this[index] = temp

    this.heapify(largest, heapSize)
  }
}

/*
 * Heap sort sorts an array by building a heap from the array and
 * utilizing the heap property.
 * For more information see: https://en.wikipedia.org/wiki/Heapsort
 */
export function heapSort (items) {
  const length = items.length

  for (let i = Math.floor(length / 2) - 1; i > -1; i--) {
    items.heapify(i, length)
  }
  for (let j = length - 1; j > 0; j--) {
    const tmp = items[0]
    items[0] = items[j]
    items[j] = tmp
    items.heapify(0, j)
  }
  return items
}

// Implementation of heapSort

// const ar = [5, 6, 7, 8, 1, 2, 12, 14]
// heapSort(ar)
/**
 * Checks whether the given array is sorted in ascending order.
 */
export function isSorted (array) {
  const length = array.length
  for (let i = 0; i < length - 1; i++) {
    if (array[i] > array[i + 1]) {
      return false
    }
  }
  return true
}

/**
 * Shuffles the given array randomly in place.
 */
function shuffle (array) {
  for (let i = array.length - 1; i; i--) {
    const m = Math.floor(Math.random() * i)
    const n = array[i - 1]
    array[i - 1] = array[m]
    array[m] = n
  }
}

/**
 * Implementation of the bogosort algorithm.
 *
 * This sorting algorithm randomly rearranges the array until it is sorted.
 *
 * For more information see: https://en.wikipedia.org/wiki/Bogosort
 */
export function bogoSort (items) {
  while (!isSorted(items)) {
    shuffle(items)
  }
  return items
}
/*
 * Stooge Sort sorts an array based on divide and conquer principle
 * note the exceptionally bad time complexity
 * more information: https://en.wikipedia.org/wiki/Stooge_sort
 *
 */
export function stoogeSort (items, leftEnd, rightEnd) {
  if (items[rightEnd - 1] < items[leftEnd]) {
    const temp = items[leftEnd]
    items[leftEnd] = items[rightEnd - 1]
    items[rightEnd - 1] = temp
  }
  const length = rightEnd - leftEnd
  if (length > 2) {
    const third = Math.floor(length / 3)
    stoogeSort(items, leftEnd, rightEnd - third)
    stoogeSort(items, leftEnd + third, rightEnd)
    stoogeSort(items, leftEnd, rightEnd - third)
  }
  return items
}
